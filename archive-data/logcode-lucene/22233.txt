GitDiffStart: d7bd3f981a442efa2ba9744fa54bb2e9524f9224 | Tue Sep 25 19:01:11 2007 +0000
diff --git a/client/ruby/flare/vendor/plugins/engines/CHANGELOG b/client/ruby/flare/vendor/plugins/engines/CHANGELOG
new file mode 100644
index 0000000..05a0e1a
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/CHANGELOG
@@ -0,0 +1,241 @@
+= 1.2.0 - MASSIVE INTERNAL REFACTORING
+
+
+* !!!Support for Rails < 1.2 has been dropped!!!; if you are using Rails =< 1.1.6, please use Engines 1.1.6, available from http://svn.rails-engines.org/engines/tags/rel_1.1.6
+
+* Engines are dead! Long live plugins! There is now no meaningful notion of an engine - all plugins can take advantage of the more powerful features that the engines plugin provides by including app directories, etc.
+
+* Init_engine.rb is no longer used; please use the plugin-standard init.rb instead.
+
+* Engines.start is no longer required; please use the config.plugins array provided by Rails instead
+
+* To get the most benefit from Engines, set config.plugins to ["engines", "*"] to load the engines plugin first, and then all other plugins in their normal order after.
+
+* Access all loaded plugins via the new Rails.plugins array, and by name using Rails.plugins[:plugin_name].
+
+* Access plugin metadata loaded automatically from about.yml: Rails.plugins[:name].about. Plugin#version is provided directly, for easy access.
+
+* Module.config is has been removed - use mattr_accessor instead, and initialize your default values via the init.rb mechanism.
+
+* Public asset helpers have been rewritten; instead of engine_stylesheet, now use stylesheet_link_tag :name, :plugin => "plugin_name"
+
+* Plugin migrations have been reworked to integrate into the main migration stream. Please run script/generate plugin_migration to create plugin migrations in your main application.
+
+* The fixture method for loading fixtures against any class has been removed; instead, engines will now provide a mechanism for loading fixtures from all plugins, by mirroring fixtures into a common location.
+
+* All references to engines have been removed; For example, any rake tasks which applied to engines now apply to all plugins. The default Rails rake tasks for plugins are overridden where necessary.
+
+* Layouts can now be shared via plugins - inspiration gratefully taken from PluginAWeek's plugin_routing :)
+
+* Actual routing from plugins is now possible, by including routes.rb in your plugin directory and using the from_plugin method in config/routes.rb (Ticket #182)
+
+* Controllers are no longer loaded twice if they're not present in the normal app/ directory (Ticket #177)
+
+* The preferred location for javascripts/stylesheets/etc is now 'assets' rather than 'public'
+
+* Ensure that plugins started before routing have their controllers appropriately added to config.controller_paths (Ticket #258)
+
+* Removed Engines.version - it's not longer relevant, now we're loading version information from about.yml files.
+
+* Added a huge amount of documentation to all new modules.
+
+* Added new warning message if installation of engines 1.2.x is attempted in a Rails 1.1.x application
+
+* Added details of the removal of the config method to UPGRADING
+
+* Removed the plugins:info rake task in favour of adding information to script/about via the Rails::Info module (Ticket #261)
+
+* Improved handling of testing and documentation tasks for plugins
+
+
+
+= 1.1.4
+
+* Fixed creation of multipart emails (Ticket #190)
+
+* Added a temporary fix to the code-mixing issue. In your engine's test/test_helper.rb, please add the following lines:
+
+   # Ensure that the code mixing and view loading from the application is disabled
+   Engines.disable_app_views_loading = true
+   Engines.disable_app_code_mixing = true
+
+  which will prevent code mixing for controllers and helpers, and loading views from the application. One thing to remember is to load any controllers/helpers using 'require_or_load' in your tests, to ensure that the engine behaviour is respected (Ticket #135)
+
+* Added tasks to easily test engines individually (Ticket #120)
+
+* Fixture extensions will now fail with an exception if the corresponding class cannot be loaded (Ticket #138)
+
+* Patch for new routing/controller loading in Rails 1.1.6. The routing code is now replaced with the contents of config.controller_paths, along with controller paths from any started engines (Ticket #196)
+
+* Rails' Configuration instance is now stored, and available from all engines and plugins.
+
+
+
+= 1.1.3
+
+* Fixed README to show 'models' rather than 'model' class (Ticket #167)
+* Fixed dependency loading to work with Rails 1.1.4 (Ticket #180)
+
+
+
+= 1.1.2
+
+* Added better fix to version checking (Ticket #130, jdell@gbdev.com).
+
+* Fixed generated init_engine.rb so that VERSION module doesn't cause probems (Ticket #131, japgolly@gmail.com)
+
+* Fixed error with Rails 1.0 when trying to ignore the engine_schema_info table (Ticket #132, snowblink@gmail.com)
+
+* Re-added old style rake tasks (Ticket #133)
+
+* No longer adding all subdirectories of <engine>/app or <engine>/lib, as this can cause issues when files are grouped in modules (Ticket #149, kasatani@gmail.com)
+
+* Fixed engine precidence ordering for Rails 1.1 (Ticket #146)
+
+* Added new Engines.each method to assist in processing the engines in the desired order (Ticket #146)
+
+* Fixed annoying error message at appears when starting the console in development mode (Ticket #134)
+
+* Engines is now super-careful about loading the correct version of Rails from vendor (Ticket #154)
+
+
+
+= 1.1.1
+
+* Fixed migration rake task failing when given a specific version (Ticket #115)
+
+* Added new rake task "test:engines" which will test engines (and other plugins) but ensure that the test database is cloned from development beforehand (Ticket #125)
+
+* Fixed issue where 'engine_schema_info' table was included in schema dumps (Ticket #87)
+
+* Fixed multi-part emails (Ticket #121)
+
+* Added an 'install.rb' file to new engines created by the bundled generator, which installs the engines plugin automatically if it doesn't already exist (Ticket #122)
+
+* Added a default VERSION module to generated engines (Ticket #123)
+
+* Refactored copying of engine's public files to a method of an Engine instance. You can now call Engines.get(:engine_name).copy_public_files (Ticket #108)
+
+* Changed engine generator templates from .rb files to .erb files (Ticket #106)
+
+* Fixed the test_helper.erb file to use the correct testing extensions and not load any schema - the schema will be cloned automatically via rake test:engines
+
+* Fixed problem when running with Rails 1.1.1 where version wasn't determined correctly (Ticket #129)
+
+* Fixed bug preventing engines from loading when both Rails 1.1.0 and 1.1.1 gems are installed and in use.
+
+* Updated version (d'oh!)
+
+
+
+= 1.1.0
+
+* Improved regexp matching for Rails 1.0 engines with peculiar paths
+
+* Engine instance objects can be accessed via Engines[:name], an alias for Engines.get(:name) (Ticket #99)
+
+* init_engine.rb is now processed as the final step in the Engine.start process, so it can access files within the lib directory, which is now in the $LOAD_PATH at that point. (Ticket #99)
+
+* Clarified MIT license (Ticket #98)
+
+* Updated Rake tasks to integrate smoothly with Rails 1.1 namespaces
+
+* Changed the version to "1.1.0 (svn)"
+
+* Added more information about using the plugin with Edge Rails to the README
+
+* moved extensions into lib/engines/ directory to enable use of Engines module in extension code.
+
+* Added conditional require_or_load method which attempts to detect the current Rails version. To use the Edge Rails version of the loading mechanism, add the line:
+
+*   Engines.config :edge, true
+
+* to your environment.rb file.
+
+* Merged changes from /branches/edge and /branches/rb_1.0 into /trunk
+
+* engine_schema_info now respects the prefix/suffixes set for ActiveRecord::Base (Ticket #67)
+
+* added ActiveRecord::Base.wrapped_table_name(name) method to assist in determining the correct table name
+
+
+
+= 1.0.6
+
+* Added ability to determine version information for engines: rake engine_info
+
+* Added a custom logger for the Engines module, to stop pollution of the Rails logs.
+
+* Added some more tests (in particular, see rails_engines/applications/engines_test).
+
+* Another attempt at solving Ticket #53 - controllers and helpers should now be loadable from modules, and if a full path (including RAILS_ROOT/ENGINES_ROOT) is given, it should be safely stripped from the require filename such that corresponding files can be located in any active engines. In other words, controller/helper overloading should now completely work, even if the controllers/helpers are in modules.
+
+* Added (finally) patch from Ticket #22 - ActionMailer helpers should now load
+
+* Removed support for Engines.start :engine, :engine_name => 'whatever'. It was pointless.
+
+* Fixed engine name referencing; engine_stylesheet/engine_javascript can now happily use shorthand engine names (i.e. :test == :test_engine) (Ticket #45)
+
+* Fixed minor documentation error ('Engine.start' ==> 'Engines.start') (Ticket #57)
+
+* Fixed double inclusion of RAILS_ROOT in engine_migrate rake task (Ticket #61)
+
+* Added ability to force config values even if given as a hash (Ticket #62)
+
+
+
+= 1.0.5
+
+* Fixed bug stopping fixtures from loading with PostgreSQL
+
+
+
+= 1.0.4
+
+* Another attempt at loading controllers within modules (Ticket #56)
+
+
+
+= 1.0.3
+
+* Fixed serious dependency bug stopping controllers being loaded (Ticket #56)
+
+
+
+= 1.0.2
+
+* Fixed bug with overloading controllers in modules from /app directory
+
+* Fixed exception thrown when public files couldn't be created; exception is now logged (Ticket #52)
+
+* Fixed problem with generated test_helper.rb file via File.expand_path (Ticket #50)
+
+
+
+= 1.0.1
+
+* Added engine generator for creation of new engines
+
+* Fixed 'Engine' typo in README
+
+* Fixed bug in fixtures extensions
+
+* Fixed /lib path management bug
+
+* Added method to determine public directory location from Engine object
+
+* Fixed bug in the error message in get_engine_dir()
+
+* Added proper component loading
+
+* Added preliminary tests for the config() methods module
+
+
+
+= pre-v170
+
+* Fixed copyright notices to point to DHH, rather than me.
+
+* Moved extension require statements into lib/engines.rb, so the will be loaded if another module/file calls require 'engines
+
+* Added a CHANGELOG file (this file)
diff --git a/client/ruby/flare/vendor/plugins/engines/MIT-LICENSE b/client/ruby/flare/vendor/plugins/engines/MIT-LICENSE
new file mode 100644
index 0000000..17a3b22b
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/MIT-LICENSE
@@ -0,0 +1,21 @@
+Copyright (c) 2007 James Adam
+
+The MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/README b/client/ruby/flare/vendor/plugins/engines/README
new file mode 100644
index 0000000..415e97f
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/README
@@ -0,0 +1,64 @@
+The engines plugin enhances Rails' own plugin framework, making it simple to share controllers, helpers, models, public assets, routes and migrations in plugins.
+
+For more information, see http://rails-engines.org
+
+= Using the plugin
+
+With engines 1.2, no extra configuration in environment.rb is required. Having the plugin installed will automatically enable sharing of code within <tt>plugin/app/</tt> directories. Developers should be aware that the <tt>config.plugins</tt> parameter can be used to control plugin load order, if this is important for your application.
+
+=== config.plugins
+
+With Rails 1.2, the <tt>config.plugins</tt> list can be used to specify the order in which plugins are loaded. It's recommended (although not required) that you load the engines plugin first, and any other plugins later. The engines plugin enhances Rails' processing of <tt>config.plugins</tt> for occasions where you only care about the order of a small selection of your application's plugins. For instance, if you want to load +engines+ first, and anything else afterwards, then
+
+  config.plugins = ["engines", "*"]
+  
+will ensure that engines is loaded first, and everything else (in whatever order Rails chooses) afterwards.
+
+== Better plugins
+
+In addition to the regular set of plugin-supported files (lib, init.rb, tasks, generators, tests), plugins can carry the following when the engines plugin is also installed.
+
+
+=== Controllers, Helpers, and Views
+
+Include these files in an <tt>app</tt> directory just like you would in a normal Rails application. If you need to override a method, view or partial, create the corresponding file in your main <tt>app</tt> directory and it will be used instead.
+
+* Controllers & Helpers: See Engines::RailsExtensions::Dependencies for more information.
+* Views: See Engines::RailsExtensions::Templates for more information.
+
+=== Models
+
+Model code can similarly be placed in an <tt>app/models/</tt> directory. Unfortunately, it's not possible to automatically override methods within a model; if your application needs to change the way a model behaves, consider creating a subclass, or replacing the model entirely within your application's <tt>app/models/</tt> directory. See Engines::RailsExtensions::Dependencies for more information.
+
+IMPORTANT NOTE: when you load code from within plugins, it is typically not handled well by Rails in terms of unloading and reloading changes. Look here for more information - http://rails-engines.org/development/common-issues-when-overloading-code-from-plugins/
+
+=== Routes
+
+Include your route declarations in a <tt>routes.rb</tt> file at the root of your plugins, e.g.:
+
+  connect "/my/url", :controller => "some_controller"
+  my_named_route "do_stuff", :controller => "blah", :action => "stuff"
+  # etc.
+  
+You can then load these files into your application by declaring their inclusion in the application's <tt>config/routes.rb</tt>:
+
+  map.from_plugin :plugin_name
+
+See Engines::RailsExtensions::Routing for more information.
+  
+=== Migrations
+
+Migrations record the changes in your database as your application evolves. With engines 1.2, migrations from plugins can also join in this evolution as first-class entities. To add migrations to a plugin, include a <tt>db/migrate/</tt> folder and add migrations there as normal. These migrations can then be integrated into the main flow of database evolution by running the plugin_migration generator:
+
+  script/generate plugin_migration
+  
+This will produce a migration in your application. Running this migration (via <tt>rake db:migrate</tt>, as normal) will migrate the database according to the latest migrations in each plugin. See Engines::RailsExtensions::Migrations for more information.
+
+
+=== More powerful Rake tasks
+
+The engines plugin enhances and adds to the suite of default rake tasks for working with plugins. The <tt>doc:plugins</tt> task now includes controllers, helpers and models under <tt>app</tt>, and anything other code found under the plugin's <tt>code_paths</tt> attribute. New testing tasks have been added to run unit, functional and integration tests from plugins, whilst making it easier to load fixtures from plugins. See Engines::Testing for more details about testing, and run
+
+  rake -T
+  
+to see the set of rake tasks available.
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/Rakefile b/client/ruby/flare/vendor/plugins/engines/Rakefile
new file mode 100644
index 0000000..3c346c8
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/Rakefile
@@ -0,0 +1,32 @@
+require 'rake'
+require 'rake/rdoctask'
+require 'tmpdir'
+
+task :default => :doc
+
+desc 'Generate documentation for the engines plugin.'
+Rake::RDocTask.new(:doc) do |doc|
+  doc.rdoc_dir = 'doc'
+  doc.title    = 'Engines'
+  doc.main     = "README"
+  doc.rdoc_files.include("README", "UPGRADING", "CHANGELOG", "MIT-LICENSE")
+  doc.rdoc_files.include('lib/**/*.rb')
+  doc.options << '--line-numbers' << '--inline-source'
+end
+
+desc 'Run the engine plugin tests within their test harness'
+task :cruise do
+  # checkout the project into a temporary directory
+  version = "rails_1.2"
+  test_dir = "#{Dir.tmpdir}/engines_plugin_#{version}_test"
+  puts "Checking out test harness for #{version} into #{test_dir}"
+  `svn co http://svn.rails-engines.org/test/engines/#{version} #{test_dir}`
+
+  # run all the tests in this project
+  Dir.chdir(test_dir)
+  load 'Rakefile'
+  puts "Running all tests in test harness"
+  ['db:migrate', 'test', 'test:plugins'].each do |t|
+    Rake::Task[t].invoke
+  end  
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/UPGRADING b/client/ruby/flare/vendor/plugins/engines/UPGRADING
new file mode 100644
index 0000000..af3debd
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/UPGRADING
@@ -0,0 +1,93 @@
+= Upgrading from Engines 1.1.x to Engines 1.2.x
+
+
+The 1.2 release of the engines plugin represents a significant rewrite of the internals. Now less intrusive into the core frameworks, it's even simpler for plugin developers to make more flexible plugins than Rails typically allows.
+
+However, as a consequence of change, you may need to make some adjustments to your application to get the most benefit. These are outlined below:
+
+
+== In your application
+
+The following changes will affect code in applications which use the engines plugin
+
+=== Change the engine_schema table to plugin_schema
+
+Because the engines plugin now works universally for any Rails plugin, the table used to store migration information has been renamed appropriately. We can also play nicely with other plugin_migration implementations by supporting this convention.
+
+
+=== Rename RAILS_ROOT/public/engine_files to RAILS_ROOT/public/plugin_assets
+
+Similarly, any plugin can now share stylesheets, images and so on via an assets folder, so the destination within the main public directory has been renamed to reflect this. You can simply delete the RAILS_ROOT/public/engine_files directory; the new one will be generated the next time your application starts.
+
+
+=== The engine_image, engine_stylesheet and engine_javascript helpers have been replaced with enhanced versions of the normal Rails asset helpers
+
+Now, it's simple to include an image from any plugin, by adding a plugin key to the helper's options hash:
+
+  image_tag "image.png", :plugin => "my_plugin"
+
+A similar convention exists for stylesheets and javascript files. Additionally, the old behaviour of automatically including assets which match the "engine"'s name has been dropped - only the files you explicitly request are included.
+
+
+=== Engines.start is replaced with config.plugins
+
+Rails' native configuration object now includes an array for specifying which plugins are loaded, and in what order. The engines plugin enhances this feature with a "*" wildcard, so that you can load any order-sensitive plugins, and then the rest in any order.
+
+  config.plugins = ["engines", "some_plugin", "another_plugin", "*"]
+  
+It's worth noting that the engines plugin no longer needs to be specifically loaded first, so most people can happily ignore the config.plugins array without any problems.
+
+
+=== The "config" method for "engine"-style configuration is no longer loaded by default. 
+
+See below.
+  
+  
+=== Any "engines" type rake tasks are now "plugin" tasks.
+
+The following rake tasks are now provided by the engines plugin for operating on your application's plugins (whenever a task can operate on a single plugin, this can be controlled by specifying PLUGIN=<name> on the commandline):
+  
+  db:fixtures:plugins:load  # load fixtures from plugins. 
+  
+  test:plugins:units        # Run tests from within <plugins>/test/units
+  test:plugins:functional   # Run tests from within <plugins>/test/functional
+  test:plugins:integration  # Run tests from within <plugins>/test/integration
+  test:plugins              # Run all tests from within <plugins>/test/*
+
+  doc:plugins               # Run full rdoc against all source files within all plugins
+  doc:plugins:<plugin>      # Run full rdoc against all source files within the given plugin
+
+
+
+== In your "engine"-style plugins
+
+If you have developed or are using plugins that leverage engines enhancements, you need to be aware of the following changes in engines 1.2.
+
+=== init_engine.rb is no longer required
+
+Please now create init.rb files, just as you'd find in "normal" plugins. Remember - there's no such thing as "an engine" anymore.
+
+
+=== The "fixture" method for loading tests from arbitrary files
+
+Supporting this was just too difficult, and it seems like the combination of Rails' own lack of enhancements regarding this feature, along with the mind-shift against static fixtures, meant that it simply was too much work to continue to support.
+
+The only reason this mechanism originally existed was to support plugins which couldn't predict the names of the tables that models might be stored in. This is now a discouraged behaviour.
+
+
+=== Engines.current.version has changed its behaviour slightly.
+
+The engines plugin used to provide a simple way to store version information about plugins. This has now been superceded by including that information in an about.yml file, which any plugin can use.
+
+
+=== The "config" method is not included, by default.
+
+Where previously developers could use the "config" method to define configuration, this is now deprecated in favour of using mattr_accessor directly in the Module. However, if you still *need* to use the config method, it is included but must be explicitly required, probably near the top of environment.rb:
+  
+  require File.join(RAILS_ROOT, "vendor", "plugins", "engines",
+                    "lib", "engines", "deprecated_config_support")
+
+
+=== Public assets should now be stored in a subdirectory of your plugin called "assets", rather than "public".
+
+This clarifies the nature of this directory; it is not made public itself, but rather is a container for files which should be made accessible from the web.
diff --git a/client/ruby/flare/vendor/plugins/engines/about.yml b/client/ruby/flare/vendor/plugins/engines/about.yml
new file mode 100644
index 0000000..aee53e2
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/about.yml
@@ -0,0 +1,7 @@
+author: James Adam
+email: james.adam@gmail.com
+homepage: http://www.rails-engines.org
+summary: Enhances the plugin mechanism to perform more flexible sharing
+description: The Rails Engines plugin allows the sharing of almost any type of code or asset that you could use in a Rails application, including controllers, models, stylesheets, and views.
+license: MIT
+version: 1.2.0
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/USAGE b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/USAGE
new file mode 100644
index 0000000..ac39b50
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/USAGE
@@ -0,0 +1,45 @@
+Description:
+  The plugin migration generator assists in working with schema additions 
+  required by plugins. Instead of running migrations from plugins directly,
+  the generator creates a regular Rails migration which will be responsible
+  for migrating the plugins from their current version to the latest version
+  installed.
+  
+  This is important because the set of application migrations remains an
+  accurate record of the state of the database, even as plugins are installed
+  and removed during the development process.
+
+Example:
+  ./script/generate plugin_migration [<plugin_name> <another_plugin_name> ...]
+
+  This will generate:
+
+    RAILS_ROOT
+      |- db
+          |-migrate
+              |- xxx_plugin_migrations.rb
+
+  which contains the migrations for the given plugin(s).
+  
+  
+Advanced Usage:
+
+There may be situations where you need *complete* control over the migrations
+of plugins in your application, migrating a certainly plugin down to X, and
+another plugin up to Y, where neither X or Y are the latest migrations for those
+plugins.
+
+For those unfortunate few, I have two pieces of advice:
+
+ 1. Why? This is a code smell [http://c2.com/xp/CodeSmell.html].
+ 
+ 2. Well, OK. Don't panic. You can completely control plugin migrations by
+    creating your own migrations. To manually migrate a plugin to a specific
+    version, simply use
+    
+      Rails.plugins[:your_plugin_name].migrate(version)
+      
+    where version is the integer of the migration this plugin should end
+    up at.
+    
+With great power comes great responsibility. Use this wisely.
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/plugin_migration_generator.rb b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/plugin_migration_generator.rb
new file mode 100644
index 0000000..906a911
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/plugin_migration_generator.rb
@@ -0,0 +1,79 @@
+# Generates a migration which migrates all plugins to their latest versions
+# within the database.
+class PluginMigrationGenerator < Rails::Generator::Base
+  
+  def initialize(runtime_args, runtime_options={})
+    super
+    @options = {:assigns => {}}
+    
+    ensure_plugin_schema_table_exists
+    get_plugins_to_migrate(runtime_args)
+    
+    if @plugins_to_migrate.empty?
+      puts "All plugins are migrated to their latest versions"
+      exit(0)
+    end
+
+    @options[:migration_file_name] = build_migration_name
+    @options[:assigns][:class_name] = build_migration_name.classify
+  end
+  
+  def manifest
+    record do |m|
+      m.migration_template 'plugin_migration.erb', 'db/migrate', @options
+    end
+  end
+  
+  protected
+  
+    # Create the plugin schema table if it doesn't already exist. See
+    # Engines::RailsExtensions::Migrations#initialize_schema_information_with_engine_additions
+    def ensure_plugin_schema_table_exists
+      ActiveRecord::Base.connection.initialize_schema_information
+    end
+
+    # Determine all the plugins which have migrations that aren't present
+    # according to the plugin schema information from the database.
+    def get_plugins_to_migrate(plugin_names)
+      
+      # First, grab all the plugins which exist and have migrations
+      @plugins_to_migrate = if plugin_names.empty?
+        Rails.plugins
+      else
+        plugin_names.map do |name| 
+          Rails.plugins[name] ? Rails.plugins[name] : raise("Cannot find the plugin '#{name}'")
+        end
+      end
+      
+      @plugins_to_migrate.reject! { |p| p.latest_migration.nil? }
+      
+      # Then find the current versions from the database    
+      @current_versions = {}
+      @plugins_to_migrate.each do |plugin|
+        @current_versions[plugin.name] = Engines::PluginMigrator.current_version(plugin)
+      end
+
+      # Then find the latest versions from their migration directories
+      @new_versions = {}      
+      @plugins_to_migrate.each do |plugin|
+        @new_versions[plugin.name] = plugin.latest_migration
+      end
+      
+      # Remove any plugins that don't need migration
+      @plugins_to_migrate.map { |p| p.name }.each do |name|
+        @plugins_to_migrate.delete(Rails.plugins[name]) if @current_versions[name] == @new_versions[name]
+      end
+      
+      @options[:assigns][:plugins] = @plugins_to_migrate
+      @options[:assigns][:new_versions] = @new_versions
+      @options[:assigns][:current_versions] = @current_versions
+    end
+
+    # Construct a unique migration name based on the plugins involved and the
+    # versions they should reach after this migration is run.
+    def build_migration_name
+      @plugins_to_migrate.map do |plugin| 
+        "#{plugin.name}_to_version_#{@new_versions[plugin.name]}" 
+      end.join("_and_")
+    end  
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/templates/plugin_migration.erb b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/templates/plugin_migration.erb
new file mode 100644
index 0000000..7a5f48a
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/generators/plugin_migration/templates/plugin_migration.erb
@@ -0,0 +1,13 @@
+class <%= class_name %> < ActiveRecord::Migration
+  def self.up
+  <%- plugins.each do |plugin| -%>
+    Rails.plugins["<%= plugin.name %>"].migrate(<%= new_versions[plugin.name] %>)
+  <%- end -%>
+  end
+
+  def self.down
+  <%- plugins.each do |plugin| -%>
+    Rails.plugins["<%= plugin.name %>"].migrate(<%= current_versions[plugin.name] %>)
+  <%- end -%>
+  end
+end
diff --git a/client/ruby/flare/vendor/plugins/engines/init.rb b/client/ruby/flare/vendor/plugins/engines/init.rb
new file mode 100644
index 0000000..63914cc
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/init.rb
@@ -0,0 +1,40 @@
+begin
+  silence_warnings { require 'rails/version' } # it may already be loaded
+  unless Rails::VERSION::MAJOR >= 1 && Rails::VERSION::MINOR >= 2
+    raise "This version of the engines plugin requires Rails 1.2 or later!"
+  end
+end
+
+# First, require the engines module & core methods
+require "engines"
+
+# Load this before we get actually start engines
+require "engines/rails_extensions/rails_initializer"
+
+# Start the engines mechanism.
+Engines.init(config, self)
+
+# Now that we've defined the engines module, load up any extensions
+[:rails,
+ :rails_initializer,
+ :dependencies,
+ :active_record,
+ :migrations,
+ :templates,
+ :public_asset_helpers,
+ :routing
+].each do |f|
+  require "engines/rails_extensions/#{f}"
+end
+
+# Load the testing extensions, if we are in the test environment.
+require "engines/testing" if RAILS_ENV == "test"
+
+# Load the Rails::Info module so that plugins can insert information into it.
+begin
+  require 'rails/info'
+rescue Exception
+  # If this file can't be loaded, it's probably because we're running in an
+  # environment where Rails' builtins aren't yet in the load path.
+  # For the moment, just ignore this. See Ticket #261
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/install.rb b/client/ruby/flare/vendor/plugins/engines/install.rb
new file mode 100644
index 0000000..7bff225
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/install.rb
@@ -0,0 +1,32 @@
+$LOAD_PATH.unshift File.join(File.dirname(__FILE__), "..", "..", "rails", "railties", "lib")
+silence_warnings { require 'rails/version' } #?it may already be loaded.
+
+unless Rails::VERSION::MAJOR >= 1 && Rails::VERSION::MINOR >= 2
+  puts <<-end_of_warning
+
+         !!!=== IMPORTANT NOTE ===!!!
+
+Support for Rails < 1.2 has been dropped; if you are using 
+Rails =< 1.1.6, please use Engines 1.1.6, available from: 
+
+  >>  http://svn.rails-engines.org/engines/tags/rel_1.1.6
+
+For more details about changes in Engines 1.2, please see 
+the changelog or the website: 
+
+  >>  http://www.rails-engines.org
+
+end_of_warning
+else
+  puts <<-end_of_message
+  
+The engines plugin is now installed. Feels good, right? Yeah. 
+You knew it would.
+
+Once the warm, fuzzy glow has subsided, be sure to read the contents 
+of the README and UPGRADING files if you're migrating this application 
+from Rails 1.1.x to 1.2.x.
+
+Have a great day!
+end_of_message
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines.rb
new file mode 100644
index 0000000..8128716
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines.rb
@@ -0,0 +1,323 @@
+# This file contains the Engines module, which holds most of the logic regarding
+# the startup and management of plugins. See Engines for more details.
+#
+# The engines plugin adds to Rails' existing behaviour by producing the +Rails.plugins+
+# PluginList, a list of all loaded plugins in a form which can be easily queried
+# and manipulated. Each instance of Plugin has methods which are used to enhance
+# their behaviour, including mirroring public assets, add controllers, helpers
+# and views and even migration.
+#
+# = init.rb
+# 
+# When the engines plugin loads, it first includes the 
+# Engines::RailsExtensions::RailsInitializer module into Rails::Initializer,
+# overriding a number of the methods used to load plugins.
+#
+# Once this is loaded, Engines.init is called to prepare the application
+# and create the relevant new datastructures (including <tt>Rails.plugins</tt>).
+#
+# Finally, each of the extension modules from Engines::RailsExtensionsis 
+# loaded and included into the relevant Rails classes and modules, enhancing 
+# their behaviour to work better with files from plugins.
+
+require "engines/plugin_list"
+require "engines/plugin"
+
+# TODO: define a better logger.
+def logger
+  RAILS_DEFAULT_LOGGER
+end
+
+# The Engines module contains most of the methods used during the enhanced
+# startup of Rails plugins.
+#
+# When the Engines plugin loads (its <tt>init.rb</tt> file is evaluated), the
+# Engines.init method is called. This kickstarts the plugins hooks into 
+# the initialization process.
+#
+# == Parameters
+#
+# The Engines module has a number of public configuration parameters:
+#
+# [+public_directory+]  The directory into which plugin assets should be
+#                       mirrored. Defaults to <tt>RAILS_ROOT/public/plugin_assets</tt>.
+# [+schema_info_table+] The table to use when storing plugin migration 
+#                       version information. Defaults to +plugin_schema_info+.
+# [+rails_initializer+] A reference of the Rails initializer instance that
+#                       was used to startup Rails. This is often useful
+#                       when working with the startup process; see
+#                       Engines::RailsExtensions::RailsInitializer for more
+#                       information
+#
+# Additionally, there are a few flags which control the behaviour of
+# some of the features the engines plugin adds to Rails:
+#
+# [+disable_application_view_loading+] A boolean flag determining whether
+#                                      or not views should be loaded from 
+#                                      the main <tt>app/views</tt> directory.
+#                                      Defaults to false; probably only 
+#                                      useful when testing your plugin.
+# [+disable_application_code_loading+] A boolean flag determining whether
+#                                      or not to load controllers/helpers 
+#                                      from the main +app+ directory,
+#                                      if corresponding code exists within 
+#                                      a plugin. Defaults to false; again, 
+#                                      probably only useful when testing 
+#                                      your plugin.
+# [+disable_code_mixing+] A boolean flag indicating whether all plugin
+#                         copies of a particular controller/helper should 
+#                         be loaded and allowed to override each other, 
+#                         or if the first matching file should be loaded 
+#                         instead. Defaults to false.
+#
+module Engines
+  # The name of the public directory to mirror public engine assets into.
+  # Defaults to <tt>RAILS_ROOT/public/plugin_assets</tt>.
+  mattr_accessor :public_directory
+  self.public_directory = File.join(RAILS_ROOT, 'public', 'plugin_assets')
+
+  # The table in which to store plugin schema information. Defaults to
+  # "plugin_schema_info".
+  mattr_accessor :schema_info_table
+  self.schema_info_table = "plugin_schema_info"
+
+  # A reference to the current Rails::Initializer instance
+  mattr_accessor :rails_initializer
+  
+  
+  #--
+  # These attributes control the behaviour of the engines extensions
+  #++
+  
+  # Set this to true if views should *only* be loaded from plugins
+  mattr_accessor :disable_application_view_loading
+  self.disable_application_view_loading = false
+  
+  # Set this to true if controller/helper code shouldn't be loaded 
+  # from the application
+  mattr_accessor :disable_application_code_loading
+  self.disable_application_code_loading = false
+  
+  # Set this ti true if code should not be mixed (i.e. it will be loaded
+  # from the first valid path on $LOAD_PATH)
+  mattr_accessor :disable_code_mixing
+  self.disable_code_mixing = false
+  
+  
+  private
+
+  # A memo of the bottom of Rails' default load path
+  mattr_accessor :rails_final_load_path
+  # A memo of the bottom of Rails Dependencies load path
+  mattr_accessor :rails_final_dependency_load_path
+  
+  public
+  
+  # Initializes the engines plugin and prepares Rails to start loading
+  # plugins using engines extensions. Within this method:
+  #
+  # 1. Copies of the Rails configuration and initializer are stored;
+  # 2. The Rails.plugins PluginList instance is created;
+  # 3. Any plugins which were loaded before the engines plugin are given 
+  #    the engines treatment via #enhance_loaded_plugins.
+  # 4. The base public directory (into which plugin assets are mirrored)
+  #    is created, if necessary - #initialize_base_public_directory
+  # 5. <tt>config.plugins</tt> is checked to see if a wildcard was present -
+  #    #check_for_star_wildcard
+  #
+  def self.init(rails_configuration, rails_initializer)
+    # First, determine if we're running in legacy mode
+    @legacy_support = self.const_defined?(:LegacySupport) && LegacySupport
+
+    # Store some information about the plugin subsystem
+    Rails.configuration = rails_configuration
+
+    # We need a hook into this so we can get freaky with the plugin loading itself
+    self.rails_initializer = rails_initializer
+    
+    @load_all_plugins = false    
+    
+    store_load_path_markers
+    
+    Rails.plugins ||= PluginList.new
+    enhance_loaded_plugins # including this one, as it happens.
+
+    initialize_base_public_directory
+    
+    check_for_star_wildcard
+    
+    logger.debug "engines has started."
+  end
+
+  # You can enable legacy support by defining the LegacySupport constant
+  # in the Engines module before Rails loads, i.e. at the *top* of environment.rb,
+  # add:
+  # 
+  #   module Engines
+  #     LegacySupport = true
+  #   end
+  #
+  # Legacy Support doesn't actually do anything at the moment. If necessary
+  # we may support older-style 'engines' using this flag.
+  def self.legacy_support?
+    @legacy_support
+  end
+
+  # A reference to the currently-loading/loaded plugin. This is present to support
+  # legacy engines; it's preferred to use Rails.plugins[name] in your plugin's
+  # init.rb file in order to get your Plugin instance.
+  def self.current
+    Rails.plugins.last
+  end
+
+  # This is set to true if a "*" widlcard is present at the end of
+  # the config.plugins array.  
+  def self.load_all_plugins?
+    @load_all_plugins
+  end
+
+  # Stores a record of the last paths which Rails added to each of the load path
+  # attributes ($LOAD_PATH, Dependencies.load_paths and 
+  # ActionController::Routing.controller_paths) that influence how code is loaded
+  # We need this to ensure that we place our additions to the load path *after*
+  # all Rails' defaults
+  def self.store_load_path_markers
+    self.rails_final_load_path = $LOAD_PATH.last
+    logger.debug "Rails final load path: #{self.rails_final_load_path}"
+    self.rails_final_dependency_load_path = ::Dependencies.load_paths.last
+    logger.debug "Rails final dependency load path: #{self.rails_final_dependency_load_path}"
+  end
+  
+  # Create Plugin instances for plugins loaded before the engines plugin was.
+  # Once a Plugin instance is created, the Plugin#load method is then called
+  # to fully load the plugin. See Plugin#load for more details about how a
+  # plugin is started once engines is involved.
+  def self.enhance_loaded_plugins
+    Engines.rails_initializer.loaded_plugins.each do |name|
+      plugin_path = File.join(self.find_plugin_path(name), name)
+      unless Rails.plugins[name]
+        plugin = Plugin.new(name, plugin_path)
+        logger.debug "enginizing plugin: #{plugin.name} from #{plugin_path}"
+        plugin.load # injects the extra directories into the load path, and mirrors public files
+        Rails.plugins << plugin
+      end
+    end
+    logger.debug "plugins is now: #{Rails.plugins.map { |p| p.name }.join(", ")}"
+  end  
+  
+  # Ensure that the plugin asset subdirectory of RAILS_ROOT/public exists, and
+  # that we've added a little warning message to instruct developers not to mess with
+  # the files inside, since they're automatically generated.
+  def self.initialize_base_public_directory
+    if !File.exist?(self.public_directory)
+      # create the public/engines directory, with a warning message in it.
+      logger.debug "Creating public engine files directory '#{self.public_directory}'"
+      FileUtils.mkdir(self.public_directory)
+      message = %{Files in this directory are automatically generated from your Rails Engines.
+They are copied from the 'public' directories of each engine into this directory
+each time Rails starts (server, console... any time 'start_engine' is called).
+Any edits you make will NOT persist across the next server restart; instead you
+should edit the files within the <plugin_name>/assets/ directory itself.}
+      target = File.join(public_directory, "README")
+      File.open(target, 'w') { |f| f.puts(message) } unless File.exist?(target)
+    end
+  end
+  
+  # Check for a "*" at the end of the plugins list; if one is found, note that
+  # we should load all other plugins once Rails has finished initializing, and
+  # remove the "*".
+  def self.check_for_star_wildcard
+    if Rails.configuration.plugins && Rails.configuration.plugins.last == "*"
+      Rails.configuration.plugins.pop
+      @load_all_plugins = true
+    end 
+  end
+
+
+  #-
+  # The following code is called once all plugins are loaded, and Rails is almost
+  # finished initialization
+  #+
+
+  # Once the Rails Initializer has finished, the engines plugin takes over
+  # and performs any post-processing tasks it may have, including:
+  #
+  # * Loading any remaining plugins if config.plugins ended with a '*'.
+  # * Updating Rails::Info with version information, if possible.
+  #
+  def self.after_initialize
+    if self.load_all_plugins?
+      logger.debug "loading remaining plugins from #{Rails.configuration.plugin_paths.inspect}"
+      # this will actually try to load ALL plugins again, but any that have already 
+      # been loaded will be ignored.
+      rails_initializer.load_all_plugins
+      update_rails_info_with_loaded_plugins
+    end
+  end
+  
+  # Updates Rails::Info with the list of loaded plugins, and version information for
+  # each plugin. This information is then available via script/about, or through
+  # the builtin rails_info controller.
+  def self.update_rails_info_with_loaded_plugins
+    if defined?(Rails::Info) # since it may not be available by default in some environments... 
+                             # don't do anything if it's not there.
+      Rails::Info.property("Loaded plugins") { Rails.plugins.map { |p| p.name }.join(", ") }
+      Rails.plugins.each do |plugin|
+        Rails::Info.property("#{plugin.name} version") { plugin.version.blank? ? "(unknown)" : plugin.version }
+      end
+    end      
+  end
+  
+  #-
+  # helper methods to find and deal with plugin paths and names
+  #+
+  
+  # Returns the path within +Rails.configuration.plugin_paths+ which includes
+  # a plugin with the given name.
+  def self.find_plugin_path(name)
+    Rails.configuration.plugin_paths.find do |path|
+      File.exist?(File.join(path, name.to_s))
+    end    
+  end
+  
+  # Returns the name for the plugin at the given path.
+  # (Note this method also appears in Rails::Initializer extensions)
+  def self.plugin_name(path)
+    File.basename(path)
+  end
+  
+  # A general purpose method to mirror a directory (+source+) into a destination
+  # directory, including all files and subdirectories. Files will not be mirrored
+  # if they are identical already (checked via FileUtils#identical?).
+  def self.mirror_files_from(source, destination)
+    return unless File.directory?(source)
+    
+    # TODO: use Rake::FileList#pathmap?
+    
+    source_files = Dir[source + "/**/*"]
+    source_dirs = source_files.select { |d| File.directory?(d) }
+    source_files -= source_dirs  
+    
+    source_dirs.each do |dir|
+      # strip down these paths so we have simple, relative paths we can
+      # add to the destination
+      target_dir = File.join(destination, dir.gsub(source, ''))
+      begin        
+        FileUtils.mkdir_p(target_dir)
+      rescue Exception => e
+        raise "Could not create directory #{target_dir}: \n" + e
+      end
+    end
+
+    source_files.each do |file|
+      begin
+        target = File.join(destination, file.gsub(source, ''))
+        unless File.exist?(target) && FileUtils.identical?(file, target)
+          FileUtils.cp(file, target)
+        end 
+      rescue Exception => e
+        raise "Could not copy #{file} to #{target}: \n" + e 
+      end
+    end  
+  end
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/deprecated_config_support.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/deprecated_config_support.rb
new file mode 100644
index 0000000..54e504c
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/deprecated_config_support.rb
@@ -0,0 +1,135 @@
+# This file contains support for the now-deprecated +config+ method that the engines
+# plugin provided before version 1.2. Instead of using this, plugin authors are
+# now encouraged to create their own Module configuration mechanisms; the 
+# +mattr_accessor+ mechanism provided by ActiveSupport is ideal for this:
+#
+#  module MyPlugin
+#    mattr_accessor :config_value
+#    self.config_value = "default"
+#  end
+#
+# == Using the deprecated config method
+#
+# If you require the config method to be present, change your <tt>environment.rb</tt>
+# file such that the very top of the file looks like this:
+#
+#   require File.join(File.dirname(__FILE__), 'boot')
+#   require File.join(RAILS_ROOT, "vendor", "plugins", "engines",
+#                     "lib", "engines", "deprecated_config_support")
+#
+
+
+# Adds the +config+ and +default_constant+ methods to Module.
+#
+# *IMPORTANT NOTE* - these methods are deprecated. Only use them when you have no
+# other choice. See link:files/lib/engines/deprecated_config_support_rb.html for more
+# information.
+class Module
+  # Defines a constant within a module/class ONLY if that constant does
+  # not already exist.
+  #
+  # This can be used to implement defaults in plugins/engines/libraries, e.g.
+  # if a plugin module exists:
+  #   module MyPlugin
+  #     default_constant :MyDefault, "the_default_value"
+  #   end
+  #
+  # then developers can override this default by defining that constant at
+  # some point *before* the module/plugin gets loaded (such as environment.rb)
+  def default_constant(name, value)
+    if !(name.is_a?(String) or name.is_a?(Symbol))
+      raise "Cannot use a #{name.class.name} ['#{name}'] object as a constant name"
+    end
+    if !self.const_defined?(name)
+      self.class_eval("#{name} = #{value.inspect}")
+    end
+  end
+  
+  # A mechanism for defining configuration of Modules. With this
+  # mechanism, default values for configuration can be provided within shareable
+  # code, and the end user can customise the configuration without having to
+  # provide all values.
+  #
+  # Example:
+  #
+  #  module MyModule
+  #    config :param_one, "some value"
+  #    config :param_two, 12345
+  #  end
+  #
+  # Those values can now be accessed by the following method
+  #
+  #   MyModule.config :param_one  
+  #     => "some value"
+  #   MyModule.config :param_two  
+  #     => 12345
+  #
+  # ... or, if you have overrriden the method 'config'
+  #
+  #   MyModule::CONFIG[:param_one]  
+  #     => "some value"
+  #   MyModule::CONFIG[:param_two]  
+  #     => 12345
+  #
+  # Once a value is stored in the configuration, it will not be altered
+  # by subsequent assignments, unless a special flag is given:
+  #
+  #   (later on in your code, most likely in another file)
+  #   module MyModule
+  #     config :param_one, "another value"
+  #     config :param_two, 98765, :force
+  #   end
+  #
+  # The configuration is now:
+  #
+  #   MyModule.config :param_one  
+  #     => "some value" # not changed
+  #   MyModule.config :param_two  
+  #     => 98765
+  #
+  # Configuration values can also be given as a Hash:
+  #
+  #   MyModule.config :param1 => 'value1', :param2 => 'value2'
+  #
+  # Setting of these values can also be forced:
+  #
+  #   MyModule.config :param1 => 'value3', :param2 => 'value4', :force => true
+  #
+  # A value of anything other than false or nil given for the :force key will
+  # result in the new values *always* being set.
+  def config(*args)
+    
+    raise "config expects at least one argument" if args.empty?
+    
+    # extract the arguments
+    if args[0].is_a?(Hash)
+      override = args[0][:force]
+      args[0].delete(:force)
+      args[0].each { |key, value| _handle_config(key, value, override)}
+    else
+      _handle_config(*args)
+    end
+  end
+  
+  private
+    # Actually set the config values
+    def _handle_config(name, value=nil, override=false)
+      if !self.const_defined?("CONFIG")
+        self.class_eval("CONFIG = {}")
+      end
+    
+      if value != nil
+        if override or self::CONFIG[name] == nil
+          self::CONFIG[name] = value 
+        end
+      else
+        # if we pass an array of config keys to config(),
+        # get the array of values back
+        if name.is_a? Array
+          name.map { |c| self::CONFIG[c] }
+        else
+          self::CONFIG[name]
+        end
+      end      
+    end
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin.rb
new file mode 100644
index 0000000..63d1db2
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin.rb
@@ -0,0 +1,214 @@
+# An instance of Plugin is created for each plugin loaded by Rails, and
+# stored in the <tt>Rails.plugins</tt> PluginList 
+# (see Engines::RailsExtensions::RailsInitializer for more details).
+#
+# Once the engines plugin is loaded, other plugins can take advantage of
+# their own instances by accessing either Engines.current, or the preferred mechanism
+#
+#   Rails.plugins[:plugin_name]
+#
+# Useful properties of this object include Plugin#version, which plugin developers
+# can set in their <tt>init.rb</tt> scripts:
+#
+#    Rails.plugins[:my_plugin].version = "1.4.2"
+#
+# Plugin developers can also access the contents of their <tt>about.yml</tt> files
+# via Plugin#about, which returns a Hash if the <tt>about.yml</tt> file exists for
+# this plugin. Note that if <tt>about.yml</tt> contains a "version" key, it will 
+# automatically be loaded into the <tt>version</tt> attribute described above.
+#
+# If this plugin contains paths in directories other than <tt>app/controllers</tt>,
+# <tt>app/helpers</tt>, <tt>app/models</tt> and <tt>components</tt>, authors can
+# declare this by adding extra paths to #code_paths:
+#
+#    Rails.plugin[:my_plugin].code_paths << "app/sweepers" << "vendor/my_lib"
+#
+# Other properties of the Plugin instance can also be set.
+class Plugin
+  
+  # The name of this plugin
+  attr_accessor :name
+
+  # The directory in which this plugin is located
+  attr_accessor :root
+  
+  # The version of this plugin
+  attr_accessor :version
+  
+  # The about.yml information as a Hash, if it exists
+  attr_accessor :about
+  
+  # Plugins can add code paths to this attribute in init.rb if they 
+  # need plugin directories to be added to the load path, i.e.
+  #
+  #   plugin.code_paths << 'app/other_classes'
+  #
+  # Defaults to ["app/controllers", "app/helpers", "app/models", "components"]
+  # (see #default_code_paths). NOTE: if you want to set this, you must
+  # ensure that the engines plugin is loaded before any plugins which
+  # reference this since it's not available before the engines plugin has worked
+  # its magic.
+  attr_accessor :code_paths
+  
+  # Plugins can add paths to this attribute in init.rb if they need
+  # controllers loaded from additional locations. See also #default_controller_paths, and
+  # the caveat surrounding the #code_paths accessor.
+  attr_accessor :controller_paths
+  
+  # The directory in this plugin to mirror into the shared directory
+  # under +public+. See Engines.initialize_base_public_directory
+  # for more information.
+  #
+  # Defaults to "assets" (see default_public_directory).
+  attr_accessor :public_directory
+  
+  protected
+  
+    # The default set of code paths which will be added to $LOAD_PATH
+    # and Dependencies.load_paths
+    def default_code_paths
+      # lib will actually be removed from the load paths when we call
+      # uniq! in #inject_into_load_paths, but it's important to keep it
+      # around (for the documentation tasks, for instance).
+      %w(app/controllers app/helpers app/models components lib)
+    end
+    
+    # The default set of code paths which will be added to the routing system
+    def default_controller_paths
+      %w(app/controllers components)
+    end
+
+    # Attempts to detect the directory to use for public files.
+    # If +assets+ exists in the plugin, this will be used. If +assets+ is missing
+    # but +public+ is found, +public+ will be used.
+    def default_public_directory
+      %w(assets public).select { |dir| File.directory?(File.join(root, dir)) }.first || "assets"
+    end
+
+  public
+  
+  # Creates a new Plugin instance, and loads any other data from <tt>about.yml</tt>
+  def initialize(name, path)
+    @name = name
+    @root = path
+    
+    @code_paths = default_code_paths
+    @controller_paths = default_controller_paths
+    @public_directory = default_public_directory
+    
+    load_about_information
+  end
+  
+  # Load the information from <tt>about.yml</tt>. This Hash is then accessible
+  # from #about.
+  #
+  # If <tt>about.yml</tt> includes a "version", this will be assigned
+  # automatically into #version.
+  def load_about_information
+    about_path = File.join(self.root, 'about.yml')
+    if File.exist?(about_path)
+      @about = YAML.load(File.open(about_path).read)
+      @about.stringify_keys!
+      @version = @about["version"]
+    end
+  end
+  
+  # Load the plugin. Since Rails takes care of evaluating <tt>init.rb</tt> and
+  # adding +lib+ to the <tt>$LOAD_PATH</tt>, we don't need to do that here (see
+  # Engines::RailsExtensions::RailsInitializer.load_plugins_with_engine_additions).
+  # 
+  # Here we add controller/helper code to the appropriate load paths (see 
+  # #inject_into_load_path) and mirror the plugin assets into the shared public
+  # directory (#mirror_public_assets).
+  def load
+    logger.debug "Plugin '#{name}': starting load."
+    
+    inject_into_load_path
+    mirror_public_assets
+    
+    logger.debug "Plugin '#{name}': loaded."
+  end
+  
+  # Adds all directories in the +app+ and +lib+ directories within the engine
+  # to the three relevant load paths mechanism that Rails might use:
+  #
+  # * <tt>$LOAD_PATH</tt>
+  # * <tt>Dependencies.load_paths</tt>
+  # * <tt>ActionController::Routing.controller_paths</tt>
+  #
+  def inject_into_load_path
+
+    load_path_index = $LOAD_PATH.index(Engines.rails_final_load_path)
+    dependency_index = ::Dependencies.load_paths.index(Engines.rails_final_dependency_load_path)
+    
+    # Add relevant paths under the engine root to the load path
+    code_paths.map { |p| File.join(root, p) }.each do |path| 
+      if File.directory?(path)
+        # Add to the load paths
+        $LOAD_PATH.insert(load_path_index + 1, path)
+        # Add to the dependency system, for autoloading.
+        ::Dependencies.load_paths.insert(dependency_index + 1, path)
+      end
+    end
+    
+    # Add controllers to the Routing system specifically. We actually add our paths
+    # to the configuration too, since routing is started AFTER plugins are. Plugins
+    # which are loaded by engines specifically (i.e. because of the '*' in 
+    # +config.plugins+) will need their paths added directly to the routing system, 
+    # since at that point it has already been configured.
+    controller_paths.map { |p| File.join(root, p) }.each do |path|
+      if File.directory?(path)
+        ActionController::Routing.controller_paths << path
+        Rails.configuration.controller_paths << path
+      end
+    end
+
+    $LOAD_PATH.uniq!
+    ::Dependencies.load_paths.uniq!
+    ActionController::Routing.controller_paths.uniq!
+    Rails.configuration.controller_paths.uniq!
+  end
+
+  # Replicates the subdirectories under the plugins's +assets+ (or +public+) directory into
+  # the corresponding public directory. See also Plugin#public_directory for more.
+  def mirror_public_assets
+  
+    begin 
+      source = File.join(root, self.public_directory)
+      # if there is no public directory, just return after this file
+      return if !File.exist?(source)
+
+      logger.debug "Attempting to copy plugin plugin asset files from '#{source}' to '#{Engines.public_directory}'"
+
+      Engines.mirror_files_from(source, File.join(Engines.public_directory, name))
+      
+    rescue Exception => e
+      logger.warn "WARNING: Couldn't create the public file structure for plugin '#{name}'; Error follows:"
+      logger.warn e
+    end
+  end
+
+  # The path to this plugin's public files
+  def public_asset_directory
+    "#{File.basename(Engines.public_directory)}/#{name}"
+  end
+
+  # The directory containing this plugin's migrations (<tt>plugin/db/migrate</tt>)
+  def migration_directory
+    File.join(self.root, 'db', 'migrate')
+  end
+  
+  # Returns the version number of the latest migration for this plugin. Returns
+  # nil if this plugin has no migrations.
+  def latest_migration
+    migrations = Dir[migration_directory+"/*.rb"]
+    return nil if migrations.empty?
+    migrations.map { |p| File.basename(p) }.sort.last.match(/0*(\d+)\_/)[1].to_i
+  end
+  
+  # Migrate this plugin to the given version. See Engines::PluginMigrator for more
+  # information.   
+  def migrate(version = nil)
+    Engines::PluginMigrator.migrate_plugin(self, version)
+  end  
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_list.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_list.rb
new file mode 100644
index 0000000..a89d989
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_list.rb
@@ -0,0 +1,31 @@
+# The PluginList class is an array, enhanced to allow access to loaded plugins
+# by name, and iteration over loaded plugins in order of priority. This array is used
+# by Engines::RailsExtensions::RailsInitializer to create the Rails.plugins array.
+#
+# Each loaded plugin has a corresponding Plugin instance within this array, and 
+# the order the plugins were loaded is reflected in the entries in this array.
+#
+# For more information, see the Rails module.
+class PluginList < Array
+  # Finds plugins with the set with the given name (accepts Strings or Symbols), or
+  # index. So, Rails.plugins[0] returns the first-loaded Plugin, and Rails.plugins[:engines]
+  # returns the Plugin instance for the engines plugin itself.
+  def [](name_or_index)
+    if name_or_index.is_a?(Fixnum)
+      super
+    else
+      self.find { |plugin| plugin.name.to_s == name_or_index.to_s }
+    end
+  end
+  
+  # Go through each plugin, highest priority first (last loaded first). Effectively,
+  # this is like <tt>Rails.plugins.reverse</tt>, except when given a block, when it behaves
+  # like <tt>Rails.plugins.reverse.each</tt>.
+  def by_precedence(&block)
+    if block_given?
+      reverse.each { |x| yield x }
+    else 
+      reverse
+    end
+  end
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_migrator.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_migrator.rb
new file mode 100644
index 0000000..795d36e
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/plugin_migrator.rb
@@ -0,0 +1,60 @@
+# The PluginMigrator class contains the logic to run migrations from
+# within plugin directories. The directory in which a plugin's migrations
+# should be is determined by the Plugin#migration_directory method.
+#
+# To migrate a plugin, you can simple call the migrate method (Plugin#migrate)
+# with the version number that plugin should be at. The plugin's migrations
+# will then be used to migrate up (or down) to the given version.
+#
+# For more information, see Engines::RailsExtensions::Migrations
+class Engines::PluginMigrator < ActiveRecord::Migrator
+
+  # We need to be able to set the 'current' engine being migrated.
+  cattr_accessor :current_plugin
+
+  # Runs the migrations from a plugin, up (or down) to the version given
+  def self.migrate_plugin(plugin, version)
+    self.current_plugin = plugin
+    migrate(plugin.migration_directory, version)
+  end
+  
+  # Returns the name of the table used to store schema information about
+  # installed plugins.
+  #
+  # See Engines.schema_info_table for more details.
+  def self.schema_info_table_name
+    ActiveRecord::Base.wrapped_table_name Engines.schema_info_table
+  end
+
+  # Returns the current version of the given plugin
+  def self.current_version(plugin=current_plugin)
+    result = ActiveRecord::Base.connection.select_one(<<-ESQL
+      SELECT version FROM #{schema_info_table_name} 
+      WHERE plugin_name = '#{plugin.name}'
+    ESQL
+    )
+    if result
+      result["version"].to_i
+    else
+      # There probably isn't an entry for this engine in the migration info table.
+      # We need to create that entry, and set the version to 0
+      ActiveRecord::Base.connection.execute(<<-ESQL
+        INSERT INTO #{schema_info_table_name} (version, plugin_name) 
+        VALUES (0,'#{plugin.name}')
+      ESQL
+      )      
+      0
+    end
+  end
+
+  # Sets the version of the plugin in Engines::PluginMigrator.current_plugin to
+  # the given version.
+  def set_schema_version(version)
+    ActiveRecord::Base.connection.update(<<-ESQL
+      UPDATE #{self.class.schema_info_table_name} 
+      SET version = #{down? ? version.to_i - 1 : version.to_i} 
+      WHERE plugin_name = '#{self.current_plugin.name}'
+    ESQL
+    )
+  end
+end
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions.rb
new file mode 100644
index 0000000..36e76a9
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions.rb
@@ -0,0 +1,6 @@
+# This module contains all the extensions that the engines plugin makes to
+# Rails core. Explanations of how each extension works are included as RDoc
+# documentation for each of the modules listed.
+module Engines::RailsExtensions
+  # let's not rely *entirely* on Rails' magic modules. Not just yet.
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/active_record.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/active_record.rb
new file mode 100644
index 0000000..15bb045
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/active_record.rb
@@ -0,0 +1,19 @@
+# Here we add a single helpful method to ActiveRecord::Base. This method may be deprecated
+# in the future, since support for the Module#config mechanism which required it has
+# also been dropped.
+module Engines::RailsExtensions::ActiveRecord
+  # NOTE: Currently the Migrations system will ALWAYS wrap given table names
+  # in the prefix/suffix, so any table name set via ActiveRecord::Base#set_table_name, 
+  # for instance will always get wrapped in the process of migration. For this 
+  # reason, whatever value you give to the config will be wrapped when set_table_name 
+  # is used in the model.
+  #
+  # This method is useful for determining the actual name (including prefix and 
+  # suffix) that Rails will use for a model, given a particular set_table_name
+  # parameter.
+  def wrapped_table_name(name)
+    table_name_prefix + name + table_name_suffix
+  end
+end
+
+::ActiveRecord::Base.extend(Engines::RailsExtensions::ActiveRecord)
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/dependencies.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/dependencies.rb
new file mode 100644
index 0000000..07da01f
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/dependencies.rb
@@ -0,0 +1,143 @@
+# One of the magic features that that engines plugin provides is the ability to
+# override selected methods in controllers and helpers from your application.
+# This is achieved by trapping requests to load those files, and then mixing in
+# code from plugins (in the order the plugins were loaded) before finally loading
+# any versions from the main +app+ directory.
+#
+# The behaviour of this extension is output to the log file for help when
+# debugging.
+#
+# == Example
+#
+# A plugin contains the following controller in <tt>plugin/app/controllers/my_controller.rb</tt>:
+#
+#   class MyController < ApplicationController
+#     def index
+#       @name = "HAL 9000"
+#     end
+#     def list
+#       @robots = Robot.find(:all)
+#     end
+#   end
+#
+# In one application that uses this plugin, we decide that the name used in the
+# index action should be "Robbie", not "HAL 9000". To override this single method,
+# we create the corresponding controller in our application 
+# (<tt>RAILS_ROOT/app/controllers/my_controller.rb</tt>), and redefine the method:
+#
+#   class MyController < ApplicationController
+#     def index
+#       @name = "Robbie"
+#     end
+#   end
+#
+# The list method remains as it was defined in the plugin controller.
+#
+# The same basic principle applies to helpers, and also views and partials (although
+# view overriding is performed in Engines::RailsExtensions::Templates; see that
+# module for more information).
+#
+# === What about models?
+#
+# Unfortunately, it's not possible to provide this kind of magic for models.
+# The only reason why it's possible for controllers and helpers is because
+# they can be recognised by their filenames ("whatever_controller", "jazz_helper"),
+# whereas models appear the same as any other typical Ruby library ("node",
+# "user", "image", etc.). 
+#
+# If mixing were allowed in models, it would mean code mixing for *every* 
+# file that was loaded via +require_or_load+, and this could result in
+# problems where, for example, a Node model might start to include 
+# functionality from another file called "node" somewhere else in the
+# <tt>$LOAD_PATH</tt>.
+#
+# One way to overcome this is to provide model functionality as a module in
+# a plugin, which developers can then include into their own model
+# implementations.
+#
+# Another option is to provide an abstract model (see the ActiveRecord::Base
+# documentation) and have developers subclass this model in their own
+# application if they must.
+#
+# ---
+#
+# The Engines::RailsExtensions::Dependencies module includes a method to
+# override Dependencies.require_or_load, which is called to load code needed
+# by Rails as it encounters constants that aren't defined.
+#
+# This method is enhanced with the code-mixing features described above.
+#
+module Engines::RailsExtensions::Dependencies
+  def self.included(base) #:nodoc:
+    base.class_eval { alias_method_chain :require_or_load, :engine_additions }
+  end
+  
+  # Attempt to load the given file from any plugins, as well as the application.
+  # This performs the 'code mixing' magic, allowing application controllers and
+  # helpers to override single methods from those in plugins.
+  # If the file can be found in any plugins, it will be loaded first from those
+  # locations. Finally, the application version is loaded, using Ruby's behaviour
+  # to replace existing methods with their new definitions.
+  #
+  # If <tt>Engines.disable_code_mixing == true</tt>, the first controller/helper on the
+  # <tt>$LOAD_PATH</tt> will be used (plugins' +app+ directories are always lower on the
+  # <tt>$LOAD_PATH</tt> than the main +app+ directory).
+  #
+  # If <tt>Engines.disable_application_code_loading == true</tt>, controllers will
+  # not be loaded from the main +app+ directory *if* they are present in any
+  # plugins.
+  #
+  # Returns true if the file could be loaded (from anywhere); false otherwise -
+  # mirroring the behaviour of +require_or_load+ from Rails (which mirrors
+  # that of Ruby's own +require+, I believe).
+  def require_or_load_with_engine_additions(file_name, const_path=nil)
+    return require_or_load_without_engine_additions(file_name, const_path) if Engines.disable_code_mixing
+
+    file_loaded = false
+
+    # try and load the plugin code first
+    # can't use model, as there's nothing in the name to indicate that the file is a 'model' file
+    # rather than a library or anything else.
+    ['controller', 'helper'].each do |file_type| 
+      # if we recognise this type
+      # (this regexp splits out the module/filename from any instances of app/#{type}, so that
+      #  modules are still respected.)
+      if file_name =~ /^(.*app\/#{file_type}s\/)?(.*_#{file_type})(\.rb)?$/
+        base_name = $2
+        # ... go through the plugins from first started to last, so that
+        # code with a high precedence (started later) will override lower precedence
+        # implementations
+        Rails.plugins.each do |plugin|
+          plugin_file_name = File.expand_path(File.join(plugin.root, 'app', "#{file_type}s", base_name))
+          logger.debug("checking plugin '#{plugin.name}' for '#{base_name}'")
+          if File.file?("#{plugin_file_name}.rb")
+            logger.debug("==> loading from plugin '#{plugin.name}'")
+            file_loaded = true if require_or_load_without_engine_additions(plugin_file_name, const_path)
+          end
+        end
+        
+        # finally, load any application-specific controller classes using the 'proper'
+        # rails load mechanism, EXCEPT when we're testing engines and could load this file
+        # from an engine
+        if Engines.disable_application_code_loading
+          logger.debug("loading from application disabled.")
+        else
+          # Ensure we are only loading from the /app directory at this point
+          app_file_name = File.join(RAILS_ROOT, 'app', "#{file_type}s", "#{base_name}")
+          if File.file?("#{app_file_name}.rb")
+            logger.debug("loading from application: #{base_name}")
+            file_loaded = true if require_or_load_without_engine_additions(app_file_name, const_path)
+          else
+            logger.debug("(file not found in application)")
+          end
+        end        
+      end 
+    end
+    
+    # if we managed to load a file, return true. If not, default to the original method.
+    # Note that this relies on the RHS of a boolean || not to be evaluated if the LHS is true.
+    file_loaded || require_or_load_without_engine_additions(file_name, const_path)
+  end
+end
+
+::Dependencies.send(:include, Engines::RailsExtensions::Dependencies)
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/migrations.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/migrations.rb
new file mode 100644
index 0000000..2c4d93a
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/migrations.rb
@@ -0,0 +1,155 @@
+# Contains the enhancements to Rails' migrations system to support the 
+# Engines::PluginMigrator. See Engines::RailsExtensions::Migrations for more
+# information.
+
+require "engines/plugin_migrator"
+
+# = Plugins and Migrations: Background
+#
+# Rails uses migrations to describe changes to the databases as your application
+# evolves. Each change to your application - adding and removing models, most
+# commonly - might require tweaks to your schema in the form of new tables, or new
+# columns on existing tables, or possibly the removal of tables or columns. Migrations
+# can even include arbitrary code to *transform* data as the underlying schema
+# changes.
+# 
+# The point is that at any particular stage in your application's development, 
+# migrations serve to transform the database into a state where it is compatible
+# and appropriate at that time.
+# 
+# == What about plugins?
+# 
+# If you want to share models using plugins, chances are that you might also
+# want to include the corresponding migrations to create tables for those models.
+# With the engines plugin installed, plugins can carry migration data easily:
+# 
+#   vendor/
+#     |
+#     plugins/
+#       |
+#       my_plugin/
+#         |- init.rb
+#         |- lib/
+#         |- db/
+#             |-migrate/
+#                 |- 001_do_something.rb
+#                 |- 002_and_something_else.rb
+#                 |- ...
+# 
+# When you install a plugin which contains migrations, you are undertaking a
+# further step in the development of your application, the same as the addition
+# of any other code. With this in mind, you may want to 'roll back' the
+# installation of this plugin at some point, and the database should be able
+# to migrate back to the point without this plugin in it too.
+#
+# == An example
+#
+# For example, our current application is at version 14 (according to the
+# +schema_info+ table), when we decide that we want to add a tagging plugin. The
+# tagging plugin chosen includes migrations to create the tables it requires
+# (say, _tags_ and _taggings_, for instance), along with the models and helpers
+# one might expect.
+#
+# After installing this plugin, these tables should be created in our database.
+# Rather than running the migrations directly from the plugin, they should be
+# integrated into our main migration stream in order to accurately reflect the
+# state of our application's database *at this moment in time*.
+#
+#   $ script/generate plugin_migration
+#         exists  db/migrate
+#         create  db/migrate/015_migrate_tagging_plugin_to_version_3.rb
+#
+# This migration will take our application to version 15, and contains the following, 
+# typical migration code:
+# 
+#   class MigrateTaggingPluginToVersion3 < ActiveRecord::Migration
+#     def self.up
+#       Rails.plugins[:tagging].migrate(3)
+#     end
+#     def self.down
+#       Rails.plugins[:tagging].migrate(0)
+#     end
+#   end
+#
+# When we migrate our application up, using <tt>rake db:migrate</tt> as normal,
+# the plugin will be migrated up to its latest version (3 in this example). If we
+# ever decide to migrate the application back to the state it was in at version 14,
+# the plugin migrations will be taken back down to version 0 (which, typically,
+# would remove all tables the plugin migrations define).
+#
+# == Upgrading plugins
+#
+# It might happen that later in an application's life, we update to a new version of
+# the tagging plugin which requires some changes to our database. The tagging plugin
+# provides these changes in the form of its own migrations. 
+#
+# In this case, we just need to re-run the plugin_migration generator to create a 
+# new migration from the current revision to the newest one:
+#
+#   $ script/generate plugin_migration
+#        exists db/migrate
+#        create db/migrate/023_migrate_tagging_plugin_to_version_5.rb
+#
+# The contents of this migration are:
+#
+#   class MigrateTaggingPluginToVersion3 < ActiveRecord::Migration
+#     def self.up
+#       Rails.plugins[:tagging].migrate(5)
+#     end
+#     def self.down
+#       Rails.plugins[:tagging].migrate(3)
+#     end
+#   end
+#
+# Notice that if we were to migrate down to revision 22 or lower, the tagging plugin
+# will be migrated back down to version 3 - the version we were previously at.
+#
+#
+# = Creating migrations in plugins
+#
+# In order to use the plugin migration functionality that engines provides, a plugin 
+# only needs to provide regular migrations in a <tt>db/migrate</tt> folder within it.
+#
+# = Explicitly migrating plugins
+#
+# It's possible to migrate plugins within your own migrations, or any other code.
+# Simply get the Plugin instance, and its Plugin#migrate method with the version
+# you wish to end up at:
+#
+#   Rails.plugins[:whatever].migrate(version)
+#
+# ---
+#
+# The Engines::RailsExtensions::Migrations module defines extensions for Rails' 
+# migration systems. Specifically:
+#
+# * Adding a hook to initialize_schema_information to create the plugin schema
+#   info table.
+#
+module Engines::RailsExtensions::Migrations
+  def self.included(base) # :nodoc:
+    base.class_eval { alias_method_chain :initialize_schema_information, :engine_additions }
+  end
+
+  # Create the schema tables, and ensure that the plugin schema table
+  # is also initialized. The plugin schema info table is defined by
+  # Engines::PluginMigrator.schema_info_table_name.
+  def initialize_schema_information_with_engine_additions
+    initialize_schema_information_without_engine_additions
+    
+    # create the plugin schema stuff.    
+    begin
+      execute <<-ESQL
+        CREATE TABLE #{Engines::PluginMigrator.schema_info_table_name} 
+          (plugin_name #{type_to_sql(:string)}, version #{type_to_sql(:integer)})
+      ESQL
+    rescue ActiveRecord::StatementInvalid
+      # Schema has been initialized
+    end
+  end
+end
+
+::ActiveRecord::ConnectionAdapters::SchemaStatements.send(:include, Engines::RailsExtensions::Migrations)
+
+# Set ActiveRecord to ignore the plugin schema table by default
+::ActiveRecord::SchemaDumper.ignore_tables << Engines.schema_info_table
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/public_asset_helpers.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/public_asset_helpers.rb
new file mode 100644
index 0000000..7f7a02e
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/public_asset_helpers.rb
@@ -0,0 +1,116 @@
+# The engines plugin makes it trivial to share public assets using plugins. 
+# To do this, include an <tt>assets</tt> directory within your plugin, and put
+# your javascripts, stylesheets and images in subdirectories of that folder:
+#
+#   my_plugin
+#     |- init.rb
+#     |- lib/
+#     |- assets/
+#          |- javascripts/
+#          |    |- my_functions.js
+#          |
+#          |- stylesheets/
+#          |    |- my_styles.css
+#          |
+#          |- images/
+#               |- my_face.jpg
+#
+# Files within the <tt>asset</tt> structure are automatically mirrored into
+# a publicly-accessible folder each time your application starts (see
+# Plugin#mirror_public_assets).
+#
+#
+# == Using plugin assets in views
+#
+# It's also simple to use Rails' helpers in your views to use plugin assets.
+# The default helper methods have been enhanced by the engines plugin to accept
+# a <tt>:plugin</tt> option, indicating the plugin containing the desired asset.
+#
+# For example, it's easy to use plugin assets in your layouts:
+#
+#   <%= stylesheet_link_tag "my_styles", :plugin => "my_plugin", :media => "screen" %>
+#   <%= javascript_include_tag "my_functions", :plugin => "my_plugin" %>
+# 
+# ... and similarly in views and partials, it's easy to use plugin images:
+#
+#   <%= image_tag "my_face", :plugin => "my_plugin" %>
+#   <!-- or -->
+#   <%= image_path "my_face", :plugin => "my_plugin" %>
+#
+# Where the default helpers allow the specification of more than one file (i.e. the
+# javascript and stylesheet helpers), you can do similarly for multiple assets from 
+# within a single plugin.
+#
+# ---
+#
+# This module enhances four of the methods from ActionView::Helpers::AssetTagHelper:
+#
+#  * stylesheet_link_tag
+#  * javascript_include_tag
+#  * image_path
+#  * image_tag
+#
+# Each one of these methods now accepts the key/value pair <tt>:plugin => "plugin_name"</tt>,
+# which can be used to specify the originating plugin for any assets.
+#
+module Engines::RailsExtensions::PublicAssetHelpers
+  def self.included(base) #:nodoc:
+    base.class_eval do
+      [:stylesheet_link_tag, :javascript_include_tag, :image_path, :image_tag].each do |m|
+        alias_method_chain m, :engine_additions
+      end
+    end
+  end
+  
+  # Adds plugin functionality to Rails' default stylesheet_link_tag method.
+  def stylesheet_link_tag_with_engine_additions(*sources)
+    stylesheet_link_tag_without_engine_additions(*Engines::RailsExtensions::PublicAssetHelpers.pluginify_sources("stylesheets", *sources))
+  end
+
+  # Adds plugin functionality to Rails' default javascript_include_tag method.  
+  def javascript_include_tag_with_engine_additions(*sources)
+    javascript_include_tag_without_engine_additions(*Engines::RailsExtensions::PublicAssetHelpers.pluginify_sources("javascripts", *sources))
+  end
+  
+  #--
+  # Our modified image_path now takes a 'plugin' option, though it doesn't require it
+  #++
+  
+  # Adds plugin functionality to Rails' default image_path method.
+  def image_path_with_engine_additions(source, options={})
+    options.stringify_keys!
+    source = Engines::RailsExtensions::PublicAssetHelpers.plugin_asset_path(options["plugin"], "images", source) if options["plugin"]
+    image_path_without_engine_additions(source)
+  end
+  
+  # Adds plugin functionality to Rails' default image_tag method.
+  def image_tag_with_engine_additions(source, options={})
+    options.stringify_keys!
+    if options["plugin"]
+      source = Engines::RailsExtensions::PublicAssetHelpers.plugin_asset_path(options["plugin"], "images", source)
+      options.delete("plugin")
+    end
+    image_tag_without_engine_additions(source, options)
+  end
+  
+  #--
+  # The following are methods on this module directly because of the weird-freaky way
+  # Rails creates the helper instance that views actually get
+  #++
+  
+  # Convert sources to the paths for the given plugin, if any plugin option is given
+  def self.pluginify_sources(type, *sources)
+    options = sources.last.is_a?(Hash) ? sources.pop.stringify_keys : { }
+    sources.map! { |s| plugin_asset_path(options["plugin"], type, s) } if options["plugin"]
+    options.delete("plugin") # we don't want it appearing in the HTML
+    sources << options # re-add options      
+  end  
+
+  # Returns the publicly-addressable relative URI for the given asset, type and plugin
+  def self.plugin_asset_path(plugin_name, type, asset)
+    raise "No plugin called '#{plugin_name}' - please use the full name of a loaded plugin." if Rails.plugins[plugin_name].nil?
+    "/#{Rails.plugins[plugin_name].public_asset_directory}/#{type}/#{asset}"
+  end
+end
+
+::ActionView::Helpers::AssetTagHelper.send(:include, Engines::RailsExtensions::PublicAssetHelpers)
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails.rb
new file mode 100644
index 0000000..5ae0a3a
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails.rb
@@ -0,0 +1,20 @@
+# In order to give a richer infrastructure for dealing with plugins, the engines
+# plugin adds two new attributes to the Rails module:
+#
+# [+plugins+]       A PluginList instance which holds the currently loaded plugins
+# [+configuration+] The current Rails::Configuration instance, so that we can
+#                   query any parameters that might be set *after* Rails has
+#                   loaded, as well as during plugin initialization
+#
+#--
+# Here we just re-open the Rails module and add our custom accessors; it
+# may be cleaner to seperate them into a module, but in this case that seems
+# like overkill.
+#++
+module Rails
+  # The set of all loaded plugins
+  mattr_accessor :plugins
+  
+  # The Rails::Initializer::Configuration object
+  mattr_accessor :configuration
+end
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails_initializer.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails_initializer.rb
new file mode 100644
index 0000000..5686b52
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/rails_initializer.rb
@@ -0,0 +1,86 @@
+# Enhances the Rails::Initializer class to be a bit smarter about
+# plugins. See Engines::RailsExtensions::RailsInitializer for more
+# details.
+
+require "engines/rails_extensions/rails"
+require 'engines/plugin_list'
+
+# The engines plugin changes the way that Rails actually loads other plugins.
+# It creates instances of the Plugin class to represent each plugin, stored
+# in the <tt>Rails.plugins</tt> PluginList.
+#
+# ---
+#
+# Three methods from the original Rails::Initializer module are overridden
+# by Engines::RailsExtensions::RailsInitializer:
+#
+# [+load_plugin+] which now creates Plugin instances and calls Plugin#load
+# [+after_initialize+] which now performs Engines.after_initialize in addition
+#                      to the given config block
+# [<tt>plugin_enabled?</tt>]  which now respects the result of 
+#                             Engines.load_all_plugins?
+#
+module Engines::RailsExtensions::RailsInitializer
+  def self.included(base) #:nodoc:
+    base.class_eval do
+      alias_method_chain :load_plugin, :engine_additions
+      alias_method_chain :after_initialize, :engine_additions
+      alias_method_chain :plugin_enabled?, :engine_additions    
+    end
+  end
+  
+  # Loads all plugins in configuration.plugin_paths, regardless of the contents
+  # of configuration.plugins
+  def load_all_plugins
+    # a nil value implies we don't care about plugins; load 'em all in a reliable order
+    find_plugins(configuration.plugin_paths).sort.each { |path| load_plugin path }
+  end
+  
+  # Loads a plugin, performing the extra load path/public file magic of
+  # engines by calling Plugin#load.
+  def load_plugin_with_engine_additions(directory)
+    name = plugin_name(directory)
+    return false if loaded_plugins.include?(name)
+    
+    logger.debug "loading plugin from #{directory} with engine additions"
+    
+    # add the Plugin object
+    plugin = Plugin.new(plugin_name(directory), directory)
+    Rails.plugins << plugin
+          
+    # do the other stuff that load_plugin used to do. This includes
+    # allowing the plugin's init.rb to set configuration options on
+    # it's instance, which can then be used in it's initialization
+    load_plugin_without_engine_additions(directory)
+
+    # perform additional loading tasks like mirroring public assets
+    # and adding app directories to the appropriate load paths
+    plugin.load
+          
+    true
+  end
+  
+  # Allow the engines plugin to do whatever it needs to do after Rails has
+  # loaded, and then call the actual after_initialize block. Currently, this
+  # is call Engines.after_initialize.
+  def after_initialize_with_engine_additions
+    Engines.after_initialize
+    after_initialize_without_engine_additions
+  end
+  
+  protected
+  
+    # Returns true if the plugin at the given path should be loaded; false
+    # otherwise. If Engines.load_all_plugins? is true, this method will return
+    # true regardless of the path given.
+    def plugin_enabled_with_engine_additions?(path)
+      Engines.load_all_plugins? || plugin_enabled_without_engine_additions?(path)
+    end
+        
+    # Returns the name of the plugin at the given path.
+    def plugin_name(path)
+      File.basename(path)
+    end    
+end
+
+::Rails::Initializer.send(:include, Engines::RailsExtensions::RailsInitializer)
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/routing.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/routing.rb
new file mode 100644
index 0000000..f21d61e
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/routing.rb
@@ -0,0 +1,77 @@
+# Effective use of Rails' routes can help create a tidy and elegant set of URLs,
+# and is a significant part of creating an external API for your web application.
+# 
+# When developing plugins which contain controllers, it seems obvious that including
+# the corresponding routes would be extremely useful. This is particularly true
+# when exposing RESTful resources using the new REST-ian features of Rails 1.2.
+#
+# == Including routes in your plugin
+#
+# The engines plugin makes it possible to include a set of routes within your plugin
+# very simply, as it turns out. In your plugin, you simply include a <tt>routes.rb</tt> 
+# file like the one below at the root of your plugin:
+# 
+#   connect "/login", :controller => "my_plugin/account", :action => "login"
+#
+#   # add a named route
+#   logout "/logout", :controller => "my_plugin/account", :action => "logout"
+#
+#   # some restful stuff
+#   resources :things do |t|
+#     t.resources :other_things
+#   end
+# 
+# Everywhere in a normal <tt>RAILS_ROOT/config/routes.rb</tt> file 
+# where you might have <tt>map.connect</tt>, you just use <tt>connect</tt> in your 
+# plugin's <tt>routes.rb</tt>.
+# 
+# === Hooking it up in your application
+#
+# While it would be possible to have each plugin's routes automagically included into
+# the application's route set, to do so would actually be a stunningly bad idea. Route
+# priority is the key issue here. You, the application developer, needs to be in complete
+# control when it comes to specifying the priority of routes in your application, since 
+# the ordering of your routes directly affects how Rails will interpret incoming requests.
+# 
+# To add plugin routes into your application's <tt>routes.rb</tt> file, you need to explicitly 
+# map them in using the Engines::RailsExtensions::Routing#from_plugin method:
+# 
+#   ApplicationController::Routing::Routes.draw do |map|
+#
+#     map.connect "/app_stuff", :controller => "application_thing" # etc...
+#
+#     # This line includes the routes from the given plugin at this point, giving you
+#     # control over the priority of your application routes 
+#     map.from_plugin :your_plugin
+#
+#     map.connect ":controller/:action/:id"
+#   end
+# 
+# By including routes in plugins which have controllers, you can now share in a simple way 
+# a compact and elegant URL scheme which corresponds to those controllers.
+#
+# ---
+#
+# The Engines::RailsExtensions::Routing module defines extensions to Rails' 
+# routing (ActionController::Routing) mechanism such that routes can be loaded 
+# from a given plugin.
+#
+# The key method is Engines::RailsExtensions::Routing#from_plugin, which can be called 
+# within your application's <tt>config/routes.rb</tt> file to load plugin routes at that point.
+#
+module Engines::RailsExtensions::Routing
+  # Loads the set of routes from within a plugin and evaluates them at this
+  # point within an application's main <tt>routes.rb</tt> file.
+  #
+  # Plugin routes are loaded from <tt><plugin_root>/routes.rb</tt>.
+  def from_plugin(name)
+    # At the point in which routing is loaded, we cannot guarantee that all
+    #?plugins are in Rails.plugins, so instead we need to use find_plugin_path
+    path = Engines.find_plugin_path(name)
+    routes_path = File.join(path, name.to_s, "routes.rb")
+    logger.debug "loading routes from #{routes_path}"
+    eval(IO.read(routes_path), binding, routes_path) if File.file?(routes_path)
+  end
+end
+
+::ActionController::Routing::RouteSet::Mapper.send(:include, Engines::RailsExtensions::Routing)
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/templates.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/templates.rb
new file mode 100644
index 0000000..6cad6e2
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/rails_extensions/templates.rb
@@ -0,0 +1,140 @@
+# As well as providing code overloading for controllers and helpers 
+# (see Engines::RailsExtensions::Dependencies), the engines plugin also allows
+# developers to selectively override views and partials within their application.
+#
+# == An example
+#
+# This is achieved in much the same way as controller overriding. Our plugin contains
+# a view to be rendered at the URL <tt>/test/hello</tt>, in 
+# <tt>our_plugin/app/views/test/hello.rhtml</tt>:
+#
+#    <div class="greeting">Hi, <%= @dude.name %>, what's up?</div>
+#
+# If in a particular application we're not happy with this message, we can override
+# it by replacing the partial in our own application - 
+# <tt>RAILS_ROOT/app/views/test/hello.rhtml</tt>:
+#
+#     <div class="greeting custom_class">Wassup <%= @dude.name %>. 
+#                                        Waaaaassaaaaaaaaup</div>
+#
+# This view will then be rendered in favour of that in the plugin.
+#
+module Engines::RailsExtensions::Templates
+  
+  # Override the finding of partials and views. This is achieved by wrapping
+  # the (private) method #full_template_path_with_engine_additions, that checks
+  # for the given template within plugins as well as the application.
+  module ActionView
+    def self.included(base) #:nodoc:
+      base.class_eval { alias_method_chain :full_template_path, :engine_additions }
+    end
+
+    private
+      def full_template_path_with_engine_additions(template_path, extension)
+        path_in_app_directory = full_template_path_from_application(template_path, extension)
+      
+        # First check for this template in the application. If it exists, the user has
+        # overridden anything from the plugin, so use it (unless we're testing plugins;
+        # see full_template_path_from_application())
+        return path_in_app_directory if path_in_app_directory && File.exist?(path_in_app_directory)
+      
+        # Otherwise, check in the plugins to see if the template can be found there.
+        # Load this in order so that more recently started plugins will take priority.
+        Rails.plugins.by_precedence do |plugin|
+          plugin_specific_path = File.join(plugin.root, 'app', 'views',  
+                                         template_path.to_s + '.' + extension.to_s)
+          return plugin_specific_path if File.exist?(plugin_specific_path)
+        end
+
+        # If it cannot be found anywhere, return the default path.
+        return full_template_path_without_engine_additions(template_path, extension)
+      end 
+  
+      # Return a path to this template within our default app/views directory.
+      # In some circumstances, we may wish to prevent users from overloading views,
+      # such as when we are testing plugins with views. In this case, return "".
+      def full_template_path_from_application(template_path, extension)
+        if Engines.disable_application_view_loading
+          nil
+        else
+          full_template_path_without_engine_additions(template_path, extension)
+        end    
+      end
+  end
+
+
+  # The Layout module overrides a single (private) method in ActionController::Layout::ClassMethods,
+  # called #layout_list. This method now returns an array of layouts, including those in plugins.
+  module Layout
+    def self.included(base) #:nodoc:
+      base.class_eval { alias_method_chain :layout_list, :engine_additions }
+    end
+
+    private
+      # Return the list of layouts, including any in the <tt>app/views/layouts</tt>
+      # directories of loaded plugins.
+      def layout_list_with_engine_additions
+        plugin_layouts = Rails.plugins.by_precedence.map do |p| 
+          File.join(p.root, "app", "views", "layouts")
+        end
+        layout_list_without_engine_additions + Dir["{#{plugin_layouts.join(",")}}/**/*"]
+      end
+  end
+  
+  
+  # The way ActionMailer is coded in terms of finding templates is very restrictive, to the point
+  # where all templates for rendering must exist under the single base path. This is difficult to
+  # work around without re-coding significant parts of the action mailer code.
+  #
+  # ---
+  #
+  # The MailTemplates module overrides two (private) methods from ActionMailer to enable mail 
+  # templates within plugins:
+  #
+  # [+template_path+]  which now produces the contents of #template_paths
+  # [+render+]         which now find the first matching template and creates an ActionVew::Base
+  #                    instance with the correct @base_path for that template
+  module MailTemplates
+    def self.included(base) #:nodoc:
+      base.class_eval do
+        alias_method_chain :template_path, :engine_additions
+        alias_method_chain :render, :engine_additions
+      end
+    end
+
+    private    
+      # Returns all possible template paths for the current mailer, including those
+      # within the loaded plugins.
+      def template_paths
+        paths = Rails.plugins.by_precedence.map { |p| "#{p.root}/app/views/#{mailer_name}" }
+        paths.unshift(template_path_without_engine_additions) unless Engines.disable_application_view_loading
+        paths
+      end
+      
+      # Return something that Dir[] can glob against. This method is called in 
+      # ActionMailer::Base#create! and used as part of an argument to Dir. We can
+      # take advantage of this by using some of the features of Dir.glob to search
+      # multiple paths for matching files.
+      def template_path_with_engine_additions
+        "{#{template_paths.join(",")}}"
+      end
+      
+      # We've broken this up so that we can dynamically alter the base_path that ActionView
+      # is rendering from so that templates can be located from plugins.
+      def render_with_engine_additions(opts)
+        template_path_for_method = Dir["#{template_path}/#{opts[:file]}*"].first
+        body = opts.delete(:body)
+        i = initialize_template_class(body)
+        i.base_path = File.dirname(template_path_for_method)
+        i.render(opts)
+      end
+  end
+end
+
+
+::ActionView::Base.send(:include, Engines::RailsExtensions::Templates::ActionView)
+::ActionController::Layout::ClassMethods.send(:include, Engines::RailsExtensions::Templates::Layout)
+
+if Object.const_defined?(:ActionMailer) # We don't need to do this if ActionMailer hasn't been loaded.
+  ::ActionMailer::Base.send(:include, Engines::RailsExtensions::Templates::MailTemplates)
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/lib/engines/testing.rb b/client/ruby/flare/vendor/plugins/engines/lib/engines/testing.rb
new file mode 100644
index 0000000..364f992
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/lib/engines/testing.rb
@@ -0,0 +1,87 @@
+# Contains the enhancements to assist in testing plugins. See Engines::Testing
+# for more details.
+
+require 'test/unit'
+
+require 'tmpdir'
+require 'fileutils'
+
+# In most cases, Rails' own plugin testing mechanisms are sufficient. However, there
+# are cases where plugins can be given a helping hand in the testing arena. This module 
+# contains some methods to assist when testing plugins that contain fixtures.
+# 
+# == Fixtures and plugins
+#
+# Since Rails' own fixtures method is fairly strict about where files can be loaded from,
+# the simplest approach when running plugin tests with fixtures is to simply copy all
+# fixtures into a single temporary location and inform the standard Rails mechanism to
+# use this directory, rather than RAILS_ROOT/test/fixtures.
+#
+# The Engines::Testing#setup_plugin_fixtures method does this, copying all plugin fixtures
+# into the temporary location before and tests are performed. This behaviour is invoked
+# the the rake tasks provided by the Engines plugin, in the "test:plugins" namespace. If
+# necessary, you can invoke the task manually.
+#
+# If you wish to take advantage of this, add a call to the Engines::Testing.set_fixture_path
+# method somewhere before your tests (in a test_helper file, or above the TestCase itself).
+#
+# = Testing plugins
+#
+# Normally testing a plugin will require that Rails is loaded, unless you are including
+# a skeleton Rails environment or set of mocks within your plugin tests. If you require
+# the Rails environment to be started, you must ensure that this actually happens; while
+# it's not obvious, your tests do not automatically run with Rails loaded.
+#
+# The simplest way to setup plugin tests is to include a test helper with the following
+# contents:
+#
+#   # Load the normal Rails helper. This ensures the environment is loaded
+#   require File.expand_path(File.dirname(__FILE__) + '/../../../../test/test_helper')
+#   # Ensure that we are using the temporary fixture path
+#   Engines::Testing.set_fixture_path
+#
+# Then run tests using the provided tasks (<tt>test:plugins</tt>, or the tasks that the engines
+# plugin provides - <tt>test:plugins:units</tt>, etc.).
+#
+# Alternatively, you can explicitly load the environment by adpating the contents of the
+# default <tt>test_helper</tt>:
+#
+#   ENV["RAILS_ENV"] = "test"
+#   # Note that we are requiring config/environment from the root of the enclosing application.
+#   require File.expand_path(File.dirname(__FILE__) + "/../../../../config/environment")
+#   require 'test_help'
+#
+module Engines::Testing
+  mattr_accessor :temporary_fixtures_directory
+  self.temporary_fixtures_directory = FileUtils.mkdir_p(File.join(Dir.tmpdir, "rails_fixtures"))
+  
+  # Copies fixtures from plugins and the application into a temporary directory 
+  # (Engines::Testing.temporary_fixtures_directory). 
+  # 
+  # If a set of plugins is not given, fixtures are copied from all plugins in order 
+  # of precedence, meaning that plugins can 'overwrite' the fixtures of others if they are 
+  # loaded later; the application's fixtures are copied last, allowing any custom fixtures
+  # to override those in the plugins. If no argument is given, plugins are loaded via
+  # PluginList#by_precedence.
+  #
+  # This method is called by the engines-supplied plugin testing rake tasks
+  def self.setup_plugin_fixtures(plugins=Rails.plugins.by_precedence)
+    
+    # Copy all plugin fixtures, and then the application fixtures, into this directory
+    plugins.each do |plugin| 
+      plugin_fixtures_directory =  File.join(plugin.root, "test", "fixtures")
+      if File.directory?(plugin_fixtures_directory)
+        Engines.mirror_files_from(plugin_fixtures_directory, self.temporary_fixtures_directory)
+      end
+    end
+    Engines.mirror_files_from(File.join(RAILS_ROOT, "test", "fixtures"),
+                              self.temporary_fixtures_directory)
+  end
+  
+  # Sets the fixture path used by Test::Unit::TestCase to the temporary
+  # directory which contains all plugin fixtures.
+  def self.set_fixture_path
+    Test::Unit::TestCase.fixture_path = self.temporary_fixtures_directory
+    $LOAD_PATH.unshift self.temporary_fixtures_directory
+  end
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/engines/tasks/engines.rake b/client/ruby/flare/vendor/plugins/engines/tasks/engines.rake
new file mode 100644
index 0000000..1d64435
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/engines/tasks/engines.rake
@@ -0,0 +1,149 @@
+# This code lets us redefine existing Rake tasks, which is extremely
+# handy for modifying existing Rails rake tasks.
+# Credit for this snippet of code goes to Jeremy Kemper
+# http://pastie.caboo.se/9620
+unless Rake::TaskManager.methods.include?(:redefine_task)
+  module Rake
+    module TaskManager
+      def redefine_task(task_class, args, &block)
+        task_name, deps = resolve_args(args)
+        task_name = task_class.scope_name(@scope, task_name)
+        deps = [deps] unless deps.respond_to?(:to_ary)
+        deps = deps.collect {|d| d.to_s }
+        task = @tasks[task_name.to_s] = task_class.new(task_name, self)
+        task.application = self
+        task.add_comment(@last_comment)
+        @last_comment = nil
+        task.enhance(deps, &block)
+        task
+      end
+    end
+    class Task
+      class << self
+        def redefine_task(args, &block)
+          Rake.application.redefine_task(self, args, &block)
+        end
+      end
+    end
+  end
+end
+
+
+namespace :db do  
+  namespace :fixtures do
+    namespace :plugins do
+      
+      desc "Load plugin fixtures into the current environment's database."
+      task :load => :environment do
+        require 'active_record/fixtures'
+        ActiveRecord::Base.establish_connection(RAILS_ENV.to_sym)
+        Dir.glob(File.join(RAILS_ROOT, 'vendor', 'plugins', ENV['PLUGIN'] || '**', 
+                 'test', 'fixtures', '*.yml')).each do |fixture_file|
+          Fixtures.create_fixtures(File.dirname(fixture_file), File.basename(fixture_file, '.*'))
+        end
+      end
+      
+    end
+  end
+end
+
+# this is just a modification of the original task in railties/lib/tasks/documentation.rake, 
+# because the default task doesn't support subdirectories like <plugin>/app or
+# <plugin>/component. These tasks now include every file under a plugin's code paths (see
+# Plugin#code_paths).
+namespace :doc do
+
+  plugins = FileList['vendor/plugins/**'].collect { |plugin| File.basename(plugin) }
+
+  namespace :plugins do
+
+    # Define doc tasks for each plugin
+    plugins.each do |plugin|
+      desc "Create plugin documentation for '#{plugin}'"
+      Rake::Task.redefine_task(plugin => :environment) do
+        plugin_base   = RAILS_ROOT + "/vendor/plugins/#{plugin}"
+        options       = []
+        files         = Rake::FileList.new
+        options << "-o doc/plugins/#{plugin}"
+        options << "--title '#{plugin.titlecase} Plugin Documentation'"
+        options << '--line-numbers' << '--inline-source'
+        options << '-T html'
+
+        # Include every file in the plugin's code_paths (see Plugin#code_paths)
+        if Rails.plugins[plugin]
+          files.include("#{plugin_base}/{#{Rails.plugins[plugin].code_paths.join(",")}}/**/*.rb")
+        end
+        if File.exists?("#{plugin_base}/README")
+          files.include("#{plugin_base}/README")    
+          options << "--main '#{plugin_base}/README'"
+        end
+        files.include("#{plugin_base}/CHANGELOG") if File.exists?("#{plugin_base}/CHANGELOG")
+
+        if files.empty?
+          puts "No source files found in #{plugin_base}. No documentation will be generated."
+        else
+          options << files.to_s
+          sh %(rdoc #{options * ' '})
+        end
+      end
+    end
+  end
+end
+
+
+
+namespace :test do
+  task :warn_about_multiple_plugin_testing_with_engines do
+    puts %{-~============== A Moste Polite Warninge ===========================~-
+
+You may experience issues testing multiple plugins at once when using
+the code-mixing features that the engines plugin provides. If you do
+experience any problems, please test plugins individually, i.e.
+
+  $ rake test:plugins PLUGIN=my_plugin
+
+or use the per-type plugin test tasks:
+
+  $ rake test:plugins:units
+  $ rake test:plugins:functionals
+  $ rake test:plugins:integration
+  $ rake test:plugins:all
+
+Report any issues on http://dev.rails-engines.org. Thanks!
+
+-~===============( ... as you were ... )============================~-}
+  end
+  
+  namespace :plugins do
+
+    desc "Run the plugin tests in vendor/plugins/**/test (or specify with PLUGIN=name)"
+    task :all => [:warn_about_multiple_plugin_testing_with_engines, 
+                  :units, :functionals, :integration]
+    
+    desc "Run all plugin unit tests"
+    Rake::TestTask.new(:units => :setup_plugin_fixtures) do |t|
+      t.pattern = "vendor/plugins/#{ENV['PLUGIN'] || "**"}/test/unit/**/*_test.rb"
+      t.verbose = true
+    end
+    
+    desc "Run all plugin functional tests"
+    Rake::TestTask.new(:functionals => :setup_plugin_fixtures) do |t|
+      t.pattern = "vendor/plugins/#{ENV['PLUGIN'] || "**"}/test/functional/**/*_test.rb"
+      t.verbose = true
+    end
+    
+    desc "Integration test engines"
+    Rake::TestTask.new(:integration => :setup_plugin_fixtures) do |t|
+      t.pattern = "vendor/plugins/#{ENV['PLUGIN'] || "**"}/test/integration/**/*_test.rb"
+      t.verbose = true
+    end
+
+    desc "Mirrors plugin fixtures into a single location to help plugin tests"
+    task :setup_plugin_fixtures => :environment do
+      Engines::Testing.setup_plugin_fixtures
+    end
+    
+    # Patch the default plugin testing task to have setup_plugin_fixtures as a prerequisite
+    Rake::Task["test:plugins"].prerequisites << "test:plugins:setup_plugin_fixtures"
+  end  
+end
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/flare/app/controllers/browse_controller.rb b/client/ruby/flare/vendor/plugins/flare/app/controllers/browse_controller.rb
new file mode 100644
index 0000000..173d798
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/controllers/browse_controller.rb
@@ -0,0 +1,15 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+class BrowseController < ApplicationController
+  flare
+end
diff --git a/client/ruby/flare/vendor/plugins/flare/app/controllers/document_controller.rb b/client/ruby/flare/vendor/plugins/flare/app/controllers/document_controller.rb
new file mode 100755
index 0000000..48290af
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/controllers/document_controller.rb
@@ -0,0 +1,17 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+class DocumentController < ApplicationController
+  # Currently not used, as partials are used for rendering documents in search results
+  # TODO: how best to allow pluggable document rendering?
+end
diff --git a/client/ruby/flare/vendor/plugins/flare/app/controllers/simile_controller.rb b/client/ruby/flare/vendor/plugins/flare/app/controllers/simile_controller.rb
new file mode 100755
index 0000000..ae78a43
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/controllers/simile_controller.rb
@@ -0,0 +1,47 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+class SimileController < ApplicationController
+  before_filter :flare_before
+  
+  def exhibit
+    @data = @flare.search(0, 10)
+                                          
+    # Exhibit seems to require a label attribute to be happy
+    @data.each {|d| d['label'] = d['title_text']}
+    
+    respond_to do |format| 
+      format.html # renders exhibit.rhtml 
+      format.json { render :json => {'items' => @data}.to_json } # Exhibit seems to require data to be in a 'items' Hash
+    end                                         
+  end
+  
+  def timeline
+    @data = @flare.search(0, 10)
+                                              
+    respond_to do |format| 
+      format.html # renders timeline.rhtml 
+      format.xml # renders timeline.rxml
+    end                                         
+  end
+  
+  #TODO: this is duplicated from flare's 
+  private
+    def flare_before
+      # TODO: allow source of context to be configurable.
+      session[:flare_context] ||= Flare::Context.new(SOLR_CONFIG)
+
+      @flare = session[:flare_context]
+    end
+  
+end
diff --git a/client/ruby/flare/vendor/plugins/flare/app/views/browse/index.rhtml b/client/ruby/flare/vendor/plugins/flare/app/views/browse/index.rhtml
new file mode 100755
index 0000000..20e4d24
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/views/browse/index.rhtml
@@ -0,0 +1,109 @@
+<div id="sidebar"><div class="boxContent">
+	<div class="searchbar">
+  <% form_tag(:action=>'add_query') do %>
+    <%= text_field_with_auto_complete :search, :query %>
+    <%=submit_tag "search"%>
+  <% end %>
+	</div>
+<!-- <h2>browse facets</h2> -->
+
+<% if @flare.facet_queries.size > 0%>
+<h4>
+  saved searches
+</h4>
+<ul>
+<% @flare.facet_queries.each do |name,value|
+     count = @response.data['facet_counts']['facet_queries'][value[:real_query]]
+%>
+<li>
+  <%= image_tag "pie_#{(count * 100.0 / @response.total_hits).ceil rescue 0}.png"%>
+  <%= link_to "#{name} (#{count})", {:action => 'add_saved_search', :name=>name}, {:title => value.inspect}%>
+  <%= link_to "*", {:action => 'show_saved', :name => name}, {:target => '_blank'}%>
+  <%=link_to image_tag("x-close.gif"), :action => :remove_saved_search, :name => name %>
+</li>
+<% end %>
+</ul>
+<% end %>
+<% @flare.facet_fields.each do |field|%>
+  <h4> 
+<%= facet_label(field)%> <%=link_to "[browse]", :action => 'facet', :field => field%> 
+<!-- <%=link_to field, :action => 'facet', :field => field%> -->
+</h4> 
+
+  <ul>
+  <% @response.field_facets(field).each do |f| %>
+    <li>
+      <%= image_tag "pie_#{(f.value * 100.0 / @response.total_hits).ceil}.png"%>
+      <%= link_to "#{f.name} (#{f.value})", :action => 'add_filter', :field=>field, :value=>f.name%>
+    </li>
+  <% end %>
+  </ul>
+<% end %>
+<span class="exhibit"><%=link_to image_tag("simile-exhibit.png"), :controller => :simile, :action => :exhibit %></span>
+</div></div> 
+
+<div id="variables">
+	<div class="clear">
+		<%=link_to '[clear constraints]', :action => 'clear'%>
+	</div>
+	
+<div>
+  <span class="varheader">Saved searches:</span>
+  	<div id="queries">
+      <% @flare.applied_facet_queries.each_with_index do |q, i| %>
+            <%=link_to q[:negative] ? "-" : "+", :action => :invert_saved_constraint, :index => i%>
+            <%=q[:name]%>
+            <%=link_to image_tag("x-close.gif"), :action => :remove_saved_constraint, :index => i %><br/>
+      <% end %>
+    </div>
+<span class="varheader">Queries:</span>
+	<div id="queries">
+<% @flare.queries.each_with_index do |q,i| %>
+<%=link_to q[:negative] ? "-" : '+', :action => :invert_query, :index => i%>
+<span id="query_<%=i%>"><%=q[:query]%></span>
+<%= in_place_editor "query_#{i}", :url=> url_for(:action=>"update_query", :index=>i, :script=>true) %>
+<%=link_to image_tag("x-close.gif"), :action => :remove_query, :index => i %><br/>
+<% end %>
+	</div>
+</div>
+
+<div>
+<span class="varheader">Filters:</span>
+	<div id="filters">
+<% @flare.filters.each_with_index do |filter, i| %>
+      <%=link_to filter[:negative] ? "-" : "+", :action => :invert_filter, :index => i%>
+      <%=filter[:field]%>:<%=filter[:value]%>
+      <%=link_to image_tag("x-close.gif"), :action => :remove_filter, :index => i %><br/>
+<% end %>
+	</div>
+</div>
+
+<div class="clear">
+	<%=link_to '[clear constraints]', :action => 'clear'%>
+</div>
+
+<% form_tag({:action=>'save'},{:id => 'savesearch', :style => "display:none;"}) do %>
+  <%= text_field_tag :name, "", {:size => 10, :id => "savesearch_name"} %>
+  <%= link_to_function "save", "document.forms['savesearch'].submit();" -%>
+  <%= link_to_function "cancel", "Element.toggle('savesearch'); Element.toggle('savesearch_link')" -%>
+<% end %>
+<%= link_to_function "[save these constraints]", "Element.toggle('savesearch'); Element.toggle('savesearch_link'); $('savesearch_name').focus()", {:id => "savesearch_link"} -%>
+
+</div>
+
+<% if @flare.empty_constraints? %>
+  search or facet to see results
+<% else %>
+
+<div class="resultsheader">Results <strong><%=[@start + 1,@response.total_hits].min%>-<%=[@response.total_hits,@results_per_page + @start].min%></strong> of <strong><%=@response.total_hits%></strong></div>
+
+<div id="results"><table cellpadding="10">
+  <% @response.each do |doc| %>
+    <%= render :partial => "document/document_#{SOLR_ENV}", :locals => {:doc => doc, :response => @response}%>  
+  <% end %>
+</table>
+</div>
+
+<div class="resultsheader"><%=link_to_if @flare.page != 1,  "<<", :page => @flare.page - 1%> Results <strong><%=[@start + 1,@response.total_hits].min%>-<%=[@response.total_hits,@results_per_page + @start].min%></strong> of <strong><%=@response.total_hits%></strong><%=link_to_if @flare.page < (@response.total_hits.to_f / @results_per_page).ceil, ">>", :page => @flare.page + 1%></div>
+
+<% end %>
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/flare/app/views/document/_document_development.rhtml b/client/ruby/flare/vendor/plugins/flare/app/views/document/_document_development.rhtml
new file mode 100755
index 0000000..6d25c47
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/views/document/_document_development.rhtml
@@ -0,0 +1,12 @@
+<tr valign="top">
+  <td>
+    <table class="entry">
+      <tr>
+        <td class="title" colspan="2"><%=doc['title_text']%></td>
+      </tr>
+      <% doc.each do |k,v|; highlighting = response.highlighted(doc['id'], k) %>
+      <tr><td class="field"><%=k%>:</td><td><%= highlighting ? "...#{highlighting}..." : (v.respond_to?('join') ? v.join(',') : v.to_s)%></td></tr>
+      <% end %>
+    </table>
+  </td>
+</tr>
diff --git a/client/ruby/flare/vendor/plugins/flare/app/views/simile/exhibit.rhtml b/client/ruby/flare/vendor/plugins/flare/app/views/simile/exhibit.rhtml
new file mode 100644
index 0000000..8a39fac
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/views/simile/exhibit.rhtml
@@ -0,0 +1,24 @@
+<html>
+    <head>
+        <title>SIMILE Exhibit view</title>
+
+        <link href="exhibit.json" type="application/json" rel="exhibit/data" />
+
+        <script src="http://static.simile.mit.edu/exhibit/api/exhibit-api.js"
+            type="text/javascript"></script>
+    </head> 
+    <body>
+    <h1>SIMILE Exhibit view</h1>
+    <table width="100%">
+        <tr valign="top">
+            <td>
+                <div id="exhibit-control-panel"></div>
+                <div id="exhibit-view-panel"></div>
+            </td>
+            <td width="25%">
+                <div id="exhibit-browse-panel" ex:facets="<%= @flare.facet_fields.collect {|f| ".#{f}"}.join(',') -%>"></div>
+            </td>
+        </tr>
+    </table>
+    </body>
+    </html>
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rhtml b/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rhtml
new file mode 100755
index 0000000..d8119ad
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rhtml
@@ -0,0 +1,46 @@
+<html>
+  <head>
+    ...
+    <script src="http://simile.mit.edu/timeline/api/timeline-api.js" type="text/javascript"></script>
+    <script type="text/javascript">
+    var tl;
+    function onLoad() {
+      var eventSource = new Timeline.DefaultEventSource();
+      var bandInfos = [
+        Timeline.createBandInfo({
+            eventSource:    eventSource,
+            date:           "Jun 28 2006 00:00:00 GMT",
+            width:          "70%", 
+            intervalUnit:   Timeline.DateTime.DECADE, 
+            intervalPixels: 200
+        }),
+        Timeline.createBandInfo({
+            eventSource:    eventSource,
+            date:           "Jun 28 2006 00:00:00 GMT",
+            width:          "30%", 
+            intervalUnit:   Timeline.DateTime.YEAR, 
+            intervalPixels: 200
+        })
+      ];
+      bandInfos[0].syncWith = 1;
+      bandInfos[0].highlight = true;
+
+      tl = Timeline.create(document.getElementById("my-timeline"), bandInfos);
+      Timeline.loadXML("timeline.xml", function(xml, url) { eventSource.loadXML(xml, url); });
+    }
+    
+    var resizeTimerID = null;
+    function onResize() {
+        if (resizeTimerID == null) {
+            resizeTimerID = window.setTimeout(function() {
+                resizeTimerID = null;
+                tl.layout();
+            }, 500);
+        }
+    }
+    </script>
+  </head>
+  <body onload="onLoad();" onresize="onResize();">
+    <div id="my-timeline" style="height: 300px; border: 1px solid #aaa"></div>
+  </body>
+</html>
diff --git a/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rxml b/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rxml
new file mode 100755
index 0000000..d3d2518
--- /dev/null
+++ b/client/ruby/flare/vendor/plugins/flare/app/views/simile/timeline.rxml
@@ -0,0 +1,50 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+xml.data do 
+  @data.each do |doc| 
+    xml.event(doc['title_text'],
+      :start => doc[SOLR_CONFIG[:timeline_dates].to_s],
+      :end => doc[SOLR_CONFIG[:timeline_dates].to_s],
+      :title => doc['title_text'],
+      :image => SOLR_CONFIG[:image_proc] ? SOLR_CONFIG[:image_proc].call(doc) : nil)
+  end
+end
+
+# Amazon images: http://www.betaversion.org/~stefano/linotype/news/66/
+# <data>
+#     <event 
+#         start="May 28 2006 09:00:00 GMT"
+#         end="Jun 15 2006 09:00:00 GMT"
+#         isDuration="true"
+#         title="Writing Timeline documentation"
+#         image="http://simile.mit.edu/images/csail-logo.gif"
+#         >
+#         A few days to write some documentation for &lt;a href="http://simile.mit.edu/timeline/"&gt;Timeline&lt;/a&gt;.
+#         </event>
+#         
+#     <event 
+#         start="Jun 16 2006 00:00:00 GMT"
+#         end="Jun 26 2006 00:00:00 GMT"
+#         title="Friend's wedding"
+#         >
+#         I'm not sure precisely when my friend's wedding is.
+#         </event>
+#         
+#     <event 
+#         start="Aug 02 2006 00:00:00 GMT"
+#         title="Trip to Beijing"
+#         link="http://travel.yahoo.com/"
+#         >
+#         Woohoo!
+#         </event>
+# </data>
\ No newline at end of file
diff --git a/client/ruby/flare/vendor/plugins/flare/lib/flare/context.rb b/client/ruby/flare/vendor/plugins/flare/lib/flare/context.rb
index 879cc38..e02b966 100644
--- a/client/ruby/flare/vendor/plugins/flare/lib/flare/context.rb
+++ b/client/ruby/flare/vendor/plugins/flare/lib/flare/context.rb
@@ -55,6 +55,7 @@ class Flare::Context
   end
 
   def search(start=0, max=25)
+    # TODO: Allow the search method to facilitate acts_as_solr somehow too
     facet_queries = @facet_queries.collect do |k,v|
       clauses = filter_queries(v[:filters])
       clauses << build_boolean_query(v[:queries])

