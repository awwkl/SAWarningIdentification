GitDiffStart: a5ae2b0e9da0c47944108c20f365a7e0f491e586 | Wed Feb 22 07:54:32 2012 +0000
diff --git a/lucene/contrib/spatial/build.xml b/lucene/contrib/spatial/build.xml
deleted file mode 100644
index 37ca1fa..0000000
--- a/lucene/contrib/spatial/build.xml
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0"?>
-
-<!--
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements.  See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version 2.0
-    the "License"); you may not use this file except in compliance with
-    the License.  You may obtain a copy of the License at
- 
-        http://www.apache.org/licenses/LICENSE-2.0
- 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
- -->
-
-<project name="spatial" default="default">
-
-  <description>
-    Lucene Spatial Indexing
-  </description>
-
-  <import file="../contrib-build.xml"/>
-
-  <path id="classpath">
-    <pathelement path="${queries.jar}"/>
-    <path refid="base.classpath"/>
-  </path>
-
-  <target name="compile-core" depends="jar-queries, common.compile-core" />
-</project>
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java
deleted file mode 100644
index 9ba4ba8..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java
+++ /dev/null
@@ -1,465 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial;
-
-import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
-import org.apache.lucene.spatial.geometry.LatLng;
-import org.apache.lucene.spatial.geometry.shape.LLRect;
-import org.apache.lucene.spatial.geometry.shape.Rectangle;
-import org.apache.lucene.spatial.tier.InvalidGeoException;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-
-public class DistanceUtils {
-
-  public static final double DEGREES_TO_RADIANS = Math.PI / 180.0;
-  public static final double RADIANS_TO_DEGREES = 180.0 / Math.PI;
-  //pre-compute some angles that are commonly used
-  public static final double DEG_45_AS_RADS = Math.PI / 4.0;
-  public static final double SIN_45_AS_RADS = Math.sin(DEG_45_AS_RADS);
-  public static final double DEG_90_AS_RADS = Math.PI / 2;
-  public static final double DEG_180_AS_RADS = Math.PI;
-  public static final double DEG_225_AS_RADS = 5 * DEG_45_AS_RADS;
-  public static final double DEG_270_AS_RADS = 3*DEG_90_AS_RADS;
-
-
-  public static final double KM_TO_MILES = 0.621371192;
-  public static final double MILES_TO_KM = 1.609344;
-    /**
-   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
-   *
-   * [1] http://en.wikipedia.org/wiki/Earth_radius
-   */
-  public static final double EARTH_MEAN_RADIUS_KM = 6371.009;
-
-  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM / MILES_TO_KM;
-
-  public static final double EARTH_EQUATORIAL_RADIUS_MI = 3963.205;
-  public static final double EARTH_EQUATORIAL_RADIUS_KM = EARTH_EQUATORIAL_RADIUS_MI * MILES_TO_KM;
-
-
-  public static double getDistanceMi(double x1, double y1, double x2, double y2) {
-    return getLLMDistance(x1, y1, x2, y2);
-  }
-
-  /**
-   * 
-   * @param x1
-   * @param y1
-   * @param miles
-   * @return boundary rectangle where getY/getX is top left, getMinY/getMinX is bottom right
-   */
-  public static Rectangle getBoundary (double x1, double y1, double miles) {
-
-    LLRect box = LLRect.createBox( new FloatLatLng( x1, y1 ), miles, miles );
-    
-    //System.out.println("Box: "+maxX+" | "+ maxY+" | "+ minX + " | "+ minY);
-    return box.toRectangle();
-
-  }
-  
-  public static double getLLMDistance (double x1, double y1, double x2, double y2) {
-
-    LatLng p1 = new FloatLatLng( x1, y1 );
-    LatLng p2 = new FloatLatLng( x2, y2 );
-    return p1.arcDistance( p2, DistanceUnits.MILES );
-  }
-
-  /**
-   * distance/radius.
-   * @param distance The distance travelled
-   * @param radius The radius of the sphere
-   * @return The angular distance, in radians
-   */
-  public static double angularDistance(double distance, double radius){
-    return distance/radius;
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) beteen two vectors
-   *
-   * @param vec1  The first vector
-   * @param vec2  The second vector
-   * @param power The power (2 for Euclidean distance, 1 for manhattan, etc.)
-   * @return The length.
-   *         <p/>
-   *         See http://en.wikipedia.org/wiki/Lp_space
-   * @see #vectorDistance(double[], double[], double, double)
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
-    return vectorDistance(vec1, vec2, power, 1.0 / power);
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1         The first vector
-   * @param vec2         The second vector
-   * @param power        The power (2 for Euclidean distance, 1 for manhattan, etc.)
-   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
-   * @return The length.
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
-    double result = 0;
-
-    if (power == 0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
-      }
-
-    } else if (power == 1.0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i];
-      }
-    } else if (power == 2.0) {
-      result = Math.sqrt(squaredEuclideanDistance(vec1, vec2));
-    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
-      for (int i = 0; i < vec1.length; i++) {
-        result = Math.max(result, Math.max(vec1[i], vec2[i]));
-      }
-    } else {
-      for (int i = 0; i < vec1.length; i++) {
-        result += Math.pow(vec1[i] - vec2[i], power);
-      }
-      result = Math.pow(result, oneOverPower);
-    }
-    return result;
-  }
-
-  /**
-   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
-   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximatation).
-   *
-   * @param center     The center point
-   * @param result Holds the result, potentially resizing if needed.
-   * @param distance   The d from the center to the corner
-   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
-   * @return The point, either the upperLeft or the lower right
-   */
-  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
-    if (result == null || result.length != center.length) {
-      result = new double[center.length];
-    }
-    if (upperRight == false) {
-      distance = -distance;
-    }
-    //We don't care about the power here,
-    // b/c we are always in a rectangular coordinate system, so any norm can be used by
-    //using the definition of sine
-    distance = SIN_45_AS_RADS * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarily for cosine
-    for (int i = 0; i < center.length; i++) {
-      result[i] = center[i] + distance;
-    }
-    return result;
-  }
-
-  /**
-   * @param latCenter  In degrees
-   * @param lonCenter  In degrees
-   * @param distance The distance
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @param upperRight If true, calculate the upper right corner, else the lower left
-   * @param sphereRadius The radius of the sphere to use.
-   * @return The Lat/Lon in degrees
-   *
-   * @see #latLonCorner(double, double, double, double[], boolean, double)
-   */
-  public static double[] latLonCornerDegs(double latCenter, double lonCenter,
-                                          double distance, double [] result,
-                                          boolean upperRight, double sphereRadius) {
-    result = latLonCorner(latCenter * DEGREES_TO_RADIANS,
-            lonCenter * DEGREES_TO_RADIANS, distance, result, upperRight, sphereRadius);
-    result[0] = result[0] * RADIANS_TO_DEGREES;
-    result[1] = result[1] * RADIANS_TO_DEGREES;
-    return result;
-  }
-
-  /**
-   * Uses Haversine to calculate the corner of a box (upper right or lower left) that is the <i>distance</i> away, given a sphere of the specified <i>radius</i>.
-   *
-   * NOTE: This is not the same as calculating a box that transcribes a circle of the given distance.
-   *
-   * @param latCenter  In radians
-   * @param lonCenter  In radians
-   * @param distance   The distance
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @param upperRight If true, give lat/lon for the upper right corner, else lower left
-   * @param sphereRadius     The radius to use for the calculation
-   * @return The Lat/Lon in Radians
-
-   */
-  public static double[] latLonCorner(double latCenter, double lonCenter,
-                                      double distance, double [] result, boolean upperRight, double sphereRadius) {
-    // Haversine formula
-    double brng = upperRight ? DEG_45_AS_RADS : DEG_225_AS_RADS;
-    result = pointOnBearing(latCenter, lonCenter, distance, brng, result, sphereRadius);
-
-    return result;
-  }
-
-  /**
-   * Given a start point (startLat, startLon) and a bearing on a sphere of radius <i>sphereRadius</i>, return the destination point.
-   * @param startLat The starting point latitude, in radians
-   * @param startLon The starting point longitude, in radians
-   * @param distance The distance to travel along the bearing.  The units are assumed to be the same as the sphereRadius units, both of which is up to the caller to know
-   * @param bearing The bearing, in radians.  North is a 0 deg. bearing, east is 90 deg, south is 180 deg, west is 270 deg. 
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @param sphereRadius The radius of the sphere to use for the calculation.
-   * @return The destination point, in radians.  First entry is latitude, second is longitude
-   */
-  public static double[] pointOnBearing(double startLat, double startLon, double distance, double bearing, double[] result, double sphereRadius) {
-    /*
- 	lat2 = asin(sin(lat1)*cos(d/R) + cos(lat1)*sin(d/R)*cos(θ))
-  	lon2 = lon1 + atan2(sin(θ)*sin(d/R)*cos(lat1), cos(d/R)??in(lat1)*sin(lat2))    
-
-     */
-    double cosAngDist = Math.cos(distance / sphereRadius);
-    double cosStartLat = Math.cos(startLat);
-    double sinAngDist = Math.sin(distance / sphereRadius);
-    double lat2 = Math.asin(Math.sin(startLat) * cosAngDist +
-            cosStartLat * sinAngDist * Math.cos(bearing));
-    
-    double lon2 = startLon + Math.atan2(Math.sin(bearing) * sinAngDist * cosStartLat,
-            cosAngDist - Math.sin(startLat) * Math.sin(lat2));
-
-    /*lat2 = (lat2*180)/Math.PI;
-    lon2 = (lon2*180)/Math.PI;*/
-    //From Lucene.  Move back to Lucene when synced
-    // normalize long first
-    if (result == null || result.length != 2){
-      result = new double[2];
-    }
-    result[0] = lat2;
-    result[1] = lon2;
-    normLng(result);
-
-    // normalize lat - could flip poles
-    normLat(result);
-    return result;
-  }
-
-  /**
-   * @param latLng The lat/lon, in radians. lat in position 0, long in position 1
-   */
-  public static void normLat(double[] latLng) {
-
-    if (latLng[0] > DEG_90_AS_RADS) {
-      latLng[0] = DEG_90_AS_RADS - (latLng[0] - DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    } else if (latLng[0] < -DEG_90_AS_RADS) {
-      latLng[0] = -DEG_90_AS_RADS - (latLng[0] + DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    }
-
-  }
-
-  /**
-   * Returns a normalized Lng rectangle shape for the bounding box
-   *
-   * @param latLng The lat/lon, in radians, lat in position 0, long in position 1
-   */
-  public static void normLng(double[] latLng) {
-    if (latLng[1] > DEG_180_AS_RADS) {
-      latLng[1] = -1.0 * (DEG_180_AS_RADS - (latLng[1] - DEG_180_AS_RADS));
-    } else if (latLng[1] < -DEG_180_AS_RADS) {
-      latLng[1] = (latLng[1] + DEG_180_AS_RADS) + DEG_180_AS_RADS;
-    }
-  }
-
-  /**
-   * The square of the Euclidean Distance.  Not really a distance, but useful if all that matters is
-   * comparing the result to another one.
-   *
-   * @param vec1 The first point
-   * @param vec2 The second point
-   * @return The squared Euclidean distance
-   */
-  public static double squaredEuclideanDistance(double[] vec1, double[] vec2) {
-    double result = 0;
-    for (int i = 0; i < vec1.length; i++) {
-      double v = vec1[i] - vec2[i];
-      result += v * v;
-    }
-    return result;
-  }
-
-  /**
-   * Computes the haversine distance between two points. The arguments are in radians and provided in lat,lon order.
-   * @param y1     The y coordinate of the first point, in radians
-   * @param x1     The x coordinate of the first point, in radians
-   * @param y2     The y coordinate of the second point, in radians
-   * @param x2     The x coordinate of the second point, in radians
-   * @param radius The radius of the sphere
-   * @return The distance between the two points, as determined by the haversine formula.
-   */
-  public static double haversine(double y1, double x1, double y2, double x2, double radius) {
-    double result = 0;
-    //make sure they aren't all the same, as then we can just return 0
-    if ((x1 != x2) || (y1 != y2)) {
-      double diffX = x1 - x2;
-      double diffY = y1 - y2;
-      double hsinX = Math.sin(diffX * 0.5);
-      double hsinY = Math.sin(diffY * 0.5);
-      double h = hsinY * hsinY +
-          (Math.cos(y1) * Math.cos(y2) * hsinX * hsinX);
-      result = (radius * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)));
-    }
-    return result;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws org.apache.lucene.spatial.tier.InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidGeoException {
-    //TODO: Should we support sparse vectors?
-    if (out == null || out.length != dimension) out = new String[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = externalVal.trim();
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = externalVal.substring(start, end);
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidGeoException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidGeoException{
-    if (out == null || out.length != dimension) out = new double[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = Double.parseDouble(externalVal.trim());
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        //TODO: abstract common code with other parsePoint
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = Double.parseDouble(externalVal.substring(start, end));
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidGeoException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidGeoException {
-    return parseLatitudeLongitude(null, latLonStr);
-  }
-
-  /**
-   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
-   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
-   * <p/>
-   * The latitude is assumed to be the first part of the string and the longitude the second part.
-   *
-   * @param latLon    A preallocated array to hold the result
-   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
-   * @return The lat long
-   * @throws InvalidGeoException if there was an error parsing
-   */
-  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidGeoException {
-    if (latLon == null) {
-      latLon = new double[2];
-    }
-    double[] toks = parsePointDouble(null, latLonStr, 2);
-
-    if (toks[0] < -90.0 || toks[0] > 90.0) {
-      throw new InvalidGeoException(
-              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
-                      + toks[0] + "]");
-    }
-    latLon[0] = toks[0];
-
-
-    if (toks[1] < -180.0 || toks[1] > 180.0) {
-
-      throw new InvalidGeoException(
-              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
-                      + toks[1] + "]");
-    }
-    latLon[1] = toks[1];
-
-    return latLon;
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
deleted file mode 100644
index 73ce615..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geohash;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.FieldCache.DocTerms;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.FilteredDocIdSet;
-import org.apache.lucene.spatial.DistanceUtils;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.spatial.tier.DistanceFilter;
-
-
-/** <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-
-public class GeoHashDistanceFilter extends DistanceFilter {
-  
-  private double lat;
-  private double lng;
-  private String geoHashField;
-  
-  /**
-   * Provide a distance filter based from a center point with a radius
-   * in miles
-   * @param startingFilter
-   * @param lat
-   * @param lng
-   * @param miles
-   */
-  public GeoHashDistanceFilter(Filter startingFilter, double lat, double lng, double miles, String geoHashField) {
-    super(startingFilter, miles);
-    this.lat = lat;
-    this.lng = lng;
-    this.geoHashField = geoHashField;
-  }
-
-  @Override
-  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {
-
-    final DocTerms geoHashValues = FieldCache.DEFAULT.getTerms(context.reader(), geoHashField);
-    final BytesRef br = new BytesRef();
-
-    final int docBase = nextDocBase;
-    nextDocBase += context.reader().maxDoc();
-
-    return new FilteredDocIdSet(startingFilter.getDocIdSet(context, acceptDocs)) {
-      @Override
-      public boolean match(int doc) {
-
-        // TODO: cutover to BytesRef so we don't have to
-        // make String here
-        String geoHash = geoHashValues.getTerm(doc, br).utf8ToString();
-        double[] coords = GeoHashUtils.decode(geoHash);
-        double x = coords[0];
-        double y = coords[1];
-      
-        // round off lat / longs if necessary
-        //      x = DistanceHandler.getPrecision(x, precise);
-        //      y = DistanceHandler.getPrecision(y, precise);
-        Double cachedDistance = distanceLookupCache.get(geoHash);
-        double d;
-      
-        if (cachedDistance != null) {
-          d = cachedDistance.doubleValue();
-        } else {
-          d = DistanceUtils.getDistanceMi(lat, lng, x, y);
-          distanceLookupCache.put(geoHash, d);
-        }
-
-        if (d < distance){
-          distances.put(doc+docBase, d);
-          return true;
-        } else {
-          return false;
-        }
-      }
-    };
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof GeoHashDistanceFilter)) return false;
-    GeoHashDistanceFilter other = (GeoHashDistanceFilter) o;
-
-    if (!this.startingFilter.equals(other.startingFilter) ||
-        this.distance != other.distance ||
-        this.lat != other.lat ||
-        this.lng != other.lng ||
-        !this.geoHashField.equals(other.geoHashField) ) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns a hash code value for this object.*/
-  @Override
-  public int hashCode() {
-    int h = Double.valueOf(distance).hashCode();
-    h ^= startingFilter.hashCode();
-    h ^= Double.valueOf(lat).hashCode();
-    h ^= Double.valueOf(lng).hashCode();
-    h ^= geoHashField.hashCode();
-    
-    return h;
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashUtils.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashUtils.java
deleted file mode 100644
index 5ace9ad..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashUtils.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geohash;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Utilities for encoding and decoding geohashes. Based on
- * <a href="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</a>.
- */
-public class GeoHashUtils {
-
-  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
-      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
-      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
-
-  private final static Map<Character,Integer> DECODE_MAP = new HashMap<Character,Integer>();
-
-  private static final int PRECISION = 12;
-  private static final int[] BITS = {16, 8, 4, 2, 1};
-
-  static {
-    for (int i = 0; i < BASE_32.length; i++) {
-      DECODE_MAP.put(Character.valueOf(BASE_32[i]), Integer.valueOf(i));
-    }
-  }
-
-  private GeoHashUtils() {  
-  }
-
-  /**
-   * Encodes the given latitude and longitude into a geohash
-   *
-   * @param latitude Latitude to encode
-   * @param longitude Longitude to encode
-   * @return Geohash encoding of the longitude and latitude
-   */
-  public static String encode(double latitude, double longitude) {
-    double[] latInterval = {-90.0, 90.0};
-    double[] lngInterval = {-180.0, 180.0};
-
-    final StringBuilder geohash = new StringBuilder();
-    boolean isEven = true;
-
-    int bit = 0;
-    int ch = 0;
-
-    while (geohash.length() < PRECISION) {
-      double mid = 0.0;
-      if (isEven) {
-        mid = (lngInterval[0] + lngInterval[1]) / 2D;
-        if (longitude > mid) {
-          ch |= BITS[bit];
-          lngInterval[0] = mid;
-        } else {
-          lngInterval[1] = mid;
-        }
-      } else {
-        mid = (latInterval[0] + latInterval[1]) / 2D;
-        if (latitude > mid) {
-          ch |= BITS[bit];
-          latInterval[0] = mid;
-        } else {
-          latInterval[1] = mid;
-        }
-      }
-
-      isEven = !isEven;
-
-      if (bit < 4) {
-        bit++;
-      } else {
-        geohash.append(BASE_32[ch]);
-        bit = 0;
-        ch = 0;
-      }
-    }
-
-    return geohash.toString();
-  }
-
-  /**
-   * Decodes the given geohash into a latitude and longitude
-   *
-   * @param geohash Geohash to deocde
-   * @return Array with the latitude at index 0, and longitude at index 1
-   */
-  public static double[] decode(String geohash) {
-    final double[] latInterval = {-90.0, 90.0};
-    final double[] lngInterval = {-180.0, 180.0};
-
-    boolean isEven = true;
-
-    double latitude;
-    double longitude;
-    for (int i = 0; i < geohash.length(); i++) {
-      final int cd = DECODE_MAP.get(Character.valueOf(
-          geohash.charAt(i))).intValue();
-
-      for (int mask : BITS) {
-        if (isEven) {
-          if ((cd & mask) != 0) {
-            lngInterval[0] = (lngInterval[0] + lngInterval[1]) / 2D;
-          } else {
-            lngInterval[1] = (lngInterval[0] + lngInterval[1]) / 2D;
-          }
-        } else {
-          if ((cd & mask) != 0) {
-            latInterval[0] = (latInterval[0] + latInterval[1]) / 2D;
-          } else {
-            latInterval[1] = (latInterval[0] + latInterval[1]) / 2D;
-          }
-        }
-        isEven = !isEven;
-      }
-
-    }
-    latitude = (latInterval[0] + latInterval[1]) / 2D;
-    longitude = (lngInterval[0] + lngInterval[1]) / 2D;
-
-    return new double[] {latitude, longitude};
-	}
-}
\ No newline at end of file
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/package.html b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/package.html
deleted file mode 100644
index 4999361..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<body>
-Support for <a href="http://en.wikipedia.org/wiki/Geohash">Geohash</a> encoding, decoding, and filtering.
-</body>
-</html>
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/CartesianPoint.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/CartesianPoint.java
deleted file mode 100644
index c8853ae..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/CartesianPoint.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * Represents lat/lngs as fixed point numbers translated so that all
- * world coordinates are in the first quadrant.  The same fixed point
- * scale as is used for FixedLatLng is employed.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class CartesianPoint {
-  private int x;
-  private int y;
-  
-  public CartesianPoint(int x, int y) {
-    this.x=x;
-    this.y=y;
-  }
-  
-  public int getX() {
-    return x;
-  }
-  
-  public int getY() {
-    return y;
-  }
-  
-  @Override
-  public String toString() {
-    return "Point(" + x + "," + y + ")";
-  }
-
-  /**
-   * Return a new point translated in the x and y dimensions
-   */
-  public CartesianPoint translate(int deltaX, int deltaY) {
-    return new CartesianPoint(this.x+deltaX, this.y+deltaY);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + x;
-    result = prime * result + y;
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    CartesianPoint other = (CartesianPoint) obj;
-    if (x != other.x)
-      return false;
-    if (y != other.y)
-      return false;
-    return true;
-  }
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/DistanceUnits.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/DistanceUnits.java
deleted file mode 100644
index f25e06b..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/DistanceUnits.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * Enum representing difference distance units, currently only kilometers and
- * miles
- */
-public enum DistanceUnits {
-
-  MILES("miles", 3959, 24902),
-  KILOMETERS("km", 6371, 40076);
-
-  private static final double MILES_KILOMETRES_RATIO = 1.609344;
-
-  private final String unit;
-  
-  private final double earthCircumference;
-  
-  private final double earthRadius;
-
-  /**
-   * Creates a new DistanceUnit that represents the given unit
-   *
-   * @param unit Distance unit in String form
-   * @param earthRadius Radius of the Earth in the specific distance unit
-   * @param earthCircumfence Circumference of the Earth in the specific distance unit
-   */
-  DistanceUnits(String unit, double earthRadius, double earthCircumfence) {
-    this.unit = unit;
-    this.earthCircumference = earthCircumfence;
-    this.earthRadius = earthRadius;
-  }
-
-  /**
-   * Returns the DistanceUnit which represents the given unit
-   *
-   * @param unit Unit whose DistanceUnit should be found
-   * @return DistanceUnit representing the unit
-   * @throws IllegalArgumentException if no DistanceUnit which represents the given unit is found
-   */
-  public static DistanceUnits findDistanceUnit(String unit) {
-    if (MILES.getUnit().equalsIgnoreCase(unit) || unit.equalsIgnoreCase("mi")) {
-      return MILES;
-    }
-
-    if (KILOMETERS.getUnit().equalsIgnoreCase(unit)) {
-      return KILOMETERS;
-    }
-
-    throw new IllegalArgumentException("Unknown distance unit " + unit);
-  }
-
-  /**
-   * Converts the given distance in given DistanceUnit, to a distance in the unit represented by {@code this} 
-   *
-   * @param distance Distance to convert
-   * @param from Unit to convert the distance from
-   * @return Given distance converted to the distance in the given unit
-   */
-  public double convert(double distance, DistanceUnits from) {
-    if (from == this) {
-      return distance;
-    }
-    return (this == MILES) ? distance / MILES_KILOMETRES_RATIO : distance * MILES_KILOMETRES_RATIO;
-  }
-
-  /**
-   * Returns the string representation of the distance unit
-   *
-   * @return String representation of the distance unit
-   */
-  public String getUnit() {
-    return unit;
-  }
-  
-  /**
-   * Returns the <a href="http://en.wikipedia.org/wiki/Earth_radius">average earth radius</a>
-   *
-   * @return the average earth radius
-   */
-  public double earthRadius() {
-    return earthRadius;
-  }
-  
-  /**
-   * Returns the <a href="http://www.lyberty.com/encyc/articles/earth.html">circumference of the Earth</a>
-   * 
-   * @return  the circumference of the Earth
-   */
-  public double earthCircumference() {
-    return earthCircumference;
-  }
-}
-
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java
deleted file mode 100644
index 88e3150..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class FixedLatLng extends LatLng {
-  public static final double SCALE_FACTOR=1000000;
-  public static final int SCALE_FACTOR_INT=1000000;
-  
-  private int lat, lng;
-  private boolean normalized;
-  
-  public FixedLatLng(int lat, int lng) {
-    setLat(lat);
-    setLng(lng);
-  }
-  
-  public FixedLatLng(LatLng ll) {
-    this.lat=ll.getFixedLat();
-    this.lng=ll.getFixedLng();
-  }
-  
-  protected void setLat(int lat) {
-    if (lat>90*SCALE_FACTOR || lat<-90*SCALE_FACTOR) {
-      throw new IllegalArgumentException("Illegal lattitude");
-    }
-    this.lat=lat;
-  }
-
-  protected void setLng(int lng) {
-    this.lng=lng;
-  }
-  
-  public static double fixedToDouble(int fixed) {
-    return (fixed)/SCALE_FACTOR;
-  }
-  
-  public static int doubleToFixed(double d) {
-    return (int)(d*SCALE_FACTOR);
-  }
-  
-  @Override
-  public LatLng copy() {
-    return new FixedLatLng(this);
-  }
-
-  @Override
-  public int getFixedLat() {
-    return lat;
-  }
-
-  @Override
-  public int getFixedLng() {
-    return lng;
-  }
-
-  @Override
-  public double getLat() {
-    return fixedToDouble(lat);
-  }
-
-  @Override
-  public double getLng() {
-    return fixedToDouble(lng);
-  }
-
-  @Override
-  public boolean isFixedPoint() {
-    return true;
-  }
-
-  @Override
-  public FixedLatLng toFixed() {
-    return this;
-  }
-
-  @Override
-  public FloatLatLng toFloat() {
-    return new FloatLatLng(this);
-  }
-
-  @Override
-  public boolean isNormalized() {
-    return 
-      normalized || (
-          (lng>=-180*SCALE_FACTOR_INT) &&
-          (lng<=180*SCALE_FACTOR_INT)
-          );
-  }
-
-  @Override
-  public LatLng normalize() {
-    if (isNormalized()) return this;
-    
-    int delta=0;
-    if (lng<0) delta=360*SCALE_FACTOR_INT;
-    if (lng>=0) delta=-360*SCALE_FACTOR_INT;
-    
-    int newLng=lng;
-    while (newLng<=-180*SCALE_FACTOR_INT || newLng>=180*SCALE_FACTOR_INT) {
-      newLng+=delta;
-    }
-    
-    FixedLatLng ret=new FixedLatLng(lat, newLng);
-    ret.normalized=true;
-    return ret;
-  }
-  
-  @Override
-  public LatLng calculateMidpoint(LatLng other) {
-    return new FixedLatLng(
-        (lat+other.getFixedLat())/2,
-        (lng+other.getFixedLng())/2);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = prime + lat;
-    result = prime * result + lng;
-    result = prime * result + (normalized ? 1231 : 1237);
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (getClass() != obj.getClass())
-      return false;
-    FixedLatLng other = (FixedLatLng) obj;
-    if (lat != other.lat)
-      return false;
-    if (lng != other.lng)
-      return false;
-    if (normalized != other.normalized)
-      return false;
-    return true;
-  }
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java
deleted file mode 100644
index b5ab484..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class FloatLatLng extends LatLng {
-  private double lat;
-  private double lng;
-  private boolean normalized;
-  
-  public FloatLatLng(double lat, double lng) {
-    if (lat>90.0 || lat<-90.0) throw new IllegalArgumentException("Illegal latitude value " + lat);
-    this.lat=lat;
-    this.lng=lng;
-  }
-  
-  public FloatLatLng(LatLng ll) {
-    this.lat=ll.getLat();
-    this.lng=ll.getLng();
-  }
-  
-  @Override
-  public LatLng copy() {
-    return new FloatLatLng(this);
-  }
-
-  @Override
-  public int getFixedLat() {
-    return FixedLatLng.doubleToFixed(this.lat);
-  }
-
-  @Override
-  public int getFixedLng() {
-    return FixedLatLng.doubleToFixed(this.lng);
-  }
-
-  @Override
-  public double getLat() {
-    return this.lat;
-  }
-
-  @Override
-  public double getLng() {
-    return this.lng;
-  }
-
-  @Override
-  public boolean isFixedPoint() {
-    return false;
-  }
-
-  @Override
-  public FixedLatLng toFixed() {
-    return new FixedLatLng(this);
-  }
-
-  @Override
-  public FloatLatLng toFloat() {
-    return this;
-  }
-  
-  @Override
-  public boolean isNormalized() {
-    return 
-      normalized || (
-          (lng>=-180) &&
-          (lng<=180)
-          );
-  }
-
-  @Override
-  public LatLng normalize() {
-    if (isNormalized()) return this;
-    
-    double delta=0;
-    if (lng<0) delta=360;
-    if (lng>=0) delta=-360;
-    
-    double newLng=lng;
-    while (newLng<=-180 || newLng>=180) {
-      newLng+=delta;
-    }
-    
-    FloatLatLng ret=new FloatLatLng(lat, newLng);
-    ret.normalized=true;
-    return ret;
-  }
-
-  @Override
-  public LatLng calculateMidpoint(LatLng other) {
-    return new FloatLatLng(
-        (lat+other.getLat())/2.0,
-        (lng+other.getLng())/2.0);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    long temp;
-    temp = Double.doubleToLongBits(lat);
-    int result = prime  + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(lng);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    result = prime * result + (normalized ? 1231 : 1237);
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (getClass() != obj.getClass())
-      return false;
-    FloatLatLng other = (FloatLatLng) obj;
-    if (Double.doubleToLongBits(lat) != Double.doubleToLongBits(other.lat))
-      return false;
-    if (Double.doubleToLongBits(lng) != Double.doubleToLongBits(other.lng))
-      return false;
-    if (normalized != other.normalized)
-      return false;
-    return true;
-  }
-
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java
deleted file mode 100644
index b2128ab..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-
-/**
- * Abstract base lat-lng class which can manipulate fixed point or floating
- * point based coordinates. Instances are immutable.
- * 
- * @see FloatLatLng
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public abstract class LatLng {
-
-  public abstract boolean isNormalized();
-
-  public abstract boolean isFixedPoint();
-
-  public abstract LatLng normalize();
-
-  public abstract int getFixedLat();
-
-  public abstract int getFixedLng();
-
-  public abstract double getLat();
-
-  public abstract double getLng();
-
-  public abstract LatLng copy();
-
-  public abstract FixedLatLng toFixed();
-
-  public abstract FloatLatLng toFloat();
-  
-  /**
-   * Convert the lat/lng into the cartesian coordinate plane such that all
-   * world coordinates are represented in the first quadrant.
-   * The x dimension corresponds to latitude and y corresponds to longitude.
-   * The translation starts with the normalized latlng and adds 180 to the latitude and 
-   * 90 to the longitude (subject to fixed point scaling).
-   */
-  public CartesianPoint toCartesian() {
-    LatLng ll=normalize();
-    
-    int lat=ll.getFixedLat();
-    int lng=ll.getFixedLng();
-    
-    return new CartesianPoint(
-        lng+180*FixedLatLng.SCALE_FACTOR_INT,
-        lat+90*FixedLatLng.SCALE_FACTOR_INT
-    );
-  }
-  
-  /**
-   * The inverse of toCartesian().  Always returns a FixedLatLng.
-   * @param pt
-   */
-  public static LatLng fromCartesian(CartesianPoint pt) {
-    int lat=pt.getY() - 90 * FixedLatLng.SCALE_FACTOR_INT;
-    int lng=pt.getX() - 180 * FixedLatLng.SCALE_FACTOR_INT;
-    
-    return new FixedLatLng(lat, lng);
-  }
-  
-  /**
-   * Calculates the distance between two lat/lng's in miles.
-   * Imported from mq java client.
-   * 
-   * @param ll2
-   *            Second lat,lng position to calculate distance to.
-   * 
-   * @return Returns the distance in miles.
-   */
-  public double arcDistance(LatLng ll2) {
-    return arcDistance(ll2, DistanceUnits.MILES);
-  }
-
-  /**
-   * Calculates the distance between two lat/lng's in miles or meters.
-   * Imported from mq java client.  Variable references changed to match.
-   * 
-   * @param ll2
-   *            Second lat,lng position to calculate distance to.
-   * @param lUnits
-   *            Units to calculate distance, defaults to miles
-   * 
-   * @return Returns the distance in meters or miles.
-   */
-  public double arcDistance(LatLng ll2, DistanceUnits lUnits) {
-    LatLng ll1 = normalize();
-    ll2 = ll2.normalize();
-
-    double lat1 = ll1.getLat(), lng1 = ll1.getLng();
-    double lat2 = ll2.getLat(), lng2 = ll2.getLng();
-
-    // Check for same position
-    if (lat1 == lat2 && lng1 == lng2)
-      return 0.0;
-
-    // Get the m_dLongitude difference. Don't need to worry about
-    // crossing 180 since cos(x) = cos(-x)
-    double dLon = lng2 - lng1;
-
-    double a = radians(90.0 - lat1);
-    double c = radians(90.0 - lat2);
-    double cosB = (Math.cos(a) * Math.cos(c))
-        + (Math.sin(a) * Math.sin(c) * Math.cos(radians(dLon)));
-
-    double radius = (lUnits == DistanceUnits.MILES) ? 3963.205/* MILERADIUSOFEARTH */
-    : 6378.160187/* KMRADIUSOFEARTH */;
-
-    // Find angle subtended (with some bounds checking) in radians and
-    // multiply by earth radius to find the arc distance
-    if (cosB < -1.0)
-      return 3.14159265358979323846/* PI */* radius;
-    else if (cosB >= 1.0)
-      return 0;
-    else
-      return Math.acos(cosB) * radius;
-  }
-
-  private double radians(double a) {
-    return a * 0.01745329251994;
-  }
-
-  @Override
-  public String toString() {
-    return "[" + getLat() + "," + getLng() + "]";
-  }
-
-  /**
-   * Calculate the midpoint between this point an another.  Respects fixed vs floating point
-   * @param other
-   */
-  public abstract LatLng calculateMidpoint(LatLng other);
-  
-  @Override
-  public abstract int hashCode();
-
-  @Override
-  public abstract boolean equals(Object obj);
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse.java
deleted file mode 100644
index e8e6571..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Ellipse.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * Ellipse shape. From C++ gl.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class Ellipse implements Geometry2D {
-  private Point2D center;
-
-  /**
-   * Half length of major axis
-   */
-  private double a;
-
-  /**
-   * Half length of minor axis
-   */
-  private double b;
-
-  private double k1, k2, k3;
-
-  /**
-   * sin of rotation angle
-   */
-  private double s;
-
-  /**
-   * cos of rotation angle
-   */
-  private double c;
-
-  public Ellipse() {
-    center = new Point2D(0, 0);
-  }
-
-  private double SQR(double d) {
-    return d * d;
-  }
-
-  /**
-   * Constructor given bounding rectangle and a rotation.
-   */
-  public Ellipse(Point2D p1, Point2D p2, double angle) {
-    center = new Point2D();
-
-    // Set the center
-    center.x((p1.x() + p2.x()) * 0.5f);
-    center.y((p1.y() + p2.y()) * 0.5f);
-
-    // Find sin and cos of the angle
-    double angleRad = Math.toRadians(angle);
-    c = Math.cos(angleRad);
-    s = Math.sin(angleRad);
-
-    // Find the half lengths of the semi-major and semi-minor axes
-    double dx = Math.abs(p2.x() - p1.x()) * 0.5;
-    double dy = Math.abs(p2.y() - p1.y()) * 0.5;
-    if (dx >= dy) {
-      a = dx;
-      b = dy;
-    } else {
-      a = dy;
-      b = dx;
-    }
-
-    // Find k1, k2, k3 - define when a point x,y is on the ellipse
-    k1 = SQR(c / a) + SQR(s / b);
-    k2 = 2 * s * c * ((1 / SQR(a)) - (1 / SQR(b)));
-    k3 = SQR(s / a) + SQR(c / b);
-  }
-
-  /**
-   * Determines if a line segment intersects the ellipse and if so finds the
-   * point(s) of intersection.
-   * 
-   * @param seg
-   *            Line segment to test for intersection
-   * @param pt0
-   *            OUT - intersection point (if it exists)
-   * @param pt1
-   *            OUT - second intersection point (if it exists)
-   * 
-   * @return Returns the number of intersection points (0, 1, or 2).
-   */
-  public int intersect(LineSegment seg, Point2D pt0, Point2D pt1) {
-    if (pt0 == null)
-      pt0 = new Point2D();
-    if (pt1 == null)
-      pt1 = new Point2D();
-
-    // Solution is found by parameterizing the line segment and
-    // substituting those values into the ellipse equation.
-    // Results in a quadratic equation.
-    double x1 = center.x();
-    double y1 = center.y();
-    double u1 = seg.A.x();
-    double v1 = seg.A.y();
-    double u2 = seg.B.x();
-    double v2 = seg.B.y();
-    double dx = u2 - u1;
-    double dy = v2 - v1;
-    double q0 = k1 * SQR(u1 - x1) + k2 * (u1 - x1) * (v1 - y1) + k3
-        * SQR(v1 - y1) - 1;
-    double q1 = (2 * k1 * dx * (u1 - x1)) + (k2 * dx * (v1 - y1))
-        + (k2 * dy * (u1 - x1)) + (2 * k3 * dy * (v1 - y1));
-    double q2 = (k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy));
-
-    // Compare q1^2 to 4*q0*q2 to see how quadratic solves
-    double d = SQR(q1) - (4 * q0 * q2);
-    if (d < 0) {
-      // Roots are complex valued. Line containing the segment does
-      // not intersect the ellipse
-      return 0;
-    }
-
-    if (d == 0) {
-      // One real-valued root - line is tangent to the ellipse
-      double t = -q1 / (2 * q2);
-      if (0 <= t && t <= 1) {
-        // Intersection occurs along line segment
-        pt0.x(u1 + t * dx);
-        pt0.y(v1 + t * dy);
-        return 1;
-      } else
-        return 0;
-    } else {
-      // Two distinct real-valued roots. Solve for the roots and see if
-      // they fall along the line segment
-      int n = 0;
-      double q = Math.sqrt(d);
-      double t = (-q1 - q) / (2 * q2);
-      if (0 <= t && t <= 1) {
-        // Intersection occurs along line segment
-        pt0.x(u1 + t * dx);
-        pt0.y(v1 + t * dy);
-        n++;
-      }
-
-      // 2nd root
-      t = (-q1 + q) / (2 * q2);
-      if (0 <= t && t <= 1) {
-        if (n == 0) {
-          pt0.x(u1 + t * dx);
-          pt0.y(v1 + t * dy);
-          n++;
-        } else {
-          pt1.x(u1 + t * dx);
-          pt1.y(v1 + t * dy);
-          n++;
-        }
-      }
-      return n;
-    }
-  }
-
-  public IntersectCase intersect(Rectangle r) {
-    // Test if all 4 corners of the rectangle are inside the ellipse
-    Point2D ul = new Point2D(r.MinPt().x(), r.MaxPt().y());
-    Point2D ur = new Point2D(r.MaxPt().x(), r.MaxPt().y());
-    Point2D ll = new Point2D(r.MinPt().x(), r.MinPt().y());
-    Point2D lr = new Point2D(r.MaxPt().x(), r.MinPt().y());
-    if (contains(ul) && contains(ur) && contains(ll) && contains(lr))
-      return IntersectCase.CONTAINS;
-
-    // Test if any of the rectangle edges intersect
-    Point2D pt0 = new Point2D(), pt1 = new Point2D();
-    LineSegment bottom = new LineSegment(ll, lr);
-    if (intersect(bottom, pt0, pt1) > 0)
-      return IntersectCase.INTERSECTS;
-
-    LineSegment top = new LineSegment(ul, ur);
-    if (intersect(top, pt0, pt1) > 0)
-      return IntersectCase.INTERSECTS;
-
-    LineSegment left = new LineSegment(ll, ul);
-    if (intersect(left, pt0, pt1) > 0)
-      return IntersectCase.INTERSECTS;
-
-    LineSegment right = new LineSegment(lr, ur);
-    if (intersect(right, pt0, pt1) > 0)
-      return IntersectCase.INTERSECTS;
-
-    // Ellipse does not intersect any edge : since the case for the ellipse
-    // containing the rectangle was considered above then if the center
-    // is inside the ellipse is fully inside and if center is outside
-    // the ellipse is fully outside
-    return (r.contains(center)) ? IntersectCase.WITHIN
-        : IntersectCase.OUTSIDE;
-  }
-
-  public double area() {
-    throw new UnsupportedOperationException();
-  }
-
-  public Point2D centroid() {
-    throw new UnsupportedOperationException();
-  }
-
-  public boolean contains(Point2D pt) {
-    // Plug in equation for ellipse, If evaluates to <= 0 then the
-    // point is in or on the ellipse.
-    double dx = pt.x() - center.x();
-    double dy = pt.y() - center.y();
-    double eq=(((k1 * SQR(dx)) + (k2 * dx * dy) + (k3 * SQR(dy)) - 1));
-    
-    return eq<=0;
-  }
-
-  public void translate(Vector2D v) {
-    throw new UnsupportedOperationException();
-  }
-
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Geometry2D.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Geometry2D.java
deleted file mode 100644
index dcd7ed6..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Geometry2D.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * Common set of operations available on 2d shapes.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public interface Geometry2D {
-  /**
-   * Translate according to the vector
-   * @param v
-   */
-  public void translate(Vector2D v);
-  
-  /**
-   * Does the shape contain the given point
-   * @param p
-   */
-  public boolean contains(Point2D p);
-  
-  /**
-   * Return the area
-   */
-  public double area();
-  
-  /**
-   * Return the centroid
-   */
-  public Point2D centroid();
-  
-  /**
-   * Returns information about how this shape intersects the given rectangle
-   * @param r
-   */
-  public IntersectCase intersect(Rectangle r);
-
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/IntersectCase.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/IntersectCase.java
deleted file mode 100644
index 0f6cca6..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/IntersectCase.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-/**
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public enum IntersectCase {
-  WITHIN,
-  CONTAINS,
-  OUTSIDE,
-  INTERSECTS;
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java
deleted file mode 100644
index 9ff8c7e..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java
+++ /dev/null
@@ -1,191 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-import org.apache.lucene.spatial.geometry.FloatLatLng;
-import org.apache.lucene.spatial.geometry.LatLng;
-
-
-
-/**
- * Lat-long rect.  Instances are mutable.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class LLRect {
-  private LatLng ll, ur;
-  
-  public LLRect(LatLng ll, LatLng ur) {
-    this.ll=ll;
-    this.ur=ur;
-  }
-  
-  public LLRect(LLRect other) {
-    this.ll=other.ll;
-    this.ur=other.ur;
-  }
-  
-  /**
-   * Return the area in units of lat-lng squared.  This is a contrived unit
-   * that only has value when comparing to something else.
-   */
-  public double area() {
-    return Math.abs((ll.getLat()-ur.getLat()) * (ll.getLng()-ur.getLng()));
-  }
-
-  public LatLng getLowerLeft() {
-    return ll;
-  }
-  
-  public LatLng getUpperRight() {
-    return ur;
-  }
-  
-  @Override
-  public String toString() {
-    return "{" + ll + ", " + ur + "}";
-  }
-
-  public LatLng getMidpoint() {
-    return ll.calculateMidpoint(ur);
-  }
-
-  /**
-   * Approximates a box centered at the given point with the given width and height in miles.
-   * @param center
-   * @param widthMi
-   * @param heightMi
-   */
-  public static LLRect createBox(LatLng center, double widthMi, double heightMi) {
-    double d = widthMi;
-    LatLng ur = boxCorners(center, d, 45.0); // assume right angles
-    LatLng ll = boxCorners(center, d, 225.0);
-
-    //System.err.println("boxCorners: ur " + ur.getLat() + ',' + ur.getLng());
-    //System.err.println("boxCorners: cnt " + center.getLat() + ',' + center.getLng());
-    //System.err.println("boxCorners: ll " + ll.getLat() + ',' + ll.getLng());
-    return new LLRect(ll, ur);
-  }
-  
-  /**
-   * Returns a rectangle shape for the bounding box
-   */
-  public Rectangle toRectangle() {
-    return new Rectangle(ll.getLng(), ll.getLat(), ur.getLng(), ur.getLat());
-  }
-
-  private static LatLng boxCorners(LatLng center, double d, double brngdeg) {
-    double a = center.getLat();
-    double b = center.getLng();
-    double R = 3963.0; // radius of earth in miles
-    double brng = (Math.PI*brngdeg/180);
-    double lat1 = (Math.PI*a/180);
-    double lon1 = (Math.PI*b/180);
-
-    // Haversine formula
-    double lat2 = Math.asin( Math.sin(lat1)*Math.cos(d/R) +
-                             Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
-    double lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1),
-                                    Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
-
-    lat2 = (lat2*180)/Math.PI;
-    lon2 = (lon2*180)/Math.PI;
-
-    // normalize long first
-    LatLng ll = normLng(lat2,lon2);
-
-    // normalize lat - could flip poles
-    ll = normLat(ll.getLat(),ll.getLng());
-
-    return ll;
-}
-
-  /**
-   * Returns a normalized Lat rectangle shape for the bounding box
-   * If you go over the poles, you need to flip the lng value too
-   */
-  private static LatLng normLat(double lat, double lng) {
-    if (lat > 90.0) {
-        lat = 90.0 - (lat - 90.0);
-        if (lng < 0) {
-                lng = lng+180;
-        } else {
-                lng=lng-180;
-        }
-    }
-    else if (lat < -90.0) {
-        lat = -90.0 - (lat + 90.0);
-        if (lng < 0) {
-                lng = lng+180;
-        } else {
-                lng=lng-180;
-        }
-    }
-    LatLng ll=new FloatLatLng(lat, lng);
-    return ll;
-  }
-
-  /**
-   * Returns a normalized Lng rectangle shape for the bounding box
-   */
-  private static LatLng normLng(double lat,double lng) {
-    if (lng > 180.0) {
-        lng = -1.0*(180.0 - (lng - 180.0));
-    }
-    else if (lng < -180.0) {
-        lng = (lng + 180.0)+180.0;
-    }
-    LatLng ll=new FloatLatLng(lat, lng);
-    return ll;
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((ll == null) ? 0 : ll.hashCode());
-    result = prime * result + ((ur == null) ? 0 : ur.hashCode());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    LLRect other = (LLRect) obj;
-    if (ll == null) {
-      if (other.ll != null)
-        return false;
-    } else if (!ll.equals(other.ll))
-      return false;
-    if (ur == null) {
-      if (other.ur != null)
-        return false;
-    } else if (!ur.equals(other.ur))
-      return false;
-    return true;
-  }
-  
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LineSegment.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LineSegment.java
deleted file mode 100644
index 2fd05e2..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LineSegment.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * 2d line segment.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class LineSegment {
-  public final Point2D A = new Point2D();
-  public final Point2D B = new Point2D();
-
-  public LineSegment() {
-    A.set(0, 0);
-    B.set(0, 0);
-  }
-
-  public LineSegment(Point2D p1, Point2D p2) {
-    A.set(p1);
-    B.set(p2);
-  }
-
-  /**
-   * Finds the distance of a specified point from the line segment and the
-   * closest point on the segment to the specified point.
-   * 
-   * @param P
-   *            Test point.
-   * @param closestPt
-   *            (Return) Closest point on the segment to c.
-   * 
-   * @return Returns the distance from P to the closest point on the segment.
-   */
-  public double distance(Point2D P, Point2D /* out */closestPt) {
-    if (closestPt == null)
-      closestPt = new Point2D();
-
-    // Construct vector v (AB) and w (AP)
-    Vector2D v = new Vector2D(A, B);
-    Vector2D w = new Vector2D(A, P);
-
-    // Numerator of the component of w onto v. If <= 0 then A
-    // is the closest point. By separating into the numerator
-    // and denominator of the component we avoid a division unless
-    // it is necessary.
-    double n = w.dot(v);
-    if (n <= 0.0f) {
-      closestPt.set(A);
-      return w.norm();
-    }
-
-    // Get the denominator of the component. If the component >= 1
-    // (d <= n) then point B is the closest point
-    double d = v.dot(v);
-    if (d <= n) {
-      closestPt.set(B);
-      return new Vector2D(B, P).norm();
-    }
-
-    // Closest point is along the segment. The point is the projection of
-    // w onto v.
-    closestPt.set(v.mult(n / d));
-    closestPt.add(A);
-    return new Vector2D(closestPt, P).norm();
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((A == null) ? 0 : A.hashCode());
-    result = prime * result + ((B == null) ? 0 : B.hashCode());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    LineSegment other = (LineSegment) obj;
-    if (A == null) {
-      if (other.A != null)
-        return false;
-    } else if (!A.equals(other.A))
-      return false;
-    if (B == null) {
-      if (other.B != null)
-        return false;
-    } else if (!B.equals(other.B))
-      return false;
-    return true;
-  }
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Point2D.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Point2D.java
deleted file mode 100644
index 68863a4..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Point2D.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * Point class.  This type is mutable.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class Point2D {
-  private double x;
-  private double y;
-
-  public Point2D(double x, double y) {
-    this.x=x;
-    this.y=y;
-  }
-  
-  public Point2D() {
-    this.x=0;
-    this.y=0;
-  }
-  
-  public Point2D(Point2D other) {
-    this.x=other.x;
-    this.y=other.y;
-  }
-  
-  @Override
-  public String toString() {
-    return "(" + x + "," + y + ")";
-  }
-  
-  public double getX() {
-    return x;
-  }
-  
-  public double getY() {
-    return y;
-  }
-  
-  public double x() {
-    return x;
-  }
-
-  public double y() {
-    return y;
-  }
-
-  public void x(double x) {
-    this.x=x;
-  }
-
-  public void y(double y) {
-    this.y=y;
-  }
-
-  public void setX(double x) {
-    this.x = x;
-  }
-  
-  public void setY(double y) {
-    this.y = y;
-  }
-  
-  public void set(double x, double y) {
-    this.x=x;
-    this.y=y;
-  }
-
-  public void add(Vector2D v) {
-    this.x+=v.getX();
-    this.y+=v.getY();
-  }
-
-  public void set(Point2D p1) {
-    this.x=p1.getX();
-    this.y=p1.getY();
-  }
-
-  public void add(Point2D a) {
-    this.x+=a.getX();
-    this.y+=a.getY();
-  }
-
-  public void set(Vector2D v) {
-    this.x=v.getX();
-    this.y=v.getY();
-  }
-  
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    long temp;
-    temp = Double.doubleToLongBits(x);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(y);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    Point2D other = (Point2D) obj;
-    if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))
-      return false;
-    if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))
-      return false;
-    return true;
-  }
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Rectangle.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Rectangle.java
deleted file mode 100644
index 9c5ab7d..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Rectangle.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * Rectangle shape.  
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class Rectangle implements Geometry2D {
-  private Point2D ptMin, ptMax;
-  
-  public Rectangle() {
-    ptMin=new Point2D(-1, 1);
-    ptMax=new Point2D(1, 1);
-  }
-  
-  public Rectangle(Point2D ptMin, Point2D ptMax) {
-    this.ptMin=new Point2D(ptMin);
-    this.ptMax=new Point2D(ptMax);
-  }
-  
-  public Rectangle(double x1, double y1, double x2, double y2) {
-    set(x1, y1, x2, y2);
-  }
-
-  @Override
-  public String toString() {
-    return "[" + ptMin + "," + ptMax + "]";
-  }
-  
-  private void set(double x1, double y1, double x2, double y2) {
-    this.ptMin=new Point2D(Math.min(x1, x2), Math.min(y1, y2));
-    this.ptMax=new Point2D(Math.max(x1, x2), Math.max(y1, y2));
-  }
-  
-  public double area() {
-    return (ptMax.getX() - ptMin.getX()) * (ptMax.getY() - ptMin.getY());
-  }
-
-  public Point2D centroid() {
-    return new Point2D( (ptMin.getX() + ptMax.getX()) / 2,
-                  (ptMin.getY() + ptMax.getY()) / 2);
-  }
-
-  public boolean contains(Point2D p) {
-    return p.getX() >= ptMin.getX() && 
-      p.getX() <= ptMax.getX() &&
-      p.getY() >= ptMin.getY() &&
-      p.getY() <= ptMax.getY();
-  }
-
-  public void translate(Vector2D v) {
-    ptMin.add(v);
-    ptMax.add(v);
-  }
-
-  Point2D MinPt() {
-    return ptMin;
-  }
-
-  Point2D MaxPt() {
-    return ptMax;
-  }
-
-  public IntersectCase intersect(Rectangle r) {
-    throw new UnsupportedOperationException();
-    // TODO
-  }
-
-  public Point2D getMaxPoint() {
-    return ptMax;
-  }
-
-  public Point2D getMinPoint() {
-    return ptMin;
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((ptMax == null) ? 0 : ptMax.hashCode());
-    result = prime * result + ((ptMin == null) ? 0 : ptMin.hashCode());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    Rectangle other = (Rectangle) obj;
-    if (ptMax == null) {
-      if (other.ptMax != null)
-        return false;
-    } else if (!ptMax.equals(other.ptMax))
-      return false;
-    if (ptMin == null) {
-      if (other.ptMin != null)
-        return false;
-    } else if (!ptMin.equals(other.ptMin))
-      return false;
-    return true;
-  }
-
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Vector2D.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Vector2D.java
deleted file mode 100644
index 7444c8e..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/Vector2D.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry.shape;
-
-
-/**
- * 2D vector
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class Vector2D {
-  private double x;
-  private double y;
-
-  /**
-   * Create a vector from the origin of the coordinate system to the given
-   * point
-   * 
-   * @param x
-   * @param y
-   */
-  public Vector2D(double x, double y) {
-    this.x = x;
-    this.y = y;
-  }
-
-  /**
-   * Create a vector from the origin of the coordinate system to the given
-   * point
-   */
-  public Vector2D(Point2D p) {
-    this(p.getX(), p.getY());
-  }
-
-  /**
-   * Create a vector from one point to another
-   * 
-   * @param from
-   * @param to
-   */
-  public Vector2D(Point2D from, Point2D to) {
-    this(to.getX() - from.getX(), to.getY() - from.getY());
-  }
-
-  public Vector2D() {
-    this.x = 0;
-    this.y = 0;
-  }
-
-  public Vector2D(Vector2D other) {
-    this.x = other.x;
-    this.y = other.y;
-  }
-
-  public double getX() {
-    return x;
-  }
-
-  public double getY() {
-    return y;
-  }
-
-  public void setX(double x) {
-    this.x = x;
-  }
-
-  public void setY(double y) {
-    this.y = y;
-  }
-
-  public void set(double x, double y) {
-    this.x = x;
-    this.y = y;
-  }
-
-  public boolean equals(Vector2D other) {
-    return other != null && x == other.x && y == other.y;
-  }
-
-  public double dot(Vector2D in) {
-    return ((x) * in.x) + (y * in.y);
-  }
-
-  /**
-   * Vector length (magnitude) squared
-   */
-  public double normSqr() {
-    // Cast to F to prevent overflows
-    return (x * x) + (y * y);
-  }
-
-  public double norm() {
-    return Math.sqrt(normSqr());
-  }
-
-  public Vector2D mult(double d) {
-    return new Vector2D(x*d, y*d);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    long temp;
-    temp = Double.doubleToLongBits(x);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(y);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    Vector2D other = (Vector2D) obj;
-    if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))
-      return false;
-    if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))
-      return false;
-    return true;
-  }
-  
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java
deleted file mode 100644
index f92e353..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
-import org.apache.lucene.spatial.geometry.LatLng;
-import org.apache.lucene.spatial.geometry.shape.LLRect;
-import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
-import org.apache.lucene.spatial.tier.projections.IProjector;
-import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
-
-import java.math.BigDecimal;
-import java.math.RoundingMode;
-
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class CartesianPolyFilterBuilder {
-
-  // Finer granularity than 1 mile isn't accurate with
-  // standard java math.  Also, there's already a 2nd
-  // precise filter, if needed, in DistanceQueryBuilder,
-  // that will make the filtering exact.
-  public static final double MILES_FLOOR = 1.0;
-
-  private IProjector projector = new SinusoidalProjector();
-  private final String tierPrefix;
-  private int minTier;
-  private int maxTier;
-
-  /**
-   * @param tierPrefix     The prefix for the name of the fields containing the tier info
-   * @param minTierIndexed The minimum tier level indexed
-   * @param maxTierIndexed The maximum tier level indexed
-   */
-  public CartesianPolyFilterBuilder(String tierPrefix, int minTierIndexed, int maxTierIndexed) {
-    this.tierPrefix = tierPrefix;
-    this.minTier = minTierIndexed;
-    this.maxTier = maxTierIndexed;
-  }
-
-  public Shape getBoxShape(double latitude, double longitude, double miles) {
-    if (miles < MILES_FLOOR) {
-      miles = MILES_FLOOR;
-    }
-    LLRect box1 = LLRect.createBox(new FloatLatLng(latitude, longitude), miles, miles);
-    LatLng ll = box1.getLowerLeft();
-    LatLng ur = box1.getUpperRight();
-
-    double latY = ur.getLat();
-    double latX = ll.getLat();
-    double longY = ur.getLng();
-    double longX = ll.getLng();
-    double longX2 = 0.0;
-    //These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian
-    //In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then
-    //from the meridan to the upper right
-    //Are we crossing the 180 deg. longitude, if so, we need to do some special things
-    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {
-      longX2 = ll.getLng();
-      longX = -180.0;
-    }
-    //are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides
-    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {
-      longX2 = ll.getLng();
-      longX = 0.0;
-    }
-
-    //System.err.println("getBoxShape:"+latY+"," + longY);
-    //System.err.println("getBoxShape:"+latX+"," + longX);
-    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector, tierPrefix);
-    int bestFit = ctp.bestFit(miles);
-    if (bestFit < minTier) {
-      bestFit = minTier;
-    } else if (bestFit > maxTier) {
-      bestFit = maxTier;
-    }
-
-    ctp = new CartesianTierPlotter(bestFit, projector, tierPrefix);
-    Shape shape = new Shape(ctp.getTierFieldName());
-
-    // generate shape
-    // iterate from startX->endX
-    //     iterate from startY -> endY
-    //      shape.add(currentLat.currentLong);
-    //for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian
-    //for all other cases, it handles the whole set of tiles
-    shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);
-    if (longX2 != 0.0) {
-      if (longX == 0.0) {
-        longX = longX2;
-        longY = 0.0;
-        //handles the lower left longitude to the prime meridian
-        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);
-      } else {
-        //this clause handles the lower left longitude up to the 180 meridian
-        longX = longX2;
-        longY = 180.0;
-      }
-      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);
-
-      //System.err.println("getBoxShape2:"+latY+"," + longY);
-      //System.err.println("getBoxShape2:"+latX+"," + longX);
-    }
-
-
-    return shape;
-  }
-
-  public Shape getShapeLoop(Shape shape, CartesianTierPlotter ctp, double latX, double longX, double latY, double longY) {
-
-    //System.err.println("getShapeLoop:"+latY+"," + longY);
-    //System.err.println("getShapeLoop:"+latX+"," + longX);
-    double beginAt = ctp.getTierBoxId(latX, longX);
-    double endAt = ctp.getTierBoxId(latY, longY);
-    if (beginAt > endAt) {
-      double tmp = beginAt;
-      beginAt = endAt;
-      endAt = tmp;
-    }
-    double tierVert = ctp.getTierVerticalPosDivider();
-    //System.err.println(" | "+ beginAt+" | "+ endAt);
-
-    double startX = beginAt - (beginAt % 1);
-    double startY = beginAt - startX; //should give a whole number
-
-    double endX = endAt - (endAt % 1);
-    double endY = endAt - endX; //should give a whole number
-
-    int scale = (int) Math.log10(tierVert);
-    endY = new BigDecimal(endY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();
-    startY = new BigDecimal(startY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();
-    double xInc = 1.0d / tierVert;
-    xInc = new BigDecimal(xInc).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();
-
-    //System.err.println("go from startX:"+startX+" to:" + endX);
-    for (; startX <= endX; startX++) {
-
-      double itY = startY;
-      //System.err.println("go from startY:"+startY+" to:" + endY);
-      while (itY <= endY) {
-        //create a boxId
-        // startX.startY
-        double boxId = startX + itY;
-        shape.addBox(boxId);
-        //System.err.println("----"+startX+" and "+itY);
-        //System.err.println("----"+boxId);
-        itY += xInc;
-
-        // java keeps 0.0001 as 1.0E-1
-        // which ends up as 0.00011111
-        itY = new BigDecimal(itY).setScale(scale, RoundingMode.HALF_EVEN).doubleValue();
-      }
-    }
-    return shape;
-  }
-
-  public Filter getBoundingArea(double latitude, double longitude, double miles) {
-    Shape shape = getBoxShape(latitude, longitude, miles);
-    return new CartesianShapeFilter(shape, shape.getTierId());
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java
deleted file mode 100644
index 52893bf..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.DocsEnum;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.NumericUtils;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.FixedBitSet;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class CartesianShapeFilter extends Filter {
- 
-  private final Shape shape;
-  private final String fieldName;
-  
-  CartesianShapeFilter(final Shape shape, final String fieldName){
-    this.shape = shape;
-    this.fieldName = fieldName;
-  }
-  
-  @Override
-  public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits acceptDocs) throws IOException {
-    final List<Double> area = shape.getArea();
-    final int sz = area.size();
-    
-    // iterate through each boxid
-    final BytesRef bytesRef = new BytesRef(NumericUtils.BUF_SIZE_LONG);
-    if (sz == 1) {
-      double boxId = area.get(0).doubleValue();
-      NumericUtils.longToPrefixCoded(NumericUtils.doubleToSortableLong(boxId), 0, bytesRef);
-      return new DocIdSet() {
-        @Override
-        public DocIdSetIterator iterator() throws IOException {
-          return context.reader().termDocsEnum(acceptDocs, fieldName, bytesRef, false);
-        }
-        
-        @Override
-        public boolean isCacheable() {
-          return false;
-        }
-      };
-    } else {
-      final FixedBitSet bits = new FixedBitSet(context.reader().maxDoc());
-      for (int i =0; i< sz; i++) {
-        double boxId = area.get(i).doubleValue();
-        NumericUtils.longToPrefixCoded(NumericUtils.doubleToSortableLong(boxId), 0, bytesRef);
-        final DocsEnum docsEnum = context.reader().termDocsEnum(acceptDocs, fieldName, bytesRef, false);
-        if (docsEnum == null) continue;
-        // iterate through all documents
-        // which have this boxId
-        int doc;
-        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
-          bits.set(doc);
-        }
-      }
-      return bits;
-    }
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFieldComparatorSource.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFieldComparatorSource.java
deleted file mode 100644
index 214fd0b..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFieldComparatorSource.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.FieldComparator;
-import org.apache.lucene.search.FieldComparatorSource;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class DistanceFieldComparatorSource extends FieldComparatorSource {
-
-  private DistanceFilter distanceFilter;
-  private DistanceScoreDocLookupComparator dsdlc;
-
-  public DistanceFieldComparatorSource(Filter distanceFilter) {
-    this.distanceFilter = (DistanceFilter) distanceFilter;
-  }
-
-  public void cleanUp() {
-    distanceFilter = null;
-
-    if (dsdlc != null) {
-      dsdlc.cleanUp();
-    }
-
-    dsdlc = null;
-  }
-
-  @Override
-  public FieldComparator newComparator(String fieldname, int numHits,
-                                         int sortPos, boolean reversed) throws IOException {
-    dsdlc = new DistanceScoreDocLookupComparator(numHits);
-    return dsdlc;
-  }
-
-  private class DistanceScoreDocLookupComparator extends FieldComparator<Double> {
-
-    private double[] values;
-    private double bottom;
-    private int offset =0;
-		
-    public DistanceScoreDocLookupComparator(int numHits) {
-      values = new double[numHits];
-      return;
-    }
-
-    @Override
-    public int compare(int slot1, int slot2) {
-      double a = values[slot1];
-      double b = values[slot2];
-      if (a > b)
-        return 1;
-      if (a < b)
-        return -1;
-
-      return 0;
-    }
-
-    public void cleanUp() {
-      distanceFilter = null;
-    }
-
-    @Override
-    public int compareBottom(int doc) {
-      double v2 = distanceFilter.getDistance(doc+ offset);
-			
-      if (bottom > v2) {
-        return 1;
-      } else if (bottom < v2) {
-        return -1;
-      }
-      return 0;
-    }
-
-    @Override
-    public void copy(int slot, int doc) {
-      values[slot] = distanceFilter.getDistance(doc + offset);
-    }
-
-    @Override
-    public void setBottom(int slot) {
-      this.bottom = values[slot];
-    }
-
-    @Override
-    public FieldComparator setNextReader(AtomicReaderContext context)
-      throws IOException {
-      // each reader in a segmented base
-      // has an offset based on the maxDocs of previous readers
-      offset = context.docBase;
-      return this;
-    }
-
-    @Override
-    public Double value(int slot) {
-      return values[slot];
-    }
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFilter.java
deleted file mode 100644
index 22a5385..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFilter.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/** Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.HashMap;
-
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.tier.DistanceHandler.Precision;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public abstract class DistanceFilter extends Filter {
-
-  final protected Filter startingFilter;
-  protected Precision precise;
-  protected Map<Integer,Double> distances;
-  protected double distance;
-
-  protected int nextDocBase; 
-  protected transient WeakHashMap<String,Double> distanceLookupCache;
-
-  /** Filters the startingFilter by precise distance
-   *  checking filter */
-  public DistanceFilter(Filter startingFilter, double distance) {
-    if (startingFilter == null) {
-      throw new IllegalArgumentException("please provide a non-null startingFilter; you can use QueryWrapperFilter(MatchAllDocsQuery) as a no-op filter");
-    }
-    this.startingFilter = startingFilter;
-    this.distance = distance;
-
-    // NOTE: neither of the distance filters use precision
-    // now - if we turn that on, we'll need to pass top
-    // reader into here
-    // setPrecision(reader.maxDoc());
-
-    /* store calculated distances for reuse by other components */
-    distances = new HashMap<Integer,Double>();
-
-    // create an intermediate cache to avoid recomputing
-    //   distances for the same point 
-    //   TODO: Why is this a WeakHashMap? 
-    distanceLookupCache = new WeakHashMap<String,Double>();
-  }
-
-  public Map<Integer,Double> getDistances(){
-    return distances;
-  }
-  
-  public Double getDistance(int docid){
-    return distances.get(docid);
-  }
-  
-  public void setDistances(Map<Integer, Double> distances) {
-    this.distances = distances;
-  }
-
-  /** You must call this before re-using this DistanceFilter
-   *  across searches */
-  public void reset() {
-    nextDocBase = 0;
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public abstract boolean equals(Object o);
-
-  /** Returns a hash code value for this object.*/
-  @Override
-  public abstract int hashCode();
-
-  /*
-  private void setPrecision(int maxDocs) {
-    precise = Precision.EXACT;
-    
-    if (maxDocs > 1000 && distance > 10) {
-      precise = Precision.TWENTYFEET;
-    }
-    
-    if (maxDocs > 10000 && distance > 10){
-      precise = Precision.TWOHUNDREDFEET;
-    }
-  }
-  */
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
deleted file mode 100644
index 9770db4..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import org.apache.lucene.spatial.DistanceUtils;
-
-import java.util.Map;
-
-/**
- * Provide a high level access point to distances
- * Used by DistanceSortSource and DistanceQuery
- *  
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- *
- */
-public class DistanceHandler {
-
-  public enum Precision {EXACT, TWOFEET, TWENTYFEET, TWOHUNDREDFEET}
-  
-  private Map<Integer,Double> distances;
-  private Map<String, Double> distanceLookupCache;
-  private Precision precise;
-  
-  public DistanceHandler (Map<Integer,Double> distances, Map<String, Double> distanceLookupCache, Precision precise){
-    this.distances = distances;
-    this.distanceLookupCache = distanceLookupCache;
-    this.precise = precise; 
-  }
-  
-  
-  public static double getPrecision(double x, Precision thisPrecise){
-    
-    if(thisPrecise != null){
-      double dif = 0;
-      switch(thisPrecise) {
-        case EXACT: return x;
-        case TWOFEET:        dif = x % 0.0001; break;
-        case TWENTYFEET:     dif = x % 0.001;  break;
-        case TWOHUNDREDFEET: dif = x % 0.01; break;
-      }
-      return x - dif;
-    }
-    return x;
-  }
-  
-  public Precision getPrecision() {
-    return precise;
-  }
-  
-  public double getDistance(int docid, double centerLat, double centerLng, double lat, double lng){
-  
-    // check to see if we have distances
-    // if not calculate the distance
-    if(distances == null){
-      return DistanceUtils.getDistanceMi(centerLat, centerLng, lat, lng);
-    }
-    
-    // check to see if the doc id has a cached distance
-    Double docd = distances.get( docid );
-    if (docd != null){
-      return docd.doubleValue();
-    }
-    
-    //check to see if we have a precision code
-    // and if another lat/long has been calculated at
-    // that rounded location
-    if (precise != null) {
-      double xLat = getPrecision(lat, precise);
-      double xLng = getPrecision(lng, precise);
-      
-      String k = Double.valueOf(xLat).toString() +","+ Double.valueOf(xLng).toString();
-    
-      Double d = (distanceLookupCache.get(k));
-      if (d != null){
-        return d.doubleValue();
-      }
-    }
-    
-    //all else fails calculate the distances    
-    return DistanceUtils.getDistanceMi(centerLat, centerLng, lat, lng);
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceQueryBuilder.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceQueryBuilder.java
deleted file mode 100644
index c985f9c..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceQueryBuilder.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import org.apache.lucene.search.ConstantScoreQuery;
-import org.apache.lucene.queries.ChainedFilter;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryWrapperFilter;
-import org.apache.lucene.spatial.geohash.GeoHashDistanceFilter;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class DistanceQueryBuilder {
-  
-  private final double lat;
-  private final double lng;
-  private final double miles;
-  private final Filter filter;
-  final DistanceFilter distanceFilter;
-
-  /**
-   * Create a distance query using
-   * a boundary box wrapper around a more precise
-   * DistanceFilter.
-   * 
-   * @param lat The latitude to search around
-   * @param lng the Longitude to search around
-   * @param miles The radius to search within
-   * @param latField The name of the field containing the latitude
-   * @param lngField The name of the field containing the longitude
-   * @param tierFieldPrefix The prefix of the tier
-   * @param needPrecise if true, then distance is calculated in addition to tier info
-   * @param minTierIndexed The minimum tier level indexed
-   * @param maxTierIndexed The maximum tier level indexed
-   */
-  public DistanceQueryBuilder (double lat, double lng, double miles, 
-      String latField, String lngField, String tierFieldPrefix, boolean needPrecise, int minTierIndexed, int maxTierIndexed) {
-
-    this.lat = lat;
-    this.lng = lng;
-    this.miles = miles;
-    
-    CartesianPolyFilterBuilder cpf = new CartesianPolyFilterBuilder(tierFieldPrefix, minTierIndexed, maxTierIndexed);
-    Filter cartesianFilter = cpf.getBoundingArea(lat, lng, miles);
-
-    /* create precise distance filter */
-    if (needPrecise) {
-      filter = distanceFilter = new LatLongDistanceFilter(cartesianFilter, lat, lng, miles, latField, lngField);
-    } else {
-      filter = cartesianFilter;
-      distanceFilter = null;
-    }
-  }
-
-  /**
-   * Create a distance query using
-   * a boundary box wrapper around a more precise
-   * DistanceFilter.
-   * 
-   * @param lat
-   * @param lng
-   * @param miles
-   */
-  public DistanceQueryBuilder (double lat, double lng, double miles, 
-      String geoHashFieldPrefix, String tierFieldPrefix, boolean needPrecise,  int minTierIndexed, int maxTierIndexed){
-
-    this.lat = lat;
-    this.lng = lng;
-    this.miles = miles;
-    
-    CartesianPolyFilterBuilder cpf = new CartesianPolyFilterBuilder(tierFieldPrefix, minTierIndexed, maxTierIndexed);
-    Filter cartesianFilter = cpf.getBoundingArea(lat, lng, miles);
-
-    /* create precise distance filter */
-    if (needPrecise) {
-      filter = distanceFilter = new GeoHashDistanceFilter(cartesianFilter, lat, lng, miles, geoHashFieldPrefix);
-    } else {
-      filter = cartesianFilter;
-      distanceFilter = null;
-    }
-  }
-
-  
-  /**
-  * Create a distance query using
-  * a boundary box wrapper around a more precise
-  * DistanceFilter.
-  */
-  public Filter getFilter() {
-    if (distanceFilter != null) {
-      distanceFilter.reset();
-    }
-    return filter;
-  }
-  
-  public Filter getFilter(Query query) {
-    // Chain the Query (as filter) with our distance filter
-    if (distanceFilter != null) {
-      distanceFilter.reset();
-    }
-    QueryWrapperFilter qf = new QueryWrapperFilter(query);
-    return new ChainedFilter(new Filter[] {qf, filter},
-                             ChainedFilter.AND);
-  }
-
-  public DistanceFilter getDistanceFilter() {
-    return distanceFilter;
-  }
-    
-  public Query getQuery(Query query){
-    return new ConstantScoreQuery(getFilter(query));
-  }
-  
-  public double getLat() {
-    return lat;
-  }
-
-  public double getLng() {
-    return lng;
-  }
-
-  public double getMiles() {
-    return miles;
-  }
-    
-  @Override
-  public String toString() {
-    return "DistanceQuery lat: " + lat + " lng: " + lng + " miles: "+ miles;
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/InvalidGeoException.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/InvalidGeoException.java
deleted file mode 100644
index 0f8daac..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/InvalidGeoException.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class InvalidGeoException extends Exception {
-
-  public InvalidGeoException(String message){
-    super(message);
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
deleted file mode 100644
index 934a4fa..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.search.FilteredDocIdSet;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.spatial.DistanceUtils;
-
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class LatLongDistanceFilter extends DistanceFilter {
-  
-  double lat;
-  double lng;
-  String latField;
-  String lngField;
-
-  int nextOffset = 0;
-  
-  /**
-   * Provide a distance filter based from a center point with a radius
-   * in miles.
-   * @param startingFilter Filter to start from
-   * @param lat
-   * @param lng
-   * @param miles
-   * @param latField
-   * @param lngField
-   */
-  public LatLongDistanceFilter(Filter startingFilter, double lat, double lng, double miles, String latField, String lngField) {
-    super(startingFilter, miles);
-    this.lat = lat;
-    this.lng = lng;
-    this.latField = latField;
-    this.lngField = lngField;
-  }
-  
-  @Override
-  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {
-
-    final double[] latIndex = FieldCache.DEFAULT.getDoubles(context.reader(), latField, false);
-    final double[] lngIndex = FieldCache.DEFAULT.getDoubles(context.reader(), lngField, false);
-
-    final int docBase = nextDocBase;
-    nextDocBase += context.reader().maxDoc();
-
-    return new FilteredDocIdSet(startingFilter.getDocIdSet(context, acceptDocs)) {
-      @Override
-      protected boolean match(int doc) {
-        double x = latIndex[doc];
-        double y = lngIndex[doc];
-      
-        // round off lat / longs if necessary
-        //      x = DistanceHandler.getPrecision(x, precise);
-        //      y = DistanceHandler.getPrecision(y, precise);
-      
-        String ck = Double.toString(x)+","+Double.toString(y);
-        Double cachedDistance = distanceLookupCache.get(ck);
-
-        double d;
-        if (cachedDistance != null){
-          d = cachedDistance.doubleValue();
-        } else {
-          d = DistanceUtils.getDistanceMi(lat, lng, x, y);
-          distanceLookupCache.put(ck, d);
-        }
-
-        if (d < distance) {
-          // Save distances, so they can be pulled for
-          // sorting after filtering is done:
-          distances.put(doc+docBase, d);
-          return true;
-        } else {
-          return false;
-        }
-      }
-    };
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof LatLongDistanceFilter)) return false;
-    LatLongDistanceFilter other = (LatLongDistanceFilter) o;
-
-    if (!this.startingFilter.equals(other.startingFilter) ||
-        this.distance != other.distance ||
-        this.lat != other.lat ||
-        this.lng != other.lng ||
-        !this.latField.equals(other.latField) ||
-        !this.lngField.equals(other.lngField)) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns a hash code value for this object.*/
-  @Override
-  public int hashCode() {
-    int h = Double.valueOf(distance).hashCode();
-    h ^= startingFilter.hashCode();
-    h ^= Double.valueOf(lat).hashCode();
-    h ^= Double.valueOf(lng).hashCode();
-    h ^= latField.hashCode();
-    h ^= lngField.hashCode();
-    return h;
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/Shape.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/Shape.java
deleted file mode 100644
index 5b95b3f..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/Shape.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class Shape {
-
-  private List<Double> area = new ArrayList<Double>();
-  private String tierId;
-  
-  public Shape (String tierId){
-    this.tierId = tierId;
-  }
-
-  public void addBox(double  boxId){
-    area.add(boxId);
-  }
-  
-  public List<Double> getArea(){
-    return area;
-  }
-  
-  public String getTierId(){
-    return tierId;
-  }
-  
-  public boolean isInside(double boxId){
-    return area.contains(boxId);
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/package.html b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/package.html
deleted file mode 100644
index 333b794..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<body>
-Support for filtering based upon geographic location.
-</body>
-</html>
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java
deleted file mode 100644
index 2ba55a4..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier.projections;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class CartesianTierPlotter {
-  public static final String DEFALT_FIELD_PREFIX = "_tier_";
-  
-  
-  private static final double LOG_2 = Math.log(2);
-  
-  final int tierLevel;
-  int tierLength;
-  int tierBoxes;
-  int tierVerticalPosDivider;
-  final IProjector projector;
-  final String fieldPrefix;
-  Double idd = Double.valueOf(180);
-  
-  public CartesianTierPlotter (int tierLevel, IProjector projector, String fieldPrefix) {
-  
-    this.tierLevel  = tierLevel;
-    this.projector = projector;
-    this.fieldPrefix = fieldPrefix;
-    
-    setTierLength();
-    setTierBoxes();
-    setTierVerticalPosDivider();
-  }
-  
-  private void setTierLength (){
-    this.tierLength = (int) Math.pow(2 , this.tierLevel);
-  }
-  
-  private void setTierBoxes () {
-    this.tierBoxes = (int)Math.pow(this.tierLength, 2);
-  }
-  
-  /**
-   * Get nearest max power of 10 greater than
-   * the tierlen
-   * e.g
-   * tierId of 13 has tierLen 8192
-   * nearest max power of 10 greater than tierLen 
-   * would be 10,000
-   */
-  
-  private void setTierVerticalPosDivider() {
-    
-    // ceiling of log base 10 of tierLen
-    
-    tierVerticalPosDivider = Double.valueOf(Math.ceil(
-          Math.log10(Integer.valueOf(this.tierLength).doubleValue()))).intValue();
-    
-    // 
-    tierVerticalPosDivider = (int)Math.pow(10, tierVerticalPosDivider );
-    
-  }
-  
-  public double getTierVerticalPosDivider(){
-    return tierVerticalPosDivider;
-  }
-  
-  /**
-   * TierBoxId is latitude box id + longitude box id
-   * where latitude box id, and longitude box id are transposed in to position
-   * coordinates.
-   * 
-   * @param latitude
-   * @param longitude
-   */
-  public double getTierBoxId (double latitude, double longitude) {
-    
-    double[] coords = projector.coords(latitude, longitude);
-    
-    double id = getBoxId(coords[0]) + (getBoxId(coords[1]) / tierVerticalPosDivider);
-    return id ;
-  }
-  
-  
-  private double getBoxId (double coord){
-    
-    
-    return Math.floor(coord / (idd / this.tierLength));
-  }
-  
-  @SuppressWarnings("unused")
-  private double getBoxId (double coord, int tierLen){
-    return Math.floor(coord / (idd / tierLen) );
-  }
-  /**
-   * get the string name representing current tier
-   * _localTier&lt;tiedId&gt;
-   */
-  public String getTierFieldName (){
-    
-    return fieldPrefix + this.tierLevel;
-  }
-  
-  /**
-   * get the string name representing tierId
-   * _localTier&lt;tierId&gt;
-   * @param tierId
-   */
-  public String getTierFieldName (int tierId){
-    
-    return fieldPrefix + tierId;
-  }
-  
-  /**
-   * Find the tier with the best fit for a bounding box
-   * Best fit is defined as the ceiling of
-   *  log2 (circumference of earth / distance) 
-   *  distance is defined as the smallest box fitting
-   *  the corner between a radius and a bounding box.
-   *  
-   *  Distances less than a mile return 15, finer granularity is
-   *  in accurate
-   */
-  public int bestFit(double miles){
-    
-    //28,892 a rough circumference of the earth
-    int circ = 28892;
-    
-    double r = miles / 2.0;
-    
-    double corner = r - Math.sqrt(Math.pow(r, 2) / 2.0d);
-    double times = circ / corner;
-    int bestFit =  (int)Math.ceil(log2(times)) + 1;
-    
-    if (bestFit > 15) {
-      // 15 is the granularity of about 1 mile
-      // finer granularity isn't accurate with standard java math
-      return 15;
-    }
-    return bestFit;
-  }
-  
-  /**
-   * a log to the base 2 formula
-   * <code>Math.log(value) / Math.log(2)</code>
-   * @param value
-   */
-  public static double log2(double value) {
-    return Math.log(value) / LOG_2;
-  }
-
-  /**
-   * Returns the ID of the tier level plotting is occuring at
-   * 
-   * @return ID of the tier level plotting is occuring at
-   */
-  public int getTierLevelId() {
-    return this.tierLevel;
-  }
-
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/IProjector.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/IProjector.java
deleted file mode 100644
index 88c6f07..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/IProjector.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
- 
-package org.apache.lucene.spatial.tier.projections;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public interface IProjector {
-  public String coordsAsString(double latitude, double longitude);
-  public double[] coords(double latitude, double longitude);
-}
\ No newline at end of file
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java
deleted file mode 100644
index 8cc151d..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier.projections;
-
-/**
- * Based on Sinusoidal Projections
- * Project a latitude / longitude on a 2D cartesian map
- * <p/>
- * THIS PROJECTION IS WRONG, but it's not going to be fixed b/c it will break a lot of existing tests, plus we are deprecating
- * most of the existing spatial and replacing with a more reliable approach.
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- *
- * @deprecated (3.1) Until we can put in place proper tests and a proper fix. 
- */
-@Deprecated
-public class SinusoidalProjector implements IProjector {
-
-
-  public String coordsAsString(double latitude, double longitude) {
-    return null;
-  }
-
-  public double[] coords(double latitude, double longitude) {
-    double rlat = Math.toRadians(latitude);
-    double rlong = Math.toRadians(longitude);
-    double nlat = rlong * Math.cos(rlat);
-    double r[] = {nlat, rlong};
-    return r;
-    
-  }
-  
-}
-
-/*
-This whole file should really be:*/
-
-/**
- * Based on Sinusoidal Projections
- * Project a latitude / longitude on a 2D cartesian map using the Prime Meridian as the "central meridian"
- *
- * See http://en.wikipedia.org/wiki/Sinusoidal_projection
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-/*
-public class SinusoidalProjector implements IProjector {
-
-
-  public String coordsAsString(double latitude, double longitude) {
-    double [] coords = coords(latitude, longitude);
-    return coords[0] + "," + coords[1];
-  }
-
-  public double[] coords(double latitude, double longitude) {
-    double rlat = latitude * DistanceUtils.DEGREES_TO_RADIANS;
-    double rlong = longitude * DistanceUtils.DEGREES_TO_RADIANS;
-    double x = rlong * Math.cos(rlat);
-    return new double[]{x, rlat};
-
-  }
-
-}
-*/
-
-
-
diff --git a/lucene/contrib/spatial/src/java/overview.html b/lucene/contrib/spatial/src/java/overview.html
deleted file mode 100644
index 3910933..0000000
--- a/lucene/contrib/spatial/src/java/overview.html
+++ /dev/null
@@ -1,47 +0,0 @@
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-  <head>
-    <title>
-      Geographical filtering & sorting with Lucene
-    </title>
-  </head>
-  <body>
-
-<p>This package makes it possible to filter and sort according to
-geographical constraints.  For example, filter to include only
-restaurants within 2 miles of a specified latitude/longitude, sorting
-by distance ascending.</p>
-
-<p>See <a href="http://www.nsshutdown.com/projects/lucene/whitepaper/locallucene_v2.html">here</a>
-for details on the technical approach.</p>
-
-<p>Unfortunately, this package is still very new, and has little to no
-documentation.  It's best to ask for pointers on
-java-user@lucene.apache.org, and look at the unit tests included in
-the source distribution.</p>
-
-<p>There are also known issues, eg at
-least <a href="https://issues.apache.org/jira/browse/LUCENE-1815">LUCENE-1781</a>
-and <a href="https://issues.apache.org/jira/browse/LUCENE-1815">LUCENE-1815</a>.</p>
-
-<p><font color="red"><b>NOTE:</b> This package is still in flux and
-might change in incompatible ways in the next release.</font>
-
-  </body>
-</html>
-
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java
deleted file mode 100644
index caf405d..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java
+++ /dev/null
@@ -1,283 +0,0 @@
-package org.apache.lucene.spatial;
-
-import org.apache.lucene.spatial.tier.InvalidGeoException;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- *
- *
- **/
-public class DistanceUtilsTest extends LuceneTestCase {
-
-  public void testBoxCorner() throws Exception {
-    double[] zero = new double[]{0, 0};
-    double[] zeroOne = new double[]{0, 1};
-    double[] oneOne = new double[]{1, 1};
-    double[] pt1 = new double[]{1.5, 110.3};
-    double[] result = DistanceUtils.vectorBoxCorner(zero, null, Math.sqrt(2), true);
-    assertEquals(1.0, result[0], 0);
-    assertEquals(1.0, result[1], 0);
-
-    result = DistanceUtils.vectorBoxCorner(zero, null, Math.sqrt(2), false);
-    assertEquals(-1.0, result[0], 0);
-    assertEquals(-1.0, result[1], 0);
-
-    result = DistanceUtils.vectorBoxCorner(oneOne, null, Math.sqrt(2), true);
-    assertEquals(2.0, result[0], 0);
-    assertEquals(2.0, result[1], 0);
-
-    result = DistanceUtils.vectorBoxCorner(zeroOne, null, Math.sqrt(2), true);
-    assertEquals(1.0, result[0], 0);
-    assertEquals(2.0, result[1], 0);
-
-    result = DistanceUtils.vectorBoxCorner(pt1, null, Math.sqrt(2), true);
-    assertEquals(2.5, result[0], 0.1);
-    assertEquals(111.3, result[1], 0.1);
-
-    result = DistanceUtils.vectorBoxCorner(pt1, null, Math.sqrt(2), false);
-    assertEquals(0.5, result[0], 0.1);
-    assertEquals(109.3, result[1], 0.1);
-
-  }
-
-  public void testNormLatLon() throws Exception {
-
-  }
-
-  public void testLatLonCorner() throws Exception {
-    double[] zero = new double[]{0, 0};
-    double[] zero45 = new double[]{0, DistanceUtils.DEG_45_AS_RADS};
-    double[] result;
-    // 	00°38??09??, 000°38??09??
-    //Verify at http://www.movable-type.co.uk/scripts/latlong.html
-    result = DistanceUtils.latLonCorner(zero[0], zero[1], 100, null, true, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(0.63583 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(0.63583 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.latLonCornerDegs(zero[0], zero[1], 100, null, true, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    // 	00°38??09??, 000°38??09??
-    assertEquals(0.63583, result[0], 0.001);
-    assertEquals(0.63583, result[1], 0.001);
-
-    result = DistanceUtils.latLonCornerDegs(zero[0], zero[1], 100, null, false, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    // 	00°38??09??, 000°38??09??
-    assertEquals(-0.63583, result[0], 0.001);
-    assertEquals(-0.63583, result[1], 0.001);
-
-    //test some edge cases
-    //89°16??02??, 060°12??35??
-    result = DistanceUtils.latLonCornerDegs(89.0, 0, 100, null, true, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(89.26722, result[0], 0.001);
-    assertEquals(60.20972, result[1], 0.001);
-
-    result = DistanceUtils.latLonCornerDegs(0, -179.0, 100, null, true, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(0.63583, result[0], 0.001);
-    assertEquals(-178.36417, result[1], 0.001);
-
-  }
-
-  public void testPointBearing() throws Exception {
-    double[] zero = new double[]{0, 0};
-    double[] zero45 = new double[]{40 * DistanceUtils.DEGREES_TO_RADIANS, DistanceUtils.DEG_45_AS_RADS};
-    double[] result;
-    // 	00°38??09??, 000°38??09??
-    //Verify at http://www.movable-type.co.uk/scripts/latlong.html
-    result = DistanceUtils.pointOnBearing(zero[0], zero[1], 100, DistanceUtils.DEG_45_AS_RADS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(0.63583 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(0.63583 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    //should be above the current point at 0.8994°,0.0000°
-    result = DistanceUtils.pointOnBearing(zero[0], zero[1], 100, 0, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(0.8994 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(0, result[1], 0.001);
-    //directly below
-    result = DistanceUtils.pointOnBearing(zero[0], zero[1], 100, DistanceUtils.DEG_180_AS_RADS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(-0.8994 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(0, result[1], 0.001);
-    //0.7183°,0.5414° -- 37 deg bearing
-    result = DistanceUtils.pointOnBearing(zero[0], zero[1], 100, 37 * DistanceUtils.DEGREES_TO_RADIANS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(0.7183 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(0.5414 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.pointOnBearing(zero45[0], zero45[1], 100, DistanceUtils.DEG_45_AS_RADS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    //40.6328°,45.8381°
-    assertEquals(40.6328 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(45.8381 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.pointOnBearing(1 * DistanceUtils.DEGREES_TO_RADIANS, 1 * DistanceUtils.DEGREES_TO_RADIANS, 100, DistanceUtils.DEG_90_AS_RADS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    //0.9997°,1.8994°
-    assertEquals(0.9997 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(1.8994 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.pointOnBearing(-10 * DistanceUtils.DEGREES_TO_RADIANS, -150 * DistanceUtils.DEGREES_TO_RADIANS, 15, 205*DistanceUtils.DEGREES_TO_RADIANS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    //-10.1222°,-150.0578°
-    assertEquals(-10.1222 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(-150.0578 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.pointOnBearing(-10 * DistanceUtils.DEGREES_TO_RADIANS, -150 * DistanceUtils.DEGREES_TO_RADIANS, 200, 63*DistanceUtils.DEGREES_TO_RADIANS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    //-9.1797°,-148.3767°
-    assertEquals(-9.1797 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(-148.3767 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-    result = DistanceUtils.pointOnBearing(-10 * DistanceUtils.DEGREES_TO_RADIANS, -150 * DistanceUtils.DEGREES_TO_RADIANS, 3000, 63*DistanceUtils.DEGREES_TO_RADIANS, null, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    //2.7561°,-126.1281°
-    assertEquals(2.7561 * DistanceUtils.DEGREES_TO_RADIANS, result[0], 0.001);
-    assertEquals(-126.1281 * DistanceUtils.DEGREES_TO_RADIANS, result[1], 0.001);
-
-  }
-
-  public void testVectorDistance() throws Exception {
-    double[] zero = new double[]{0, 0};
-
-    double[] zeroOne = new double[]{0, 1};
-    double[] oneZero = new double[]{1, 0};
-    double[] oneOne = new double[]{1, 1};
-    double distance;
-    distance = DistanceUtils.vectorDistance(zero, zeroOne, 2);
-    assertEquals(1.0, distance, 0);
-    distance = DistanceUtils.vectorDistance(zero, oneZero, 2);
-    assertEquals(1.0, distance, 0);
-    distance = DistanceUtils.vectorDistance(zero, oneOne, 2);
-    assertEquals(Math.sqrt(2), distance, 0.001);
-
-    distance = DistanceUtils.squaredEuclideanDistance(zero, oneOne);
-    assertEquals(2, distance, 0.001);
-  }
-
-  public void testHaversine() throws Exception {
-    double distance;
-    //compare to http://www.movable-type.co.uk/scripts/latlong.html
-    distance = DistanceUtils.haversine(0, 0, Math.PI / 4.0, Math.PI / 4.0, DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(6672.0, distance, 0.5);
-
-    distance = DistanceUtils.haversine(0, 0, Math.toRadians(20), Math.toRadians(20), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(3112, distance, 0.5);
-
-    distance = DistanceUtils.haversine(0, 0, Math.toRadians(1), Math.toRadians(1), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(157.2, distance, 0.5);
-
-    //Try some around stuff
-    distance = DistanceUtils.haversine(Math.toRadians(1), Math.toRadians(-1),
-            Math.toRadians(1), Math.toRadians(1), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(222.4, distance, 0.5);
-
-    distance = DistanceUtils.haversine(Math.toRadians(89), Math.toRadians(-1),
-            Math.toRadians(89), Math.toRadians(179), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(222.4, distance, 0.5);
-
-    distance = DistanceUtils.haversine(Math.toRadians(89), Math.toRadians(-1),
-            Math.toRadians(49), Math.toRadians(179), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(4670, distance, 0.5);
-
-    distance = DistanceUtils.haversine(Math.toRadians(0), Math.toRadians(-179),
-            Math.toRadians(0), Math.toRadians(179), DistanceUtils.EARTH_MEAN_RADIUS_KM);
-    assertEquals(222.4, distance, 0.5);
-
-  }
-
-  public void testParse() throws Exception {
-    String[] parse;
-    parse = DistanceUtils.parsePoint(null, "89.0,73.2", 2);
-    assertEquals(2, parse.length);
-    assertEquals("89.0", parse[0]);
-    assertEquals("73.2", parse[1]);
-
-    parse = DistanceUtils.parsePoint(null, "89.0,73.2,-92.3", 3);
-    assertEquals(3, parse.length);
-    assertEquals("89.0", parse[0]);
-    assertEquals("73.2", parse[1]);
-    assertEquals("-92.3", parse[2]);
-
-    parse = DistanceUtils.parsePoint(null, "    89.0         ,   73.2  ,              -92.3   ", 3);
-    assertEquals(3, parse.length);
-    assertEquals("89.0", parse[0]);
-    assertEquals("73.2", parse[1]);
-    assertEquals("-92.3", parse[2]);
-
-
-    String[] foo = DistanceUtils.parsePoint(parse, "89.0         ,   73.2 ,              -92.3", 3);
-    //should be same piece of memory
-    assertTrue(foo == parse);
-    assertEquals(3, parse.length);
-    assertEquals("89.0", parse[0]);
-    assertEquals("73.2", parse[1]);
-    assertEquals("-92.3", parse[2]);
-    //array should get automatically resized
-    parse = DistanceUtils.parsePoint(new String[1], "89.0         ,   73.2 ,              -92.3", 3);
-    assertEquals(3, parse.length);
-    assertEquals("89.0", parse[0]);
-    assertEquals("73.2", parse[1]);
-    assertEquals("-92.3", parse[2]);
-
-
-    try {
-      parse = DistanceUtils.parsePoint(null, "89.0         ,   ", 3);
-      assertTrue(false);
-    } catch (InvalidGeoException e) {
-    }
-    try {
-      parse = DistanceUtils.parsePoint(null, " , 89.0          ", 3);
-      assertTrue(false);
-    } catch (InvalidGeoException e) {
-    }
-
-    try {
-      parse = DistanceUtils.parsePoint(null, "", 3);
-      assertTrue(false);
-    } catch (InvalidGeoException e) {
-    }
-
-
-    double[] dbls = DistanceUtils.parsePointDouble(null, "89.0         ,   73.2 ,              -92.3", 3);
-    assertEquals(3, dbls.length);
-    assertEquals(89.0, dbls[0], 0);
-    assertEquals(73.2, dbls[1], 0.1);
-    assertEquals(-92.3, dbls[2], 0.1);
-
-    try {
-      dbls = DistanceUtils.parsePointDouble(null, "89.0         ,   foo ,              -92.3", 3);
-      assertTrue(false);
-    } catch (NumberFormatException e) {
-    }
-
-    dbls = DistanceUtils.parseLatitudeLongitude(null, "89.0         ,   73.2    ");
-    assertEquals(2, dbls.length);
-    assertEquals(89.0, dbls[0], 0.1);
-    assertEquals(73.2, dbls[1], 0.1);
-
-    //test some bad lat/long pairs
-    try {
-      dbls = DistanceUtils.parseLatitudeLongitude(null, "189.0         ,   73.2    ");
-      assertTrue(false);
-    } catch (InvalidGeoException e) {
-
-    }
-
-    try {
-      dbls = DistanceUtils.parseLatitudeLongitude(null, "89.0         ,   273.2    ");
-      assertTrue(false);
-    } catch (InvalidGeoException e) {
-
-    }
-
-  }
-
-}
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geohash/TestGeoHashUtils.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geohash/TestGeoHashUtils.java
deleted file mode 100644
index 42b56fb..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geohash/TestGeoHashUtils.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geohash;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-/**
- * Tests for {@link GeoHashUtils}
- */
-public class TestGeoHashUtils extends LuceneTestCase {
-  
-  /**
-   * Pass condition: lat=42.6, lng=-5.6 should be encoded as "ezs42e44yx96",
-   * lat=57.64911 lng=10.40744 should be encoded as "u4pruydqqvj8"
-   */
-  @Test
-  public void testEncode() {
-    String hash = GeoHashUtils.encode(42.6, -5.6);
-    assertEquals("ezs42e44yx96", hash);
-    
-    hash = GeoHashUtils.encode(57.64911, 10.40744);
-    assertEquals("u4pruydqqvj8", hash);
-  }
-  
-  /**
-   * Pass condition: lat=52.3738007, lng=4.8909347 should be encoded and then
-   * decoded within 0.00001 of the original value
-   */
-  @Test
-  public void testDecodePreciseLongitudeLatitude() {
-    String hash = GeoHashUtils.encode(52.3738007, 4.8909347);
-    
-    double[] latitudeLongitude = GeoHashUtils.decode(hash);
-    
-    assertEquals(52.3738007, latitudeLongitude[0], 0.00001D);
-    assertEquals(4.8909347, latitudeLongitude[1], 0.00001D);
-  }
-  
-  /**
-   * Pass condition: lat=84.6, lng=10.5 should be encoded and then decoded
-   * within 0.00001 of the original value
-   */
-  @Test
-  public void testDecodeImpreciseLongitudeLatitude() {
-    String hash = GeoHashUtils.encode(84.6, 10.5);
-    
-    double[] latitudeLongitude = GeoHashUtils.decode(hash);
-    
-    assertEquals(84.6, latitudeLongitude[0], 0.00001D);
-    assertEquals(10.5, latitudeLongitude[1], 0.00001D);
-  }
-  
-  /*
-   * see https://issues.apache.org/jira/browse/LUCENE-1815 for details
-   */
-  @Test
-  public void testDecodeEncode() {
-    String geoHash = "u173zq37x014";
-    assertEquals(geoHash, GeoHashUtils.encode(52.3738007, 4.8909347));
-    double[] decode = GeoHashUtils.decode(geoHash);
-    assertEquals(52.37380061d, decode[0], 0.000001d);
-    assertEquals(4.8909343d, decode[1], 0.000001d);
-    
-    assertEquals(geoHash, GeoHashUtils.encode(decode[0], decode[1]));
-    
-    geoHash = "u173";
-    decode = GeoHashUtils.decode("u173");
-    geoHash = GeoHashUtils.encode(decode[0], decode[1]);
-    assertEquals(decode[0], GeoHashUtils.decode(geoHash)[0], 0.000001d);
-    assertEquals(decode[1], GeoHashUtils.decode(geoHash)[1], 0.000001d);
-  }
-}
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geometry/TestDistanceUnits.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geometry/TestDistanceUnits.java
deleted file mode 100644
index f175885..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/geometry/TestDistanceUnits.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.apache.lucene.spatial.geometry;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-/**
- * Tests for {@link org.apache.lucene.spatial.geometry.DistanceUnits}
- */
-public class TestDistanceUnits extends LuceneTestCase {
-
-  /**
-   * Pass condition: When finding the DistanceUnit for "km", KILOMETRES is found.  When finding the DistanceUnit for
-   * "miles", MILES is found.
-   */
-  @Test
-  public void testFindDistanceUnit() {
-    assertEquals(DistanceUnits.KILOMETERS, DistanceUnits.findDistanceUnit("km"));
-    assertEquals(DistanceUnits.MILES, DistanceUnits.findDistanceUnit("miles"));
-  }
-
-  /**
-   * Pass condition: Searching for the DistanceUnit of an unknown unit "mls" should throw an IllegalArgumentException.
-   */
-  @Test
-  public void testFindDistanceUnit_unknownUnit() {
-    try {
-      DistanceUnits.findDistanceUnit("mls");
-      assertTrue("IllegalArgumentException should have been thrown", false);
-    } catch (IllegalArgumentException iae) {
-      // Expected
-    }
-  }
-
-  /**
-   * Pass condition: Converting between the same units should not change the value.  Converting from MILES to KILOMETRES
-   * involves multiplying the distance by the ratio, and converting from KILOMETRES to MILES involves dividing by the ratio
-   */
-  @Test
-  public void testConvert() {
-    assertEquals(10.5, DistanceUnits.MILES.convert(10.5, DistanceUnits.MILES), 0D);
-    assertEquals(10.5, DistanceUnits.KILOMETERS.convert(10.5, DistanceUnits.KILOMETERS), 0D);
-    assertEquals(10.5 * 1.609344, DistanceUnits.KILOMETERS.convert(10.5, DistanceUnits.MILES), 0D);
-    assertEquals(10.5 / 1.609344, DistanceUnits.MILES.convert(10.5, DistanceUnits.KILOMETERS), 0D);
-  }
-}
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
deleted file mode 100644
index 0250549..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
+++ /dev/null
@@ -1,493 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.FieldType.NumericType;
-import org.apache.lucene.document.DoubleField;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.spatial.DistanceUtils;
-import org.apache.lucene.spatial.geohash.GeoHashUtils;
-import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
-import org.apache.lucene.spatial.geometry.LatLng;
-import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
-import org.apache.lucene.spatial.tier.projections.IProjector;
-import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-public class TestCartesian extends LuceneTestCase {
-
-  private Directory directory;
-  private IndexSearcher searcher;
-  // reston va
-  private double lat = 38.969398; 
-  private double lng= -77.386398;
-  private String latField = "lat";
-  private String lngField = "lng";
-  private List<CartesianTierPlotter> ctps = new LinkedList<CartesianTierPlotter>();
-  private String geoHashPrefix = "_geoHash_";
-  
-  private IProjector project = new SinusoidalProjector();
-  
-
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-
-    IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)));
-    
-    setUpPlotter( 2, 15);
-    
-    addData(writer);
-    
-  }
-  
-  @Override
-  public void tearDown() throws Exception {
-    directory.close();
-    super.tearDown();
-  }
-  
-  
-  private void setUpPlotter(int base, int top) {
-    
-    for (; base <= top; base ++){
-      ctps.add(new CartesianTierPlotter(base,project,
-          CartesianTierPlotter.DEFALT_FIELD_PREFIX));
-    }
-  }
-  
-  private static final FieldType latLongType = new FieldType();
-  static {
-    latLongType.setIndexed(true);
-    latLongType.setStored(true);
-    latLongType.setTokenized(true);
-    latLongType.setOmitNorms(true);
-    latLongType.setIndexOptions(IndexOptions.DOCS_ONLY);
-    latLongType.setNumericType(NumericType.DOUBLE);
-    latLongType.setNumericPrecisionStep(Integer.MAX_VALUE);
-    latLongType.freeze();
-  }
-  
-  private void addPoint(IndexWriter writer, String name, double lat, double lng) throws IOException{
-    
-    Document doc = new Document();
-
-    doc.add(newField("name", name, TextField.TYPE_STORED));
-    
-    // convert the lat / long to lucene fields
-    doc.add(new DoubleField(latField, lat, latLongType));
-    doc.add(new DoubleField(lngField, lng, latLongType));
-    
-    // add a default meta field to make searching all documents easy 
-    doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
-    
-    int ctpsize = ctps.size();
-    for (int i =0; i < ctpsize; i++){
-      CartesianTierPlotter ctp = ctps.get(i);
-      doc.add(new DoubleField(ctp.getTierFieldName(), ctp.getTierBoxId(lat, lng), latLongType));
-      
-      doc.add(newField(geoHashPrefix, GeoHashUtils.encode(lat,lng), StringField.TYPE_STORED));
-    }
-    writer.addDocument(doc);
-    
-  }
-  
-  
-  
-  private void addData(IndexWriter writer) throws IOException {
-    addPoint(writer,"McCormick &amp; Schmick's Seafood Restaurant",38.9579000,-77.3572000);
-    addPoint(writer,"Jimmy's Old Town Tavern",38.9690000,-77.3862000);
-    addPoint(writer,"Ned Devine's",38.9510000,-77.4107000);
-    addPoint(writer,"Old Brogue Irish Pub",38.9955000,-77.2884000);
-    addPoint(writer,"Alf Laylah Wa Laylah",38.8956000,-77.4258000);
-    addPoint(writer,"Sully's Restaurant &amp; Supper",38.9003000,-77.4467000);
-    addPoint(writer,"TGIFriday",38.8725000,-77.3829000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"White Tiger Restaurant",38.9027000,-77.2638000);
-    addPoint(writer,"Jammin' Java",38.9039000,-77.2622000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"WiseAcres Comedy Club",38.9248000,-77.2344000);
-    addPoint(writer,"Glen Echo Spanish Ballroom",38.9691000,-77.1400000);
-    addPoint(writer,"Whitlow's on Wilson",38.8889000,-77.0926000);
-    addPoint(writer,"Iota Club and Cafe",38.8890000,-77.0923000);
-    addPoint(writer,"Hilton Washington Embassy Row",38.9103000,-77.0451000);
-    addPoint(writer,"HorseFeathers, Bar & Grill", 39.01220000000001, -77.3942);
-    addPoint(writer,"Marshall Island Airfield",7.06, 171.2);
-    addPoint(writer, "Wonga Wongue Reserve, Gabon", -0.546562,9.459229);
-    addPoint(writer,"Midway Island",25.7, -171.7);
-    addPoint(writer,"North Pole Way",55.0, 4.0);
-   
-    writer.commit();
-    // TODO: fix CustomScoreQuery usage in testRange/testGeoHashRange so we don't need this.
-    writer.forceMerge(1);
-    writer.close();
-  }
-
-
-  public void testDistances() throws IOException, InvalidGeoException {
-    LatLng p1 = new FloatLatLng( 7.06, 171.2 );
-    LatLng p2 = new FloatLatLng( 21.6032207, -158.0 );
-    double miles = p1.arcDistance( p2, DistanceUnits.MILES );
-    if (VERBOSE) {
-      System.out.println("testDistances");
-      System.out.println("miles:" + miles);
-    }
-    assertEquals(2288.82495932794, miles, 0.001);
-    LatLng p3 = new FloatLatLng( 41.6032207, -73.087749);
-    LatLng p4 = new FloatLatLng( 55.0, 4.0 );
-    miles = p3.arcDistance( p4, DistanceUnits.MILES );
-    if (VERBOSE) System.out.println("miles:" + miles);
-    assertEquals(3474.331719997617, miles, 0.001);
-  }
-
-  /*public void testCartesianPolyFilterBuilder() throws Exception {
-    CartesianPolyFilterBuilder cpfb = new CartesianPolyFilterBuilder(CartesianTierPlotter.DEFALT_FIELD_PREFIX, 2, 15);
-    //try out some shapes
-    final double miles = 20.0;
-        // Hawaii
-        // 2300 miles to Marshall Island Airfield
-    //Hawaii to Midway is 911 miles
-    lat = 0;
-    lng = -179.9;
-    Shape shape;
-    shape = cpfb.getBoxShape(lat, lng, miles);
-    System.out.println("Tier: " + shape.getTierLevel());
-    System.out.println("area: " + shape.getArea().size());
-    lat = 30;
-    lng = -100;
-    shape = cpfb.getBoxShape(lat, lng, miles);
-    System.out.println("Tier: " + shape.getTierLevel());
-    System.out.println("area: " + shape.getArea().size());
-
-    lat = 30;
-    lng = 100;
-    shape = cpfb.getBoxShape(lat, lng, miles);
-    System.out.println("Tier: " + shape.getTierLevel());
-    System.out.println("area: " + shape.getArea().size());
-  }
-*/
-
-
-  public void testAntiM() throws IOException, InvalidGeoException {
-    IndexReader reader = IndexReader.open(directory);
-    searcher = new IndexSearcher(reader);
-
-    final double miles = 2800.0;
-        // Hawaii
-        // 2300 miles to Marshall Island Airfield
-    //Hawaii to Midway is 911 miles
-    lat = 21.6032207;
-    lng = -158.0;
-
-    if (VERBOSE) System.out.println("testAntiM");
-    // create a distance query
-    final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles,
-        latField, lngField, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true, 2, 15);
-
-    if (VERBOSE) System.out.println(dq);
-    //create a term query to search against all documents
-    Query tq = new TermQuery(new Term("metafile", "doc"));
-    // Create a distance sort
-    // As the radius filter has performed the distance calculations
-    // already, pass in the filter to reuse the results.
-    //
-    DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
-    Sort sort = new Sort(new SortField("foo", dsort,false));
-
-    // Perform the search, using the term query, the serial chain filter, and the
-    // distance sort
-    TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
-    int results = hits.totalHits;
-    ScoreDoc[] scoreDocs = hits.scoreDocs; 
-    
-    // Get a list of distances
-    Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-
-    // distances calculated from filter first pass must be less than total
-    // docs, from the above test of 20 items, 12 will come from the boundary box
-    // filter, but only 5 are actually in the radius of the results.
-
-    // Note Boundary Box filtering, is not accurate enough for most systems.
-
-
-    if (VERBOSE) {
-      System.out.println("Distance Filter filtered: " + distances.size());
-      System.out.println("Results: " + results);
-      System.out.println("=============================");
-      System.out.println("Distances should be 2 "+ distances.size());
-      System.out.println("Results should be 2 "+ results);
-    }
-
-    assertEquals(2, distances.size()); // fixed a store of only needed distances
-    assertEquals(2, results);
-    double lastDistance = 0;
-    for(int i =0 ; i < results; i++){
-      Document d = searcher.doc(scoreDocs[i].doc);
-
-      String name = d.get("name");
-      double rsLat = d.getField(latField).numericValue().doubleValue();
-      double rsLng = d.getField(lngField).numericValue().doubleValue();
-      Double geo_distance = distances.get(scoreDocs[i].doc);
-
-      double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
-      double llm = DistanceUtils.getLLMDistance(lat, lng, rsLat, rsLng);
-      if (VERBOSE) System.out.println("Name: "+ name +", Distance "+ distance); //(res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
-      assertTrue(Math.abs((distance - llm)) < 1);
-      assertTrue((distance < miles ));
-      assertTrue(geo_distance >= lastDistance);
-      lastDistance = geo_distance;
-    }
-    reader.close();
-  }
-
-  public void testPoleFlipping() throws IOException, InvalidGeoException {
-    IndexReader reader = IndexReader.open(directory);
-    searcher = new IndexSearcher(reader);
-
-    final double miles = 3500.0;
-    lat = 41.6032207;
-    lng = -73.087749;
-
-    if (VERBOSE) System.out.println("testPoleFlipping");
-
-    // create a distance query
-    final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles,
-        latField, lngField, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true, 2, 15);
-
-    if (VERBOSE) System.out.println(dq);
-    //create a term query to search against all documents
-    Query tq = new TermQuery(new Term("metafile", "doc"));
-    // Create a distance sort
-    // As the radius filter has performed the distance calculations
-    // already, pass in the filter to reuse the results.
-    //
-    DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
-    Sort sort = new Sort(new SortField("foo", dsort,false));
-
-    // Perform the search, using the term query, the serial chain filter, and the
-    // distance sort
-    TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
-    int results = hits.totalHits;
-    ScoreDoc[] scoreDocs = hits.scoreDocs; 
-
-    // Get a list of distances
-    Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-
-    // distances calculated from filter first pass must be less than total
-    // docs, from the above test of 20 items, 12 will come from the boundary box
-    // filter, but only 5 are actually in the radius of the results.
-
-    // Note Boundary Box filtering, is not accurate enough for most systems.
-
-
-    if (VERBOSE) {
-      System.out.println("Distance Filter filtered: " + distances.size());
-      System.out.println("Results: " + results);
-      System.out.println("=============================");
-      System.out.println("Distances should be 18 "+ distances.size());
-      System.out.println("Results should be 18 "+ results);
-    }
-
-    assertEquals(18, distances.size()); // fixed a store of only needed distances
-    assertEquals(18, results);
-    double lastDistance = 0;
-    for(int i =0 ; i < results; i++){
-      Document d = searcher.doc(scoreDocs[i].doc);
-      String name = d.get("name");
-      double rsLat = d.getField(latField).numericValue().doubleValue();
-      double rsLng = d.getField(lngField).numericValue().doubleValue();
-      Double geo_distance = distances.get(scoreDocs[i].doc);
-
-      double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
-      double llm = DistanceUtils.getLLMDistance(lat, lng, rsLat, rsLng);
-      if (VERBOSE) System.out.println("Name: "+ name +", Distance "+ distance); //(res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
-      assertTrue(Math.abs((distance - llm)) < 1);
-      if (VERBOSE) System.out.println("checking limit "+ distance + " < " + miles);
-      assertTrue((distance < miles ));
-      if (VERBOSE) System.out.println("checking sort "+ geo_distance + " >= " + lastDistance);
-      assertTrue(geo_distance >= lastDistance);
-      lastDistance = geo_distance;
-    }
-    reader.close();
-  }
-  
-  public void testRange() throws IOException, InvalidGeoException {
-    IndexReader reader = IndexReader.open(directory);
-    searcher = new IndexSearcher(reader);
-
-    final double[] milesToTest = new double[] {6.0, 0.5, 0.001, 0.0};
-    final int[] expected = new int[] {7, 1, 0, 0};
-
-    for(int x=0;x<expected.length;x++) {
-    
-      final double miles = milesToTest[x];
-    
-      // create a distance query
-      final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
-                                                               latField, lngField, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true, 2, 15);
-     
-      if (VERBOSE) System.out.println(dq);
-      //create a term query to search against all documents
-      Query tq = new TermQuery(new Term("metafile", "doc"));
-      // Create a distance sort
-      // As the radius filter has performed the distance calculations
-      // already, pass in the filter to reuse the results.
-      // 
-      DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
-      Sort sort = new Sort(new SortField("foo", dsort,false));
-    
-      // Perform the search, using the term query, the serial chain filter, and the
-      // distance sort
-      TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
-      int results = hits.totalHits;
-      ScoreDoc[] scoreDocs = hits.scoreDocs; 
-    
-      // Get a list of distances 
-      Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-    
-      // distances calculated from filter first pass must be less than total
-      // docs, from the above test of 20 items, 12 will come from the boundary box
-      // filter, but only 5 are actually in the radius of the results.
-    
-      // Note Boundary Box filtering, is not accurate enough for most systems.
-    
-      if (VERBOSE) {
-        System.out.println("Distance Filter filtered: " + distances.size());
-        System.out.println("Results: " + results);
-        System.out.println("=============================");
-        System.out.println("Distances should be 7 "+ expected[x] + ":" + distances.size());
-        System.out.println("Results should be 7 "+ expected[x] + ":" + results);
-      }
-
-      assertEquals(expected[x], distances.size()); // fixed a store of only needed distances
-      assertEquals(expected[x], results);
-      double lastDistance = 0;
-      for(int i =0 ; i < results; i++){
-        Document d = searcher.doc(scoreDocs[i].doc);
-      
-        String name = d.get("name");
-        double rsLat = d.getField(latField).numericValue().doubleValue();
-        double rsLng = d.getField(lngField).numericValue().doubleValue(); 
-        Double geo_distance = distances.get(scoreDocs[i].doc);
-      
-        double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
-        double llm = DistanceUtils.getLLMDistance(lat, lng, rsLat, rsLng);
-        if (VERBOSE) System.out.println("Name: "+ name +", Distance "+ distance); //(res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
-        assertTrue(Math.abs((distance - llm)) < 1);
-        assertTrue((distance < miles ));
-        assertTrue(geo_distance > lastDistance);
-        lastDistance = geo_distance;
-      }
-    }
-    reader.close();
-  }
-  
-  
-  
-  public void testGeoHashRange() throws IOException, InvalidGeoException {
-    IndexReader reader = IndexReader.open(directory);
-    searcher = new IndexSearcher(reader);
-	    
-    final double[] milesToTest = new double[] {6.0, 0.5, 0.001, 0.0};
-    final int[] expected = new int[] {7, 1, 0, 0};
-
-    for(int x=0;x<expected.length;x++) {
-      final double miles = milesToTest[x];
-	    
-      // create a distance query
-      final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
-                                                               geoHashPrefix, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true, 2, 15);
-	     
-      if (VERBOSE) System.out.println(dq);
-      //create a term query to search against all documents
-      Query tq = new TermQuery(new Term("metafile", "doc"));
-      // Create a distance sort
-      // As the radius filter has performed the distance calculations
-      // already, pass in the filter to reuse the results.
-      // 
-      //DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
-      //Sort sort = new Sort(new SortField("foo", dsort));
-	    
-      // Perform the search, using the term query, the serial chain filter, and the
-      // distance sort
-      TopDocs hits = searcher.search(tq,dq.getFilter(), 1000); //,sort);
-      int results = hits.totalHits;
-      ScoreDoc[] scoreDocs = hits.scoreDocs; 
-	    
-      // Get a list of distances 
-      Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-	    
-      // distances calculated from filter first pass must be less than total
-      // docs, from the above test of 20 items, 12 will come from the boundary box
-      // filter, but only 5 are actually in the radius of the results.
-	    
-      // Note Boundary Box filtering, is not accurate enough for most systems.
-	    
-	    if (VERBOSE) {
-        System.out.println("Distance Filter filtered: " + distances.size());
-        System.out.println("Results: " + results);
-        System.out.println("=============================");
-        System.out.println("Distances should be 14 "+ expected[x] + ":" + distances.size());
-        System.out.println("Results should be 7 "+ expected[x] + ":" + results);
-      }
-
-      assertEquals(expected[x], distances.size());
-      assertEquals(expected[x], results);
-	    
-      for(int i =0 ; i < results; i++){
-        Document d = searcher.doc(scoreDocs[i].doc);
-	      
-        String name = d.get("name");
-        double rsLat = d.getField(latField).numericValue().doubleValue();
-        double rsLng = d.getField(lngField).numericValue().doubleValue(); 
-        Double geo_distance = distances.get(scoreDocs[i].doc);
-	      
-        double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
-        double llm = DistanceUtils.getLLMDistance(lat, lng, rsLat, rsLng);
-        if (VERBOSE) System.out.println("Name: "+ name +", Distance (res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ scoreDocs[i].score);
-        assertTrue(Math.abs((distance - llm)) < 1);
-        assertTrue((distance < miles ));
-	      
-      }
-    }
-    reader.close();
-  }
-}
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
deleted file mode 100644
index cc30bf7..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.FieldType.NumericType;
-import org.apache.lucene.document.DoubleField;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.QueryWrapperFilter;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-
-public class TestDistance extends LuceneTestCase {
-  
-  private Directory directory;
-  // reston va
-  private double lat = 38.969398; 
-  private double lng= -77.386398;
-  private String latField = "lat";
-  private String lngField = "lng";
-  private IndexWriter writer;
-  
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    writer = new IndexWriter(directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)));
-    addData(writer);
-    
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    writer.close();
-    directory.close();
-    super.tearDown();
-  }
-
-  private static final FieldType latLongType = new FieldType();
-  static {
-    latLongType.setIndexed(true);
-    latLongType.setStored(true);
-    latLongType.setTokenized(true);
-    latLongType.setOmitNorms(true);
-    latLongType.setIndexOptions(IndexOptions.DOCS_ONLY);
-    latLongType.setNumericType(NumericType.DOUBLE);
-    latLongType.setNumericPrecisionStep(Integer.MAX_VALUE);
-    latLongType.freeze();
-  }
-  
-  private void addPoint(IndexWriter writer, String name, double lat, double lng) throws IOException{
-    
-    Document doc = new Document();
-
-    doc.add(newField("name", name, TextField.TYPE_STORED));
-    
-    // convert the lat / long to lucene fields
-    doc.add(new DoubleField(latField, lat, latLongType));
-    doc.add(new DoubleField(lngField, lng, latLongType));
-    
-    // add a default meta field to make searching all documents easy 
-    doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
-    writer.addDocument(doc);
-    
-  }
-  
-
-  private void addData(IndexWriter writer) throws IOException {
-    addPoint(writer,"McCormick &amp; Schmick's Seafood Restaurant",38.9579000,-77.3572000);
-    addPoint(writer,"Jimmy's Old Town Tavern",38.9690000,-77.3862000);
-    addPoint(writer,"Ned Devine's",38.9510000,-77.4107000);
-    addPoint(writer,"Old Brogue Irish Pub",38.9955000,-77.2884000);
-    addPoint(writer,"Alf Laylah Wa Laylah",38.8956000,-77.4258000);
-    addPoint(writer,"Sully's Restaurant &amp; Supper",38.9003000,-77.4467000);
-    addPoint(writer,"TGIFriday",38.8725000,-77.3829000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"White Tiger Restaurant",38.9027000,-77.2638000);
-    addPoint(writer,"Jammin' Java",38.9039000,-77.2622000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"WiseAcres Comedy Club",38.9248000,-77.2344000);
-    addPoint(writer,"Glen Echo Spanish Ballroom",38.9691000,-77.1400000);
-    addPoint(writer,"Whitlow's on Wilson",38.8889000,-77.0926000);
-    addPoint(writer,"Iota Club and Cafe",38.8890000,-77.0923000);
-    addPoint(writer,"Hilton Washington Embassy Row",38.9103000,-77.0451000);
-    addPoint(writer,"HorseFeathers, Bar & Grill", 39.01220000000001, -77.3942);
-    writer.commit();
-  }
-
-  public void testLatLongFilterOnDeletedDocs() throws Exception {
-    writer.deleteDocuments(new Term("name", "Potomac"));
-    IndexReader r = IndexReader.open(writer, true);
-    LatLongDistanceFilter f = new LatLongDistanceFilter(new QueryWrapperFilter(new MatchAllDocsQuery()),
-                                                        lat, lng, 1.0, latField, lngField);
-
-    AtomicReaderContext[] leaves = r.getTopReaderContext().leaves();
-    for (int i = 0; i < leaves.length; i++) {
-      f.getDocIdSet(leaves[i], leaves[i].reader().getLiveDocs());
-    }
-    r.close();
-  }
- 
-  /* these tests do not test anything, as no assertions:
-  public void testMiles() {
-    double LLM = DistanceUtils.getInstance().getLLMDistance(lat, lng,39.012200001, -77.3942);
-    System.out.println(LLM);
-    System.out.println("-->"+DistanceUtils.getInstance().getDistanceMi(lat, lng, 39.0122, -77.3942));
-  }
-  
-  public void testMiles2(){
-    System.out.println("Test Miles 2");
-    double LLM = DistanceUtils.getInstance().getLLMDistance(44.30073, -78.32131,43.687267, -79.39842);
-    System.out.println(LLM);
-    System.out.println("-->"+DistanceUtils.getInstance().getDistanceMi(44.30073, -78.32131, 43.687267, -79.39842));
-    
-  }
-  */
-  
-//  public void testDistanceQueryCacheable() throws IOException {
-//
-//    // create two of the same distance queries
-//    double miles = 6.0;
-//    DistanceQuery dq1 = new DistanceQuery(lat, lng, miles, latField, lngField, true);
-//    DistanceQuery dq2 = new DistanceQuery(lat, lng, miles, latField, lngField, true);
-//
-//    /* ensure that they hash to the same code, which will cause a cache hit in solr */
-//    System.out.println("hash differences?");
-//    assertEquals(dq1.getQuery().hashCode(), dq2.getQuery().hashCode());
-//    
-//    /* ensure that changing the radius makes a different hash code, creating a cache miss in solr */
-//    DistanceQuery widerQuery = new DistanceQuery(lat, lng, miles + 5.0, latField, lngField, false);
-//    assertTrue(dq1.getQuery().hashCode() != widerQuery.getQuery().hashCode());
-//  }
-}
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java
deleted file mode 100644
index d764200..0000000
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.apache.lucene.spatial.tier.projections;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-
-/**
- *
- *
- **/
-public class SinusoidalProjectorTest extends LuceneTestCase {
-
-  @Test
-  public void testProjection() throws Exception {
-    SinusoidalProjector prj = new SinusoidalProjector();
-    //TODO: uncomment once SinusoidalProjector is fixed.  Unfortunately, fixing it breaks a lot of other stuff
-    /*double[] doubles;
-    doubles = prj.coords(-89.0, 10);
-    assertEquals(0.003, doubles[0], 0.001);//x
-    assertEquals(-89.0 * DistanceUtils.DEGREES_TO_RADIANS, doubles[1]);
-    
-    doubles = prj.coords(89.0, 0);
-    assertEquals(0.0, doubles[0]);//x
-    assertEquals(89.0 * DistanceUtils.DEGREES_TO_RADIANS, doubles[1]);
-
-    doubles = prj.coords(89.0, 10);
-    assertEquals(0.003, doubles[0], 0.001);//x
-    assertEquals(89.0 * DistanceUtils.DEGREES_TO_RADIANS, doubles[1]);
-
-
-    doubles = prj.coords(-89.0, 0);
-    assertEquals(0.0, doubles[0]);//x
-    assertEquals(-89.0 * DistanceUtils.DEGREES_TO_RADIANS, doubles[1]);*/
-
-
-  }
-}
-
-//This code demonstrates that the SinusoidalProjector is incorrect
-  /*@Test
-  public void testFoo() throws Exception {
-    CartesianTierPlotter plotter = new CartesianTierPlotter(11, new SinusoidalProjector(), "foo");
-    SinusoidalProjector prj = new SinusoidalProjector();
-    System.out.println("---- Equator ---");
-    printValues(plotter, prj, 0);
-    System.out.println("---- North ---");
-    printValues(plotter, prj, 89.0);
-    System.out.println("---- South ---");
-    printValues(plotter, prj, -89.0);
-  }
-
-  private void printValues(CartesianTierPlotter plotter, SinusoidalProjector prj, double latitude){
-    for (int i = 0; i <= 10; i++){
-      double boxId = plotter.getTierBoxId(latitude, i);
-      double[] doubles = prj.coords(latitude, i);
-      System.out.println("Box[" + latitude + ", " + i + "] = " + boxId + " sinusoidal: [" + doubles[0] + ", " + doubles[1] + "]");
-    }
-    for (int i = -10; i <= 0; i++){
-      double boxId = plotter.getTierBoxId(latitude, i);
-      double[] doubles = prj.coords(latitude, i);
-      System.out.println("Box[" + latitude + ", " + i + "] = " + boxId + " sinusoidal: [" + doubles[0] + ", " + doubles[1] + "]");
-    }
-
-  }
-  */
\ No newline at end of file

