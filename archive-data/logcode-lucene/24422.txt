GitDiffStart: 646f0f043406de9cc580ef04e8fb0fa6540d0b44 | Sun Feb 6 14:51:59 2005 +0000
diff --git a/contrib/ant/build.xml b/contrib/ant/build.xml
index c341d5e..db4617b 100644
--- a/contrib/ant/build.xml
+++ b/contrib/ant/build.xml
@@ -15,8 +15,6 @@
                refid="additional.dependencies"
   />
 
-  <property name="src.dir" location="src/main"/>
-
   <!-- alias classpath for cleaner example in index target -->
   <path id="index.classpath">
     <path refid="test.classpath"/>
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/ConfigurableDocumentHandler.java b/contrib/ant/src/java/org/apache/lucene/ant/ConfigurableDocumentHandler.java
new file mode 100644
index 0000000..d6eb81b
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/ConfigurableDocumentHandler.java
@@ -0,0 +1,7 @@
+package org.apache.lucene.ant;
+
+import java.util.Properties;
+
+public interface ConfigurableDocumentHandler extends DocumentHandler {
+    void configure(Properties props);
+}
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandler.java b/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandler.java
new file mode 100644
index 0000000..96a2ec9
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandler.java
@@ -0,0 +1,24 @@
+package org.apache.lucene.ant;
+
+import org.apache.lucene.document.Document;
+
+import java.io.File;
+
+/**
+ *  Allows a class to act as a Lucene document handler
+ *
+ *@author     Erik Hatcher
+ *@created    October 27, 2001
+ */
+public interface DocumentHandler {
+
+    /**
+     *  Gets the document attribute of the DocumentHandler object
+     *
+     *@param  file  Description of Parameter
+     *@return       The document value
+     */
+    Document getDocument(File file)
+            throws DocumentHandlerException;
+}
+
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandlerException.java b/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandlerException.java
new file mode 100644
index 0000000..324eb26
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/DocumentHandlerException.java
@@ -0,0 +1,64 @@
+package org.apache.lucene.ant;
+
+import java.io.PrintStream;
+import java.io.PrintWriter;
+
+/**
+ */
+public class DocumentHandlerException extends Exception {
+    private Throwable cause;
+
+    /**
+     * Default constructor.
+     */
+    public DocumentHandlerException() {
+        super();
+    }
+
+    /**
+     * Constructs with message.
+     */
+    public DocumentHandlerException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs with chained exception.
+     */
+    public DocumentHandlerException(Throwable cause) {
+        super(cause.toString());
+        this.cause = cause;
+    }
+
+    /**
+     * Retrieves nested exception.
+     */
+    public Throwable getException() {
+        return cause;
+    }
+
+    public void printStackTrace() {
+        printStackTrace(System.err);
+    }
+
+    public void printStackTrace(PrintStream ps) {
+        synchronized (ps) {
+            super.printStackTrace(ps);
+            if (cause != null) {
+                ps.println("--- Nested Exception ---");
+                cause.printStackTrace(ps);
+            }
+        }
+    }
+
+    public void printStackTrace(PrintWriter pw) {
+        synchronized (pw) {
+            super.printStackTrace(pw);
+            if (cause != null) {
+                pw.println("--- Nested Exception ---");
+                cause.printStackTrace(pw);
+            }
+        }
+    }
+}
+
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/FileExtensionDocumentHandler.java b/contrib/ant/src/java/org/apache/lucene/ant/FileExtensionDocumentHandler.java
new file mode 100644
index 0000000..7962272
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/FileExtensionDocumentHandler.java
@@ -0,0 +1,49 @@
+package org.apache.lucene.ant;
+
+import org.apache.lucene.document.Document;
+
+import java.io.File;
+
+/**
+ *  A DocumentHandler implementation to delegate responsibility to
+ *  based on a files extension.  Currently only .html and .txt
+ *  files are handled, other extensions ignored.
+ *
+ *@author     Erik Hatcher
+ *@created    October 28, 2001
+ *@todo Implement dynamic document type lookup
+ */
+public class FileExtensionDocumentHandler
+        implements DocumentHandler {
+    /**
+     *  Gets the document attribute of the
+     *  FileExtensionDocumentHandler object
+     *
+     *@param  file                          Description of
+     *      Parameter
+     *@return                               The document value
+     *@exception  DocumentHandlerException  Description of
+     *      Exception
+     */
+    public Document getDocument(File file)
+            throws DocumentHandlerException {
+        Document doc = null;
+
+        String name = file.getName();
+
+        try {
+            if (name.endsWith(".txt")) {
+                doc = TextDocument.Document(file);
+            }
+
+            if (name.endsWith(".html")) {
+                doc = HtmlDocument.Document(file);
+            }
+        } catch (java.io.IOException e) {
+            throw new DocumentHandlerException(e);
+        }
+
+        return doc;
+    }
+}
+
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/HtmlDocument.java b/contrib/ant/src/java/org/apache/lucene/ant/HtmlDocument.java
new file mode 100644
index 0000000..7bf1768
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/HtmlDocument.java
@@ -0,0 +1,226 @@
+package org.apache.lucene.ant;
+
+import org.apache.lucene.document.Field;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.w3c.dom.Text;
+import org.w3c.tidy.Tidy;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.StringWriter;
+
+/**
+ *  The <code>HtmlDocument</code> class creates a Lucene {@link
+ *  org.apache.lucene.document.Document} from an HTML document. <P>
+ *
+ *  It does this by using JTidy package. It can take input input
+ *  from {@link java.io.File} or {@link java.io.InputStream}.
+ *
+ *@author     Erik Hatcher
+ */
+public class HtmlDocument {
+    private Element rawDoc;
+
+
+    //-------------------------------------------------------------
+    // Constructors
+    //-------------------------------------------------------------
+
+    /**
+     *  Constructs an <code>HtmlDocument</code> from a {@link
+     *  java.io.File}.
+     *
+     *@param  file             the <code>File</code> containing the
+     *      HTML to parse
+     *@exception  IOException  if an I/O exception occurs
+     *@since
+     */
+    public HtmlDocument(File file) throws IOException {
+        Tidy tidy = new Tidy();
+        tidy.setQuiet(true);
+        tidy.setShowWarnings(false);
+        org.w3c.dom.Document root =
+                tidy.parseDOM(new FileInputStream(file), null);
+        rawDoc = root.getDocumentElement();
+    }
+
+
+    /**
+     *  Constructs an <code>HtmlDocument</code> from an {@link
+     *  java.io.InputStream}.
+     *
+     *@param  is               the <code>InputStream</code>
+     *      containing the HTML
+     *@exception  IOException  if I/O exception occurs
+     *@since
+     */
+    public HtmlDocument(InputStream is) {
+        Tidy tidy = new Tidy();
+        tidy.setQuiet(true);
+        tidy.setShowWarnings(false);
+        org.w3c.dom.Document root = tidy.parseDOM(is, null);
+        rawDoc = root.getDocumentElement();
+    }
+
+
+    /**
+     *  Creates a Lucene <code>Document</code> from an {@link
+     *  java.io.InputStream}.
+     *
+     *@param  is
+     *@return
+     *@exception  IOException
+     */
+    public static org.apache.lucene.document.Document
+            getDocument(InputStream is) {
+        HtmlDocument htmlDoc = new HtmlDocument(is);
+        org.apache.lucene.document.Document luceneDoc =
+                new org.apache.lucene.document.Document();
+
+        luceneDoc.add(new Field("title", htmlDoc.getTitle(), Field.Store.YES, Field.Index.TOKENIZED));
+        luceneDoc.add(new Field("contents", htmlDoc.getBody(), Field.Store.YES, Field.Index.TOKENIZED));
+
+        return luceneDoc;
+    }
+
+
+    //-------------------------------------------------------------
+    // Public methods
+    //-------------------------------------------------------------
+
+    /**
+     *  Creates a Lucene <code>Document</code> from a {@link
+     *  java.io.File}.
+     *
+     *@param  file
+     *@return
+     *@exception  IOException
+     */
+    public static org.apache.lucene.document.Document
+            Document(File file) throws IOException {
+        HtmlDocument htmlDoc = new HtmlDocument(file);
+        org.apache.lucene.document.Document luceneDoc =
+                new org.apache.lucene.document.Document();
+
+        luceneDoc.add(new Field("title", htmlDoc.getTitle(), Field.Store.YES, Field.Index.TOKENIZED));
+        luceneDoc.add(new Field("contents", htmlDoc.getBody(), Field.Store.YES, Field.Index.TOKENIZED));
+
+        String contents = null;
+        BufferedReader br =
+                new BufferedReader(new FileReader(file));
+        StringWriter sw = new StringWriter();
+        String line = br.readLine();
+        while (line != null) {
+            sw.write(line);
+            line = br.readLine();
+        }
+        br.close();
+        contents = sw.toString();
+        sw.close();
+
+        luceneDoc.add(new Field("rawcontents", contents, Field.Store.YES, Field.Index.NO));
+
+        return luceneDoc;
+    }
+
+
+    //-------------------------------------------------------------
+    // Private methods
+    //-------------------------------------------------------------
+
+    /**
+     *  Runs <code>HtmlDocument</code> on the files specified on
+     *  the command line.
+     *
+     *@param  args           Command line arguments
+     *@exception  Exception  Description of Exception
+     */
+    public static void main(String args[]) throws Exception {
+//         HtmlDocument doc = new HtmlDocument(new File(args[0]));
+//         System.out.println("Title = " + doc.getTitle());
+//         System.out.println("Body  = " + doc.getBody());
+
+        HtmlDocument doc =
+                new HtmlDocument(new FileInputStream(new File(args[0])));
+        System.out.println("Title = " + doc.getTitle());
+        System.out.println("Body  = " + doc.getBody());
+    }
+
+
+    /**
+     *  Gets the title attribute of the <code>HtmlDocument</code>
+     *  object.
+     *
+     *@return    the title value
+     */
+    public String getTitle() {
+        if (rawDoc == null) {
+            return null;
+        }
+
+        String title = "";
+
+        NodeList nl = rawDoc.getElementsByTagName("title");
+        if (nl.getLength() > 0) {
+            Element titleElement = ((Element) nl.item(0));
+            Text text = (Text) titleElement.getFirstChild();
+            if (text != null) {
+                title = text.getData();
+            }
+        }
+        return title;
+    }
+
+
+    /**
+     *  Gets the bodyText attribute of the
+     *  <code>HtmlDocument</code> object.
+     *
+     *@return    the bodyText value
+     */
+    public String getBody() {
+        if (rawDoc == null) {
+            return null;
+        }
+
+        String body = "";
+        NodeList nl = rawDoc.getElementsByTagName("body");
+        if (nl.getLength() > 0) {
+            body = getBodyText(nl.item(0));
+        }
+        return body;
+    }
+
+
+    /**
+     *  Gets the bodyText attribute of the
+     *  <code>HtmlDocument</code> object.
+     *
+     *@param  node  a DOM Node
+     *@return       The bodyText value
+     */
+    private String getBodyText(Node node) {
+        NodeList nl = node.getChildNodes();
+        StringBuffer buffer = new StringBuffer();
+        for (int i = 0; i < nl.getLength(); i++) {
+            Node child = nl.item(i);
+            switch (child.getNodeType()) {
+                case Node.ELEMENT_NODE:
+                    buffer.append(getBodyText(child));
+                    buffer.append(" ");
+                    break;
+                case Node.TEXT_NODE:
+                    buffer.append(((Text) child).getData());
+                    break;
+            }
+        }
+        return buffer.toString();
+    }
+}
+
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/IndexTask.java b/contrib/ant/src/java/org/apache/lucene/ant/IndexTask.java
new file mode 100644
index 0000000..774e1c0
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/IndexTask.java
@@ -0,0 +1,389 @@
+package org.apache.lucene.ant;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.StopAnalyzer;
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.TermQuery;
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.DirectoryScanner;
+import org.apache.tools.ant.DynamicConfigurator;
+import org.apache.tools.ant.Project;
+import org.apache.tools.ant.Task;
+import org.apache.tools.ant.types.FileSet;
+import org.apache.tools.ant.types.EnumeratedAttribute;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Date;
+import java.util.Properties;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.ArrayList;
+
+/**
+ *  Ant task to index files with Lucene
+ *
+ *@author Erik Hatcher
+ */
+public class IndexTask extends Task {
+  /**
+   *  file list
+   */
+  private ArrayList filesets = new ArrayList();
+
+  /**
+   *  overwrite index?
+   */
+  private boolean overwrite = false;
+
+  /**
+   *  index path
+   */
+  private File indexDir;
+
+  /**
+   *  document handler classname
+   */
+  private String handlerClassName =
+    FileExtensionDocumentHandler.class.getName();
+
+  /**
+   *  document handler instance
+   */
+  private DocumentHandler handler;
+
+
+  /**
+   *
+   */
+  private String analyzerClassName =
+    StandardAnalyzer.class.getName();
+
+  /**
+   *  analyzer instance
+   */
+  private Analyzer analyzer;
+
+  /**
+   *  Lucene merge factor
+   */
+  private int mergeFactor = 20;
+
+  private HandlerConfig handlerConfig;
+
+  private boolean useCompoundIndex = true;
+
+
+  /**
+   *  Creates new instance
+   */
+  public IndexTask() {
+  }
+
+
+  /**
+   *  Specifies the directory where the index will be stored
+   */
+  public void setIndex(File indexDir) {
+    this.indexDir = indexDir;
+  }
+
+
+  /**
+   *  Sets the mergeFactor attribute of the IndexTask object
+   *
+   *@param  mergeFactor  The new mergeFactor value
+   */
+  public void setMergeFactor(int mergeFactor) {
+    this.mergeFactor = mergeFactor;
+  }
+
+
+  /**
+   *  Sets the overwrite attribute of the IndexTask object
+   *
+   *@param  overwrite  The new overwrite value
+   */
+  public void setOverwrite(boolean overwrite) {
+    this.overwrite = overwrite;
+  }
+
+
+  /**
+   * If creating a new index and this is set to true, the
+   * index will be created in compound format.
+   */ 
+  public void setUseCompoundIndex(boolean useCompoundIndex) {
+    this.useCompoundIndex = useCompoundIndex;
+  }
+
+  /**
+   *  Sets the documentHandler attribute of the IndexTask object
+   *
+   *@param  classname  The new documentHandler value
+   */
+  public void setDocumentHandler(String classname) {
+    handlerClassName = classname;
+  }
+
+  /**
+   * Sets the analyzer based on the builtin Lucene analyzer types.
+   *
+   * @todo Enforce analyzer and analyzerClassName to be mutually exclusive
+   */
+  public void setAnalyzer(AnalyzerType type) {
+    analyzerClassName = type.getClassname();
+  }
+
+  public void setAnalyzerClassName(String classname) {
+    analyzerClassName = classname;
+  }
+
+  /**
+   *  Adds a set of files (nested fileset attribute).
+   *
+   *@param  set  FileSet to be added
+   */
+  public void addFileset(FileSet set) {
+    filesets.add(set);
+  }
+
+  /**
+   * Sets custom properties for a configurable document handler.
+   */
+  public void addConfig(HandlerConfig config) throws BuildException {
+    if (handlerConfig != null) {
+      throw new BuildException("Only one config element allowed");
+    }
+
+    handlerConfig = config;
+  }
+
+
+  /**
+   *  Begins the indexing
+   *
+   *@exception  BuildException  If an error occurs indexing the
+   *      fileset
+   */
+  public void execute() throws BuildException {
+
+    // construct handler and analyzer dynamically
+    try {
+      Class clazz = Class.forName(handlerClassName);
+      handler = (DocumentHandler) clazz.newInstance();
+
+      clazz = Class.forName(analyzerClassName);
+      analyzer = (Analyzer) clazz.newInstance();
+    } catch (ClassNotFoundException cnfe) {
+      throw new BuildException(cnfe);
+    } catch (InstantiationException ie) {
+      throw new BuildException(ie);
+    } catch (IllegalAccessException iae) {
+      throw new BuildException(iae);
+    }
+
+    log("Document handler = " + handler.getClass(), Project.MSG_VERBOSE);
+    log("Analyzer = " + analyzer.getClass(), Project.MSG_VERBOSE);
+
+    if (handler instanceof ConfigurableDocumentHandler) {
+      ((ConfigurableDocumentHandler) handler).configure(handlerConfig.getProperties());
+    }
+
+    try {
+      indexDocs();
+    } catch (IOException e) {
+      throw new BuildException(e);
+    }
+  }
+
+
+  /**
+   * Index the fileset.
+   *
+   *@exception  IOException if Lucene I/O exception
+   *@todo refactor!!!!!
+   */
+  private void indexDocs() throws IOException {
+    Date start = new Date();
+
+    boolean create = overwrite;
+    // If the index directory doesn't exist,
+    // create it and force create mode
+    if (indexDir.mkdirs() && !overwrite) {
+      create = true;
+    }
+
+    Searcher searcher = null;
+    boolean checkLastModified = false;
+    if (!create) {
+      try {
+        searcher = new IndexSearcher(indexDir.getAbsolutePath());
+        checkLastModified = true;
+      } catch (IOException ioe) {
+        log("IOException: " + ioe.getMessage());
+        // Empty - ignore, which indicates to index all
+        // documents
+      }
+    }
+
+    log("checkLastModified = " + checkLastModified, Project.MSG_VERBOSE);
+
+    IndexWriter writer =
+      new IndexWriter(indexDir, analyzer, create);
+
+    writer.setUseCompoundFile(useCompoundIndex);
+    int totalFiles = 0;
+    int totalIndexed = 0;
+    int totalIgnored = 0;
+    try {
+      writer.setMergeFactor(mergeFactor);
+
+      for (int i = 0; i < filesets.size(); i++) {
+        FileSet fs = (FileSet) filesets.get(i);
+        if (fs != null) {
+          DirectoryScanner ds =
+            fs.getDirectoryScanner(getProject());
+          String[] dsfiles = ds.getIncludedFiles();
+          File baseDir = ds.getBasedir();
+
+          for (int j = 0; j < dsfiles.length; j++) {
+            File file = new File(baseDir, dsfiles[j]);
+            totalFiles++;
+
+            if (!file.exists() || !file.canRead()) {
+              throw new BuildException("File \"" +
+                                       file.getAbsolutePath()
+                                       + "\" does not exist or is not readable.");
+            }
+
+            boolean indexIt = true;
+
+            if (checkLastModified) {
+              Term pathTerm =
+                new Term("path", file.getPath());
+              TermQuery query =
+                new TermQuery(pathTerm);
+              Hits hits = searcher.search(query);
+
+              // if document is found, compare the
+              // indexed last modified time with the
+              // current file
+              // - don't index if up to date
+              if (hits.length() > 0) {
+                Document doc = hits.doc(0);
+                String indexModified =
+                  doc.get("modified").trim();
+                if (indexModified != null) {
+                  if (DateField.stringToTime(indexModified)
+                    == file.lastModified()) {
+                    // TODO: remove existing document
+                    indexIt = false;
+                  }
+                }
+              }
+            }
+
+            if (indexIt) {
+              try {
+                log("Indexing " + file.getPath(),
+                    Project.MSG_VERBOSE);
+                Document doc =
+                  handler.getDocument(file);
+
+                if (doc == null) {
+                  totalIgnored++;
+                } else {
+                  // Add the path of the file as a field named "path".  Use a Keyword field, so
+                  // that the index stores the path, and so that the path is searchable
+                  doc.add(new Field("path", file.getPath(), Field.Store.YES, Field.Index.UN_TOKENIZED));
+
+                  // Add the last modified date of the file a field named "modified".  Use a
+                  // Keyword field, so that it's searchable, but so that no attempt is made
+                  // to tokenize the field into words.
+                  doc.add(new Field("modified", DateField.timeToString(file.lastModified()), Field.Store.YES, Field.Index.UN_TOKENIZED));
+
+                  writer.addDocument(doc);
+                  totalIndexed++;
+                }
+              } catch (DocumentHandlerException e) {
+                throw new BuildException(e);
+              }
+            }
+          }
+          // for j
+        }
+        // if (fs != null)
+      }
+      // for i
+
+      writer.optimize();
+    }
+      //try
+    finally {
+      // always make sure everything gets closed,
+      // no matter how we exit.
+      writer.close();
+      if (searcher != null) {
+        searcher.close();
+      }
+    }
+
+    Date end = new Date();
+
+    log(totalIndexed + " out of " + totalFiles + " indexed (" +
+        totalIgnored + " ignored) in " + (end.getTime() - start.getTime()) +
+        " milliseconds");
+  }
+
+  public static class HandlerConfig implements DynamicConfigurator {
+    Properties props = new Properties();
+
+    public void setDynamicAttribute(String attributeName, String value) throws BuildException {
+      props.setProperty(attributeName, value);
+    }
+
+    public Object createDynamicElement(String elementName) throws BuildException {
+      throw new BuildException("Sub elements not supported");
+    }
+
+    public Properties getProperties() {
+      return props;
+    }
+  }
+
+ public static class AnalyzerType extends EnumeratedAttribute {
+    private static Map analyzerLookup = new HashMap();
+
+    static {
+      analyzerLookup.put("simple", SimpleAnalyzer.class.getName());
+      analyzerLookup.put("standard", StandardAnalyzer.class.getName());
+      analyzerLookup.put("stop", StopAnalyzer.class.getName());
+      analyzerLookup.put("whitespace", WhitespaceAnalyzer.class.getName());
+    }
+
+    /**
+     * @see EnumeratedAttribute#getValues
+     */
+    public String[] getValues() {
+      Set keys = analyzerLookup.keySet();
+      return (String[]) keys.toArray(new String[0]);
+    }
+
+    public String getClassname() {
+      return (String) analyzerLookup.get(getValue());
+    }
+  }
+}
+
diff --git a/contrib/ant/src/java/org/apache/lucene/ant/TextDocument.java b/contrib/ant/src/java/org/apache/lucene/ant/TextDocument.java
new file mode 100644
index 0000000..b03bd36
--- /dev/null
+++ b/contrib/ant/src/java/org/apache/lucene/ant/TextDocument.java
@@ -0,0 +1,82 @@
+package org.apache.lucene.ant;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.StringWriter;
+
+/**
+ *  A utility for making Lucene Documents from a File.
+ *
+ *@author     Erik Hatcher
+ *@created    December 6, 2001
+ *@todo       Fix JavaDoc comments here
+ */
+
+public class TextDocument {
+    private String contents;
+
+
+    /**
+     *  Constructor for the TextDocument object
+     *
+     *@param  file             Description of Parameter
+     *@exception  IOException  Description of Exception
+     */
+    public TextDocument(File file) throws IOException {
+        BufferedReader br =
+                new BufferedReader(new FileReader(file));
+        StringWriter sw = new StringWriter();
+
+        String line = br.readLine();
+        while (line != null) {
+            sw.write(line);
+            line = br.readLine();
+        }
+        br.close();
+
+        contents = sw.toString();
+        sw.close();
+    }
+
+
+    /**
+     *  Makes a document for a File. <p>
+     *
+     *  The document has a single field:
+     *  <ul>
+     *    <li> <code>contents</code>--containing the full contents
+     *    of the file, as a Text field;
+     *
+     *@param  f                Description of Parameter
+     *@return                  Description of the Returned Value
+     *@exception  IOException  Description of Exception
+     */
+    public static Document Document(File f) throws IOException {
+
+        TextDocument textDoc = new TextDocument(f);
+        // make a new, empty document
+        Document doc = new Document();
+
+        doc.add(new Field("title", f.getName(), Field.Store.YES, Field.Index.TOKENIZED));
+        doc.add(new Field("contents", textDoc.getContents(), Field.Store.YES, Field.Index.TOKENIZED));
+        doc.add(new Field("rawcontents", textDoc.getContents(), Field.Store.YES, Field.Index.NO));
+
+        // return the document
+        return doc;
+    }
+
+
+    /**
+     *@return    The contents value
+     *@todo      finish this method
+     */
+    public String getContents() {
+        return contents;
+    }
+}
+
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/ConfigurableDocumentHandler.java b/contrib/ant/src/main/org/apache/lucene/ant/ConfigurableDocumentHandler.java
deleted file mode 100644
index d6eb81b..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/ConfigurableDocumentHandler.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.apache.lucene.ant;
-
-import java.util.Properties;
-
-public interface ConfigurableDocumentHandler extends DocumentHandler {
-    void configure(Properties props);
-}
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandler.java b/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandler.java
deleted file mode 100644
index 96a2ec9..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandler.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.apache.lucene.ant;
-
-import org.apache.lucene.document.Document;
-
-import java.io.File;
-
-/**
- *  Allows a class to act as a Lucene document handler
- *
- *@author     Erik Hatcher
- *@created    October 27, 2001
- */
-public interface DocumentHandler {
-
-    /**
-     *  Gets the document attribute of the DocumentHandler object
-     *
-     *@param  file  Description of Parameter
-     *@return       The document value
-     */
-    Document getDocument(File file)
-            throws DocumentHandlerException;
-}
-
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandlerException.java b/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandlerException.java
deleted file mode 100644
index 324eb26..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/DocumentHandlerException.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.apache.lucene.ant;
-
-import java.io.PrintStream;
-import java.io.PrintWriter;
-
-/**
- */
-public class DocumentHandlerException extends Exception {
-    private Throwable cause;
-
-    /**
-     * Default constructor.
-     */
-    public DocumentHandlerException() {
-        super();
-    }
-
-    /**
-     * Constructs with message.
-     */
-    public DocumentHandlerException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs with chained exception.
-     */
-    public DocumentHandlerException(Throwable cause) {
-        super(cause.toString());
-        this.cause = cause;
-    }
-
-    /**
-     * Retrieves nested exception.
-     */
-    public Throwable getException() {
-        return cause;
-    }
-
-    public void printStackTrace() {
-        printStackTrace(System.err);
-    }
-
-    public void printStackTrace(PrintStream ps) {
-        synchronized (ps) {
-            super.printStackTrace(ps);
-            if (cause != null) {
-                ps.println("--- Nested Exception ---");
-                cause.printStackTrace(ps);
-            }
-        }
-    }
-
-    public void printStackTrace(PrintWriter pw) {
-        synchronized (pw) {
-            super.printStackTrace(pw);
-            if (cause != null) {
-                pw.println("--- Nested Exception ---");
-                cause.printStackTrace(pw);
-            }
-        }
-    }
-}
-
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/FileExtensionDocumentHandler.java b/contrib/ant/src/main/org/apache/lucene/ant/FileExtensionDocumentHandler.java
deleted file mode 100644
index 7962272..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/FileExtensionDocumentHandler.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.apache.lucene.ant;
-
-import org.apache.lucene.document.Document;
-
-import java.io.File;
-
-/**
- *  A DocumentHandler implementation to delegate responsibility to
- *  based on a files extension.  Currently only .html and .txt
- *  files are handled, other extensions ignored.
- *
- *@author     Erik Hatcher
- *@created    October 28, 2001
- *@todo Implement dynamic document type lookup
- */
-public class FileExtensionDocumentHandler
-        implements DocumentHandler {
-    /**
-     *  Gets the document attribute of the
-     *  FileExtensionDocumentHandler object
-     *
-     *@param  file                          Description of
-     *      Parameter
-     *@return                               The document value
-     *@exception  DocumentHandlerException  Description of
-     *      Exception
-     */
-    public Document getDocument(File file)
-            throws DocumentHandlerException {
-        Document doc = null;
-
-        String name = file.getName();
-
-        try {
-            if (name.endsWith(".txt")) {
-                doc = TextDocument.Document(file);
-            }
-
-            if (name.endsWith(".html")) {
-                doc = HtmlDocument.Document(file);
-            }
-        } catch (java.io.IOException e) {
-            throw new DocumentHandlerException(e);
-        }
-
-        return doc;
-    }
-}
-
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/HtmlDocument.java b/contrib/ant/src/main/org/apache/lucene/ant/HtmlDocument.java
deleted file mode 100644
index 7bf1768..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/HtmlDocument.java
+++ /dev/null
@@ -1,226 +0,0 @@
-package org.apache.lucene.ant;
-
-import org.apache.lucene.document.Field;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.w3c.dom.Text;
-import org.w3c.tidy.Tidy;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.StringWriter;
-
-/**
- *  The <code>HtmlDocument</code> class creates a Lucene {@link
- *  org.apache.lucene.document.Document} from an HTML document. <P>
- *
- *  It does this by using JTidy package. It can take input input
- *  from {@link java.io.File} or {@link java.io.InputStream}.
- *
- *@author     Erik Hatcher
- */
-public class HtmlDocument {
-    private Element rawDoc;
-
-
-    //-------------------------------------------------------------
-    // Constructors
-    //-------------------------------------------------------------
-
-    /**
-     *  Constructs an <code>HtmlDocument</code> from a {@link
-     *  java.io.File}.
-     *
-     *@param  file             the <code>File</code> containing the
-     *      HTML to parse
-     *@exception  IOException  if an I/O exception occurs
-     *@since
-     */
-    public HtmlDocument(File file) throws IOException {
-        Tidy tidy = new Tidy();
-        tidy.setQuiet(true);
-        tidy.setShowWarnings(false);
-        org.w3c.dom.Document root =
-                tidy.parseDOM(new FileInputStream(file), null);
-        rawDoc = root.getDocumentElement();
-    }
-
-
-    /**
-     *  Constructs an <code>HtmlDocument</code> from an {@link
-     *  java.io.InputStream}.
-     *
-     *@param  is               the <code>InputStream</code>
-     *      containing the HTML
-     *@exception  IOException  if I/O exception occurs
-     *@since
-     */
-    public HtmlDocument(InputStream is) {
-        Tidy tidy = new Tidy();
-        tidy.setQuiet(true);
-        tidy.setShowWarnings(false);
-        org.w3c.dom.Document root = tidy.parseDOM(is, null);
-        rawDoc = root.getDocumentElement();
-    }
-
-
-    /**
-     *  Creates a Lucene <code>Document</code> from an {@link
-     *  java.io.InputStream}.
-     *
-     *@param  is
-     *@return
-     *@exception  IOException
-     */
-    public static org.apache.lucene.document.Document
-            getDocument(InputStream is) {
-        HtmlDocument htmlDoc = new HtmlDocument(is);
-        org.apache.lucene.document.Document luceneDoc =
-                new org.apache.lucene.document.Document();
-
-        luceneDoc.add(new Field("title", htmlDoc.getTitle(), Field.Store.YES, Field.Index.TOKENIZED));
-        luceneDoc.add(new Field("contents", htmlDoc.getBody(), Field.Store.YES, Field.Index.TOKENIZED));
-
-        return luceneDoc;
-    }
-
-
-    //-------------------------------------------------------------
-    // Public methods
-    //-------------------------------------------------------------
-
-    /**
-     *  Creates a Lucene <code>Document</code> from a {@link
-     *  java.io.File}.
-     *
-     *@param  file
-     *@return
-     *@exception  IOException
-     */
-    public static org.apache.lucene.document.Document
-            Document(File file) throws IOException {
-        HtmlDocument htmlDoc = new HtmlDocument(file);
-        org.apache.lucene.document.Document luceneDoc =
-                new org.apache.lucene.document.Document();
-
-        luceneDoc.add(new Field("title", htmlDoc.getTitle(), Field.Store.YES, Field.Index.TOKENIZED));
-        luceneDoc.add(new Field("contents", htmlDoc.getBody(), Field.Store.YES, Field.Index.TOKENIZED));
-
-        String contents = null;
-        BufferedReader br =
-                new BufferedReader(new FileReader(file));
-        StringWriter sw = new StringWriter();
-        String line = br.readLine();
-        while (line != null) {
-            sw.write(line);
-            line = br.readLine();
-        }
-        br.close();
-        contents = sw.toString();
-        sw.close();
-
-        luceneDoc.add(new Field("rawcontents", contents, Field.Store.YES, Field.Index.NO));
-
-        return luceneDoc;
-    }
-
-
-    //-------------------------------------------------------------
-    // Private methods
-    //-------------------------------------------------------------
-
-    /**
-     *  Runs <code>HtmlDocument</code> on the files specified on
-     *  the command line.
-     *
-     *@param  args           Command line arguments
-     *@exception  Exception  Description of Exception
-     */
-    public static void main(String args[]) throws Exception {
-//         HtmlDocument doc = new HtmlDocument(new File(args[0]));
-//         System.out.println("Title = " + doc.getTitle());
-//         System.out.println("Body  = " + doc.getBody());
-
-        HtmlDocument doc =
-                new HtmlDocument(new FileInputStream(new File(args[0])));
-        System.out.println("Title = " + doc.getTitle());
-        System.out.println("Body  = " + doc.getBody());
-    }
-
-
-    /**
-     *  Gets the title attribute of the <code>HtmlDocument</code>
-     *  object.
-     *
-     *@return    the title value
-     */
-    public String getTitle() {
-        if (rawDoc == null) {
-            return null;
-        }
-
-        String title = "";
-
-        NodeList nl = rawDoc.getElementsByTagName("title");
-        if (nl.getLength() > 0) {
-            Element titleElement = ((Element) nl.item(0));
-            Text text = (Text) titleElement.getFirstChild();
-            if (text != null) {
-                title = text.getData();
-            }
-        }
-        return title;
-    }
-
-
-    /**
-     *  Gets the bodyText attribute of the
-     *  <code>HtmlDocument</code> object.
-     *
-     *@return    the bodyText value
-     */
-    public String getBody() {
-        if (rawDoc == null) {
-            return null;
-        }
-
-        String body = "";
-        NodeList nl = rawDoc.getElementsByTagName("body");
-        if (nl.getLength() > 0) {
-            body = getBodyText(nl.item(0));
-        }
-        return body;
-    }
-
-
-    /**
-     *  Gets the bodyText attribute of the
-     *  <code>HtmlDocument</code> object.
-     *
-     *@param  node  a DOM Node
-     *@return       The bodyText value
-     */
-    private String getBodyText(Node node) {
-        NodeList nl = node.getChildNodes();
-        StringBuffer buffer = new StringBuffer();
-        for (int i = 0; i < nl.getLength(); i++) {
-            Node child = nl.item(i);
-            switch (child.getNodeType()) {
-                case Node.ELEMENT_NODE:
-                    buffer.append(getBodyText(child));
-                    buffer.append(" ");
-                    break;
-                case Node.TEXT_NODE:
-                    buffer.append(((Text) child).getData());
-                    break;
-            }
-        }
-        return buffer.toString();
-    }
-}
-
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/IndexTask.java b/contrib/ant/src/main/org/apache/lucene/ant/IndexTask.java
deleted file mode 100644
index 774e1c0..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/IndexTask.java
+++ /dev/null
@@ -1,389 +0,0 @@
-package org.apache.lucene.ant;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.StopAnalyzer;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.DateField;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Searcher;
-import org.apache.lucene.search.TermQuery;
-import org.apache.tools.ant.BuildException;
-import org.apache.tools.ant.DirectoryScanner;
-import org.apache.tools.ant.DynamicConfigurator;
-import org.apache.tools.ant.Project;
-import org.apache.tools.ant.Task;
-import org.apache.tools.ant.types.FileSet;
-import org.apache.tools.ant.types.EnumeratedAttribute;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.Date;
-import java.util.Properties;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Set;
-import java.util.ArrayList;
-
-/**
- *  Ant task to index files with Lucene
- *
- *@author Erik Hatcher
- */
-public class IndexTask extends Task {
-  /**
-   *  file list
-   */
-  private ArrayList filesets = new ArrayList();
-
-  /**
-   *  overwrite index?
-   */
-  private boolean overwrite = false;
-
-  /**
-   *  index path
-   */
-  private File indexDir;
-
-  /**
-   *  document handler classname
-   */
-  private String handlerClassName =
-    FileExtensionDocumentHandler.class.getName();
-
-  /**
-   *  document handler instance
-   */
-  private DocumentHandler handler;
-
-
-  /**
-   *
-   */
-  private String analyzerClassName =
-    StandardAnalyzer.class.getName();
-
-  /**
-   *  analyzer instance
-   */
-  private Analyzer analyzer;
-
-  /**
-   *  Lucene merge factor
-   */
-  private int mergeFactor = 20;
-
-  private HandlerConfig handlerConfig;
-
-  private boolean useCompoundIndex = true;
-
-
-  /**
-   *  Creates new instance
-   */
-  public IndexTask() {
-  }
-
-
-  /**
-   *  Specifies the directory where the index will be stored
-   */
-  public void setIndex(File indexDir) {
-    this.indexDir = indexDir;
-  }
-
-
-  /**
-   *  Sets the mergeFactor attribute of the IndexTask object
-   *
-   *@param  mergeFactor  The new mergeFactor value
-   */
-  public void setMergeFactor(int mergeFactor) {
-    this.mergeFactor = mergeFactor;
-  }
-
-
-  /**
-   *  Sets the overwrite attribute of the IndexTask object
-   *
-   *@param  overwrite  The new overwrite value
-   */
-  public void setOverwrite(boolean overwrite) {
-    this.overwrite = overwrite;
-  }
-
-
-  /**
-   * If creating a new index and this is set to true, the
-   * index will be created in compound format.
-   */ 
-  public void setUseCompoundIndex(boolean useCompoundIndex) {
-    this.useCompoundIndex = useCompoundIndex;
-  }
-
-  /**
-   *  Sets the documentHandler attribute of the IndexTask object
-   *
-   *@param  classname  The new documentHandler value
-   */
-  public void setDocumentHandler(String classname) {
-    handlerClassName = classname;
-  }
-
-  /**
-   * Sets the analyzer based on the builtin Lucene analyzer types.
-   *
-   * @todo Enforce analyzer and analyzerClassName to be mutually exclusive
-   */
-  public void setAnalyzer(AnalyzerType type) {
-    analyzerClassName = type.getClassname();
-  }
-
-  public void setAnalyzerClassName(String classname) {
-    analyzerClassName = classname;
-  }
-
-  /**
-   *  Adds a set of files (nested fileset attribute).
-   *
-   *@param  set  FileSet to be added
-   */
-  public void addFileset(FileSet set) {
-    filesets.add(set);
-  }
-
-  /**
-   * Sets custom properties for a configurable document handler.
-   */
-  public void addConfig(HandlerConfig config) throws BuildException {
-    if (handlerConfig != null) {
-      throw new BuildException("Only one config element allowed");
-    }
-
-    handlerConfig = config;
-  }
-
-
-  /**
-   *  Begins the indexing
-   *
-   *@exception  BuildException  If an error occurs indexing the
-   *      fileset
-   */
-  public void execute() throws BuildException {
-
-    // construct handler and analyzer dynamically
-    try {
-      Class clazz = Class.forName(handlerClassName);
-      handler = (DocumentHandler) clazz.newInstance();
-
-      clazz = Class.forName(analyzerClassName);
-      analyzer = (Analyzer) clazz.newInstance();
-    } catch (ClassNotFoundException cnfe) {
-      throw new BuildException(cnfe);
-    } catch (InstantiationException ie) {
-      throw new BuildException(ie);
-    } catch (IllegalAccessException iae) {
-      throw new BuildException(iae);
-    }
-
-    log("Document handler = " + handler.getClass(), Project.MSG_VERBOSE);
-    log("Analyzer = " + analyzer.getClass(), Project.MSG_VERBOSE);
-
-    if (handler instanceof ConfigurableDocumentHandler) {
-      ((ConfigurableDocumentHandler) handler).configure(handlerConfig.getProperties());
-    }
-
-    try {
-      indexDocs();
-    } catch (IOException e) {
-      throw new BuildException(e);
-    }
-  }
-
-
-  /**
-   * Index the fileset.
-   *
-   *@exception  IOException if Lucene I/O exception
-   *@todo refactor!!!!!
-   */
-  private void indexDocs() throws IOException {
-    Date start = new Date();
-
-    boolean create = overwrite;
-    // If the index directory doesn't exist,
-    // create it and force create mode
-    if (indexDir.mkdirs() && !overwrite) {
-      create = true;
-    }
-
-    Searcher searcher = null;
-    boolean checkLastModified = false;
-    if (!create) {
-      try {
-        searcher = new IndexSearcher(indexDir.getAbsolutePath());
-        checkLastModified = true;
-      } catch (IOException ioe) {
-        log("IOException: " + ioe.getMessage());
-        // Empty - ignore, which indicates to index all
-        // documents
-      }
-    }
-
-    log("checkLastModified = " + checkLastModified, Project.MSG_VERBOSE);
-
-    IndexWriter writer =
-      new IndexWriter(indexDir, analyzer, create);
-
-    writer.setUseCompoundFile(useCompoundIndex);
-    int totalFiles = 0;
-    int totalIndexed = 0;
-    int totalIgnored = 0;
-    try {
-      writer.setMergeFactor(mergeFactor);
-
-      for (int i = 0; i < filesets.size(); i++) {
-        FileSet fs = (FileSet) filesets.get(i);
-        if (fs != null) {
-          DirectoryScanner ds =
-            fs.getDirectoryScanner(getProject());
-          String[] dsfiles = ds.getIncludedFiles();
-          File baseDir = ds.getBasedir();
-
-          for (int j = 0; j < dsfiles.length; j++) {
-            File file = new File(baseDir, dsfiles[j]);
-            totalFiles++;
-
-            if (!file.exists() || !file.canRead()) {
-              throw new BuildException("File \"" +
-                                       file.getAbsolutePath()
-                                       + "\" does not exist or is not readable.");
-            }
-
-            boolean indexIt = true;
-
-            if (checkLastModified) {
-              Term pathTerm =
-                new Term("path", file.getPath());
-              TermQuery query =
-                new TermQuery(pathTerm);
-              Hits hits = searcher.search(query);
-
-              // if document is found, compare the
-              // indexed last modified time with the
-              // current file
-              // - don't index if up to date
-              if (hits.length() > 0) {
-                Document doc = hits.doc(0);
-                String indexModified =
-                  doc.get("modified").trim();
-                if (indexModified != null) {
-                  if (DateField.stringToTime(indexModified)
-                    == file.lastModified()) {
-                    // TODO: remove existing document
-                    indexIt = false;
-                  }
-                }
-              }
-            }
-
-            if (indexIt) {
-              try {
-                log("Indexing " + file.getPath(),
-                    Project.MSG_VERBOSE);
-                Document doc =
-                  handler.getDocument(file);
-
-                if (doc == null) {
-                  totalIgnored++;
-                } else {
-                  // Add the path of the file as a field named "path".  Use a Keyword field, so
-                  // that the index stores the path, and so that the path is searchable
-                  doc.add(new Field("path", file.getPath(), Field.Store.YES, Field.Index.UN_TOKENIZED));
-
-                  // Add the last modified date of the file a field named "modified".  Use a
-                  // Keyword field, so that it's searchable, but so that no attempt is made
-                  // to tokenize the field into words.
-                  doc.add(new Field("modified", DateField.timeToString(file.lastModified()), Field.Store.YES, Field.Index.UN_TOKENIZED));
-
-                  writer.addDocument(doc);
-                  totalIndexed++;
-                }
-              } catch (DocumentHandlerException e) {
-                throw new BuildException(e);
-              }
-            }
-          }
-          // for j
-        }
-        // if (fs != null)
-      }
-      // for i
-
-      writer.optimize();
-    }
-      //try
-    finally {
-      // always make sure everything gets closed,
-      // no matter how we exit.
-      writer.close();
-      if (searcher != null) {
-        searcher.close();
-      }
-    }
-
-    Date end = new Date();
-
-    log(totalIndexed + " out of " + totalFiles + " indexed (" +
-        totalIgnored + " ignored) in " + (end.getTime() - start.getTime()) +
-        " milliseconds");
-  }
-
-  public static class HandlerConfig implements DynamicConfigurator {
-    Properties props = new Properties();
-
-    public void setDynamicAttribute(String attributeName, String value) throws BuildException {
-      props.setProperty(attributeName, value);
-    }
-
-    public Object createDynamicElement(String elementName) throws BuildException {
-      throw new BuildException("Sub elements not supported");
-    }
-
-    public Properties getProperties() {
-      return props;
-    }
-  }
-
- public static class AnalyzerType extends EnumeratedAttribute {
-    private static Map analyzerLookup = new HashMap();
-
-    static {
-      analyzerLookup.put("simple", SimpleAnalyzer.class.getName());
-      analyzerLookup.put("standard", StandardAnalyzer.class.getName());
-      analyzerLookup.put("stop", StopAnalyzer.class.getName());
-      analyzerLookup.put("whitespace", WhitespaceAnalyzer.class.getName());
-    }
-
-    /**
-     * @see EnumeratedAttribute#getValues
-     */
-    public String[] getValues() {
-      Set keys = analyzerLookup.keySet();
-      return (String[]) keys.toArray(new String[0]);
-    }
-
-    public String getClassname() {
-      return (String) analyzerLookup.get(getValue());
-    }
-  }
-}
-
diff --git a/contrib/ant/src/main/org/apache/lucene/ant/TextDocument.java b/contrib/ant/src/main/org/apache/lucene/ant/TextDocument.java
deleted file mode 100644
index b03bd36..0000000
--- a/contrib/ant/src/main/org/apache/lucene/ant/TextDocument.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.apache.lucene.ant;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.StringWriter;
-
-/**
- *  A utility for making Lucene Documents from a File.
- *
- *@author     Erik Hatcher
- *@created    December 6, 2001
- *@todo       Fix JavaDoc comments here
- */
-
-public class TextDocument {
-    private String contents;
-
-
-    /**
-     *  Constructor for the TextDocument object
-     *
-     *@param  file             Description of Parameter
-     *@exception  IOException  Description of Exception
-     */
-    public TextDocument(File file) throws IOException {
-        BufferedReader br =
-                new BufferedReader(new FileReader(file));
-        StringWriter sw = new StringWriter();
-
-        String line = br.readLine();
-        while (line != null) {
-            sw.write(line);
-            line = br.readLine();
-        }
-        br.close();
-
-        contents = sw.toString();
-        sw.close();
-    }
-
-
-    /**
-     *  Makes a document for a File. <p>
-     *
-     *  The document has a single field:
-     *  <ul>
-     *    <li> <code>contents</code>--containing the full contents
-     *    of the file, as a Text field;
-     *
-     *@param  f                Description of Parameter
-     *@return                  Description of the Returned Value
-     *@exception  IOException  Description of Exception
-     */
-    public static Document Document(File f) throws IOException {
-
-        TextDocument textDoc = new TextDocument(f);
-        // make a new, empty document
-        Document doc = new Document();
-
-        doc.add(new Field("title", f.getName(), Field.Store.YES, Field.Index.TOKENIZED));
-        doc.add(new Field("contents", textDoc.getContents(), Field.Store.YES, Field.Index.TOKENIZED));
-        doc.add(new Field("rawcontents", textDoc.getContents(), Field.Store.YES, Field.Index.NO));
-
-        // return the document
-        return doc;
-    }
-
-
-    /**
-     *@return    The contents value
-     *@todo      finish this method
-     */
-    public String getContents() {
-        return contents;
-    }
-}
-

