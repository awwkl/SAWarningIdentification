GitDiffStart: 425d8ac209c57dd1a0faf639330607c861613556 | Wed Aug 13 14:57:20 2008 +0000
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
index 1528115..8a57e5f 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
@@ -34,7 +34,7 @@ import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.core.MultiCore;
+import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.BinaryResponseWriter;
 import org.apache.solr.request.QueryResponseWriter;
@@ -55,9 +55,9 @@ import org.apache.solr.servlet.SolrRequestParsers;
 public class EmbeddedSolrServer extends SolrServer
 {
   
-  protected final MultiCore multicore; // either multicore
+  protected final CoreContainer multicore; // either multicore
   protected final SolrCore core; // or single core
-  protected final String coreName;  // use MultiCore registry
+  protected final String coreName;  // use CoreContainer registry
 
   private final SolrRequestParsers _parser;
   
@@ -73,10 +73,10 @@ public class EmbeddedSolrServer extends SolrServer
     _parser = new SolrRequestParsers( null );
   }
     
-  public EmbeddedSolrServer(  MultiCore multicore, String coreName )
+  public EmbeddedSolrServer(  CoreContainer multicore, String coreName )
   {
     if ( multicore == null ) {
-      throw new NullPointerException("MultiCore instance required");
+      throw new NullPointerException("CoreContainer instance required");
     }
     this.core = null;
     this.multicore = multicore;
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java b/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
index 004b8e1..85005ac 100644
--- a/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
+++ b/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
@@ -25,7 +25,7 @@ import org.apache.solr.client.solrj.request.UpdateRequest;
 import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
 import org.apache.solr.client.solrj.response.MultiCoreResponse;
 import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.core.MultiCore;
+import org.apache.solr.core.CoreContainer;
 
 
 /**
@@ -34,7 +34,7 @@ import org.apache.solr.core.MultiCore;
  */
 public abstract class MultiCoreExampleTestBase extends SolrExampleTestBase 
 {
-  protected static final MultiCore multicore = new MultiCore();
+  protected static final CoreContainer multicore = new CoreContainer();
   
   @Override public String getSolrHome() { return "../../../example/multicore/"; }
   
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
index 82a99d7..17baea1 100644
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
+++ b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
@@ -76,6 +76,7 @@ public class JettyWebappTest extends TestCase
     assertNotNull( html ); // real error will be an exception
 
     adminPath += "admin/";
+    html = IOUtils.toString( new URL(adminPath).openStream() );
     assertNotNull( html ); // real error will be an exception
 
     // analysis
diff --git a/example/solr/conf/schema.xml b/example/solr/conf/schema.xml
index ed27785..6cdeebc 100755
--- a/example/solr/conf/schema.xml
+++ b/example/solr/conf/schema.xml
@@ -204,6 +204,14 @@
       </analyzer>
     </fieldType>
 
+    <fieldType name="grams" class="solr.TextField" positionIncrementGap="100" >
+      <analyzer>
+        <tokenizer class="solr.StandardTokenizerFactory"/>
+        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+        <filter class="solr.LengthFilterFactory" min="3" max="15" />
+        <filter class="solr.WordGramFilterFactory" minLength="1" maxLength="3" sep=" " />      
+      </analyzer>
+    </fieldType>
 
     <!--
      Setup simple analysis for spell checking
diff --git a/src/java/org/apache/solr/core/CoreContainer.java b/src/java/org/apache/solr/core/CoreContainer.java
new file mode 100644
index 0000000..3fd77dc
--- /dev/null
+++ b/src/java/org/apache/solr/core/CoreContainer.java
@@ -0,0 +1,535 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.core;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.channels.FileChannel;
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.logging.Logger;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPathConstants;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.handler.admin.CoreAdminHandler;
+import org.apache.solr.schema.IndexSchema;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.SAXException;
+
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class CoreContainer 
+{
+  protected static Logger log = Logger.getLogger(CoreContainer.class.getName());
+  
+  protected final Map<String, CoreDescriptor> cores = new LinkedHashMap<String, CoreDescriptor>();
+  protected boolean enabled = false;
+  protected boolean persistent = false;
+  protected String adminPath = null;
+  protected CoreAdminHandler coreAdminHandler = null;
+  protected File configFile = null;
+  protected String libDir = null;
+  protected ClassLoader libLoader = null;
+  protected SolrResourceLoader loader = null;
+  protected java.lang.ref.WeakReference<SolrCore> adminCore = null;
+  
+  public CoreContainer() {
+    
+  }
+
+  /**
+   * Initalize CoreContainer directly from the constructor
+   * 
+   * @param dir
+   * @param configFile
+   * @throws ParserConfigurationException
+   * @throws IOException
+   * @throws SAXException
+   */
+  public CoreContainer(String dir, File configFile ) throws ParserConfigurationException, IOException, SAXException 
+  {
+    this.load(dir, configFile);
+  }
+  
+  //-------------------------------------------------------------------
+  // Initialization / Cleanup
+  //-------------------------------------------------------------------
+  
+  /**
+   * Load a config file listing the available solr cores.
+   * @param dir the home directory of all resources.
+   * @param configFile the configuration file
+   * @throws javax.xml.parsers.ParserConfigurationException
+   * @throws java.io.IOException
+   * @throws org.xml.sax.SAXException
+   */
+  public void load(String dir, File configFile ) throws ParserConfigurationException, IOException, SAXException {
+    this.configFile = configFile;
+    this.loader = new SolrResourceLoader(dir);
+    FileInputStream cfgis = new FileInputStream(configFile);
+    try {
+      Config cfg = new Config(loader, null, cfgis, null);
+    
+      persistent = cfg.getBool( "solr/@persistent", false );
+      libDir     = cfg.get(     "solr/@sharedLib", null);
+      
+      adminPath  = cfg.get(     "solr/cores/@adminPath", null );
+      
+      if (libDir != null) {
+        // relative dir to conf
+        File f = new File(dir, libDir);
+        libDir = f.getPath(); 
+        log.info( "loading shared library: "+f.getAbsolutePath() );
+        libLoader = SolrResourceLoader.createClassLoader(f, null);
+      }
+      
+      if( adminPath != null ) {
+        coreAdminHandler = this.createMultiCoreHandler();
+      }
+      
+      NodeList nodes = (NodeList)cfg.evaluate("solr/cores/core", XPathConstants.NODESET);
+      synchronized (cores) {
+        for (int i=0; i<nodes.getLength(); i++) {
+          Node node = nodes.item(i);
+          try {
+            CoreDescriptor p = new CoreDescriptor(this);
+            p.init(DOMUtil.getAttr(node, "name", null), DOMUtil.getAttr(node, "instanceDir", null));
+            // deal with optional settings
+            String opt = DOMUtil.getAttr(node, "config", null);
+            if (opt != null) {
+              p.setConfigName(opt);
+            }
+            opt = DOMUtil.getAttr(node, "schema", null);
+            if (opt != null) {
+              p.setSchemaName(opt);
+            }
+            CoreDescriptor old = cores.get(p.getName());
+            if (old != null && old.getName() != null && old.getName().equals(p.getName())) {
+              throw new RuntimeException( cfg.getName() +
+                " registers multiple cores to the same name: " + p.name);
+            }
+            p.setCore(create(p));
+          }
+          catch (Throwable ex) {
+            SolrConfig.severeErrors.add( ex );
+            SolrException.logOnce(log,null,ex);
+          }
+        }
+      }
+    }
+    finally {
+      if (cfgis != null) {
+        try { cfgis.close(); } catch (Exception xany) {}
+      }
+    }
+
+    setEnabled(true);
+  }
+  
+  /**
+   * Stops all cores.
+   */
+  public void shutdown() {
+    synchronized(cores) {
+      for(Map.Entry<String,CoreDescriptor> e : cores.entrySet()) {
+        SolrCore core = e.getValue().getCore();
+        if (core == null) continue;
+        String key = e.getKey();
+        if (core.getName().equals(key))
+        core.close();
+      }
+      cores.clear();
+    }
+  }
+  
+  @Override
+  protected void finalize() {
+    shutdown();
+  }
+  
+  /**
+   * Registers a SolrCore descriptor in the registry.
+   * @param descr the Solr core descriptor
+   * @return a previous descriptor having the same name if it existed, null otherwise
+   */
+  public CoreDescriptor register( CoreDescriptor descr ) {
+    if( descr == null ) {
+      throw new RuntimeException( "Can not register a null core." );
+    }
+    String name = descr.getName();
+    if( name == null || 
+        name.length() < 1 ||
+        name.indexOf( '/'  ) >= 0 ||
+        name.indexOf( '\\' ) >= 0 ){
+      throw new RuntimeException( "Invalid core name: "+name );
+    }
+
+    CoreDescriptor old = null;    
+    synchronized (cores) {
+      old = cores.put(name, descr);
+    }
+    if( old == null ) {
+      log.info( "registering core: "+name );
+      return null;
+    } 
+    else {
+      log.info( "replacing core: "+name );
+      return old;
+    }
+  }
+  
+
+  /**
+   * Swaps two SolrCore descriptors.
+   * @param c0
+   * @param c1
+   */
+  public void swap(CoreDescriptor c0, CoreDescriptor c1) {
+    if( c0 == null || c1 == null ) {
+      throw new RuntimeException( "Can not swap a null core." );
+    }
+    synchronized( cores ) {
+      String n0 = c0.getName();
+      String n1 = c1.getName();
+      cores.put(n0, c1);
+      cores.put(n1, c0);
+      c0.setName( n1 );
+      if (c0.getCore() != null)
+        c0.getCore().setName(n1);
+      c1.setName( n0 );
+      if (c1.getCore() != null)
+        c1.getCore().setName(n0);
+    }
+    log.info( "swaped: "+c0.getName() + " with " + c1.getName() );
+  }
+
+  /**
+   * Creates a new core based on a descriptor.
+   *
+   * @param dcore a core descriptor
+   * @return the newly created core
+   * @throws javax.xml.parsers.ParserConfigurationException
+   * @throws java.io.IOException
+   * @throws org.xml.sax.SAXException
+   */
+  public SolrCore create(CoreDescriptor dcore)  throws ParserConfigurationException, IOException, SAXException {
+    // Make the instanceDir relative to the multicore instanceDir if not absolute
+    File idir = new File(dcore.getInstanceDir());
+    if (!idir.isAbsolute()) {
+      idir = new File(loader.getInstanceDir(), dcore.getInstanceDir());
+    }
+    String instanceDir = idir.getPath();
+    
+    // Initialize the solr config
+    SolrResourceLoader solrLoader = new SolrResourceLoader(instanceDir, libLoader);
+    SolrConfig config = new SolrConfig(solrLoader, dcore.getConfigName(), null);
+    IndexSchema schema = new IndexSchema(config, dcore.getSchemaName(), null);
+    SolrCore core = new SolrCore(dcore.getName(), null, config, schema, dcore);
+    dcore.setCore(core);
+    
+    // Register the new core
+    CoreDescriptor old = this.register(dcore);
+    return core;
+  }
+  
+  /**
+   * Recreates a SolrCore.
+   * While the new core is loading, requests will continue to be dispatched to
+   * and processed by the old core
+   * 
+   * @param dcore the SolrCore to reload
+   * @throws ParserConfigurationException
+   * @throws IOException
+   * @throws SAXException
+   */
+  public void reload(CoreDescriptor dcore) throws ParserConfigurationException, IOException, SAXException {
+    create(new CoreDescriptor(dcore));
+  }
+    
+  // TODO? -- add some kind of hook to close the core after all references are 
+  // gone...  is finalize() enough?
+  public void remove( String name ) {
+    synchronized(cores) {
+      CoreDescriptor dcore = cores.remove( name );
+      if (dcore == null) {
+        return;
+      }
+      
+      SolrCore core = dcore.getCore();
+      if (core != null) {
+        core.close();
+      }
+    }
+  }
+  
+  /**
+   * @return a Collection of registered SolrCores
+   */
+  public Collection<SolrCore> getCores() {
+    java.util.List<SolrCore> l = new java.util.ArrayList<SolrCore>();
+    synchronized (cores) {
+      for(CoreDescriptor descr : this.cores.values()) {
+        if (descr.getCore() != null)
+          l.add(descr.getCore());
+      }
+    }
+    return l;
+  }
+  
+  public Collection<CoreDescriptor> getDescriptors() {
+   java.util.List<CoreDescriptor> l = new java.util.ArrayList<CoreDescriptor>();
+   synchronized (cores) {
+     l.addAll(cores.values());
+   }
+   return l;
+  }
+  
+  public SolrCore getCore(String name) {
+    CoreDescriptor dcore = getDescriptor( name );
+    return (dcore == null) ? null : dcore.getCore();
+  }
+  
+  public CoreDescriptor getDescriptor(String name) {
+    synchronized(cores) {
+      return cores.get( name );
+    }
+  }
+
+  // all of the following properties aren't synchronized
+  // but this should be OK since they normally won't be changed rapidly
+  public boolean isEnabled() {
+    return enabled;
+  }
+  
+  public void setEnabled(boolean enabled) {
+    synchronized(this) {
+      this.enabled = enabled;
+    }
+  }
+  
+  public boolean isPersistent() {
+    return persistent;
+  }
+  
+  public void setPersistent(boolean persistent) {
+    synchronized(this) {
+      this.persistent = persistent;
+    }
+  }
+  
+  public String getAdminPath() {
+    return adminPath;
+  }
+  
+  public void setAdminPath(String adminPath) {
+    synchronized (this) {
+      this.adminPath = adminPath;
+    }
+  }
+  
+  /**
+   * Sets the preferred core used to handle CoreContainer admin tasks.
+   * Note that getAdminCore is not symmetrical to this method since
+   * it will always return an opened SolrCore.
+   * This however can be useful implementing a "metacore" (a core of cores).
+   */
+  public void setAdminCore(SolrCore core) {
+    synchronized (cores) {
+      adminCore = new java.lang.ref.WeakReference<SolrCore>(core);
+    }
+  }
+
+  /**
+   * Gets a core to handle CoreContainer admin tasks (@see SolrDispatchFilter).
+   * This makes the best attempt to reuse the same opened SolrCore across calls.
+   */
+  public SolrCore getAdminCore() {
+    synchronized (cores) {
+      SolrCore core = adminCore != null ? adminCore.get() : null;
+      if (core == null || core.isClosed()) {
+        for (CoreDescriptor descr : this.cores.values()) {
+          core = descr.getCore();
+          if (core == null || core.isClosed()) {
+            core = null;
+          } else {
+            break;
+          }
+        }
+        setAdminCore(core);
+      }
+      return core;
+    }
+  }
+
+  /** 
+   * Creates a CoreAdminHandler for this CoreContainer.
+   * @return a CoreAdminHandler
+   */
+  protected CoreAdminHandler createMultiCoreHandler() {
+    return new CoreAdminHandler() {
+      @Override
+      public CoreContainer getMultiCore() {
+        return CoreContainer.this;
+      }
+    };
+  }
+ 
+  public CoreAdminHandler getMultiCoreHandler() {
+    return coreAdminHandler;
+  }
+  
+  public File getConfigFile() {
+    return configFile;
+  }
+  
+  /** Persists the multicore config file. */
+  public void persist() {
+    File tmpFile = null;
+    try {
+      // write in temp first
+      tmpFile = File.createTempFile("solr", ".xml", configFile.getParentFile());
+      java.io.FileOutputStream out = new java.io.FileOutputStream(tmpFile);
+      synchronized(cores) {
+        Writer writer = new BufferedWriter(new OutputStreamWriter(out, "UTF-8"));
+        persist(writer);
+        writer.flush();
+        writer.close();
+        out.close();
+        // rename over origin or copy it it this fails
+        if (tmpFile.renameTo(configFile))
+          tmpFile = null;
+        else
+          fileCopy(tmpFile, configFile);
+      }
+    } 
+    catch(java.io.FileNotFoundException xnf) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, xnf);
+    } 
+    catch(java.io.IOException xio) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, xio);
+    } 
+    finally {
+      if (tmpFile != null) {
+        if (!tmpFile.delete())
+          tmpFile.deleteOnExit();
+      }
+    }
+  }
+  
+  /** Write the multicore configuration through a writer.*/
+  void persist(Writer writer) throws IOException {
+    writer.write("<?xml version='1.0' encoding='UTF-8'?>");
+    writer.write("<solr");
+    if (this.libDir != null) {
+      writer.write(" sharedLib='");
+      XML.escapeAttributeValue(libDir, writer);
+      writer.write('\'');
+    }
+    writer.write(" persistent='");
+    if (isPersistent()) {
+      writer.write("true'");
+    }
+    else {
+      writer.write("false'");
+    }
+    writer.write(">\n");
+    writer.write("<cores adminPath='");
+    XML.escapeAttributeValue(adminPath, writer);
+    writer.write('\'');
+    writer.write(">\n");
+
+    synchronized(cores) {
+      for (Map.Entry<String, CoreDescriptor> entry : cores.entrySet()) {
+        persist(writer, entry.getValue());
+      }
+    }
+    writer.write("</cores>\n");
+    writer.write("</solr>\n");
+  }
+  
+  /** Writes the multicore configuration node for a given core. */
+  void persist(Writer writer, CoreDescriptor dcore) throws IOException {
+    writer.write("  <core");
+    writer.write (" name='");
+    XML.escapeAttributeValue(dcore.getName(), writer);
+    writer.write("' instanceDir='");
+    XML.escapeAttributeValue(dcore.getInstanceDir(), writer);
+    writer.write('\'');
+    //write config (if not default)
+    String opt = dcore.getConfigName();
+    if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {
+      writer.write(" config='");
+      XML.escapeAttributeValue(opt, writer);
+      writer.write('\'');
+    }
+    //write schema (if not default)
+    opt = dcore.getSchemaName();
+    if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {
+      writer.write(" schema='");
+      XML.escapeAttributeValue(opt, writer);
+      writer.write('\'');
+    }
+    writer.write("/>\n"); // core
+  }
+  
+  /** Copies a src file to a dest file:
+   *  used to circumvent the platform discrepancies regarding renaming files.
+   */
+  public static void fileCopy(File src, File dest) throws IOException {
+    IOException xforward = null;
+    FileInputStream fis =  null;
+    FileOutputStream fos = null;
+    FileChannel fcin = null;
+    FileChannel fcout = null;
+    try {
+      fis = new FileInputStream(src);
+      fos = new FileOutputStream(dest);
+      fcin = fis.getChannel();
+      fcout = fos.getChannel();
+      // do the file copy
+      fcin.transferTo(0, fcin.size(), fcout);
+    } 
+    catch(IOException xio) {
+      xforward = xio;
+    } 
+    finally {
+      if (fis   != null) try { fis.close(); fis = null; } catch(IOException xio) {}
+      if (fos   != null) try { fos.close(); fos = null; } catch(IOException xio) {}
+      if (fcin  != null && fcin.isOpen() ) try { fcin.close();  fcin = null;  } catch(IOException xio) {}
+      if (fcout != null && fcout.isOpen()) try { fcout.close(); fcout = null; } catch(IOException xio) {}
+    }
+    if (xforward != null) {
+      throw xforward;
+    }
+  }
+ 
+}
diff --git a/src/java/org/apache/solr/core/CoreDescriptor.java b/src/java/org/apache/solr/core/CoreDescriptor.java
index 0836d98..6e789a7 100644
--- a/src/java/org/apache/solr/core/CoreDescriptor.java
+++ b/src/java/org/apache/solr/core/CoreDescriptor.java
@@ -17,13 +17,10 @@
 
 package org.apache.solr.core;
 
-import org.xml.sax.SAXException;
-
-import javax.xml.parsers.ParserConfigurationException;
-import java.io.IOException;
 
 /**
  * A Solr core descriptor
+ * 
  * @since solr 1.3
  */
 public class CoreDescriptor implements Cloneable {
@@ -32,10 +29,10 @@ public class CoreDescriptor implements Cloneable {
   protected String configName;
   protected String schemaName;
   protected SolrCore core = null;
-  private final MultiCore multiCore;
+  private final CoreContainer coreContainer;
 
-  public CoreDescriptor(MultiCore multiCore) {
-    this.multiCore = multiCore;
+  public CoreDescriptor(CoreContainer coreContainer) {
+    this.coreContainer = coreContainer;
   }
 
   /** Initialize defaults from instance directory. */
@@ -58,7 +55,7 @@ public class CoreDescriptor implements Cloneable {
     this.instanceDir = descr.instanceDir;
     this.configName = descr.configName;
     this.schemaName = descr.schemaName;
-    multiCore = descr.multiCore;
+    coreContainer = descr.coreContainer;
   }
   
   /**@return the default config name. */
@@ -123,7 +120,7 @@ public class CoreDescriptor implements Cloneable {
     this.core = core;
   }
 
-  public MultiCore getMultiCore() {
-    return multiCore;
+  public CoreContainer getMultiCore() {
+    return coreContainer;
   }
 }
diff --git a/src/java/org/apache/solr/core/MultiCore.java b/src/java/org/apache/solr/core/MultiCore.java
deleted file mode 100644
index 9e250b7..0000000
--- a/src/java/org/apache/solr/core/MultiCore.java
+++ /dev/null
@@ -1,535 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.core;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.nio.channels.FileChannel;
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.logging.Logger;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.xpath.XPathConstants;
-
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.handler.admin.MultiCoreHandler;
-import org.apache.solr.schema.IndexSchema;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.SAXException;
-
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class MultiCore 
-{
-  protected static Logger log = Logger.getLogger(MultiCore.class.getName());
-  
-  protected final Map<String, CoreDescriptor> cores = new LinkedHashMap<String, CoreDescriptor>();
-  protected boolean enabled = false;
-  protected boolean persistent = false;
-  protected String adminPath = null;
-  protected MultiCoreHandler multiCoreHandler = null;
-  protected File configFile = null;
-  protected String libDir = null;
-  protected ClassLoader libLoader = null;
-  protected SolrResourceLoader loader = null;
-  protected java.lang.ref.WeakReference<SolrCore> adminCore = null;
-  
-  public MultiCore() {
-    
-  }
-
-  /**
-   * Initalize MultiCore directly from the constructor
-   * 
-   * @param dir
-   * @param configFile
-   * @throws ParserConfigurationException
-   * @throws IOException
-   * @throws SAXException
-   */
-  public MultiCore(String dir, File configFile ) throws ParserConfigurationException, IOException, SAXException 
-  {
-    this.load(dir, configFile);
-  }
-  
-  //-------------------------------------------------------------------
-  // Initialization / Cleanup
-  //-------------------------------------------------------------------
-  
-  /**
-   * Load a config file listing the available solr cores.
-   * @param dir the home directory of all resources.
-   * @param configFile the configuration file
-   * @throws javax.xml.parsers.ParserConfigurationException
-   * @throws java.io.IOException
-   * @throws org.xml.sax.SAXException
-   */
-  public void load(String dir, File configFile ) throws ParserConfigurationException, IOException, SAXException {
-    this.configFile = configFile;
-    this.loader = new SolrResourceLoader(dir);
-    FileInputStream cfgis = new FileInputStream(configFile);
-    try {
-      Config cfg = new Config(loader, null, cfgis, null);
-    
-      persistent = cfg.getBool( "solr/@persistent", false );
-      libDir     = cfg.get(     "solr/@sharedLib", null);
-      
-      adminPath  = cfg.get(     "solr/cores/@adminPath", null );
-      
-      if (libDir != null) {
-        // relative dir to conf
-        File f = new File(dir, libDir);
-        libDir = f.getPath(); 
-        log.info( "loading shared library: "+f.getAbsolutePath() );
-        libLoader = SolrResourceLoader.createClassLoader(f, null);
-      }
-      
-      if( adminPath != null ) {
-        multiCoreHandler = this.createMultiCoreHandler();
-      }
-      
-      NodeList nodes = (NodeList)cfg.evaluate("solr/cores/core", XPathConstants.NODESET);
-      synchronized (cores) {
-        for (int i=0; i<nodes.getLength(); i++) {
-          Node node = nodes.item(i);
-          try {
-            CoreDescriptor p = new CoreDescriptor(this);
-            p.init(DOMUtil.getAttr(node, "name", null), DOMUtil.getAttr(node, "instanceDir", null));
-            // deal with optional settings
-            String opt = DOMUtil.getAttr(node, "config", null);
-            if (opt != null) {
-              p.setConfigName(opt);
-            }
-            opt = DOMUtil.getAttr(node, "schema", null);
-            if (opt != null) {
-              p.setSchemaName(opt);
-            }
-            CoreDescriptor old = cores.get(p.getName());
-            if (old != null && old.getName() != null && old.getName().equals(p.getName())) {
-              throw new RuntimeException( cfg.getName() +
-                " registers multiple cores to the same name: " + p.name);
-            }
-            p.setCore(create(p));
-          }
-          catch (Throwable ex) {
-            SolrConfig.severeErrors.add( ex );
-            SolrException.logOnce(log,null,ex);
-          }
-        }
-      }
-    }
-    finally {
-      if (cfgis != null) {
-        try { cfgis.close(); } catch (Exception xany) {}
-      }
-    }
-
-    setEnabled(true);
-  }
-  
-  /**
-   * Stops all cores.
-   */
-  public void shutdown() {
-    synchronized(cores) {
-      for(Map.Entry<String,CoreDescriptor> e : cores.entrySet()) {
-        SolrCore core = e.getValue().getCore();
-        if (core == null) continue;
-        String key = e.getKey();
-        if (core.getName().equals(key))
-        core.close();
-      }
-      cores.clear();
-    }
-  }
-  
-  @Override
-  protected void finalize() {
-    shutdown();
-  }
-  
-  /**
-   * Registers a SolrCore descriptor in the registry.
-   * @param descr the Solr core descriptor
-   * @return a previous descriptor having the same name if it existed, null otherwise
-   */
-  public CoreDescriptor register( CoreDescriptor descr ) {
-    if( descr == null ) {
-      throw new RuntimeException( "Can not register a null core." );
-    }
-    String name = descr.getName();
-    if( name == null || 
-        name.length() < 1 ||
-        name.indexOf( '/'  ) >= 0 ||
-        name.indexOf( '\\' ) >= 0 ){
-      throw new RuntimeException( "Invalid core name: "+name );
-    }
-
-    CoreDescriptor old = null;    
-    synchronized (cores) {
-      old = cores.put(name, descr);
-    }
-    if( old == null ) {
-      log.info( "registering core: "+name );
-      return null;
-    } 
-    else {
-      log.info( "replacing core: "+name );
-      return old;
-    }
-  }
-  
-
-  /**
-   * Swaps two SolrCore descriptors.
-   * @param c0
-   * @param c1
-   */
-  public void swap(CoreDescriptor c0, CoreDescriptor c1) {
-    if( c0 == null || c1 == null ) {
-      throw new RuntimeException( "Can not swap a null core." );
-    }
-    synchronized( cores ) {
-      String n0 = c0.getName();
-      String n1 = c1.getName();
-      cores.put(n0, c1);
-      cores.put(n1, c0);
-      c0.setName( n1 );
-      if (c0.getCore() != null)
-        c0.getCore().setName(n1);
-      c1.setName( n0 );
-      if (c1.getCore() != null)
-        c1.getCore().setName(n0);
-    }
-    log.info( "swaped: "+c0.getName() + " with " + c1.getName() );
-  }
-
-  /**
-   * Creates a new core based on a descriptor.
-   *
-   * @param dcore a core descriptor
-   * @return the newly created core
-   * @throws javax.xml.parsers.ParserConfigurationException
-   * @throws java.io.IOException
-   * @throws org.xml.sax.SAXException
-   */
-  public SolrCore create(CoreDescriptor dcore)  throws ParserConfigurationException, IOException, SAXException {
-    // Make the instanceDir relative to the multicore instanceDir if not absolute
-    File idir = new File(dcore.getInstanceDir());
-    if (!idir.isAbsolute()) {
-      idir = new File(loader.getInstanceDir(), dcore.getInstanceDir());
-    }
-    String instanceDir = idir.getPath();
-    
-    // Initialize the solr config
-    SolrResourceLoader solrLoader = new SolrResourceLoader(instanceDir, libLoader);
-    SolrConfig config = new SolrConfig(solrLoader, dcore.getConfigName(), null);
-    IndexSchema schema = new IndexSchema(config, dcore.getSchemaName(), null);
-    SolrCore core = new SolrCore(dcore.getName(), null, config, schema, dcore);
-    dcore.setCore(core);
-    
-    // Register the new core
-    CoreDescriptor old = this.register(dcore);
-    return core;
-  }
-  
-  /**
-   * Recreates a SolrCore.
-   * While the new core is loading, requests will continue to be dispatched to
-   * and processed by the old core
-   * 
-   * @param dcore the SolrCore to reload
-   * @throws ParserConfigurationException
-   * @throws IOException
-   * @throws SAXException
-   */
-  public void reload(CoreDescriptor dcore) throws ParserConfigurationException, IOException, SAXException {
-    create(new CoreDescriptor(dcore));
-  }
-    
-  // TODO? -- add some kind of hook to close the core after all references are 
-  // gone...  is finalize() enough?
-  public void remove( String name ) {
-    synchronized(cores) {
-      CoreDescriptor dcore = cores.remove( name );
-      if (dcore == null) {
-        return;
-      }
-      
-      SolrCore core = dcore.getCore();
-      if (core != null) {
-        core.close();
-      }
-    }
-  }
-  
-  /**
-   * @return a Collection of registered SolrCores
-   */
-  public Collection<SolrCore> getCores() {
-    java.util.List<SolrCore> l = new java.util.ArrayList<SolrCore>();
-    synchronized (cores) {
-      for(CoreDescriptor descr : this.cores.values()) {
-        if (descr.getCore() != null)
-          l.add(descr.getCore());
-      }
-    }
-    return l;
-  }
-  
-  public Collection<CoreDescriptor> getDescriptors() {
-   java.util.List<CoreDescriptor> l = new java.util.ArrayList<CoreDescriptor>();
-   synchronized (cores) {
-     l.addAll(cores.values());
-   }
-   return l;
-  }
-  
-  public SolrCore getCore(String name) {
-    CoreDescriptor dcore = getDescriptor( name );
-    return (dcore == null) ? null : dcore.getCore();
-  }
-  
-  public CoreDescriptor getDescriptor(String name) {
-    synchronized(cores) {
-      return cores.get( name );
-    }
-  }
-
-  // all of the following properties aren't synchronized
-  // but this should be OK since they normally won't be changed rapidly
-  public boolean isEnabled() {
-    return enabled;
-  }
-  
-  public void setEnabled(boolean enabled) {
-    synchronized(this) {
-      this.enabled = enabled;
-    }
-  }
-  
-  public boolean isPersistent() {
-    return persistent;
-  }
-  
-  public void setPersistent(boolean persistent) {
-    synchronized(this) {
-      this.persistent = persistent;
-    }
-  }
-  
-  public String getAdminPath() {
-    return adminPath;
-  }
-  
-  public void setAdminPath(String adminPath) {
-    synchronized (this) {
-      this.adminPath = adminPath;
-    }
-  }
-  
-  /**
-   * Sets the preferred core used to handle MultiCore admin tasks.
-   * Note that getAdminCore is not symmetrical to this method since
-   * it will allways return an opened SolrCore.
-   * This however can be useful implementing a "metacore" (a core of cores).
-   */
-  public void setAdminCore(SolrCore core) {
-    synchronized (cores) {
-      adminCore = new java.lang.ref.WeakReference<SolrCore>(core);
-    }
-  }
-
-  /**
-   * Gets a core to handle MultiCore admin tasks (@see SolrDispatchFilter).
-   * This makes the best attempt to reuse the same opened SolrCore accross calls.
-   */
-  public SolrCore getAdminCore() {
-    synchronized (cores) {
-      SolrCore core = adminCore != null ? adminCore.get() : null;
-      if (core == null || core.isClosed()) {
-        for (CoreDescriptor descr : this.cores.values()) {
-          core = descr.getCore();
-          if (core == null || core.isClosed()) {
-            core = null;
-          } else {
-            break;
-          }
-        }
-        setAdminCore(core);
-      }
-      return core;
-    }
-  }
-
-  /** 
-   * Creates a MultiCoreHandler for this MultiCore.
-   * @return a MultiCoreHandler
-   */
-  protected MultiCoreHandler createMultiCoreHandler() {
-    return new MultiCoreHandler() {
-      @Override
-      public MultiCore getMultiCore() {
-        return MultiCore.this;
-      }
-    };
-  }
- 
-  public MultiCoreHandler getMultiCoreHandler() {
-    return multiCoreHandler;
-  }
-  
-  public File getConfigFile() {
-    return configFile;
-  }
-  
-  /** Persists the multicore config file. */
-  public void persist() {
-    File tmpFile = null;
-    try {
-      // write in temp first
-      tmpFile = File.createTempFile("solr", ".xml", configFile.getParentFile());
-      java.io.FileOutputStream out = new java.io.FileOutputStream(tmpFile);
-      synchronized(cores) {
-        Writer writer = new BufferedWriter(new OutputStreamWriter(out, "UTF-8"));
-        persist(writer);
-        writer.flush();
-        writer.close();
-        out.close();
-        // rename over origin or copy it it this fails
-        if (tmpFile.renameTo(configFile))
-          tmpFile = null;
-        else
-          fileCopy(tmpFile, configFile);
-      }
-    } 
-    catch(java.io.FileNotFoundException xnf) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, xnf);
-    } 
-    catch(java.io.IOException xio) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, xio);
-    } 
-    finally {
-      if (tmpFile != null) {
-        if (!tmpFile.delete())
-          tmpFile.deleteOnExit();
-      }
-    }
-  }
-  
-  /** Write the multicore configuration through a writer.*/
-  void persist(Writer writer) throws IOException {
-    writer.write("<?xml version='1.0' encoding='UTF-8'?>");
-    writer.write("<solr");
-    if (this.libDir != null) {
-      writer.write(" sharedLib='");
-      XML.escapeAttributeValue(libDir, writer);
-      writer.write('\'');
-    }
-    writer.write(" persistent='");
-    if (isPersistent()) {
-      writer.write("true'");
-    }
-    else {
-      writer.write("false'");
-    }
-    writer.write(">\n");
-    writer.write("<cores adminPath='");
-    XML.escapeAttributeValue(adminPath, writer);
-    writer.write('\'');
-    writer.write(">\n");
-
-    synchronized(cores) {
-      for (Map.Entry<String, CoreDescriptor> entry : cores.entrySet()) {
-        persist(writer, entry.getValue());
-      }
-    }
-    writer.write("</cores>\n");
-    writer.write("</solr>\n");
-  }
-  
-  /** Writes the multicore configuration node for a given core. */
-  void persist(Writer writer, CoreDescriptor dcore) throws IOException {
-    writer.write("  <core");
-    writer.write (" name='");
-    XML.escapeAttributeValue(dcore.getName(), writer);
-    writer.write("' instanceDir='");
-    XML.escapeAttributeValue(dcore.getInstanceDir(), writer);
-    writer.write('\'');
-    //write config (if not default)
-    String opt = dcore.getConfigName();
-    if (opt != null && !opt.equals(dcore.getDefaultConfigName())) {
-      writer.write(" config='");
-      XML.escapeAttributeValue(opt, writer);
-      writer.write('\'');
-    }
-    //write schema (if not default)
-    opt = dcore.getSchemaName();
-    if (opt != null && !opt.equals(dcore.getDefaultSchemaName())) {
-      writer.write(" schema='");
-      XML.escapeAttributeValue(opt, writer);
-      writer.write('\'');
-    }
-    writer.write("/>\n"); // core
-  }
-  
-  /** Copies a src file to a dest file:
-   *  used to circumvent the platform discrepancies regarding renaming files.
-   */
-  public static void fileCopy(File src, File dest) throws IOException {
-    IOException xforward = null;
-    FileInputStream fis =  null;
-    FileOutputStream fos = null;
-    FileChannel fcin = null;
-    FileChannel fcout = null;
-    try {
-      fis = new FileInputStream(src);
-      fos = new FileOutputStream(dest);
-      fcin = fis.getChannel();
-      fcout = fos.getChannel();
-      // do the file copy
-      fcin.transferTo(0, fcin.size(), fcout);
-    } 
-    catch(IOException xio) {
-      xforward = xio;
-    } 
-    finally {
-      if (fis   != null) try { fis.close(); fis = null; } catch(IOException xio) {}
-      if (fos   != null) try { fos.close(); fos = null; } catch(IOException xio) {}
-      if (fcin  != null && fcin.isOpen() ) try { fcin.close();  fcin = null;  } catch(IOException xio) {}
-      if (fcout != null && fcout.isOpen()) try { fcout.close(); fcout = null; } catch(IOException xio) {}
-    }
-    if (xforward != null) {
-      throw xforward;
-    }
-  }
- 
-}
diff --git a/src/java/org/apache/solr/core/SolrCore.java b/src/java/org/apache/solr/core/SolrCore.java
index c159846..bec6532 100644
--- a/src/java/org/apache/solr/core/SolrCore.java
+++ b/src/java/org/apache/solr/core/SolrCore.java
@@ -91,7 +91,7 @@ public final class SolrCore {
   public long getStartTime() { return startTime; }
 
   /**
-   * @deprecated Use {@link MultiCore#getCore(String)} instead.
+   * @deprecated Use {@link CoreContainer#getCore(String)} instead.
    */
   @Deprecated
   private static SolrCore instance;
@@ -345,7 +345,7 @@ public final class SolrCore {
    * @return the last core initialized.  If you are using multiple cores, 
    * this is not a function to use.
    * 
-   * @deprecated Use {@link MultiCore#getCore(String)} instead.
+   * @deprecated Use {@link CoreContainer#getCore(String)} instead.
    */
   @Deprecated
   public static SolrCore getSolrCore() {
diff --git a/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java b/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
new file mode 100644
index 0000000..b753d5c
--- /dev/null
+++ b/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
@@ -0,0 +1,220 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.handler.admin;
+
+import java.io.IOException;
+import java.util.Date;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.MultiCoreParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.MultiCoreParams.MultiCoreAction;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.core.CoreDescriptor;
+import org.apache.solr.handler.RequestHandlerBase;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.util.RefCounted;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class CoreAdminHandler extends RequestHandlerBase
+{
+  public CoreAdminHandler()
+  {
+    super();
+    // Unlike most request handlers, CoreContainer initialization 
+    // should happen in the constructor...  
+  }
+  
+  
+  @Override
+  final public void init(NamedList args) {
+    throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,
+        "CoreAdminHandler should not be configured in solrconf.xml\n"+
+        "it is a special Handler configured directly by the RequestDispatcher" );
+  }
+  
+  /**
+   * The instance of multicore this handler handles.
+   * This should be the CoreContainer instance that created this handler.
+   * @return a CoreContainer instance
+   */
+  public abstract CoreContainer getMultiCore();
+  
+  @Override
+  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception 
+  {
+    // Make sure the manager is enabled
+    CoreContainer manager = getMultiCore();
+    if( !manager.isEnabled() ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+          "CoreContainer support must be enabled at startup." );
+    }
+    boolean do_persist = false;
+    
+    // Pick the action
+    SolrParams params = req.getParams();
+    SolrParams required = params.required();
+    MultiCoreAction action = MultiCoreAction.STATUS;
+    String a = params.get( MultiCoreParams.ACTION );
+    if( a != null ) {
+      action = MultiCoreAction.get( a );
+      if( action == null ) {
+        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+          "Unknown 'action' value.  Use: "+MultiCoreAction.values() );
+      }
+    }
+    
+    SolrCore core = null;
+    // Handle a core creation
+    //---------------------------------------------------------
+    if (action == MultiCoreAction.CREATE) {
+      CoreDescriptor dcore = new CoreDescriptor(manager);
+      dcore.init(params.get(MultiCoreParams.NAME),
+                params.get(MultiCoreParams.INSTANCE_DIR));
+      
+      // fillup optional parameters
+      String opts = params.get(MultiCoreParams.CONFIG);
+      if (opts != null)
+        dcore.setConfigName(opts);
+      
+      opts = params.get(MultiCoreParams.SCHEMA);
+      if (opts != null)
+        dcore.setSchemaName(opts);
+      
+      core = manager.create(dcore);
+      rsp.add("core", core.getName());
+      do_persist = manager.isPersistent();
+    }
+    else {
+      // Select the core
+      String cname = params.get( MultiCoreParams.CORE );
+      if( cname != null ) {
+        core = manager.getCore(cname);
+        if( core == null ) {
+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+              "Unknown core: "+cname );
+        }
+      }
+
+      // Handle a Status Request
+      //---------------------------------------------------------
+      if( action == MultiCoreAction.STATUS ) {
+        do_persist = false; // no state change
+        NamedList<Object> status = new SimpleOrderedMap<Object>();
+        if( core == null ) {
+          for (CoreDescriptor d : manager.getDescriptors()) {
+            status.add(d.getName(), getCoreStatus( d.getCore() ) );
+          }
+        } 
+        else {
+          status.add(core.getName(), getCoreStatus(core) );
+        }
+        rsp.add( "status", status );
+      } 
+      else if (core == null) {
+        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+          "Action '"+action+"' requires a core name." );
+      } 
+      else {
+        // Handle all other
+        //---------------------------------------------------------
+        do_persist = params.getBool(MultiCoreParams.PERSISTENT, manager.isPersistent());
+        switch( action ) {
+          case RELOAD: {
+            manager.reload( manager.getDescriptor( core.getName() ) );
+            do_persist = false; // no change on reload
+            break;
+          }
+  
+          case SWAP: {
+            String name = required.get( MultiCoreParams.WITH );
+            CoreDescriptor swap = manager.getDescriptor( name );
+            
+            if( swap == null ) {
+              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+                  "Unknown core: "+name );
+            }
+            manager.swap( manager.getDescriptor( core.getName() ), swap );
+            break;
+          } 
+        
+          case PERSIST: {
+            do_persist = true;
+            break;
+          } 
+          
+          default: {
+            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+                "TODO: IMPLEMENT: " + action );
+          }
+        } // switch
+      }
+    }
+    
+    // Should we persist the changes?
+    if (do_persist) {
+      manager.persist();
+      rsp.add("saved", manager.getConfigFile().getAbsolutePath());
+    }
+  }
+  
+  private static NamedList<Object> getCoreStatus( SolrCore core ) throws IOException
+  {
+    NamedList<Object> info = new SimpleOrderedMap<Object>();
+    info.add( "name", core.getName() );
+    info.add( "instanceDir", core.getResourceLoader().getInstanceDir() );
+    info.add( "dataDir", core.getDataDir() );
+    info.add( "startTime", new Date( core.getStartTime() ) );
+    info.add( "uptime", System.currentTimeMillis()-core.getStartTime() );
+    RefCounted<SolrIndexSearcher> searcher = core.getSearcher();
+    info.add( "index", LukeRequestHandler.getIndexInfo( searcher.get().getReader(), false ) );
+    searcher.decref();
+    return info;
+  }
+  
+  
+  //////////////////////// SolrInfoMBeans methods //////////////////////
+
+  @Override
+  public String getDescription() {
+    return "Manage Multiple Solr Cores";
+  }
+
+  @Override
+  public String getVersion() {
+    return "$Revision$";
+  }
+
+  @Override
+  public String getSourceId() {
+    return "$Id$";
+  }
+
+  @Override
+  public String getSource() {
+    return "$URL$";
+  }
+}
diff --git a/src/java/org/apache/solr/handler/admin/MultiCoreHandler.java b/src/java/org/apache/solr/handler/admin/MultiCoreHandler.java
deleted file mode 100644
index e1eb64e..0000000
--- a/src/java/org/apache/solr/handler/admin/MultiCoreHandler.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.handler.admin;
-
-import java.io.IOException;
-import java.util.Date;
-
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.params.MultiCoreParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.params.MultiCoreParams.MultiCoreAction;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-import org.apache.solr.core.MultiCore;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.CoreDescriptor;
-import org.apache.solr.handler.RequestHandlerBase;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.RefCounted;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class MultiCoreHandler extends RequestHandlerBase
-{
-  public MultiCoreHandler()
-  {
-    super();
-    // Unlike most request handlers, MultiCore initialization 
-    // should happen in the constructor...  
-  }
-  
-  
-  @Override
-  final public void init(NamedList args) {
-    throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,
-        "MultiCoreHandler should not be configured in solrconf.xml\n"+
-        "it is a special Handler configured directly by the RequestDispatcher" );
-  }
-  
-  /**
-   * The instance of multicore this handler handles.
-   * This should be the MultiCore instance that created this handler.
-   * @return a MultiCore instance
-   */
-  public abstract MultiCore getMultiCore();
-  
-  @Override
-  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception 
-  {
-    // Make sure the manager is enabled
-    MultiCore manager = getMultiCore();
-    if( !manager.isEnabled() ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-          "MultiCore support must be enabled at startup." );
-    }
-    boolean do_persist = false;
-    
-    // Pick the action
-    SolrParams params = req.getParams();
-    SolrParams required = params.required();
-    MultiCoreAction action = MultiCoreAction.STATUS;
-    String a = params.get( MultiCoreParams.ACTION );
-    if( a != null ) {
-      action = MultiCoreAction.get( a );
-      if( action == null ) {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-          "Unknown 'action' value.  Use: "+MultiCoreAction.values() );
-      }
-    }
-    
-    SolrCore core = null;
-    // Handle a core creation
-    //---------------------------------------------------------
-    if (action == MultiCoreAction.CREATE) {
-      CoreDescriptor dcore = new CoreDescriptor(manager);
-      dcore.init(params.get(MultiCoreParams.NAME),
-                params.get(MultiCoreParams.INSTANCE_DIR));
-      
-      // fillup optional parameters
-      String opts = params.get(MultiCoreParams.CONFIG);
-      if (opts != null)
-        dcore.setConfigName(opts);
-      
-      opts = params.get(MultiCoreParams.SCHEMA);
-      if (opts != null)
-        dcore.setSchemaName(opts);
-      
-      core = manager.create(dcore);
-      rsp.add("core", core.getName());
-      do_persist = manager.isPersistent();
-    }
-    else {
-      // Select the core
-      String cname = params.get( MultiCoreParams.CORE );
-      if( cname != null ) {
-        core = manager.getCore(cname);
-        if( core == null ) {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-              "Unknown core: "+cname );
-        }
-      }
-
-      // Handle a Status Request
-      //---------------------------------------------------------
-      if( action == MultiCoreAction.STATUS ) {
-        do_persist = false; // no state change
-        NamedList<Object> status = new SimpleOrderedMap<Object>();
-        if( core == null ) {
-          for (CoreDescriptor d : manager.getDescriptors()) {
-            status.add(d.getName(), getCoreStatus( d.getCore() ) );
-          }
-        } 
-        else {
-          status.add(core.getName(), getCoreStatus(core) );
-        }
-        rsp.add( "status", status );
-      } 
-      else if (core == null) {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-          "Action '"+action+"' requires a core name." );
-      } 
-      else {
-        // Handle all other
-        //---------------------------------------------------------
-        do_persist = params.getBool(MultiCoreParams.PERSISTENT, manager.isPersistent());
-        switch( action ) {
-          case RELOAD: {
-            manager.reload( manager.getDescriptor( core.getName() ) );
-            do_persist = false; // no change on reload
-            break;
-          }
-  
-          case SWAP: {
-            String name = required.get( MultiCoreParams.WITH );
-            CoreDescriptor swap = manager.getDescriptor( name );
-            
-            if( swap == null ) {
-              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                  "Unknown core: "+name );
-            }
-            manager.swap( manager.getDescriptor( core.getName() ), swap );
-            break;
-          } 
-        
-          case PERSIST: {
-            do_persist = true;
-            break;
-          } 
-          
-          default: {
-            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                "TODO: IMPLEMENT: " + action );
-          }
-        } // switch
-      }
-    }
-    
-    // Should we persist the changes?
-    if (do_persist) {
-      manager.persist();
-      rsp.add("saved", manager.getConfigFile().getAbsolutePath());
-    }
-  }
-  
-  private static NamedList<Object> getCoreStatus( SolrCore core ) throws IOException
-  {
-    NamedList<Object> info = new SimpleOrderedMap<Object>();
-    info.add( "name", core.getName() );
-    info.add( "instanceDir", core.getResourceLoader().getInstanceDir() );
-    info.add( "dataDir", core.getDataDir() );
-    info.add( "startTime", new Date( core.getStartTime() ) );
-    info.add( "uptime", System.currentTimeMillis()-core.getStartTime() );
-    RefCounted<SolrIndexSearcher> searcher = core.getSearcher();
-    info.add( "index", LukeRequestHandler.getIndexInfo( searcher.get().getReader(), false ) );
-    searcher.decref();
-    return info;
-  }
-  
-  
-  //////////////////////// SolrInfoMBeans methods //////////////////////
-
-  @Override
-  public String getDescription() {
-    return "Manage Multiple Solr Cores";
-  }
-
-  @Override
-  public String getVersion() {
-    return "$Revision$";
-  }
-
-  @Override
-  public String getSourceId() {
-    return "$Id$";
-  }
-
-  @Override
-  public String getSource() {
-    return "$URL$";
-  }
-}
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
index 1cf8156..6f16a77 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
@@ -52,7 +52,7 @@ public class SolrDispatchFilter implements Filter
 
   protected CoreDescriptor singleCoreDescriptor;
 
-  protected MultiCore multicore;
+  protected CoreContainer cores;
   protected String pathPrefix = null; // strip this from the beginning of a path
   protected String abortErrorMessage = null;
   protected final WeakHashMap<SolrCore, SolrRequestParsers> parsers = new WeakHashMap<SolrCore, SolrRequestParsers>();
@@ -68,14 +68,14 @@ public class SolrDispatchFilter implements Filter
       this.pathPrefix = config.getInitParameter( "path-prefix" );
       this.solrConfigFilename = config.getInitParameter("solrconfig-filename");
 
-      // multicore instantiation
-      this.multicore = initMultiCore(config);
+      // cores instantiation
+      this.cores = initMultiCore(config);
 
-      if(multicore != null && multicore.isEnabled() ) {
+      if(cores != null && cores.isEnabled() ) {
         abortOnConfigurationError = false;
         singleCoreDescriptor = null;
         // if any core aborts on startup, then abort
-        for( SolrCore c : multicore.getCores() ) {
+        for( SolrCore c : cores.getCores() ) {
           if( c.getSolrConfig().getBool( "abortOnConfigurationError",false) ) {
             abortOnConfigurationError = true;
             break;
@@ -84,7 +84,7 @@ public class SolrDispatchFilter implements Filter
       }
       else {
         SolrConfig cfg = this.solrConfigFilename == null? new SolrConfig() : new SolrConfig(this.solrConfigFilename);
-        singleCoreDescriptor = new CoreDescriptor((MultiCore)null);
+        singleCoreDescriptor = new CoreDescriptor((CoreContainer)null);
         singleCoreDescriptor.init("",cfg.getResourceLoader().getInstanceDir());
         SolrCore singlecore = new SolrCore( null, null, cfg, null, singleCoreDescriptor);
         singleCoreDescriptor.setCore(singlecore);
@@ -108,7 +108,7 @@ public class SolrDispatchFilter implements Filter
       out.println( "Check your log files for more detailed information on what may be wrong.\n" );
       out.println( "If you want solr to continue after configuration errors, change: \n");
       out.println( " <abortOnConfigurationError>false</abortOnConfigurationError>\n" );
-      if (multicore != null && multicore.isEnabled()) {
+      if (cores != null && cores.isEnabled()) {
         out.println( "in solr.xml\n" );
       } else {
         out.println( "in solrconfig.xml\n" );
@@ -133,13 +133,13 @@ public class SolrDispatchFilter implements Filter
   }
 
   /**
-   * Initialize the multicore instance.
+   * Initialize the cores instance.
    * @param config the filter configuration
-   * @return the multicore instance or null
+   * @return the cores instance or null
    * @throws java.lang.Exception
    */
-  protected MultiCore initMultiCore(FilterConfig config) throws Exception {
-    MultiCore mcore = new MultiCore();
+  protected CoreContainer initMultiCore(FilterConfig config) throws Exception {
+    CoreContainer mcore = new CoreContainer();
     String instanceDir = SolrResourceLoader.locateInstanceDir();
     File fconf = new File(instanceDir, "solr.xml");
     log.info("looking for solr.xml: " + fconf.getAbsolutePath());
@@ -151,9 +151,9 @@ public class SolrDispatchFilter implements Filter
 
 
   public void destroy() {
-    if (multicore != null) {
-    multicore.shutdown();
-      multicore = null;
+    if (cores != null) {
+    cores.shutdown();
+      cores = null;
     }
     if( singleCoreDescriptor != null ) {
       singleCoreDescriptor.getCore().close();
@@ -189,18 +189,18 @@ public class SolrDispatchFilter implements Filter
           path = path.substring( 0, idx );
         }
 
-        // By default use the single core.  If multicore is enabled, look for one.
+        // By default use the single core.  If cores is enabled, look for one.
         final SolrCore core;
-        if (multicore != null && multicore.isEnabled()) {
-          req.setAttribute("org.apache.solr.MultiCore", multicore);
+        if (cores != null && cores.isEnabled()) {
+          req.setAttribute("org.apache.solr.CoreContainer", cores);
 
           // if this is the multi-core admin page, it will handle it
-          if( path.equals( multicore.getAdminPath() ) ) {
-            handler = multicore.getMultiCoreHandler();
+          if( path.equals( cores.getAdminPath() ) ) {
+            handler = cores.getMultiCoreHandler();
             // pick a core to use for output generation
-            core = multicore.getAdminCore();
+            core = cores.getAdminCore();
             if( core == null ) {
-              throw new RuntimeException( "Can not find a valid core for the multicore admin handler" );
+              throw new RuntimeException( "Can not find a valid core for the cores admin handler" );
             }
           } else {
             //otherwise, we should find a core from the path
@@ -209,7 +209,7 @@ public class SolrDispatchFilter implements Filter
               // try to get the corename as a request parameter first
               String corename = path.substring( 1, idx );
               path = path.substring( idx );
-              core = multicore.getCore( corename );
+              core = cores.getCore( corename );
             } else {
               core = null;
             }
@@ -231,7 +231,7 @@ public class SolrDispatchFilter implements Filter
           }
 
           // Determine the handler from the url path if not set
-          // (we might already have selected the multicore handler)
+          // (we might already have selected the cores handler)
           if( handler == null && path.length() > 1 ) { // don't match "" or "/" as valid path
             handler = core.getRequestHandler( path );
             // no handler yet but allowed to handle select; let's check
diff --git a/src/webapp/web/admin/index.jsp b/src/webapp/web/admin/index.jsp
index ad4aeba..0f77872 100644
--- a/src/webapp/web/admin/index.jsp
+++ b/src/webapp/web/admin/index.jsp
@@ -52,7 +52,7 @@
 </tr>
 
 <%-- List the cores (that arent this one) so we can switch --%>
-<% org.apache.solr.core.MultiCore multicore = (org.apache.solr.core.MultiCore)request.getAttribute("org.apache.solr.MultiCore");
+<% org.apache.solr.core.CoreContainer multicore = (org.apache.solr.core.CoreContainer)request.getAttribute("org.apache.solr.CoreContainer");
   if (multicore!=null) {
   java.util.Collection<SolrCore> cores = multicore.getCores();
 if (cores.size() > 1) {%><tr><td><strong>Cores:</strong><br></td><td><%
diff --git a/src/webapp/web/index.jsp b/src/webapp/web/index.jsp
index 502f805..b026c89 100644
--- a/src/webapp/web/index.jsp
+++ b/src/webapp/web/index.jsp
@@ -28,7 +28,7 @@
 <a href="."><img border="0" align="right" height="61" width="142" src="admin/solr-head.gif" alt="Solr"/></a>
 
 <% 
-  org.apache.solr.core.MultiCore multicore = (org.apache.solr.core.MultiCore)request.getAttribute("org.apache.solr.MultiCore");
+  org.apache.solr.core.CoreContainer multicore = (org.apache.solr.core.CoreContainer)request.getAttribute("org.apache.solr.CoreContainer");
   if(multicore != null && multicore.isEnabled() ) { 
     for( org.apache.solr.core.SolrCore core : multicore.getCores() ) {%>
 <a href="<%= core.getName() %>/admin/">Admin <%= core.getName() %></a><br/>

