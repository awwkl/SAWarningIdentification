GitDiffStart: 04da5e73f26bb92a74eb10b3baf870ad0133312c | Wed Oct 21 19:30:06 2009 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 23f3949..cb582e0 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -88,6 +88,11 @@ API Changes
   also implement java.io.Closeable (IndexReader, IndexWriter, Directory,...).
   (Uwe Schindler)
 
+* LUCENE-1998: Change all Parameter instances to Java 5 enums. This
+  is no backwards-break, only a change of the super class. Parameter
+  was deprecated and will be removed in a later version.
+  (DM Smith, Uwe Schindler)
+
 Bug fixes
 
 * LUCENE-1951: When the text provided to WildcardQuery has no wildcard
diff --git a/common-build.xml b/common-build.xml
index a84fed2..dc5cbdc 100644
--- a/common-build.xml
+++ b/common-build.xml
@@ -42,7 +42,7 @@
   <property name="Name" value="Lucene"/>
   <property name="dev.version" value="3.0-dev"/>
   <property name="version" value="${dev.version}"/>
-  <property name="compatibility.tag" value="lucene_2_9_back_compat_tests_20091021"/>
+  <property name="compatibility.tag" value="lucene_2_9_back_compat_tests_20091021a"/>
   <property name="spec.version" value="${version}"/>	
   <property name="year" value="2000-${current.year}"/>
   <property name="final.name" value="lucene-${name}-${version}"/>
diff --git a/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.java b/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.java
index 02c026a..a878284 100644
--- a/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.java
+++ b/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.java
@@ -17,7 +17,6 @@ package org.apache.lucene.analysis.ngram;
  * limitations under the License.
  */
 
-import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
@@ -36,28 +35,23 @@ public final class EdgeNGramTokenFilter extends TokenFilter {
   public static final int DEFAULT_MAX_GRAM_SIZE = 1;
   public static final int DEFAULT_MIN_GRAM_SIZE = 1;
 
-  // Replace this with an enum when the Java 1.5 upgrade is made, the impl will be simplified
   /** Specifies which side of the input the n-gram should be generated from */
-  public static class Side {
-    private String label;
+  public static enum Side {
 
     /** Get the n-gram from the front of the input */
-    public static Side FRONT = new Side("front");
+    FRONT { public String getLabel() { return "front"; } },
 
     /** Get the n-gram from the end of the input */
-    public static Side BACK = new Side("back");
+    BACK  { public String getLabel() { return "back"; } };
 
-    // Private ctor
-    private Side(String label) { this.label = label; }
-
-    public String getLabel() { return label; }
+    public abstract String getLabel();
 
     // Get the appropriate Side from a string
     public static Side getSide(String sideName) {
       if (FRONT.getLabel().equals(sideName)) {
         return FRONT;
       }
-      else if (BACK.getLabel().equals(sideName)) {
+      if (BACK.getLabel().equals(sideName)) {
         return BACK;
       }
       return null;
diff --git a/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.java b/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.java
index 77247bc..57390c2 100644
--- a/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.java
+++ b/contrib/analyzers/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.java
@@ -17,7 +17,6 @@ package org.apache.lucene.analysis.ngram;
  * limitations under the License.
  */
 
-import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
@@ -41,29 +40,23 @@ public final class EdgeNGramTokenizer extends Tokenizer {
   private TermAttribute termAtt;
   private OffsetAttribute offsetAtt;
 
-  // Replace this with an enum when the Java 1.5 upgrade is made, the impl will be simplified
   /** Specifies which side of the input the n-gram should be generated from */
-  public static class Side {
-    private String label;
+  public static enum Side {
 
     /** Get the n-gram from the front of the input */
-    public static Side FRONT = new Side("front");
+    FRONT { public String getLabel() { return "front"; } },
 
     /** Get the n-gram from the end of the input */
-    public static Side BACK = new Side("back");
+    BACK  { public String getLabel() { return "back"; } };
 
-    // Private ctor
-    private Side(String label) { this.label = label; }
-
-
-    public String getLabel() { return label; }
+    public abstract String getLabel();
 
     // Get the appropriate Side from a string
     public static Side getSide(String sideName) {
       if (FRONT.getLabel().equals(sideName)) {
         return FRONT;
       }
-      else if (BACK.getLabel().equals(sideName)) {
+      if (BACK.getLabel().equals(sideName)) {
         return BACK;
       }
       return null;
diff --git a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
index 48cf66e..d824d0a 100644
--- a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
+++ b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
@@ -25,7 +25,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 import org.apache.lucene.util.AttributeSource;
 
 /**
@@ -104,13 +103,7 @@ public class PrecedenceQueryParser implements PrecedenceQueryParserConstants {
   int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;
   Locale locale = Locale.getDefault();
 
-  static final class Operator extends Parameter {
-    private Operator(String name) {
-      super(name);
-    }
-    static final Operator OR = new Operator("OR");
-    static final Operator AND = new Operator("AND");
-  }
+  static enum Operator { OR, AND }
 
   /** Constructs a query parser.
    *  @param f  the default field for query terms.
diff --git a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj
index 1aa7a24..ddee139 100644
--- a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj
+++ b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj
@@ -49,7 +49,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 import org.apache.lucene.util.AttributeSource;
 
 /**
@@ -128,13 +127,7 @@ public class PrecedenceQueryParser {
   int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;
   Locale locale = Locale.getDefault();
 
-  static final class Operator extends Parameter {
-    private Operator(String name) {
-      super(name);
-    }
-    static final Operator OR = new Operator("OR");
-    static final Operator AND = new Operator("AND");
-  }
+  static enum Operator { OR, AND }
 
   /** Constructs a query parser.
    *  @param f  the default field for query terms.
diff --git a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParserTokenManager.java b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParserTokenManager.java
index 76f5d91..e022065 100644
--- a/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParserTokenManager.java
+++ b/contrib/misc/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParserTokenManager.java
@@ -23,7 +23,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 import org.apache.lucene.util.AttributeSource;
 
 /** Token Manager. */
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java
index 0f81525..4d9a305 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ParametricQueryNode.java
@@ -30,25 +30,12 @@ public class ParametricQueryNode extends FieldQueryNode {
   private CompareOperator operator;
 
   public enum CompareOperator {
-    LE, LT, GE, GT, EQ, NE;
-
-    public String toString() {
-      if (LE.equals(this)) {
-        return "<=";
-      } else if (LT.equals(this)) {
-        return "<";
-      } else if (GE.equals(this)) {
-        return ">=";
-      } else if (GT.equals(this)) {
-        return ">";
-      } else if (EQ.equals(this)) {
-        return "=";
-      } else if (NE.equals(this)) {
-        return "!=";
-      } else {
-        throw new IllegalArgumentException("Unknown operator");
-      }
-    }
+    LE { public String toString() { return "<="; } },
+    LT { public String toString() { return "<";  } },
+    GE { public String toString() { return ">="; } },
+    GT { public String toString() { return ">";  } },
+    EQ { public String toString() { return "=";  } },
+    NE { public String toString() { return "!="; } };
   }
 
   /**
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java
index c886d99..b8e73fd 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/ProximityQueryNode.java
@@ -36,33 +36,11 @@ public class ProximityQueryNode extends BooleanQueryNode {
   private static final long serialVersionUID = 9018220596680832916L;
 
   public enum Type {
-    PARAGRAPH, SENTENCE, NUMBER;
-
-    CharSequence toQueryString() {
-      switch (this) {
-      case PARAGRAPH:
-        return "WITHIN PARAGRAPH";
-      case SENTENCE:
-        return "WITHIN SENTENCE";
-      case NUMBER:
-        return "WITHIN";
-      default:
-        return "WITHIN SENTENCE";
-      }
-    }
+    PARAGRAPH { CharSequence toQueryString() { return "WITHIN PARAGRAPH"; } },
+    SENTENCE  { CharSequence toQueryString() { return "WITHIN SENTENCE";  } },
+    NUMBER    { CharSequence toQueryString() { return "WITHIN";           } };
 
-    public String toString() {
-      switch (this) {
-      case PARAGRAPH:
-        return "PARAGRAPH";
-      case SENTENCE:
-        return "SENTENCE";
-      case NUMBER:
-        return "NUMBER";
-      default:
-        return "NUMBER";
-      }
-    }
+    abstract CharSequence toQueryString();
   }
 
   // utility class
diff --git a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
index 629dc3e..61f159a 100644
--- a/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
+++ b/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/QueryParserWrapper.java
@@ -52,7 +52,6 @@ import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProces
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.Parameter;
 
 /**
  * This class performs the query parsing using the new query parser
@@ -71,17 +70,7 @@ public class QueryParserWrapper {
    * The default operator for parsing queries. Use
    * {@link QueryParserWrapper#setDefaultOperator} to change it.
    */
-  static public final class Operator extends Parameter {
-    private static final long serialVersionUID = 3550299139196880290L;
-
-    private Operator(String name) {
-      super(name);
-    }
-
-    static public final Operator OR = new Operator("OR");
-
-    static public final Operator AND = new Operator("AND");
-  }
+  static public enum Operator { OR, AND }
 
   // the nested class:
   /** Alternative form of QueryParser.Operator.AND */
diff --git a/src/java/org/apache/lucene/document/AbstractField.java b/src/java/org/apache/lucene/document/AbstractField.java
index 997452c..294289b 100755
--- a/src/java/org/apache/lucene/document/AbstractField.java
+++ b/src/java/org/apache/lucene/document/AbstractField.java
@@ -56,35 +56,10 @@ public abstract class AbstractField implements Fieldable {
       throw new NullPointerException("name cannot be null");
     this.name = StringHelper.intern(name);        // field names are interned
 
-    if (store == Field.Store.YES){
-      this.isStored = true;
-    }
-    else if (store == Field.Store.NO){
-      this.isStored = false;
-    }
-    else
-      throw new IllegalArgumentException("unknown store parameter " + store);
-
-    if (index == Field.Index.NO) {
-      this.isIndexed = false;
-      this.isTokenized = false;
-    } else if (index == Field.Index.ANALYZED) {
-      this.isIndexed = true;
-      this.isTokenized = true;
-    } else if (index == Field.Index.NOT_ANALYZED) {
-      this.isIndexed = true;
-      this.isTokenized = false;
-    } else if (index == Field.Index.NOT_ANALYZED_NO_NORMS) {
-      this.isIndexed = true;
-      this.isTokenized = false;
-      this.omitNorms = true;
-    } else if (index == Field.Index.ANALYZED_NO_NORMS) {
-      this.isIndexed = true;
-      this.isTokenized = true;
-      this.omitNorms = true;
-    } else {
-      throw new IllegalArgumentException("unknown index parameter " + index);
-    }
+    this.isStored = store.isStored();
+    this.isIndexed = index.isIndexed();
+    this.isTokenized = index.isAnalyzed();
+    this.omitNorms = index.omitNorms();
 
     this.isBinary = false;
 
@@ -138,34 +113,9 @@ public abstract class AbstractField implements Fieldable {
   public String name()    { return name; }
 
   protected void setStoreTermVector(Field.TermVector termVector) {
-    if (termVector == Field.TermVector.NO) {
-      this.storeTermVector = false;
-      this.storePositionWithTermVector = false;
-      this.storeOffsetWithTermVector = false;
-    }
-    else if (termVector == Field.TermVector.YES) {
-      this.storeTermVector = true;
-      this.storePositionWithTermVector = false;
-      this.storeOffsetWithTermVector = false;
-    }
-    else if (termVector == Field.TermVector.WITH_POSITIONS) {
-      this.storeTermVector = true;
-      this.storePositionWithTermVector = true;
-      this.storeOffsetWithTermVector = false;
-    }
-    else if (termVector == Field.TermVector.WITH_OFFSETS) {
-      this.storeTermVector = true;
-      this.storePositionWithTermVector = false;
-      this.storeOffsetWithTermVector = true;
-    }
-    else if (termVector == Field.TermVector.WITH_POSITIONS_OFFSETS) {
-      this.storeTermVector = true;
-      this.storePositionWithTermVector = true;
-      this.storeOffsetWithTermVector = true;
-    }
-    else {
-      throw new IllegalArgumentException("unknown termVector parameter " + termVector);
-    }
+    this.storeTermVector = termVector.isStored();
+    this.storePositionWithTermVector = termVector.withPositions();
+    this.storeOffsetWithTermVector = termVector.withOffsets();
   }
 
   /** True iff the value of the field is to be stored in the index for return
diff --git a/src/java/org/apache/lucene/document/Field.java b/src/java/org/apache/lucene/document/Field.java
index 96f93b1..5f6a47e 100644
--- a/src/java/org/apache/lucene/document/Field.java
+++ b/src/java/org/apache/lucene/document/Field.java
@@ -19,7 +19,6 @@ package org.apache.lucene.document;
 
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.index.IndexWriter;   // for javadoc
-import org.apache.lucene.util.Parameter;
 import org.apache.lucene.util.StringHelper;
 
 import java.io.Reader;
@@ -36,45 +35,56 @@ import java.io.Serializable;
 public final class Field extends AbstractField implements Fieldable, Serializable {
   
   /** Specifies whether and how a field should be stored. */
-  public static final class Store extends Parameter implements Serializable {
-
-    private Store(String name) {
-      super(name);
-    }
+  public static enum Store {
 
     /** Store the original field value in the index. This is useful for short texts
      * like a document's title which should be displayed with the results. The
      * value is stored in its original form, i.e. no analyzer is used before it is
      * stored.
      */
-    public static final Store YES = new Store("YES");
+    YES {
+      public boolean isStored() { return true; }
+    },
 
     /** Do not store the field value in the index. */
-    public static final Store NO = new Store("NO");
+    NO
+    {
+      public boolean isStored() { return false; }
+    };
+
+    public abstract boolean isStored();
   }
 
   /** Specifies whether and how a field should be indexed. */
-  public static final class Index extends Parameter implements Serializable {
-
-    private Index(String name) {
-      super(name);
-    }
+  public static enum Index {
 
     /** Do not index the field value. This field can thus not be searched,
      * but one can still access its contents provided it is
      * {@link Field.Store stored}. */
-    public static final Index NO = new Index("NO");
+    NO {
+      public boolean isIndexed()  { return false; }
+      public boolean isAnalyzed() { return false; }
+      public boolean omitNorms()  { return true;  }   
+    },
 
     /** Index the tokens produced by running the field's
      * value through an Analyzer.  This is useful for
      * common text. */
-    public static final Index ANALYZED = new Index("ANALYZED");
+    ANALYZED {
+      public boolean isIndexed()  { return true;  }
+      public boolean isAnalyzed() { return true;  }
+      public boolean omitNorms()  { return false; }   	
+    },
 
     /** Index the field's value without using an Analyzer, so it can be searched.
      * As no analyzer is used the value will be stored as a single term. This is
      * useful for unique Ids like product numbers.
      */
-    public static final Index NOT_ANALYZED = new Index("NOT_ANALYZED");
+    NOT_ANALYZED {
+      public boolean isIndexed()  { return true;  }
+      public boolean isAnalyzed() { return false; }
+      public boolean omitNorms()  { return false; }   	
+    },
 
     /** Expert: Index the field's value without an Analyzer,
      * and also disable the storing of norms.  Note that you
@@ -90,44 +100,96 @@ public final class Field extends AbstractField implements Fieldable, Serializabl
      * above described effect on a field, all instances of
      * that field must be indexed with NOT_ANALYZED_NO_NORMS
      * from the beginning. */
-    public static final Index NOT_ANALYZED_NO_NORMS = new Index("NOT_ANALYZED_NO_NORMS");
+    NOT_ANALYZED_NO_NORMS {
+      public boolean isIndexed()  { return true;  }
+      public boolean isAnalyzed() { return false; }
+      public boolean omitNorms()  { return true;  }   	
+    },
 
     /** Expert: Index the tokens produced by running the
      *  field's value through an Analyzer, and also
      *  separately disable the storing of norms.  See
      *  {@link #NOT_ANALYZED_NO_NORMS} for what norms are
      *  and why you may want to disable them. */
-    public static final Index ANALYZED_NO_NORMS = new Index("ANALYZED_NO_NORMS");
+    ANALYZED_NO_NORMS {
+      public boolean isIndexed()  { return true;  }
+      public boolean isAnalyzed() { return true;  }
+      public boolean omitNorms()  { return true;  }   	
+    };
+
+    /** Get the best representation of the index given the flags. */
+    public static Index toIndex(boolean indexed, boolean analyzed) {
+      return toIndex(indexed, analyzed, false);
+    }
+
+    /** Expert: Get the best representation of the index given the flags. */
+    public static Index toIndex(boolean indexed, boolean analyzed, boolean omitNorms) {
+
+      // If it is not indexed nothing else matters
+      if (!indexed) {
+        return Index.NO;
+      }
+
+      // typical, non-expert
+      if (!omitNorms) {
+        if (analyzed) {
+          return Index.ANALYZED;
+        }
+        return Index.NOT_ANALYZED;
+      }
+
+      // Expert: Norms omitted
+      if (analyzed) {
+        return Index.ANALYZED_NO_NORMS;
+      }
+      return Index.NOT_ANALYZED_NO_NORMS;
+    }
+
+    public abstract boolean isIndexed();
+    public abstract boolean isAnalyzed();
+    public abstract boolean omitNorms();  	
   }
 
   /** Specifies whether and how a field should have term vectors. */
-  public static final class TermVector  extends Parameter implements Serializable {
-    
-    private TermVector(String name) {
-      super(name);
-    }
+  public static enum TermVector {
     
     /** Do not store term vectors. 
      */
-    public static final TermVector NO = new TermVector("NO");
+    NO {
+    	public boolean isStored()      { return false; }
+    	public boolean withPositions() { return false; }
+    	public boolean withOffsets()   { return false; }
+    },
     
     /** Store the term vectors of each document. A term vector is a list
      * of the document's terms and their number of occurrences in that document. */
-    public static final TermVector YES = new TermVector("YES");
+    YES {
+    	public boolean isStored()      { return true;  }
+    	public boolean withPositions() { return false; }
+    	public boolean withOffsets()   { return false; }
+    },
     
     /**
      * Store the term vector + token position information
      * 
      * @see #YES
      */ 
-    public static final TermVector WITH_POSITIONS = new TermVector("WITH_POSITIONS");
+    WITH_POSITIONS {
+    	public boolean isStored()      { return true;  }
+    	public boolean withPositions() { return true;  }
+    	public boolean withOffsets()   { return false; }
+    },
     
     /**
      * Store the term vector + Token offset information
      * 
      * @see #YES
      */ 
-    public static final TermVector WITH_OFFSETS = new TermVector("WITH_OFFSETS");
+    WITH_OFFSETS {
+    	public boolean isStored()      { return true;  }
+    	public boolean withPositions() { return false; }
+    	public boolean withOffsets()   { return true;  }
+    },
     
     /**
      * Store the term vector + Token position and offset information
@@ -136,7 +198,36 @@ public final class Field extends AbstractField implements Fieldable, Serializabl
      * @see #WITH_POSITIONS
      * @see #WITH_OFFSETS
      */ 
-    public static final TermVector WITH_POSITIONS_OFFSETS = new TermVector("WITH_POSITIONS_OFFSETS");
+    WITH_POSITIONS_OFFSETS {
+    	public boolean isStored()      { return true;  }
+    	public boolean withPositions() { return true;  }
+    	public boolean withOffsets()   { return true;  }
+    };
+
+    /** Get the best representation of a TermVector given the flags. */
+    public static TermVector toTermVector(boolean stored, boolean withOffsets, boolean withPositions) {
+
+      // If it is not stored, nothing else matters.
+      if (!stored) {
+    	return TermVector.NO;
+      }
+
+      if (withOffsets) {
+        if (withPositions) {
+          return Field.TermVector.WITH_POSITIONS_OFFSETS;
+        }
+        return Field.TermVector.WITH_OFFSETS;
+      }
+
+      if (withPositions) {
+        return Field.TermVector.WITH_POSITIONS;
+      }
+      return Field.TermVector.YES;
+    }
+
+    public abstract boolean isStored();
+    public abstract boolean withPositions();
+    public abstract boolean withOffsets();
   }
   
   
@@ -288,38 +379,15 @@ public final class Field extends AbstractField implements Fieldable, Serializabl
     
     this.fieldsData = value;
 
-    if (store == Store.YES){
-      this.isStored = true;
-    }
-    else if (store == Store.NO){
-      this.isStored = false;
-    }
-    else
-      throw new IllegalArgumentException("unknown store parameter " + store);
+    this.isStored = store.isStored();
    
+    this.isIndexed = index.isIndexed();
+    this.isTokenized = index.isAnalyzed();
+    this.omitNorms = index.omitNorms();
     if (index == Index.NO) {
-      this.isIndexed = false;
-      this.isTokenized = false;
       this.omitTermFreqAndPositions = false;
-      this.omitNorms = true;
-    } else if (index == Index.ANALYZED) {
-      this.isIndexed = true;
-      this.isTokenized = true;
-    } else if (index == Index.NOT_ANALYZED) {
-      this.isIndexed = true;
-      this.isTokenized = false;
-    } else if (index == Index.NOT_ANALYZED_NO_NORMS) {
-      this.isIndexed = true;
-      this.isTokenized = false;
-      this.omitNorms = true;
-    } else if (index == Index.ANALYZED_NO_NORMS) {
-      this.isIndexed = true;
-      this.isTokenized = true;
-      this.omitNorms = true;
-    } else {
-      throw new IllegalArgumentException("unknown index parameter " + index);
-    }
-    
+    }    
+
     this.isBinary = false;
 
     setStoreTermVector(termVector);
@@ -449,14 +517,10 @@ public final class Field extends AbstractField implements Fieldable, Serializabl
     this.name = StringHelper.intern(name);        // field names are interned
     fieldsData = value;
     
-    if (store == Store.YES) {
-      isStored = true;
-    }
-    else if (store == Store.NO)
+    if (store == Store.NO)
       throw new IllegalArgumentException("binary values can't be unstored");
-    else
-      throw new IllegalArgumentException("unknown store parameter " + store);
     
+    isStored = store.isStored();
     isIndexed   = false;
     isTokenized = false;
     omitTermFreqAndPositions = false;
diff --git a/src/java/org/apache/lucene/document/FieldSelectorResult.java b/src/java/org/apache/lucene/document/FieldSelectorResult.java
index 47bf5de..7638a6f 100755
--- a/src/java/org/apache/lucene/document/FieldSelectorResult.java
+++ b/src/java/org/apache/lucene/document/FieldSelectorResult.java
@@ -1,6 +1,5 @@
 package org.apache.lucene.document;
 
-import java.io.Serializable;
 /**
  * Copyright 2004 The Apache Software Foundation
  *
@@ -21,16 +20,16 @@ import java.io.Serializable;
  *  Provides information about what should be done with this Field 
  *
  **/
-//Replace with an enumerated type in 1.5
-public final class FieldSelectorResult implements Serializable {
+public enum FieldSelectorResult {
 
     /**
      * Load this {@link Field} every time the {@link Document} is loaded, reading in the data as it is encountered.
      *  {@link Document#getField(String)} and {@link Document#getFieldable(String)} should not return null.
      *<p/>
      * {@link Document#add(Fieldable)} should be called by the Reader.
-      */
-  public transient static final FieldSelectorResult LOAD = new FieldSelectorResult(0);
+     */
+  LOAD,
+
     /**
      * Lazily load this {@link Field}.  This means the {@link Field} is valid, but it may not actually contain its data until
      * invoked.  {@link Document#getField(String)} SHOULD NOT BE USED.  {@link Document#getFieldable(String)} is safe to use and should
@@ -38,14 +37,16 @@ public final class FieldSelectorResult implements Serializable {
      *<p/>
      * {@link Document#add(Fieldable)} should be called by the Reader.
      */
-  public transient static final FieldSelectorResult LAZY_LOAD = new FieldSelectorResult(1);
+  LAZY_LOAD,
+
     /**
      * Do not load the {@link Field}.  {@link Document#getField(String)} and {@link Document#getFieldable(String)} should return null.
      * {@link Document#add(Fieldable)} is not called.
      * <p/>
      * {@link Document#add(Fieldable)} should not be called by the Reader.
      */
-  public transient static final FieldSelectorResult NO_LOAD = new FieldSelectorResult(2);
+  NO_LOAD,
+
     /**
      * Load this field as in the {@link #LOAD} case, but immediately return from {@link Field} loading for the {@link Document}.  Thus, the
      * Document may not have its complete set of Fields.  {@link Document#getField(String)} and {@link Document#getFieldable(String)} should
@@ -53,37 +54,14 @@ public final class FieldSelectorResult implements Serializable {
      * <p/>
      * {@link Document#add(Fieldable)} should be called by the Reader.
      */
-  public transient static final FieldSelectorResult LOAD_AND_BREAK = new FieldSelectorResult(3);
-
-     /** Expert:  Load the size of this {@link Field} rather than its value.
-       * Size is measured as number of bytes required to store the field == bytes for a binary or any compressed value, and 2*chars for a String value.
-      * The size is stored as a binary value, represented as an int in a byte[], with the higher order byte first in [0]
-      */
-  public transient static final FieldSelectorResult SIZE = new FieldSelectorResult(5);
-
-  /** Expert: Like {@link #SIZE} but immediately break from the field loading loop, i.e., stop loading further fields, after the size is loaded */         
-  public transient static final FieldSelectorResult SIZE_AND_BREAK = new FieldSelectorResult(6);
-
+  LOAD_AND_BREAK,
 
+    /** Expert:  Load the size of this {@link Field} rather than its value.
+     * Size is measured as number of bytes required to store the field == bytes for a binary or any compressed value, and 2*chars for a String value.
+     * The size is stored as a binary value, represented as an int in a byte[], with the higher order byte first in [0]
+     */
+  SIZE,
 
-  private int id;
-
-  private FieldSelectorResult(int id) {
-    this.id = id;
-  }
-
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    final FieldSelectorResult that = (FieldSelectorResult) o;
-
-    if (id != that.id) return false;
-
-    return true;
-  }
-
-  public int hashCode() {
-    return id;
-  }
+    /** Expert: Like {@link #SIZE} but immediately break from the field loading loop, i.e., stop loading further fields, after the size is loaded */         
+  SIZE_AND_BREAK
 }
diff --git a/src/java/org/apache/lucene/index/FieldsReader.java b/src/java/org/apache/lucene/index/FieldsReader.java
index 12b31ab..346ef7e 100644
--- a/src/java/org/apache/lucene/index/FieldsReader.java
+++ b/src/java/org/apache/lucene/index/FieldsReader.java
@@ -18,7 +18,12 @@ package org.apache.lucene.index;
  */
 
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.document.*;
+import org.apache.lucene.document.AbstractField;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldSelector;
+import org.apache.lucene.document.FieldSelectorResult;
+import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -298,8 +303,8 @@ final class FieldsReader implements Cloneable {
       fieldsStream.seek(pointer + toRead);
     } else {
       Field.Store store = Field.Store.YES;
-      Field.Index index = getIndexType(fi, tokenize);
-      Field.TermVector termVector = getTermVectorType(fi);
+      Field.Index index = Field.Index.toIndex(fi.isIndexed, tokenize);
+      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, fi.storeOffsetWithTermVector, fi.storePositionWithTermVector);
 
       AbstractField f;
       int length = fieldsStream.readVInt();
@@ -327,8 +332,8 @@ final class FieldsReader implements Cloneable {
       doc.add(new Field(fi.name, b, Field.Store.YES));
     } else {
       Field.Store store = Field.Store.YES;
-      Field.Index index = getIndexType(fi, tokenize);
-      Field.TermVector termVector = getTermVectorType(fi);
+      Field.Index index = Field.Index.toIndex(fi.isIndexed, tokenize);
+      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, fi.storeOffsetWithTermVector, fi.storePositionWithTermVector);
 
       AbstractField f;
       f = new Field(fi.name,     // name
@@ -357,37 +362,6 @@ final class FieldsReader implements Cloneable {
     return size;
   }
 
-  private Field.TermVector getTermVectorType(FieldInfo fi) {
-    Field.TermVector termVector = null;
-    if (fi.storeTermVector) {
-      if (fi.storeOffsetWithTermVector) {
-        if (fi.storePositionWithTermVector) {
-          termVector = Field.TermVector.WITH_POSITIONS_OFFSETS;
-        } else {
-          termVector = Field.TermVector.WITH_OFFSETS;
-        }
-      } else if (fi.storePositionWithTermVector) {
-        termVector = Field.TermVector.WITH_POSITIONS;
-      } else {
-        termVector = Field.TermVector.YES;
-      }
-    } else {
-      termVector = Field.TermVector.NO;
-    }
-    return termVector;
-  }
-
-  private Field.Index getIndexType(FieldInfo fi, boolean tokenize) {
-    Field.Index index;
-    if (fi.isIndexed && tokenize)
-      index = Field.Index.ANALYZED;
-    else if (fi.isIndexed && !tokenize)
-      index = Field.Index.NOT_ANALYZED;
-    else
-      index = Field.Index.NO;
-    return index;
-  }
-
   /**
    * A Lazy implementation of Fieldable that differs loading of fields until asked for, instead of when the Document is
    * loaded.
diff --git a/src/java/org/apache/lucene/queryParser/QueryParser.java b/src/java/org/apache/lucene/queryParser/QueryParser.java
index e9ad4e5..7ccbe8b 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParser.java
+++ b/src/java/org/apache/lucene/queryParser/QueryParser.java
@@ -12,7 +12,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Vector;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -34,7 +33,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 
 /**
  * This class is generated by JavaCC.  The most important method is
@@ -146,14 +144,7 @@ public class QueryParser implements QueryParserConstants {
   /** The default operator for parsing queries. 
    * Use {@link QueryParser#setDefaultOperator} to change it.
    */
-  static public final class Operator extends Parameter {
-    private Operator(String name) {
-      super(name);
-    }
-    static public final Operator OR = new Operator("OR");
-    static public final Operator AND = new Operator("AND");
-  }
-
+  static public enum Operator { OR, AND }
 
   /** Constructs a query parser.
    *  @param f  the default field for query terms.
diff --git a/src/java/org/apache/lucene/queryParser/QueryParser.jj b/src/java/org/apache/lucene/queryParser/QueryParser.jj
index acc1a25..2e39f8a 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParser.jj
+++ b/src/java/org/apache/lucene/queryParser/QueryParser.jj
@@ -36,7 +36,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.Vector;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -58,7 +57,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 
 /**
  * This class is generated by JavaCC.  The most important method is
@@ -170,14 +168,7 @@ public class QueryParser {
   /** The default operator for parsing queries. 
    * Use {@link QueryParser#setDefaultOperator} to change it.
    */
-  static public final class Operator extends Parameter {
-    private Operator(String name) {
-      super(name);
-    }
-    static public final Operator OR = new Operator("OR");
-    static public final Operator AND = new Operator("AND");
-  }
-
+  static public enum Operator { OR, AND }
 
   /** Constructs a query parser.
    *  @param f  the default field for query terms.
diff --git a/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java b/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
index 2dc793f..0bbd441 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
+++ b/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
@@ -32,7 +32,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.util.Parameter;
 
 /** Token Manager. */
 public class QueryParserTokenManager implements QueryParserConstants
diff --git a/src/java/org/apache/lucene/search/BooleanClause.java b/src/java/org/apache/lucene/search/BooleanClause.java
index bf091a5..1c0c4dd 100644
--- a/src/java/org/apache/lucene/search/BooleanClause.java
+++ b/src/java/org/apache/lucene/search/BooleanClause.java
@@ -1,7 +1,5 @@
 package org.apache.lucene.search;
 
-import org.apache.lucene.util.Parameter;
-
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -23,33 +21,24 @@ import org.apache.lucene.util.Parameter;
 public class BooleanClause implements java.io.Serializable {
   
   /** Specifies how clauses are to occur in matching documents. */
-  public static final class Occur extends Parameter implements java.io.Serializable {
-    
-    private Occur(String name) {
-      // typesafe enum pattern, no public constructor
-      super(name);
-    }
-
-    public String toString() {
-      if (this == MUST) return "+";
-      if (this == MUST_NOT) return "-";
-      return "";
-    }
+  public static enum Occur {
 
     /** Use this operator for clauses that <i>must</i> appear in the matching documents. */
-    public static final Occur MUST = new Occur("MUST");
+    MUST     { public String toString() { return "+"; } },
+
     /** Use this operator for clauses that <i>should</i> appear in the 
      * matching documents. For a BooleanQuery with no <code>MUST</code> 
      * clauses one or more <code>SHOULD</code> clauses must match a document 
      * for the BooleanQuery to match.
      * @see BooleanQuery#setMinimumNumberShouldMatch
      */
-    public static final Occur SHOULD = new Occur("SHOULD");
+    SHOULD   { public String toString() { return "";  } },
+
     /** Use this operator for clauses that <i>must not</i> appear in the matching documents.
      * Note that it is not possible to search for queries that only consist
      * of a <code>MUST_NOT</code> clause. */
-    public static final Occur MUST_NOT = new Occur("MUST_NOT");
-    
+    MUST_NOT { public String toString() { return "-"; } };
+
   }
 
   /** The query whose matching documents are combined by the boolean query.
@@ -85,11 +74,11 @@ public class BooleanClause implements java.io.Serializable {
   }
   
   public boolean isProhibited() {
-    return Occur.MUST_NOT.equals(occur);
+    return Occur.MUST_NOT == occur;
   }
 
   public boolean isRequired() {
-    return Occur.MUST.equals(occur);
+    return Occur.MUST == occur;
   }
 
 
@@ -100,12 +89,12 @@ public class BooleanClause implements java.io.Serializable {
       return false;
     BooleanClause other = (BooleanClause)o;
     return this.query.equals(other.query)
-      && this.occur.equals(other.occur);
+      && this.occur == other.occur;
   }
 
   /** Returns a hash code value for this object.*/
   public int hashCode() {
-    return query.hashCode() ^ (Occur.MUST.equals(occur)?1:0) ^ (Occur.MUST_NOT.equals(occur)?2:0);
+    return query.hashCode() ^ (Occur.MUST == occur?1:0) ^ (Occur.MUST_NOT == occur?2:0);
   }
 
 
diff --git a/src/java/org/apache/lucene/util/Parameter.java b/src/java/org/apache/lucene/util/Parameter.java
index 1d15556..30fc82f 100644
--- a/src/java/org/apache/lucene/util/Parameter.java
+++ b/src/java/org/apache/lucene/util/Parameter.java
@@ -25,7 +25,9 @@ import java.util.Map;
 
 /**
  * A serializable Enum class.
+ * @deprecated Use Java 5 enum
  */
+@SuppressWarnings("serial")
 public abstract class Parameter implements Serializable
 {
   static Map<String,Parameter> allParameters = new HashMap<String,Parameter>();
diff --git a/src/java/org/apache/lucene/util/Version.java b/src/java/org/apache/lucene/util/Version.java
index b01ad36..b460f5b 100644
--- a/src/java/org/apache/lucene/util/Version.java
+++ b/src/java/org/apache/lucene/util/Version.java
@@ -18,51 +18,47 @@ package org.apache.lucene.util;
  */
 
 
-import java.io.Serializable;
-
 /**
  * Use by certain classes to match version compatibility
  * across releases of Lucene.
  */
-public final class Version extends Parameter implements Serializable {
+public enum Version {
 
-  /** Use this to get the latest & greatest settings, bug
-   *  fixes, etc, for Lucene.
-   *
-   * <p><b>WARNING</b>: if you use this setting, and then
-   * upgrade to a newer release of Lucene, sizable changes
-   * may happen.  If precise back compatibility is important
-   * then you should instead explicitly specify an actual
-   * version.
-   */
-  public static final Version LUCENE_CURRENT = new Version("LUCENE_CURRENT", 0);
-  
   /** Match settings and bugs in Lucene's 2.0 release. */
-  public static final Version LUCENE_20 = new Version("LUCENE_20", 2000);
+  LUCENE_20,
 
   /** Match settings and bugs in Lucene's 2.1 release. */
-  public static final Version LUCENE_21 = new Version("LUCENE_21", 2100);
+  LUCENE_21,
 
   /** Match settings and bugs in Lucene's 2.2 release. */
-  public static final Version LUCENE_22 = new Version("LUCENE_22", 2200);
+  LUCENE_22,
 
   /** Match settings and bugs in Lucene's 2.3 release. */
-  public static final Version LUCENE_23 = new Version("LUCENE_23", 2300);
+  LUCENE_23,
 
   /** Match settings and bugs in Lucene's 2.4 release. */
-  public static final Version LUCENE_24 = new Version("LUCENE_24", 2400);
+  LUCENE_24,
 
   /** Match settings and bugs in Lucene's 2.9 release. */
-  public static final Version LUCENE_29 = new Version("LUCENE_29", 2900);
+  LUCENE_29,
 
-  private final int v;
+  /** Match settings and bugs in Lucene's 3.0 release. */
+  LUCENE_30,
+  
+  /* Add new constants for later versions **here** to respect order! */
 
-  public Version(String name, int v) {
-    super(name);
-    this.v = v;
-  }
+  /** Use this to get the latest &amp; greatest settings, bug
+   *  fixes, etc, for Lucene.
+   *
+   * <p><b>WARNING</b>: if you use this setting, and then
+   * upgrade to a newer release of Lucene, sizable changes
+   * may happen.  If precise back compatibility is important
+   * then you should instead explicitly specify an actual
+   * version.
+   */
+  LUCENE_CURRENT;
 
   public boolean onOrAfter(Version other) {
-    return v == 0 || v >= other.v;
+    return compareTo(other) >= 0;
   }
 }
\ No newline at end of file
diff --git a/src/test/org/apache/lucene/util/TestVersion.java b/src/test/org/apache/lucene/util/TestVersion.java
new file mode 100644
index 0000000..0ff50ce
--- /dev/null
+++ b/src/test/org/apache/lucene/util/TestVersion.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.util;
+
+import java.util.EnumSet;
+
+public class TestVersion extends LuceneTestCase {
+
+  public void test() {
+    for (Version v : Version.values()) {
+      assertTrue("LUCENE_CURRENT must be always onOrAfter("+v+")", Version.LUCENE_CURRENT.onOrAfter(v));
+    }
+    assertTrue(Version.LUCENE_30.onOrAfter(Version.LUCENE_29));
+    assertTrue(Version.LUCENE_30.onOrAfter(Version.LUCENE_30));
+    assertFalse(Version.LUCENE_29.onOrAfter(Version.LUCENE_30));
+  }
+
+}

