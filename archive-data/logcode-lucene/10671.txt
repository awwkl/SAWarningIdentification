GitDiffStart: 472242dc8f838a1d783ba7040ae0b350f209ab6b | Tue Oct 30 14:15:44 2012 +0000
diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
index 9908988..10f643a 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
@@ -36,7 +36,6 @@ import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeoutException;
 
-import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.Transformer;
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.TransformerFactory;
@@ -78,7 +77,6 @@ import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
 
 
 /**
@@ -106,9 +104,15 @@ public class CoreContainer
   private static final String CORE_COLLECTION = "collection";
   private static final String CORE_ROLES = "roles";
   private static final String CORE_PROPERTIES = "properties";
+  private static final String CORE_LOADONSTARTUP = "loadOnStartup";
+  private static final String CORE_SWAPPABLE = "swappable";
 
 
-  protected final Map<String, SolrCore> cores = new LinkedHashMap<String, SolrCore>();
+  protected final Map<String, SolrCore> cores = new LinkedHashMap<String, SolrCore>(); // For "permanent" cores
+
+  protected Map<String, SolrCore> swappableCores = new LinkedHashMap<String, SolrCore>(); // For "lazily loaded" cores
+
+  protected final Map<String, CoreDescriptor> dynamicDescriptors = new LinkedHashMap<String, CoreDescriptor>();
 
   protected final Map<String,Exception> coreInitFailures = 
     Collections.synchronizedMap(new LinkedHashMap<String,Exception>());
@@ -140,6 +144,7 @@ public class CoreContainer
   private String zkHost;
   private Map<SolrCore,String> coreToOrigName = new ConcurrentHashMap<SolrCore,String>();
   private String leaderVoteWait;
+  protected int swappableCacheSize = Integer.MAX_VALUE; // Use as a flag too, if swappableCacheSize set in solr.xml this will be changed
   
   {
     log.info("New CoreContainer " + System.identityHashCode(this));
@@ -158,7 +163,7 @@ public class CoreContainer
   /**
    * Initalize CoreContainer directly from the constructor
    */
-  public CoreContainer(String dir, File configFile) throws ParserConfigurationException, IOException, SAXException
+  public CoreContainer(String dir, File configFile)
   {
     this(dir);
     this.load(dir, configFile);
@@ -290,8 +295,7 @@ public class CoreContainer
     protected String dataDir = null; // override datadir for single core mode
 
     // core container instantiation
-    public CoreContainer initialize() throws IOException,
-        ParserConfigurationException, SAXException {
+    public CoreContainer initialize() {
       CoreContainer cores = null;
       String solrHome = SolrResourceLoader.locateSolrHome();
       File fconf = new File(solrHome, containerConfigFilename == null ? "solr.xml"
@@ -303,7 +307,12 @@ public class CoreContainer
         cores.load(solrHome, fconf);
       } else {
         log.info("no solr.xml file found - using default");
-        cores.load(solrHome, new InputSource(new ByteArrayInputStream(DEF_SOLR_XML.getBytes("UTF-8"))));
+        try {
+          cores.load(solrHome, new InputSource(new ByteArrayInputStream(DEF_SOLR_XML.getBytes("UTF-8"))));
+        } catch (Exception e) {
+          throw new SolrException(ErrorCode.SERVER_ERROR,
+              "CoreContainer.Initialize failed when trying to load default solr.xml file", e);
+        }
         cores.configFile = fconf;
       }
       
@@ -335,7 +344,22 @@ public class CoreContainer
     return p;
   }
 
-
+  // Trivial helper method for load, note it implements LRU on swappable cores
+  private void allocateLazyCores(Config cfg) {
+    swappableCacheSize = cfg.getInt("solr/cores/@swappableCacheSize", Integer.MAX_VALUE);
+    if (swappableCacheSize != Integer.MAX_VALUE) {
+      swappableCores = new LinkedHashMap<String, SolrCore>(swappableCacheSize, 0.75f, true) {
+        @Override
+        protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {
+          if (size() > swappableCacheSize) {
+            eldest.getValue().close();
+            return true;
+          }
+          return false;
+        }
+      };
+    }
+  }
 
   //-------------------------------------------------------------------
   // Initialization / Cleanup
@@ -346,7 +370,7 @@ public class CoreContainer
    * @param dir the home directory of all resources.
    * @param configFile the configuration file
    */
-  public void load(String dir, File configFile ) throws ParserConfigurationException, IOException, SAXException {
+  public void load(String dir, File configFile ) {
     this.configFile = configFile;
     this.load(dir, new InputSource(configFile.toURI().toASCIIString()));
   } 
@@ -357,8 +381,7 @@ public class CoreContainer
    * @param dir the home directory of all resources.
    * @param cfgis the configuration file InputStream
    */
-  public void load(String dir, InputSource cfgis)
-      throws ParserConfigurationException, IOException, SAXException {
+  public void load(String dir, InputSource cfgis)  {
 
     if (null == dir) {
       // don't rely on SolrResourceLoader(), determine explicitly first
@@ -369,17 +392,20 @@ public class CoreContainer
     this.loader = new SolrResourceLoader(dir);
     solrHome = loader.getInstanceDir();
     
-    Config cfg = new Config(loader, null, cfgis, null, false);
+    Config cfg;
     
     // keep orig config for persist to consult
     try {
+      cfg = new Config(loader, null, cfgis, null, false);
       this.cfg = new Config(loader, null, copyDoc(cfg.getDocument()));
-    } catch (TransformerException e) {
+    } catch (Exception e) {
       throw new SolrException(ErrorCode.SERVER_ERROR, "", e);
     }
-    
+    // Since the cores  var is now initialized to null, let's set it up right now.
     cfg.substituteProperties();
-    
+
+    allocateLazyCores(cfg);
+
     // Initialize Logging
     if(cfg.getBool("solr/logging/@enabled",true)) {
       String slf4jImpl = null;
@@ -404,9 +430,6 @@ public class CoreContainer
         if("JUL".equalsIgnoreCase(fname)) {
           logging = new JulWatcher(slf4jImpl);
         }
-//        else if( "Log4j".equals(fname) ) {
-//          logging = new Log4jWatcher(slf4jImpl);
-//        }
         else {
           try {
             logging = loader.newInstance(fname, LogWatcher.class);
@@ -427,8 +450,7 @@ public class CoreContainer
         }
       }
     }
-    
-    
+
     String dcoreName = cfg.get("solr/cores/@defaultCoreName", null);
     if(dcoreName != null && !dcoreName.isEmpty()) {
       defaultCoreName = dcoreName;
@@ -502,6 +524,7 @@ public class CoreContainer
         if (opt != null) {
           p.setSchemaName(opt);
         }
+
         if (zkController != null) {
           opt = DOMUtil.getAttr(node, CORE_SHARD, null);
           if (opt != null && opt.length() > 0) {
@@ -527,11 +550,25 @@ public class CoreContainer
 
         p.setCoreProperties(readProperties(cfg, node));
 
-        core  = create(p);
-        register(name, core, false);
-        
-        // track original names
-        coreToOrigName.put(core, rawName);
+        opt = DOMUtil.getAttr(node, CORE_LOADONSTARTUP, null);
+        if (opt != null) {
+          p.setLoadOnStartup(("true".equalsIgnoreCase(opt) || "on".equalsIgnoreCase(opt)) ? true : false);
+        }
+
+        opt = DOMUtil.getAttr(node, CORE_SWAPPABLE, null);
+        if (opt != null) {
+          p.setSwappable(("true".equalsIgnoreCase(opt) || "on".equalsIgnoreCase(opt)) ? true : false);
+        }
+
+        if (! p.isSwappable() && p.isLoadOnStartup()) { // Just like current case.
+          core = create(p);
+          register(name, core, false);
+          // track original names
+          coreToOrigName.put(core, rawName);
+        } else {
+          // Store it away for later use. includes non-swappable but not loaded at startup cores.
+          dynamicDescriptors.put(rawName, p);
+        }
       }
       catch (Throwable ex) {
         SolrException.log(log,null,ex);
@@ -583,7 +620,7 @@ public class CoreContainer
     }
     try {
       synchronized (cores) {
-        
+
         for (SolrCore core : cores.values()) {
           try {
             core.close();
@@ -593,6 +630,16 @@ public class CoreContainer
         }
         cores.clear();
       }
+      synchronized (swappableCores) {
+        for (SolrCore core : swappableCores.values()) {
+          try {
+            core.close();
+          } catch (Throwable t) {
+            SolrException.log(log, "Error shutting down core", t);
+          }
+        }
+        swappableCores.clear();
+      }
     } finally {
       if (shardHandlerFactory != null) {
         shardHandlerFactory.close();
@@ -646,6 +693,14 @@ public class CoreContainer
    * @return a previous core having the same name if it existed
    */
   public SolrCore register(String name, SolrCore core, boolean returnPrevNotClosed) {
+    return registerCore(cores, name, core, returnPrevNotClosed);
+  }
+
+  protected SolrCore registerLazyCore(String name, SolrCore core, boolean returnPrevNotClosed) {
+    return registerCore(swappableCores, name, core, returnPrevNotClosed);
+  }
+
+  protected SolrCore registerCore(Map<String,SolrCore> whichCores, String name, SolrCore core, boolean returnPrevNotClosed) {
     if( core == null ) {
       throw new RuntimeException( "Can not register a null core." );
     }
@@ -672,12 +727,12 @@ public class CoreContainer
     }
     
     SolrCore old = null;
-    synchronized (cores) {
+    synchronized (whichCores) {
       if (isShutDown) {
         core.close();
         throw new IllegalStateException("This CoreContainer has been shutdown");
       }
-      old = cores.put(name, core);
+      old = whichCores.put(name, core);
       coreInitFailures.remove(name);
       /*
       * set both the name of the descriptor and the name of the
@@ -743,18 +798,99 @@ public class CoreContainer
     return register(core.getName(), core, returnPrev);
   }
 
+  // Helper method to separate out creating a core from ZK as opposed to the "usual" way. See create()
+  private SolrCore createFromZk(String instanceDir, CoreDescriptor dcore)
+  {
+    try {
+      SolrResourceLoader solrLoader = null;
+      SolrConfig config = null;
+      String zkConfigName = null;
+      IndexSchema schema;
+      String collection = dcore.getCloudDescriptor().getCollectionName();
+      zkController.createCollectionZkNode(dcore.getCloudDescriptor());
+
+      zkConfigName = zkController.readConfigName(collection);
+      if (zkConfigName == null) {
+        log.error("Could not find config name for collection:" + collection);
+        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
+            "Could not find config name for collection:" + collection);
+      }
+      solrLoader = new ZkSolrResourceLoader(instanceDir, zkConfigName, libLoader, getCoreProps(instanceDir,
+          dcore.getPropertiesName(), dcore.getCoreProperties()), zkController);
+      config = getSolrConfigFromZk(zkConfigName, dcore.getConfigName(), solrLoader);
+      schema = getSchemaFromZk(zkConfigName, dcore.getSchemaName(), config, solrLoader);
+      return new SolrCore(dcore.getName(), null, config, schema, dcore);
+
+    } catch (KeeperException e) {
+      log.error("", e);
+      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
+          "", e);
+    } catch (InterruptedException e) {
+      // Restore the interrupted status
+      Thread.currentThread().interrupt();
+      log.error("", e);
+      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
+          "", e);
+    }
+  }
+
+  // Helper method to separate out creating a core from local configuration files. See create()
+  private SolrCore createFromLocal(String instanceDir, CoreDescriptor dcore) {
+    SolrResourceLoader solrLoader = null;
+
+    SolrConfig config = null;
+    solrLoader = new SolrResourceLoader(instanceDir, libLoader, getCoreProps(instanceDir, dcore.getPropertiesName(), dcore.getCoreProperties()));
+    try {
+      config = new SolrConfig(solrLoader, dcore.getConfigName(), null);
+    } catch (Exception e) {
+      throw new SolrException(ErrorCode.SERVER_ERROR, "Could not load config for " + dcore.getConfigName(), e);
+    }
+
+    IndexSchema schema = null;
+    if (indexSchemaCache != null) {
+      File schemaFile = new File(dcore.getSchemaName());
+      if (!schemaFile.isAbsolute()) {
+        schemaFile = new File(solrLoader.getInstanceDir() + "conf"
+            + File.separator + dcore.getSchemaName());
+      }
+      if (schemaFile.exists()) {
+        String key = schemaFile.getAbsolutePath()
+            + ":"
+            + new SimpleDateFormat("yyyyMMddHHmmss", Locale.ROOT).format(new Date(
+            schemaFile.lastModified()));
+        schema = indexSchemaCache.get(key);
+        if (schema == null) {
+          log.info("creating new schema object for core: " + dcore.name);
+          schema = new IndexSchema(config, dcore.getSchemaName(), null);
+          indexSchemaCache.put(key, schema);
+        } else {
+          log.info("re-using schema object for core: " + dcore.name);
+        }
+      }
+    }
+
+    if (schema == null) {
+      schema = new IndexSchema(config, dcore.getSchemaName(), null);
+    }
+
+    SolrCore core = new SolrCore(dcore.getName(), null, config, schema, dcore);
+
+    if (core.getUpdateHandler().getUpdateLog() != null) {
+      // always kick off recovery if we are in standalone mode.
+      core.getUpdateHandler().getUpdateLog().recoverFromLog();
+    }
+    return core;
+  }
+
   /**
    * Creates a new core based on a descriptor but does not register it.
    *
    * @param dcore a core descriptor
    * @return the newly created core
    */
-  public SolrCore create(CoreDescriptor dcore)  throws ParserConfigurationException, IOException, SAXException {
-
-    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException
+  public SolrCore create(CoreDescriptor dcore) {
 
     final String name = dcore.getName();
-    Exception failure = null;
 
     try {
       // Make the instanceDir relative to the cores instanceDir if not absolute
@@ -762,121 +898,18 @@ public class CoreContainer
       String instanceDir = idir.getPath();
       log.info("Creating SolrCore '{}' using instanceDir: {}", 
                dcore.getName(), instanceDir);
+
       // Initialize the solr config
-      SolrResourceLoader solrLoader = null;
-      
-      SolrConfig config = null;
-      String zkConfigName = null;
-      if(zkController == null) {
-        solrLoader = new SolrResourceLoader(instanceDir, libLoader, getCoreProps(instanceDir, dcore.getPropertiesName(),dcore.getCoreProperties()));
-        config = new SolrConfig(solrLoader, dcore.getConfigName(), null);
+      if (zkController != null) {
+        return createFromZk(instanceDir, dcore);
       } else {
-        try {
-          String collection = dcore.getCloudDescriptor().getCollectionName();
-          zkController.createCollectionZkNode(dcore.getCloudDescriptor());
-          
-          zkConfigName = zkController.readConfigName(collection);
-          if (zkConfigName == null) {
-            log.error("Could not find config name for collection:" + collection);
-            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
-                                         "Could not find config name for collection:" + collection);
-          }
-          solrLoader = new ZkSolrResourceLoader(instanceDir, zkConfigName, libLoader, getCoreProps(instanceDir, dcore.getPropertiesName(),dcore.getCoreProperties()), zkController);
-          config = getSolrConfigFromZk(zkConfigName, dcore.getConfigName(), solrLoader);
-        } catch (KeeperException e) {
-          log.error("", e);
-          throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
-                                       "", e);
-        } catch (InterruptedException e) {
-          // Restore the interrupted status
-          Thread.currentThread().interrupt();
-          log.error("", e);
-          throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
-                                       "", e);
-        }
-      }
-    
-      IndexSchema schema = null;
-      if (indexSchemaCache != null) {
-        if (zkController == null) {
-          File schemaFile = new File(dcore.getSchemaName());
-          if (!schemaFile.isAbsolute()) {
-            schemaFile = new File(solrLoader.getInstanceDir() + "conf"
-                                  + File.separator + dcore.getSchemaName());
-          }
-          if (schemaFile.exists()) {
-            String key = schemaFile.getAbsolutePath()
-              + ":"
-              + new SimpleDateFormat("yyyyMMddHHmmss", Locale.ROOT).format(new Date(
-                                                                                    schemaFile.lastModified()));
-            schema = indexSchemaCache.get(key);
-            if (schema == null) {
-              log.info("creating new schema object for core: " + dcore.name);
-              schema = new IndexSchema(config, dcore.getSchemaName(), null);
-              indexSchemaCache.put(key, schema);
-            } else {
-              log.info("re-using schema object for core: " + dcore.name);
-            }
-          }
-        } else {
-          // TODO: handle caching from ZooKeeper - perhaps using ZooKeepers versioning
-          // Don't like this cache though - how does it empty as last modified changes?
-        }
+        return createFromLocal(instanceDir, dcore);
       }
-      if(schema == null){
-        if(zkController != null) {
-          try {
-            schema = getSchemaFromZk(zkConfigName, dcore.getSchemaName(), config, solrLoader);
-          } catch (KeeperException e) {
-            log.error("", e);
-            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
-                                         "", e);
-          } catch (InterruptedException e) {
-            // Restore the interrupted status
-            Thread.currentThread().interrupt();
-            log.error("", e);
-            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
-                                         "", e);
-          }
-        } else {
-          schema = new IndexSchema(config, dcore.getSchemaName(), null);
-        }
-      }
-
-      SolrCore core = new SolrCore(dcore.getName(), null, config, schema, dcore);
-
-      if (zkController == null && core.getUpdateHandler().getUpdateLog() != null) {
-        // always kick off recovery if we are in standalone mode.
-        core.getUpdateHandler().getUpdateLog().recoverFromLog();
-      }
-
-      return core;
 
       // :TODO: Java7...
       // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
-    } catch (ParserConfigurationException e1) {
-      failure = e1;
-      throw e1;
-    } catch (IOException e2) {
-      failure = e2;
-      throw e2;
-    } catch (SAXException e3) {
-      failure = e3;
-      throw e3;
-    } catch (RuntimeException e4) {
-      failure = e4;
-      throw e4;
-    } finally {
-      if (null != failure) {
-        log.error("Unable to create core: " + name, failure);
-      }
-      synchronized (coreInitFailures) {
-        // remove first so insertion order is updated and newest is last
-        coreInitFailures.remove(name);
-        if (null != failure) {
-          coreInitFailures.put(name, failure);
-        }
-      }
+    } catch (Exception ex) {
+      throw recordAndThrow(name, "Unable to create core: " + name, ex);
     }
   }
 
@@ -899,6 +932,9 @@ public class CoreContainer
     synchronized (cores) {
       lst.addAll(this.cores.keySet());
     }
+    synchronized (swappableCores) {
+      lst.addAll(this.swappableCores.keySet());
+    }
     return lst;
   }
 
@@ -914,6 +950,14 @@ public class CoreContainer
         }
       }
     }
+    synchronized (swappableCores) {
+      for (Map.Entry<String,SolrCore> entry : swappableCores.entrySet()) {
+        if (core == entry.getValue()) {
+          lst.add(entry.getKey());
+        }
+      }
+    }
+
     return lst;
   }
 
@@ -951,11 +995,7 @@ public class CoreContainer
    * 
    * @param name the name of the SolrCore to reload
    */
-  public void reload(String name) throws ParserConfigurationException, IOException, SAXException {
-
-    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException
-
-    Exception failure = null;
+  public void reload(String name) {
     try {
 
       name= checkDefault(name);
@@ -1011,29 +1051,8 @@ public class CoreContainer
 
       // :TODO: Java7...
       // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
-    } catch (ParserConfigurationException e1) {
-      failure = e1;
-      throw e1;
-    } catch (IOException e2) {
-      failure = e2;
-      throw e2;
-    } catch (SAXException e3) {
-      failure = e3;
-      throw e3;
-    } catch (RuntimeException e4) {
-      failure = e4;
-      throw e4;
-    } finally {
-      if (null != failure) {
-        log.error("Unable to reload core: " + name, failure);
-      }
-      synchronized (coreInitFailures) {
-        // remove first so insertion order is updated and newest is last
-        coreInitFailures.remove(name);
-        if (null != failure) {
-          coreInitFailures.put(name, failure);
-        }
-      }
+    } catch (Exception ex) {
+      throw recordAndThrow(name, "Unable to reload core: " + name, ex);
     }
   }
 
@@ -1108,13 +1127,44 @@ public class CoreContainer
    * @return the core if found
    */
   public SolrCore getCore(String name) {
-    name= checkDefault(name);
-    synchronized(cores) {
-      SolrCore core = cores.get(name);
-      if (core != null)
-        core.open();  // increment the ref count while still synchronized
-      return core;
+    name = checkDefault(name);
+    // Do this in two phases since we don't want to lock access to the cores over a load.
+    SolrCore core;
+
+    synchronized (cores) {
+      core = cores.get(name);
+      if (core != null) {
+        core.open();
+        return core;
+      }
+    }
+
+    if (dynamicDescriptors.size() == 0) return null; // Nobody even tried to define any swappable cores, so we're done.
+
+    // Now look for already loaded swappable cores.
+    synchronized (swappableCores) {
+      core = swappableCores.get(name);
+      if (core != null) {
+        core.open();
+        return core;
+      }
+    }
+    CoreDescriptor desc =  dynamicDescriptors.get(name);
+    if (desc == null) { //Nope, no swappable core with this name
+      return null;
+    }
+    try {
+      core = create(desc); // This should throw an error if it fails.
+      core.open();
+      if (desc.isSwappable()) {
+        registerLazyCore(name, core, false);    // This is a swappable core
+      } else {
+        register(name, core, false); // This is a "permanent", although deferred-load core
+      }
+    } catch (Exception ex) {
+      throw recordAndThrow(name, "Unable to create core" + name, ex);
     }
+    return core;
   }
 
   // ---------------- Multicore self related methods ---------------
@@ -1215,6 +1265,10 @@ public class CoreContainer
     if (! (null == defaultCoreName || defaultCoreName.equals("")) ) {
       coresAttribs.put("defaultCoreName", defaultCoreName);
     }
+
+    if (swappableCacheSize != Integer.MAX_VALUE) {
+      coresAttribs.put("swappableCacheSize", Integer.toString(swappableCacheSize));
+    }
     
     addCoresAttrib(coresAttribs, "hostPort", this.hostPort, DEFAULT_HOST_PORT);
     addCoresAttrib(coresAttribs, "zkClientTimeout",
@@ -1222,7 +1276,8 @@ public class CoreContainer
         Integer.toString(DEFAULT_ZK_CLIENT_TIMEOUT));
     addCoresAttrib(coresAttribs, "hostContext", this.hostContext, DEFAULT_HOST_CONTEXT);
     addCoresAttrib(coresAttribs, "leaderVoteWait", this.leaderVoteWait, LEADER_VOTE_WAIT);
-    
+
+
     List<SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrCoreXMLDef>();
     
     synchronized (cores) {
@@ -1291,7 +1346,9 @@ public class CoreContainer
         
         String dataDir = dcore.dataDir;
         addCoreProperty(coreAttribs, coreNode, CORE_DATADIR, dataDir, null);
-        
+        addCoreProperty(coreAttribs, coreNode, CORE_SWAPPABLE, Boolean.toString(dcore.isSwappable()), null);
+        addCoreProperty(coreAttribs, coreNode, CORE_LOADONSTARTUP, Boolean.toString(dcore.isLoadOnStartup()), null);
+
         CloudDescriptor cd = dcore.getCloudDescriptor();
         String shard = null;
         String roles = null;
@@ -1416,19 +1473,33 @@ public class CoreContainer
   }
   
   private SolrConfig getSolrConfigFromZk(String zkConfigName, String solrConfigFileName,
-      SolrResourceLoader resourceLoader) throws IOException,
-      ParserConfigurationException, SAXException, KeeperException,
-      InterruptedException {
-    byte[] config = zkController.getConfigFileData(zkConfigName, solrConfigFileName);
-    InputSource is = new InputSource(new ByteArrayInputStream(config));
-    is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(solrConfigFileName));
-    SolrConfig cfg = solrConfigFileName == null ? new SolrConfig(
-        resourceLoader, SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(
-        resourceLoader, solrConfigFileName, is);
+      SolrResourceLoader resourceLoader)
+  {
+    SolrConfig cfg = null;
+    try {
+      byte[] config = zkController.getConfigFileData(zkConfigName, solrConfigFileName);
+      InputSource is = new InputSource(new ByteArrayInputStream(config));
+      is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(solrConfigFileName));
+      cfg = solrConfigFileName == null ? new SolrConfig(
+          resourceLoader, SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(
+          resourceLoader, solrConfigFileName, is);
+    } catch (Exception e) {
+      throw new SolrException(ErrorCode.SERVER_ERROR,
+          "getSolrConfigFromZK failed for " + zkConfigName + " " + solrConfigFileName, e);
+    }
 
     return cfg;
   }
-  
+
+  // Just to tidy up the code where it did this in-line.
+  private SolrException recordAndThrow(String name, String msg, Exception ex) {
+    synchronized (coreInitFailures) {
+      coreInitFailures.remove(name);
+      coreInitFailures.put(name, ex);
+    }
+    log.error(msg, ex);
+    return new SolrException(ErrorCode.SERVER_ERROR, msg, ex);
+  }
   private IndexSchema getSchemaFromZk(String zkConfigName, String schemaName,
       SolrConfig config, SolrResourceLoader resourceLoader)
       throws KeeperException, InterruptedException {
diff --git a/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java b/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
index 7b2f4a7..53fbc60 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
@@ -36,7 +36,10 @@ public class CoreDescriptor {
   protected String schemaName;
   private final CoreContainer coreContainer;
   private Properties coreProperties;
-  
+  private boolean loadOnStartup = true;
+  private boolean swappable = false;
+
+
   private CloudDescriptor cloudDesc;
 
   public CoreDescriptor(CoreContainer coreContainer, String name, String instanceDir) {
@@ -207,4 +210,19 @@ public class CoreDescriptor {
   public void setCloudDescriptor(CloudDescriptor cloudDesc) {
     this.cloudDesc = cloudDesc;
   }
+  public boolean isLoadOnStartup() {
+    return loadOnStartup;
+  }
+
+  public void setLoadOnStartup(boolean loadOnStartup) {
+    this.loadOnStartup = loadOnStartup;
+  }
+
+  public boolean isSwappable() {
+    return swappable;
+  }
+
+  public void setSwappable(boolean swappable) {
+    this.swappable = swappable;
+  }
 }
diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java
index 6659d9d..6fdf82b 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -308,7 +308,7 @@ public final class SolrCore implements SolrInfoMBean {
     this.name = v;
     this.logid = (v==null)?"":("["+v+"] ");
   }
-  
+
   public String getLogId()
   {
     return this.logid;
@@ -617,7 +617,31 @@ public final class SolrCore implements SolrInfoMBean {
   public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd) {
     this(name, dataDir, config, schema, cd, null, null);
   }
-  
+
+
+  /**
+   * Creates a new core that is to be loaded lazily. i.e. lazyLoad="true" in solr.xml
+   * @since solr 4.1
+   */
+  public SolrCore(String name, CoreDescriptor cd) {
+    this.setName(name);
+    coreDescriptor = cd;
+    this.schema = null;
+    this.dataDir = null;
+    this.solrConfig = null;
+    this.startTime = System.currentTimeMillis();
+    this.maxWarmingSearchers = 2;  // we don't have a config yet, just pick a number.
+    this.resourceLoader = null;
+    this.updateHandler = null;
+    this.isReloaded = true;
+    this.reqHandlers = null;
+    this.searchComponents = null;
+    this.updateProcessorChains = null;
+    this.infoRegistry = null;
+    this.codec = null;
+
+    solrCoreState = null;
+  }
   /**
    * Creates a new core and register it in the list of cores.
    * If a core with the same name already exists, it will be stopped and replaced by this one.
diff --git a/solr/core/src/test-files/solr/solr-lots-of-cores.xml b/solr/core/src/test-files/solr/solr-lots-of-cores.xml
new file mode 100644
index 0000000..2e27327
--- /dev/null
+++ b/solr/core/src/test-files/solr/solr-lots-of-cores.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+ All (relative) paths are relative to the installation path
+
+  persistent: Save changes made via the API to this file
+  sharedLib: path to a lib directory that will be shared across all cores
+-->
+<solr persistent="false">
+  <cores adminPath="/admin/cores" defaultCoreName="collectionLazy2" swappableCacheSize="4">
+    <core name="collection1" instanceDir="collection1" />
+    <core name="collectionLazy2" instanceDir="collection1" swappable="true" loadOnStartup="false"  />
+    <core name="collectionLazy3" instanceDir="collection1" swappable="on" loadOnStartup="false"/>
+    <core name="collectionLazy4" instanceDir="collection1" swappable="false" loadOnStartup="false"/>
+    <core name="collectionLazy5" instanceDir="collection1" swappable="false" loadOnStartup="true"/>
+    <core name="collectionLazy6" instanceDir="collection1" swappable="true" loadOnStartup="false" />
+    <core name="collectionLazy7" instanceDir="collection1" swappable="true" loadOnStartup="false" />
+    <core name="collectionLazy8" instanceDir="collection1" swappable="true" loadOnStartup="false" />
+    <core name="collectionLazy9" instanceDir="collection1" swappable="true" loadOnStartup="false" />
+  </cores>
+</solr>
\ No newline at end of file
diff --git a/solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java b/solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java
index 8fab323..781aea1 100644
--- a/solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/BasicZkTest.java
@@ -21,6 +21,7 @@ import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.LogMergePolicy;
 import org.apache.lucene.util.LuceneTestCase.Slow;
 import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
@@ -32,7 +33,6 @@ import org.apache.solr.util.RefCounted;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
-import org.xml.sax.SAXParseException;
 
 /**
  * This test is not fully functional - the port registered is illegal - 
@@ -148,19 +148,19 @@ public class BasicZkTest extends AbstractZkTestCase {
     assertU(delQ("id:[100 TO 110]"));
     assertU(commit());
     assertQ(request("id:[100 TO 110]"), "//*[@numFound='0']");
-    
-   
-    
+
+
+
     // SOLR-2651: test that reload still gets config files from zookeeper 
     zkController.getZkClient().setData("/configs/conf1/solrconfig.xml", new byte[0], true);
  
     // we set the solrconfig to nothing, so this reload should fail
     try {
-      SolrTestCaseJ4.ignoreException("SAXParseException");
+      SolrTestCaseJ4.ignoreException("SolrException");
       h.getCoreContainer().reload(h.getCore().getName());
       SolrTestCaseJ4.resetExceptionIgnores();
       fail("The reloaded SolrCore did not pick up configs from zookeeper");
-    } catch(SAXParseException e) {
+    } catch(SolrException e) {
       
     }
     
diff --git a/solr/core/src/test/org/apache/solr/core/CoreContainerCoreInitFailuresTest.java b/solr/core/src/test/org/apache/solr/core/CoreContainerCoreInitFailuresTest.java
index c2254c1..ca262ad 100644
--- a/solr/core/src/test/org/apache/solr/core/CoreContainerCoreInitFailuresTest.java
+++ b/solr/core/src/test/org/apache/solr/core/CoreContainerCoreInitFailuresTest.java
@@ -96,11 +96,9 @@ public class CoreContainerCoreInitFailuresTest extends SolrTestCaseJ4 {
       ignoreException(Pattern.quote("bogus_path"));
       cc.create(bogus);
       fail("bogus inst dir failed to trigger exception from create");
-    } catch (Exception e) {
-      // :TODO: should really tighten up the exceptions CoreContainer throws (ie: just SolrException)
-      
-      assertTrue("init exception doesn't mention bogus dir: " + e.getMessage(),
-                 0 < e.getMessage().indexOf("bogus_path"));
+    } catch (SolrException e) {
+      assertTrue("init exception doesn't mention bogus dir: " + e.getCause().getCause().getMessage(),
+                 0 < e.getCause().getCause().getMessage().indexOf("bogus_path"));
       
     }
     
@@ -115,8 +113,8 @@ public class CoreContainerCoreInitFailuresTest extends SolrTestCaseJ4 {
     assertEquals("wrong number of core failures", 1, failures.size());
     fail = failures.get("bogus");
     assertNotNull("null failure for test core", fail);
-    assertTrue("init failure doesn't mention problem: " + fail.getMessage(),
-               0 < fail.getMessage().indexOf("bogus_path"));
+    assertTrue("init failure doesn't mention problem: " + fail.getCause().getMessage(),
+               0 < fail.getCause().getMessage().indexOf("bogus_path"));
 
     // let the test end here, with some recorded failures, and let cleanUp()
     // verify that there is no problem shuting down CoreContainer with known 
@@ -197,11 +195,9 @@ public class CoreContainerCoreInitFailuresTest extends SolrTestCaseJ4 {
       ignoreException(Pattern.quote("bogus_path"));
       cc.create(bogus);
       fail("bogus inst dir failed to trigger exception from create");
-    } catch (Exception e) {
-      // :TODO: should really tighten up the exceptions CoreContainer throws (ie: just SolrException)
-      
-      assertTrue("init exception doesn't mention bogus dir: " + e.getMessage(),
-                 0 < e.getMessage().indexOf("bogus_path"));
+    } catch (SolrException e) {
+      assertTrue("init exception doesn't mention bogus dir: " + e.getCause().getCause().getMessage(),
+                 0 < e.getCause().getCause().getMessage().indexOf("bogus_path"));
       
     }
     
@@ -218,8 +214,8 @@ public class CoreContainerCoreInitFailuresTest extends SolrTestCaseJ4 {
     assertEquals("wrong number of core failures", 1, failures.size());
     fail = failures.get("bogus");
     assertNotNull("null failure for test core", fail);
-    assertTrue("init failure doesn't mention problem: " + fail.getMessage(),
-               0 < fail.getMessage().indexOf("bogus_path"));
+    assertTrue("init failure doesn't mention problem: " + fail.getCause().getMessage(),
+               0 < fail.getCause().getMessage().indexOf("bogus_path"));
 
 
     // -----
@@ -254,11 +250,9 @@ public class CoreContainerCoreInitFailuresTest extends SolrTestCaseJ4 {
       ignoreException(Pattern.quote("SAX"));
       cc.reload("col_bad");
       fail("corrupt solrconfig.xml failed to trigger exception from reload");
-    } catch (SAXParseException e) {
-      // :TODO: should really tighten up the exceptions CoreContainer throws (ie: just SolrException)
-      
-      assertTrue("reload exception doesn't refer to slrconfig.xml " + e.getSystemId(),
-                 0 < e.getSystemId().indexOf("solrconfig.xml"));
+    } catch (SolrException e) {
+      assertTrue("reload exception doesn't refer to prolog " + e.getCause().getMessage(),
+                 0 < e.getCause().getMessage().indexOf("prolog"));
       
     }
 
diff --git a/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java b/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
index da7843d..b1ffe3c 100644
--- a/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
+++ b/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
@@ -89,7 +89,7 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
     
     final CoreContainer cores = h.getCoreContainer();
     cores.setPersistent(true); // is this needed since we make explicit calls?
-    
+
     String instDir = null;
     {
       SolrCore template = null;
@@ -108,12 +108,12 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
     
     final File oneXml = new File(workDir, "1.solr.xml");
     cores.persistFile(oneXml);
-    
+
     assertXmlFile(oneXml, "/solr[@persistent='true']",
-        "/solr/cores[@defaultCoreName='collection1']",
-        "/solr/cores/core[@name='collection1' and @instanceDir='" + instDir
-            + "']", "1=count(/solr/cores/core)");
-    
+        "/solr/cores[@defaultCoreName='collection1' and not(@swappableCacheSize)]",
+        "/solr/cores/core[@name='collection1' and @instanceDir='" + instDir +
+        "' and @swappable='false' and @loadOnStartup='true' ]", "1=count(/solr/cores/core)");
+
     // create some new cores and sanity check the persistence
     
     final File dataXfile = new File(workDir, "dataX");
@@ -142,16 +142,18 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
       assertEquals("cores not added?", 3, cores.getCoreNames().size());
       
       final File twoXml = new File(workDir, "2.solr.xml");
+      cores.swappableCacheSize = 32;
+
       cores.persistFile(twoXml);
-      
+
       assertXmlFile(twoXml, "/solr[@persistent='true']",
-          "/solr/cores[@defaultCoreName='collection1']",
+          "/solr/cores[@defaultCoreName='collection1' and @swappableCacheSize='32']",
           "/solr/cores/core[@name='collection1' and @instanceDir='" + instDir
               + "']", "/solr/cores/core[@name='X' and @instanceDir='" + instDir
               + "' and @dataDir='" + dataX + "']",
           "/solr/cores/core[@name='Y' and @instanceDir='" + instY + "']",
           "3=count(/solr/cores/core)");
-      
+
       // delete a core, check persistence again
       assertNotNull("removing X returned null", cores.remove("X"));
       
@@ -200,7 +202,7 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
       throw new RuntimeException("XPath is invalid", e2);
     }
   }
-  
+
   public void testNoCores() throws IOException, ParserConfigurationException, SAXException {
     //create solrHome
     File solrHomeDirectory = new File(TEMP_DIR, this.getClass().getName()
diff --git a/solr/core/src/test/org/apache/solr/core/TestLazyCores.java b/solr/core/src/test/org/apache/solr/core/TestLazyCores.java
new file mode 100644
index 0000000..8a2d176
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/core/TestLazyCores.java
@@ -0,0 +1,260 @@
+package org.apache.solr.core;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.update.AddUpdateCommand;
+import org.apache.solr.update.CommitUpdateCommand;
+import org.apache.solr.update.UpdateHandler;
+import org.apache.solr.util.RefCounted;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public class TestLazyCores extends SolrTestCaseJ4 {
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore("solrconfig.xml", "schema.xml");
+  }
+
+  private CoreContainer cores;
+
+  @Before
+  public void before() throws IOException, SAXException, ParserConfigurationException {
+    String solrHome;
+    solrHome = SolrResourceLoader.locateSolrHome();
+    File fconf = new File(solrHome, "solr-lots-of-cores.xml");
+
+    cores = new CoreContainer(solrHome);
+    cores.load(solrHome, fconf);
+    cores.setPersistent(false);
+  }
+  @Test
+  public void testLazyLoad() {
+    try {
+      // NOTE: the way this works, this should not assert, however if it's put after the getCore on this collection,
+      // that will cause the core to be loaded and this test will fail.
+
+      Collection<String> names = cores.getCoreNames();
+      for (String name : names) {
+        assertFalse("collectionLazy2".equals(name));
+      }
+
+      SolrCore core1 = cores.getCore("collection1");
+      CoreDescriptor cont = core1.getCoreDescriptor();
+      assertFalse("core1 should not be swappable", core1.getCoreDescriptor().isSwappable());
+      assertTrue("core1 should  be loadable", core1.getCoreDescriptor().isLoadOnStartup());
+      assertNotNull(core1.getSolrConfig());
+
+      SolrCore core2 = cores.getCore("collectionLazy2");
+      assertTrue("core2 should not be swappable", core2.getCoreDescriptor().isSwappable());
+      assertFalse("core2 should not be loadable", core2.getCoreDescriptor().isLoadOnStartup());
+
+      SolrCore core3 = cores.getCore("collectionLazy3");
+      assertTrue("core3 should not be swappable", core3.getCoreDescriptor().isSwappable());
+      assertFalse("core3 should not be loadable", core3.getCoreDescriptor().isLoadOnStartup());
+
+      SolrCore core4 = cores.getCore("collectionLazy4");
+      assertFalse("core4 should not be swappable", core4.getCoreDescriptor().isSwappable());
+      assertFalse("core4 should not be loadable", core4.getCoreDescriptor().isLoadOnStartup());
+
+      SolrCore core5 = cores.getCore("collectionLazy5");
+      assertFalse("core5 should not be swappable", core5.getCoreDescriptor().isSwappable());
+      assertTrue("core5 should  be loadable", core5.getCoreDescriptor().isLoadOnStartup());
+
+      core1.close();
+      core2.close();
+      core3.close();
+      core4.close();
+      core5.close();
+    } finally {
+      cores.shutdown();
+    }
+  }
+
+  // This is a little weak. I'm not sure how to test that lazy core2 is loaded automagically. The getCore
+  // will, of course, load it.
+  @Test
+  public void testLazySearch() throws Exception {
+    try {
+      // Make sure Lazy2 isn't loaded.
+      checkNotInCores("collectionLazy2");
+      SolrCore core2 = cores.getCore("collectionLazy2");
+
+      addLazy(core2, "id", "0");
+      addLazy(core2, "id", "1", "v_t", "Hello Dude");
+      addLazy(core2, "id", "2", "v_t", "Hello Yonik");
+      addLazy(core2, "id", "3", "v_s", "{!literal}");
+      addLazy(core2, "id", "4", "v_s", "other stuff");
+      addLazy(core2, "id", "5", "v_f", "3.14159");
+      addLazy(core2, "id", "6", "v_f", "8983");
+
+      SolrQueryRequest req = makeReq(core2);
+      CommitUpdateCommand cmtCmd = new CommitUpdateCommand(req, false);
+      core2.getUpdateHandler().commit(cmtCmd);
+
+      RefCounted<SolrIndexSearcher> holder = core2.getSearcher();
+      SolrIndexSearcher searcher = holder.get();
+
+      // Just get a couple of searches to work!
+      assertQ("test prefix query",
+          makeReq(core2, "q", "{!prefix f=v_t}hel")
+          , "//result[@numFound='2']"
+      );
+
+      assertQ("test raw query",
+          makeReq(core2, "q", "{!raw f=v_t}hello")
+          , "//result[@numFound='2']"
+      );
+
+      // Now just insure that the normal searching on "collection1" finds _0_ on the same query that found _2_ above.
+      // Use of makeReq above and req below is tricky, very tricky.
+      assertQ("test raw query",
+          req("q", "{!raw f=v_t}hello")
+          , "//result[@numFound='0']"
+      );
+
+      // no analysis is done, so these should match nothing
+      assertQ("test raw query",
+          makeReq(core2, "q", "{!raw f=v_t}Hello")
+          , "//result[@numFound='0']"
+      );
+      assertQ("test raw query",
+          makeReq(core2, "q", "{!raw f=v_f}1.5")
+          , "//result[@numFound='0']"
+      );
+
+      checkInCores("collectionLazy2");
+
+      searcher.close();
+      core2.close();
+    } finally {
+      cores.shutdown();
+    }
+  }
+  @Test
+  public void testCachingLimit() {
+    try {
+      // NOTE: the way this works, this should not assert, however if it's put after the getCore on this collection,
+      // that will cause the core to be loaded and this test will fail.
+      Collection<String> names = cores.getCoreNames();
+
+      // By putting these in non-alpha order, we're also checking that we're  not just seeing an artifact.
+      SolrCore core1 = cores.getCore("collection1");
+      SolrCore core2 = cores.getCore("collectionLazy3");
+      SolrCore core4 = cores.getCore("collectionLazy4");
+      SolrCore core3 = cores.getCore("collectionLazy2");
+      SolrCore core5 = cores.getCore("collectionLazy5");
+
+
+      checkInCores("collection1", "collectionLazy2", "collectionLazy3", "collectionLazy4", "collectionLazy5");
+      checkNotInCores("collectionLazy6", "collectionLazy7", "collectionLazy8", "collectionLazy9");
+
+      // map should be full up, add one more and verify
+      SolrCore core6 = cores.getCore("collectionLazy6");
+      checkInCores("collection1", "collectionLazy2", "collectionLazy3", "collectionLazy4", "collectionLazy5", "collectionLazy6");
+      checkNotInCores("collectionLazy7", "collectionLazy8", "collectionLazy9");
+
+      SolrCore core7 = cores.getCore("collectionLazy7");
+      checkInCores("collection1", "collectionLazy2", "collectionLazy3", "collectionLazy4", "collectionLazy5", "collectionLazy6", "collectionLazy7");
+      checkNotInCores("collectionLazy8", "collectionLazy9");
+      SolrCore core8 = cores.getCore("collectionLazy8");
+      checkInCores("collection1", "collectionLazy2", "collectionLazy4", "collectionLazy5", "collectionLazy6", "collectionLazy7", "collectionLazy8");
+      checkNotInCores("collectionLazy3", "collectionLazy9");
+
+      SolrCore core9 = cores.getCore("collectionLazy9");
+      checkInCores("collection1", "collectionLazy4", "collectionLazy5", "collectionLazy6", "collectionLazy7", "collectionLazy8", "collectionLazy9");
+      checkNotInCores( "collectionLazy2","collectionLazy3");
+
+
+      // Note decrementing the count when the core is removed from the lazyCores list is appropriate, since the
+      // refcount is 1 when constructed. anyone _else_ who's opened up one has to close it.
+      core1.close();
+      core2.close();
+      core3.close();
+      core4.close();
+      core5.close();
+      core6.close();
+      core7.close();
+      core8.close();
+      core9.close();
+    } finally {
+      cores.shutdown();
+    }
+  }
+
+  private void checkNotInCores(String... nameCheck) {
+    Collection<String> names = cores.getCoreNames();
+    for (String name : nameCheck) {
+      assertFalse("core " + name + " was found in the list of cores", names.contains(name));
+    }
+  }
+
+  private void checkInCores(String... nameCheck) {
+    Collection<String> names = cores.getCoreNames();
+    for (String name : nameCheck) {
+      assertTrue("core " + name + " was not found in the list of cores", names.contains(name));
+    }
+  }
+
+
+  private void addLazy(SolrCore core, String... fieldValues) throws IOException {
+    UpdateHandler updater = core.getUpdateHandler();
+    SolrQueryRequest req = makeReq(core);
+    AddUpdateCommand cmd = new AddUpdateCommand(req);
+    if ((fieldValues.length % 2) != 0) {
+      throw new RuntimeException("The length of the string array (query arguments) needs to be even");
+    }
+    cmd.solrDoc = new SolrInputDocument();
+    for (int idx = 0; idx < fieldValues.length; idx += 2) {
+      cmd.solrDoc.addField(fieldValues[idx], fieldValues[idx + 1]);
+    }
+
+    updater.addDoc(cmd);
+  }
+
+  private LocalSolrQueryRequest makeReq(SolrCore core, String... q) {
+    if (q.length == 1) {
+      return new LocalSolrQueryRequest(core,
+          q[0], null, 0, 20, new HashMap<String, String>());
+    }
+    if (q.length % 2 != 0) {
+      throw new RuntimeException("The length of the string array (query arguments) needs to be even");
+    }
+    Map.Entry<String, String>[] entries = new NamedList.NamedListEntry[q.length / 2];
+    for (int i = 0; i < q.length; i += 2) {
+      entries[i / 2] = new NamedList.NamedListEntry<String>(q[i], q[i + 1]);
+    }
+    return new LocalSolrQueryRequest(core, new NamedList(entries));
+  }
+}
diff --git a/solr/core/src/test/org/apache/solr/handler/admin/CoreAdminHandlerTest.java b/solr/core/src/test/org/apache/solr/handler/admin/CoreAdminHandlerTest.java
index a2a184a..2e8a617 100644
--- a/solr/core/src/test/org/apache/solr/handler/admin/CoreAdminHandlerTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/admin/CoreAdminHandlerTest.java
@@ -111,10 +111,10 @@ public class CoreAdminHandlerTest extends SolrTestCaseJ4 {
       fail("bogus collection created ok");
     } catch (SolrException e) {
       // :NOOP:
-      // :TODO: CoreAdminHandler's exception messages are terrible, otherwise we could asert something useful here
+      // :TODO: CoreAdminHandler's exception messages are terrible, otherwise we could assert something useful here
     }
 
-    // check specificly for status of the failed core name
+    // check specifically for status of the failed core name
     resp = new SolrQueryResponse();
     admin.handleRequestBody
       (req(CoreAdminParams.ACTION, 
@@ -132,8 +132,8 @@ public class CoreAdminHandlerTest extends SolrTestCaseJ4 {
     assertEquals("wrong number of core failures", 1, failures.size());
     Exception fail = failures.get("bogus_dir_core");
     assertNotNull("null failure for test core", fail);
-    assertTrue("init failure doesn't mention problem: " + fail.getMessage(),
-               0 < fail.getMessage().indexOf("dir_does_not_exist"));
+    assertTrue("init failure doesn't mention problem: " + fail.getCause().getMessage(),
+               0 < fail.getCause().getMessage().indexOf("dir_does_not_exist"));
 
     assertEquals("bogus_dir_core status isn't empty",
                  0, ((NamedList)status.get("bogus_dir_core")).size());

