GitDiffStart: de495a3c0daef9b55f8d3288ffe3e8f6d7500342 | Thu Jan 19 17:16:25 2012 +0000
diff --git a/lucene/src/java/org/apache/lucene/codecs/Codec.java b/lucene/src/java/org/apache/lucene/codecs/Codec.java
index 6d5514a..5c13446 100644
--- a/lucene/src/java/org/apache/lucene/codecs/Codec.java
+++ b/lucene/src/java/org/apache/lucene/codecs/Codec.java
@@ -75,6 +75,9 @@ public abstract class Codec implements NamedSPILoader.NamedSPI {
   /** Encodes/decodes document normalization values */
   public abstract NormsFormat normsFormat();
   
+  /** Encodes/decodes live docs */
+  public abstract LiveDocsFormat liveDocsFormat();
+  
   /** looks up a codec by name */
   public static Codec forName(String name) {
     return loader.lookup(name);
diff --git a/lucene/src/java/org/apache/lucene/codecs/LiveDocsFormat.java b/lucene/src/java/org/apache/lucene/codecs/LiveDocsFormat.java
new file mode 100644
index 0000000..e3e5e46
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/codecs/LiveDocsFormat.java
@@ -0,0 +1,34 @@
+package org.apache.lucene.codecs;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.MutableBits;
+
+public abstract class LiveDocsFormat {
+  public abstract MutableBits newLiveDocs(int size) throws IOException;
+  public abstract Bits readLiveDocs(Directory dir, SegmentInfo info, IOContext context) throws IOException;
+  public abstract void writeLiveDocs(MutableBits bits, Directory dir, SegmentInfo info, IOContext context) throws IOException;
+  public abstract void files(Directory dir, SegmentInfo info, Set<String> files) throws IOException;
+}
diff --git a/lucene/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java b/lucene/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
index d5fd741..f338594 100644
--- a/lucene/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
+++ b/lucene/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.appending;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfosFormat;
@@ -28,6 +29,7 @@ import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40Codec;
 import org.apache.lucene.codecs.lucene40.Lucene40DocValuesFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40NormsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40TermVectorsFormat;
@@ -50,6 +52,7 @@ public class AppendingCodec extends Codec {
   private final TermVectorsFormat vectors = new Lucene40TermVectorsFormat();
   private final DocValuesFormat docValues = new Lucene40DocValuesFormat();
   private final NormsFormat norms = new Lucene40NormsFormat();
+  private final LiveDocsFormat liveDocs = new Lucene40LiveDocsFormat();
   
   @Override
   public PostingsFormat postingsFormat() {
@@ -85,4 +88,9 @@ public class AppendingCodec extends Codec {
   public NormsFormat normsFormat() {
     return norms;
   }
+  
+  @Override
+  public LiveDocsFormat liveDocsFormat() {
+    return liveDocs;
+  }
 }
diff --git a/lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java b/lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
index 7d196be..beaf194 100644
--- a/lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
+++ b/lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
@@ -23,6 +23,7 @@ import java.util.Set;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PerDocConsumer;
 import org.apache.lucene.codecs.PerDocProducer;
@@ -30,6 +31,7 @@ import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfosFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsFormat;
 import org.apache.lucene.index.PerDocWriteState;
 import org.apache.lucene.index.SegmentInfo;
@@ -57,6 +59,9 @@ public class Lucene3xCodec extends Codec {
   
   private final NormsFormat normsFormat = new Lucene3xNormsFormat();
   
+  // TODO: this should really be a different impl
+  private final LiveDocsFormat liveDocsFormat = new Lucene40LiveDocsFormat();
+  
   // 3.x doesn't support docvalues
   private final DocValuesFormat docValuesFormat = new DocValuesFormat() {
     @Override
@@ -107,4 +112,9 @@ public class Lucene3xCodec extends Codec {
   public NormsFormat normsFormat() {
     return normsFormat;
   }
+  
+  @Override
+  public LiveDocsFormat liveDocsFormat() {
+    return liveDocsFormat;
+  }
 }
diff --git a/lucene/src/java/org/apache/lucene/codecs/lucene40/BitVector.java b/lucene/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
new file mode 100644
index 0000000..7b4aff0
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
@@ -0,0 +1,418 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.store.CompoundFileDirectory;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.CodecUtil;
+import org.apache.lucene.util.MutableBits;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+ *  java.util.BitSet, but also includes the following:
+ *  <ul>
+ *  <li>a count() method, which efficiently computes the number of one bits;</li>
+ *  <li>optimized read from and write to disk;</li>
+ *  <li>inlinable get() method;</li>
+ *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+ *  </ul>
+ *
+ *  @lucene.internal
+ */
+public final class BitVector implements Cloneable, MutableBits {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+  private int version;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector(int n) {
+    size = n;
+    bits = new byte[getNumBytes(size)];
+    count = 0;
+  }
+
+  BitVector(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  private int getNumBytes(int size) {
+    int bytesLength = size >>> 3;
+    if ((size & 7) != 0) {
+      bytesLength++;
+    }
+    return bytesLength;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector clone = new BitVector(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1) {
+        count++;
+        assert count <= size;
+      }
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  public final boolean getAndClear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) == 0) {
+      return false;
+    } else {
+      bits[pos] &= ~flag;
+      if (count != -1) {
+        count--;
+        assert count >= 0;
+      }
+      return true;
+    }
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  @Override
+  public int length() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++) {
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      }
+      count = c;
+    }
+    assert count <= size: "count=" + count + " size=" + size;
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++) {
+      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+    }
+    return c;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+  private static String CODEC = "BitVector";
+
+  // Version before version tracking was added:
+  public final static int VERSION_PRE = -1;
+
+  // First version:
+  public final static int VERSION_START = 0;
+
+  // Changed DGaps to encode gaps between cleared bits, not
+  // set:
+  public final static int VERSION_DGAPS_CLEARED = 1;
+
+  // Increment version to change it:
+  public final static int VERSION_CURRENT = VERSION_DGAPS_CLEARED;
+
+  public int getVersion() {
+    return version;
+  }
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector(Directory, String, IOContext)}.  */
+  public final void write(Directory d, String name, IOContext context) throws IOException {
+    assert !(d instanceof CompoundFileDirectory);
+    IndexOutput output = d.createOutput(name, context);
+    try {
+      output.writeInt(-2);
+      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
+      if (isSparse()) { 
+        // sparse bit-set more efficiently saved as d-gaps.
+        writeClearedDgaps(output);
+      } else {
+        writeBits(output);
+      }
+      assert verifyCount();
+    } finally {
+      output.close();
+    }
+  }
+
+  /** Invert all bits */
+  public void invertAll() {
+    if (count != -1) {
+      count = size - count;
+    }
+    if (bits.length > 0) {
+      for(int idx=0;idx<bits.length;idx++) {
+        bits[idx] = (byte) (~bits[idx]);
+      }
+      clearUnusedBits();
+    }
+  }
+
+  private void clearUnusedBits() {
+    // Take care not to invert the "unused" bits in the
+    // last byte:
+    if (bits.length > 0) {
+      final int lastNBits = size & 7;
+      if (lastNBits != 0) {
+        final int mask = (1 << lastNBits)-1;
+        bits[bits.length-1] &= mask;
+      }
+    }
+  }
+
+  /** Set all bits */
+  public void setAll() {
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    count = size;
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeClearedDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int numCleared = size()-count();
+    for (int i=0; i<bits.length && numCleared>0; i++) {
+      if (bits[i] != (byte) 0xff) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        numCleared -= (8-BYTE_COUNTS[bits[i] & 0xFF]);
+        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+
+    final int clearedCount = size() - count();
+    if (clearedCount == 0) {
+      return true;
+    }
+
+    final int avgGapLength = bits.length / clearedCount;
+
+    // expected number of bytes for vInt encoding of each gap
+    final int expectedDGapBytes;
+    if (avgGapLength <= (1<< 7)) {
+      expectedDGapBytes = 1;
+    } else if (avgGapLength <= (1<<14)) {
+      expectedDGapBytes = 2;
+    } else if (avgGapLength <= (1<<21)) {
+      expectedDGapBytes = 3;
+    } else if (avgGapLength <= (1<<28)) {
+      expectedDGapBytes = 4;
+    } else {
+      expectedDGapBytes = 5;
+    }
+
+    // +1 because we write the byte itself that contains the
+    // set bit
+    final int bytesPerSetBit = expectedDGapBytes + 1;
+    
+    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
+    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
+
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    final long factor = 10;  
+    return factor * expectedBits < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector(Directory d, String name, IOContext context) throws IOException {
+    IndexInput input = d.openInput(name, context);
+
+    try {
+      final int firstInt = input.readInt();
+
+      if (firstInt == -2) {
+        // New format, with full header & version:
+        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
+        size = input.readInt();
+      } else {
+        version = VERSION_PRE;
+        size = firstInt;
+      }
+      if (size == -1) {
+        if (version >= VERSION_DGAPS_CLEARED) {
+          readClearedDgaps(input);
+        } else {
+          readSetDgaps(input);
+        }
+      } else {
+        readBits(input);
+      }
+
+      if (version < VERSION_DGAPS_CLEARED) {
+        invertAll();
+      }
+
+      assert verifyCount();
+    } finally {
+      input.close();
+    }
+  }
+
+  // asserts only
+  private boolean verifyCount() {
+    assert count != -1;
+    final int countSav = count;
+    count = -1;
+    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
+    return true;
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readSetDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+      assert n >= 0;
+    }          
+  }
+
+  /** read as a d-gaps cleared bits list */ 
+  private void readClearedDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    int last=0;
+    int numCleared = size()-count();
+    while (numCleared>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      numCleared -= 8-BYTE_COUNTS[bits[last] & 0xFF];
+      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
+    }
+  }
+}
diff --git a/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java b/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
index b0e9626..8b2279d 100644
--- a/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
+++ b/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.lucene40;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfosFormat;
@@ -42,6 +43,8 @@ public class Lucene40Codec extends Codec {
   private final DocValuesFormat docValuesFormat = new Lucene40DocValuesFormat();
   private final SegmentInfosFormat infosFormat = new Lucene40SegmentInfosFormat();
   private final NormsFormat normsFormat = new Lucene40NormsFormat();
+  private final LiveDocsFormat liveDocsFormat = new Lucene40LiveDocsFormat();
+  
   private final PostingsFormat postingsFormat = new PerFieldPostingsFormat() {
     @Override
     public PostingsFormat getPostingsFormatForField(String field) {
@@ -87,6 +90,11 @@ public class Lucene40Codec extends Codec {
   public NormsFormat normsFormat() {
     return normsFormat;
   }
+  
+  @Override
+  public LiveDocsFormat liveDocsFormat() {
+    return liveDocsFormat;
+  }
 
   /** Returns the postings format that should be used for writing 
    *  new segments of <code>field</code>.
diff --git a/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java b/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
new file mode 100644
index 0000000..768d3d7
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
@@ -0,0 +1,42 @@
+package org.apache.lucene.codecs.lucene40;
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.MutableBits;
+
+public class Lucene40LiveDocsFormat extends LiveDocsFormat {
+
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    BitVector bitVector = new BitVector(size);
+    bitVector.invertAll();
+    return bitVector;
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentInfo info, IOContext context) throws IOException {
+    // nocommit: compute filename here
+    return new BitVector(dir, info.getDelFileName(), context);
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentInfo info, IOContext context) throws IOException {
+    // nocommit: compute filename here
+    // nocommit: this api is ugly...
+    ((BitVector)bits).write(dir, info.getDelFileName(), context);
+  }
+
+  @Override
+  public void files(Directory dir, SegmentInfo info, Set<String> files) throws IOException {
+    // nocommit: compute filename here
+    if (info.hasDeletions()) {
+      files.add(info.getDelFileName());
+    }
+  }
+}
diff --git a/lucene/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java b/lucene/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
index e6a0867..b407595 100644
--- a/lucene/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
+++ b/lucene/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
@@ -20,12 +20,14 @@ package org.apache.lucene.codecs.simpletext;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfosFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40DocValuesFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 
 /**
  * plain text index format.
@@ -43,6 +45,8 @@ public final class SimpleTextCodec extends Codec {
   private final DocValuesFormat docValues = new Lucene40DocValuesFormat();
   // TODO: need a plain-text impl (using the above)
   private final NormsFormat normsFormat = new SimpleTextNormsFormat();
+  // TODO: need a plain-text impl
+  private final LiveDocsFormat liveDocs = new Lucene40LiveDocsFormat();
   
   public SimpleTextCodec() {
     super("SimpleText");
@@ -82,4 +86,9 @@ public final class SimpleTextCodec extends Codec {
   public NormsFormat normsFormat() {
     return normsFormat;
   }
+  
+  @Override
+  public LiveDocsFormat liveDocsFormat() {
+    return liveDocs;
+  }
 }
diff --git a/lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java b/lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
index f279de0..f4b5b9c 100644
--- a/lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
+++ b/lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
@@ -25,12 +25,12 @@ import java.text.NumberFormat;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.index.DocumentsWriterDeleteQueue.DeleteSlice;
 import org.apache.lucene.search.similarities.SimilarityProvider;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FlushInfo;
 import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.Counter;
 import org.apache.lucene.util.ByteBlockPool.Allocator;
 import org.apache.lucene.util.ByteBlockPool.DirectTrackingAllocator;
diff --git a/lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java b/lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
index 30a8028..802d11f 100644
--- a/lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
+++ b/lucene/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
@@ -27,8 +27,8 @@ import org.apache.lucene.codecs.FieldsConsumer;
 import org.apache.lucene.codecs.PostingsConsumer;
 import org.apache.lucene.codecs.TermStats;
 import org.apache.lucene.codecs.TermsConsumer;
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.RamUsageEstimator;
diff --git a/lucene/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/src/java/org/apache/lucene/index/IndexWriter.java
index 51d7ff8..6d6ec31 100644
--- a/lucene/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/src/java/org/apache/lucene/index/IndexWriter.java
@@ -34,6 +34,7 @@ import java.util.regex.Pattern;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.index.DocumentsWriterPerThread.FlushedSegment;
 import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
@@ -48,7 +49,6 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.Lock;
 import org.apache.lucene.store.LockObtainFailedException;
 import org.apache.lucene.store.MergeInfo;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
diff --git a/lucene/src/java/org/apache/lucene/index/MergePolicy.java b/lucene/src/java/org/apache/lucene/index/MergePolicy.java
index 728a672..58d7f05 100644
--- a/lucene/src/java/org/apache/lucene/index/MergePolicy.java
+++ b/lucene/src/java/org/apache/lucene/index/MergePolicy.java
@@ -22,9 +22,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.MergeInfo;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.SetOnce.AlreadySetException;
 import org.apache.lucene.util.SetOnce;
 
diff --git a/lucene/src/java/org/apache/lucene/index/SegmentReader.java b/lucene/src/java/org/apache/lucene/index/SegmentReader.java
index 7bda25b..0962e56 100644
--- a/lucene/src/java/org/apache/lucene/index/SegmentReader.java
+++ b/lucene/src/java/org/apache/lucene/index/SegmentReader.java
@@ -23,9 +23,9 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.codecs.PerDocProducer;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.TermVectorsReader;
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.search.FieldCache; // javadocs
 import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.Bits;
 
 /**
@@ -36,7 +36,7 @@ public final class SegmentReader extends IndexReader {
   private final SegmentInfo si;
   private final ReaderContext readerContext = new AtomicReaderContext(this);
   
-  private final BitVector liveDocs;
+  private final Bits liveDocs;
 
   // Normally set to si.docCount - si.delDocCount, unless we
   // were created as an NRT reader from IW, in which case IW
@@ -56,7 +56,7 @@ public final class SegmentReader extends IndexReader {
     try {
       if (si.hasDeletions()) {
         // NOTE: the bitvector is stored using the regular directory, not cfs
-        liveDocs = new BitVector(directory(), si.getDelFileName(), new IOContext(IOContext.READ, true));
+        liveDocs = si.getCodec().liveDocsFormat().readLiveDocs(directory(), si, new IOContext(IOContext.READ, true));
       } else {
         assert si.getDelCount() == 0;
         liveDocs = null;
@@ -124,7 +124,9 @@ public final class SegmentReader extends IndexReader {
     return liveDocs;
   }
 
+  // nocommit
   private boolean checkLiveCounts(boolean isNRT) throws IOException {
+    BitVector liveDocs = (BitVector) this.liveDocs;
     if (liveDocs != null) {
       if (liveDocs.size() != si.docCount) {
         throw new CorruptIndexException("document count mismatch: deleted docs count " + liveDocs.size() + " vs segment doc count " + si.docCount + " segment=" + si.name);
diff --git a/lucene/src/java/org/apache/lucene/index/SegmentWriteState.java b/lucene/src/java/org/apache/lucene/index/SegmentWriteState.java
index 5898ca5..358124c 100644
--- a/lucene/src/java/org/apache/lucene/index/SegmentWriteState.java
+++ b/lucene/src/java/org/apache/lucene/index/SegmentWriteState.java
@@ -18,9 +18,9 @@ package org.apache.lucene.index;
  */
 
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.lucene40.BitVector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.InfoStream;
 
 /**
diff --git a/lucene/src/java/org/apache/lucene/util/BitVector.java b/lucene/src/java/org/apache/lucene/util/BitVector.java
deleted file mode 100644
index 39f749d..0000000
--- a/lucene/src/java/org/apache/lucene/util/BitVector.java
+++ /dev/null
@@ -1,416 +0,0 @@
-package org.apache.lucene.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.store.CompoundFileDirectory;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-
-/** Optimized implementation of a vector of bits.  This is more-or-less like
- *  java.util.BitSet, but also includes the following:
- *  <ul>
- *  <li>a count() method, which efficiently computes the number of one bits;</li>
- *  <li>optimized read from and write to disk;</li>
- *  <li>inlinable get() method;</li>
- *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
- *  </ul>
- *
- *  @lucene.internal
- */
-public final class BitVector implements Cloneable, Bits {
-
-  private byte[] bits;
-  private int size;
-  private int count;
-  private int version;
-
-  /** Constructs a vector capable of holding <code>n</code> bits. */
-  public BitVector(int n) {
-    size = n;
-    bits = new byte[getNumBytes(size)];
-    count = 0;
-  }
-
-  BitVector(byte[] bits, int size) {
-    this.bits = bits;
-    this.size = size;
-    count = -1;
-  }
-  
-  private int getNumBytes(int size) {
-    int bytesLength = size >>> 3;
-    if ((size & 7) != 0) {
-      bytesLength++;
-    }
-    return bytesLength;
-  }
-  
-  @Override
-  public Object clone() {
-    byte[] copyBits = new byte[bits.length];
-    System.arraycopy(bits, 0, copyBits, 0, bits.length);
-    BitVector clone = new BitVector(copyBits, size);
-    clone.count = count;
-    return clone;
-  }
-  
-  /** Sets the value of <code>bit</code> to one. */
-  public final void set(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    bits[bit >> 3] |= 1 << (bit & 7);
-    count = -1;
-  }
-
-  /** Sets the value of <code>bit</code> to true, and
-   *  returns true if bit was already set */
-  public final boolean getAndSet(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) != 0)
-      return true;
-    else {
-      bits[pos] = (byte) (v | flag);
-      if (count != -1) {
-        count++;
-        assert count <= size;
-      }
-      return false;
-    }
-  }
-
-  /** Sets the value of <code>bit</code> to zero. */
-  public final void clear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    bits[bit >> 3] &= ~(1 << (bit & 7));
-    count = -1;
-  }
-
-  public final boolean getAndClear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) == 0) {
-      return false;
-    } else {
-      bits[pos] &= ~flag;
-      if (count != -1) {
-        count--;
-        assert count >= 0;
-      }
-      return true;
-    }
-  }
-
-  /** Returns <code>true</code> if <code>bit</code> is one and
-    <code>false</code> if it is zero. */
-  public final boolean get(int bit) {
-    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
-    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
-  }
-
-  /** Returns the number of bits in this vector.  This is also one greater than
-    the number of the largest valid bit number. */
-  public final int size() {
-    return size;
-  }
-
-  @Override
-  public int length() {
-    return size;
-  }
-
-  /** Returns the total number of one bits in this vector.  This is efficiently
-    computed and cached, so that, if the vector is not changed, no
-    recomputation is done for repeated calls. */
-  public final int count() {
-    // if the vector has been modified
-    if (count == -1) {
-      int c = 0;
-      int end = bits.length;
-      for (int i = 0; i < end; i++) {
-        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
-      }
-      count = c;
-    }
-    assert count <= size: "count=" + count + " size=" + size;
-    return count;
-  }
-
-  /** For testing */
-  public final int getRecomputedCount() {
-    int c = 0;
-    int end = bits.length;
-    for (int i = 0; i < end; i++) {
-      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
-    }
-    return c;
-  }
-
-  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
-    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
-    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
-    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
-    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
-    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
-    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
-    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
-    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
-  };
-
-  private static String CODEC = "BitVector";
-
-  // Version before version tracking was added:
-  public final static int VERSION_PRE = -1;
-
-  // First version:
-  public final static int VERSION_START = 0;
-
-  // Changed DGaps to encode gaps between cleared bits, not
-  // set:
-  public final static int VERSION_DGAPS_CLEARED = 1;
-
-  // Increment version to change it:
-  public final static int VERSION_CURRENT = VERSION_DGAPS_CLEARED;
-
-  public int getVersion() {
-    return version;
-  }
-
-  /** Writes this vector to the file <code>name</code> in Directory
-    <code>d</code>, in a format that can be read by the constructor {@link
-    #BitVector(Directory, String, IOContext)}.  */
-  public final void write(Directory d, String name, IOContext context) throws IOException {
-    assert !(d instanceof CompoundFileDirectory);
-    IndexOutput output = d.createOutput(name, context);
-    try {
-      output.writeInt(-2);
-      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
-      if (isSparse()) { 
-        // sparse bit-set more efficiently saved as d-gaps.
-        writeClearedDgaps(output);
-      } else {
-        writeBits(output);
-      }
-      assert verifyCount();
-    } finally {
-      output.close();
-    }
-  }
-
-  /** Invert all bits */
-  public void invertAll() {
-    if (count != -1) {
-      count = size - count;
-    }
-    if (bits.length > 0) {
-      for(int idx=0;idx<bits.length;idx++) {
-        bits[idx] = (byte) (~bits[idx]);
-      }
-      clearUnusedBits();
-    }
-  }
-
-  private void clearUnusedBits() {
-    // Take care not to invert the "unused" bits in the
-    // last byte:
-    if (bits.length > 0) {
-      final int lastNBits = size & 7;
-      if (lastNBits != 0) {
-        final int mask = (1 << lastNBits)-1;
-        bits[bits.length-1] &= mask;
-      }
-    }
-  }
-
-  /** Set all bits */
-  public void setAll() {
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    count = size;
-  }
-     
-  /** Write as a bit set */
-  private void writeBits(IndexOutput output) throws IOException {
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    output.writeBytes(bits, bits.length);
-  }
-  
-  /** Write as a d-gaps list */
-  private void writeClearedDgaps(IndexOutput output) throws IOException {
-    output.writeInt(-1);            // mark using d-gaps                         
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    int last=0;
-    int numCleared = size()-count();
-    for (int i=0; i<bits.length && numCleared>0; i++) {
-      if (bits[i] != (byte) 0xff) {
-        output.writeVInt(i-last);
-        output.writeByte(bits[i]);
-        last = i;
-        numCleared -= (8-BYTE_COUNTS[bits[i] & 0xFF]);
-        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
-      }
-    }
-  }
-
-  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
-  private boolean isSparse() {
-
-    final int clearedCount = size() - count();
-    if (clearedCount == 0) {
-      return true;
-    }
-
-    final int avgGapLength = bits.length / clearedCount;
-
-    // expected number of bytes for vInt encoding of each gap
-    final int expectedDGapBytes;
-    if (avgGapLength <= (1<< 7)) {
-      expectedDGapBytes = 1;
-    } else if (avgGapLength <= (1<<14)) {
-      expectedDGapBytes = 2;
-    } else if (avgGapLength <= (1<<21)) {
-      expectedDGapBytes = 3;
-    } else if (avgGapLength <= (1<<28)) {
-      expectedDGapBytes = 4;
-    } else {
-      expectedDGapBytes = 5;
-    }
-
-    // +1 because we write the byte itself that contains the
-    // set bit
-    final int bytesPerSetBit = expectedDGapBytes + 1;
-    
-    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
-    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
-
-    // note: factor is for read/write of byte-arrays being faster than vints.  
-    final long factor = 10;  
-    return factor * expectedBits < size();
-  }
-
-  /** Constructs a bit vector from the file <code>name</code> in Directory
-    <code>d</code>, as written by the {@link #write} method.
-    */
-  public BitVector(Directory d, String name, IOContext context) throws IOException {
-    IndexInput input = d.openInput(name, context);
-
-    try {
-      final int firstInt = input.readInt();
-
-      if (firstInt == -2) {
-        // New format, with full header & version:
-        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
-        size = input.readInt();
-      } else {
-        version = VERSION_PRE;
-        size = firstInt;
-      }
-      if (size == -1) {
-        if (version >= VERSION_DGAPS_CLEARED) {
-          readClearedDgaps(input);
-        } else {
-          readSetDgaps(input);
-        }
-      } else {
-        readBits(input);
-      }
-
-      if (version < VERSION_DGAPS_CLEARED) {
-        invertAll();
-      }
-
-      assert verifyCount();
-    } finally {
-      input.close();
-    }
-  }
-
-  // asserts only
-  private boolean verifyCount() {
-    assert count != -1;
-    final int countSav = count;
-    count = -1;
-    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
-    return true;
-  }
-
-  /** Read as a bit set */
-  private void readBits(IndexInput input) throws IOException {
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    input.readBytes(bits, 0, bits.length);
-  }
-
-  /** read as a d-gaps list */ 
-  private void readSetDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    int last=0;
-    int n = count();
-    while (n>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      n -= BYTE_COUNTS[bits[last] & 0xFF];
-      assert n >= 0;
-    }          
-  }
-
-  /** read as a d-gaps cleared bits list */ 
-  private void readClearedDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    int last=0;
-    int numCleared = size()-count();
-    while (numCleared>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      numCleared -= 8-BYTE_COUNTS[bits[last] & 0xFF];
-      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
-    }
-  }
-}
diff --git a/lucene/src/java/org/apache/lucene/util/MutableBits.java b/lucene/src/java/org/apache/lucene/util/MutableBits.java
new file mode 100644
index 0000000..6f5cb96
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/util/MutableBits.java
@@ -0,0 +1,22 @@
+package org.apache.lucene.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface MutableBits extends Bits {
+  
+}
diff --git a/lucene/src/test/org/apache/lucene/codecs/lucene40/TestBitVector.java b/lucene/src/test/org/apache/lucene/codecs/lucene40/TestBitVector.java
new file mode 100644
index 0000000..8a66bb6
--- /dev/null
+++ b/lucene/src/test/org/apache/lucene/codecs/lucene40/TestBitVector.java
@@ -0,0 +1,287 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+
+/**
+ * <code>TestBitVector</code> tests the <code>BitVector</code>, obviously.
+ */
+public class TestBitVector extends LuceneTestCase
+{
+
+    /**
+     * Test the default constructor on BitVectors of various sizes.
+     * @throws Exception
+     */
+    public void testConstructSize() throws Exception {
+        doTestConstructOfSize(8);
+        doTestConstructOfSize(20);
+        doTestConstructOfSize(100);
+        doTestConstructOfSize(1000);
+    }
+
+    private void doTestConstructOfSize(int n) {
+        BitVector bv = new BitVector(n);
+        assertEquals(n,bv.size());
+    }
+
+    /**
+     * Test the get() and set() methods on BitVectors of various sizes.
+     * @throws Exception
+     */
+    public void testGetSet() throws Exception {
+        doTestGetSetVectorOfSize(8);
+        doTestGetSetVectorOfSize(20);
+        doTestGetSetVectorOfSize(100);
+        doTestGetSetVectorOfSize(1000);
+    }
+
+    private void doTestGetSetVectorOfSize(int n) {
+        BitVector bv = new BitVector(n);
+        for(int i=0;i<bv.size();i++) {
+            // ensure a set bit can be git'
+            assertFalse(bv.get(i));
+            bv.set(i);
+            assertTrue(bv.get(i));
+        }
+    }
+
+    /**
+     * Test the clear() method on BitVectors of various sizes.
+     * @throws Exception
+     */
+    public void testClear() throws Exception {
+        doTestClearVectorOfSize(8);
+        doTestClearVectorOfSize(20);
+        doTestClearVectorOfSize(100);
+        doTestClearVectorOfSize(1000);
+    }
+
+    private void doTestClearVectorOfSize(int n) {
+        BitVector bv = new BitVector(n);
+        for(int i=0;i<bv.size();i++) {
+            // ensure a set bit is cleared
+            assertFalse(bv.get(i));
+            bv.set(i);
+            assertTrue(bv.get(i));
+            bv.clear(i);
+            assertFalse(bv.get(i));
+        }
+    }
+
+    /**
+     * Test the count() method on BitVectors of various sizes.
+     * @throws Exception
+     */
+    public void testCount() throws Exception {
+        doTestCountVectorOfSize(8);
+        doTestCountVectorOfSize(20);
+        doTestCountVectorOfSize(100);
+        doTestCountVectorOfSize(1000);
+    }
+
+    private void doTestCountVectorOfSize(int n) {
+        BitVector bv = new BitVector(n);
+        // test count when incrementally setting bits
+        for(int i=0;i<bv.size();i++) {
+            assertFalse(bv.get(i));
+            assertEquals(i,bv.count());
+            bv.set(i);
+            assertTrue(bv.get(i));
+            assertEquals(i+1,bv.count());
+        }
+
+        bv = new BitVector(n);
+        // test count when setting then clearing bits
+        for(int i=0;i<bv.size();i++) {
+            assertFalse(bv.get(i));
+            assertEquals(0,bv.count());
+            bv.set(i);
+            assertTrue(bv.get(i));
+            assertEquals(1,bv.count());
+            bv.clear(i);
+            assertFalse(bv.get(i));
+            assertEquals(0,bv.count());
+        }
+    }
+
+    /**
+     * Test writing and construction to/from Directory.
+     * @throws Exception
+     */
+    public void testWriteRead() throws Exception {
+        doTestWriteRead(8);
+        doTestWriteRead(20);
+        doTestWriteRead(100);
+        doTestWriteRead(1000);
+    }
+
+    private void doTestWriteRead(int n) throws Exception {
+        MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
+        d.setPreventDoubleWrite(false);
+        BitVector bv = new BitVector(n);
+        // test count when incrementally setting bits
+        for(int i=0;i<bv.size();i++) {
+            assertFalse(bv.get(i));
+            assertEquals(i,bv.count());
+            bv.set(i);
+            assertTrue(bv.get(i));
+            assertEquals(i+1,bv.count());
+            bv.write(d, "TESTBV", newIOContext(random));
+            BitVector compare = new BitVector(d, "TESTBV", newIOContext(random));
+            // compare bit vectors with bits set incrementally
+            assertTrue(doCompare(bv,compare));
+        }
+    }
+    
+    /**
+     * Test r/w when size/count cause switching between bit-set and d-gaps file formats.  
+     */
+    public void testDgaps() throws IOException {
+      doTestDgaps(1,0,1);
+      doTestDgaps(10,0,1);
+      doTestDgaps(100,0,1);
+      doTestDgaps(1000,4,7);
+      doTestDgaps(10000,40,43);
+      doTestDgaps(100000,415,418);
+      doTestDgaps(1000000,3123,3126);
+      // now exercise skipping of fully populated byte in the bitset (they are omitted if bitset is sparse)
+      MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
+      d.setPreventDoubleWrite(false);
+      BitVector bv = new BitVector(10000);
+      bv.set(0);
+      for (int i = 8; i < 16; i++) {
+        bv.set(i);
+      } // make sure we have once byte full of set bits
+      for (int i = 32; i < 40; i++) {
+        bv.set(i);
+      } // get a second byte full of set bits
+      // add some more bits here 
+      for (int i = 40; i < 10000; i++) {
+        if (random.nextInt(1000) == 0) {
+          bv.set(i);
+        }
+      }
+      bv.write(d, "TESTBV", newIOContext(random));
+      BitVector compare = new BitVector(d, "TESTBV", newIOContext(random));
+      assertTrue(doCompare(bv,compare));
+    }
+    
+    private void doTestDgaps(int size, int count1, int count2) throws IOException {
+      MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
+      d.setPreventDoubleWrite(false);
+      BitVector bv = new BitVector(size);
+      bv.invertAll();
+      for (int i=0; i<count1; i++) {
+        bv.clear(i);
+        assertEquals(i+1,size-bv.count());
+      }
+      bv.write(d, "TESTBV", newIOContext(random));
+      // gradually increase number of set bits
+      for (int i=count1; i<count2; i++) {
+        BitVector bv2 = new BitVector(d, "TESTBV", newIOContext(random));
+        assertTrue(doCompare(bv,bv2));
+        bv = bv2;
+        bv.clear(i);
+        assertEquals(i+1, size-bv.count());
+        bv.write(d, "TESTBV", newIOContext(random));
+      }
+      // now start decreasing number of set bits
+      for (int i=count2-1; i>=count1; i--) {
+        BitVector bv2 = new BitVector(d, "TESTBV", newIOContext(random));
+        assertTrue(doCompare(bv,bv2));
+        bv = bv2;
+        bv.set(i);
+        assertEquals(i,size-bv.count());
+        bv.write(d, "TESTBV", newIOContext(random));
+      }
+    }
+
+    public void testSparseWrite() throws IOException {
+      Directory d = newDirectory();
+      final int numBits = 10240;
+      BitVector bv = new BitVector(numBits);
+      bv.invertAll();
+      int numToClear = random.nextInt(5);
+      for(int i=0;i<numToClear;i++) {
+        bv.clear(random.nextInt(numBits));
+      }
+      bv.write(d, "test", newIOContext(random));
+      final long size = d.fileLength("test");
+      assertTrue("size=" + size, size < 100);
+      d.close();
+    }
+
+    public void testClearedBitNearEnd() throws IOException {
+      Directory d = newDirectory();
+      final int numBits = _TestUtil.nextInt(random, 7, 1000);
+      BitVector bv = new BitVector(numBits);
+      bv.invertAll();
+      bv.clear(numBits-_TestUtil.nextInt(random, 1, 7));
+      bv.write(d, "test", newIOContext(random));
+      assertEquals(numBits-1, bv.count());
+      d.close();
+    }
+
+    public void testMostlySet() throws IOException {
+      Directory d = newDirectory();
+      final int numBits = _TestUtil.nextInt(random, 30, 1000);
+      for(int numClear=0;numClear<20;numClear++) {
+        BitVector bv = new BitVector(numBits);
+        bv.invertAll();
+        int count = 0;
+        while(count < numClear) {
+          final int bit = random.nextInt(numBits);
+          // Don't use getAndClear, so that count is recomputed
+          if (bv.get(bit)) {
+            bv.clear(bit);
+            count++;
+            assertEquals(numBits-count, bv.count());
+          }
+        }
+      }
+
+      d.close();
+    }
+
+    /**
+     * Compare two BitVectors.
+     * This should really be an equals method on the BitVector itself.
+     * @param bv One bit vector
+     * @param compare The second to compare
+     */
+    private boolean doCompare(BitVector bv, BitVector compare) {
+        boolean equal = true;
+        for(int i=0;i<bv.size();i++) {
+            // bits must be equal
+            if(bv.get(i)!=compare.get(i)) {
+                equal = false;
+                break;
+            }
+        }
+        assertEquals(bv.count(), compare.count());
+        return equal;
+    }
+}
diff --git a/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java b/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
index 9758b77..ebf57e2 100755
--- a/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
+++ b/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
@@ -27,6 +27,7 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfosFormat;
@@ -35,6 +36,7 @@ import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40Codec;
 import org.apache.lucene.codecs.lucene40.Lucene40DocValuesFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40NormsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40SegmentInfosFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsFormat;
@@ -1156,6 +1158,11 @@ public class TestAddIndexes extends LuceneTestCase {
     public NormsFormat normsFormat() {
       return new Lucene40NormsFormat();
     }
+    
+    @Override
+    public LiveDocsFormat liveDocsFormat() {
+      return new Lucene40LiveDocsFormat();
+    }
   }
   
   /*
diff --git a/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java b/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
index e54bb97..9075ed8 100644
--- a/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
+++ b/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
@@ -42,7 +42,6 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
diff --git a/lucene/src/test/org/apache/lucene/util/TestBitVector.java b/lucene/src/test/org/apache/lucene/util/TestBitVector.java
deleted file mode 100644
index d45f58c..0000000
--- a/lucene/src/test/org/apache/lucene/util/TestBitVector.java
+++ /dev/null
@@ -1,285 +0,0 @@
-package org.apache.lucene.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * <code>TestBitVector</code> tests the <code>BitVector</code>, obviously.
- */
-public class TestBitVector extends LuceneTestCase
-{
-
-    /**
-     * Test the default constructor on BitVectors of various sizes.
-     * @throws Exception
-     */
-    public void testConstructSize() throws Exception {
-        doTestConstructOfSize(8);
-        doTestConstructOfSize(20);
-        doTestConstructOfSize(100);
-        doTestConstructOfSize(1000);
-    }
-
-    private void doTestConstructOfSize(int n) {
-        BitVector bv = new BitVector(n);
-        assertEquals(n,bv.size());
-    }
-
-    /**
-     * Test the get() and set() methods on BitVectors of various sizes.
-     * @throws Exception
-     */
-    public void testGetSet() throws Exception {
-        doTestGetSetVectorOfSize(8);
-        doTestGetSetVectorOfSize(20);
-        doTestGetSetVectorOfSize(100);
-        doTestGetSetVectorOfSize(1000);
-    }
-
-    private void doTestGetSetVectorOfSize(int n) {
-        BitVector bv = new BitVector(n);
-        for(int i=0;i<bv.size();i++) {
-            // ensure a set bit can be git'
-            assertFalse(bv.get(i));
-            bv.set(i);
-            assertTrue(bv.get(i));
-        }
-    }
-
-    /**
-     * Test the clear() method on BitVectors of various sizes.
-     * @throws Exception
-     */
-    public void testClear() throws Exception {
-        doTestClearVectorOfSize(8);
-        doTestClearVectorOfSize(20);
-        doTestClearVectorOfSize(100);
-        doTestClearVectorOfSize(1000);
-    }
-
-    private void doTestClearVectorOfSize(int n) {
-        BitVector bv = new BitVector(n);
-        for(int i=0;i<bv.size();i++) {
-            // ensure a set bit is cleared
-            assertFalse(bv.get(i));
-            bv.set(i);
-            assertTrue(bv.get(i));
-            bv.clear(i);
-            assertFalse(bv.get(i));
-        }
-    }
-
-    /**
-     * Test the count() method on BitVectors of various sizes.
-     * @throws Exception
-     */
-    public void testCount() throws Exception {
-        doTestCountVectorOfSize(8);
-        doTestCountVectorOfSize(20);
-        doTestCountVectorOfSize(100);
-        doTestCountVectorOfSize(1000);
-    }
-
-    private void doTestCountVectorOfSize(int n) {
-        BitVector bv = new BitVector(n);
-        // test count when incrementally setting bits
-        for(int i=0;i<bv.size();i++) {
-            assertFalse(bv.get(i));
-            assertEquals(i,bv.count());
-            bv.set(i);
-            assertTrue(bv.get(i));
-            assertEquals(i+1,bv.count());
-        }
-
-        bv = new BitVector(n);
-        // test count when setting then clearing bits
-        for(int i=0;i<bv.size();i++) {
-            assertFalse(bv.get(i));
-            assertEquals(0,bv.count());
-            bv.set(i);
-            assertTrue(bv.get(i));
-            assertEquals(1,bv.count());
-            bv.clear(i);
-            assertFalse(bv.get(i));
-            assertEquals(0,bv.count());
-        }
-    }
-
-    /**
-     * Test writing and construction to/from Directory.
-     * @throws Exception
-     */
-    public void testWriteRead() throws Exception {
-        doTestWriteRead(8);
-        doTestWriteRead(20);
-        doTestWriteRead(100);
-        doTestWriteRead(1000);
-    }
-
-    private void doTestWriteRead(int n) throws Exception {
-        MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
-        d.setPreventDoubleWrite(false);
-        BitVector bv = new BitVector(n);
-        // test count when incrementally setting bits
-        for(int i=0;i<bv.size();i++) {
-            assertFalse(bv.get(i));
-            assertEquals(i,bv.count());
-            bv.set(i);
-            assertTrue(bv.get(i));
-            assertEquals(i+1,bv.count());
-            bv.write(d, "TESTBV", newIOContext(random));
-            BitVector compare = new BitVector(d, "TESTBV", newIOContext(random));
-            // compare bit vectors with bits set incrementally
-            assertTrue(doCompare(bv,compare));
-        }
-    }
-    
-    /**
-     * Test r/w when size/count cause switching between bit-set and d-gaps file formats.  
-     */
-    public void testDgaps() throws IOException {
-      doTestDgaps(1,0,1);
-      doTestDgaps(10,0,1);
-      doTestDgaps(100,0,1);
-      doTestDgaps(1000,4,7);
-      doTestDgaps(10000,40,43);
-      doTestDgaps(100000,415,418);
-      doTestDgaps(1000000,3123,3126);
-      // now exercise skipping of fully populated byte in the bitset (they are omitted if bitset is sparse)
-      MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
-      d.setPreventDoubleWrite(false);
-      BitVector bv = new BitVector(10000);
-      bv.set(0);
-      for (int i = 8; i < 16; i++) {
-        bv.set(i);
-      } // make sure we have once byte full of set bits
-      for (int i = 32; i < 40; i++) {
-        bv.set(i);
-      } // get a second byte full of set bits
-      // add some more bits here 
-      for (int i = 40; i < 10000; i++) {
-        if (random.nextInt(1000) == 0) {
-          bv.set(i);
-        }
-      }
-      bv.write(d, "TESTBV", newIOContext(random));
-      BitVector compare = new BitVector(d, "TESTBV", newIOContext(random));
-      assertTrue(doCompare(bv,compare));
-    }
-    
-    private void doTestDgaps(int size, int count1, int count2) throws IOException {
-      MockDirectoryWrapper d = new  MockDirectoryWrapper(random, new RAMDirectory());
-      d.setPreventDoubleWrite(false);
-      BitVector bv = new BitVector(size);
-      bv.invertAll();
-      for (int i=0; i<count1; i++) {
-        bv.clear(i);
-        assertEquals(i+1,size-bv.count());
-      }
-      bv.write(d, "TESTBV", newIOContext(random));
-      // gradually increase number of set bits
-      for (int i=count1; i<count2; i++) {
-        BitVector bv2 = new BitVector(d, "TESTBV", newIOContext(random));
-        assertTrue(doCompare(bv,bv2));
-        bv = bv2;
-        bv.clear(i);
-        assertEquals(i+1, size-bv.count());
-        bv.write(d, "TESTBV", newIOContext(random));
-      }
-      // now start decreasing number of set bits
-      for (int i=count2-1; i>=count1; i--) {
-        BitVector bv2 = new BitVector(d, "TESTBV", newIOContext(random));
-        assertTrue(doCompare(bv,bv2));
-        bv = bv2;
-        bv.set(i);
-        assertEquals(i,size-bv.count());
-        bv.write(d, "TESTBV", newIOContext(random));
-      }
-    }
-
-    public void testSparseWrite() throws IOException {
-      Directory d = newDirectory();
-      final int numBits = 10240;
-      BitVector bv = new BitVector(numBits);
-      bv.invertAll();
-      int numToClear = random.nextInt(5);
-      for(int i=0;i<numToClear;i++) {
-        bv.clear(random.nextInt(numBits));
-      }
-      bv.write(d, "test", newIOContext(random));
-      final long size = d.fileLength("test");
-      assertTrue("size=" + size, size < 100);
-      d.close();
-    }
-
-    public void testClearedBitNearEnd() throws IOException {
-      Directory d = newDirectory();
-      final int numBits = _TestUtil.nextInt(random, 7, 1000);
-      BitVector bv = new BitVector(numBits);
-      bv.invertAll();
-      bv.clear(numBits-_TestUtil.nextInt(random, 1, 7));
-      bv.write(d, "test", newIOContext(random));
-      assertEquals(numBits-1, bv.count());
-      d.close();
-    }
-
-    public void testMostlySet() throws IOException {
-      Directory d = newDirectory();
-      final int numBits = _TestUtil.nextInt(random, 30, 1000);
-      for(int numClear=0;numClear<20;numClear++) {
-        BitVector bv = new BitVector(numBits);
-        bv.invertAll();
-        int count = 0;
-        while(count < numClear) {
-          final int bit = random.nextInt(numBits);
-          // Don't use getAndClear, so that count is recomputed
-          if (bv.get(bit)) {
-            bv.clear(bit);
-            count++;
-            assertEquals(numBits-count, bv.count());
-          }
-        }
-      }
-
-      d.close();
-    }
-
-    /**
-     * Compare two BitVectors.
-     * This should really be an equals method on the BitVector itself.
-     * @param bv One bit vector
-     * @param compare The second to compare
-     */
-    private boolean doCompare(BitVector bv, BitVector compare) {
-        boolean equal = true;
-        for(int i=0;i<bv.size();i++) {
-            // bits must be equal
-            if(bv.get(i)!=compare.get(i)) {
-                equal = false;
-                break;
-            }
-        }
-        assertEquals(bv.count(), compare.count());
-        return equal;
-    }
-}

