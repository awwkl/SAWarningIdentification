GitDiffStart: 6bf44e94399e474ba3285d442ce6406cdadc1d9e | Fri Oct 31 20:48:22 2014 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index ac80a55..aec9f24 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -194,7 +194,7 @@ Bug Fixes
   behave properly when wrapping other ValueSources which do not exist for the specified document
   (hossman)
 
-* LUCENE-6039: Add IndexOptions.NO and DocValuesType.NO instead of
+* LUCENE-6039: Add IndexOptions.NONE and DocValuesType.NONE instead of
   using null to mean not index and no doc values, renamed
   IndexOptions.DOCS_ONLY to DOCS, and pulled IndexOptions and
   DocValues out of FieldInfo into their own classes in
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java
index 107ea50..9b1e887 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java
@@ -104,7 +104,7 @@ class SimpleTextDocValuesReader extends DocValuesProducer {
       assert startsWith(TYPE) : scratch.get().utf8ToString();
 
       DocValuesType dvType = DocValuesType.valueOf(stripPrefix(TYPE));
-      assert dvType != DocValuesType.NO;
+      assert dvType != DocValuesType.NONE;
       if (dvType == DocValuesType.NUMERIC) {
         readLine();
         assert startsWith(MINVALUE): "got " + scratch.get().utf8ToString() + " field=" + fieldName + " ext=" + ext;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
index 7be2abc..7339c3f 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
@@ -138,7 +138,7 @@ public abstract class DocValuesConsumer implements Closeable {
 
     for (FieldInfo mergeFieldInfo : mergeState.mergeFieldInfos) {
       DocValuesType type = mergeFieldInfo.getDocValuesType();
-      if (type != DocValuesType.NO) {
+      if (type != DocValuesType.NONE) {
         if (type == DocValuesType.NUMERIC) {
           List<NumericDocValues> toMerge = new ArrayList<>();
           List<Bits> docsWithField = new ArrayList<>();
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java
index f8dafdd..e41b216 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java
@@ -824,7 +824,7 @@ public final class BlockTreeTermsWriter extends FieldsConsumer {
 
     TermsWriter(FieldInfo fieldInfo) {
       this.fieldInfo = fieldInfo;
-      assert fieldInfo.getIndexOptions() != IndexOptions.NO;
+      assert fieldInfo.getIndexOptions() != IndexOptions.NONE;
       docsSeen = new FixedBitSet(maxDoc);
 
       this.longsSize = postingsWriter.setField(fieldInfo);
@@ -975,7 +975,7 @@ public final class BlockTreeTermsWriter extends FieldsConsumer {
         termsOut.writeVLong(field.numTerms);
         termsOut.writeVInt(field.rootCode.length);
         termsOut.writeBytes(field.rootCode.bytes, field.rootCode.offset, field.rootCode.length);
-        assert field.fieldInfo.getIndexOptions() != IndexOptions.NO;
+        assert field.fieldInfo.getIndexOptions() != IndexOptions.NONE;
         if (field.fieldInfo.getIndexOptions() != IndexOptions.DOCS) {
           termsOut.writeVLong(field.sumTotalTermFreq);
         }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
index 83f1b80..c8bd6d9 100755
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
@@ -164,7 +164,7 @@ public final class Lucene50FieldInfosFormat extends FieldInfosFormat {
 
   private static byte docValuesByte(DocValuesType type) {
     switch(type) {
-    case NO:
+    case NONE:
       return 0;
     case NUMERIC:
       return 1;
@@ -185,7 +185,7 @@ public final class Lucene50FieldInfosFormat extends FieldInfosFormat {
   private static DocValuesType getDocValuesType(IndexInput input, byte b) throws IOException {
     switch(b) {
     case 0:
-      return DocValuesType.NO;
+      return DocValuesType.NONE;
     case 1:
       return DocValuesType.NUMERIC;
     case 2:
@@ -209,7 +209,7 @@ public final class Lucene50FieldInfosFormat extends FieldInfosFormat {
 
   private static byte indexOptionsByte(IndexOptions indexOptions) {
     switch (indexOptions) {
-    case NO:
+    case NONE:
       return 0;
     case DOCS:
       return 1;
@@ -228,7 +228,7 @@ public final class Lucene50FieldInfosFormat extends FieldInfosFormat {
   private static IndexOptions getIndexOptions(IndexInput input, byte b) throws IOException {
     switch (b) {
     case 0:
-      return IndexOptions.NO;
+      return IndexOptions.NONE;
     case 1:
       return IndexOptions.DOCS;
     case 2:
diff --git a/lucene/core/src/java/org/apache/lucene/document/Document.java b/lucene/core/src/java/org/apache/lucene/document/Document.java
index ecf6328..bff0c9b 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Document.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Document.java
@@ -312,7 +312,7 @@ public final class Document implements IndexDocument {
     return new FilterIterator<StorableField, Field>(fields.iterator()) {
       @Override
       protected boolean predicateFunction(Field field) {
-        return field.type.stored() || field.type.docValueType() != DocValuesType.NO;
+        return field.type.stored() || field.type.docValueType() != DocValuesType.NONE;
       }
     };
   }
@@ -321,7 +321,7 @@ public final class Document implements IndexDocument {
     return new FilterIterator<IndexableField, Field>(fields.iterator()) {
       @Override
       protected boolean predicateFunction(Field field) {
-        return field.type.indexOptions() != IndexOptions.NO;
+        return field.type.indexOptions() != IndexOptions.NONE;
       }
     };
   }
diff --git a/lucene/core/src/java/org/apache/lucene/document/Field.java b/lucene/core/src/java/org/apache/lucene/document/Field.java
index 7cd4f4b..aa0aecf 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Field.java
@@ -123,7 +123,7 @@ public class Field implements IndexableField, StorableField {
     if (type.stored()) {
       throw new IllegalArgumentException("fields with a Reader value cannot be stored");
     }
-    if (type.indexOptions() != IndexOptions.NO && !type.tokenized()) {
+    if (type.indexOptions() != IndexOptions.NONE && !type.tokenized()) {
       throw new IllegalArgumentException("non-tokenized fields must use String values");
     }
     
@@ -149,7 +149,7 @@ public class Field implements IndexableField, StorableField {
     if (tokenStream == null) {
       throw new NullPointerException("tokenStream cannot be null");
     }
-    if (type.indexOptions() == IndexOptions.NO || !type.tokenized()) {
+    if (type.indexOptions() == IndexOptions.NONE || !type.tokenized()) {
       throw new IllegalArgumentException("TokenStream fields must be indexed and tokenized");
     }
     if (type.stored()) {
@@ -215,7 +215,7 @@ public class Field implements IndexableField, StorableField {
     if (bytes == null) {
       throw new IllegalArgumentException("bytes cannot be null");
     }
-    if (type.indexOptions() != IndexOptions.NO) {
+    if (type.indexOptions() != IndexOptions.NONE) {
       throw new IllegalArgumentException("Fields with BytesRef values cannot be indexed");
     }
     this.fieldsData = bytes;
@@ -242,7 +242,7 @@ public class Field implements IndexableField, StorableField {
     if (value == null) {
       throw new IllegalArgumentException("value cannot be null");
     }
-    if (!type.stored() && type.indexOptions() == IndexOptions.NO) {
+    if (!type.stored() && type.indexOptions() == IndexOptions.NONE) {
       throw new IllegalArgumentException("it doesn't make sense to have a field that "
         + "is neither indexed nor stored");
     }
@@ -339,7 +339,7 @@ public class Field implements IndexableField, StorableField {
     if (!(fieldsData instanceof BytesRef)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to BytesRef");
     }
-    if (type.indexOptions() != IndexOptions.NO) {
+    if (type.indexOptions() != IndexOptions.NONE) {
       throw new IllegalArgumentException("cannot set a BytesRef value on an indexed field");
     }
     if (value == null) {
@@ -420,7 +420,7 @@ public class Field implements IndexableField, StorableField {
    * values from stringValue() or getBinaryValue()
    */
   public void setTokenStream(TokenStream tokenStream) {
-    if (type.indexOptions() == IndexOptions.NO || !type.tokenized()) {
+    if (type.indexOptions() == IndexOptions.NONE || !type.tokenized()) {
       throw new IllegalArgumentException("TokenStream fields must be indexed and tokenized");
     }
     if (type.numericType() != null) {
@@ -453,7 +453,7 @@ public class Field implements IndexableField, StorableField {
    */
   public void setBoost(float boost) {
     if (boost != 1.0f) {
-      if (type.indexOptions() == IndexOptions.NO || type.omitNorms()) {
+      if (type.indexOptions() == IndexOptions.NONE || type.omitNorms()) {
         throw new IllegalArgumentException("You cannot set an index-time boost on an unindexed field, or one that omits norms");
       }
     }
@@ -503,7 +503,7 @@ public class Field implements IndexableField, StorableField {
 
   @Override
   public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) throws IOException {
-    if (fieldType().indexOptions() == IndexOptions.NO) {
+    if (fieldType().indexOptions() == IndexOptions.NONE) {
       // Not indexed
       return null;
     }
diff --git a/lucene/core/src/java/org/apache/lucene/document/FieldType.java b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
index 603ffed..ac908a3 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FieldType.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
@@ -50,11 +50,11 @@ public class FieldType implements IndexableFieldType  {
   private boolean storeTermVectorPositions;
   private boolean storeTermVectorPayloads;
   private boolean omitNorms;
-  private IndexOptions indexOptions = IndexOptions.NO;
+  private IndexOptions indexOptions = IndexOptions.NONE;
   private NumericType numericType;
   private boolean frozen;
   private int numericPrecisionStep = NumericUtils.PRECISION_STEP_DEFAULT;
-  private DocValuesType docValueType = DocValuesType.NO;
+  private DocValuesType docValueType = DocValuesType.NONE;
 
   /**
    * Create a new mutable FieldType with all of the properties from <code>ref</code>
@@ -344,7 +344,7 @@ public class FieldType implements IndexableFieldType  {
     if (stored()) {
       result.append("stored");
     }
-    if (indexOptions != IndexOptions.NO) {
+    if (indexOptions != IndexOptions.NONE) {
       if (result.length() > 0)
         result.append(",");
       result.append("indexed");
@@ -377,7 +377,7 @@ public class FieldType implements IndexableFieldType  {
         result.append(numericPrecisionStep);
       }
     }
-    if (docValueType != DocValuesType.NO) {
+    if (docValueType != DocValuesType.NONE) {
       if (result.length() > 0) {
         result.append(",");
       }
diff --git a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
index 8f7a4d3..805a5f0 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
@@ -365,7 +365,7 @@ final class DefaultIndexingChain extends DocConsumer {
         if (dvType == null) {
           throw new NullPointerException("docValueType cannot be null (field: \"" + fieldName + "\")");
         }
-        if (dvType != DocValuesType.NO) {
+        if (dvType != DocValuesType.NONE) {
           indexDocValue(fp, dvType, field);
         }
       }
@@ -382,7 +382,7 @@ final class DefaultIndexingChain extends DocConsumer {
     if (ft.indexOptions() == null) {
       throw new NullPointerException("IndexOptions must not be null (field: \"" + name + "\")");
     }
-    if (ft.indexOptions() == IndexOptions.NO) {
+    if (ft.indexOptions() == IndexOptions.NONE) {
       if (ft.storeTermVectors()) {
         throw new IllegalArgumentException("cannot store term vectors "
                                            + "for a field that is not indexed (field=\"" + name + "\")");
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValuesType.java b/lucene/core/src/java/org/apache/lucene/index/DocValuesType.java
index cb1ca37..014d479 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValuesType.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValuesType.java
@@ -26,7 +26,7 @@ public enum DocValuesType {
   /**
    * No doc values for this field.
    */
-  NO,
+  NONE,
   /** 
    * A per-document Number
    */
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java b/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
index eff161b..cf69cff 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
@@ -34,14 +34,14 @@ public final class FieldInfo {
   /** Internal field number */
   public final int number;
 
-  private DocValuesType docValuesType = DocValuesType.NO;
+  private DocValuesType docValuesType = DocValuesType.NONE;
 
   // True if any document indexed term vectors
   private boolean storeTermVector;
 
   private boolean omitNorms; // omit norms associated with indexed fields  
 
-  private IndexOptions indexOptions = IndexOptions.NO;
+  private IndexOptions indexOptions = IndexOptions.NONE;
   private boolean storePayloads; // whether this field stores payloads together with term positions
 
   private Map<String,String> attributes;
@@ -65,7 +65,7 @@ public final class FieldInfo {
     this.number = number;
     this.docValuesType = docValues;
     this.indexOptions = indexOptions;
-    if (indexOptions != IndexOptions.NO) {
+    if (indexOptions != IndexOptions.NONE) {
       this.storeTermVector = storeTermVector;
       this.storePayloads = storePayloads;
       this.omitNorms = omitNorms;
@@ -84,7 +84,7 @@ public final class FieldInfo {
    * Always returns true (or throws IllegalStateException) 
    */
   public boolean checkConsistency() {
-    if (indexOptions != IndexOptions.NO) {
+    if (indexOptions != IndexOptions.NONE) {
       // Cannot store payloads unless positions are indexed:
       if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0 && storePayloads) {
         throw new IllegalStateException("indexed field '" + name + "' cannot have payloads without positions");
@@ -101,7 +101,7 @@ public final class FieldInfo {
       }
     }
     
-    if (dvGen != -1 && docValuesType == DocValuesType.NO) {
+    if (dvGen != -1 && docValuesType == DocValuesType.NONE) {
       throw new IllegalStateException("field '" + name + "' cannot have a docvalues update generation without having docvalues");
     }
 
@@ -119,24 +119,24 @@ public final class FieldInfo {
     }
     //System.out.println("FI.update field=" + name + " indexed=" + indexed + " omitNorms=" + omitNorms + " this.omitNorms=" + this.omitNorms);
     if (this.indexOptions != indexOptions) {
-      if (this.indexOptions == IndexOptions.NO) {
+      if (this.indexOptions == IndexOptions.NONE) {
         this.indexOptions = indexOptions;
-      } else if (indexOptions != IndexOptions.NO) {
+      } else if (indexOptions != IndexOptions.NONE) {
         // downgrade
         this.indexOptions = this.indexOptions.compareTo(indexOptions) < 0 ? this.indexOptions : indexOptions;
       }
     }
 
-    if (this.indexOptions != IndexOptions.NO) { // if updated field data is not for indexing, leave the updates out
+    if (this.indexOptions != IndexOptions.NONE) { // if updated field data is not for indexing, leave the updates out
       this.storeTermVector |= storeTermVector;                // once vector, always vector
       this.storePayloads |= storePayloads;
 
       // Awkward: only drop norms if incoming update is indexed:
-      if (indexOptions != IndexOptions.NO && this.omitNorms != omitNorms) {
+      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {
         this.omitNorms = true;                // if one require omitNorms at least once, it remains off for life
       }
     }
-    if (this.indexOptions == IndexOptions.NO || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {
+    if (this.indexOptions == IndexOptions.NONE || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {
       // cannot store payloads if we don't store positions:
       this.storePayloads = false;
     }
@@ -147,14 +147,14 @@ public final class FieldInfo {
     if (type == null) {
       throw new NullPointerException("DocValuesType cannot be null (field: \"" + name + "\")");
     }
-    if (docValuesType != DocValuesType.NO && docValuesType != type) {
+    if (docValuesType != DocValuesType.NONE && docValuesType != type) {
       throw new IllegalArgumentException("cannot change DocValues type from " + docValuesType + " to " + type + " for field \"" + name + "\"");
     }
     docValuesType = type;
     assert checkConsistency();
   }
   
-  /** Returns IndexOptions for the field, or IndexOptions.NO if the field is not indexed */
+  /** Returns IndexOptions for the field, or IndexOptions.NONE if the field is not indexed */
   public IndexOptions getIndexOptions() {
     return indexOptions;
   }
@@ -163,12 +163,12 @@ public final class FieldInfo {
    * Returns true if this field has any docValues.
    */
   public boolean hasDocValues() {
-    return docValuesType != DocValuesType.NO;
+    return docValuesType != DocValuesType.NONE;
   }
 
   /**
    * Returns {@link DocValuesType} of the docValues; this is
-   * {@code DocValuesType.NO} if the field has no docvalues.
+   * {@code DocValuesType.NONE} if the field has no docvalues.
    */
   public DocValuesType getDocValuesType() {
     return docValuesType;
@@ -194,7 +194,7 @@ public final class FieldInfo {
   }
   
   void setStorePayloads() {
-    if (indexOptions != IndexOptions.NO && indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
+    if (indexOptions != IndexOptions.NONE && indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
       storePayloads = true;
     }
     assert checkConsistency();
@@ -215,10 +215,10 @@ public final class FieldInfo {
   }
   
   /**
-   * Returns true if this field is indexed ({@link #getIndexOptions} is not IndexOptions.NO).
+   * Returns true if this field is indexed ({@link #getIndexOptions} is not IndexOptions.NONE).
    */
   public boolean isIndexed() {
-    return indexOptions != IndexOptions.NO;
+    return indexOptions != IndexOptions.NONE;
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
index 4476ea5..7ab9572 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
@@ -187,11 +187,11 @@ public class FieldInfos implements Iterable<FieldInfo> {
      * is used as the field number.
      */
     synchronized int addOrGet(String fieldName, int preferredFieldNumber, DocValuesType dvType) {
-      if (dvType != DocValuesType.NO) {
+      if (dvType != DocValuesType.NONE) {
         DocValuesType currentDVType = docValuesType.get(fieldName);
         if (currentDVType == null) {
           docValuesType.put(fieldName, dvType);
-        } else if (currentDVType != DocValuesType.NO && currentDVType != dvType) {
+        } else if (currentDVType != DocValuesType.NONE && currentDVType != dvType) {
           throw new IllegalArgumentException("cannot change DocValues type from " + currentDVType + " to " + dvType + " for field \"" + fieldName + "\"");
         }
       }
@@ -224,7 +224,7 @@ public class FieldInfos implements Iterable<FieldInfo> {
         throw new IllegalArgumentException("field name \"" + name + "\" is already mapped to field number \"" + nameToNumber.get(name) + "\", not \"" + number + "\"");
       }
       DocValuesType currentDVType = docValuesType.get(name);
-      if (dvType != DocValuesType.NO && currentDVType != null && currentDVType != DocValuesType.NO && dvType != currentDVType) {
+      if (dvType != DocValuesType.NONE && currentDVType != null && currentDVType != DocValuesType.NONE && dvType != currentDVType) {
         throw new IllegalArgumentException("cannot change DocValues type from " + currentDVType + " to " + dvType + " for field \"" + name + "\"");
       }
     }
@@ -312,7 +312,7 @@ public class FieldInfos implements Iterable<FieldInfo> {
       } else {
         fi.update(storeTermVector, omitNorms, storePayloads, indexOptions);
 
-        if (docValues != DocValuesType.NO) {
+        if (docValues != DocValuesType.NONE) {
           // Only pay the synchronization cost if fi does not already have a DVType
           boolean updateGlobal = !fi.hasDocValues();
           if (updateGlobal) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java b/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
index 5abe281..fae0d6f 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriterPerField.java
@@ -49,7 +49,7 @@ final class FreqProxTermsWriterPerField extends TermsHashPerField {
   public FreqProxTermsWriterPerField(FieldInvertState invertState, TermsHash termsHash, FieldInfo fieldInfo, TermsHashPerField nextPerField) {
     super(fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 ? 2 : 1, invertState, termsHash, nextPerField, fieldInfo);
     IndexOptions indexOptions = fieldInfo.getIndexOptions();
-    assert indexOptions != IndexOptions.NO;
+    assert indexOptions != IndexOptions.NONE;
     hasFreq = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
     hasProx = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
     hasOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
@@ -195,7 +195,7 @@ final class FreqProxTermsWriterPerField extends TermsHashPerField {
   @Override
   ParallelPostingsArray createPostingsArray(int size) {
     IndexOptions indexOptions = fieldInfo.getIndexOptions();
-    assert indexOptions != IndexOptions.NO;
+    assert indexOptions != IndexOptions.NONE;
     boolean hasFreq = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
     boolean hasProx = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
     boolean hasOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexOptions.java b/lucene/core/src/java/org/apache/lucene/index/IndexOptions.java
index 992955d..3fd5d25 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexOptions.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexOptions.java
@@ -27,7 +27,7 @@ public enum IndexOptions {
   // order to merge two conflicting IndexOptions (always
   // "downgrades" by picking the lowest).
   /** Not indexed */
-  NO,
+  NONE,
   /** 
    * Only documents are indexed: term frequencies and positions are omitted.
    * Phrase and other positional queries on the field will throw an exception, and scoring
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 449b737..4a2061c 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -1500,7 +1500,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
       if (dvType == null) {
         throw new NullPointerException("DocValuesType cannot be null (field: \"" + f.name() + "\")");
       }
-      if (dvType == DocValuesType.NO) {
+      if (dvType == DocValuesType.NONE) {
         throw new IllegalArgumentException("can only update NUMERIC or BINARY fields! field=" + f.name());
       }
       if (!globalFieldNumberMap.contains(f.name(), dvType)) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
index 3fd7ba5..26eb9b5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexableField.java
@@ -64,7 +64,7 @@ public interface IndexableField extends GeneralField {
    * the range of that encoding.
    * <p>
    * It is illegal to return a boost other than 1.0f for a field that is not
-   * indexed ({@link IndexableFieldType#indexOptions()} is IndexOptions.NO) or
+   * indexed ({@link IndexableFieldType#indexOptions()} is IndexOptions.NONE) or
    * omits normalization values ({@link IndexableFieldType#omitNorms()} returns true).
    *
    * @see Similarity#computeNorm(FieldInvertState)
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexableFieldType.java b/lucene/core/src/java/org/apache/lucene/index/IndexableFieldType.java
index f86d691..6de57c3 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexableFieldType.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexableFieldType.java
@@ -33,7 +33,7 @@ public interface IndexableFieldType {
    * {@link Analyzer}.
    * <p>
    * This has no effect if {@link #indexOptions()} returns
-   * IndexOptions.NO.
+   * IndexOptions.NONE.
    */
   // TODO: shouldn't we remove this?  Whether/how a field is
   // tokenized is an impl detail under Field?
@@ -48,7 +48,7 @@ public interface IndexableFieldType {
    * {@link IndexReader#getTermVector(int,String)}.
    * <p>
    * This option is illegal if {@link #indexOptions()} returns
-   * IndexOptions.NO.
+   * IndexOptions.NONE.
    */
   public boolean storeTermVectors();
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java b/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
index c7f39ef..7878cb9 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
@@ -339,7 +339,7 @@ public final class SegmentReader extends LeafReader implements Accountable {
       // Field does not exist
       return null;
     }
-    if (fi.getDocValuesType() == DocValuesType.NO) {
+    if (fi.getDocValuesType() == DocValuesType.NONE) {
       // Field was not indexed with doc values
       return null;
     }
@@ -384,7 +384,7 @@ public final class SegmentReader extends LeafReader implements Accountable {
         // Field does not exist
         return null;
       }
-      if (fi.getDocValuesType() == DocValuesType.NO) {
+      if (fi.getDocValuesType() == DocValuesType.NONE) {
         // Field was not indexed with doc values
         return null;
       }
diff --git a/lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField.java b/lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField.java
index 68b28b2..f211720 100644
--- a/lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField.java
+++ b/lucene/core/src/java/org/apache/lucene/index/TermVectorsConsumerPerField.java
@@ -111,7 +111,7 @@ final class TermVectorsConsumerPerField extends TermsHashPerField {
 
   @Override
   boolean start(IndexableField field, boolean first) {
-    assert field.fieldType().indexOptions() != IndexOptions.NO;
+    assert field.fieldType().indexOptions() != IndexOptions.NONE;
 
     if (first) {
 
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat2.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat2.java
index a8096af..34a9caf 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat2.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/lucene50/TestBlockPostingsFormat2.java
@@ -66,7 +66,7 @@ public class TestBlockPostingsFormat2 extends LuceneTestCase {
   private Document newDocument() {
     Document doc = new Document();
     for (IndexOptions option : IndexOptions.values()) {
-      if (option == IndexOptions.NO) {
+      if (option == IndexOptions.NONE) {
         continue;
       }
       FieldType ft = new FieldType(TextField.TYPE_NOT_STORED);
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestDocument.java b/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
index 581d76f..e28170c 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
@@ -65,7 +65,7 @@ public class TestDocument extends LuceneTestCase {
     
     assertTrue(binaryFld.binaryValue() != null);
     assertTrue(binaryFld.fieldType().stored());
-    assertEquals(IndexOptions.NO, binaryFld.fieldType().indexOptions());
+    assertEquals(IndexOptions.NONE, binaryFld.fieldType().indexOptions());
     
     String binaryTest = doc.getBinaryValue("binary").utf8ToString();
     assertTrue(binaryTest.equals(binaryVal));
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java b/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
index 5eeefae..28e73b7 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
@@ -115,7 +115,7 @@ public class TestCodecs extends LuceneTestCase {
         public IndexOptions indexOptions() { return omitTF ? IndexOptions.DOCS : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS; }
 
         @Override
-        public DocValuesType docValueType() { return DocValuesType.NO; }
+        public DocValuesType docValueType() { return DocValuesType.NONE; }
       });
       if (storePayloads) {
         fieldInfo.setStorePayloads();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
index 76be7b2..6c9298e 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexableField.java
@@ -57,7 +57,7 @@ public class TestIndexableField extends LuceneTestCase {
 
       @Override
       public boolean storeTermVectors() {
-        return indexOptions() != IndexOptions.NO && counter % 2 == 1 && counter % 10 != 9;
+        return indexOptions() != IndexOptions.NONE && counter % 2 == 1 && counter % 10 != 9;
       }
 
       @Override
@@ -82,12 +82,12 @@ public class TestIndexableField extends LuceneTestCase {
 
       @Override
       public IndexOptions indexOptions() {
-        return counter%10 == 3 ? IndexOptions.NO : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
+        return counter%10 == 3 ? IndexOptions.NONE : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
       }
 
       @Override
       public DocValuesType docValueType() {
-        return DocValuesType.NO;
+        return DocValuesType.NONE;
       }
     };
 
@@ -202,7 +202,7 @@ public class TestIndexableField extends LuceneTestCase {
                     next = new MyField(finalBaseCount + (fieldUpto++-1));
                   }
                   
-                  if (next != null && next.fieldType().indexOptions() != IndexOptions.NO) return true;
+                  if (next != null && next.fieldType().indexOptions() != IndexOptions.NONE) return true;
                   else return this.hasNext();
                 }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java b/lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java
index 857b5eb..7c7c636 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java
@@ -176,7 +176,7 @@ public class TestSegmentReader extends LuceneTestCase {
     // test omit norms
     for (int i=0; i<DocHelper.fields.length; i++) {
       IndexableField f = DocHelper.fields[i];
-      if (f.fieldType().indexOptions() != IndexOptions.NO) {
+      if (f.fieldType().indexOptions() != IndexOptions.NONE) {
         assertEquals(reader.getNormValues(f.name()) != null, !f.fieldType().omitNorms());
         assertEquals(reader.getNormValues(f.name()) != null, !DocHelper.noNorms.containsKey(f.name()));
         if (reader.getNormValues(f.name()) == null) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
index e09734b..f1ae67b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarityBase.java
@@ -112,7 +112,7 @@ public class TestSimilarityBase extends LuceneTestCase {
     for (int i = 0; i < docs.length; i++) {
       Document d = new Document();
       FieldType ft = new FieldType(TextField.TYPE_STORED);
-      ft.setIndexOptions(IndexOptions.NO);
+      ft.setIndexOptions(IndexOptions.NONE);
       d.add(newField(FIELD_ID, Integer.toString(i), ft));
       d.add(newTextField(FIELD_BODY, docs[i], Field.Store.YES));
       writer.addDocument(d);
diff --git a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index 2587085..4b0644e 100644
--- a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
+++ b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -450,7 +450,7 @@ public class MemoryIndex {
         fieldInfos.put(fieldName, 
             new FieldInfo(fieldName, fieldInfos.size(), false, false, false,
                           this.storeOffsets ? IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS,
-                          DocValuesType.NO, -1, null));
+                          DocValuesType.NONE, -1, null));
       }
       TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);
       PositionIncrementAttribute posIncrAttribute = stream.addAttribute(PositionIncrementAttribute.class);
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
index f1bdc7f..65c140c 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
@@ -433,7 +433,7 @@ public class TestMemoryIndexAgainstRAMDir extends BaseTokenStreamTestCase {
       Document nextDoc = lineFileDocs.nextDoc();
       Document doc = new Document();
       for (Field field : nextDoc.getFields()) {
-        if (field.fieldType().indexOptions() != IndexOptions.NO) {
+        if (field.fieldType().indexOptions() != IndexOptions.NONE) {
           doc.add(field);
           if (random().nextInt(3) == 0) {
             doc.add(field);  // randomly add the same field twice
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
index 24bdbbf..2342457 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
@@ -146,7 +146,7 @@ public class TestDocValuesFieldSources extends LuceneTestCase {
 
   public void test() throws IOException {
     for (DocValuesType type : DocValuesType.values()) {
-      if (type != DocValuesType.SORTED_SET && type != DocValuesType.SORTED_NUMERIC && type != DocValuesType.NO) {
+      if (type != DocValuesType.SORTED_SET && type != DocValuesType.SORTED_NUMERIC && type != DocValuesType.NONE) {
         test(type);
       }
     }
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
index ae0a143..06966c7 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
@@ -97,7 +97,7 @@ public class DistanceStrategyTest extends StrategyTestCase {
     if (strategy instanceof BBoxStrategy && random().nextBoolean()) {//disable indexing sometimes
       BBoxStrategy bboxStrategy = (BBoxStrategy)strategy;
       final FieldType fieldType = new FieldType(bboxStrategy.getFieldType());
-      fieldType.setIndexOptions(IndexOptions.NO);
+      fieldType.setIndexOptions(IndexOptions.NONE);
       bboxStrategy.setFieldType(fieldType);
     }
   }
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java b/lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
index 33b02dc..fe9339d 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
@@ -112,7 +112,7 @@ public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
     if (random().nextBoolean()) {
       BBoxStrategy bboxStrategy = (BBoxStrategy) strategy;
       FieldType fieldType = new FieldType(bboxStrategy.getFieldType());
-      fieldType.setDocValueType(DocValuesType.NO);
+      fieldType.setDocValueType(DocValuesType.NONE);
       bboxStrategy.setFieldType(fieldType);
     }
     for (SpatialOperation operation : SpatialOperation.values()) {
@@ -294,7 +294,7 @@ public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
     BBoxStrategy bboxStrategy = (BBoxStrategy) strategy;
     if (random().nextBoolean()) {
       FieldType fieldType = new FieldType(bboxStrategy.getFieldType());
-      fieldType.setIndexOptions(IndexOptions.NO);
+      fieldType.setIndexOptions(IndexOptions.NONE);
       bboxStrategy.setFieldType(fieldType);
     }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingDocValuesFormat.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingDocValuesFormat.java
index 4910049..b8d04b1 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingDocValuesFormat.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingDocValuesFormat.java
@@ -270,7 +270,7 @@ public class AssertingDocValuesFormat extends DocValuesFormat {
     
     @Override
     public Bits getDocsWithField(FieldInfo field) throws IOException {
-      assert field.getDocValuesType() != DocValuesType.NO;
+      assert field.getDocValuesType() != DocValuesType.NONE;
       Bits bits = in.getDocsWithField(field);
       assert bits != null;
       assert bits.length() == maxDoc;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java
index 211bf45..aab2367 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java
@@ -82,7 +82,7 @@ public abstract class BaseFieldInfoFormatTestCase extends BaseIndexFileFormatTes
     for (String field : fieldNames) {
       IndexableFieldType fieldType = randomFieldType(random());
       FieldInfo fi = builder.addOrUpdate(field, fieldType);
-      if (fieldType.indexOptions() != IndexOptions.NO && fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
+      if (fieldType.indexOptions() != IndexOptions.NONE && fieldType.indexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
         if (random().nextBoolean()) {
           fi.setStorePayloads();
         }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
index 8f3efca..b6be6f2 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
@@ -371,7 +371,7 @@ public abstract class BasePostingsFormatTestCase extends BaseIndexFileFormatTest
 
       fieldInfoArray[fieldUpto] = new FieldInfo(field, fieldUpto, false, false, true,
                                                 IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS,
-                                                DocValuesType.NO, -1, null);
+                                                DocValuesType.NONE, -1, null);
       fieldUpto++;
 
       SortedMap<BytesRef,SeedAndOrd> postings = new TreeMap<>();
@@ -698,7 +698,7 @@ public abstract class BasePostingsFormatTestCase extends BaseIndexFileFormatTest
                                                    false,
                                                    doPayloads,
                                                    indexOptions,
-                                                   DocValuesType.NO,
+                                                   DocValuesType.NONE,
                                                    -1,
                                                    null);
     }
@@ -1735,7 +1735,7 @@ public abstract class BasePostingsFormatTestCase extends BaseIndexFileFormatTest
   @Override
   protected void addRandomFields(Document doc) {
     for (IndexOptions opts : IndexOptions.values()) {
-      if (opts == IndexOptions.NO) {
+      if (opts == IndexOptions.NONE) {
         continue;
       }
       FieldType ft = new FieldType();
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
index 318ce6a..7ac7a0d 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase.java
@@ -320,7 +320,7 @@ public abstract class BaseStoredFieldsFormatTestCase extends BaseIndexFileFormat
     w.addDocument(doc);
     IndexReader r = w.getReader();
     w.close();
-    assertEquals(IndexOptions.NO, r.document(0).getField("field").fieldType().indexOptions());
+    assertEquals(IndexOptions.NONE, r.document(0).getField("field").fieldType().indexOptions());
     assertNotNull(r.document(0).getField("field2").fieldType().indexOptions());
     r.close();
     dir.close();
@@ -515,7 +515,7 @@ public abstract class BaseStoredFieldsFormatTestCase extends BaseIndexFileFormat
     }
 
     final FieldType type = new FieldType(StringField.TYPE_STORED);
-    type.setIndexOptions(IndexOptions.NO);
+    type.setIndexOptions(IndexOptions.NONE);
     type.freeze();
     IntField id = new IntField("id", 0, Store.YES);
     for (int i = 0; i < data.length; ++i) {
@@ -605,7 +605,7 @@ public abstract class BaseStoredFieldsFormatTestCase extends BaseIndexFileFormat
     bigDoc2.add(idField);
 
     final FieldType onlyStored = new FieldType(StringField.TYPE_STORED);
-    onlyStored.setIndexOptions(IndexOptions.NO);
+    onlyStored.setIndexOptions(IndexOptions.NONE);
 
     final Field smallField = new Field("fld", randomByteArray(random().nextInt(10), 256), onlyStored);
     final int numFields = RandomInts.randomIntBetween(random(), 500000, 1000000);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/DocHelper.java b/lucene/test-framework/src/java/org/apache/lucene/index/DocHelper.java
index 28ceb6c..39ef70f 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/DocHelper.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/DocHelper.java
@@ -203,10 +203,10 @@ class DocHelper {
     for (int i=0; i<fields.length; i++) {
       IndexableField f = fields[i];
       add(all,f);
-      if (f.fieldType().indexOptions() != IndexOptions.NO) add(indexed,f);
+      if (f.fieldType().indexOptions() != IndexOptions.NONE) add(indexed,f);
       else add(unindexed,f);
       if (f.fieldType().storeTermVectors()) add(termvector,f);
-      if (f.fieldType().indexOptions() != IndexOptions.NO && !f.fieldType().storeTermVectors()) add(notermvector,f);
+      if (f.fieldType().indexOptions() != IndexOptions.NONE && !f.fieldType().storeTermVectors()) add(notermvector,f);
       if (f.fieldType().stored()) add(stored,f);
       else add(unstored,f);
       if (f.fieldType().indexOptions() == IndexOptions.DOCS) add(noTf,f);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index 679cd2e..4af462e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -1340,7 +1340,7 @@ public abstract class LuceneTestCase extends Assert {
   /** Returns a FieldType derived from newType but whose
    *  term vector options match the old type */
   private static FieldType mergeTermVectorOptions(FieldType newType, FieldType oldType) {
-    if (newType.indexOptions() != IndexOptions.NO && oldType.storeTermVectors() == true && newType.storeTermVectors() == false) {
+    if (newType.indexOptions() != IndexOptions.NONE && oldType.storeTermVectors() == true && newType.storeTermVectors() == false) {
       newType = new FieldType(newType);
       newType.setStoreTermVectors(oldType.storeTermVectors());
       newType.setStoreTermVectorPositions(oldType.storeTermVectorPositions());
@@ -1365,7 +1365,7 @@ public abstract class LuceneTestCase extends Assert {
 
     FieldType prevType = fieldToType.get(name);
 
-    if (usually(random) || type.indexOptions() == IndexOptions.NO || prevType != null) {
+    if (usually(random) || type.indexOptions() == IndexOptions.NONE || prevType != null) {
       // most of the time, don't modify the params
       if (prevType == null) {
         fieldToType.put(name, new FieldType(type));
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
index 323c434..d82e1c7 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
@@ -889,7 +889,7 @@ public final class TestUtil {
       final Field field2;
       final DocValuesType dvType = field1.fieldType().docValueType();
       final NumericType numType = field1.fieldType().numericType();
-      if (dvType != DocValuesType.NO) {
+      if (dvType != DocValuesType.NONE) {
         switch(dvType) {
           case NUMERIC:
             field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
index 65cf1ef..307b272 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
@@ -177,10 +177,10 @@ public class LukeRequestHandler extends RequestHandlerBase
 
     StringBuilder flags = new StringBuilder();
 
-    flags.append( (f != null && f.fieldType().indexOptions() != IndexOptions.NO)                     ? FieldFlag.INDEXED.getAbbreviation() : '-' );
+    flags.append( (f != null && f.fieldType().indexOptions() != IndexOptions.NONE)                     ? FieldFlag.INDEXED.getAbbreviation() : '-' );
     flags.append( (f != null && f.fieldType().tokenized())                   ? FieldFlag.TOKENIZED.getAbbreviation() : '-' );
     flags.append( (f != null && f.fieldType().stored())                      ? FieldFlag.STORED.getAbbreviation() : '-' );
-    flags.append( (f != null && f.fieldType().docValueType() != DocValuesType.NO)        ? FieldFlag.DOC_VALUES.getAbbreviation() : "-" );
+    flags.append( (f != null && f.fieldType().docValueType() != DocValuesType.NONE)        ? FieldFlag.DOC_VALUES.getAbbreviation() : "-" );
     flags.append( (false)                                          ? FieldFlag.MULTI_VALUED.getAbbreviation() : '-' ); // SchemaField Specific
     flags.append( (f != null && f.fieldType().storeTermVectors())            ? FieldFlag.TERM_VECTOR_STORED.getAbbreviation() : '-' );
     flags.append( (f != null && f.fieldType().storeTermVectorOffsets())   ? FieldFlag.TERM_VECTOR_OFFSET.getAbbreviation() : '-' );
diff --git a/solr/core/src/java/org/apache/solr/schema/EnumField.java b/solr/core/src/java/org/apache/solr/schema/EnumField.java
index 6a107f1..ec3a365 100644
--- a/solr/core/src/java/org/apache/solr/schema/EnumField.java
+++ b/solr/core/src/java/org/apache/solr/schema/EnumField.java
@@ -385,7 +385,7 @@ public class EnumField extends PrimitiveFieldType {
     newType.setTokenized(field.isTokenized());
     newType.setStored(field.stored());
     newType.setOmitNorms(field.omitNorms());
-    newType.setIndexOptions(field.indexed() ? getIndexOptions(field, intAsString) : IndexOptions.NO);
+    newType.setIndexOptions(field.indexed() ? getIndexOptions(field, intAsString) : IndexOptions.NONE);
     newType.setStoreTermVectors(field.storeTermVector());
     newType.setStoreTermVectorOffsets(field.storeTermOffsets());
     newType.setStoreTermVectorPositions(field.storeTermPositions());
diff --git a/solr/core/src/java/org/apache/solr/schema/FieldType.java b/solr/core/src/java/org/apache/solr/schema/FieldType.java
index 437ce96..70ab20f 100644
--- a/solr/core/src/java/org/apache/solr/schema/FieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/FieldType.java
@@ -268,7 +268,7 @@ public abstract class FieldType extends FieldProperties {
     newType.setTokenized(field.isTokenized());
     newType.setStored(field.stored());
     newType.setOmitNorms(field.omitNorms());
-    newType.setIndexOptions(field.indexed() ? getIndexOptions(field, val) : IndexOptions.NO);
+    newType.setIndexOptions(field.indexed() ? getIndexOptions(field, val) : IndexOptions.NONE);
     newType.setStoreTermVectors(field.storeTermVector());
     newType.setStoreTermVectorOffsets(field.storeTermOffsets());
     newType.setStoreTermVectorPositions(field.storeTermPositions());
diff --git a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
index 25c47cb..0325d14 100644
--- a/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
+++ b/solr/core/src/java/org/apache/solr/schema/PreAnalyzedField.java
@@ -250,7 +250,7 @@ public class PreAnalyzedField extends FieldType {
         }
       } else {
         if (f != null) {
-          f.fieldType().setIndexOptions(IndexOptions.NO);
+          f.fieldType().setIndexOptions(IndexOptions.NONE);
           f.fieldType().setTokenized(false);
         }
       }
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieField.java b/solr/core/src/java/org/apache/solr/schema/TrieField.java
index f26e98e..f8df52f 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -602,7 +602,7 @@ public class TrieField extends PrimitiveFieldType {
     ft.setStored(stored);
     ft.setTokenized(true);
     ft.setOmitNorms(field.omitNorms());
-    ft.setIndexOptions(indexed ? getIndexOptions(field, value.toString()) : IndexOptions.NO);
+    ft.setIndexOptions(indexed ? getIndexOptions(field, value.toString()) : IndexOptions.NONE);
 
     switch (type) {
       case INTEGER:
diff --git a/solr/core/src/java/org/apache/solr/search/Insanity.java b/solr/core/src/java/org/apache/solr/search/Insanity.java
index d4d528b..99cf08f 100644
--- a/solr/core/src/java/org/apache/solr/search/Insanity.java
+++ b/solr/core/src/java/org/apache/solr/search/Insanity.java
@@ -66,7 +66,7 @@ public class Insanity {
       for (FieldInfo fi : in.getFieldInfos()) {
         if (fi.name.equals(insaneField)) {
           filteredInfos.add(new FieldInfo(fi.name, fi.number, fi.hasVectors(), fi.omitsNorms(),
-                                          fi.hasPayloads(), fi.getIndexOptions(), DocValuesType.NO, -1, null));
+                                          fi.hasPayloads(), fi.getIndexOptions(), DocValuesType.NONE, -1, null));
         } else {
           filteredInfos.add(fi);
         }

