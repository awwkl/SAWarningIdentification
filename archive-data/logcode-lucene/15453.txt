GitDiffStart: f9ed2c19cd72f4f6fd37f609f2b2c2b10ceb350c | Wed Jun 22 01:48:45 2011 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 6105f6a..579daf9 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -284,6 +284,10 @@ API Changes
 * LUCENE-2953: In addition to changes in 3.x, PriorityQueue#initialize(int)
   function was moved into the ctor. (Uwe Schindler, Yonik Seeley)
 
+* LUCENE-3219: SortField type properties have been moved to an enum
+  SortField.Type.  In be consistent, CachedArrayCreator.getSortTypeID() has
+  been changed CachedArrayCreator.getSortType(). (Chris Male)
+
 New features
 
 * LUCENE-2604: Added RegexpQuery support to QueryParser. Regular expressions
diff --git a/lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java b/lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java
index 6b1af4c..eb7ed67 100644
--- a/lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java
+++ b/lucene/contrib/misc/src/test/org/apache/lucene/index/TestNRTManager.java
@@ -672,7 +672,7 @@ public class TestNRTManager extends LuceneTestCase {
 
   private int runQuery(IndexSearcher s, Query q) throws Exception {
     s.search(q, 10);
-    return s.search(q, null, 10, new Sort(new SortField("title", SortField.STRING))).totalHits;
+    return s.search(q, null, 10, new Sort(new SortField("title", SortField.Type.STRING))).totalHits;
   }
 
   private void smokeTestSearcher(IndexSearcher s) throws Exception {
diff --git a/lucene/src/java/org/apache/lucene/search/SortField.java b/lucene/src/java/org/apache/lucene/search/SortField.java
index b345675..6473376 100644
--- a/lucene/src/java/org/apache/lucene/search/SortField.java
+++ b/lucene/src/java/org/apache/lucene/search/SortField.java
@@ -39,69 +39,70 @@ import org.apache.lucene.util.StringHelper;
  */
 public class SortField {
 
-  /** Sort by document score (relevance).  Sort values are Float and higher
-   * values are at the front. */
-  public static final int SCORE = 0;
+  public static enum Type {
 
-  /** Sort by document number (index order).  Sort values are Integer and lower
-   * values are at the front. */
-  public static final int DOC = 1;
+    /** Sort by document score (relevance).  Sort values are Float and higher
+     * values are at the front. */
+    SCORE,
 
-  // reserved, in Lucene 2.9, there was a constant: AUTO = 2;
+    /** Sort by document number (index order).  Sort values are Integer and lower
+     * values are at the front. */
+    DOC,
 
-  /** Sort using term values as Strings.  Sort values are String and lower
-   * values are at the front. */
-  public static final int STRING = 3;
+    /** Sort using term values as Strings.  Sort values are String and lower
+     * values are at the front. */
+    STRING,
 
-  /** Sort using term values as encoded Integers.  Sort values are Integer and
-   * lower values are at the front. */
-  public static final int INT = 4;
+    /** Sort using term values as encoded Integers.  Sort values are Integer and
+     * lower values are at the front. */
+    INT,
 
-  /** Sort using term values as encoded Floats.  Sort values are Float and
-   * lower values are at the front. */
-  public static final int FLOAT = 5;
+    /** Sort using term values as encoded Floats.  Sort values are Float and
+     * lower values are at the front. */
+    FLOAT,
 
-  /** Sort using term values as encoded Longs.  Sort values are Long and
-   * lower values are at the front. */
-  public static final int LONG = 6;
+    /** Sort using term values as encoded Longs.  Sort values are Long and
+     * lower values are at the front. */
+    LONG,
 
-  /** Sort using term values as encoded Doubles.  Sort values are Double and
-   * lower values are at the front. */
-  public static final int DOUBLE = 7;
+    /** Sort using term values as encoded Doubles.  Sort values are Double and
+     * lower values are at the front. */
+    DOUBLE,
 
-  /** Sort using term values as encoded Shorts.  Sort values are Short and
-   * lower values are at the front. */
-  public static final int SHORT = 8;
+    /** Sort using term values as encoded Shorts.  Sort values are Short and
+     * lower values are at the front. */
+    SHORT,
 
-  /** Sort using a custom Comparator.  Sort values are any Comparable and
-   * sorting is done according to natural order. */
-  public static final int CUSTOM = 9;
+    /** Sort using a custom Comparator.  Sort values are any Comparable and
+     * sorting is done according to natural order. */
+    CUSTOM,
 
-  /** Sort using term values as encoded Bytes.  Sort values are Byte and
-   * lower values are at the front. */
-  public static final int BYTE = 10;
-  
-  /** Sort using term values as Strings, but comparing by
-   * value (using String.compareTo) for all comparisons.
-   * This is typically slower than {@link #STRING}, which
-   * uses ordinals to do the sorting. */
-  public static final int STRING_VAL = 11;
+    /** Sort using term values as encoded Bytes.  Sort values are Byte and
+     * lower values are at the front. */
+    BYTE,
+
+    /** Sort using term values as Strings, but comparing by
+     * value (using String.compareTo) for all comparisons.
+     * This is typically slower than {@link #STRING}, which
+     * uses ordinals to do the sorting. */
+    STRING_VAL,
 
-  /** Sort use byte[] index values. */
-  public static final int BYTES = 12;
+    /** Sort use byte[] index values. */
+    BYTES,
 
-  /** Force rewriting of SortField using {@link SortField#rewrite(IndexSearcher)}
-   * before it can be used for sorting */
-  public static final int REWRITEABLE = 13;
+    /** Force rewriting of SortField using {@link SortField#rewrite(IndexSearcher)}
+     * before it can be used for sorting */
+    REWRITEABLE
+  }
 
   /** Represents sorting by document score (relevance). */
-  public static final SortField FIELD_SCORE = new SortField(null, SCORE);
+  public static final SortField FIELD_SCORE = new SortField(null, Type.SCORE);
 
   /** Represents sorting by document number (index order). */
-  public static final SortField FIELD_DOC = new SortField(null, DOC);
+  public static final SortField FIELD_DOC = new SortField(null, Type.DOC);
 
   private String field;
-  private int type;  // defaults to determining type dynamically
+  private Type type;  // defaults to determining type dynamically
   boolean reverse = false;  // defaults to natural order
   private CachedArrayCreator<?> creator;
   public Object missingValue = null; // used for 'sortMissingFirst/Last'
@@ -115,7 +116,7 @@ public class SortField {
    *               <code>type</code> is SCORE or DOC.
    * @param type   Type of values in the terms.
    */
-  public SortField(String field, int type) {
+  public SortField(String field, Type type) {
     initFieldType(field, type);
   }
 
@@ -126,7 +127,7 @@ public class SortField {
    * @param type   Type of values in the terms.
    * @param reverse True if natural order should be reversed.
    */
-  public SortField(String field, int type, boolean reverse) {
+  public SortField(String field, Type type, boolean reverse) {
     initFieldType(field, type);
     this.reverse = reverse;
   }
@@ -170,32 +171,27 @@ public class SortField {
     this.reverse = reverse;
     
     if (parser instanceof FieldCache.IntParser) {
-      this.type = INT;
       this.creator = new IntValuesCreator( field, (FieldCache.IntParser)parser );
     }
     else if (parser instanceof FieldCache.FloatParser) {
-      this.type = FLOAT;
       this.creator = new FloatValuesCreator( field, (FieldCache.FloatParser)parser );
     }
     else if (parser instanceof FieldCache.ShortParser) {
-      this.type = SHORT;
       this.creator = new ShortValuesCreator( field, (FieldCache.ShortParser)parser );
     }
     else if (parser instanceof FieldCache.ByteParser) {
-      this.type = BYTE;
       this.creator = new ByteValuesCreator( field, (FieldCache.ByteParser)parser );
     }
     else if (parser instanceof FieldCache.LongParser) {
-      this.type = LONG;
       this.creator = new LongValuesCreator( field, (FieldCache.LongParser)parser );
     }
     else if (parser instanceof FieldCache.DoubleParser) {
-      this.type = DOUBLE;
       this.creator = new DoubleValuesCreator( field, (FieldCache.DoubleParser)parser );
     }
     else
       throw new IllegalArgumentException("Parser instance does not subclass existing numeric parser from FieldCache (got " + parser + ")");
 
+    this.type = this.creator.getSortType();
   }
   
   /**
@@ -208,7 +204,7 @@ public class SortField {
     this.field = creator.field;
     this.reverse = reverse;
     this.creator = creator;
-    this.type = creator.getSortTypeID();
+    this.type = creator.getSortType();
   }
   
   public SortField setMissingValue( Object v )
@@ -230,7 +226,7 @@ public class SortField {
    * @param comparator Returns a comparator for sorting hits.
    */
   public SortField(String field, FieldComparatorSource comparator) {
-    initFieldType(field, CUSTOM);
+    initFieldType(field, Type.CUSTOM);
     this.comparatorSource = comparator;
   }
 
@@ -240,17 +236,17 @@ public class SortField {
    * @param reverse True if natural order should be reversed.
    */
   public SortField(String field, FieldComparatorSource comparator, boolean reverse) {
-    initFieldType(field, CUSTOM);
+    initFieldType(field, Type.CUSTOM);
     this.reverse = reverse;
     this.comparatorSource = comparator;
   }
 
   // Sets field & type, and ensures field is not NULL unless
   // type is SCORE or DOC
-  private void initFieldType(String field, int type) {
+  private void initFieldType(String field, Type type) {
     this.type = type;
     if (field == null) {
-      if (type != SCORE && type != DOC)
+      if (type != Type.SCORE && type != Type.DOC)
         throw new IllegalArgumentException("field can only be null when type is SCORE or DOC");
     } else {
       this.field = field;
@@ -280,7 +276,7 @@ public class SortField {
   /** Returns the type of contents in the field.
    * @return One of the constants SCORE, DOC, STRING, INT or FLOAT.
    */
-  public int getType() {
+  public Type getType() {
     return type;
   }
 
@@ -396,7 +392,7 @@ public class SortField {
    *  used). */
   @Override
   public int hashCode() {
-    int hash=type^0x346565dd + Boolean.valueOf(reverse).hashCode()^0xaf5998bb;
+    int hash = type.hashCode() ^ 0x346565dd + Boolean.valueOf(reverse).hashCode() ^ 0xaf5998bb;
     if (field != null) hash += field.hashCode()^0xff5685dd;
     if (comparatorSource != null) hash += comparatorSource.hashCode();
     if (creator != null) hash += creator.hashCode()^0x3aaf56ff;
@@ -438,49 +434,49 @@ public class SortField {
   public FieldComparator getComparator(final int numHits, final int sortPos) throws IOException {
 
     switch (type) {
-    case SortField.SCORE:
+    case SCORE:
       return new FieldComparator.RelevanceComparator(numHits);
 
-    case SortField.DOC:
+    case DOC:
       return new FieldComparator.DocComparator(numHits);
 
-    case SortField.INT:
+    case INT:
       if (useIndexValues) {
         return new FieldComparator.IntDocValuesComparator(numHits, field);
       } else {
         return new FieldComparator.IntComparator(numHits, (IntValuesCreator)creator, (Integer) missingValue);
       }
 
-    case SortField.FLOAT:
+    case FLOAT:
       if (useIndexValues) {
         return new FieldComparator.FloatDocValuesComparator(numHits, field);
       } else {
         return new FieldComparator.FloatComparator(numHits, (FloatValuesCreator) creator, (Float) missingValue);
       }
 
-    case SortField.LONG:
+    case LONG:
       return new FieldComparator.LongComparator(numHits, (LongValuesCreator)creator, (Long)missingValue );
 
-    case SortField.DOUBLE:
+    case DOUBLE:
       return new FieldComparator.DoubleComparator(numHits, (DoubleValuesCreator)creator, (Double)missingValue );
 
-    case SortField.BYTE:
+    case BYTE:
       return new FieldComparator.ByteComparator(numHits, (ByteValuesCreator)creator, (Byte)missingValue );
 
-    case SortField.SHORT:
+    case SHORT:
       return new FieldComparator.ShortComparator(numHits, (ShortValuesCreator)creator, (Short)missingValue );
 
-    case SortField.CUSTOM:
+    case CUSTOM:
       assert comparatorSource != null;
       return comparatorSource.newComparator(field, numHits, sortPos, reverse);
 
-    case SortField.STRING:
+    case STRING:
       return new FieldComparator.TermOrdValComparator(numHits, field, sortPos, reverse);
 
-    case SortField.STRING_VAL:
+    case STRING_VAL:
       return new FieldComparator.TermValComparator(numHits, field);
 
-    case SortField.REWRITEABLE:
+    case REWRITEABLE:
       throw new IllegalStateException("SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)");
         
     default:
@@ -491,7 +487,7 @@ public class SortField {
   /**
    * Rewrites this SortField, returning a new SortField if a change is made.
    * Subclasses should override this define their rewriting behavior when this
-   * SortField is of type {@link SortField#REWRITEABLE}
+   * SortField is of type {@link SortField.Type#REWRITEABLE}
    *
    * @param searcher IndexSearcher to use during rewriting
    * @return New rewritten SortField, or {@code this} if nothing has changed.
diff --git a/lucene/src/java/org/apache/lucene/search/cache/ByteValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/ByteValuesCreator.java
index 11bde67..05555de 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/ByteValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/ByteValuesCreator.java
@@ -61,8 +61,8 @@ public class ByteValuesCreator extends CachedArrayCreator<ByteValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.BYTE;
+  public SortField.Type getSortType() {
+    return SortField.Type.BYTE;
   }
 
   //--------------------------------------------------------------------------------
@@ -143,4 +143,4 @@ public class ByteValuesCreator extends CachedArrayCreator<ByteValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator.java b/lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator.java
index 3129c75..5b17cd8 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/CachedArrayCreator.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.FieldCache.Parser;
+import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.OpenBitSet;
@@ -73,7 +74,7 @@ public abstract class CachedArrayCreator<T extends CachedArray> extends EntryCre
   /** Return the type that the array will hold */
   public abstract Class getArrayType();
   public abstract Parser getParser();
-  public abstract int getSortTypeID();
+  public abstract SortField.Type getSortType();
 
   protected void setParserAndResetCounts(T value, Parser parser)
   {
diff --git a/lucene/src/java/org/apache/lucene/search/cache/DoubleValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/DoubleValuesCreator.java
index 13a8558..9e018a4 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/DoubleValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/DoubleValuesCreator.java
@@ -61,8 +61,8 @@ public class DoubleValuesCreator extends CachedArrayCreator<DoubleValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.DOUBLE;
+  public SortField.Type getSortType() {
+    return SortField.Type.DOUBLE;
   }
 
   //--------------------------------------------------------------------------------
@@ -161,4 +161,4 @@ public class DoubleValuesCreator extends CachedArrayCreator<DoubleValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/java/org/apache/lucene/search/cache/FloatValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/FloatValuesCreator.java
index bfd6f07..40909cc 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/FloatValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/FloatValuesCreator.java
@@ -61,8 +61,8 @@ public class FloatValuesCreator extends CachedArrayCreator<FloatValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.FLOAT;
+  public SortField.Type getSortType() {
+    return SortField.Type.FLOAT;
   }
 
 
@@ -162,4 +162,4 @@ public class FloatValuesCreator extends CachedArrayCreator<FloatValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/java/org/apache/lucene/search/cache/IntValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/IntValuesCreator.java
index 7c41f4f..1699b11 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/IntValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/IntValuesCreator.java
@@ -61,8 +61,8 @@ public class IntValuesCreator extends CachedArrayCreator<IntValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.INT;
+  public SortField.Type getSortType() {
+    return SortField.Type.INT;
   }
 
 
@@ -162,4 +162,4 @@ public class IntValuesCreator extends CachedArrayCreator<IntValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/java/org/apache/lucene/search/cache/LongValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/LongValuesCreator.java
index 27c1672..caf14e0 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/LongValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/LongValuesCreator.java
@@ -61,8 +61,8 @@ public class LongValuesCreator extends CachedArrayCreator<LongValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.LONG;
+  public SortField.Type getSortType() {
+    return SortField.Type.LONG;
   }
 
 
@@ -162,4 +162,4 @@ public class LongValuesCreator extends CachedArrayCreator<LongValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/java/org/apache/lucene/search/cache/ShortValuesCreator.java b/lucene/src/java/org/apache/lucene/search/cache/ShortValuesCreator.java
index 88c776b..d042522 100644
--- a/lucene/src/java/org/apache/lucene/search/cache/ShortValuesCreator.java
+++ b/lucene/src/java/org/apache/lucene/search/cache/ShortValuesCreator.java
@@ -61,8 +61,8 @@ public class ShortValuesCreator extends CachedArrayCreator<ShortValues>
   }
   
   @Override
-  public int getSortTypeID() {
-    return SortField.SHORT;
+  public SortField.Type getSortType() {
+    return SortField.Type.SHORT;
   }
 
 
@@ -144,4 +144,4 @@ public class ShortValuesCreator extends CachedArrayCreator<ShortValues>
       vals.valid = new Bits.MatchNoBits( maxDoc );
     }
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/src/test/org/apache/lucene/TestSearch.java b/lucene/src/test/org/apache/lucene/TestSearch.java
index a79b5c2..3ee5447 100644
--- a/lucene/src/test/org/apache/lucene/TestSearch.java
+++ b/lucene/src/test/org/apache/lucene/TestSearch.java
@@ -112,7 +112,7 @@ public class TestSearch extends LuceneTestCase {
 
       Sort sort = new Sort(new SortField[] {
           SortField.FIELD_SCORE,
-          new SortField("id", SortField.INT)});
+          new SortField("id", SortField.Type.INT)});
 
       QueryParser parser = new QueryParser(TEST_VERSION_CURRENT, "contents", analyzer);
       parser.setPhraseSlop(4);
diff --git a/lucene/src/test/org/apache/lucene/TestSearchForDuplicates.java b/lucene/src/test/org/apache/lucene/TestSearchForDuplicates.java
index 1209642..29befca 100644
--- a/lucene/src/test/org/apache/lucene/TestSearchForDuplicates.java
+++ b/lucene/src/test/org/apache/lucene/TestSearchForDuplicates.java
@@ -112,7 +112,7 @@ public class TestSearchForDuplicates extends LuceneTestCase {
 
       final Sort sort = new Sort(new SortField[] {
           SortField.FIELD_SCORE,
-          new SortField(ID_FIELD, SortField.INT)});
+          new SortField(ID_FIELD, SortField.Type.INT)});
 
       ScoreDoc[] hits = searcher.search(query, null, MAX_DOCS, sort).scoreDocs;
       printHits(out, hits, searcher);
diff --git a/lucene/src/test/org/apache/lucene/index/TestNRTThreads.java b/lucene/src/test/org/apache/lucene/index/TestNRTThreads.java
index aec6c68..fdbf16e 100644
--- a/lucene/src/test/org/apache/lucene/index/TestNRTThreads.java
+++ b/lucene/src/test/org/apache/lucene/index/TestNRTThreads.java
@@ -579,7 +579,7 @@ public class TestNRTThreads extends LuceneTestCase {
 
   private int runQuery(IndexSearcher s, Query q) throws Exception {
     s.search(q, 10);
-    return s.search(q, null, 10, new Sort(new SortField("title", SortField.STRING))).totalHits;
+    return s.search(q, null, 10, new Sort(new SortField("title", SortField.Type.STRING))).totalHits;
   }
 
   private void smokeTestReader(IndexReader r) throws Exception {
diff --git a/lucene/src/test/org/apache/lucene/search/TestCustomSearcherSort.java b/lucene/src/test/org/apache/lucene/search/TestCustomSearcherSort.java
index 38c60c5..f78f07e 100644
--- a/lucene/src/test/org/apache/lucene/search/TestCustomSearcherSort.java
+++ b/lucene/src/test/org/apache/lucene/search/TestCustomSearcherSort.java
@@ -86,7 +86,7 @@ public class TestCustomSearcherSort extends LuceneTestCase {
     // log("Run testFieldSortCustomSearcher");
     // define the sort criteria
     Sort custSort = new Sort(
-        new SortField("publicationDate_", SortField.STRING),
+        new SortField("publicationDate_", SortField.Type.STRING),
         SortField.FIELD_SCORE);
     IndexSearcher searcher = new CustomSearcher(reader, 2);
     // search and check hits
@@ -100,7 +100,7 @@ public class TestCustomSearcherSort extends LuceneTestCase {
     // log("Run testFieldSortSingleSearcher");
     // define the sort criteria
     Sort custSort = new Sort(
-        new SortField("publicationDate_", SortField.STRING),
+        new SortField("publicationDate_", SortField.Type.STRING),
         SortField.FIELD_SCORE);
     IndexSearcher searcher = new CustomSearcher(reader, 2);
     // search and check hits
diff --git a/lucene/src/test/org/apache/lucene/search/TestDateSort.java b/lucene/src/test/org/apache/lucene/search/TestDateSort.java
index 45e0d8a..72719a0 100644
--- a/lucene/src/test/org/apache/lucene/search/TestDateSort.java
+++ b/lucene/src/test/org/apache/lucene/search/TestDateSort.java
@@ -79,7 +79,7 @@ public class TestDateSort extends LuceneTestCase {
   public void testReverseDateSort() throws Exception {
     IndexSearcher searcher = newSearcher(reader);
 
-    Sort sort = new Sort(new SortField(DATE_TIME_FIELD, SortField.STRING, true));
+    Sort sort = new Sort(new SortField(DATE_TIME_FIELD, SortField.Type.STRING, true));
 
     QueryParser queryParser = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD, new MockAnalyzer(random));
     Query query = queryParser.parse("Document");
diff --git a/lucene/src/test/org/apache/lucene/search/TestElevationComparator.java b/lucene/src/test/org/apache/lucene/search/TestElevationComparator.java
index 23e1afb..32d1407 100644
--- a/lucene/src/test/org/apache/lucene/search/TestElevationComparator.java
+++ b/lucene/src/test/org/apache/lucene/search/TestElevationComparator.java
@@ -73,7 +73,7 @@ public class TestElevationComparator extends LuceneTestCase {
 
     Sort sort = new Sort(
         new SortField("id", new ElevationComparatorSource(priority), false),
-        new SortField(null, SortField.SCORE, reversed)
+        new SortField(null, SortField.Type.SCORE, reversed)
       );
 
     TopDocsCollector<Entry> topCollector = TopFieldCollector.create(sort, 50, false, true, true, true);
diff --git a/lucene/src/test/org/apache/lucene/search/TestFilteredQuery.java b/lucene/src/test/org/apache/lucene/search/TestFilteredQuery.java
index 3062720..b901d2f 100644
--- a/lucene/src/test/org/apache/lucene/search/TestFilteredQuery.java
+++ b/lucene/src/test/org/apache/lucene/search/TestFilteredQuery.java
@@ -115,7 +115,7 @@ public class TestFilteredQuery extends LuceneTestCase {
     assertEquals (1, hits[0].doc);
     QueryUtils.check(random, filteredquery,searcher);
 
-    hits = searcher.search (filteredquery, null, 1000, new Sort(new SortField("sorter", SortField.STRING))).scoreDocs;
+    hits = searcher.search (filteredquery, null, 1000, new Sort(new SortField("sorter", SortField.Type.STRING))).scoreDocs;
     assertEquals (1, hits.length);
     assertEquals (1, hits[0].doc);
 
diff --git a/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java b/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
index 23a0004..37da532 100644
--- a/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
+++ b/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
@@ -498,7 +498,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
         int a=lower; lower=upper; upper=a;
       }
       Query tq=NumericRangeQuery.newIntRange(field, precisionStep, lower, upper, true, true);
-      TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.INT, true)));
+      TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.Type.INT, true)));
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
       assertNotNull(sd);
diff --git a/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java b/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
index d1b7cc6..d3e051d 100644
--- a/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
+++ b/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
@@ -530,7 +530,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
         long a=lower; lower=upper; upper=a;
       }
       Query tq=NumericRangeQuery.newLongRange(field, precisionStep, lower, upper, true, true);
-      TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.LONG, true)));
+      TopDocs topDocs = searcher.search(tq, null, noDocs, new Sort(new SortField(field, SortField.Type.LONG, true)));
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
       assertNotNull(sd);
diff --git a/lucene/src/test/org/apache/lucene/search/TestSort.java b/lucene/src/test/org/apache/lucene/search/TestSort.java
index 52059ff..30a0448 100644
--- a/lucene/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/src/test/org/apache/lucene/search/TestSort.java
@@ -283,44 +283,44 @@ public class TestSort extends LuceneTestCase {
   }
   // test sorts where the type of field is specified
   public void testTypedSort() throws Exception {
-    sort.setSort (new SortField ("int", SortField.INT), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "IGAEC");
     assertMatches (full, queryY, sort, "DHFJB");
     
-    sort.setSort (new SortField ("float", SortField.FLOAT), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "GCIEA");
     assertMatches (full, queryY, sort, "DHJFB");
 
-    sort.setSort (new SortField ("long", SortField.LONG), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("long", SortField.Type.LONG), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "EACGI");
     assertMatches (full, queryY, sort, "FBJHD");
 
-    sort.setSort (new SortField ("double", SortField.DOUBLE), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("double", SortField.Type.DOUBLE), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "AGICE");
     assertMatches (full, queryY, sort, "DJHBF");
     
-    sort.setSort (new SortField ("byte", SortField.BYTE), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("byte", SortField.Type.BYTE), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "CIGAE");
     assertMatches (full, queryY, sort, "DHFBJ");
 
-    sort.setSort (new SortField ("short", SortField.SHORT), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("short", SortField.Type.SHORT), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "IAGCE");
     assertMatches (full, queryY, sort, "DFHBJ");
 
-    sort.setSort (new SortField ("string", SortField.STRING), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("string", SortField.Type.STRING), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "AIGEC");
     assertMatches (full, queryY, sort, "DJHFB");
     
     if (supportsDocValues) {
-      sort.setSort (useDocValues(new SortField ("int", SortField.INT)), SortField.FIELD_DOC );
+      sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC );
       assertMatches (full, queryX, sort, "IGAEC");
       assertMatches (full, queryY, sort, "DHFJB");
       
-      sort.setSort (useDocValues(new SortField ("float", SortField.FLOAT)), SortField.FIELD_DOC );
+      sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)), SortField.FIELD_DOC );
       assertMatches (full, queryX, sort, "GCIEA");
       assertMatches (full, queryY, sort, "DHJFB");
       
-      sort.setSort (useDocValues(new SortField ("double", SortField.DOUBLE)), SortField.FIELD_DOC );
+      sort.setSort (useDocValues(new SortField ("double", SortField.Type.DOUBLE)), SortField.FIELD_DOC );
       assertMatches (full, queryX, sort, "AGICE");
       assertMatches (full, queryY, sort, "DJHBF");
     }
@@ -369,8 +369,8 @@ public class TestSort extends LuceneTestCase {
     ScoreDoc[] result = null;
     IndexSearcher searcher = getFullStrings();
     sort.setSort(
-        new SortField("string", SortField.STRING),
-        new SortField("string2", SortField.STRING, true),
+        new SortField("string", SortField.Type.STRING),
+        new SortField("string2", SortField.Type.STRING, true),
         SortField.FIELD_DOC);
 
     result = searcher.search(new MatchAllDocsQuery(), null, 500, sort).scoreDocs;
@@ -495,19 +495,19 @@ public class TestSort extends LuceneTestCase {
     sort.setSort(SortField.FIELD_DOC);
     assertMatches (empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("int", SortField.INT), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC );
     assertMatches (empty, queryX, sort, "");
     
-    sort.setSort (useDocValues(new SortField ("int", SortField.INT)), SortField.FIELD_DOC );
+    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC );
     assertMatches (empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("string", SortField.STRING, true), SortField.FIELD_DOC );
+    sort.setSort (new SortField ("string", SortField.Type.STRING, true), SortField.FIELD_DOC );
     assertMatches (empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("float", SortField.FLOAT), new SortField ("string", SortField.STRING) );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT), new SortField ("string", SortField.Type.STRING) );
     assertMatches (empty, queryX, sort, "");
     
-    sort.setSort (useDocValues(new SortField ("float", SortField.FLOAT)), new SortField ("string", SortField.STRING) );
+    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)), new SortField ("string", SortField.Type.STRING) );
     assertMatches (empty, queryX, sort, "");
   }
 
@@ -574,32 +574,32 @@ public class TestSort extends LuceneTestCase {
 
   // test sorts in reverse
   public void testReverseSort() throws Exception {
-    sort.setSort (new SortField (null, SortField.SCORE, true), SortField.FIELD_DOC );
+    sort.setSort (new SortField (null, SortField.Type.SCORE, true), SortField.FIELD_DOC );
     assertMatches (full, queryX, sort, "IEGCA");
     assertMatches (full, queryY, sort, "JFHDB");
 
-    sort.setSort (new SortField (null, SortField.DOC, true));
+    sort.setSort (new SortField (null, SortField.Type.DOC, true));
     assertMatches (full, queryX, sort, "IGECA");
     assertMatches (full, queryY, sort, "JHFDB");
 
-    sort.setSort (new SortField ("int", SortField.INT, true) );
+    sort.setSort (new SortField ("int", SortField.Type.INT, true) );
     assertMatches (full, queryX, sort, "CAEGI");
     assertMatches (full, queryY, sort, "BJFHD");
 
-    sort.setSort (new SortField ("float", SortField.FLOAT, true) );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT, true) );
     assertMatches (full, queryX, sort, "AECIG");
     assertMatches (full, queryY, sort, "BFJHD");
     
-    sort.setSort (new SortField ("string", SortField.STRING, true) );
+    sort.setSort (new SortField ("string", SortField.Type.STRING, true) );
     assertMatches (full, queryX, sort, "CEGIA");
     assertMatches (full, queryY, sort, "BFHJD");
     
     if (supportsDocValues) {
-      sort.setSort (useDocValues(new SortField ("int", SortField.INT, true)) );
+      sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT, true)) );
       assertMatches (full, queryX, sort, "CAEGI");
       assertMatches (full, queryY, sort, "BJFHD");
     
-      sort.setSort (useDocValues(new SortField ("float", SortField.FLOAT, true)) );
+      sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT, true)) );
       assertMatches (full, queryX, sort, "AECIG");
       assertMatches (full, queryY, sort, "BFJHD");
     }
@@ -607,62 +607,62 @@ public class TestSort extends LuceneTestCase {
 
   // test sorting when the sort field is empty (undefined) for some of the documents
   public void testEmptyFieldSort() throws Exception {
-    sort.setSort (new SortField ("string", SortField.STRING) );
+    sort.setSort (new SortField ("string", SortField.Type.STRING) );
     assertMatches (full, queryF, sort, "ZJI");
 
-    sort.setSort (new SortField ("string", SortField.STRING, true) );
+    sort.setSort (new SortField ("string", SortField.Type.STRING, true) );
     assertMatches (full, queryF, sort, "IJZ");
     
-    sort.setSort (new SortField ("int", SortField.INT) );
+    sort.setSort (new SortField ("int", SortField.Type.INT) );
     assertMatches (full, queryF, sort, "IZJ");
 
-    sort.setSort (new SortField ("int", SortField.INT, true) );
+    sort.setSort (new SortField ("int", SortField.Type.INT, true) );
     assertMatches (full, queryF, sort, "JZI");
 
-    sort.setSort (new SortField ("float", SortField.FLOAT) );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT) );
     assertMatches (full, queryF, sort, "ZJI");
 
     if (supportsDocValues) {
-      sort.setSort (useDocValues(new SortField ("int", SortField.INT)) );
+      sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)) );
       assertMatches (full, queryF, sort, "IZJ");
     
-      sort.setSort (useDocValues(new SortField ("float", SortField.FLOAT)) );
+      sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)) );
       assertMatches (full, queryF, sort, "ZJI");
     }
 
     // using a nonexisting field as first sort key shouldn't make a difference:
-    sort.setSort (new SortField ("nosuchfield", SortField.STRING),
-        new SortField ("float", SortField.FLOAT) );
+    sort.setSort (new SortField ("nosuchfield", SortField.Type.STRING),
+        new SortField ("float", SortField.Type.FLOAT) );
     assertMatches (full, queryF, sort, "ZJI");
 
-    sort.setSort (new SortField ("float", SortField.FLOAT, true) );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT, true) );
     assertMatches (full, queryF, sort, "IJZ");
 
     // When a field is null for both documents, the next SortField should be used.
                 // Works for
-    sort.setSort (new SortField ("int", SortField.INT),
-                                new SortField ("string", SortField.STRING),
-        new SortField ("float", SortField.FLOAT) );
+    sort.setSort (new SortField ("int", SortField.Type.INT),
+                                new SortField ("string", SortField.Type.STRING),
+        new SortField ("float", SortField.Type.FLOAT) );
     assertMatches (full, queryG, sort, "ZWXY");
 
     // Reverse the last criterium to make sure the test didn't pass by chance
-    sort.setSort (new SortField ("int", SortField.INT),
-                                new SortField ("string", SortField.STRING),
-        new SortField ("float", SortField.FLOAT, true) );
+    sort.setSort (new SortField ("int", SortField.Type.INT),
+                                new SortField ("string", SortField.Type.STRING),
+        new SortField ("float", SortField.Type.FLOAT, true) );
     assertMatches (full, queryG, sort, "ZYXW");
 
     // Do the same for a ParallelMultiSearcher
     ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random, 2, 8));
     IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);
 
-    sort.setSort (new SortField ("int", SortField.INT),
-                                new SortField ("string", SortField.STRING),
-        new SortField ("float", SortField.FLOAT) );
+    sort.setSort (new SortField ("int", SortField.Type.INT),
+                                new SortField ("string", SortField.Type.STRING),
+        new SortField ("float", SortField.Type.FLOAT) );
     assertMatches (parallelSearcher, queryG, sort, "ZWXY");
 
-    sort.setSort (new SortField ("int", SortField.INT),
-                                new SortField ("string", SortField.STRING),
-        new SortField ("float", SortField.FLOAT, true) );
+    sort.setSort (new SortField ("int", SortField.Type.INT),
+                                new SortField ("string", SortField.Type.STRING),
+        new SortField ("float", SortField.Type.FLOAT, true) );
     assertMatches (parallelSearcher, queryG, sort, "ZYXW");
     parallelSearcher.close();
     exec.shutdown();
@@ -671,13 +671,13 @@ public class TestSort extends LuceneTestCase {
 
   // test sorts using a series of fields
   public void testSortCombos() throws Exception {
-    sort.setSort (new SortField ("int", SortField.INT), new SortField ("float", SortField.FLOAT) );
+    sort.setSort (new SortField ("int", SortField.Type.INT), new SortField ("float", SortField.Type.FLOAT) );
     assertMatches (full, queryX, sort, "IGEAC");
 
-    sort.setSort (new SortField ("int", SortField.INT, true), new SortField (null, SortField.DOC, true) );
+    sort.setSort (new SortField ("int", SortField.Type.INT, true), new SortField (null, SortField.Type.DOC, true) );
     assertMatches (full, queryX, sort, "CEAGI");
 
-    sort.setSort (new SortField ("float", SortField.FLOAT), new SortField ("string", SortField.STRING) );
+    sort.setSort (new SortField ("float", SortField.Type.FLOAT), new SortField ("string", SortField.Type.STRING) );
     assertMatches (full, queryX, sort, "GICEA");
   }
 
@@ -940,88 +940,88 @@ public class TestSort extends LuceneTestCase {
     String expected = isFull ? "ABCDEFGHIJ" : "ACEGIBDFHJ";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField ("int", SortField.INT));
+    sort.setSort(new SortField ("int", SortField.Type.INT));
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField ("int", SortField.INT), SortField.FIELD_DOC);
+    sort.setSort(new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC);
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField("int", SortField.INT));
+    sort.setSort(new SortField("int", SortField.Type.INT));
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
     
-    sort.setSort(new SortField ("float", SortField.FLOAT), SortField.FIELD_DOC);
+    sort.setSort(new SortField ("float", SortField.Type.FLOAT), SortField.FIELD_DOC);
     assertMatches(multi, queryA, sort, "GDHJCIEFAB");
 
-    sort.setSort(new SortField("float", SortField.FLOAT));
+    sort.setSort(new SortField("float", SortField.Type.FLOAT));
     assertMatches(multi, queryA, sort, "GDHJCIEFAB");
 
-    sort.setSort(new SortField("string", SortField.STRING));
+    sort.setSort(new SortField("string", SortField.Type.STRING));
     assertMatches(multi, queryA, sort, "DJAIHGFEBC");
 
-    sort.setSort(new SortField("int", SortField.INT, true));
+    sort.setSort(new SortField("int", SortField.Type.INT, true));
     expected = isFull ? "CABEJGFHDI" : "CAEBJGFHDI";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField("float", SortField.FLOAT, true));
+    sort.setSort(new SortField("float", SortField.Type.FLOAT, true));
     assertMatches(multi, queryA, sort, "BAFECIJHDG");
 
-    sort.setSort(new SortField("string", SortField.STRING, true));
+    sort.setSort(new SortField("string", SortField.Type.STRING, true));
     assertMatches(multi, queryA, sort, "CBEFGHIAJD");
 
-    sort.setSort(new SortField("int", SortField.INT),new SortField("float", SortField.FLOAT));
+    sort.setSort(new SortField("int", SortField.Type.INT),new SortField("float", SortField.Type.FLOAT));
     assertMatches(multi, queryA, sort, "IDHFGJEABC");
 
-    sort.setSort(new SortField("float", SortField.FLOAT),new SortField("string", SortField.STRING));
+    sort.setSort(new SortField("float", SortField.Type.FLOAT),new SortField("string", SortField.Type.STRING));
     assertMatches(multi, queryA, sort, "GDHJICEFAB");
 
-    sort.setSort(new SortField ("int", SortField.INT));
+    sort.setSort(new SortField ("int", SortField.Type.INT));
     assertMatches(multi, queryF, sort, "IZJ");
 
-    sort.setSort(new SortField ("int", SortField.INT, true));
+    sort.setSort(new SortField ("int", SortField.Type.INT, true));
     assertMatches(multi, queryF, sort, "JZI");
 
-    sort.setSort(new SortField ("float", SortField.FLOAT));
+    sort.setSort(new SortField ("float", SortField.Type.FLOAT));
     assertMatches(multi, queryF, sort, "ZJI");
 
-    sort.setSort(new SortField ("string", SortField.STRING));
+    sort.setSort(new SortField ("string", SortField.Type.STRING));
     assertMatches(multi, queryF, sort, "ZJI");
 
-    sort.setSort(new SortField ("string", SortField.STRING, true));
+    sort.setSort(new SortField ("string", SortField.Type.STRING, true));
     assertMatches(multi, queryF, sort, "IJZ");
 
     if (supportsDocValues) {
-      sort.setSort(useDocValues(new SortField ("int", SortField.INT)));
+      sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)));
       expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
       assertMatches(multi, queryA, sort, expected);
 
-      sort.setSort(useDocValues(new SortField ("int", SortField.INT)), SortField.FIELD_DOC);
+      sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC);
       expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
       assertMatches(multi, queryA, sort, expected);
 
-      sort.setSort(useDocValues(new SortField("int", SortField.INT)));
+      sort.setSort(useDocValues(new SortField("int", SortField.Type.INT)));
       expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
       assertMatches(multi, queryA, sort, expected);
     
-      sort.setSort(useDocValues(new SortField ("float", SortField.FLOAT)), SortField.FIELD_DOC);
+      sort.setSort(useDocValues(new SortField ("float", SortField.Type.FLOAT)), SortField.FIELD_DOC);
       assertMatches(multi, queryA, sort, "GDHJCIEFAB");
 
-      sort.setSort(useDocValues(new SortField("float", SortField.FLOAT)));
+      sort.setSort(useDocValues(new SortField("float", SortField.Type.FLOAT)));
       assertMatches(multi, queryA, sort, "GDHJCIEFAB");
     
-      sort.setSort(useDocValues(new SortField("int", SortField.INT, true)));
+      sort.setSort(useDocValues(new SortField("int", SortField.Type.INT, true)));
       expected = isFull ? "CABEJGFHDI" : "CAEBJGFHDI";
       assertMatches(multi, queryA, sort, expected);
     
-      sort.setSort(useDocValues(new SortField("int", SortField.INT)), useDocValues(new SortField("float", SortField.FLOAT)));
+      sort.setSort(useDocValues(new SortField("int", SortField.Type.INT)), useDocValues(new SortField("float", SortField.Type.FLOAT)));
       assertMatches(multi, queryA, sort, "IDHFGJEABC");
     
-      sort.setSort(useDocValues(new SortField ("int", SortField.INT)));
+      sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)));
       assertMatches(multi, queryF, sort, "IZJ");
 
-      sort.setSort(useDocValues(new SortField ("int", SortField.INT, true)));
+      sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT, true)));
       assertMatches(multi, queryF, sort, "JZI");
     }
     
@@ -1071,7 +1071,7 @@ public class TestSort extends LuceneTestCase {
     IndexReader r = IndexReader.open(w, true);
     w.close();
     IndexSearcher s = newSearcher(r);
-    TopDocs hits = s.search(new TermQuery(new Term("t", "1")), null, 10, new Sort(new SortField("f", SortField.STRING)));
+    TopDocs hits = s.search(new TermQuery(new Term("t", "1")), null, 10, new Sort(new SortField("f", SortField.Type.STRING)));
     assertEquals(2, hits.totalHits);
     // null sorts first
     assertEquals(1, hits.scoreDocs[0].doc);
@@ -1094,7 +1094,7 @@ public class TestSort extends LuceneTestCase {
     writer.optimize(); // enforce one segment to have a higher unique term count in all cases
     writer.close();
     sort.setSort(
-        new SortField("string", SortField.STRING),
+        new SortField("string", SortField.Type.STRING),
         SortField.FIELD_DOC );
     // this should not throw AIOOBE or RuntimeEx
     IndexSearcher searcher = new IndexSearcher(indexStore, true);
diff --git a/lucene/src/test/org/apache/lucene/search/TestTopDocsMerge.java b/lucene/src/test/org/apache/lucene/search/TestTopDocsMerge.java
index 7c459f7..0eb353f 100644
--- a/lucene/src/test/org/apache/lucene/search/TestTopDocsMerge.java
+++ b/lucene/src/test/org/apache/lucene/search/TestTopDocsMerge.java
@@ -133,16 +133,16 @@ public class TestTopDocsMerge extends LuceneTestCase {
     }
 
     final List<SortField> sortFields = new ArrayList<SortField>();
-    sortFields.add(new SortField("string", SortField.STRING, true));
-    sortFields.add(new SortField("string", SortField.STRING, false));
-    sortFields.add(new SortField("int", SortField.INT, true));
-    sortFields.add(new SortField("int", SortField.INT, false));
-    sortFields.add(new SortField("float", SortField.FLOAT, true));
-    sortFields.add(new SortField("float", SortField.FLOAT, false));
-    sortFields.add(new SortField(null, SortField.SCORE, true));
-    sortFields.add(new SortField(null, SortField.SCORE, false));
-    sortFields.add(new SortField(null, SortField.DOC, true));
-    sortFields.add(new SortField(null, SortField.DOC, false));
+    sortFields.add(new SortField("string", SortField.Type.STRING, true));
+    sortFields.add(new SortField("string", SortField.Type.STRING, false));
+    sortFields.add(new SortField("int", SortField.Type.INT, true));
+    sortFields.add(new SortField("int", SortField.Type.INT, false));
+    sortFields.add(new SortField("float", SortField.Type.FLOAT, true));
+    sortFields.add(new SortField("float", SortField.Type.FLOAT, false));
+    sortFields.add(new SortField(null, SortField.Type.SCORE, true));
+    sortFields.add(new SortField(null, SortField.Type.SCORE, false));
+    sortFields.add(new SortField(null, SortField.Type.DOC, true));
+    sortFields.add(new SortField(null, SortField.Type.DOC, false));
 
     final int[] docStarts = new int[subSearchers.length];
     int docBase = 0;
diff --git a/modules/analysis/common/src/test/org/apache/lucene/collation/CollationTestBase.java b/modules/analysis/common/src/test/org/apache/lucene/collation/CollationTestBase.java
index e65732a..1c7084e 100644
--- a/modules/analysis/common/src/test/org/apache/lucene/collation/CollationTestBase.java
+++ b/modules/analysis/common/src/test/org/apache/lucene/collation/CollationTestBase.java
@@ -228,16 +228,16 @@ public abstract class CollationTestBase extends LuceneTestCase {
     Query queryX = new TermQuery(new Term ("contents", "x"));
     Query queryY = new TermQuery(new Term ("contents", "y"));
     
-    sort.setSort(new SortField("US", SortField.STRING));
+    sort.setSort(new SortField("US", SortField.Type.STRING));
     assertMatches(searcher, queryY, sort, usResult);
 
-    sort.setSort(new SortField("France", SortField.STRING));
+    sort.setSort(new SortField("France", SortField.Type.STRING));
     assertMatches(searcher, queryX, sort, frResult);
 
-    sort.setSort(new SortField("Sweden", SortField.STRING));
+    sort.setSort(new SortField("Sweden", SortField.Type.STRING));
     assertMatches(searcher, queryY, sort, svResult);
 
-    sort.setSort(new SortField("Denmark", SortField.STRING));
+    sort.setSort(new SortField("Denmark", SortField.Type.STRING));
     assertMatches(searcher, queryY, sort, dkResult);
   }
     
diff --git a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
index 04236c2..315c2cb 100644
--- a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
+++ b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
@@ -75,8 +75,7 @@ public class SearchWithSortTask extends ReadTask {
         } else {
           throw new RuntimeException("You must specify the sort type ie page:int,subject:string");
         }
-        int type = getType(typeString);
-        sortField0 = new SortField(fieldName, type);
+        sortField0 = new SortField(fieldName, SortField.Type.valueOf(typeString.toUpperCase()));
       }
       sortFields[upto++] = sortField0;
     }
@@ -89,30 +88,6 @@ public class SearchWithSortTask extends ReadTask {
     this.sort = new Sort(sortFields);
   }
 
-  private int getType(String typeString) {
-    int type;
-    if (typeString.equals("float")) {
-      type = SortField.FLOAT;
-    } else if (typeString.equals("double")) {
-      type = SortField.DOUBLE;
-    } else if (typeString.equals("byte")) {
-      type = SortField.BYTE;
-    } else if (typeString.equals("short")) {
-      type = SortField.SHORT;
-    } else if (typeString.equals("int")) {
-      type = SortField.INT;
-    } else if (typeString.equals("long")) {
-      type = SortField.LONG;
-    } else if (typeString.equals("string")) {
-      type = SortField.STRING;
-    } else if (typeString.equals("string_val")) {
-      type = SortField.STRING_VAL;
-    } else {
-      throw new RuntimeException("Unrecognized sort field type " + typeString);
-    }
-    return type;
-  }
-
   @Override
   public boolean supportsParams() {
     return true;
diff --git a/modules/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTaskTest.java b/modules/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTaskTest.java
index 705ab9e..c16e546 100644
--- a/modules/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTaskTest.java
+++ b/modules/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTaskTest.java
@@ -29,6 +29,6 @@ public class SearchWithSortTaskTest extends BenchmarkTestCase {
   public void testSetParams_docField() throws Exception {
     SearchWithSortTask task = new SearchWithSortTask(new PerfRunData(new Config(new Properties())));
     task.setParams("doc");
-    assertEquals(SortField.DOC, task.getSort().getSort()[0].getType());
+    assertEquals(SortField.Type.DOC, task.getSort().getSort()[0].getType());
   }
 }
diff --git a/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java b/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index a4b0b9f..5e7224d 100644
--- a/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ b/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -176,17 +176,17 @@ public class TestGrouping extends LuceneTestCase {
     } else {
       if (random.nextBoolean()) {
         if (random.nextBoolean()) {
-          sortFields.add(new SortField("sort1", SortField.STRING, random.nextBoolean()));
+          sortFields.add(new SortField("sort1", SortField.Type.STRING, random.nextBoolean()));
         } else {
-          sortFields.add(new SortField("sort2", SortField.STRING, random.nextBoolean()));
+          sortFields.add(new SortField("sort2", SortField.Type.STRING, random.nextBoolean()));
         }
       } else if (random.nextBoolean()) {
-        sortFields.add(new SortField("sort1", SortField.STRING, random.nextBoolean()));
-        sortFields.add(new SortField("sort2", SortField.STRING, random.nextBoolean()));
+        sortFields.add(new SortField("sort1", SortField.Type.STRING, random.nextBoolean()));
+        sortFields.add(new SortField("sort2", SortField.Type.STRING, random.nextBoolean()));
       }
     }
     // Break ties:
-    sortFields.add(new SortField("id", SortField.INT));
+    sortFields.add(new SortField("id", SortField.Type.INT));
     return new Sort(sortFields.toArray(new SortField[sortFields.size()]));
   }
 
@@ -197,7 +197,7 @@ public class TestGrouping extends LuceneTestCase {
       public int compare(GroupDoc d1, GroupDoc d2) {
         for(SortField sf : sortFields) {
           final int cmp;
-          if (sf.getType() == SortField.SCORE) {
+          if (sf.getType() == SortField.Type.SCORE) {
             if (d1.score > d2.score) {
               cmp = -1;
             } else if (d1.score < d2.score) {
@@ -230,7 +230,7 @@ public class TestGrouping extends LuceneTestCase {
     for(int fieldIDX=0;fieldIDX<sortFields.length;fieldIDX++) {
       final Comparable<?> c;
       final SortField sf = sortFields[fieldIDX];
-      if (sf.getType() == SortField.SCORE) {
+      if (sf.getType() == SortField.Type.SCORE) {
         c = new Float(d.score);
       } else if (sf.getField().equals("sort1")) {
         c = d.sort1;
@@ -625,13 +625,13 @@ public class TestGrouping extends LuceneTestCase {
           final Sort docSort = getRandomSort();
 
           for(SortField sf : docSort.getSort()) {
-            if (sf.getType() == SortField.SCORE) {
+            if (sf.getType() == SortField.Type.SCORE) {
               getScores = true;
             }
           }
 
           for(SortField sf : groupSort.getSort()) {
-            if (sf.getType() == SortField.SCORE) {
+            if (sf.getType() == SortField.Type.SCORE) {
               getScores = true;
             }
           }
@@ -827,7 +827,7 @@ public class TestGrouping extends LuceneTestCase {
             final SortField[] sortFields = groupSort.getSort();
             final Map<Float,Float> termScoreMap = scoreMap.get(searchTerm);
             for(int groupSortIDX=0;groupSortIDX<sortFields.length;groupSortIDX++) {
-              if (sortFields[groupSortIDX].getType() == SortField.SCORE) {
+              if (sortFields[groupSortIDX].getType() == SortField.Type.SCORE) {
                 for (GroupDocs groupDocsHits : expectedGroups.groups) {
                   if (groupDocsHits.groupSortValues != null) {
                     //System.out.println("remap " + groupDocsHits.groupSortValues[groupSortIDX] + " to " + termScoreMap.get(groupDocsHits.groupSortValues[groupSortIDX]));
@@ -840,7 +840,7 @@ public class TestGrouping extends LuceneTestCase {
 
             final SortField[] docSortFields = docSort.getSort();
             for(int docSortIDX=0;docSortIDX<docSortFields.length;docSortIDX++) {
-              if (docSortFields[docSortIDX].getType() == SortField.SCORE) {
+              if (docSortFields[docSortIDX].getType() == SortField.Type.SCORE) {
                 for (GroupDocs groupDocsHits : expectedGroups.groups) {
                   for(ScoreDoc _hit : groupDocsHits.scoreDocs) {
                     FieldDoc hit = (FieldDoc) _hit;
diff --git a/solr/src/java/org/apache/solr/handler/component/QueryComponent.java b/solr/src/java/org/apache/solr/handler/component/QueryComponent.java
index 9af9b02..610065c 100644
--- a/solr/src/java/org/apache/solr/handler/component/QueryComponent.java
+++ b/solr/src/java/org/apache/solr/handler/component/QueryComponent.java
@@ -435,8 +435,8 @@ public class QueryComponent extends SearchComponent
       }
 
       for (SortField sortField: sortFields) {
-        int type = sortField.getType();
-        if (type==SortField.SCORE || type==SortField.DOC) continue;
+        SortField.Type type = sortField.getType();
+        if (type==SortField.Type.SCORE || type==SortField.Type.DOC) continue;
 
         FieldComparator comparator = null;
         FieldComparator comparators[] = (leaves==null) ? null : new FieldComparator[leaves.length];
diff --git a/solr/src/java/org/apache/solr/handler/component/QueryElevationComponent.java b/solr/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
index 457911a..977199e 100644
--- a/solr/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
+++ b/solr/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
@@ -378,7 +378,7 @@ public class QueryElevationComponent extends SearchComponent implements SolrCore
       if( sortSpec.getSort() == null ) {
         sortSpec.setSort( new Sort( new SortField[] {
             new SortField(idField, booster.comparatorSource, false ),
-            new SortField(null, SortField.SCORE, false)
+            new SortField(null, SortField.Type.SCORE, false)
         }));
       }
       else {
@@ -387,12 +387,12 @@ public class QueryElevationComponent extends SearchComponent implements SolrCore
         SortField[] current = sortSpec.getSort().getSort();
         ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );
         // Perhaps force it to always sort by score
-        if( force && current[0].getType() != SortField.SCORE ) {
+        if( force && current[0].getType() != SortField.Type.SCORE ) {
           sorts.add( new SortField(idField, booster.comparatorSource, false ) );
           modify = true;
         }
         for( SortField sf : current ) {
-          if( sf.getType() == SortField.SCORE ) {
+          if( sf.getType() == SortField.Type.SCORE ) {
             sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );
             modify = true;
           }
diff --git a/solr/src/java/org/apache/solr/handler/component/ShardDoc.java b/solr/src/java/org/apache/solr/handler/component/ShardDoc.java
index 564cc00..aa02a0c 100755
--- a/solr/src/java/org/apache/solr/handler/component/ShardDoc.java
+++ b/solr/src/java/org/apache/solr/handler/component/ShardDoc.java
@@ -89,8 +89,8 @@ class ShardFieldSortedHitQueue extends PriorityQueue {
     for (int i = 0; i < n; ++i) {
 
       // keep track of the named fields
-      int type = fields[i].getType();
-      if (type!=SortField.SCORE && type!=SortField.DOC) {
+      SortField.Type type = fields[i].getType();
+      if (type!=SortField.Type.SCORE && type!=SortField.Type.DOC) {
         fieldNames.add(fields[i].getField());
       }
 
@@ -98,8 +98,8 @@ class ShardFieldSortedHitQueue extends PriorityQueue {
       comparators[i] = getCachedComparator(fieldname, fields[i]
           .getType(), fields[i].getComparatorSource());
 
-     if (fields[i].getType() == SortField.STRING) {
-        this.fields[i] = new SortField(fieldname, SortField.STRING, 
+     if (fields[i].getType() == SortField.Type.STRING) {
+        this.fields[i] = new SortField(fieldname, SortField.Type.STRING,
             fields[i].getReverse());
       } else {
         this.fields[i] = new SortField(fieldname, fields[i].getType(),
@@ -144,16 +144,16 @@ class ShardFieldSortedHitQueue extends PriorityQueue {
     return c < 0;
   }
 
-  Comparator getCachedComparator(String fieldname, int type, FieldComparatorSource factory) {
+  Comparator getCachedComparator(String fieldname, SortField.Type type, FieldComparatorSource factory) {
     Comparator comparator = null;
     switch (type) {
-    case SortField.SCORE:
+    case SCORE:
       comparator = comparatorScore(fieldname);
       break;
-    case SortField.STRING:
+    case STRING:
       comparator = comparatorNatural(fieldname);
       break;
-    case SortField.CUSTOM:
+    case CUSTOM:
       if (factory instanceof MissingStringLastComparatorSource){
         comparator = comparatorMissingStringLast(fieldname);
       } else {
@@ -163,7 +163,7 @@ class ShardFieldSortedHitQueue extends PriorityQueue {
         // throw new RuntimeException("Custom sort not supported factory is "+factory.getClass());
       }
       break;
-    case SortField.DOC:
+    case DOC:
       // TODO: we can support this!
       throw new RuntimeException("Doc sort not supported");
     default:
@@ -282,4 +282,4 @@ class ShardFieldSortedHitQueue extends PriorityQueue {
     };
   }
 
-}
\ No newline at end of file
+}
diff --git a/solr/src/java/org/apache/solr/schema/ByteField.java b/solr/src/java/org/apache/solr/schema/ByteField.java
index ce59010..cc1cbb2 100644
--- a/solr/src/java/org/apache/solr/schema/ByteField.java
+++ b/solr/src/java/org/apache/solr/schema/ByteField.java
@@ -42,7 +42,7 @@ public class ByteField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field, boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name, SortField.BYTE, reverse);
+    return new SortField(field.name, SortField.Type.BYTE, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/schema/DoubleField.java b/solr/src/java/org/apache/solr/schema/DoubleField.java
index c07f43d..12aca16 100644
--- a/solr/src/java/org/apache/solr/schema/DoubleField.java
+++ b/solr/src/java/org/apache/solr/schema/DoubleField.java
@@ -42,7 +42,7 @@ public class DoubleField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field, boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name, SortField.DOUBLE, reverse);
+    return new SortField(field.name, SortField.Type.DOUBLE, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/schema/FloatField.java b/solr/src/java/org/apache/solr/schema/FloatField.java
index 4c9c46a..7a4b538 100644
--- a/solr/src/java/org/apache/solr/schema/FloatField.java
+++ b/solr/src/java/org/apache/solr/schema/FloatField.java
@@ -40,7 +40,7 @@ public class FloatField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field,boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name,SortField.FLOAT, reverse);
+    return new SortField(field.name,SortField.Type.FLOAT, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/schema/IntField.java b/solr/src/java/org/apache/solr/schema/IntField.java
index 3199ff8..a5d0adf 100644
--- a/solr/src/java/org/apache/solr/schema/IntField.java
+++ b/solr/src/java/org/apache/solr/schema/IntField.java
@@ -40,7 +40,7 @@ public class IntField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field,boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name,SortField.INT, reverse);
+    return new SortField(field.name,SortField.Type.INT, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/schema/LongField.java b/solr/src/java/org/apache/solr/schema/LongField.java
index 7c0d2ac..9c0fad1 100644
--- a/solr/src/java/org/apache/solr/schema/LongField.java
+++ b/solr/src/java/org/apache/solr/schema/LongField.java
@@ -42,7 +42,7 @@ public class LongField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field,boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name,SortField.LONG, reverse);
+    return new SortField(field.name,SortField.Type.LONG, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/schema/ShortField.java b/solr/src/java/org/apache/solr/schema/ShortField.java
index b6685db..5e6ae6e 100644
--- a/solr/src/java/org/apache/solr/schema/ShortField.java
+++ b/solr/src/java/org/apache/solr/schema/ShortField.java
@@ -45,7 +45,7 @@ public class ShortField extends FieldType {
   @Override
   public SortField getSortField(SchemaField field, boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name, SortField.SHORT, reverse);
+    return new SortField(field.name, SortField.Type.SHORT, reverse);
   }
 
   @Override
diff --git a/solr/src/java/org/apache/solr/search/Grouping.java b/solr/src/java/org/apache/solr/search/Grouping.java
index 32637b3..8649b57 100755
--- a/solr/src/java/org/apache/solr/search/Grouping.java
+++ b/solr/src/java/org/apache/solr/search/Grouping.java
@@ -278,7 +278,7 @@ public class Grouping {
         cacheScores = true;
       } else {
         for (SortField field : commands.get(0).groupSort.getSort()) {
-          if (field.getType() == SortField.SCORE) {
+          if (field.getType() == SortField.Type.SCORE) {
             cacheScores = true;
             break;
           }
@@ -1070,4 +1070,4 @@ public class Grouping {
 
   }
 
-}
\ No newline at end of file
+}
diff --git a/solr/src/java/org/apache/solr/search/QueryParsing.java b/solr/src/java/org/apache/solr/search/QueryParsing.java
index 9644625..7e17003 100644
--- a/solr/src/java/org/apache/solr/search/QueryParsing.java
+++ b/solr/src/java/org/apache/solr/search/QueryParsing.java
@@ -321,10 +321,10 @@ public class QueryParsing {
           if (top) {
             lst.add(SortField.FIELD_SCORE);
           } else {
-            lst.add(new SortField(null, SortField.SCORE, true));
+            lst.add(new SortField(null, SortField.Type.SCORE, true));
           }
         } else if (DOCID.equals(field)) {
-          lst.add(new SortField(null, SortField.DOC, top));
+          lst.add(new SortField(null, SortField.Type.DOC, top));
         } else {
           // try to find the field
           SchemaField sf = req.getSchema().getFieldOrNull(field);
diff --git a/solr/src/java/org/apache/solr/search/SolrIndexSearcher.java b/solr/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 1185343..2094cc8 100644
--- a/solr/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/solr/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -1024,7 +1024,7 @@ public class SolrIndexSearcher extends IndexSearcher implements SolrInfoMBean {
       useFilterCache=true;
       SortField[] sfields = cmd.getSort().getSort();
       for (SortField sf : sfields) {
-        if (sf.getType() == SortField.SCORE) {
+        if (sf.getType() == SortField.Type.SCORE) {
           useFilterCache=false;
           break;
         }
diff --git a/solr/src/java/org/apache/solr/search/SortSpec.java b/solr/src/java/org/apache/solr/search/SortSpec.java
index 039de0a..f2c8004 100644
--- a/solr/src/java/org/apache/solr/search/SortSpec.java
+++ b/solr/src/java/org/apache/solr/search/SortSpec.java
@@ -48,7 +48,7 @@ public class SortSpec
   public static boolean includesScore(Sort sort) {
     if (sort==null) return true;
     for (SortField sf : sort.getSort()) {
-      if (sf.getType() == SortField.SCORE) return true;
+      if (sf.getType() == SortField.Type.SCORE) return true;
     }
     return false;
   }
diff --git a/solr/src/java/org/apache/solr/search/Sorting.java b/solr/src/java/org/apache/solr/search/Sorting.java
index 325871c..9b9a97c 100644
--- a/solr/src/java/org/apache/solr/search/Sorting.java
+++ b/solr/src/java/org/apache/solr/search/Sorting.java
@@ -42,12 +42,12 @@ public class Sorting {
   public static SortField getStringSortField(String fieldName, boolean reverse, boolean nullLast, boolean nullFirst) {
     if (nullLast) {
       if (!reverse) return new SortField(fieldName, nullStringLastComparatorSource);
-      else return new SortField(fieldName, SortField.STRING, true);
+      else return new SortField(fieldName, SortField.Type.STRING, true);
     } else if (nullFirst) {
       if (reverse) return new SortField(fieldName, nullStringLastComparatorSource, true);
-      else return new SortField(fieldName, SortField.STRING, false);
+      else return new SortField(fieldName, SortField.Type.STRING, false);
     } else {
-      return new SortField(fieldName, SortField.STRING, reverse);
+      return new SortField(fieldName, SortField.Type.STRING, reverse);
     }
   }
 
diff --git a/solr/src/java/org/apache/solr/search/function/ValueSource.java b/solr/src/java/org/apache/solr/search/function/ValueSource.java
index bb50461..3230ad8 100644
--- a/solr/src/java/org/apache/solr/search/function/ValueSource.java
+++ b/solr/src/java/org/apache/solr/search/function/ValueSource.java
@@ -102,7 +102,7 @@ public abstract class ValueSource implements Serializable {
 
   class ValueSourceSortField extends SortField {
     public ValueSourceSortField(boolean reverse) {
-      super(description(), SortField.REWRITEABLE, reverse);
+      super(description(), SortField.Type.REWRITEABLE, reverse);
     }
 
     @Override
diff --git a/solr/src/test/org/apache/solr/search/QueryParsingTest.java b/solr/src/test/org/apache/solr/search/QueryParsingTest.java
index 9fc881f..ff2dc53 100644
--- a/solr/src/test/org/apache/solr/search/QueryParsingTest.java
+++ b/solr/src/test/org/apache/solr/search/QueryParsingTest.java
@@ -46,57 +46,57 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
 
     sort = QueryParsing.parseSort("score asc", req);
     SortField[] flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.SCORE);
+    assertEquals(flds[0].getType(), SortField.Type.SCORE);
     assertTrue(flds[0].getReverse());
 
     sort = QueryParsing.parseSort("weight desc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[0].getReverse(), true);
     sort = QueryParsing.parseSort("weight desc,bday asc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[0].getReverse(), true);
-    assertEquals(flds[1].getType(), SortField.LONG);
+    assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getReverse(), false);
     //order aliases
     sort = QueryParsing.parseSort("weight top,bday asc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[0].getReverse(), true);
-    assertEquals(flds[1].getType(), SortField.LONG);
+    assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getReverse(), false);
     sort = QueryParsing.parseSort("weight top,bday bottom", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[0].getReverse(), true);
-    assertEquals(flds[1].getType(), SortField.LONG);
+    assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
     assertEquals(flds[1].getReverse(), false);
 
     //test weird spacing
     sort = QueryParsing.parseSort("weight         desc,            bday         asc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
     assertEquals(flds[1].getField(), "bday");
-    assertEquals(flds[1].getType(), SortField.LONG);
+    assertEquals(flds[1].getType(), SortField.Type.LONG);
     //handles trailing commas
     sort = QueryParsing.parseSort("weight desc,", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
 
     //test functions
     sort = QueryParsing.parseSort("pow(weight, 2) desc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.REWRITEABLE);
+    assertEquals(flds[0].getType(), SortField.Type.REWRITEABLE);
     //Not thrilled about the fragility of string matching here, but...
     //the value sources get wrapped, so the out field is different than the input
     assertEquals(flds[0].getField(), "pow(float(weight),const(2))");
@@ -104,12 +104,12 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     //test functions (more deep)
     sort = QueryParsing.parseSort("sum(product(r_f1,sum(d_f1,t_f1,1.0)),a_f1) asc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.REWRITEABLE);
+    assertEquals(flds[0].getType(), SortField.Type.REWRITEABLE);
     assertEquals(flds[0].getField(), "sum(product(float(r_f1),sum(float(d_f1),float(t_f1),const(1.0))),float(a_f1))");
 
     sort = QueryParsing.parseSort("pow(weight,                 2.0)         desc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.REWRITEABLE);
+    assertEquals(flds[0].getType(), SortField.Type.REWRITEABLE);
     //Not thrilled about the fragility of string matching here, but...
     //the value sources get wrapped, so the out field is different than the input
     assertEquals(flds[0].getField(), "pow(float(weight),const(2.0))");
@@ -117,27 +117,27 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
 
     sort = QueryParsing.parseSort("pow(weight, 2.0) desc, weight    desc,   bday    asc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.REWRITEABLE);
+    assertEquals(flds[0].getType(), SortField.Type.REWRITEABLE);
 
     //Not thrilled about the fragility of string matching here, but...
     //the value sources get wrapped, so the out field is different than the input
     assertEquals(flds[0].getField(), "pow(float(weight),const(2.0))");
 
-    assertEquals(flds[1].getType(), SortField.FLOAT);
+    assertEquals(flds[1].getType(), SortField.Type.FLOAT);
     assertEquals(flds[1].getField(), "weight");
     assertEquals(flds[2].getField(), "bday");
-    assertEquals(flds[2].getType(), SortField.LONG);
+    assertEquals(flds[2].getType(), SortField.Type.LONG);
     
     //handles trailing commas
     sort = QueryParsing.parseSort("weight desc,", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.FLOAT);
+    assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
 
     //Test literals in functions
     sort = QueryParsing.parseSort("strdist(foo_s1, \"junk\", jw) desc", req);
     flds = sort.getSort();
-    assertEquals(flds[0].getType(), SortField.REWRITEABLE);
+    assertEquals(flds[0].getType(), SortField.Type.REWRITEABLE);
     //the value sources get wrapped, so the out field is different than the input
     assertEquals(flds[0].getField(), "strdist(str(foo_s1),literal(junk), dist=org.apache.lucene.search.spell.JaroWinklerDistance)");
 
diff --git a/solr/src/test/org/apache/solr/search/TestSort.java b/solr/src/test/org/apache/solr/search/TestSort.java
index b70b9c7..be86a7e 100755
--- a/solr/src/test/org/apache/solr/search/TestSort.java
+++ b/solr/src/test/org/apache/solr/search/TestSort.java
@@ -126,13 +126,13 @@ public class TestSort extends AbstractSolrTestCase {
         final boolean sortMissingFirst2 = !luceneSort2 && !sortMissingLast2;
         final boolean reverse2 = r.nextBoolean();
 
-        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));
+        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));
         // hit both use-cases of sort-missing-last
         sfields.add( Sorting.getStringSortField("f", reverse, sortMissingLast, sortMissingFirst) );
         if (secondary) {
           sfields.add( Sorting.getStringSortField("f2", reverse2, sortMissingLast2, sortMissingFirst2) );
         }
-        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.SCORE));
+        if (r.nextBoolean()) sfields.add( new SortField(null, SortField.Type.SCORE));
 
         Sort sort = new Sort(sfields.toArray(new SortField[sfields.size()]));
 

