GitDiffStart: b737186489e44bcaeee4497c15a6d1643d712bb6 | Sun Apr 12 21:39:34 2015 +0000
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java
new file mode 100644
index 0000000..a233d40
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java
@@ -0,0 +1,170 @@
+package org.apache.lucene.search.payloads;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.SimplePayloadFilter;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.spans.SpanNearPayloadCheckQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanPayloadCheckQuery;
+import org.apache.lucene.search.spans.SpanPositionRangeQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+/** basic test of payload-spans */
+public class TestPayloadBasics extends LuceneTestCase {
+  private static IndexSearcher searcher;
+  private static IndexReader reader;
+  private static Directory directory;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    Analyzer simplePayloadAnalyzer = new Analyzer() {
+        @Override
+        public TokenStreamComponents createComponents(String fieldName) {
+          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
+          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
+        }
+    };
+  
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(simplePayloadAnalyzer)
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
+    //writer.infoStream = System.out;
+    for (int i = 0; i < 2000; i++) {
+      Document doc = new Document();
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+  
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    reader = null;
+    directory = null;
+  }
+  
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, "field", searcher, results);
+  }
+  
+  public void testSpanPayloadCheck() throws Exception {
+    SpanQuery term1 = new SpanTermQuery(new Term("field", "five"));
+    BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
+    SpanQuery query = new SpanPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
+    checkHits(query, new int[]
+      {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
+    assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
+
+    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
+    SpanNearQuery snq;
+    SpanQuery[] clauses;
+    List<byte[]> list;
+    BytesRef pay2;
+    clauses = new SpanQuery[2];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    snq = new SpanNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    query = new SpanNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599});
+    clauses = new SpanQuery[3];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    clauses[2] = new SpanTermQuery(new Term("field", "five"));
+    snq = new SpanNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    list.add(pay3.bytes);
+    query = new SpanNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {505});
+  }
+
+  public void testComplexSpanChecks() throws Exception {
+    SpanTermQuery one = new SpanTermQuery(new Term("field", "one"));
+    SpanTermQuery thous = new SpanTermQuery(new Term("field", "thousand"));
+    //should be one position in between
+    SpanTermQuery hundred = new SpanTermQuery(new Term("field", "hundred"));
+    SpanTermQuery three = new SpanTermQuery(new Term("field", "three"));
+
+    SpanNearQuery oneThous = new SpanNearQuery(new SpanQuery[]{one, thous}, 0, true);
+    SpanNearQuery hundredThree = new SpanNearQuery(new SpanQuery[]{hundred, three}, 0, true);
+    SpanNearQuery oneThousHunThree = new SpanNearQuery(new SpanQuery[]{oneThous, hundredThree}, 1, true);
+    SpanQuery query;
+    //this one's too small
+    query = new SpanPositionRangeQuery(oneThousHunThree, 1, 2);
+    checkHits(query, new int[]{});
+    //this one's just right
+    query = new SpanPositionRangeQuery(oneThousHunThree, 0, 6);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+    Collection<byte[]> payloads = new ArrayList<>();
+    BytesRef pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 3).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay4 = new BytesRef(("pos: " + 4).getBytes(StandardCharsets.UTF_8));
+    payloads.add(pay.bytes);
+    payloads.add(pay2.bytes);
+    payloads.add(pay3.bytes);
+    payloads.add(pay4.bytes);
+    query = new SpanNearPayloadCheckQuery(oneThousHunThree, payloads);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
new file mode 100644
index 0000000..d351680
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
@@ -0,0 +1,538 @@
+package org.apache.lucene.search.payloads;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.payloads.PayloadHelper;
+import org.apache.lucene.search.payloads.PayloadSpanUtil;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.spans.MultiSpansWrapper;
+import org.apache.lucene.search.spans.SpanFirstQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanNotQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestPayloadSpans extends LuceneTestCase {
+  private IndexSearcher searcher;
+  private Similarity similarity = new DefaultSimilarity();
+  protected IndexReader indexReader;
+  private IndexReader closeIndexReader;
+  private Directory directory;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    PayloadHelper helper = new PayloadHelper();
+    searcher = helper.setUp(random(), similarity, 1000);
+    indexReader = searcher.getIndexReader();
+  }
+
+  public void testSpanTermQuery() throws Exception {
+    SpanTermQuery stq;
+    Spans spans;
+    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
+    spans = MultiSpansWrapper.wrap(indexReader, stq);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 100, 1, 1, 1);
+
+    stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
+    spans = MultiSpansWrapper.wrap(indexReader, stq);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 100, 0, 0, 0);
+  }
+
+  public void testSpanFirst() throws IOException {
+
+    SpanQuery match;
+    SpanFirstQuery sfq;
+    match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    sfq = new SpanFirstQuery(match, 2);
+    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq);
+    checkSpans(spans, 109, 1, 1, 1);
+    //Test more complicated subclause
+    SpanQuery[] clauses = new SpanQuery[2];
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
+    match = new SpanNearQuery(clauses, 0, true);
+    sfq = new SpanFirstQuery(match, 2);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
+
+    match = new SpanNearQuery(clauses, 0, false);
+    sfq = new SpanFirstQuery(match, 2);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
+    
+  }
+  
+  public void testSpanNot() throws Exception {
+    SpanQuery[] clauses = new SpanQuery[2];
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
+    SpanQuery spq = new SpanNearQuery(clauses, 5, true);
+    SpanNotQuery snq = new SpanNotQuery(spq, new SpanTermQuery(new Term(PayloadHelper.FIELD, "two")));
+
+
+
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
+
+    Document doc = new Document();
+    doc.add(newTextField(PayloadHelper.FIELD, "one two three one four three", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    writer.close();
+    
+
+    checkSpans(MultiSpansWrapper.wrap(reader, snq), 1,new int[]{2});
+    reader.close();
+    directory.close();
+  }
+  
+  public void testNestedSpans() throws Exception {
+    SpanTermQuery stq;
+    Spans spans;
+    IndexSearcher searcher = getSearcher();
+    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq);
+    assertNull(spans);
+
+    SpanQuery[] clauses = new SpanQuery[3];
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
+
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 2, new int[]{3,3});
+
+     
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+
+    spanNearQuery = new SpanNearQuery(clauses, 6, true);
+   
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
+
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 1, new int[]{3});
+     
+    clauses = new SpanQuery[2];
+     
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+
+    spanNearQuery = new SpanNearQuery(clauses, 6, true);
+     
+    // xx within 6 of rr
+    
+    SpanQuery[] clauses2 = new SpanQuery[2];
+     
+    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses2[1] = spanNearQuery;
+     
+    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
+    
+    // yy within 6 of xx within 6 of rr
+
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 2, new int[]{3,3});
+    closeIndexReader.close();
+    directory.close();
+  }
+  
+  public void testFirstClauseWithoutPayload() throws Exception {
+    Spans spans;
+    IndexSearcher searcher = getSearcher();
+
+    SpanQuery[] clauses = new SpanQuery[3];
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nopayload"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "qq"));
+    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ss"));
+
+    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 6, true);
+    
+    SpanQuery[] clauses2 = new SpanQuery[2];
+     
+    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "pp"));
+    clauses2[1] = spanNearQuery;
+
+    SpanNearQuery snq = new SpanNearQuery(clauses2, 6, false);
+    
+    SpanQuery[] clauses3 = new SpanQuery[2];
+     
+    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "np"));
+    clauses3[1] = snq;
+     
+    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 1, new int[]{3});
+    closeIndexReader.close();
+    directory.close();
+  }
+  
+  public void testHeavilyNestedSpanQuery() throws Exception {
+    Spans spans;
+    IndexSearcher searcher = getSearcher();
+
+    SpanQuery[] clauses = new SpanQuery[3];
+    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "two"));
+    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
+
+    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 5, true);
+   
+    clauses = new SpanQuery[3];
+    clauses[0] = spanNearQuery; 
+    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "five"));
+    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "six"));
+
+    SpanNearQuery spanNearQuery2 = new SpanNearQuery(clauses, 6, true);
+     
+    SpanQuery[] clauses2 = new SpanQuery[2];
+    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "eleven"));
+    clauses2[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ten"));
+    SpanNearQuery spanNearQuery3 = new SpanNearQuery(clauses2, 2, false);
+    
+    SpanQuery[] clauses3 = new SpanQuery[3];
+    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nine"));
+    clauses3[1] = spanNearQuery2;
+    clauses3[2] = spanNearQuery3;
+     
+    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
+
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpans(spans, 2, new int[]{8, 8});
+    closeIndexReader.close();
+    directory.close();
+  }
+  
+  public void testShrinkToAfterShortestMatch() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("a b c d e f g h i j a k")));
+    writer.addDocument(doc);
+
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
+    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    SpanQuery[] sqs = { stq1, stq2 };
+    SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
+    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+  
+  public void testShrinkToAfterShortestMatch2() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("a b a d k f a h i k a k")));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
+    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    SpanQuery[] sqs = { stq1, stq2 };
+    SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+  
+  public void testShrinkToAfterShortestMatch3() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("j k a l f k k p a t a k l k t a")));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
+    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    SpanQuery[] sqs = { stq1, stq2 };
+    SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    if(VERBOSE) {
+      for (final String payload : payloadSet)
+        System.out.println("match:" +  payload);
+      
+    }
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+  
+  public void testPayloadSpanUtil() throws Exception {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
+
+    Document doc = new Document();
+    doc.add(newTextField(PayloadHelper.FIELD, "xx rr yy mm  pp", Field.Store.YES));
+    writer.addDocument(doc);
+  
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    PayloadSpanUtil psu = new PayloadSpanUtil(searcher.getTopReaderContext());
+    
+    Collection<byte[]> payloads = psu.getPayloadsForQuery(new TermQuery(new Term(PayloadHelper.FIELD, "rr")));
+    if(VERBOSE) {
+      System.out.println("Num payloads:" + payloads.size());
+      for (final byte [] bytes : payloads) {
+        System.out.println(new String(bytes, StandardCharsets.UTF_8));
+      }
+    }
+    reader.close();
+    directory.close();
+  }
+
+  private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
+                          int expectedPayloadLength, int expectedFirstByte) throws IOException {
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    //each position match should have a span associated with it, since there is just one underlying term query, there should
+    //only be one entry in the span
+    int seen = 0;
+    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        assertEquals("isPayloadAvailable should return true/false as payloads are expected", expectedNumPayloads > 0, spans.isPayloadAvailable());
+        //See payload helper, for the PayloadHelper.FIELD field, there is a single byte payload at every token
+        if (spans.isPayloadAvailable()) {
+          Collection<byte[]> payload = spans.getPayload();
+          assertEquals("payload size", expectedNumPayloads, payload.size());
+          for (final byte [] thePayload : payload) {
+            assertEquals("payload length", expectedPayloadLength, thePayload.length);
+            assertEquals("payload first byte", expectedFirstByte, thePayload[0]);
+          }
+        }
+        seen++;
+      }
+    }
+    assertEquals("expectedNumSpans", expectedNumSpans, seen);
+  }
+  
+  private IndexSearcher getSearcher() throws Exception {
+    directory = newDirectory();
+    String[] docs = new String[]{"xx rr yy mm  pp","xx yy mm rr pp", "nopayload qq ss pp np", "one two three four five six seven eight nine ten eleven", "nine one two three four five six seven eight eleven ten"};
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
+
+    Document doc = null;
+    for(int i = 0; i < docs.length; i++) {
+      doc = new Document();
+      String docText = docs[i];
+      doc.add(newTextField(PayloadHelper.FIELD, docText, Field.Store.YES));
+      writer.addDocument(doc);
+    }
+
+    closeIndexReader = writer.getReader();
+    writer.close();
+
+    IndexSearcher searcher = newSearcher(closeIndexReader);
+    return searcher;
+  }
+  
+  private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
+    int cnt = 0;
+
+    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        if(VERBOSE)
+          System.out.println("\nSpans Dump --");
+        if (spans.isPayloadAvailable()) {
+          Collection<byte[]> payload = spans.getPayload();
+          if(VERBOSE) {
+            System.out.println("payloads for span:" + payload.size());
+            for (final byte [] bytes : payload) {
+              System.out.println("doc:" + spans.docID() + " s:" + spans.startPosition() + " e:" + spans.endPosition() + " "
+                + new String(bytes, StandardCharsets.UTF_8));
+            }
+          }
+          assertEquals("payload size", numPayloads[cnt], payload.size());
+        } else { // no payload available
+          assertFalse("Expected spans:" + numPayloads[cnt] + " found: 0", numPayloads.length > 0 && numPayloads[cnt] > 0 );
+        }
+        cnt++;
+      }
+    }
+
+    assertEquals("expected numSpans", numSpans, cnt);
+  }
+
+  final class PayloadAnalyzer extends Analyzer {
+
+    @Override
+    public TokenStreamComponents createComponents(String fieldName) {
+      Tokenizer result = new MockTokenizer(MockTokenizer.SIMPLE, true);
+      return new TokenStreamComponents(result, new PayloadFilter(result));
+    }
+  }
+
+  final class PayloadFilter extends TokenFilter {
+    Set<String> entities = new HashSet<>();
+    Set<String> nopayload = new HashSet<>();
+    int pos;
+    PayloadAttribute payloadAtt;
+    CharTermAttribute termAtt;
+    PositionIncrementAttribute posIncrAtt;
+
+    public PayloadFilter(TokenStream input) {
+      super(input);
+      pos = 0;
+      entities.add("xx");
+      entities.add("one");
+      nopayload.add("nopayload");
+      nopayload.add("np");
+      termAtt = addAttribute(CharTermAttribute.class);
+      posIncrAtt = addAttribute(PositionIncrementAttribute.class);
+      payloadAtt = addAttribute(PayloadAttribute.class);
+    }
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (input.incrementToken()) {
+        String token = termAtt.toString();
+
+        if (!nopayload.contains(token)) {
+          if (entities.contains(token)) {
+            payloadAtt.setPayload(new BytesRef(token + ":Entity:"+ pos ));
+          } else {
+            payloadAtt.setPayload(new BytesRef(token + ":Noise:" + pos ));
+          }
+        }
+        pos += posIncrAtt.getPositionIncrement();
+        return true;
+      }
+      return false;
+    }
+
+    @Override
+    public void reset() throws IOException {
+      super.reset();
+      this.pos = 0;
+    }
+  }
+  
+  public final class TestPayloadAnalyzer extends Analyzer {
+
+    @Override
+    public TokenStreamComponents createComponents(String fieldName) {
+      Tokenizer result = new MockTokenizer(MockTokenizer.SIMPLE, true);
+      return new TokenStreamComponents(result, new PayloadFilter(result));
+    }
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
index f5a51e6..e02e941 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
@@ -18,15 +18,8 @@ package org.apache.lucene.search.spans;
  */
 
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
 
 import org.apache.lucene.analysis.*;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
@@ -38,16 +31,15 @@ import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Test;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
 
 /**
  * Tests basic search capabilities.
@@ -66,51 +58,11 @@ public class TestBasics extends LuceneTestCase {
   private static IndexReader reader;
   private static Directory directory;
 
-  static final class SimplePayloadFilter extends TokenFilter {
-    int pos;
-    final PayloadAttribute payloadAttr;
-    final CharTermAttribute termAttr;
-
-    public SimplePayloadFilter(TokenStream input) {
-      super(input);
-      pos = 0;
-      payloadAttr = input.addAttribute(PayloadAttribute.class);
-      termAttr = input.addAttribute(CharTermAttribute.class);
-    }
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (input.incrementToken()) {
-        payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
-        pos++;
-        return true;
-      } else {
-        return false;
-      }
-    }
-
-    @Override
-    public void reset() throws IOException {
-      super.reset();
-      pos = 0;
-    }
-  }
-  
-  static Analyzer simplePayloadAnalyzer;
-
   @BeforeClass
   public static void beforeClass() throws Exception {
-    simplePayloadAnalyzer = new Analyzer() {
-        @Override
-        public TokenStreamComponents createComponents(String fieldName) {
-          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
-          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
-        }
-    };
-  
     directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(simplePayloadAnalyzer)
+        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true))
             .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
     //writer.infoStream = System.out;
     for (int i = 0; i < 2000; i++) {
@@ -130,10 +82,8 @@ public class TestBasics extends LuceneTestCase {
     searcher = null;
     reader = null;
     directory = null;
-    simplePayloadAnalyzer = null;
   }
 
-  @Test
   public void testTerm() throws Exception {
     Query query = new TermQuery(new Term("field", "seventy"));
     checkHits(query, new int[]
@@ -157,13 +107,11 @@ public class TestBasics extends LuceneTestCase {
               1979});
     }
 
-  @Test
   public void testTerm2() throws Exception {
     Query query = new TermQuery(new Term("field", "seventish"));
     checkHits(query, new int[] {});
   }
 
-  @Test
   public void testPhrase() throws Exception {
     PhraseQuery query = new PhraseQuery();
     query.add(new Term("field", "seventy"));
@@ -173,7 +121,6 @@ public class TestBasics extends LuceneTestCase {
               977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
   }
 
-  @Test
   public void testPhrase2() throws Exception {
     PhraseQuery query = new PhraseQuery();
     query.add(new Term("field", "seventish"));
@@ -181,7 +128,6 @@ public class TestBasics extends LuceneTestCase {
     checkHits(query, new int[] {});
   }
 
-  @Test
   public void testBoolean() throws Exception {
     BooleanQuery query = new BooleanQuery();
     query.add(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST);
@@ -193,7 +139,6 @@ public class TestBasics extends LuceneTestCase {
               1977});
   }
 
-  @Test
   public void testBoolean2() throws Exception {
     BooleanQuery query = new BooleanQuery();
     query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
@@ -201,27 +146,19 @@ public class TestBasics extends LuceneTestCase {
     checkHits(query, new int[] {});
   }
 
-  @Test
   public void testSpanNearExact() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "seven"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
+    SpanQuery query = spanNearOrderedQuery("field", 0, "seventy", "seven");
+    
     checkHits(query, new int[]
       {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
 
     assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
     assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
-
-    QueryUtils.check(term1);
-    QueryUtils.check(term2);
-    QueryUtils.checkUnequal(term1,term2);
   }
   
   public void testSpanTermQuery() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
-    checkHits(term1, new int[]
-                             { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
+    checkHits(spanTermQuery("field", "seventy"), 
+              new int[] { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
         171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
         275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
         379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
@@ -239,38 +176,23 @@ public class TestBasics extends LuceneTestCase {
         1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
   }
 
-  @Test
   public void testSpanNearUnordered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, false);
-
-    checkHits(query, new int[]
-      {609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
+    checkHits(spanNearUnorderedQuery("field", 4, "nine", "six"), 
+              new int[] { 609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
               966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
               1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
               1996});
   }
 
-  @Test
   public void testSpanNearOrdered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, true);
-    checkHits(query, new int[]
-      {906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986, 1996});
+    checkHits(spanNearOrderedQuery("field", 4, "nine", "six"), 
+              new int[] { 906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 
+                          1936, 1946, 1956, 1966, 1976, 1986, 1996});
   }
 
-  @Test
   public void testSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNotQuery query = new SpanNotQuery(near, term3);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "forty"));
 
     checkHits(query, new int[]
       {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
@@ -279,17 +201,10 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
   }
   
-  @Test
   public void testSpanWithMultipleNotSingle() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-
-    SpanOrQuery or = new SpanOrQuery(term3);
-
-    SpanNotQuery query = new SpanNotQuery(near, or);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty");
+    SpanQuery query = spanNotQuery(near, or);
 
     checkHits(query, new int[]
       {801, 821, 831, 851, 861, 871, 881, 891,
@@ -299,19 +214,10 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
   }
 
-  @Test
   public void testSpanWithMultipleNotMany() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "sixty"));
-    SpanTermQuery term5 = new SpanTermQuery(new Term("field", "eighty"));
-
-    SpanOrQuery or = new SpanOrQuery(term3, term4, term5);
-
-    SpanNotQuery query = new SpanNotQuery(near, or);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty", "sixty", "eighty");
+    SpanQuery query = spanNotQuery(near, or);
 
     checkHits(query, new int[]
       {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
@@ -320,18 +226,10 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
   }
 
-  @Test
   public void testNpeInSpanNearWithSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery exclude = new SpanNearQuery(new SpanQuery[] {hun, term3},
-                                              1, true);
-    
-    SpanNotQuery query = new SpanNotQuery(near, exclude);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery exclude = spanNearOrderedQuery("field", 1, "hundred", "forty");
+    SpanQuery query = spanNotQuery(near, exclude);
 
     checkHits(query, new int[]
       {801, 821, 831, 851, 861, 871, 881, 891,
@@ -341,18 +239,12 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
   }
 
-  @Test
   public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
-    int n = 5;
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term40c = (SpanTermQuery)term40.clone();
-
-    SpanFirstQuery include = new SpanFirstQuery(term40, n);
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
-                                           n-1, true);
-    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
-    SpanNotQuery q = new SpanNotQuery(include, exclude);
+    final int n = 5;
+    SpanQuery include = spanFirstQuery(spanTermQuery("field", "forty"), n);
+    SpanQuery near = spanNearOrderedQuery("field", n-1, "hundred", "forty");
+    SpanQuery exclude = spanFirstQuery(near, n-1);
+    SpanQuery q = spanNotQuery(include, exclude);
     
     checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
             1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
@@ -363,14 +255,9 @@ public class TestBasics extends LuceneTestCase {
             1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
   }
   
-  @Test
   public void testSpanNotWindowOne() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
-    SpanNotQuery query = new SpanNotQuery(near, term3, 1, 1);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 1, 1);
 
     checkHits(query, new int[]
       {840, 842, 843, 844, 845, 846, 847, 848, 849,
@@ -380,14 +267,9 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
   }
   
-  @Test
   public void testSpanNotWindowTwoBefore() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
-    SpanNotQuery query = new SpanNotQuery(near, term3, 2, 0);
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 2, 0);
 
     checkHits(query, new int[]
       {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
@@ -396,48 +278,35 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
   }
 
-  @Test
   public void testSpanNotWindowNeg() throws Exception {
-     //test handling of invalid window < 0
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, true);
-     SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
+    //test handling of invalid window < 0
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty");
+    SpanQuery query = spanNotQuery(near, or);
 
-     SpanOrQuery or = new SpanOrQuery(term3);
-
-     SpanNotQuery query = new SpanNotQuery(near, or);
-
-     checkHits(query, new int[]
+    checkHits(query, new int[]
        {801, 821, 831, 851, 861, 871, 881, 891,
                1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
 
-     assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
   }
   
-  @Test
   public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
-     //test hitting two excludes before an include
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "forty"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "two"));
-     SpanNearQuery near = new SpanNearQuery(new SpanTermQuery[]{term1, term2}, 2, true);
-     SpanTermQuery exclude = new SpanTermQuery(new Term("field", "one"));
-
-     SpanNotQuery query = new SpanNotQuery(near, exclude, 4, 1);
+    //test hitting two excludes before an include
+    SpanQuery near = spanNearOrderedQuery("field", 2, "forty", "two");
+    SpanQuery exclude = spanTermQuery("field", "one");
+    SpanQuery query = spanNotQuery(near, exclude, 4, 1);
 
-     checkHits(query, new int[]
+    checkHits(query, new int[]
        {42, 242, 342, 442, 542, 642, 742, 842, 942});
 
-     assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
-     assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
   }
   
-  @Test
   public void testSpanFirst() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    SpanFirstQuery query = new SpanFirstQuery(term1, 1);
+    SpanQuery query = spanFirstQuery(spanTermQuery("field", "five"), 1);
 
     checkHits(query, new int[]
       {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
@@ -454,17 +323,16 @@ public class TestBasics extends LuceneTestCase {
 
   }
 
-  @Test
   public void testSpanPositionRange() throws Exception {
-    SpanPositionRangeQuery query;
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    query = new SpanPositionRangeQuery(term1, 1, 2);
+    SpanQuery term1 = spanTermQuery("field", "five");
+    SpanQuery query = spanPositionRangeQuery(term1, 1, 2);
+    
     checkHits(query, new int[]
       {25,35, 45, 55, 65, 75, 85, 95});
     assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
     assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
 
-    query = new SpanPositionRangeQuery(term1, 0, 1);
+    query = spanPositionRangeQuery(term1, 0, 1);
     checkHits(query, new int[]
       {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
               513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
@@ -476,98 +344,14 @@ public class TestBasics extends LuceneTestCase {
               585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
               598, 599});
 
-    query = new SpanPositionRangeQuery(term1, 6, 7);
-    checkHits(query, new int[]{});
-  }
-
-  @Test
-  public void testSpanPayloadCheck() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
-    SpanQuery query = new SpanPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
-    checkHits(query, new int[]
-      {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
-    assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
-
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
-    SpanNearQuery snq;
-    SpanQuery[] clauses;
-    List<byte[]> list;
-    BytesRef pay2;
-    clauses = new SpanQuery[2];
-    clauses[0] = term1;
-    clauses[1] = term2;
-    snq = new SpanNearQuery(clauses, 0, true);
-    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    list = new ArrayList<>();
-    list.add(pay.bytes);
-    list.add(pay2.bytes);
-    query = new SpanNearPayloadCheckQuery(snq, list);
-    checkHits(query, new int[]
-      {500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599});
-    clauses = new SpanQuery[3];
-    clauses[0] = term1;
-    clauses[1] = term2;
-    clauses[2] = new SpanTermQuery(new Term("field", "five"));
-    snq = new SpanNearQuery(clauses, 0, true);
-    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay3 = new BytesRef(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
-    list = new ArrayList<>();
-    list.add(pay.bytes);
-    list.add(pay2.bytes);
-    list.add(pay3.bytes);
-    query = new SpanNearPayloadCheckQuery(snq, list);
-    checkHits(query, new int[]
-      {505});
-  }
-
-  public void testComplexSpanChecks() throws Exception {
-    SpanTermQuery one = new SpanTermQuery(new Term("field", "one"));
-    SpanTermQuery thous = new SpanTermQuery(new Term("field", "thousand"));
-    //should be one position in between
-    SpanTermQuery hundred = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery three = new SpanTermQuery(new Term("field", "three"));
-
-    SpanNearQuery oneThous = new SpanNearQuery(new SpanQuery[]{one, thous}, 0, true);
-    SpanNearQuery hundredThree = new SpanNearQuery(new SpanQuery[]{hundred, three}, 0, true);
-    SpanNearQuery oneThousHunThree = new SpanNearQuery(new SpanQuery[]{oneThous, hundredThree}, 1, true);
-    SpanQuery query;
-    //this one's too small
-    query = new SpanPositionRangeQuery(oneThousHunThree, 1, 2);
+    query = spanPositionRangeQuery(term1, 6, 7);
     checkHits(query, new int[]{});
-    //this one's just right
-    query = new SpanPositionRangeQuery(oneThousHunThree, 0, 6);
-    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
-
-    Collection<byte[]> payloads = new ArrayList<>();
-    BytesRef pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay3 = new BytesRef(("pos: " + 3).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay4 = new BytesRef(("pos: " + 4).getBytes(StandardCharsets.UTF_8));
-    payloads.add(pay.bytes);
-    payloads.add(pay2.bytes);
-    payloads.add(pay3.bytes);
-    payloads.add(pay4.bytes);
-    query = new SpanNearPayloadCheckQuery(oneThousHunThree, payloads);
-    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
-
   }
 
-
-  @Test
   public void testSpanOr() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "three"));
-    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "seven"));
-    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
-                                            0, true);
-
-    SpanOrQuery query = new SpanOrQuery(near1, near2);
+    SpanQuery near1 = spanNearOrderedQuery("field", 0, "thirty", "three");
+    SpanQuery near2 = spanNearOrderedQuery("field", 0, "forty", "seven");
+    SpanQuery query = spanOrQuery(near1, near2);
 
     checkHits(query, new int[]
       {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
@@ -578,40 +362,21 @@ public class TestBasics extends LuceneTestCase {
     assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
   }
 
-  @Test
   public void testSpanExactNested() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "three"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
-    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "three"));
-    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
-                                            0, true);
-
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {near1, near2},
-                                            0, true);
-
+    SpanQuery near1 = spanNearOrderedQuery("field", 0, "three", "hundred");
+    SpanQuery near2 = spanNearOrderedQuery("field", 0, "thirty", "three");
+    SpanQuery query = spanNearOrderedQuery(0, near1, near2);
+    
     checkHits(query, new int[] {333, 1333});
 
     assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
   }
 
-  @Test
   public void testSpanNearOr() throws Exception {
-
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
-    
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
-
-    SpanOrQuery to1 = new SpanOrQuery(t1, t3);
-    SpanOrQuery to2 = new SpanOrQuery(t5, t6);
+    SpanQuery to1 = spanOrQuery("field", "six", "seven");
+    SpanQuery to2 = spanOrQuery("field", "seven", "six");
+    SpanQuery query = spanNearOrderedQuery(10, to1, to2);
     
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
-                                            10, true);
-
     checkHits(query, new int[]
       {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
               686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
@@ -622,25 +387,13 @@ public class TestBasics extends LuceneTestCase {
               1797});
   }
 
-  @Test
   public void testSpanComplex1() throws Exception {
-      
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field","hundred"));
-    SpanNearQuery tt1 = new SpanNearQuery(new SpanQuery[] {t1, t2}, 0,true);
-
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t4 = new SpanTermQuery(new Term("field","hundred"));
-    SpanNearQuery tt2 = new SpanNearQuery(new SpanQuery[] {t3, t4}, 0,true);
-    
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
+    SpanQuery tt1 = spanNearOrderedQuery("field", 0, "six", "hundred");
+    SpanQuery tt2 = spanNearOrderedQuery("field", 0, "seven", "hundred");
 
-    SpanOrQuery to1 = new SpanOrQuery(tt1, tt2);
-    SpanOrQuery to2 = new SpanOrQuery(t5, t6);
-    
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
-                                            100, true);
+    SpanQuery to1 = spanOrQuery(tt1, tt2);
+    SpanQuery to2 = spanOrQuery("field", "seven", "six");
+    SpanQuery query = spanNearOrderedQuery(100, to1, to2);
     
     checkHits(query, new int[]
       {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
index 677749b..bbf4836 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
@@ -36,6 +36,8 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 public class TestFieldMaskingSpanQuery extends LuceneTestCase {
 
   protected static Document doc(Field[] fields) {
@@ -260,17 +262,16 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
     check(q, new int[] { 0, 1, 2, 3, 4 });
 
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-
-    TestSpans.tstNextSpans(span, 0,0,1);
-    TestSpans.tstNextSpans(span, 1,0,1);
-    TestSpans.tstNextSpans(span, 1,1,2);
-    TestSpans.tstNextSpans(span, 2,0,1);
-    TestSpans.tstNextSpans(span, 2,1,2);
-    TestSpans.tstNextSpans(span, 2,2,3);
-    TestSpans.tstNextSpans(span, 3,0,1);
-    TestSpans.tstNextSpans(span, 4,0,1);
-    TestSpans.tstNextSpans(span, 4,1,2);
-    TestSpans.tstEndSpans(span);
+    assertNext(span, 0,0,1);
+    assertNext(span, 1,0,1);
+    assertNext(span, 1,1,2);
+    assertNext(span, 2,0,1);
+    assertNext(span, 2,1,2);
+    assertNext(span, 2,2,3);
+    assertNext(span, 3,0,1);
+    assertNext(span, 4,0,1);
+    assertNext(span, 4,1,2);
+    assertFinished(span);
   }
   
   public void testSpans1() throws Exception {
@@ -309,13 +310,12 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
     check(q, new int[] { 0, 1, 2, 3 });
 
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-
-    TestSpans.tstNextSpans(span, 0,0,1);
-    TestSpans.tstNextSpans(span, 1,1,2);
-    TestSpans.tstNextSpans(span, 2,0,1);
-    TestSpans.tstNextSpans(span, 2,2,3);
-    TestSpans.tstNextSpans(span, 3,0,1);
-    TestSpans.tstEndSpans(span);
+    assertNext(span, 0,0,1);
+    assertNext(span, 1,1,2);
+    assertNext(span, 2,0,1);
+    assertNext(span, 2,2,3);
+    assertNext(span, 3,0,1);
+    assertFinished(span);
   }
   
   public String s(int doc, int start, int end) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index 1af6bf1..c6938b4 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -20,7 +20,6 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
@@ -34,6 +33,8 @@ import org.apache.lucene.search.Weight;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 public class TestNearSpansOrdered extends LuceneTestCase {
   protected IndexSearcher searcher;
   protected Directory directory;
@@ -115,9 +116,9 @@ public class TestNearSpansOrdered extends LuceneTestCase {
   public void testNearSpansNext() throws Exception {
     SpanNearQuery q = makeQuery();
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    TestSpans.tstNextSpans(span,0,0,3);
-    TestSpans.tstNextSpans(span,1,0,4);
-    TestSpans.tstEndSpans(span);
+    assertNext(span,0,0,3);
+    assertNext(span,1,0,4);
+    assertFinished(span);
   }
 
   /**
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
deleted file mode 100644
index 134fc23..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
+++ /dev/null
@@ -1,531 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/**
- * Copyright 2004 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.payloads.PayloadHelper;
-import org.apache.lucene.search.payloads.PayloadSpanUtil;
-import org.apache.lucene.search.similarities.DefaultSimilarity;
-import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase;
-
-public class TestPayloadSpans extends LuceneTestCase {
-  private IndexSearcher searcher;
-  private Similarity similarity = new DefaultSimilarity();
-  protected IndexReader indexReader;
-  private IndexReader closeIndexReader;
-  private Directory directory;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    PayloadHelper helper = new PayloadHelper();
-    searcher = helper.setUp(random(), similarity, 1000);
-    indexReader = searcher.getIndexReader();
-  }
-
-  public void testSpanTermQuery() throws Exception {
-    SpanTermQuery stq;
-    Spans spans;
-    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
-    spans = MultiSpansWrapper.wrap(indexReader, stq);
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 100, 1, 1, 1);
-
-    stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
-    spans = MultiSpansWrapper.wrap(indexReader, stq);
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 100, 0, 0, 0);
-  }
-
-  public void testSpanFirst() throws IOException {
-
-    SpanQuery match;
-    SpanFirstQuery sfq;
-    match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    sfq = new SpanFirstQuery(match, 2);
-    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq);
-    checkSpans(spans, 109, 1, 1, 1);
-    //Test more complicated subclause
-    SpanQuery[] clauses = new SpanQuery[2];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
-    match = new SpanNearQuery(clauses, 0, true);
-    sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
-
-    match = new SpanNearQuery(clauses, 0, false);
-    sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
-    
-  }
-  
-  public void testSpanNot() throws Exception {
-    SpanQuery[] clauses = new SpanQuery[2];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
-    SpanQuery spq = new SpanNearQuery(clauses, 5, true);
-    SpanNotQuery snq = new SpanNotQuery(spq, new SpanTermQuery(new Term(PayloadHelper.FIELD, "two")));
-
-
-
-    Directory directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
-
-    Document doc = new Document();
-    doc.add(newTextField(PayloadHelper.FIELD, "one two three one four three", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader reader = writer.getReader();
-    writer.close();
-    
-
-    checkSpans(MultiSpansWrapper.wrap(reader, snq), 1,new int[]{2});
-    reader.close();
-    directory.close();
-  }
-  
-  public void testNestedSpans() throws Exception {
-    SpanTermQuery stq;
-    Spans spans;
-    IndexSearcher searcher = getSearcher();
-    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq);
-    assertNull(spans);
-
-    SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
-    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
-
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
-
-     
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
-
-    spanNearQuery = new SpanNearQuery(clauses, 6, true);
-   
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
-
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 1, new int[]{3});
-     
-    clauses = new SpanQuery[2];
-     
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
-
-    spanNearQuery = new SpanNearQuery(clauses, 6, true);
-     
-    // xx within 6 of rr
-    
-    SpanQuery[] clauses2 = new SpanQuery[2];
-     
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
-    clauses2[1] = spanNearQuery;
-     
-    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
-    
-    // yy within 6 of xx within 6 of rr
-
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
-    closeIndexReader.close();
-    directory.close();
-  }
-  
-  public void testFirstClauseWithoutPayload() throws Exception {
-    Spans spans;
-    IndexSearcher searcher = getSearcher();
-
-    SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nopayload"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "qq"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ss"));
-
-    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 6, true);
-    
-    SpanQuery[] clauses2 = new SpanQuery[2];
-     
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "pp"));
-    clauses2[1] = spanNearQuery;
-
-    SpanNearQuery snq = new SpanNearQuery(clauses2, 6, false);
-    
-    SpanQuery[] clauses3 = new SpanQuery[2];
-     
-    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "np"));
-    clauses3[1] = snq;
-     
-    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
-
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 1, new int[]{3});
-    closeIndexReader.close();
-    directory.close();
-  }
-  
-  public void testHeavilyNestedSpanQuery() throws Exception {
-    Spans spans;
-    IndexSearcher searcher = getSearcher();
-
-    SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "two"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
-
-    SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 5, true);
-   
-    clauses = new SpanQuery[3];
-    clauses[0] = spanNearQuery; 
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "five"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "six"));
-
-    SpanNearQuery spanNearQuery2 = new SpanNearQuery(clauses, 6, true);
-     
-    SpanQuery[] clauses2 = new SpanQuery[2];
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "eleven"));
-    clauses2[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ten"));
-    SpanNearQuery spanNearQuery3 = new SpanNearQuery(clauses2, 2, false);
-    
-    SpanQuery[] clauses3 = new SpanQuery[3];
-    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nine"));
-    clauses3[1] = spanNearQuery2;
-    clauses3[2] = spanNearQuery3;
-     
-    SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
-
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{8, 8});
-    closeIndexReader.close();
-    directory.close();
-  }
-  
-  public void testShrinkToAfterShortestMatch() throws IOException {
-    Directory directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
-
-    Document doc = new Document();
-    doc.add(new TextField("content", new StringReader("a b c d e f g h i j a k")));
-    writer.addDocument(doc);
-
-    IndexReader reader = writer.getReader();
-    IndexSearcher is = newSearcher(reader);
-    writer.close();
-
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
-    SpanQuery[] sqs = { stq1, stq2 };
-    SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
-
-    TopDocs topDocs = is.search(snq, 1);
-    Set<String> payloadSet = new HashSet<>();
-    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
-  
-          for (final byte [] payload : payloads) {
-            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
-          }
-        }
-      }
-    }
-    assertEquals(2, payloadSet.size());
-    assertTrue(payloadSet.contains("a:Noise:10"));
-    assertTrue(payloadSet.contains("k:Noise:11"));
-    reader.close();
-    directory.close();
-  }
-  
-  public void testShrinkToAfterShortestMatch2() throws IOException {
-    Directory directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
-
-    Document doc = new Document();
-    doc.add(new TextField("content", new StringReader("a b a d k f a h i k a k")));
-    writer.addDocument(doc);
-    IndexReader reader = writer.getReader();
-    IndexSearcher is = newSearcher(reader);
-    writer.close();
-
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
-    SpanQuery[] sqs = { stq1, stq2 };
-    SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
-
-    TopDocs topDocs = is.search(snq, 1);
-    Set<String> payloadSet = new HashSet<>();
-    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
-  
-          for (final byte [] payload : payloads) {
-            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
-          }
-        }
-      }
-    }
-    assertEquals(2, payloadSet.size());
-    assertTrue(payloadSet.contains("a:Noise:10"));
-    assertTrue(payloadSet.contains("k:Noise:11"));
-    reader.close();
-    directory.close();
-  }
-  
-  public void testShrinkToAfterShortestMatch3() throws IOException {
-    Directory directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
-
-    Document doc = new Document();
-    doc.add(new TextField("content", new StringReader("j k a l f k k p a t a k l k t a")));
-    writer.addDocument(doc);
-    IndexReader reader = writer.getReader();
-    IndexSearcher is = newSearcher(reader);
-    writer.close();
-
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
-    SpanQuery[] sqs = { stq1, stq2 };
-    SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
-
-    TopDocs topDocs = is.search(snq, 1);
-    Set<String> payloadSet = new HashSet<>();
-    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
-  
-          for (final byte [] payload : payloads) {
-            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
-          }
-        }
-      }
-    }
-    assertEquals(2, payloadSet.size());
-    if(VERBOSE) {
-      for (final String payload : payloadSet)
-        System.out.println("match:" +  payload);
-      
-    }
-    assertTrue(payloadSet.contains("a:Noise:10"));
-    assertTrue(payloadSet.contains("k:Noise:11"));
-    reader.close();
-    directory.close();
-  }
-  
-  public void testPayloadSpanUtil() throws Exception {
-    Directory directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
-
-    Document doc = new Document();
-    doc.add(newTextField(PayloadHelper.FIELD, "xx rr yy mm  pp", Field.Store.YES));
-    writer.addDocument(doc);
-  
-    IndexReader reader = writer.getReader();
-    writer.close();
-    IndexSearcher searcher = newSearcher(reader);
-
-    PayloadSpanUtil psu = new PayloadSpanUtil(searcher.getTopReaderContext());
-    
-    Collection<byte[]> payloads = psu.getPayloadsForQuery(new TermQuery(new Term(PayloadHelper.FIELD, "rr")));
-    if(VERBOSE) {
-      System.out.println("Num payloads:" + payloads.size());
-      for (final byte [] bytes : payloads) {
-        System.out.println(new String(bytes, StandardCharsets.UTF_8));
-      }
-    }
-    reader.close();
-    directory.close();
-  }
-
-  private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
-                          int expectedPayloadLength, int expectedFirstByte) throws IOException {
-    assertTrue("spans is null and it shouldn't be", spans != null);
-    //each position match should have a span associated with it, since there is just one underlying term query, there should
-    //only be one entry in the span
-    int seen = 0;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-        assertEquals("isPayloadAvailable should return true/false as payloads are expected", expectedNumPayloads > 0, spans.isPayloadAvailable());
-        //See payload helper, for the PayloadHelper.FIELD field, there is a single byte payload at every token
-        if (spans.isPayloadAvailable()) {
-          Collection<byte[]> payload = spans.getPayload();
-          assertEquals("payload size", expectedNumPayloads, payload.size());
-          for (final byte [] thePayload : payload) {
-            assertEquals("payload length", expectedPayloadLength, thePayload.length);
-            assertEquals("payload first byte", expectedFirstByte, thePayload[0]);
-          }
-        }
-        seen++;
-      }
-    }
-    assertEquals("expectedNumSpans", expectedNumSpans, seen);
-  }
-  
-  private IndexSearcher getSearcher() throws Exception {
-    directory = newDirectory();
-    String[] docs = new String[]{"xx rr yy mm  pp","xx yy mm rr pp", "nopayload qq ss pp np", "one two three four five six seven eight nine ten eleven", "nine one two three four five six seven eight eleven ten"};
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
-
-    Document doc = null;
-    for(int i = 0; i < docs.length; i++) {
-      doc = new Document();
-      String docText = docs[i];
-      doc.add(newTextField(PayloadHelper.FIELD, docText, Field.Store.YES));
-      writer.addDocument(doc);
-    }
-
-    closeIndexReader = writer.getReader();
-    writer.close();
-
-    IndexSearcher searcher = newSearcher(closeIndexReader);
-    return searcher;
-  }
-  
-  private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
-    int cnt = 0;
-
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-        if(VERBOSE)
-          System.out.println("\nSpans Dump --");
-        if (spans.isPayloadAvailable()) {
-          Collection<byte[]> payload = spans.getPayload();
-          if(VERBOSE) {
-            System.out.println("payloads for span:" + payload.size());
-            for (final byte [] bytes : payload) {
-              System.out.println("doc:" + spans.docID() + " s:" + spans.startPosition() + " e:" + spans.endPosition() + " "
-                + new String(bytes, StandardCharsets.UTF_8));
-            }
-          }
-          assertEquals("payload size", numPayloads[cnt], payload.size());
-        } else { // no payload available
-          assertFalse("Expected spans:" + numPayloads[cnt] + " found: 0", numPayloads.length > 0 && numPayloads[cnt] > 0 );
-        }
-        cnt++;
-      }
-    }
-
-    assertEquals("expected numSpans", numSpans, cnt);
-  }
-
-  final class PayloadAnalyzer extends Analyzer {
-
-    @Override
-    public TokenStreamComponents createComponents(String fieldName) {
-      Tokenizer result = new MockTokenizer(MockTokenizer.SIMPLE, true);
-      return new TokenStreamComponents(result, new PayloadFilter(result));
-    }
-  }
-
-  final class PayloadFilter extends TokenFilter {
-    Set<String> entities = new HashSet<>();
-    Set<String> nopayload = new HashSet<>();
-    int pos;
-    PayloadAttribute payloadAtt;
-    CharTermAttribute termAtt;
-    PositionIncrementAttribute posIncrAtt;
-
-    public PayloadFilter(TokenStream input) {
-      super(input);
-      pos = 0;
-      entities.add("xx");
-      entities.add("one");
-      nopayload.add("nopayload");
-      nopayload.add("np");
-      termAtt = addAttribute(CharTermAttribute.class);
-      posIncrAtt = addAttribute(PositionIncrementAttribute.class);
-      payloadAtt = addAttribute(PayloadAttribute.class);
-    }
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (input.incrementToken()) {
-        String token = termAtt.toString();
-
-        if (!nopayload.contains(token)) {
-          if (entities.contains(token)) {
-            payloadAtt.setPayload(new BytesRef(token + ":Entity:"+ pos ));
-          } else {
-            payloadAtt.setPayload(new BytesRef(token + ":Noise:" + pos ));
-          }
-        }
-        pos += posIncrAtt.getPositionIncrement();
-        return true;
-      }
-      return false;
-    }
-
-    @Override
-    public void reset() throws IOException {
-      super.reset();
-      this.pos = 0;
-    }
-  }
-  
-  public final class TestPayloadAnalyzer extends Analyzer {
-
-    @Override
-    public TokenStreamComponents createComponents(String fieldName) {
-      Tokenizer result = new MockTokenizer(MockTokenizer.SIMPLE, true);
-      return new TokenStreamComponents(result, new PayloadFilter(result));
-    }
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
index aab5a9e..d234d55 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
@@ -19,6 +19,7 @@ package org.apache.lucene.search.spans;
 
 import org.apache.lucene.search.*;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
 
 /**
  * TestExplanations subclass focusing on span queries
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
index 3567285..8f9c460 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
@@ -24,13 +24,14 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 public class TestSpanFirstQuery extends LuceneTestCase {
   public void testStartPositions() throws Exception {
     Directory dir = newDirectory();
@@ -51,12 +52,12 @@ public class TestSpanFirstQuery extends LuceneTestCase {
     IndexSearcher searcher = newSearcher(reader);
     
     // user queries on "starts-with quick"
-    SpanQuery sfq = new SpanFirstQuery(new SpanTermQuery(new Term("field", "quick")), 1);
+    SpanQuery sfq = spanFirstQuery(spanTermQuery("field", "quick"), 1);
     assertEquals(1, searcher.search(sfq, 10).totalHits);
     
     // user queries on "starts-with the quick"
-    SpanQuery include = new SpanFirstQuery(new SpanTermQuery(new Term("field", "quick")), 2);
-    sfq = new SpanNotQuery(include, sfq);
+    SpanQuery include = spanFirstQuery(spanTermQuery("field", "quick"), 2);
+    sfq = spanNotQuery(include, sfq);
     assertEquals(1, searcher.search(sfq, 10).totalHits);
     
     writer.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java
new file mode 100644
index 0000000..150700b
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanOrQuery */
+public class TestSpanOrQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
+    
+    SpanOrQuery or1 = new SpanOrQuery(q1, q2);
+    SpanOrQuery or2 = new SpanOrQuery(q2, q3);
+    QueryUtils.check(or1);
+    QueryUtils.check(or2);
+    QueryUtils.checkUnequal(or1, or2);
+  }
+  
+  public void testSpanOrEmpty() throws Exception {
+    SpanOrQuery a = new SpanOrQuery();
+    SpanOrQuery b = new SpanOrQuery();
+    assertTrue("empty should equal", a.equals(b));
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
index 9834ef2..04c80d9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
@@ -25,6 +25,8 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SearchEquivalenceTestBase;
 import org.apache.lucene.search.TermQuery;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 /**
  * Basic equivalence tests for span queries
  */
@@ -33,20 +35,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   // TODO: we could go a little crazy for a lot of these,
   // but these are just simple minimal cases in case something 
   // goes horribly wrong. Put more intense tests elsewhere.
-  
-  /** generally wrap with asserting. but not always, so we don't hide bugs */
-  private SpanQuery span(SpanQuery query) {
-    if (random().nextInt(100) <= 95) {
-      return new AssertingSpanQuery(query);
-    } else {
-      return query;
-    }
-  }
 
   /** SpanTermQuery(A) = TermQuery(A) */
   public void testSpanTermVersusTerm() throws Exception {
     Term t1 = randomTerm();
-    assertSameSet(new TermQuery(t1), span(new SpanTermQuery(t1)));
+    assertSameSet(new TermQuery(t1), spanQuery(new SpanTermQuery(t1)));
   }
   
   /** SpanOrQuery(A, B) = (A B) */
@@ -56,7 +49,7 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     BooleanQuery q1 = new BooleanQuery();
     q1.add(new TermQuery(t1), Occur.SHOULD);
     q1.add(new TermQuery(t2), Occur.SHOULD);
-    SpanQuery q2 = span(new SpanOrQuery(span(new SpanTermQuery(t1)), span(new SpanTermQuery(t2))));
+    SpanQuery q2 = spanQuery(new SpanOrQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2))));
     assertSameSet(q1, q2);
   }
   
@@ -64,8 +57,8 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   public void testSpanNotVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    assertSubsetOf(span(new SpanNotQuery(span(new SpanTermQuery(t1)), span(new SpanTermQuery(t2)))), 
-                   span(new SpanTermQuery(t1)));
+    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2)))), 
+                   spanQuery(new SpanTermQuery(t1)));
   }
   
   /** SpanNotQuery(A, [B C]) ?? SpanTermQuery(A) */
@@ -73,11 +66,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery near = span(new SpanNearQuery(new SpanQuery[] { 
-                                              span(new SpanTermQuery(t2)), 
-                                              span(new SpanTermQuery(t3)) 
+    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                              spanQuery(new SpanTermQuery(t2)), 
+                                              spanQuery(new SpanTermQuery(t3)) 
                                             }, 10, random().nextBoolean()));
-    assertSubsetOf(span(new SpanNotQuery(span(new SpanTermQuery(t1)), near)), span(new SpanTermQuery(t1)));
+    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), near)), spanQuery(new SpanTermQuery(t1)));
   }
   
   /** SpanNotQuery([A B], C) ?? SpanNearQuery([A B]) */
@@ -85,11 +78,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery near = span(new SpanNearQuery(new SpanQuery[] { 
-                                              span(new SpanTermQuery(t1)), 
-                                              span(new SpanTermQuery(t2)) 
+    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                              spanQuery(new SpanTermQuery(t1)), 
+                                              spanQuery(new SpanTermQuery(t2)) 
                                             }, 10, random().nextBoolean()));
-    assertSubsetOf(span(new SpanNotQuery(near, span(new SpanTermQuery(t3)))), near);
+    assertSubsetOf(spanQuery(new SpanNotQuery(near, spanQuery(new SpanTermQuery(t3)))), near);
   }
   
   /** SpanNotQuery([A B], [C D]) ?? SpanNearQuery([A B]) */
@@ -98,22 +91,22 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t2 = randomTerm();
     Term t3 = randomTerm();
     Term t4 = randomTerm();
-    SpanQuery near1 = span(new SpanNearQuery(new SpanQuery[] { 
-                                               span(new SpanTermQuery(t1)), 
-                                               span(new SpanTermQuery(t2)) 
+    SpanQuery near1 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t1)), 
+                                               spanQuery(new SpanTermQuery(t2)) 
                                              }, 10, random().nextBoolean()));
-    SpanQuery near2 = span(new SpanNearQuery(new SpanQuery[] { 
-                                               span(new SpanTermQuery(t3)), 
-                                               span(new SpanTermQuery(t4)) 
+    SpanQuery near2 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t3)), 
+                                               spanQuery(new SpanTermQuery(t4)) 
                                              }, 10, random().nextBoolean()));
-    assertSubsetOf(span(new SpanNotQuery(near1, near2)), near1);
+    assertSubsetOf(spanQuery(new SpanNotQuery(near1, near2)), near1);
   }
   
   /** SpanFirstQuery(A, 10) ?? SpanTermQuery(A) */
   public void testSpanFirstVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
-    assertSubsetOf(span(new SpanFirstQuery(span(new SpanTermQuery(t1)), 10)), 
-                   span(new SpanTermQuery(t1)));
+    assertSubsetOf(spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), 10)), 
+                   spanQuery(new SpanTermQuery(t1)));
   }
   
   /** SpanNearQuery([A, B], 0, true) = "A B" */
@@ -121,10 +114,10 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery q1 = span(new SpanNearQuery(subquery, 0, true));
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, true));
     PhraseQuery q2 = new PhraseQuery();
     q2.add(t1);
     q2.add(t2);
@@ -136,10 +129,10 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery q1 = span(new SpanNearQuery(subquery, Integer.MAX_VALUE, false));
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, Integer.MAX_VALUE, false));
     BooleanQuery q2 = new BooleanQuery();
     q2.add(new TermQuery(t1), Occur.MUST);
     q2.add(new TermQuery(t2), Occur.MUST);
@@ -151,11 +144,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery q1 = span(new SpanNearQuery(subquery, 0, false));
-    SpanQuery q2 = span(new SpanNearQuery(subquery, 1, false));
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, false));
+    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 1, false));
     assertSubsetOf(q1, q2);
   }
   
@@ -164,11 +157,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery q1 = span(new SpanNearQuery(subquery, 3, true));
-    SpanQuery q2 = span(new SpanNearQuery(subquery, 3, false));
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 3, true));
+    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 3, false));
     assertSubsetOf(q1, q2);
   }
   
@@ -177,12 +170,12 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
     for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = span(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = span(new SpanNearQuery(subquery, i+1, false));
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
       assertSubsetOf(q1, q2);
     }
   }
@@ -193,13 +186,13 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t2 = randomTerm();
     Term t3 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)), 
-                             span(new SpanTermQuery(t3)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)), 
+                             spanQuery(new SpanTermQuery(t3)) 
                            };
     for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = span(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = span(new SpanNearQuery(subquery, i+1, false));
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
       assertSubsetOf(q1, q2);
     }
   }
@@ -209,12 +202,12 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
     for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = span(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = span(new SpanNearQuery(subquery, i+1, false));
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
       assertSubsetOf(q1, q2);
     }
   }
@@ -225,13 +218,13 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t2 = randomTerm();
     Term t3 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)), 
-                             span(new SpanTermQuery(t3)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)), 
+                             spanQuery(new SpanTermQuery(t3)) 
                            };
     for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = span(new SpanNearQuery(subquery, i, true));
-      SpanQuery q2 = span(new SpanNearQuery(subquery, i+1, true));
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, true));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, true));
       assertSubsetOf(q1, q2);
     }
   }
@@ -241,7 +234,7 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = span(new SpanPositionRangeQuery(span(new SpanTermQuery(t1)), i, i+j));
+        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
         Query q2 = new TermQuery(t1);
         assertSubsetOf(q1, q2);
       }
@@ -253,8 +246,8 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = span(new SpanPositionRangeQuery(span(new SpanTermQuery(t1)), i, i+j));
-        Query q2 = span(new SpanPositionRangeQuery(span(new SpanTermQuery(t1)), i, i+j+1));
+        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
+        Query q2 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j+1));
         assertSubsetOf(q1, q2);
       }
     }
@@ -263,7 +256,7 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   /** SpanPositionRangeQuery(A, 0, ??) = TermQuery(A) */
   public void testSpanRangeTermEverything() throws Exception {
     Term t1 = randomTerm();
-    Query q1 = span(new SpanPositionRangeQuery(span(new SpanTermQuery(t1)), 0, Integer.MAX_VALUE));
+    Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), 0, Integer.MAX_VALUE));
     Query q2 = new TermQuery(t1);
     assertSameSet(q1, q2);
   }
@@ -273,13 +266,13 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = span(new SpanPositionRangeQuery(nearQuery, i, i+j));
+        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
         Query q2 = nearQuery;
         assertSubsetOf(q1, q2);
       }
@@ -291,14 +284,14 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = span(new SpanPositionRangeQuery(nearQuery, i, i+j));
-        Query q2 = span(new SpanPositionRangeQuery(nearQuery, i, i+j+1));
+        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
+        Query q2 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j+1));
         assertSubsetOf(q1, q2);
       }
     }
@@ -309,11 +302,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
-    Query q1 = span(new SpanPositionRangeQuery(nearQuery, 0, Integer.MAX_VALUE));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, 0, Integer.MAX_VALUE));
     Query q2 = nearQuery;
     assertSameSet(q1, q2);
   }
@@ -322,7 +315,7 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   public void testSpanFirstTerm() throws Exception {
     Term t1 = randomTerm();
     for (int i = 0; i < 10; i++) {
-      Query q1 = span(new SpanFirstQuery(span(new SpanTermQuery(t1)), i));
+      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
       Query q2 = new TermQuery(t1);
       assertSubsetOf(q1, q2);
     }
@@ -332,8 +325,8 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   public void testSpanFirstTermIncreasing() throws Exception {
     Term t1 = randomTerm();
     for (int i = 0; i < 10; i++) {
-      Query q1 = span(new SpanFirstQuery(span(new SpanTermQuery(t1)), i));
-      Query q2 = span(new SpanFirstQuery(span(new SpanTermQuery(t1)), i+1));
+      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
+      Query q2 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i+1));
       assertSubsetOf(q1, q2);
     }
   }
@@ -341,7 +334,7 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
   /** SpanFirstQuery(A, ??) = TermQuery(A) */
   public void testSpanFirstTermEverything() throws Exception {
     Term t1 = randomTerm();
-    Query q1 = span(new SpanFirstQuery(span(new SpanTermQuery(t1)), Integer.MAX_VALUE));
+    Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), Integer.MAX_VALUE));
     Query q2 = new TermQuery(t1);
     assertSameSet(q1, q2);
   }
@@ -351,12 +344,12 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
     for (int i = 0; i < 10; i++) {
-      Query q1 = span(new SpanFirstQuery(nearQuery, i));
+      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
       Query q2 = nearQuery;
       assertSubsetOf(q1, q2);
     }
@@ -367,13 +360,13 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
     for (int i = 0; i < 10; i++) {
-      Query q1 = span(new SpanFirstQuery(nearQuery, i));
-      Query q2 = span(new SpanFirstQuery(nearQuery, i+1));
+      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
+      Query q2 = spanQuery(new SpanFirstQuery(nearQuery, i+1));
       assertSubsetOf(q1, q2);
     }
   }
@@ -383,11 +376,11 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     SpanQuery subquery[] = new SpanQuery[] { 
-                             span(new SpanTermQuery(t1)), 
-                             span(new SpanTermQuery(t2)) 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
                            };
-    SpanQuery nearQuery = span(new SpanNearQuery(subquery, 10, true));
-    Query q1 = span(new SpanFirstQuery(nearQuery, Integer.MAX_VALUE));
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    Query q1 = spanQuery(new SpanFirstQuery(nearQuery, Integer.MAX_VALUE));
     Query q2 = nearQuery;
     assertSameSet(q1, q2);
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
new file mode 100644
index 0000000..13934ce
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
@@ -0,0 +1,34 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanTermQuery */
+public class TestSpanTermQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    QueryUtils.check(q1);
+    QueryUtils.check(q2);
+    QueryUtils.checkUnequal(q1, q2);
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 5a8bad9..d9d53f3 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -43,6 +43,8 @@ import org.apache.lucene.util.LuceneTestCase;
 import java.io.IOException;
 import java.util.List;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 public class TestSpans extends LuceneTestCase {
   private IndexSearcher searcher;
   private IndexReader reader;
@@ -87,10 +89,6 @@ public class TestSpans extends LuceneTestCase {
     "t1 t2 t1 t3 t2 t3",
     "s2 s1 s1 xx xx s2 xx s2 xx s1 xx xx xx xx xx s2 xx"
   };
-
-  public SpanTermQuery makeSpanTermQuery(String text) {
-    return new SpanTermQuery(new Term(field, text));
-  }
   
   private void checkHits(Query query, int[] results) throws IOException {
     CheckHits.checkHits(random(), query, field, searcher, results);
@@ -102,34 +100,33 @@ public class TestSpans extends LuceneTestCase {
         SpanQuery q3,
         int slop,
         int[] expectedDocs) throws IOException {
-    boolean ordered = true;
-    SpanNearQuery snq = new SpanNearQuery( new SpanQuery[]{q1,q2,q3}, slop, ordered);
-    checkHits(snq, expectedDocs);
+    SpanQuery query = spanNearOrderedQuery(slop, q1, q2, q3);
+    checkHits(query, expectedDocs);
   }
   
   public void orderedSlopTest3(int slop, int[] expectedDocs) throws IOException {
     orderedSlopTest3SQ(
-       makeSpanTermQuery("w1"),
-       makeSpanTermQuery("w2"),
-       makeSpanTermQuery("w3"),
+       spanTermQuery(field, "w1"),
+       spanTermQuery(field, "w2"),
+       spanTermQuery(field, "w3"),
        slop,
        expectedDocs);
   }
   
   public void orderedSlopTest3Equal(int slop, int[] expectedDocs) throws IOException {
     orderedSlopTest3SQ(
-       makeSpanTermQuery("w1"),
-       makeSpanTermQuery("w3"),
-       makeSpanTermQuery("w3"),
+       spanTermQuery(field, "w1"),
+       spanTermQuery(field, "w3"),
+       spanTermQuery(field, "w3"),
        slop,
        expectedDocs);
   }
   
   public void orderedSlopTest1Equal(int slop, int[] expectedDocs) throws IOException {
     orderedSlopTest3SQ(
-       makeSpanTermQuery("u2"),
-       makeSpanTermQuery("u2"),
-       makeSpanTermQuery("u1"),
+       spanTermQuery(field, "u2"),
+       spanTermQuery(field, "u2"),
+       spanTermQuery(field, "u1"),
        slop,
        expectedDocs);
   }
@@ -191,16 +188,9 @@ public class TestSpans extends LuceneTestCase {
   }
 
   public void testSpanNearOrderedOverlap() throws Exception {
-    boolean ordered = true;
-    int slop = 1;
-    SpanNearQuery snq = new SpanNearQuery(
-                              new SpanQuery[] {
-                                makeSpanTermQuery("t1"),
-                                makeSpanTermQuery("t2"),
-                                makeSpanTermQuery("t3") },
-                              slop,
-                              ordered);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
+    final SpanQuery query = spanNearOrderedQuery(field, 1, "t1", "t2", "t3");
+    
+    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
 
     assertEquals("first doc", 11, spans.nextDoc());
     assertEquals("first start", 0, spans.nextStartPosition());
@@ -209,140 +199,87 @@ public class TestSpans extends LuceneTestCase {
     assertEquals("second start", 2, spans.nextStartPosition());
     assertEquals("second end", 6, spans.endPosition());
 
-    tstEndSpans(spans);  
+    assertFinished(spans);  
   }
 
   public void testSpanNearUnOrdered() throws Exception {
     //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
-    SpanNearQuery senq;
-    senq = new SpanNearQuery(
-                              new SpanQuery[] {
-                                makeSpanTermQuery("u1"),
-                                makeSpanTermQuery("u2") },
-                              0,
-                              false);
+    SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
     Spans spans = MultiSpansWrapper.wrap(reader, senq);
-    tstNextSpans(spans, 4, 1, 3);
-    tstNextSpans(spans, 5, 2, 4);
-    tstNextSpans(spans, 8, 2, 4);
-    tstNextSpans(spans, 9, 0, 2);
-    tstNextSpans(spans, 10, 0, 2);
-    tstEndSpans(spans);
-
-    SpanNearQuery u1u2 = new SpanNearQuery(new SpanQuery[]{makeSpanTermQuery("u1"),
-                                makeSpanTermQuery("u2")}, 0, false);
-    senq = new SpanNearQuery(
-                              new SpanQuery[] {
-                                u1u2,
-                                makeSpanTermQuery("u2")
-                              },
-                              1,
-                              false);
+    assertNext(spans, 4, 1, 3);
+    assertNext(spans, 5, 2, 4);
+    assertNext(spans, 8, 2, 4);
+    assertNext(spans, 9, 0, 2);
+    assertNext(spans, 10, 0, 2);
+    assertFinished(spans);
+
+    senq = spanNearUnorderedQuery(1, senq, spanTermQuery(field, "u2")); 
     spans = MultiSpansWrapper.wrap(reader, senq);
-    tstNextSpans(spans, 4, 0, 3);
-    tstNextSpans(spans, 4, 1, 3); // unordered spans can be subsets
-    tstNextSpans(spans, 5, 0, 4);
-    tstNextSpans(spans, 5, 2, 4);
-    tstNextSpans(spans, 8, 0, 4);
-    tstNextSpans(spans, 8, 2, 4);
-    tstNextSpans(spans, 9, 0, 2);
-    tstNextSpans(spans, 9, 0, 4);
-    tstNextSpans(spans, 10, 0, 2);
-    tstEndSpans(spans);
+    assertNext(spans, 4, 0, 3);
+    assertNext(spans, 4, 1, 3); // unordered spans can be subsets
+    assertNext(spans, 5, 0, 4);
+    assertNext(spans, 5, 2, 4);
+    assertNext(spans, 8, 0, 4);
+    assertNext(spans, 8, 2, 4);
+    assertNext(spans, 9, 0, 2);
+    assertNext(spans, 9, 0, 4);
+    assertNext(spans, 10, 0, 2);
+    assertFinished(spans);
   }
 
-
-
   private Spans orSpans(String[] terms) throws Exception {
-    SpanQuery[] sqa = new SpanQuery[terms.length];
-    for (int i = 0; i < terms.length; i++) {
-      sqa[i] = makeSpanTermQuery(terms[i]);
-    }
-    return MultiSpansWrapper.wrap(searcher.getIndexReader(), new SpanOrQuery(sqa));
-  }
-
-  public static void tstNextSpans(Spans spans, int doc, int start, int end) throws IOException {
-    if (spans.docID() >= doc) {
-      assertEquals("docId", doc, spans.docID());
-    } else { // nextDoc needed before testing start/end
-      if (spans.docID() >= 0) {
-        assertEquals("nextStartPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
-        assertEquals("endPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.endPosition());
-      }
-      assertEquals("nextDoc", doc, spans.nextDoc());
-      if (doc != Spans.NO_MORE_DOCS) {
-        assertEquals("first startPosition", -1, spans.startPosition());
-        assertEquals("first endPosition", -1, spans.endPosition());
-      }
-    }
-    if (doc != Spans.NO_MORE_DOCS) {
-      assertEquals("nextStartPosition", start, spans.nextStartPosition());
-      assertEquals("startPosition", start, spans.startPosition());
-      assertEquals("endPosition", end, spans.endPosition());
-    }
-  }
-  
-  public static void tstEndSpans(Spans spans) throws Exception {
-    if (spans != null) { // null Spans is empty
-      tstNextSpans(spans, Spans.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
-    }
+    return MultiSpansWrapper.wrap(searcher.getIndexReader(), spanOrQuery(field, terms));
   }
 
   public void testSpanOrEmpty() throws Exception {
     Spans spans = orSpans(new String[0]);
-    tstEndSpans(spans);
-    
-    SpanOrQuery a = new SpanOrQuery();
-    SpanOrQuery b = new SpanOrQuery();
-    assertTrue("empty should equal", a.equals(b));
+    assertFinished(spans);
   }
 
   public void testSpanOrSingle() throws Exception {
     Spans spans = orSpans(new String[] {"w5"});
-    tstNextSpans(spans, 0, 4, 5);
-    tstEndSpans(spans);
+    assertNext(spans, 0, 4, 5);
+    assertFinished(spans);
   }
   
   public void testSpanOrDouble() throws Exception {
     Spans spans = orSpans(new String[] {"w5", "yy"});
-    tstNextSpans(spans, 0, 4, 5);
-    tstNextSpans(spans, 2, 3, 4);
-    tstNextSpans(spans, 3, 4, 5);
-    tstNextSpans(spans, 7, 3, 4);
-    tstEndSpans(spans);
+    assertNext(spans, 0, 4, 5);
+    assertNext(spans, 2, 3, 4);
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
   }
 
   public void testSpanOrDoubleAdvance() throws Exception {
     Spans spans = orSpans(new String[] {"w5", "yy"});
     assertEquals("initial advance", 3, spans.advance(3));
-    tstNextSpans(spans, 3, 4, 5);
-    tstNextSpans(spans, 7, 3, 4);
-    tstEndSpans(spans);
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
   }
 
   public void testSpanOrUnused() throws Exception {
     Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
-    tstNextSpans(spans, 0, 4, 5);
-    tstNextSpans(spans, 2, 3, 4);
-    tstNextSpans(spans, 3, 4, 5);
-    tstNextSpans(spans, 7, 3, 4);
-    tstEndSpans(spans);
+    assertNext(spans, 0, 4, 5);
+    assertNext(spans, 2, 3, 4);
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
   }
 
   public void testSpanOrTripleSameDoc() throws Exception {
     Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
-    tstNextSpans(spans, 11, 0, 1);
-    tstNextSpans(spans, 11, 1, 2);
-    tstNextSpans(spans, 11, 2, 3);
-    tstNextSpans(spans, 11, 3, 4);
-    tstNextSpans(spans, 11, 4, 5);
-    tstNextSpans(spans, 11, 5, 6);
-    tstEndSpans(spans);
+    assertNext(spans, 11, 0, 1);
+    assertNext(spans, 11, 1, 2);
+    assertNext(spans, 11, 2, 3);
+    assertNext(spans, 11, 3, 4);
+    assertNext(spans, 11, 4, 5);
+    assertNext(spans, 11, 5, 6);
+    assertFinished(spans);
   }
 
   public void testSpanScorerZeroSloppyFreq() throws Exception {
-    boolean ordered = true;
-    int slop = 1;
     IndexReaderContext topReaderContext = searcher.getTopReaderContext();
     List<LeafReaderContext> leaves = topReaderContext.leaves();
     int subIndex = ReaderUtil.subIndex(11, leaves);
@@ -360,13 +297,7 @@ public class TestSpans extends LuceneTestCase {
       Scorer spanScorer;
       try {
         searcher.setSimilarity(sim);
-        SpanNearQuery snq = new SpanNearQuery(
-                                new SpanQuery[] {
-                                  makeSpanTermQuery("t1"),
-                                  makeSpanTermQuery("t2") },
-                                slop,
-                                ordered);
-  
+        SpanQuery snq = spanNearOrderedQuery(field, 1, "t1", "t2");
         spanScorer = searcher.createNormalizedWeight(snq, true).scorer(ctx, ctx.reader().getLiveDocs());
       } finally {
         searcher.setSimilarity(oldSim);
@@ -397,12 +328,16 @@ public class TestSpans extends LuceneTestCase {
 
   // LUCENE-1404
   private SpanQuery createSpan(String value) {
-    return new SpanTermQuery(new Term("text", value));
+    return spanTermQuery("text", value);
   }                     
   
   // LUCENE-1404
   private SpanQuery createSpan(int slop, boolean ordered, SpanQuery[] clauses) {
-    return new SpanNearQuery(clauses, slop, ordered);
+    if (ordered) {
+      return spanNearOrderedQuery(slop, clauses);
+    } else {
+      return spanNearUnorderedQuery(slop, clauses);
+    }
   }
 
   // LUCENE-1404
@@ -476,9 +411,9 @@ public class TestSpans extends LuceneTestCase {
   }
   
   private int spanCount(String include, String exclude, int pre, int post) throws IOException{
-     SpanTermQuery iq = new SpanTermQuery(new Term(field, include));
-     SpanTermQuery eq = new SpanTermQuery(new Term(field, exclude));
-     SpanNotQuery snq = new SpanNotQuery(iq, eq, pre, post);
+     SpanQuery iq = spanTermQuery(field, include);
+     SpanQuery eq = spanTermQuery(field, exclude);
+     SpanQuery snq = spanNotQuery(iq, eq, pre, post);
      Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
 
      int i = 0;
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
index 1f632ed..adb3edc 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
@@ -18,27 +18,23 @@ package org.apache.lucene.search.spans;
  */
 
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
 
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-import org.junit.Test;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
 
 /**
  * Tests Spans (v2)
@@ -49,50 +45,11 @@ public class TestSpansEnum extends LuceneTestCase {
   private static IndexReader reader;
   private static Directory directory;
 
-  static final class SimplePayloadFilter extends TokenFilter {
-    int pos;
-    final PayloadAttribute payloadAttr;
-    final CharTermAttribute termAttr;
-
-    public SimplePayloadFilter(TokenStream input) {
-      super(input);
-      pos = 0;
-      payloadAttr = input.addAttribute(PayloadAttribute.class);
-      termAttr = input.addAttribute(CharTermAttribute.class);
-    }
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (input.incrementToken()) {
-        payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
-        pos++;
-        return true;
-      } else {
-        return false;
-      }
-    }
-
-    @Override
-    public void reset() throws IOException {
-      super.reset();
-      pos = 0;
-    }
-  }
-
-  static Analyzer simplePayloadAnalyzer;
   @BeforeClass
   public static void beforeClass() throws Exception {
-    simplePayloadAnalyzer = new Analyzer() {
-        @Override
-        public TokenStreamComponents createComponents(String fieldName) {
-          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
-          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
-        }
-    };
-
     directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(simplePayloadAnalyzer)
+        newIndexWriterConfig(new MockAnalyzer(random()))
             .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
     //writer.infoStream = System.out;
     for (int i = 0; i < 10; i++) {
@@ -117,71 +74,48 @@ public class TestSpansEnum extends LuceneTestCase {
     searcher = null;
     reader = null;
     directory = null;
-    simplePayloadAnalyzer = null;
   }
 
   private void checkHits(Query query, int[] results) throws IOException {
     CheckHits.checkHits(random(), query, "field", searcher, results);
   }
 
-  SpanTermQuery spanTQ(String term) {
-    return new SpanTermQuery(new Term("field", term));
-  }
-
-  @Test
   public void testSpansEnumOr1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t2 = spanTQ("two");
-    SpanOrQuery soq = new SpanOrQuery(t1, t2);
-    checkHits(soq, new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+    checkHits(spanOrQuery("field", "one", "two"), 
+              new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
   }
 
-  @Test
   public void testSpansEnumOr2() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t11 = spanTQ("eleven");
-    SpanOrQuery soq = new SpanOrQuery(t1, t11);
-    checkHits(soq, new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+    checkHits(spanOrQuery("field", "one", "eleven"), 
+              new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
   }
 
-  @Test
   public void testSpansEnumOr3() throws Exception {
-    SpanTermQuery t12 = spanTQ("twelve");
-    SpanTermQuery t11 = spanTQ("eleven");
-    SpanOrQuery soq = new SpanOrQuery(t12, t11);
-    checkHits(soq, new int[] {});
+    checkHits(spanOrQuery("field", "twelve", "eleven"), 
+              new int[] {});
+  }
+  
+  public SpanQuery spanTQ(String s) {
+    return spanTermQuery("field", s);
   }
 
-  @Test
   public void testSpansEnumOrNot1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t2 = spanTQ("two");
-    SpanOrQuery soq = new SpanOrQuery(t1, t2);
-    SpanNotQuery snq = new SpanNotQuery(soq, t1);
-    checkHits(snq, new int[] {2,12});
+    checkHits(spanNotQuery(spanOrQuery("field", "one", "two"), spanTermQuery("field", "one")),
+              new int[] {2,12});
   }
 
-  @Test
   public void testSpansEnumNotBeforeAfter1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
-    SpanNotQuery snq = new SpanNotQuery(t100, t1, 0, 0);
-    checkHits(snq, new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one")), 
+              new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
   }
 
-  @Test
   public void testSpansEnumNotBeforeAfter2() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
-    SpanNotQuery snq = new SpanNotQuery(t100, t1, 1, 0);
-    checkHits(snq, new int[] {}); // exclude all "one hundred ..."
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 1, 0),
+              new int[] {}); // exclude all "one hundred ..."
   }
 
-  @Test
   public void testSpansEnumNotBeforeAfter3() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
-    SpanNotQuery snq = new SpanNotQuery(t100, t1, 0, 1);
-    checkHits(snq, new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 0, 1),
+              new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
   }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/analysis/SimplePayloadFilter.java b/lucene/test-framework/src/java/org/apache/lucene/analysis/SimplePayloadFilter.java
new file mode 100644
index 0000000..9bf1b3c
--- /dev/null
+++ b/lucene/test-framework/src/java/org/apache/lucene/analysis/SimplePayloadFilter.java
@@ -0,0 +1,56 @@
+package org.apache.lucene.analysis;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.util.BytesRef;
+
+/** Simple payload filter that sets the payload as pos: XXXX */
+public final class SimplePayloadFilter extends TokenFilter {
+  int pos;
+  final PayloadAttribute payloadAttr;
+  final CharTermAttribute termAttr;
+
+  public SimplePayloadFilter(TokenStream input) {
+    super(input);
+    pos = 0;
+    payloadAttr = input.addAttribute(PayloadAttribute.class);
+    termAttr = input.addAttribute(CharTermAttribute.class);
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
+      pos++;
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public void reset() throws IOException {
+    super.reset();
+    pos = 0;
+  }
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
index ee6c390..d6e364b 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
@@ -25,18 +25,15 @@ import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
 /**
  * Tests primitive queries (ie: that rewrite to themselves) to
  * insure they match the expected set of docs, and that the score of each
@@ -140,58 +137,66 @@ public abstract class BaseExplanationTestCase extends LuceneTestCase {
   }
 
   /** MACRO for SpanTermQuery */
-  public SpanTermQuery st(String s) {
-    return new SpanTermQuery(new Term(FIELD,s));
+  public SpanQuery st(String s) {
+    return spanTermQuery(FIELD, s);
   }
   
   /** MACRO for SpanNotQuery */
-  public SpanNotQuery snot(SpanQuery i, SpanQuery e) {
-    return new SpanNotQuery(i,e);
+  public SpanQuery snot(SpanQuery i, SpanQuery e) {
+    return spanNotQuery(i, e);
   }
 
   /** MACRO for SpanOrQuery containing two SpanTerm queries */
-  public SpanOrQuery sor(String s, String e) {
-    return sor(st(s), st(e));
+  public SpanQuery sor(String s, String e) {
+    return spanOrQuery(FIELD, s, e);
   }
+  
   /** MACRO for SpanOrQuery containing two SpanQueries */
-  public SpanOrQuery sor(SpanQuery s, SpanQuery e) {
-    return new SpanOrQuery(s, e);
+  public SpanQuery sor(SpanQuery s, SpanQuery e) {
+    return spanOrQuery(s, e);
   }
   
   /** MACRO for SpanOrQuery containing three SpanTerm queries */
-  public SpanOrQuery sor(String s, String m, String e) {
-    return sor(st(s), st(m), st(e));
+  public SpanQuery sor(String s, String m, String e) {
+    return spanOrQuery(FIELD, s, m, e);
   }
   /** MACRO for SpanOrQuery containing two SpanQueries */
-  public SpanOrQuery sor(SpanQuery s, SpanQuery m, SpanQuery e) {
-    return new SpanOrQuery(s, m, e);
+  public SpanQuery sor(SpanQuery s, SpanQuery m, SpanQuery e) {
+    return spanOrQuery(s, m, e);
   }
   
   /** MACRO for SpanNearQuery containing two SpanTerm queries */
-  public SpanNearQuery snear(String s, String e, int slop, boolean inOrder) {
+  public SpanQuery snear(String s, String e, int slop, boolean inOrder) {
     return snear(st(s), st(e), slop, inOrder);
   }
+  
   /** MACRO for SpanNearQuery containing two SpanQueries */
-  public SpanNearQuery snear(SpanQuery s, SpanQuery e,
-                             int slop, boolean inOrder) {
-    return new SpanNearQuery(new SpanQuery[] { s, e }, slop, inOrder);
+  public SpanQuery snear(SpanQuery s, SpanQuery e, int slop, boolean inOrder) {
+    if (inOrder) {
+      return spanNearOrderedQuery(slop, s, e);
+    } else {
+      return spanNearUnorderedQuery(slop, s, e);
+    }
   }
   
   
   /** MACRO for SpanNearQuery containing three SpanTerm queries */
-  public SpanNearQuery snear(String s, String m, String e,
+  public SpanQuery snear(String s, String m, String e,
                              int slop, boolean inOrder) {
     return snear(st(s), st(m), st(e), slop, inOrder);
   }
   /** MACRO for SpanNearQuery containing three SpanQueries */
-  public SpanNearQuery snear(SpanQuery s, SpanQuery m, SpanQuery e,
-                             int slop, boolean inOrder) {
-    return new SpanNearQuery(new SpanQuery[] { s, m, e }, slop, inOrder);
+  public SpanQuery snear(SpanQuery s, SpanQuery m, SpanQuery e, int slop, boolean inOrder) {
+    if (inOrder) {
+      return spanNearOrderedQuery(slop, s, m, e);
+    } else {
+      return spanNearUnorderedQuery(slop, s, m, e);
+    }
   }
   
   /** MACRO for SpanFirst(SpanTermQuery) */
-  public SpanFirstQuery sf(String s, int b) {
-    return new SpanFirstQuery(st(s), b);
+  public SpanQuery sf(String s, int b) {
+    return spanFirstQuery(st(s), b);
   }
 
   /**
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
new file mode 100644
index 0000000..bdc65f2
--- /dev/null
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
@@ -0,0 +1,161 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.QueryUtils;
+
+import static org.junit.Assert.*;
+
+/** Some utility methods used for testing span queries */
+public class SpanTestUtil {
+  
+  /** 
+   * Adds additional asserts to a spanquery. Highly recommended 
+   * if you want tests to actually be debuggable.
+   */
+  public static SpanQuery spanQuery(SpanQuery query) {
+    QueryUtils.check(query);
+    return new AssertingSpanQuery(query);
+  }
+  
+  /**
+   * Makes a new SpanTermQuery (with additional asserts).
+   */
+  public static SpanQuery spanTermQuery(String field, String term) {
+    return spanQuery(new SpanTermQuery(new Term(field, term)));
+  }
+  
+  /**
+   * Makes a new SpanOrQuery (with additional asserts) from the provided {@code terms}.
+   */
+  public static SpanQuery spanOrQuery(String field, String... terms) {
+    SpanQuery[] subqueries = new SpanQuery[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      subqueries[i] = spanTermQuery(field, terms[i]);
+    }
+    return spanOrQuery(subqueries);
+  }
+  
+  /**
+   * Makes a new SpanOrQuery (with additional asserts).
+   */
+  public static SpanQuery spanOrQuery(SpanQuery... subqueries) {
+    return spanQuery(new SpanOrQuery(subqueries));
+  }
+  
+  /**
+   * Makes a new SpanNotQuery (with additional asserts).
+   */
+  public static SpanQuery spanNotQuery(SpanQuery include, SpanQuery exclude) {
+    return spanQuery(new SpanNotQuery(include, exclude));
+  }
+  
+  /**
+   * Makes a new SpanNotQuery (with additional asserts).
+   */
+  public static SpanQuery spanNotQuery(SpanQuery include, SpanQuery exclude, int pre, int post) {
+    return spanQuery(new SpanNotQuery(include, exclude, pre, post));
+  }
+  
+  /**
+   * Makes a new SpanFirstQuery (with additional asserts).
+   */
+  public static SpanQuery spanFirstQuery(SpanQuery query, int end) {
+    return spanQuery(new SpanFirstQuery(query, end));
+  }
+  
+  /**
+   * Makes a new SpanPositionRangeQuery (with additional asserts).
+   */
+  public static SpanQuery spanPositionRangeQuery(SpanQuery query, int start, int end) {
+    return spanQuery(new SpanPositionRangeQuery(query, start, end));
+  }
+  
+  /**
+   * Makes a new ordered SpanNearQuery (with additional asserts) from the provided {@code terms}
+   */
+  public static SpanQuery spanNearOrderedQuery(String field, int slop, String... terms) {
+    SpanQuery[] subqueries = new SpanQuery[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      subqueries[i] = spanTermQuery(field, terms[i]);
+    }
+    return spanNearOrderedQuery(slop, subqueries);
+  }
+  
+  /**
+   * Makes a new ordered SpanNearQuery (with additional asserts)
+   */
+  public static SpanQuery spanNearOrderedQuery(int slop, SpanQuery... subqueries) {
+    return spanQuery(new SpanNearQuery(subqueries, slop, true));
+  }
+  
+  /**
+   * Makes a new unordered SpanNearQuery (with additional asserts) from the provided {@code terms}
+   */
+  public static SpanQuery spanNearUnorderedQuery(String field, int slop, String... terms) {
+    SpanQuery[] subqueries = new SpanQuery[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      subqueries[i] = spanTermQuery(field, terms[i]);
+    }
+    return spanNearUnorderedQuery(slop, subqueries);
+  }
+  
+  /**
+   * Makes a new unordered SpanNearQuery (with additional asserts)
+   */
+  public static SpanQuery spanNearUnorderedQuery(int slop, SpanQuery... subqueries) {
+    return spanQuery(new SpanNearQuery(subqueries, slop, false));
+  }
+  
+  /** 
+   * Assert the next iteration from {@code spans} is a match
+   * from {@code start} to {@code end} in {@code doc}.
+   */
+  public static void assertNext(Spans spans, int doc, int start, int end) throws IOException {
+    if (spans.docID() >= doc) {
+      assertEquals("docId", doc, spans.docID());
+    } else { // nextDoc needed before testing start/end
+      if (spans.docID() >= 0) {
+        assertEquals("nextStartPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
+        assertEquals("endPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.endPosition());
+      }
+      assertEquals("nextDoc", doc, spans.nextDoc());
+      if (doc != Spans.NO_MORE_DOCS) {
+        assertEquals("first startPosition", -1, spans.startPosition());
+        assertEquals("first endPosition", -1, spans.endPosition());
+      }
+    }
+    if (doc != Spans.NO_MORE_DOCS) {
+      assertEquals("nextStartPosition", start, spans.nextStartPosition());
+      assertEquals("startPosition", start, spans.startPosition());
+      assertEquals("endPosition", end, spans.endPosition());
+    }
+  }
+  
+  /** 
+   * Assert that {@code spans} is exhausted.
+   */
+  public static void assertFinished(Spans spans) throws Exception {
+    if (spans != null) { // null Spans is empty
+      assertNext(spans, Spans.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
+    }
+  }
+}

