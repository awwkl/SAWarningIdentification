GitDiffStart: fed4bba63d724da192988fc7717a25da6832ff8b | Sat Jul 4 20:14:12 2009 +0000
diff --git a/BUILD.txt b/BUILD.txt
index 3b471f6..4feaeaa 100644
--- a/BUILD.txt
+++ b/BUILD.txt
@@ -67,7 +67,8 @@ Step 3) Install JavaCC
 
 Building the Lucene distribution from the source does not require the JavaCC
 parser generator, but if you wish to regenerate any of the pre-generated
-parser pieces, you will need to install JavaCC.
+parser pieces, you will need to install JavaCC. Version 4.1 is tested to
+work correctly.
 
   http://javacc.dev.java.net
 
diff --git a/CHANGES.txt b/CHANGES.txt
index 96bba64..5ff60ec 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -281,6 +281,12 @@ API Changes
     includes more detailed status than previously.  (Tim Smith via
     Mike McCandless)
 
+28. LUCENE-1713: Deprecated RangeQuery and RangeFilter and renamed
+    to TermRangeQuery and TermRangeFilter. TermRangeQuery is in
+    constant score rewrite mode by default. The new classes also have
+    new ctors taking field and term ranges as Strings (see also
+    LUCENE-1424).  (Uwe Schindler)
+
 Bug fixes
 
 1. LUCENE-1415: MultiPhraseQuery has incorrect hashCode() and equals()
@@ -374,7 +380,7 @@ New features
     packaged as War file (Mark Harwood)    
 
  6. LUCENE-1424: Moved constant score query rewrite capability into
-    MultiTermQuery, allowing RangeQuery, PrefixQuery and WildcardQuery
+    MultiTermQuery, allowing TermRangeQuery, PrefixQuery and WildcardQuery
     to switch betwen constant-score rewriting or BooleanQuery
     expansion rewriting via a new setConstantScoreRewrite method.
     Deprecated ConstantScoreRangeQuery (Mark Miller via Mike
diff --git a/common-build.xml b/common-build.xml
index 1d27e3b..37c0e25 100644
--- a/common-build.xml
+++ b/common-build.xml
@@ -42,7 +42,7 @@
   <property name="Name" value="Lucene"/>
   <property name="dev.version" value="2.9-dev"/>
   <property name="version" value="${dev.version}"/>
-  <property name="compatibility.tag" value="lucene_2_4_back_compat_tests_20090623a"/>
+  <property name="compatibility.tag" value="lucene_2_4_back_compat_tests_20090704"/>
   <property name="spec.version" value="${version}"/>	
   <property name="year" value="2000-${current.year}"/>
   <property name="final.name" value="lucene-${name}-${version}"/>
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java b/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
index b0044a8..29cff6a 100644
--- a/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
+++ b/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
@@ -29,9 +29,9 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.ConstantScoreRangeQuery;
 import org.apache.lucene.search.Searcher;
 import org.apache.lucene.search.Sort;
@@ -102,7 +102,7 @@ public class CollationTestBase extends TestCase {
     result = is.search(aqp.parse("[ \u0633 TO \u0638 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
-    // Test RangeQuery
+    // Test TermRangeQuery
     aqp.setUseOldRangeQuery(true);
     result = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
@@ -132,15 +132,15 @@ public class CollationTestBase extends TestCase {
 
     // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
     // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeFilter with a Farsi
+    // index Term below should NOT be returned by a TermRangeFilter with a Farsi
     // Collator (or an Arabic one for the case when Farsi searcher not
     // supported).
     ScoreDoc[] result = searcher.search
-      (query, new RangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
+      (query, new TermRangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
 
     result = searcher.search
-      (query, new RangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
+      (query, new TermRangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
     searcher.close();
@@ -156,7 +156,7 @@ public class CollationTestBase extends TestCase {
 
     // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
     // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeQuery with a Farsi
+    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
     // Collator (or an Arabic one for the case when Farsi is not supported).
     doc.add(new Field("content", "\u0633\u0627\u0628", 
                       Field.Store.YES, Field.Index.ANALYZED));
@@ -164,13 +164,11 @@ public class CollationTestBase extends TestCase {
     writer.close();
     IndexSearcher searcher = new IndexSearcher(ramDir);
 
-    Query query = new RangeQuery(new Term("content", firstBeg),
-                                 new Term("content", firstEnd), true);
+    Query query = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, hits.length);
 
-    query = new RangeQuery(new Term("content", secondBeg),
-                           new Term("content", secondEnd), true);
+    query = new TermRangeQuery("content", secondBeg, secondEnd, true, true);
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, hits.length);
     searcher.close();
diff --git a/contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java b/contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
index 29da378..a5f595c 100644
--- a/contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
+++ b/contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
@@ -29,7 +29,7 @@ import org.apache.lucene.search.Query;
 
 /**
  * Utility class used to extract the terms used in a query, plus any weights.
- * This class will not find terms for MultiTermQuery, RangeQuery and PrefixQuery classes
+ * This class will not find terms for MultiTermQuery, TermRangeQuery and PrefixQuery classes
  * so the caller must pass a rewritten query (see Query.rewrite) to obtain a list of 
  * expanded terms. 
  * 
diff --git a/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java b/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
index 8bad29a..d439b16 100644
--- a/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
+++ b/contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
@@ -45,7 +45,7 @@ import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
@@ -145,8 +145,8 @@ public class WeightedSpanTermExtractor {
         query = mtq;
       }
       String field;
-      if(mtq instanceof RangeQuery) {
-        field = ((RangeQuery)mtq).getField();
+      if(mtq instanceof TermRangeQuery) {
+        field = ((TermRangeQuery)mtq).getField();
       } else {
         field = mtq.getTerm().field();
       }
@@ -472,10 +472,10 @@ public class WeightedSpanTermExtractor {
   }
   
   private MultiTermQuery copyMultiTermQuery(MultiTermQuery query) {
-    if(query instanceof RangeQuery) {
-      RangeQuery q = (RangeQuery)query;
+    if(query instanceof TermRangeQuery) {
+      TermRangeQuery q = (TermRangeQuery)query;
       q.setBoost(query.getBoost());
-      return new RangeQuery(q.getField(), q.getLowerTermText(), q.getUpperTermText(), q.includesLower(), q.includesUpper());
+      return new TermRangeQuery(q.getField(), q.getLowerTerm(), q.getUpperTerm(), q.includesLower(), q.includesUpper());
     } else if(query instanceof WildcardQuery) {
       MultiTermQuery q = new WildcardQuery(query.getTerm());
       q.setBoost(query.getBoost());
diff --git a/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index cf8c5bb..b3fe47e 100644
--- a/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -59,7 +59,7 @@ import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.MultiSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.search.Searcher;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
@@ -484,7 +484,7 @@ public class HighlighterTest extends TestCase implements Formatter {
         numHighlights = 0;
         String queryString = FIELD_NAME + ":[kannedy TO kznnedy]";
 
-        // Need to explicitly set the QueryParser property to use RangeQuery
+        // Need to explicitly set the QueryParser property to use TermRangeQuery
         // rather
         // than RangeFilters
         QueryParser parser = new QueryParser(FIELD_NAME, new StandardAnalyzer());
@@ -701,7 +701,7 @@ public class HighlighterTest extends TestCase implements Formatter {
 
       public void run() throws Exception {
         numHighlights = 0;
-        RangeFilter rf = new RangeFilter("contents", "john", "john", true, true);
+        TermRangeFilter rf = new TermRangeFilter("contents", "john", "john", true, true);
         SpanQuery clauses[] = { new SpanTermQuery(new Term("contents", "john")),
             new SpanTermQuery(new Term("contents", "kennedy")), };
         SpanNearQuery snq = new SpanNearQuery(clauses, 1, true);
@@ -723,7 +723,7 @@ public class HighlighterTest extends TestCase implements Formatter {
 
       public void run() throws Exception {
         numHighlights = 0;
-        RangeFilter rf = new RangeFilter("contents", "john", "john", true, true);
+        TermRangeFilter rf = new TermRangeFilter("contents", "john", "john", true, true);
         PhraseQuery pq = new PhraseQuery();
         pq.add(new Term("contents", "john"));
         pq.add(new Term("contents", "kennedy"));
diff --git a/contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java b/contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java
index 9067e5d..4b6906c 100644
--- a/contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java
+++ b/contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java
@@ -40,7 +40,7 @@ public class ChainedFilterTest extends TestCase {
   private IndexSearcher searcher;
   private Query query;
   // private DateFilter dateFilter;   DateFilter was deprecated and removed
-  private RangeFilter dateFilter;
+  private TermRangeFilter dateFilter;
   private QueryWrapperFilter bobFilter;
   private QueryWrapperFilter sueFilter;
 
@@ -76,7 +76,7 @@ public class ChainedFilterTest extends TestCase {
     //Date pastTheEnd = parseDate("2099 Jan 1");
     // dateFilter = DateFilter.Before("date", pastTheEnd);
     // just treat dates as strings and select the whole range for now...
-    dateFilter = new RangeFilter("date","","ZZZZ",true,true);
+    dateFilter = new TermRangeFilter("date","","ZZZZ",true,true);
 
     bobFilter = new QueryWrapperFilter(
         new TermQuery(new Term("owner", "bob")));
diff --git a/contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java b/contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java
index fbb1dcd..f601284 100644
--- a/contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java
+++ b/contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java
@@ -30,7 +30,7 @@ import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanFilter;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.FilterClause;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.DocIdBitSet;
 
@@ -84,7 +84,7 @@ public class BooleanFilterTest extends TestCase
 	
   private Filter getRangeFilter(String field,String lowerPrice, String upperPrice, boolean old)
 	{
-    Filter f = new RangeFilter(field,lowerPrice,upperPrice,true,true);
+    Filter f = new TermRangeFilter(field,lowerPrice,upperPrice,true,true);
     if (old) {
       return getOldBitSetFilter(f);
     }
diff --git a/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java b/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java
index 389af5d..7c1b7b2 100644
--- a/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java
+++ b/contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java
@@ -4,7 +4,7 @@
 package org.apache.lucene.xmlparser.builders;
 
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.xmlparser.DOMUtils;
 import org.apache.lucene.xmlparser.FilterBuilder;
 import org.apache.lucene.xmlparser.ParserException;
@@ -39,7 +39,7 @@ public class RangeFilterBuilder implements FilterBuilder {
 		String upperTerm=e.getAttribute("upperTerm");
 		boolean includeLower=DOMUtils.getAttribute(e,"includeLower",true);
 		boolean includeUpper=DOMUtils.getAttribute(e,"includeUpper",true);
-		return new RangeFilter(fieldName,lowerTerm,upperTerm,includeLower,includeUpper);
+		return new TermRangeFilter(fieldName,lowerTerm,upperTerm,includeLower,includeUpper);
 	}
 
 }
diff --git a/src/java/org/apache/lucene/document/DateField.java b/src/java/org/apache/lucene/document/DateField.java
index 7128a1c..3ccd53e 100644
--- a/src/java/org/apache/lucene/document/DateField.java
+++ b/src/java/org/apache/lucene/document/DateField.java
@@ -18,7 +18,7 @@ package org.apache.lucene.document;
  */
 
 import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.NumericRangeQuery; // for javadocs
 import org.apache.lucene.util.NumericUtils; // for javadocs
 
@@ -33,7 +33,7 @@ import java.util.Calendar;   // for javadoc
  * which makes them suitable for use as field values and search terms.
  *
  * <P>Note that this class saves dates with millisecond granularity,
- * which is bad for {@link RangeQuery} and {@link PrefixQuery}, as those
+ * which is bad for {@link TermRangeQuery} and {@link PrefixQuery}, as those
  * queries are expanded to a BooleanQuery with a potentially large number
  * of terms when searching. Thus you might want to use
  * {@link DateTools} instead.
diff --git a/src/java/org/apache/lucene/queryParser/CharStream.java b/src/java/org/apache/lucene/queryParser/CharStream.java
index 9e546d5..4423996 100644
--- a/src/java/org/apache/lucene/queryParser/CharStream.java
+++ b/src/java/org/apache/lucene/queryParser/CharStream.java
@@ -109,4 +109,4 @@ public interface CharStream {
   void Done();
 
 }
-/* JavaCC - OriginalChecksum=a83909a2403f969f94d18375f9f143e4 (do not edit this line) */
+/* JavaCC - OriginalChecksum=32a89423891f765dde472f7ef0e3ef7b (do not edit this line) */
diff --git a/src/java/org/apache/lucene/queryParser/ParseException.java b/src/java/org/apache/lucene/queryParser/ParseException.java
index fdb4784..b48a446 100644
--- a/src/java/org/apache/lucene/queryParser/ParseException.java
+++ b/src/java/org/apache/lucene/queryParser/ParseException.java
@@ -195,4 +195,4 @@ public class ParseException extends Exception {
    }
 
 }
-/* JavaCC - OriginalChecksum=c63b396885c4ff44d7aa48d3feae60cd (do not edit this line) */
+/* JavaCC - OriginalChecksum=c7631a240f7446940695eac31d9483ca (do not edit this line) */
diff --git a/src/java/org/apache/lucene/queryParser/QueryParser.java b/src/java/org/apache/lucene/queryParser/QueryParser.java
index b6c9632..c04048f 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParser.java
+++ b/src/java/org/apache/lucene/queryParser/QueryParser.java
@@ -31,7 +31,7 @@ import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
@@ -174,7 +174,6 @@ public class QueryParser implements QueryParserConstants {
     }
     catch (ParseException tme) {
       // rethrow to include the original query:
-      // rethrow to include the original query:
       ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
       e.initCause(tme);
       throw e;
@@ -877,22 +876,15 @@ public class QueryParser implements QueryParserConstants {
   }
 
   /**
-   * Builds a new RangeQuery instance
+   * Builds a new TermRangeQuery instance
    * @param field Field
    * @param part1 min
    * @param part2 max
    * @param inclusive true if range is inclusive
-   * @return new RangeQuery instance
+   * @return new TermRangeQuery instance
    */
   protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
-    RangeQuery query;
-
-    if (constantScoreRewrite) {
-      // TODO: remove in Lucene 3.0
-      query = new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    } else {
-      query = new RangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    }
+    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
     query.setConstantScoreRewrite(constantScoreRewrite);
     return query;
   }
diff --git a/src/java/org/apache/lucene/queryParser/QueryParser.jj b/src/java/org/apache/lucene/queryParser/QueryParser.jj
index fe655a6..74b5872 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParser.jj
+++ b/src/java/org/apache/lucene/queryParser/QueryParser.jj
@@ -55,7 +55,7 @@ import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
@@ -198,13 +198,19 @@ public class QueryParser {
     }
     catch (ParseException tme) {
       // rethrow to include the original query:
-      throw new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      e.initCause(tme);
+      throw e;
     }
     catch (TokenMgrError tme) {
-      throw new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      e.initCause(tme);
+      throw e;
     }
     catch (BooleanQuery.TooManyClauses tmc) {
-      throw new ParseException("Cannot parse '" +query+ "': too many boolean clauses");
+      ParseException e = new ParseException("Cannot parse '" +query+ "': too many boolean clauses");
+      e.initCause(tmc);
+      throw e;
     }
   }
 
@@ -894,22 +900,15 @@ public class QueryParser {
   }
 
   /**
-   * Builds a new RangeQuery instance
+   * Builds a new TermRangeQuery instance
    * @param field Field
    * @param part1 min
    * @param part2 max
    * @param inclusive true if range is inclusive
-   * @return new RangeQuery instance
+   * @return new TermRangeQuery instance
    */
   protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
-    RangeQuery query;  
-  
-    if (constantScoreRewrite) {
-      // TODO: remove in Lucene 3.0
-      query = new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    } else {
-      query = new RangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    }
+    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
     query.setConstantScoreRewrite(constantScoreRewrite);
     return query;
   }
diff --git a/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java b/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
index 5b20f44..f3992bc 100644
--- a/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
+++ b/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
@@ -29,7 +29,7 @@ import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
diff --git a/src/java/org/apache/lucene/queryParser/Token.java b/src/java/org/apache/lucene/queryParser/Token.java
index 9767798..2c665d6 100644
--- a/src/java/org/apache/lucene/queryParser/Token.java
+++ b/src/java/org/apache/lucene/queryParser/Token.java
@@ -121,4 +121,4 @@ public class Token {
   }
 
 }
-/* JavaCC - OriginalChecksum=37b1923f964a5a434f5ea3d6952ff200 (do not edit this line) */
+/* JavaCC - OriginalChecksum=c147cc166a7cf8812c7c39bc8c5eb868 (do not edit this line) */
diff --git a/src/java/org/apache/lucene/queryParser/TokenMgrError.java b/src/java/org/apache/lucene/queryParser/TokenMgrError.java
index 2208bc2..3dff0ae 100644
--- a/src/java/org/apache/lucene/queryParser/TokenMgrError.java
+++ b/src/java/org/apache/lucene/queryParser/TokenMgrError.java
@@ -137,4 +137,4 @@ public class TokenMgrError extends Error
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=55cddb2336a66b376c0bb59d916b326d (do not edit this line) */
+/* JavaCC - OriginalChecksum=186d5bcc64733844c7daab5ad5a6e349 (do not edit this line) */
diff --git a/src/java/org/apache/lucene/search/BooleanQuery.java b/src/java/org/apache/lucene/search/BooleanQuery.java
index 6f6673c..4484602 100644
--- a/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -34,7 +34,7 @@ public class BooleanQuery extends Query {
 
   /** Thrown when an attempt is made to add more than {@link
    * #getMaxClauseCount()} clauses. This typically happens if
-   * a PrefixQuery, FuzzyQuery, WildcardQuery, or RangeQuery 
+   * a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery 
    * is expanded to many terms during search. 
    */
   public static class TooManyClauses extends RuntimeException {
@@ -58,8 +58,8 @@ public class BooleanQuery extends Query {
    * so this parameter indirectly controls the maximum buffer requirements for
    * query search.
    * <p>When this parameter becomes a bottleneck for a Query one can use a
-   * Filter. For example instead of a {@link RangeQuery} one can use a
-   * {@link RangeFilter}.
+   * Filter. For example instead of a {@link TermRangeQuery} one can use a
+   * {@link TermRangeFilter}.
    * <p>Normally the buffers are allocated by the JVM. When using for example
    * {@link org.apache.lucene.store.MMapDirectory} the buffering is left to
    * the operating system.
diff --git a/src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java b/src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java
index 146178a..a558f2c 100644
--- a/src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java
+++ b/src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java
@@ -29,31 +29,32 @@ import java.text.Collator;
  * Either or both endpoints may be open.  Open endpoints may not be exclusive
  * (you can't select all but the first or last term without explicitly specifying the term to exclude.)
  *
- * @deprecated Please use {@link RangeQuery}, and call
- * {@link RangeQuery#setConstantScoreRewrite}, instead.
+ * @deprecated Use {@link TermRangeQuery} for term ranges or
+ * {@link NumericRangeQuery} for numeric ranges instead.
+ * This class will be removed in Lucene 3.0.
  * @version $Id$
  */
-public class ConstantScoreRangeQuery extends RangeQuery
+public class ConstantScoreRangeQuery extends TermRangeQuery
 {
 
   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper)
   {
     super(fieldName, lowerVal, upperVal, includeLower, includeUpper);
-    this.constantScoreRewrite = true;
+    setConstantScoreRewrite(true);
   }
 
   public ConstantScoreRangeQuery(String fieldName, String lowerVal,
                                  String upperVal, boolean includeLower,
                                  boolean includeUpper, Collator collator) {
     super(fieldName, lowerVal, upperVal, includeLower, includeUpper, collator);
-    this.constantScoreRewrite = true;
+    setConstantScoreRewrite(true);
   }
 
   public String getLowerVal() {
-    return getLowerTermText();
+    return getLowerTerm();
   }
 
   public String getUpperVal() {
-    return getUpperTermText();
+    return getUpperTerm();
   }
 }
diff --git a/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java b/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
index 6efac81..9d80af5 100644
--- a/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
+++ b/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
@@ -31,9 +31,9 @@ import org.apache.lucene.document.NumericField; // for javadocs
  * even if the range itself changes. 
  * 
  * <p>This means that FieldCacheRangeFilter is much faster (sometimes more than 100x as fast) 
- * as building a {@link RangeFilter} (or {@link ConstantScoreRangeQuery} on a {@link RangeFilter})
+ * as building a {@link TermRangeFilter} (or {@link ConstantScoreRangeQuery} on a {@link TermRangeFilter})
  * for each query, if using a {@link #newStringRange}. However, if the range never changes it
- * is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single RangeFilter.
+ * is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single TermRangeFilter.
  *
  * For numeric data types, this filter may be significantly faster than {@link NumericRangeFilter}.
  * Furthermore, it does not need the numeric values encoded by {@link NumericField}. But
diff --git a/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java b/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
index 2e016a9..35b432c 100644
--- a/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
+++ b/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
@@ -34,7 +34,7 @@ import java.util.BitSet;
  * be used by itself. Normally you subclass it to provide a Filter
  * counterpart for a {@link MultiTermQuery} subclass.
  * <P>
- * For example, {@link RangeFilter} and {@link PrefixFilter} extend
+ * For example, {@link TermRangeFilter} and {@link PrefixFilter} extend
  * <code>MultiTermQueryWrapperFilter</code>.
  * This class also provides the functionality behind
  * {@link MultiTermQuery#getFilter}, this is why it is not abstract.
diff --git a/src/java/org/apache/lucene/search/Query.java b/src/java/org/apache/lucene/search/Query.java
index 6e08fde..a76af31 100644
--- a/src/java/org/apache/lucene/search/Query.java
+++ b/src/java/org/apache/lucene/search/Query.java
@@ -36,7 +36,8 @@ import org.apache.lucene.index.IndexReader;
     <li> {@link PrefixQuery}
     <li> {@link MultiPhraseQuery}
     <li> {@link FuzzyQuery}
-    <li> {@link RangeQuery}
+    <li> {@link TermRangeQuery}
+    <li> {@link NumericRangeQuery}
     <li> {@link org.apache.lucene.search.spans.SpanQuery}
     </ul>
     <p>A parser for queries is contained in:
@@ -146,7 +147,7 @@ public abstract class Query implements java.io.Serializable, Cloneable {
    * correspondence with queries). This is an optimization of the OR of
    * all queries. We handle the common optimization cases of equal
    * queries and overlapping clauses of boolean OR queries (as generated
-   * by MultiTermQuery.rewrite() and RangeQuery.rewrite()).
+   * by MultiTermQuery.rewrite()).
    * Be careful overriding this method as queries[0] determines which
    * method will be called and is not necessarily of the same type as
    * the other queries.
diff --git a/src/java/org/apache/lucene/search/QueryWrapperFilter.java b/src/java/org/apache/lucene/search/QueryWrapperFilter.java
index d697482..c855a7f 100644
--- a/src/java/org/apache/lucene/search/QueryWrapperFilter.java
+++ b/src/java/org/apache/lucene/search/QueryWrapperFilter.java
@@ -26,10 +26,10 @@ import org.apache.lucene.index.IndexReader;
  * Constrains search results to only match those which also match a provided
  * query.  
  *
- * <p> This could be used, for example, with a {@link RangeQuery} on a suitably
+ * <p> This could be used, for example, with a {@link TermRangeQuery} on a suitably
  * formatted date field to implement date filtering.  One could re-use a single
  * QueryFilter that matches, e.g., only documents modified within the last
- * week.  The QueryFilter and RangeQuery would only need to be reconstructed
+ * week.  The QueryFilter and TermRangeQuery would only need to be reconstructed
  * once per day.
  *
  * @version $Id:$
diff --git a/src/java/org/apache/lucene/search/RangeFilter.java b/src/java/org/apache/lucene/search/RangeFilter.java
deleted file mode 100644
index 97b6846..0000000
--- a/src/java/org/apache/lucene/search/RangeFilter.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.Collator;
-
-/**
- * A Filter that restricts search results to a range of values in a given
- * field.
- *
- * <p>This filter matches the documents looking for terms that fall into the
- * supplied range according to {@link String#compareTo(String)}. It is not intended
- * for numerical ranges, use {@link NumericRangeFilter} instead.
- *
- * <p>If you construct a large number of range filters with different ranges but on the 
- * same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
- */
-public class RangeFilter extends MultiTermQueryWrapperFilter {
-    
-  /**
-     * @param fieldName The field this range applies to
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper));
-    }
-
-    /**
-     * <strong>WARNING:</strong> Using this constructor and supplying a non-null
-     * value in the <code>collator</code> parameter will cause every single 
-     * index Term in the Field referenced by lowerTerm and/or upperTerm to be
-     * examined.  Depending on the number of index Terms in this Field, the 
-     * operation could be very slow.
-     *
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @param collator The collator to use when determining range inclusion; set
-     *  to null to use Unicode code point ordering instead of collation.
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper,
-                       Collator collator) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper, collator));
-    }
-
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * less than or equal to <code>upperTerm</code>.
-     */
-    public static RangeFilter Less(String fieldName, String upperTerm) {
-        return new RangeFilter(fieldName, null, upperTerm, false, true);
-    }
-
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * greater than or equal to <code>lowerTerm</code>.
-     */
-    public static RangeFilter More(String fieldName, String lowerTerm) {
-        return new RangeFilter(fieldName, lowerTerm, null, true, false);
-    }
-}
diff --git a/src/java/org/apache/lucene/search/RangeQuery.java b/src/java/org/apache/lucene/search/RangeQuery.java
deleted file mode 100644
index 5db2959..0000000
--- a/src/java/org/apache/lucene/search/RangeQuery.java
+++ /dev/null
@@ -1,244 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-
-/**
- * A Query that matches documents within an exclusive range.
- *
- * <p>This query matches the documents looking for terms that fall into the
- * supplied range according to {@link String#compareTo(String)}. It is not intended
- * for numerical ranges, use {@link NumericRangeQuery} instead.
- *
- * <p>See {@link MultiTermQuery#setConstantScoreRewrite} for the tradeoffs between
- * enabling and disabling constantScoreRewrite mode.
- */
-
-public class RangeQuery extends MultiTermQuery {
-  private Term lowerTerm;
-  private Term upperTerm;
-  private Collator collator;
-  private String field;
-  private boolean includeLower;
-  private boolean includeUpper;
-
-
-  /**
-   * Constructs a query selecting all terms greater/equal than <code>lowerTerm</code>
-   * but less/equal than <code>upperTerm</code>. 
-   * 
-   * <p>
-   * If an endpoint is null, it is said 
-   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
-   * be exclusive (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * 
-   * @param field The field that holds both lower and upper terms.
-   * @param lowerTerm
-   *          The term text at the lower end of the range
-   * @param upperTerm
-   *          The term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is
-   *          included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is
-   *          included in the range.
-   */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
-    init(new Term(field, lowerTerm), new Term(field, upperTerm), includeLower, includeUpper, null);
-  }
-
-  /** Constructs a query selecting all terms greater/equal than
-   * <code>lowerTerm</code> but less/equal than <code>upperTerm</code>.
-   * <p>
-   * If an endpoint is null, it is said 
-   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
-   * be exclusive (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * <p>
-   * If <code>collator</code> is not null, it will be used to decide whether
-   * index terms are within the given range, rather than using the Unicode code
-   * point order in which index terms are stored.
-   * <p>
-   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
-   * value in the <code>collator</code> parameter will cause every single 
-   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
-   * examined.  Depending on the number of index Terms in this Field, the 
-   * operation could be very slow.
-   *
-   * @param lowerTerm The Term text at the lower end of the range
-   * @param upperTerm The Term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is
-   *          included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is
-   *          included in the range.
-   * @param collator The collator to use to collate index Terms, to determine
-   *  their membership in the range bounded by <code>lowerTerm</code> and
-   *  <code>upperTerm</code>.
-   */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper,
-                    Collator collator) {
-    init(new Term(field, lowerTerm), new Term(field,upperTerm), includeLower, includeUpper, collator);
-  }
-
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean, Collator)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive,
-                    Collator collator) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, collator);
-  }
-  
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, null);
-  }
-
-  private void init(Term lowerTerm, Term upperTerm, boolean includeLower, boolean includeUpper, Collator collator) {
-    if (lowerTerm == null && upperTerm == null)
-      throw new IllegalArgumentException("At least one term must be non-null");
-    if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
-      throw new IllegalArgumentException("Both terms must be for the same field");
-
-    if (lowerTerm == null)
-      this.field = upperTerm.field();
-    else
-      this.field = lowerTerm.field();
-    this.lowerTerm = lowerTerm;
-    this.upperTerm = upperTerm;
-    this.includeLower = includeLower;
-    this.includeUpper = includeUpper;
-    this.collator = collator;
-  }
-  
-  /** Returns the field name for this query */
-  public String getField() {
-    return field;
-  }
-
-  /** Returns the lower term of this range query.
-   *  @deprecated Use {@link #getLowerTermText} instead. */
-  public Term getLowerTerm() { return lowerTerm; }
-
-  /** Returns the upper term of this range query.
-   *  @deprecated Use {@link #getUpperTermText} instead. */
-  public Term getUpperTerm() { return upperTerm; }
-  
-  /** Returns the lower value of this range query */
-  public String getLowerTermText() { return lowerTerm == null ? null : lowerTerm.text(); }
-
-  /** Returns the upper value of this range query */
-  public String getUpperTermText() { return upperTerm == null ? null : upperTerm.text(); }
-  
-  /** Returns <code>true</code> if the lower endpoint is inclusive */
-  public boolean includesLower() { return includeLower; }
-  
-  /** Returns <code>true</code> if the upper endpoint is inclusive */
-  public boolean includesUpper() { return includeUpper; }
-
-  /** Returns <code>true</code> if the range query is inclusive 
-   *  @deprecated Use {@link #includesLower}, {@link #includesUpper}  instead. 
-   */
-  public boolean isInclusive() { return includeUpper && includeLower; }
-
-  /** Returns the collator used to determine range inclusion, if any. */
-  public Collator getCollator() { return collator; }
-  
-  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
-    //TODO: when the deprecated 'Term' constructors are removed we can remove these null checks
-    return new RangeTermEnum(reader, collator, getField(), lowerTerm == null ? null : lowerTerm.text(),
-        upperTerm == null ? null : upperTerm.text(), includeLower, includeUpper);
-  }
-
-  /** Prints a user-readable version of this query. */
-  public String toString(String field) {
-      StringBuffer buffer = new StringBuffer();
-      if (!getField().equals(field)) {
-          buffer.append(getField());
-          buffer.append(":");
-      }
-      buffer.append(includeLower ? '[' : '{');
-      buffer.append(lowerTerm != null ? lowerTerm.text() : "*");
-      buffer.append(" TO ");
-      buffer.append(upperTerm != null ? upperTerm.text() : "*");
-      buffer.append(includeUpper ? ']' : '}');
-      if (getBoost() != 1.0f) {
-          buffer.append("^");
-          buffer.append(Float.toString(getBoost()));
-      }
-      return buffer.toString();
-  }
-
-  //@Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    result = prime * result + ((collator == null) ? 0 : collator.hashCode());
-    result = prime * result + ((field == null) ? 0 : field.hashCode());
-    result = prime * result + (includeLower ? 1231 : 1237);
-    result = prime * result + (includeUpper ? 1231 : 1237);
-    result = prime * result + ((lowerTerm == null) ? 0 : lowerTerm.hashCode());
-    result = prime * result + ((upperTerm == null) ? 0 : upperTerm.hashCode());
-    return result;
-  }
-
-  //@Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (!super.equals(obj))
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    RangeQuery other = (RangeQuery) obj;
-    if (collator == null) {
-      if (other.collator != null)
-        return false;
-    } else if (!collator.equals(other.collator))
-      return false;
-    if (field == null) {
-      if (other.field != null)
-        return false;
-    } else if (!field.equals(other.field))
-      return false;
-    if (includeLower != other.includeLower)
-      return false;
-    if (includeUpper != other.includeUpper)
-      return false;
-    if (lowerTerm == null) {
-      if (other.lowerTerm != null)
-        return false;
-    } else if (!lowerTerm.equals(other.lowerTerm))
-      return false;
-    if (upperTerm == null) {
-      if (other.upperTerm != null)
-        return false;
-    } else if (!upperTerm.equals(other.upperTerm))
-      return false;
-    return true;
-  }
-
-}
diff --git a/src/java/org/apache/lucene/search/RangeTermEnum.java b/src/java/org/apache/lucene/search/RangeTermEnum.java
deleted file mode 100644
index 4358127..0000000
--- a/src/java/org/apache/lucene/search/RangeTermEnum.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-
-/**
- * Subclass of FilteredTermEnum for enumerating all terms that match the
- * specified range parameters.
- * <p>
- * Term enumerations are always ordered by Term.compareTo().  Each term in
- * the enumeration is greater than all that precede it.
- */
-public class RangeTermEnum extends FilteredTermEnum {
-
-  private Collator collator = null;
-  private boolean endEnum = false;
-  private String field;
-  private String upperTermText;
-  private String lowerTermText;
-  private boolean includeLower;
-  private boolean includeUpper;
-
-  /**
-   * Enumerates all terms greater/equal than <code>lowerTerm</code>
-   * but less/equal than <code>upperTerm</code>. 
-   * 
-   * If an endpoint is null, it is said to be "open". Either or both 
-   * endpoints may be open.  Open endpoints may not be exclusive 
-   * (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * 
-   * @param reader
-   * @param collator
-   *          The collator to use to collate index Terms, to determine their
-   *          membership in the range bounded by <code>lowerTerm</code> and
-   *          <code>upperTerm</code>.
-   * @param field
-   *          An interned field that holds both lower and upper terms.
-   * @param lowerTermText
-   *          The term text at the lower end of the range
-   * @param upperTermText
-   *          The term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is included in the range.
-   * 
-   * @throws IOException
-   */
-  public RangeTermEnum(IndexReader reader, Collator collator, String field,
-      String lowerTermText, String upperTermText, boolean includeLower, boolean includeUpper) throws IOException {
-    this.collator = collator;
-    this.upperTermText = upperTermText;
-    this.lowerTermText = lowerTermText;
-    this.includeLower = includeLower;
-    this.includeUpper = includeUpper;
-    this.field = field;
-    
-    // do a little bit of normalization...
-    // open ended range queries should always be inclusive.
-    if (this.lowerTermText == null) {
-      this.lowerTermText = "";
-      this.includeLower = true;
-    }
-    
-    if (this.upperTermText == null) {
-      this.includeUpper = true;
-    }
-
-    String startTermText = collator == null ? this.lowerTermText : "";
-    setEnum(reader.terms(new Term(this.field, startTermText)));
-  }
-
-  public float difference() {
-    return 1.0f;
-  }
-
-  protected boolean endEnum() {
-    return endEnum;
-  }
-
-  protected boolean termCompare(Term term) {
-    if (collator == null) {
-      // Use Unicode code point ordering
-      boolean checkLower = false;
-      if (!includeLower) // make adjustments to set to exclusive
-        checkLower = true;
-      if (term != null && term.field() == field) { // interned comparison
-        if (!checkLower || null==lowerTermText || term.text().compareTo(lowerTermText) > 0) {
-          checkLower = false;
-          if (upperTermText != null) {
-            int compare = upperTermText.compareTo(term.text());
-            /*
-             * if beyond the upper term, or is exclusive and this is equal to
-             * the upper term, break out
-             */
-            if ((compare < 0) ||
-                (!includeUpper && compare==0)) {
-              endEnum = true;
-              return false;
-            }
-          }
-          return true;
-        }
-      } else {
-        // break
-        endEnum = true;
-        return false;
-      }
-      return false;
-    } else {
-      if (term != null && term.field() == field) { // interned comparison
-        if ((lowerTermText == null
-            || (includeLower
-                ? collator.compare(term.text(), lowerTermText) >= 0
-                : collator.compare(term.text(), lowerTermText) > 0))
-           && (upperTermText == null
-               || (includeUpper
-                   ? collator.compare(term.text(), upperTermText) <= 0
-                   : collator.compare(term.text(), upperTermText) < 0))) {
-          return true;
-        }
-        return false;
-      }
-      endEnum = true;
-      return false;
-    }
-  }
-}
diff --git a/src/java/org/apache/lucene/search/TermRangeFilter.java b/src/java/org/apache/lucene/search/TermRangeFilter.java
new file mode 100644
index 0000000..e557193
--- /dev/null
+++ b/src/java/org/apache/lucene/search/TermRangeFilter.java
@@ -0,0 +1,88 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.Collator;
+
+/**
+ * A Filter that restricts search results to a range of values in a given
+ * field.
+ *
+ * <p>This filter matches the documents looking for terms that fall into the
+ * supplied range according to {@link String#compareTo(String)}. It is not intended
+ * for numerical ranges, use {@link NumericRangeFilter} instead.
+ *
+ * <p>If you construct a large number of range filters with different ranges but on the 
+ * same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
+ */
+public class TermRangeFilter extends MultiTermQueryWrapperFilter {
+    
+  /**
+   * @param fieldName The field this range applies to
+   * @param lowerTerm The lower bound on this range
+   * @param upperTerm The upper bound on this range
+   * @param includeLower Does this range include the lower bound?
+   * @param includeUpper Does this range include the upper bound?
+   * @throws IllegalArgumentException if both terms are null or if
+   *  lowerTerm is null and includeLower is true (similar for upperTerm
+   *  and includeUpper)
+   */
+  public TermRangeFilter(String fieldName, String lowerTerm, String upperTerm,
+                     boolean includeLower, boolean includeUpper) {
+      super(new TermRangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper));
+  }
+
+  /**
+   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
+   * value in the <code>collator</code> parameter will cause every single 
+   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
+   * examined.  Depending on the number of index Terms in this Field, the 
+   * operation could be very slow.
+   *
+   * @param lowerTerm The lower bound on this range
+   * @param upperTerm The upper bound on this range
+   * @param includeLower Does this range include the lower bound?
+   * @param includeUpper Does this range include the upper bound?
+   * @param collator The collator to use when determining range inclusion; set
+   *  to null to use Unicode code point ordering instead of collation.
+   * @throws IllegalArgumentException if both terms are null or if
+   *  lowerTerm is null and includeLower is true (similar for upperTerm
+   *  and includeUpper)
+   */
+  public TermRangeFilter(String fieldName, String lowerTerm, String upperTerm,
+                     boolean includeLower, boolean includeUpper,
+                     Collator collator) {
+      super(new TermRangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper, collator));
+  }
+
+  /**
+   * Constructs a filter for field <code>fieldName</code> matching
+   * less than or equal to <code>upperTerm</code>.
+   */
+  public static TermRangeFilter Less(String fieldName, String upperTerm) {
+      return new TermRangeFilter(fieldName, null, upperTerm, false, true);
+  }
+
+  /**
+   * Constructs a filter for field <code>fieldName</code> matching
+   * greater than or equal to <code>lowerTerm</code>.
+   */
+  public static TermRangeFilter More(String fieldName, String lowerTerm) {
+      return new TermRangeFilter(fieldName, lowerTerm, null, true, false);
+  }
+}
diff --git a/src/java/org/apache/lucene/search/TermRangeQuery.java b/src/java/org/apache/lucene/search/TermRangeQuery.java
new file mode 100644
index 0000000..4ebae13
--- /dev/null
+++ b/src/java/org/apache/lucene/search/TermRangeQuery.java
@@ -0,0 +1,205 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.text.Collator;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.util.ToStringUtils;
+
+/**
+ * A Query that matches documents within an exclusive range of terms.
+ *
+ * <p>This query matches the documents looking for terms that fall into the
+ * supplied range according to {@link String#compareTo(String)}. It is not intended
+ * for numerical ranges, use {@link NumericRangeQuery} instead.
+ *
+ * <p>This query is in constant score mode per default.
+ * See {@link MultiTermQuery#setConstantScoreRewrite} for the tradeoffs between
+ * enabling and disabling constantScoreRewrite mode.
+ */
+
+public class TermRangeQuery extends MultiTermQuery {
+  private String lowerTerm;
+  private String upperTerm;
+  private Collator collator;
+  private String field;
+  private boolean includeLower;
+  private boolean includeUpper;
+
+
+  /**
+   * Constructs a query selecting all terms greater/equal than <code>lowerTerm</code>
+   * but less/equal than <code>upperTerm</code>. 
+   * 
+   * <p>
+   * If an endpoint is null, it is said 
+   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
+   * be exclusive (you can't select all but the first or last term without 
+   * explicitly specifying the term to exclude.)
+   * 
+   * @param field The field that holds both lower and upper terms.
+   * @param lowerTerm
+   *          The term text at the lower end of the range
+   * @param upperTerm
+   *          The term text at the upper end of the range
+   * @param includeLower
+   *          If true, the <code>lowerTerm</code> is
+   *          included in the range.
+   * @param includeUpper
+   *          If true, the <code>upperTerm</code> is
+   *          included in the range.
+   */
+  public TermRangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
+    this(field, lowerTerm, upperTerm, includeLower, includeUpper, null);
+  }
+
+  /** Constructs a query selecting all terms greater/equal than
+   * <code>lowerTerm</code> but less/equal than <code>upperTerm</code>.
+   * <p>
+   * If an endpoint is null, it is said 
+   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
+   * be exclusive (you can't select all but the first or last term without 
+   * explicitly specifying the term to exclude.)
+   * <p>
+   * If <code>collator</code> is not null, it will be used to decide whether
+   * index terms are within the given range, rather than using the Unicode code
+   * point order in which index terms are stored.
+   * <p>
+   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
+   * value in the <code>collator</code> parameter will cause every single 
+   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
+   * examined.  Depending on the number of index Terms in this Field, the 
+   * operation could be very slow.
+   *
+   * @param lowerTerm The Term text at the lower end of the range
+   * @param upperTerm The Term text at the upper end of the range
+   * @param includeLower
+   *          If true, the <code>lowerTerm</code> is
+   *          included in the range.
+   * @param includeUpper
+   *          If true, the <code>upperTerm</code> is
+   *          included in the range.
+   * @param collator The collator to use to collate index Terms, to determine
+   *  their membership in the range bounded by <code>lowerTerm</code> and
+   *  <code>upperTerm</code>.
+   */
+  public TermRangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper,
+                    Collator collator) {
+    this.field = field;
+    this.lowerTerm = lowerTerm;
+    this.upperTerm = upperTerm;
+    this.includeLower = includeLower;
+    this.includeUpper = includeUpper;
+    this.collator = collator;
+    setConstantScoreRewrite(true);
+  }
+
+  /** Returns the field name for this query */
+  public String getField() {
+    return field;
+  }
+  
+  /** Returns the lower value of this range query */
+  public String getLowerTerm() { return lowerTerm; }
+
+  /** Returns the upper value of this range query */
+  public String getUpperTerm() { return upperTerm; }
+  
+  /** Returns <code>true</code> if the lower endpoint is inclusive */
+  public boolean includesLower() { return includeLower; }
+  
+  /** Returns <code>true</code> if the upper endpoint is inclusive */
+  public boolean includesUpper() { return includeUpper; }
+
+  /** Returns the collator used to determine range inclusion, if any. */
+  public Collator getCollator() { return collator; }
+  
+  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
+    return new TermRangeTermEnum(reader, collator, field, lowerTerm,
+        upperTerm, includeLower, includeUpper);
+  }
+
+  /** Prints a user-readable version of this query. */
+  public String toString(String field) {
+      StringBuffer buffer = new StringBuffer();
+      if (!getField().equals(field)) {
+          buffer.append(getField());
+          buffer.append(":");
+      }
+      buffer.append(includeLower ? '[' : '{');
+      buffer.append(lowerTerm != null ? lowerTerm : "*");
+      buffer.append(" TO ");
+      buffer.append(upperTerm != null ? upperTerm : "*");
+      buffer.append(includeUpper ? ']' : '}');
+      buffer.append(ToStringUtils.boost(getBoost()));
+      return buffer.toString();
+  }
+
+  //@Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + ((collator == null) ? 0 : collator.hashCode());
+    result = prime * result + ((field == null) ? 0 : field.hashCode());
+    result = prime * result + (includeLower ? 1231 : 1237);
+    result = prime * result + (includeUpper ? 1231 : 1237);
+    result = prime * result + ((lowerTerm == null) ? 0 : lowerTerm.hashCode());
+    result = prime * result + ((upperTerm == null) ? 0 : upperTerm.hashCode());
+    return result;
+  }
+
+  //@Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (!super.equals(obj))
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    TermRangeQuery other = (TermRangeQuery) obj;
+    if (collator == null) {
+      if (other.collator != null)
+        return false;
+    } else if (!collator.equals(other.collator))
+      return false;
+    if (field == null) {
+      if (other.field != null)
+        return false;
+    } else if (!field.equals(other.field))
+      return false;
+    if (includeLower != other.includeLower)
+      return false;
+    if (includeUpper != other.includeUpper)
+      return false;
+    if (lowerTerm == null) {
+      if (other.lowerTerm != null)
+        return false;
+    } else if (!lowerTerm.equals(other.lowerTerm))
+      return false;
+    if (upperTerm == null) {
+      if (other.upperTerm != null)
+        return false;
+    } else if (!upperTerm.equals(other.upperTerm))
+      return false;
+    return true;
+  }
+
+}
diff --git a/src/java/org/apache/lucene/search/TermRangeTermEnum.java b/src/java/org/apache/lucene/search/TermRangeTermEnum.java
new file mode 100644
index 0000000..ebb13c3
--- /dev/null
+++ b/src/java/org/apache/lucene/search/TermRangeTermEnum.java
@@ -0,0 +1,149 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.text.Collator;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+
+/**
+ * Subclass of FilteredTermEnum for enumerating all terms that match the
+ * specified range parameters.
+ * <p>
+ * Term enumerations are always ordered by Term.compareTo().  Each term in
+ * the enumeration is greater than all that precede it.
+ */
+public class TermRangeTermEnum extends FilteredTermEnum {
+
+  private Collator collator = null;
+  private boolean endEnum = false;
+  private String field;
+  private String upperTermText;
+  private String lowerTermText;
+  private boolean includeLower;
+  private boolean includeUpper;
+
+  /**
+   * Enumerates all terms greater/equal than <code>lowerTerm</code>
+   * but less/equal than <code>upperTerm</code>. 
+   * 
+   * If an endpoint is null, it is said to be "open". Either or both 
+   * endpoints may be open.  Open endpoints may not be exclusive 
+   * (you can't select all but the first or last term without 
+   * explicitly specifying the term to exclude.)
+   * 
+   * @param reader
+   * @param collator
+   *          The collator to use to collate index Terms, to determine their
+   *          membership in the range bounded by <code>lowerTerm</code> and
+   *          <code>upperTerm</code>.
+   * @param field
+   *          An interned field that holds both lower and upper terms.
+   * @param lowerTermText
+   *          The term text at the lower end of the range
+   * @param upperTermText
+   *          The term text at the upper end of the range
+   * @param includeLower
+   *          If true, the <code>lowerTerm</code> is included in the range.
+   * @param includeUpper
+   *          If true, the <code>upperTerm</code> is included in the range.
+   * 
+   * @throws IOException
+   */
+  public TermRangeTermEnum(IndexReader reader, Collator collator, String field,
+      String lowerTermText, String upperTermText, boolean includeLower, boolean includeUpper) throws IOException {
+    this.collator = collator;
+    this.upperTermText = upperTermText;
+    this.lowerTermText = lowerTermText;
+    this.includeLower = includeLower;
+    this.includeUpper = includeUpper;
+    this.field = field.intern();
+    
+    // do a little bit of normalization...
+    // open ended range queries should always be inclusive.
+    if (this.lowerTermText == null) {
+      this.lowerTermText = "";
+      this.includeLower = true;
+    }
+    
+    if (this.upperTermText == null) {
+      this.includeUpper = true;
+    }
+
+    String startTermText = collator == null ? this.lowerTermText : "";
+    setEnum(reader.terms(new Term(this.field, startTermText)));
+  }
+
+  public float difference() {
+    return 1.0f;
+  }
+
+  protected boolean endEnum() {
+    return endEnum;
+  }
+
+  protected boolean termCompare(Term term) {
+    if (collator == null) {
+      // Use Unicode code point ordering
+      boolean checkLower = false;
+      if (!includeLower) // make adjustments to set to exclusive
+        checkLower = true;
+      if (term != null && term.field() == field) { // interned comparison
+        if (!checkLower || null==lowerTermText || term.text().compareTo(lowerTermText) > 0) {
+          checkLower = false;
+          if (upperTermText != null) {
+            int compare = upperTermText.compareTo(term.text());
+            /*
+             * if beyond the upper term, or is exclusive and this is equal to
+             * the upper term, break out
+             */
+            if ((compare < 0) ||
+                (!includeUpper && compare==0)) {
+              endEnum = true;
+              return false;
+            }
+          }
+          return true;
+        }
+      } else {
+        // break
+        endEnum = true;
+        return false;
+      }
+      return false;
+    } else {
+      if (term != null && term.field() == field) { // interned comparison
+        if ((lowerTermText == null
+            || (includeLower
+                ? collator.compare(term.text(), lowerTermText) >= 0
+                : collator.compare(term.text(), lowerTermText) > 0))
+           && (upperTermText == null
+               || (includeUpper
+                   ? collator.compare(term.text(), upperTermText) <= 0
+                   : collator.compare(term.text(), upperTermText) < 0))) {
+          return true;
+        }
+        return false;
+      }
+      endEnum = true;
+      return false;
+    }
+  }
+}
diff --git a/src/java/org/apache/lucene/search/package.html b/src/java/org/apache/lucene/search/package.html
index 2fdf926..f67fbc6 100644
--- a/src/java/org/apache/lucene/search/package.html
+++ b/src/java/org/apache/lucene/search/package.html
@@ -138,11 +138,11 @@ org.apache.lucene.search.Searcher#search(Query,Filter)}.
 </p>
 
 <h4>
-    <a href="RangeQuery.html">RangeQuery</a>
+    <a href="TermRangeQuery.html">TermRangeQuery</a>
 </h4>
 
 <p>The
-    <a href="RangeQuery.html">RangeQuery</a>
+    <a href="TermRangeQuery.html">TermRangeQuery</a>
     matches all documents that occur in the
     exclusive range of a lower
     <a href="../index/Term.html">Term</a>
diff --git a/src/test/org/apache/lucene/queryParser/TestQueryParser.java b/src/test/org/apache/lucene/queryParser/TestQueryParser.java
index f88e38f..86a246c 100644
--- a/src/test/org/apache/lucene/queryParser/TestQueryParser.java
+++ b/src/test/org/apache/lucene/queryParser/TestQueryParser.java
@@ -50,7 +50,7 @@ import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
@@ -431,11 +431,11 @@ public class TestQueryParser extends LuceneTestCase {
 
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertTrue(((RangeQuery)getQuery("[ a TO z]", null)).getConstantScoreRewrite());
+    assertTrue(((TermRangeQuery)getQuery("[ a TO z]", null)).getConstantScoreRewrite());
 
     QueryParser qp = new QueryParser("field", new SimpleAnalyzer());
 	  qp.setConstantScoreRewrite(false);
-    assertFalse(((RangeQuery)qp.parse("[ a TO z]")).getConstantScoreRewrite());
+    assertFalse(((TermRangeQuery)qp.parse("[ a TO z]")).getConstantScoreRewrite());
     
     assertQueryEquals("[ a TO z ]", null, "[a TO z]");
     assertQueryEquals("{ a TO z}", null, "{a TO z}");
@@ -481,7 +481,7 @@ public class TestQueryParser extends LuceneTestCase {
     result = is.search(qp.parse("[ \u0633 TO \u0638 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
-    // Test RangeQuery
+    // Test TermRangeQuery
     qp.setConstantScoreRewrite(false);
     result = is.search(qp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
diff --git a/src/test/org/apache/lucene/search/TestDateFilter.java b/src/test/org/apache/lucene/search/TestDateFilter.java
index 134f5d4..a5b21a5 100644
--- a/src/test/org/apache/lucene/search/TestDateFilter.java
+++ b/src/test/org/apache/lucene/search/TestDateFilter.java
@@ -66,11 +66,11 @@ public class TestDateFilter
 
 	// filter that should preserve matches
 	//DateFilter df1 = DateFilter.Before("datefield", now);
-    RangeFilter df1 = new RangeFilter("datefield", DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df1 = new TermRangeFilter("datefield", DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now, DateTools.Resolution.MILLISECOND), false, true);
 	// filter that should discard matches
 	//DateFilter df2 = DateFilter.Before("datefield", now - 999999);
-    RangeFilter df2 = new RangeFilter("datefield", DateTools.timeToString(0, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df2 = new TermRangeFilter("datefield", DateTools.timeToString(0, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND), true, false);
 
     // search something that doesn't exist with DateFilter
@@ -127,11 +127,11 @@ public class TestDateFilter
 
 	// filter that should preserve matches
 	//DateFilter df1 = DateFilter.After("datefield", now);
-    RangeFilter df1 = new RangeFilter("datefield", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df1 = new TermRangeFilter("datefield", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND), true, false);
 	// filter that should discard matches
 	//DateFilter df2 = DateFilter.After("datefield", now + 999999);
-    RangeFilter df2 = new RangeFilter("datefield", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df2 = new TermRangeFilter("datefield", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),
                                           DateTools.timeToString(now + 999999999, DateTools.Resolution.MILLISECOND), false, true);
 
     // search something that doesn't exist with DateFilter
diff --git a/src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java b/src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java
index afeca13..a084b41 100644
--- a/src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java
+++ b/src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java
@@ -30,7 +30,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.store.RAMDirectory;
 
 /**
- * A basic 'positive' Unit test class for the RangeFilter class.
+ * A basic 'positive' Unit test class for the FieldCacheRangeFilter class.
  *
  * <p>
  * NOTE: at the moment, this class only tests for 'positive' results,
diff --git a/src/test/org/apache/lucene/search/TestFilteredQuery.java b/src/test/org/apache/lucene/search/TestFilteredQuery.java
index 0e1dc72..e4d6200 100644
--- a/src/test/org/apache/lucene/search/TestFilteredQuery.java
+++ b/src/test/org/apache/lucene/search/TestFilteredQuery.java
@@ -177,8 +177,8 @@ extends LuceneTestCase {
    * This tests FilteredQuery's rewrite correctness
    */
   public void testRangeQuery() throws Exception {
-    RangeQuery rq = new RangeQuery(
-        new Term("sorter", "b"), new Term("sorter", "d"), true);
+    TermRangeQuery rq = new TermRangeQuery(
+        "sorter", "b", "d", true, true);
 
     Query filteredquery = new FilteredQuery(rq, filter);
     ScoreDoc[] hits = searcher.search(filteredquery, null, 1000).scoreDocs;
diff --git a/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java b/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
index 182b5b5..8bab8a8 100644
--- a/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
+++ b/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
@@ -87,7 +87,7 @@ public class TestMultiTermConstantScore extends BaseTestRangeFilter {
 
   /** macro for readability */
   public static Query csrq(String f, String l, String h, boolean il, boolean ih) {
-    RangeQuery query = new RangeQuery(f, l, h, il, ih);
+    TermRangeQuery query = new TermRangeQuery(f, l, h, il, ih);
     query.setConstantScoreRewrite(true);
     return query;
   }
@@ -95,7 +95,7 @@ public class TestMultiTermConstantScore extends BaseTestRangeFilter {
   /** macro for readability */
   public static Query csrq(String f, String l, String h, boolean il,
       boolean ih, Collator c) {
-    RangeQuery query = new RangeQuery(f, l, h, il, ih, c);
+    TermRangeQuery query = new TermRangeQuery(f, l, h, il, ih, c);
     query.setConstantScoreRewrite(true);
     return query;
   }
@@ -220,10 +220,10 @@ public class TestMultiTermConstantScore extends BaseTestRangeFilter {
     IndexReader reader = IndexReader.open(small);
     IndexSearcher search = new IndexSearcher(reader);
 
-    // first do a regular RangeQuery which uses term expansion so
+    // first do a regular TermRangeQuery which uses term expansion so
     // docs with more terms in range get higher scores
 
-    Query rq = new RangeQuery(new Term("data", "1"), new Term("data", "4"), T);
+    Query rq = new TermRangeQuery("data", "1", "4", T, T);
 
     ScoreDoc[] expected = search.search(rq, null, 1000).scoreDocs;
     int numHits = expected.length;
diff --git a/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java b/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
index 6c4c113..5c928dc 100644
--- a/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
+++ b/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
@@ -226,38 +226,38 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
       }
       // test inclusive range
       NumericRangeQuery tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
-      RangeQuery cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);
+      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);
       cq.setConstantScoreRewrite(true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, false);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, true);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, false);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
     }
diff --git a/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java b/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
index 1415b0c..bec0a35 100644
--- a/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
+++ b/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
@@ -226,38 +226,38 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
       }
       // test inclusive range
       NumericRangeQuery tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
-      RangeQuery cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, true);
+      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, true);
       cq.setConstantScoreRewrite(true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, false);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, false);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, true);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, true);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, true);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, false);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, false);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
     }
diff --git a/src/test/org/apache/lucene/search/TestRangeFilter.java b/src/test/org/apache/lucene/search/TestRangeFilter.java
deleted file mode 100644
index 18ce868..0000000
--- a/src/test/org/apache/lucene/search/TestRangeFilter.java
+++ /dev/null
@@ -1,421 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-import java.util.Locale;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * A basic 'positive' Unit test class for the RangeFilter class.
- *
- * <p>
- * NOTE: at the moment, this class only tests for 'positive' results,
- * it does not verify the results to ensure there are no 'false positives',
- * nor does it adequately test 'negative' results.  It also does not test
- * that garbage in results in an Exception.
- */
-public class TestRangeFilter extends BaseTestRangeFilter {
-
-    public TestRangeFilter(String name) {
-	super(name);
-    }
-    public TestRangeFilter() {
-        super();
-    }
-
-    public void testRangeFilterId() throws IOException {
-
-        IndexReader reader = IndexReader.open(signedIndex.index);
-	IndexSearcher search = new IndexSearcher(reader);
-
-        int medId = ((maxId - minId) / 2);
-        
-        String minIP = pad(minId);
-        String maxIP = pad(maxId);
-        String medIP = pad(medId);
-    
-        int numDocs = reader.numDocs();
-        
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-        
-  ScoreDoc[] result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test id, bounded on both ends
-        
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T), numDocs).scoreDocs;
-  assertEquals("find all", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F), numDocs).scoreDocs;
-  assertEquals("all but last", numDocs-1, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T), numDocs).scoreDocs;
-  assertEquals("all but first", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F), numDocs).scoreDocs;
-        assertEquals("all but ends", numDocs-2, result.length);
-    
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T), numDocs).scoreDocs;
-        assertEquals("med and up", 1+ maxId-medId, result.length);
-        
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T), numDocs).scoreDocs;
-        assertEquals("up to med", 1+ medId-minId, result.length);
-
-        // unbounded id
-
-  result = search.search(q,new RangeFilter("id",minIP,null,T,F), numDocs).scoreDocs;
-  assertEquals("min and up", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,T), numDocs).scoreDocs;
-  assertEquals("max and down", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,null,F,F), numDocs).scoreDocs;
-  assertEquals("not min, but up", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,F), numDocs).scoreDocs;
-  assertEquals("not max, but down", numDocs-1, result.length);
-        
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F), numDocs).scoreDocs;
-        assertEquals("med and up, not max", maxId-medId, result.length);
-        
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T), numDocs).scoreDocs;
-        assertEquals("not min, up to med", medId-minId, result.length);
-
-        // very small sets
-
-  result = search.search(q,new RangeFilter("id",minIP,minIP,F,F), numDocs).scoreDocs;
-  assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",medIP,medIP,F,F), numDocs).scoreDocs;
-  assertEquals("med,med,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F), numDocs).scoreDocs;
-  assertEquals("max,max,F,F", 0, result.length);
-                     
-  result = search.search(q,new RangeFilter("id",minIP,minIP,T,T), numDocs).scoreDocs;
-  assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",null,minIP,F,T), numDocs).scoreDocs;
-  assertEquals("nul,min,F,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T), numDocs).scoreDocs;
-  assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,null,T,F), numDocs).scoreDocs;
-  assertEquals("max,nul,T,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("id",medIP,medIP,T,T), numDocs).scoreDocs;
-  assertEquals("med,med,T,T", 1, result.length);
-        
-    }
-
-    public void testRangeFilterIdCollating() throws IOException {
-
-        IndexReader reader = IndexReader.open(signedIndex.index);
-        IndexSearcher search = new IndexSearcher(reader);
-
-        Collator c = Collator.getInstance(Locale.ENGLISH);
-
-        int medId = ((maxId - minId) / 2);
-
-        String minIP = pad(minId);
-        String maxIP = pad(maxId);
-        String medIP = pad(medId);
-
-        int numDocs = reader.numDocs();
-
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-
-        Hits result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test id, bounded on both ends
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T,c));
-        assertEquals("find all", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F,c));
-        assertEquals("all but last", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T,c));
-        assertEquals("all but first", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F,c));
-        assertEquals("all but ends", numDocs-2, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T,c));
-        assertEquals("med and up", 1+ maxId-medId, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T,c));
-        assertEquals("up to med", 1+ medId-minId, result.length());
-
-        // unbounded id
-
-        result = search.search(q,new RangeFilter("id",minIP,null,T,F,c));
-        assertEquals("min and up", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,T,c));
-        assertEquals("max and down", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,null,F,F,c));
-        assertEquals("not min, but up", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,F,c));
-        assertEquals("not max, but down", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F,c));
-        assertEquals("med and up, not max", maxId-medId, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T,c));
-        assertEquals("not min, up to med", medId-minId, result.length());
-
-        // very small sets
-
-        result = search.search(q,new RangeFilter("id",minIP,minIP,F,F,c));
-        assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",medIP,medIP,F,F,c));
-        assertEquals("med,med,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F,c));
-        assertEquals("max,max,F,F", 0, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,minIP,T,T,c));
-        assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",null,minIP,F,T,c));
-        assertEquals("nul,min,F,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T,c));
-        assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,null,T,F,c));
-        assertEquals("max,nul,T,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,medIP,T,T,c));
-        assertEquals("med,med,T,T", 1, result.length());
-    }
-
-    public void testRangeFilterRand() throws IOException {
-
-  IndexReader reader = IndexReader.open(signedIndex.index);
-	IndexSearcher search = new IndexSearcher(reader);
-
-        String minRP = pad(signedIndex.minR);
-        String maxRP = pad(signedIndex.maxR);
-    
-        int numDocs = reader.numDocs();
-        
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-        
-  ScoreDoc[] result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test extremes, bounded on both ends
-        
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T), numDocs).scoreDocs;
-  assertEquals("find all", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F), numDocs).scoreDocs;
-  assertEquals("all but biggest", numDocs-1, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T), numDocs).scoreDocs;
-  assertEquals("all but smallest", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F), numDocs).scoreDocs;
-        assertEquals("all but extremes", numDocs-2, result.length);
-    
-        // unbounded
-
-  result = search.search(q,new RangeFilter("rand",minRP,null,T,F), numDocs).scoreDocs;
-  assertEquals("smallest and up", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,T), numDocs).scoreDocs;
-  assertEquals("biggest and down", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,null,F,F), numDocs).scoreDocs;
-  assertEquals("not smallest, but up", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,F), numDocs).scoreDocs;
-  assertEquals("not biggest, but down", numDocs-1, result.length);
-        
-        // very small sets
-
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F), numDocs).scoreDocs;
-  assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F), numDocs).scoreDocs;
-  assertEquals("max,max,F,F", 0, result.length);
-                     
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T), numDocs).scoreDocs;
-  assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",null,minRP,F,T), numDocs).scoreDocs;
-  assertEquals("nul,min,F,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T), numDocs).scoreDocs;
-  assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,null,T,F), numDocs).scoreDocs;
-  assertEquals("max,nul,T,T", 1, result.length);
-        
-    }
-
-    public void testRangeFilterRandCollating() throws IOException {
-
-        // using the unsigned index because collation seems to ignore hyphens
-        IndexReader reader = IndexReader.open(unsignedIndex.index);
-        IndexSearcher search = new IndexSearcher(reader);
-
-        Collator c = Collator.getInstance(Locale.ENGLISH);
-
-        String minRP = pad(unsignedIndex.minR);
-        String maxRP = pad(unsignedIndex.maxR);
-
-        int numDocs = reader.numDocs();
-
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-
-        Hits result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test extremes, bounded on both ends
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T,c));
-        assertEquals("find all", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F,c));
-        assertEquals("all but biggest", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T,c));
-        assertEquals("all but smallest", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F,c));
-        assertEquals("all but extremes", numDocs-2, result.length());
-
-        // unbounded
-
-        result = search.search(q,new RangeFilter("rand",minRP,null,T,F,c));
-        assertEquals("smallest and up", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,T,c));
-        assertEquals("biggest and down", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,null,F,F,c));
-        assertEquals("not smallest, but up", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,F,c));
-        assertEquals("not biggest, but down", numDocs-1, result.length());
-
-        // very small sets
-
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F,c));
-        assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F,c));
-        assertEquals("max,max,F,F", 0, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T,c));
-        assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",null,minRP,F,T,c));
-        assertEquals("nul,min,F,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T,c));
-        assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,null,T,F,c));
-        assertEquals("max,nul,T,T", 1, result.length());
-    }
-    
-    public void testFarsi() throws Exception {
-            
-        /* build an index */
-        RAMDirectory farsiIndex = new RAMDirectory();
-        IndexWriter writer = new IndexWriter(farsiIndex, new SimpleAnalyzer(), T, 
-                                             IndexWriter.MaxFieldLength.LIMITED);
-        Document doc = new Document();
-        doc.add(new Field("content","\u0633\u0627\u0628", 
-                          Field.Store.YES, Field.Index.UN_TOKENIZED));
-        doc.add(new Field("body", "body",
-                          Field.Store.YES, Field.Index.UN_TOKENIZED));
-        writer.addDocument(doc);
-            
-        writer.optimize();
-        writer.close();
-
-        IndexReader reader = IndexReader.open(farsiIndex);
-        IndexSearcher search = new IndexSearcher(reader);
-        Query q = new TermQuery(new Term("body","body"));
-
-        // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-        // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-        // characters properly.
-        Collator collator = Collator.getInstance(new Locale("ar"));
-        
-        // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-        // orders the U+0698 character before the U+0633 character, so the single
-        // index Term below should NOT be returned by a RangeFilter with a Farsi
-        // Collator (or an Arabic one for the case when Farsi is not supported).
-        Hits result = search.search
-            (q, new RangeFilter("content", "\u062F", "\u0698", T, T, collator));
-        assertEquals("The index Term should not be included.", 0, result.length());
-
-        result = search.search
-            (q, new RangeFilter("content", "\u0633", "\u0638", T, T, collator));
-        assertEquals("The index Term should be included.", 1, result.length());
-        search.close();
-    }
-
-    public void testDanish() throws Exception {
-            
-        /* build an index */
-        RAMDirectory danishIndex = new RAMDirectory();
-        IndexWriter writer = new IndexWriter
-            (danishIndex, new SimpleAnalyzer(), T, 
-             IndexWriter.MaxFieldLength.LIMITED);
-        // Danish collation orders the words below in the given order
-        // (example taken from TestSort.testInternationalSort() ).
-        String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
-        for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
-            Document doc = new Document();
-            doc.add(new Field("content", words[docnum], 
-                              Field.Store.YES, Field.Index.UN_TOKENIZED));
-            doc.add(new Field("body", "body",
-                              Field.Store.YES, Field.Index.UN_TOKENIZED));
-            writer.addDocument(doc);
-        }
-        writer.optimize();
-        writer.close();
-
-        IndexReader reader = IndexReader.open(danishIndex);
-        IndexSearcher search = new IndexSearcher(reader);
-        Query q = new TermQuery(new Term("body","body"));
-
-        Collator collator = Collator.getInstance(new Locale("da", "dk"));
-        Query query = new RangeQuery
-            ("content", "H\u00D8T", "MAND", false, false, collator);
-
-        // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
-        // but Danish collation does.
-        Hits result = search.search
-            (q, new RangeFilter("content", "H\u00D8T", "MAND", F, F, collator));
-        assertEquals("The index Term should be included.", 1, result.length());
-
-        result = search.search
-            (q, new RangeFilter("content", "H\u00C5T", "MAND", F, F, collator));
-        assertEquals
-            ("The index Term should not be included.", 0, result.length());
-        search.close();
-    }
-}
diff --git a/src/test/org/apache/lucene/search/TestRangeQuery.java b/src/test/org/apache/lucene/search/TestRangeQuery.java
deleted file mode 100644
index 17766d5..0000000
--- a/src/test/org/apache/lucene/search/TestRangeQuery.java
+++ /dev/null
@@ -1,380 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
-
-import org.apache.lucene.util.LuceneTestCase;
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Locale;
-import java.text.Collator;
-
-
-public class TestRangeQuery extends LuceneTestCase {
-
-  private int docCount = 0;
-  private RAMDirectory dir;
-
-  public void setUp() throws Exception {
-    super.setUp();
-    dir = new RAMDirectory();
-  }
-
-  public void testExclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[] {"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added, still only B in range", 1, hits.length);
-    searcher.close();
-  }
-  
-  //TODO: remove in Lucene 3.0
-  public void testDeprecatedCstrctors() throws IOException {
-    Query query = new RangeQuery(null, new Term("content","C"), false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 2, hits.length);
-    searcher.close();
-    
-    query = new RangeQuery(new Term("content","C"),null, false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-  }
-
-  public void testInclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", true, true);
-
-    initializeIndex(new String[]{"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[]{"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D - A and B in range", 2, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added - A, B, C in range", 3, hits.length);
-    searcher.close();
-  }
-
-  public void testEqualsHashcode() {
-    Query query = new RangeQuery("content", "A", "C", true, true);
-    
-    query.setBoost(1.0f);
-    Query other = new RangeQuery("content", "A", "C", true, true);
-    other.setBoost(1.0f);
-
-    assertEquals("query equals itself is true", query, query);
-    assertEquals("equivalent queries are equal", query, other);
-    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
-
-    other.setBoost(2.0f);
-    assertFalse("Different boost queries are not equal", query.equals(other));
-
-    other = new RangeQuery("notcontent", "A", "C", true, true);
-    assertFalse("Different fields are not equal", query.equals(other));
-
-    other = new RangeQuery("content", "X", "C", true, true);
-    assertFalse("Different lower terms are not equal", query.equals(other));
-
-    other = new RangeQuery("content", "A", "Z", true, true);
-    assertFalse("Different upper terms are not equal", query.equals(other));
-
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", null, "C", true, true);
-    assertEquals("equivalent queries with null lowerterms are equal()", query, other);
-    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
-
-    query = new RangeQuery("content", "C", null, true, true);
-    other = new RangeQuery("content", "C", null, true, true);
-    assertEquals("equivalent queries with null upperterms are equal()", query, other);
-    assertEquals("hashcode returns same value", query.hashCode(), other.hashCode());
-
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", "C", null, true, true);
-    assertFalse("queries with different upper and lower terms are not equal", query.equals(other));
-
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", true, true);
-    assertFalse("queries with different inclusive are not equal", query.equals(other));
-    
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", false, false, Collator.getInstance());
-    assertFalse("a query with a collator is not equal to one without", query.equals(other));
-  }
-
-  public void testExclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false, Collator.getInstance(Locale.ENGLISH));
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[] {"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added, still only B in range", 1, hits.length);
-    searcher.close();
-  }
-
-  public void testInclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C",true, true, Collator.getInstance(Locale.ENGLISH));
-
-    initializeIndex(new String[]{"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[]{"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D - A and B in range", 2, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added - A, B, C in range", 3, hits.length);
-    searcher.close();
-  }
-
-  public void testFarsi() throws Exception {
-    // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-    // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-    // characters properly.
-    Collator collator = Collator.getInstance(new Locale("ar"));
-    Query query = new RangeQuery("content", "\u062F", "\u0698", true, true, collator);
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeQuery with a Farsi
-    // Collator (or an Arabic one for the case when Farsi is not supported).
-    initializeIndex(new String[]{ "\u0633\u0627\u0628"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, hits.length);
-
-    query = new RangeQuery("content", "\u0633", "\u0638",true, true, collator);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, hits.length);
-    searcher.close();
-  }
-  
-  public void testDanish() throws Exception {
-    Collator collator = Collator.getInstance(new Locale("da", "dk"));
-    // Danish collation orders the words below in the given order (example taken
-    // from TestSort.testInternationalSort() ).
-    String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
-    Query query = new RangeQuery("content", "H\u00D8T", "MAND", false, false, collator);
-
-    // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
-    // but Danish collation does.
-    initializeIndex(words);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, hits.length);
-
-    query = new RangeQuery("content", "H\u00C5T", "MAND", false, false, collator);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, hits.length);
-    searcher.close();
-  }
-
-  private static class SingleCharAnalyzer extends Analyzer {
-
-    private static class SingleCharTokenizer extends Tokenizer {
-      char[] buffer = new char[1];
-      boolean done;
-      TermAttribute termAtt;
-      
-      public SingleCharTokenizer(Reader r) {
-        super(r);
-        termAtt = (TermAttribute) addAttribute(TermAttribute.class);
-      }
-
-      public boolean incrementToken() throws IOException {
-        int count = input.read(buffer);
-        if (done)
-          return false;
-        else {
-          done = true;
-          if (count == 1) {
-            termAtt.termBuffer()[0] = buffer[0];
-            termAtt.setTermLength(1);
-          } else
-            termAtt.setTermLength(0);
-          return true;
-        }
-      }
-
-      public final void reset(Reader reader) throws IOException {
-        super.reset(reader);
-        done = false;
-      }
-    }
-
-    public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
-      Tokenizer tokenizer = (Tokenizer) getPreviousTokenStream();
-      if (tokenizer == null) {
-        tokenizer = new SingleCharTokenizer(reader);
-        setPreviousTokenStream(tokenizer);
-      } else
-        tokenizer.reset(reader);
-      return tokenizer;
-    }
-
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      return new SingleCharTokenizer(reader);
-    }
-  }
-
-  private void initializeIndex(String[] values) throws IOException {
-    initializeIndex(values, new WhitespaceAnalyzer());
-  }
-
-  private void initializeIndex(String[] values, Analyzer analyzer) throws IOException {
-    IndexWriter writer = new IndexWriter(dir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    for (int i = 0; i < values.length; i++) {
-      insertDoc(writer, values[i]);
-    }
-    writer.close();
-  }
-
-  private void addDoc(String content) throws IOException {
-    IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, IndexWriter.MaxFieldLength.LIMITED);
-    insertDoc(writer, content);
-    writer.close();
-  }
-
-  private void insertDoc(IndexWriter writer, String content) throws IOException {
-    Document doc = new Document();
-
-    doc.add(new Field("id", "id" + docCount, Field.Store.YES, Field.Index.NOT_ANALYZED));
-    doc.add(new Field("content", content, Field.Store.NO, Field.Index.ANALYZED));
-
-    writer.addDocument(doc);
-    docCount++;
-  }
-
-  // LUCENE-38
-  public void testExclusiveLowerNull() throws Exception {
-    Analyzer analyzer = new SingleCharAnalyzer();
-    //http://issues.apache.org/jira/browse/LUCENE-38
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 false);
-    initializeIndex(new String[] {"A", "B", "", "C", "D"}, analyzer);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    Hits hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert:
-    //assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 2, hits.length());
-
-    searcher.close();
-    initializeIndex(new String[] {"A", "B", "", "D"}, analyzer);
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert:
-    //assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 2, hits.length());
-    searcher.close();
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("C added, still A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("C added, still A, B & <empty string> are in range", 2, hits.length());
-    searcher.close();
-  }
-
-  // LUCENE-38
-  public void testInclusiveLowerNull() throws Exception {
-    //http://issues.apache.org/jira/browse/LUCENE-38
-    Analyzer analyzer = new SingleCharAnalyzer();
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 true);
-    initializeIndex(new String[]{"A", "B", "","C", "D"}, analyzer);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    Hits hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 4, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 3, hits.length());
-    searcher.close();
-    initializeIndex(new String[]{"A", "B", "", "D"}, analyzer);
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,D - A, B and <empty string> in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("A,B,<empty string>,D => A, B and <empty string> in range", 2, hits.length());
-    searcher.close();
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("C added => A,B,<empty string>,C in range", 4, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("C added => A,B,<empty string>,C in range", 3, hits.length());
-     searcher.close();
-  }
-}
diff --git a/src/test/org/apache/lucene/search/TestTermRangeFilter.java b/src/test/org/apache/lucene/search/TestTermRangeFilter.java
new file mode 100644
index 0000000..0a9fe3c
--- /dev/null
+++ b/src/test/org/apache/lucene/search/TestTermRangeFilter.java
@@ -0,0 +1,421 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.text.Collator;
+import java.util.Locale;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * A basic 'positive' Unit test class for the TermRangeFilter class.
+ *
+ * <p>
+ * NOTE: at the moment, this class only tests for 'positive' results,
+ * it does not verify the results to ensure there are no 'false positives',
+ * nor does it adequately test 'negative' results.  It also does not test
+ * that garbage in results in an Exception.
+ */
+public class TestTermRangeFilter extends BaseTestRangeFilter {
+
+    public TestTermRangeFilter(String name) {
+	super(name);
+    }
+    public TestTermRangeFilter() {
+        super();
+    }
+
+    public void testRangeFilterId() throws IOException {
+
+        IndexReader reader = IndexReader.open(signedIndex.index);
+	IndexSearcher search = new IndexSearcher(reader);
+
+        int medId = ((maxId - minId) / 2);
+        
+        String minIP = pad(minId);
+        String maxIP = pad(maxId);
+        String medIP = pad(medId);
+    
+        int numDocs = reader.numDocs();
+        
+        assertEquals("num of docs", numDocs, 1+ maxId - minId);
+        
+  ScoreDoc[] result;
+        Query q = new TermQuery(new Term("body","body"));
+
+        // test id, bounded on both ends
+        
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,T), numDocs).scoreDocs;
+  assertEquals("find all", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,F), numDocs).scoreDocs;
+  assertEquals("all but last", numDocs-1, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,T), numDocs).scoreDocs;
+  assertEquals("all but first", numDocs-1, result.length);
+        
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,F), numDocs).scoreDocs;
+        assertEquals("all but ends", numDocs-2, result.length);
+    
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,T), numDocs).scoreDocs;
+        assertEquals("med and up", 1+ maxId-medId, result.length);
+        
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,T,T), numDocs).scoreDocs;
+        assertEquals("up to med", 1+ medId-minId, result.length);
+
+        // unbounded id
+
+  result = search.search(q,new TermRangeFilter("id",minIP,null,T,F), numDocs).scoreDocs;
+  assertEquals("min and up", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",null,maxIP,F,T), numDocs).scoreDocs;
+  assertEquals("max and down", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",minIP,null,F,F), numDocs).scoreDocs;
+  assertEquals("not min, but up", numDocs-1, result.length);
+        
+  result = search.search(q,new TermRangeFilter("id",null,maxIP,F,F), numDocs).scoreDocs;
+  assertEquals("not max, but down", numDocs-1, result.length);
+        
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,F), numDocs).scoreDocs;
+        assertEquals("med and up, not max", maxId-medId, result.length);
+        
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,F,T), numDocs).scoreDocs;
+        assertEquals("not min, up to med", medId-minId, result.length);
+
+        // very small sets
+
+  result = search.search(q,new TermRangeFilter("id",minIP,minIP,F,F), numDocs).scoreDocs;
+  assertEquals("min,min,F,F", 0, result.length);
+  result = search.search(q,new TermRangeFilter("id",medIP,medIP,F,F), numDocs).scoreDocs;
+  assertEquals("med,med,F,F", 0, result.length);
+  result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,F,F), numDocs).scoreDocs;
+  assertEquals("max,max,F,F", 0, result.length);
+                     
+  result = search.search(q,new TermRangeFilter("id",minIP,minIP,T,T), numDocs).scoreDocs;
+  assertEquals("min,min,T,T", 1, result.length);
+  result = search.search(q,new TermRangeFilter("id",null,minIP,F,T), numDocs).scoreDocs;
+  assertEquals("nul,min,F,T", 1, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,T,T), numDocs).scoreDocs;
+  assertEquals("max,max,T,T", 1, result.length);
+  result = search.search(q,new TermRangeFilter("id",maxIP,null,T,F), numDocs).scoreDocs;
+  assertEquals("max,nul,T,T", 1, result.length);
+
+  result = search.search(q,new TermRangeFilter("id",medIP,medIP,T,T), numDocs).scoreDocs;
+  assertEquals("med,med,T,T", 1, result.length);
+        
+    }
+
+    public void testRangeFilterIdCollating() throws IOException {
+
+        IndexReader reader = IndexReader.open(signedIndex.index);
+        IndexSearcher search = new IndexSearcher(reader);
+
+        Collator c = Collator.getInstance(Locale.ENGLISH);
+
+        int medId = ((maxId - minId) / 2);
+
+        String minIP = pad(minId);
+        String maxIP = pad(maxId);
+        String medIP = pad(medId);
+
+        int numDocs = reader.numDocs();
+
+        assertEquals("num of docs", numDocs, 1+ maxId - minId);
+
+        Hits result;
+        Query q = new TermQuery(new Term("body","body"));
+
+        // test id, bounded on both ends
+
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,T,c));
+        assertEquals("find all", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,F,c));
+        assertEquals("all but last", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,T,c));
+        assertEquals("all but first", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,F,c));
+        assertEquals("all but ends", numDocs-2, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,T,c));
+        assertEquals("med and up", 1+ maxId-medId, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,T,T,c));
+        assertEquals("up to med", 1+ medId-minId, result.length());
+
+        // unbounded id
+
+        result = search.search(q,new TermRangeFilter("id",minIP,null,T,F,c));
+        assertEquals("min and up", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",null,maxIP,F,T,c));
+        assertEquals("max and down", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,null,F,F,c));
+        assertEquals("not min, but up", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",null,maxIP,F,F,c));
+        assertEquals("not max, but down", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,F,c));
+        assertEquals("med and up, not max", maxId-medId, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,F,T,c));
+        assertEquals("not min, up to med", medId-minId, result.length());
+
+        // very small sets
+
+        result = search.search(q,new TermRangeFilter("id",minIP,minIP,F,F,c));
+        assertEquals("min,min,F,F", 0, result.length());
+        result = search.search(q,new TermRangeFilter("id",medIP,medIP,F,F,c));
+        assertEquals("med,med,F,F", 0, result.length());
+        result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,F,F,c));
+        assertEquals("max,max,F,F", 0, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",minIP,minIP,T,T,c));
+        assertEquals("min,min,T,T", 1, result.length());
+        result = search.search(q,new TermRangeFilter("id",null,minIP,F,T,c));
+        assertEquals("nul,min,F,T", 1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,T,T,c));
+        assertEquals("max,max,T,T", 1, result.length());
+        result = search.search(q,new TermRangeFilter("id",maxIP,null,T,F,c));
+        assertEquals("max,nul,T,T", 1, result.length());
+
+        result = search.search(q,new TermRangeFilter("id",medIP,medIP,T,T,c));
+        assertEquals("med,med,T,T", 1, result.length());
+    }
+
+    public void testRangeFilterRand() throws IOException {
+
+  IndexReader reader = IndexReader.open(signedIndex.index);
+	IndexSearcher search = new IndexSearcher(reader);
+
+        String minRP = pad(signedIndex.minR);
+        String maxRP = pad(signedIndex.maxR);
+    
+        int numDocs = reader.numDocs();
+        
+        assertEquals("num of docs", numDocs, 1+ maxId - minId);
+        
+  ScoreDoc[] result;
+        Query q = new TermQuery(new Term("body","body"));
+
+        // test extremes, bounded on both ends
+        
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,T), numDocs).scoreDocs;
+  assertEquals("find all", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,F), numDocs).scoreDocs;
+  assertEquals("all but biggest", numDocs-1, result.length);
+
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,T), numDocs).scoreDocs;
+  assertEquals("all but smallest", numDocs-1, result.length);
+        
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,F), numDocs).scoreDocs;
+        assertEquals("all but extremes", numDocs-2, result.length);
+    
+        // unbounded
+
+  result = search.search(q,new TermRangeFilter("rand",minRP,null,T,F), numDocs).scoreDocs;
+  assertEquals("smallest and up", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,T), numDocs).scoreDocs;
+  assertEquals("biggest and down", numDocs, result.length);
+
+  result = search.search(q,new TermRangeFilter("rand",minRP,null,F,F), numDocs).scoreDocs;
+  assertEquals("not smallest, but up", numDocs-1, result.length);
+        
+  result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,F), numDocs).scoreDocs;
+  assertEquals("not biggest, but down", numDocs-1, result.length);
+        
+        // very small sets
+
+  result = search.search(q,new TermRangeFilter("rand",minRP,minRP,F,F), numDocs).scoreDocs;
+  assertEquals("min,min,F,F", 0, result.length);
+  result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,F,F), numDocs).scoreDocs;
+  assertEquals("max,max,F,F", 0, result.length);
+                     
+  result = search.search(q,new TermRangeFilter("rand",minRP,minRP,T,T), numDocs).scoreDocs;
+  assertEquals("min,min,T,T", 1, result.length);
+  result = search.search(q,new TermRangeFilter("rand",null,minRP,F,T), numDocs).scoreDocs;
+  assertEquals("nul,min,F,T", 1, result.length);
+
+  result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,T,T), numDocs).scoreDocs;
+  assertEquals("max,max,T,T", 1, result.length);
+  result = search.search(q,new TermRangeFilter("rand",maxRP,null,T,F), numDocs).scoreDocs;
+  assertEquals("max,nul,T,T", 1, result.length);
+        
+    }
+
+    public void testRangeFilterRandCollating() throws IOException {
+
+        // using the unsigned index because collation seems to ignore hyphens
+        IndexReader reader = IndexReader.open(unsignedIndex.index);
+        IndexSearcher search = new IndexSearcher(reader);
+
+        Collator c = Collator.getInstance(Locale.ENGLISH);
+
+        String minRP = pad(unsignedIndex.minR);
+        String maxRP = pad(unsignedIndex.maxR);
+
+        int numDocs = reader.numDocs();
+
+        assertEquals("num of docs", numDocs, 1+ maxId - minId);
+
+        Hits result;
+        Query q = new TermQuery(new Term("body","body"));
+
+        // test extremes, bounded on both ends
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,T,c));
+        assertEquals("find all", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,F,c));
+        assertEquals("all but biggest", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,T,c));
+        assertEquals("all but smallest", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,F,c));
+        assertEquals("all but extremes", numDocs-2, result.length());
+
+        // unbounded
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,null,T,F,c));
+        assertEquals("smallest and up", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,T,c));
+        assertEquals("biggest and down", numDocs, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,null,F,F,c));
+        assertEquals("not smallest, but up", numDocs-1, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,F,c));
+        assertEquals("not biggest, but down", numDocs-1, result.length());
+
+        // very small sets
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,minRP,F,F,c));
+        assertEquals("min,min,F,F", 0, result.length());
+        result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,F,F,c));
+        assertEquals("max,max,F,F", 0, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",minRP,minRP,T,T,c));
+        assertEquals("min,min,T,T", 1, result.length());
+        result = search.search(q,new TermRangeFilter("rand",null,minRP,F,T,c));
+        assertEquals("nul,min,F,T", 1, result.length());
+
+        result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,T,T,c));
+        assertEquals("max,max,T,T", 1, result.length());
+        result = search.search(q,new TermRangeFilter("rand",maxRP,null,T,F,c));
+        assertEquals("max,nul,T,T", 1, result.length());
+    }
+    
+    public void testFarsi() throws Exception {
+            
+        /* build an index */
+        RAMDirectory farsiIndex = new RAMDirectory();
+        IndexWriter writer = new IndexWriter(farsiIndex, new SimpleAnalyzer(), T, 
+                                             IndexWriter.MaxFieldLength.LIMITED);
+        Document doc = new Document();
+        doc.add(new Field("content","\u0633\u0627\u0628", 
+                          Field.Store.YES, Field.Index.UN_TOKENIZED));
+        doc.add(new Field("body", "body",
+                          Field.Store.YES, Field.Index.UN_TOKENIZED));
+        writer.addDocument(doc);
+            
+        writer.optimize();
+        writer.close();
+
+        IndexReader reader = IndexReader.open(farsiIndex);
+        IndexSearcher search = new IndexSearcher(reader);
+        Query q = new TermQuery(new Term("body","body"));
+
+        // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
+        // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
+        // characters properly.
+        Collator collator = Collator.getInstance(new Locale("ar"));
+        
+        // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+        // orders the U+0698 character before the U+0633 character, so the single
+        // index Term below should NOT be returned by a TermRangeFilter with a Farsi
+        // Collator (or an Arabic one for the case when Farsi is not supported).
+        Hits result = search.search
+            (q, new TermRangeFilter("content", "\u062F", "\u0698", T, T, collator));
+        assertEquals("The index Term should not be included.", 0, result.length());
+
+        result = search.search
+            (q, new TermRangeFilter("content", "\u0633", "\u0638", T, T, collator));
+        assertEquals("The index Term should be included.", 1, result.length());
+        search.close();
+    }
+
+    public void testDanish() throws Exception {
+            
+        /* build an index */
+        RAMDirectory danishIndex = new RAMDirectory();
+        IndexWriter writer = new IndexWriter
+            (danishIndex, new SimpleAnalyzer(), T, 
+             IndexWriter.MaxFieldLength.LIMITED);
+        // Danish collation orders the words below in the given order
+        // (example taken from TestSort.testInternationalSort() ).
+        String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
+        for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
+            Document doc = new Document();
+            doc.add(new Field("content", words[docnum], 
+                              Field.Store.YES, Field.Index.UN_TOKENIZED));
+            doc.add(new Field("body", "body",
+                              Field.Store.YES, Field.Index.UN_TOKENIZED));
+            writer.addDocument(doc);
+        }
+        writer.optimize();
+        writer.close();
+
+        IndexReader reader = IndexReader.open(danishIndex);
+        IndexSearcher search = new IndexSearcher(reader);
+        Query q = new TermQuery(new Term("body","body"));
+
+        Collator collator = Collator.getInstance(new Locale("da", "dk"));
+        Query query = new TermRangeQuery
+            ("content", "H\u00D8T", "MAND", false, false, collator);
+
+        // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
+        // but Danish collation does.
+        Hits result = search.search
+            (q, new TermRangeFilter("content", "H\u00D8T", "MAND", F, F, collator));
+        assertEquals("The index Term should be included.", 1, result.length());
+
+        result = search.search
+            (q, new TermRangeFilter("content", "H\u00C5T", "MAND", F, F, collator));
+        assertEquals
+            ("The index Term should not be included.", 0, result.length());
+        search.close();
+    }
+}
diff --git a/src/test/org/apache/lucene/search/TestTermRangeQuery.java b/src/test/org/apache/lucene/search/TestTermRangeQuery.java
new file mode 100644
index 0000000..383a715
--- /dev/null
+++ b/src/test/org/apache/lucene/search/TestTermRangeQuery.java
@@ -0,0 +1,377 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+
+import org.apache.lucene.util.LuceneTestCase;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Locale;
+import java.text.Collator;
+
+
+public class TestTermRangeQuery extends LuceneTestCase {
+
+  private int docCount = 0;
+  private RAMDirectory dir;
+
+  public void setUp() throws Exception {
+    super.setUp();
+    dir = new RAMDirectory();
+  }
+
+  public void testExclusive() throws Exception {
+    Query query = new TermRangeQuery("content", "A", "C", false, false);
+    initializeIndex(new String[] {"A", "B", "C", "D"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D, only B in range", 1, hits.length);
+    searcher.close();
+
+    initializeIndex(new String[] {"A", "B", "D"});
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,D, only B in range", 1, hits.length);
+    searcher.close();
+
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("C added, still only B in range", 1, hits.length);
+    searcher.close();
+  }
+  
+  //TODO: remove in Lucene 3.0
+  public void testDeprecatedCstrctors() throws IOException {
+    Query query = new RangeQuery(null, new Term("content","C"), false);
+    initializeIndex(new String[] {"A", "B", "C", "D"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D, only B in range", 2, hits.length);
+    searcher.close();
+    
+    query = new RangeQuery(new Term("content","C"),null, false);
+    initializeIndex(new String[] {"A", "B", "C", "D"});
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D, only B in range", 1, hits.length);
+    searcher.close();
+  }
+
+  public void testInclusive() throws Exception {
+    Query query = new TermRangeQuery("content", "A", "C", true, true);
+
+    initializeIndex(new String[]{"A", "B", "C", "D"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
+    searcher.close();
+
+    initializeIndex(new String[]{"A", "B", "D"});
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,D - A and B in range", 2, hits.length);
+    searcher.close();
+
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("C added - A, B, C in range", 3, hits.length);
+    searcher.close();
+  }
+
+  public void testEqualsHashcode() {
+    Query query = new TermRangeQuery("content", "A", "C", true, true);
+    
+    query.setBoost(1.0f);
+    Query other = new TermRangeQuery("content", "A", "C", true, true);
+    other.setBoost(1.0f);
+
+    assertEquals("query equals itself is true", query, query);
+    assertEquals("equivalent queries are equal", query, other);
+    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
+
+    other.setBoost(2.0f);
+    assertFalse("Different boost queries are not equal", query.equals(other));
+
+    other = new TermRangeQuery("notcontent", "A", "C", true, true);
+    assertFalse("Different fields are not equal", query.equals(other));
+
+    other = new TermRangeQuery("content", "X", "C", true, true);
+    assertFalse("Different lower terms are not equal", query.equals(other));
+
+    other = new TermRangeQuery("content", "A", "Z", true, true);
+    assertFalse("Different upper terms are not equal", query.equals(other));
+
+    query = new TermRangeQuery("content", null, "C", true, true);
+    other = new TermRangeQuery("content", null, "C", true, true);
+    assertEquals("equivalent queries with null lowerterms are equal()", query, other);
+    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
+
+    query = new TermRangeQuery("content", "C", null, true, true);
+    other = new TermRangeQuery("content", "C", null, true, true);
+    assertEquals("equivalent queries with null upperterms are equal()", query, other);
+    assertEquals("hashcode returns same value", query.hashCode(), other.hashCode());
+
+    query = new TermRangeQuery("content", null, "C", true, true);
+    other = new TermRangeQuery("content", "C", null, true, true);
+    assertFalse("queries with different upper and lower terms are not equal", query.equals(other));
+
+    query = new TermRangeQuery("content", "A", "C", false, false);
+    other = new TermRangeQuery("content", "A", "C", true, true);
+    assertFalse("queries with different inclusive are not equal", query.equals(other));
+    
+    query = new TermRangeQuery("content", "A", "C", false, false);
+    other = new TermRangeQuery("content", "A", "C", false, false, Collator.getInstance());
+    assertFalse("a query with a collator is not equal to one without", query.equals(other));
+  }
+
+  public void testExclusiveCollating() throws Exception {
+    Query query = new TermRangeQuery("content", "A", "C", false, false, Collator.getInstance(Locale.ENGLISH));
+    initializeIndex(new String[] {"A", "B", "C", "D"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D, only B in range", 1, hits.length);
+    searcher.close();
+
+    initializeIndex(new String[] {"A", "B", "D"});
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,D, only B in range", 1, hits.length);
+    searcher.close();
+
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("C added, still only B in range", 1, hits.length);
+    searcher.close();
+  }
+
+  public void testInclusiveCollating() throws Exception {
+    Query query = new TermRangeQuery("content", "A", "C",true, true, Collator.getInstance(Locale.ENGLISH));
+
+    initializeIndex(new String[]{"A", "B", "C", "D"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
+    searcher.close();
+
+    initializeIndex(new String[]{"A", "B", "D"});
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("A,B,D - A and B in range", 2, hits.length);
+    searcher.close();
+
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("C added - A, B, C in range", 3, hits.length);
+    searcher.close();
+  }
+
+  public void testFarsi() throws Exception {
+    // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
+    // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
+    // characters properly.
+    Collator collator = Collator.getInstance(new Locale("ar"));
+    Query query = new TermRangeQuery("content", "\u062F", "\u0698", true, true, collator);
+    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+    // orders the U+0698 character before the U+0633 character, so the single
+    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
+    // Collator (or an Arabic one for the case when Farsi is not supported).
+    initializeIndex(new String[]{ "\u0633\u0627\u0628"});
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should not be included.", 0, hits.length);
+
+    query = new TermRangeQuery("content", "\u0633", "\u0638",true, true, collator);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should be included.", 1, hits.length);
+    searcher.close();
+  }
+  
+  public void testDanish() throws Exception {
+    Collator collator = Collator.getInstance(new Locale("da", "dk"));
+    // Danish collation orders the words below in the given order (example taken
+    // from TestSort.testInternationalSort() ).
+    String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
+    Query query = new TermRangeQuery("content", "H\u00D8T", "MAND", false, false, collator);
+
+    // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
+    // but Danish collation does.
+    initializeIndex(words);
+    IndexSearcher searcher = new IndexSearcher(dir);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should be included.", 1, hits.length);
+
+    query = new TermRangeQuery("content", "H\u00C5T", "MAND", false, false, collator);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should not be included.", 0, hits.length);
+    searcher.close();
+  }
+
+  private static class SingleCharAnalyzer extends Analyzer {
+
+    private static class SingleCharTokenizer extends Tokenizer {
+      char[] buffer = new char[1];
+      boolean done;
+      TermAttribute termAtt;
+      
+      public SingleCharTokenizer(Reader r) {
+        super(r);
+        termAtt = (TermAttribute) addAttribute(TermAttribute.class);
+      }
+
+      public boolean incrementToken() throws IOException {
+        int count = input.read(buffer);
+        if (done)
+          return false;
+        else {
+          done = true;
+          if (count == 1) {
+            termAtt.termBuffer()[0] = buffer[0];
+            termAtt.setTermLength(1);
+          } else
+            termAtt.setTermLength(0);
+          return true;
+        }
+      }
+
+      public final void reset(Reader reader) throws IOException {
+        super.reset(reader);
+        done = false;
+      }
+    }
+
+    public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
+      Tokenizer tokenizer = (Tokenizer) getPreviousTokenStream();
+      if (tokenizer == null) {
+        tokenizer = new SingleCharTokenizer(reader);
+        setPreviousTokenStream(tokenizer);
+      } else
+        tokenizer.reset(reader);
+      return tokenizer;
+    }
+
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      return new SingleCharTokenizer(reader);
+    }
+  }
+
+  private void initializeIndex(String[] values) throws IOException {
+    initializeIndex(values, new WhitespaceAnalyzer());
+  }
+
+  private void initializeIndex(String[] values, Analyzer analyzer) throws IOException {
+    IndexWriter writer = new IndexWriter(dir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+    for (int i = 0; i < values.length; i++) {
+      insertDoc(writer, values[i]);
+    }
+    writer.close();
+  }
+
+  private void addDoc(String content) throws IOException {
+    IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, IndexWriter.MaxFieldLength.LIMITED);
+    insertDoc(writer, content);
+    writer.close();
+  }
+
+  private void insertDoc(IndexWriter writer, String content) throws IOException {
+    Document doc = new Document();
+
+    doc.add(new Field("id", "id" + docCount, Field.Store.YES, Field.Index.NOT_ANALYZED));
+    doc.add(new Field("content", content, Field.Store.NO, Field.Index.ANALYZED));
+
+    writer.addDocument(doc);
+    docCount++;
+  }
+
+  // LUCENE-38
+  public void testExclusiveLowerNull() throws Exception {
+    Analyzer analyzer = new SingleCharAnalyzer();
+    //http://issues.apache.org/jira/browse/LUCENE-38
+    Query query = new TermRangeQuery("content", null, "C",
+                                 false, false);
+    initializeIndex(new String[] {"A", "B", "", "C", "D"}, analyzer);
+    IndexSearcher searcher = new IndexSearcher(dir);
+    Hits hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 3, hits.length());
+    // until Lucene-38 is fixed, use this assert:
+    //assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 2, hits.length());
+
+    searcher.close();
+    initializeIndex(new String[] {"A", "B", "", "D"}, analyzer);
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 3, hits.length());
+    // until Lucene-38 is fixed, use this assert:
+    //assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 2, hits.length());
+    searcher.close();
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("C added, still A, B & <empty string> are in range", 3, hits.length());
+    // until Lucene-38 is fixed, use this assert
+    //assertEquals("C added, still A, B & <empty string> are in range", 2, hits.length());
+    searcher.close();
+  }
+
+  // LUCENE-38
+  public void testInclusiveLowerNull() throws Exception {
+    //http://issues.apache.org/jira/browse/LUCENE-38
+    Analyzer analyzer = new SingleCharAnalyzer();
+    Query query = new TermRangeQuery("content", null, "C", true, true);
+    initializeIndex(new String[]{"A", "B", "","C", "D"}, analyzer);
+    IndexSearcher searcher = new IndexSearcher(dir);
+    Hits hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 4, hits.length());
+    // until Lucene-38 is fixed, use this assert
+    //assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 3, hits.length());
+    searcher.close();
+    initializeIndex(new String[]{"A", "B", "", "D"}, analyzer);
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("A,B,<empty string>,D - A, B and <empty string> in range", 3, hits.length());
+    // until Lucene-38 is fixed, use this assert
+    //assertEquals("A,B,<empty string>,D => A, B and <empty string> in range", 2, hits.length());
+    searcher.close();
+    addDoc("C");
+    searcher = new IndexSearcher(dir);
+    hits = searcher.search(query);
+    // When Lucene-38 is fixed, use the assert on the next line:
+    assertEquals("C added => A,B,<empty string>,C in range", 4, hits.length());
+    // until Lucene-38 is fixed, use this assert
+    //assertEquals("C added => A,B,<empty string>,C in range", 3, hits.length());
+     searcher.close();
+  }
+}

