GitDiffStart: 3ba23367ea92468a07d1e3819b4145a336310829 | Tue Feb 14 21:31:11 2012 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
index 9b632c5..b0b4770 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
@@ -18,7 +18,6 @@ package org.apache.lucene.codecs;
  */
 import java.io.IOException;
 
-import org.apache.lucene.codecs.lucene40.values.Writer;
 import org.apache.lucene.document.DocValuesField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.DocValues.Source;
@@ -155,7 +154,7 @@ public abstract class DocValuesConsumer {
    * <p>
    * All documents IDs between the given ID and the previously given ID or
    * <tt>0</tt> if the method is call the first time are filled with default
-   * values depending on the {@link Writer} implementation. The given document
+   * values depending on the implementation. The given document
    * ID must always be greater than the previous ID or <tt>0</tt> if called the
    * first time.
    */
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesReaderBase.java b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesReaderBase.java
deleted file mode 100644
index 40239a9..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesReaderBase.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package org.apache.lucene.codecs;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Map;
-import java.util.TreeMap;
-
-import org.apache.lucene.codecs.lucene40.values.Bytes;
-import org.apache.lucene.codecs.lucene40.values.Floats;
-import org.apache.lucene.codecs.lucene40.values.Ints;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.DocValues;
-import org.apache.lucene.index.DocValues.Type; // javadocs
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * Abstract base class for PerDocProducer implementations
- * @lucene.experimental
- */
-// TODO: this needs to go under lucene40 codec (its specific to its impl)
-public abstract class DocValuesReaderBase extends PerDocProducer {
-
-  protected abstract void closeInternal(Collection<? extends Closeable> closeables) throws IOException;
-  protected abstract Map<String, DocValues> docValues();
-  
-  @Override
-  public void close() throws IOException {
-    closeInternal(docValues().values());
-  }
-  
-  @Override
-  public DocValues docValues(String field) throws IOException {
-    return docValues().get(field);
-  }
-  
-  public Comparator<BytesRef> getComparator() throws IOException {
-    return BytesRef.getUTF8SortedAsUnicodeComparator();
-  }
-
-  // Only opens files... doesn't actually load any values
-  protected TreeMap<String, DocValues> load(FieldInfos fieldInfos,
-      String segment, int docCount, Directory dir, IOContext context)
-      throws IOException {
-    TreeMap<String, DocValues> values = new TreeMap<String, DocValues>();
-    boolean success = false;
-    try {
-
-      for (FieldInfo fieldInfo : fieldInfos) {
-        if (canLoad(fieldInfo)) {
-          final String field = fieldInfo.name;
-          // TODO can we have a compound file per segment and codec for
-          // docvalues?
-          final String id = DocValuesWriterBase.docValuesId(segment,
-              fieldInfo.number);
-          values.put(field,
-              loadDocValues(docCount, dir, id, getDocValuesType(fieldInfo), context));
-        }
-      }
-      success = true;
-    } finally {
-      if (!success) {
-        // if we fail we must close all opened resources if there are any
-        closeInternal(values.values());
-      }
-    }
-    return values;
-  }
-  
-  protected boolean canLoad(FieldInfo info) {
-    return info.hasDocValues();
-  }
-  
-  protected Type getDocValuesType(FieldInfo info) {
-    return info.getDocValuesType();
-  }
-  
-  protected boolean anyDocValuesFields(FieldInfos infos) {
-    return infos.anyDocValuesFields();
-  }
-  
-  /**
-   * Loads a {@link DocValues} instance depending on the given {@link Type}.
-   * Codecs that use different implementations for a certain {@link Type} can
-   * simply override this method and return their custom implementations.
-   * 
-   * @param docCount
-   *          number of documents in the segment
-   * @param dir
-   *          the {@link Directory} to load the {@link DocValues} from
-   * @param id
-   *          the unique file ID within the segment
-   * @param type
-   *          the type to load
-   * @return a {@link DocValues} instance for the given type
-   * @throws IOException
-   *           if an {@link IOException} occurs
-   * @throws IllegalArgumentException
-   *           if the given {@link Type} is not supported
-   */
-  protected DocValues loadDocValues(int docCount, Directory dir, String id,
-      DocValues.Type type, IOContext context) throws IOException {
-    switch (type) {
-    case FIXED_INTS_16:
-    case FIXED_INTS_32:
-    case FIXED_INTS_64:
-    case FIXED_INTS_8:
-    case VAR_INTS:
-      return Ints.getValues(dir, id, docCount, type, context);
-    case FLOAT_32:
-      return Floats.getValues(dir, id, docCount, context, type);
-    case FLOAT_64:
-      return Floats.getValues(dir, id, docCount, context, type);
-    case BYTES_FIXED_STRAIGHT:
-      return Bytes.getValues(dir, id, Bytes.Mode.STRAIGHT, true, docCount, getComparator(), context);
-    case BYTES_FIXED_DEREF:
-      return Bytes.getValues(dir, id, Bytes.Mode.DEREF, true, docCount, getComparator(), context);
-    case BYTES_FIXED_SORTED:
-      return Bytes.getValues(dir, id, Bytes.Mode.SORTED, true, docCount, getComparator(), context);
-    case BYTES_VAR_STRAIGHT:
-      return Bytes.getValues(dir, id, Bytes.Mode.STRAIGHT, false, docCount, getComparator(), context);
-    case BYTES_VAR_DEREF:
-      return Bytes.getValues(dir, id, Bytes.Mode.DEREF, false, docCount, getComparator(), context);
-    case BYTES_VAR_SORTED:
-      return Bytes.getValues(dir, id, Bytes.Mode.SORTED, false, docCount, getComparator(), context);
-    default:
-      throw new IllegalStateException("unrecognized index values mode " + type);
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesWriterBase.java b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesWriterBase.java
deleted file mode 100644
index d6fae8b..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesWriterBase.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package org.apache.lucene.codecs;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Comparator;
-
-import org.apache.lucene.codecs.lucene40.values.Writer;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.PerDocWriteState;
-import org.apache.lucene.index.DocValues.Type; // javadoc
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Counter;
-
-/**
- * Abstract base class for PerDocConsumer implementations
- *
- * @lucene.experimental
- */
-//TODO: this needs to go under lucene40 codec (its specific to its impl)
-public abstract class DocValuesWriterBase extends PerDocConsumer {
-  protected final String segmentName;
-  private final Counter bytesUsed;
-  protected final IOContext context;
-  private final boolean fasterButMoreRam;
-
-  /**
-   * @param state The state to initiate a {@link PerDocConsumer} instance
-   */
-  protected DocValuesWriterBase(PerDocWriteState state) {
-    this(state, true);
-  }
-
-  /**
-   * @param state The state to initiate a {@link PerDocConsumer} instance
-   * @param fasterButMoreRam whether packed ints for docvalues should be optimized for speed by rounding up the bytes
-   *                         used for a value to either 8, 16, 32 or 64 bytes. This option is only applicable for
-   *                         docvalues of type {@link Type#BYTES_FIXED_SORTED} and {@link Type#BYTES_VAR_SORTED}.
-   */
-  protected DocValuesWriterBase(PerDocWriteState state, boolean fasterButMoreRam) {
-    this.segmentName = state.segmentName;
-    this.bytesUsed = state.bytesUsed;
-    this.context = state.context;
-    this.fasterButMoreRam = fasterButMoreRam;
-  }
-
-  protected abstract Directory getDirectory() throws IOException;
-  
-  @Override
-  public void close() throws IOException {   
-  }
-
-  @Override
-  public DocValuesConsumer addValuesField(Type valueType, FieldInfo field) throws IOException {
-    return Writer.create(valueType,
-        docValuesId(segmentName, field.number), 
-        getDirectory(), getComparator(), bytesUsed, context, fasterButMoreRam);
-  }
-
-  public static String docValuesId(String segmentsName, int fieldId) {
-    return segmentsName + "_" + fieldId;
-  }
-  
-  
-  public Comparator<BytesRef> getComparator() throws IOException {
-    return BytesRef.getUTF8SortedAsUnicodeComparator();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesConsumer.java
index 39f7b58..6ffaec4 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesConsumer.java
@@ -20,7 +20,7 @@ package org.apache.lucene.codecs.lucene40;
 import java.io.IOException;
 import java.util.Set;
 
-import org.apache.lucene.codecs.DocValuesWriterBase;
+import org.apache.lucene.codecs.lucene40.values.DocValuesWriterBase;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesProducer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesProducer.java
index 2162095..67521f6 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesProducer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesProducer.java
@@ -24,7 +24,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.TreeMap;
 
-import org.apache.lucene.codecs.DocValuesReaderBase;
+import org.apache.lucene.codecs.lucene40.values.DocValuesReaderBase;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentReadState;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
index eefd72b..06bf58e 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
@@ -64,7 +64,7 @@ import org.apache.lucene.util.packed.PackedInts;
  * 
  * @lucene.experimental
  */
-public final class Bytes {
+final class Bytes {
 
   static final String DV_SEGMENT_SUFFIX = "dv";
 
@@ -256,7 +256,7 @@ public final class Bytes {
         boolean success = false;
         try {
           datOut = dir.createOutput(IndexFileNames.segmentFileName(id, DV_SEGMENT_SUFFIX,
-              DATA_EXTENSION), context);
+              DocValuesWriterBase.DATA_EXTENSION), context);
           CodecUtil.writeHeader(datOut, codecName, version);
           success = true;
         } finally {
@@ -281,7 +281,7 @@ public final class Bytes {
       try {
         if (idxOut == null) {
           idxOut = dir.createOutput(IndexFileNames.segmentFileName(id, DV_SEGMENT_SUFFIX,
-              INDEX_EXTENSION), context);
+              DocValuesWriterBase.INDEX_EXTENSION), context);
           CodecUtil.writeHeader(idxOut, codecName, version);
         }
         success = true;
@@ -331,11 +331,11 @@ public final class Bytes {
       boolean success = false;
       try {
         dataIn = dir.openInput(IndexFileNames.segmentFileName(id, DV_SEGMENT_SUFFIX,
-                                                              Writer.DATA_EXTENSION), context);
+                                                              DocValuesWriterBase.DATA_EXTENSION), context);
         version = CodecUtil.checkHeader(dataIn, codecName, maxVersion, maxVersion);
         if (doIndex) {
           indexIn = dir.openInput(IndexFileNames.segmentFileName(id, DV_SEGMENT_SUFFIX,
-                                                                 Writer.INDEX_EXTENSION), context);
+                                                                 DocValuesWriterBase.INDEX_EXTENSION), context);
           final int version2 = CodecUtil.checkHeader(indexIn, codecName,
                                                      maxVersion, maxVersion);
           assert version == version2;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/BytesRefUtils.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/BytesRefUtils.java
index 885d2f8..4d4e7ea 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/BytesRefUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/BytesRefUtils.java
@@ -25,7 +25,7 @@ import org.apache.lucene.util.BytesRef;
  * 
  * @lucene.internal
  */
-public final class BytesRefUtils {
+final class BytesRefUtils {
 
   private BytesRefUtils() {
   }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DirectSource.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DirectSource.java
index d26b72d..5f38e3c 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DirectSource.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DirectSource.java
@@ -19,7 +19,6 @@ package org.apache.lucene.codecs.lucene40.values;
 
 import java.io.IOException;
 
-import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocValues.Source;
 import org.apache.lucene.index.DocValues.Type;
 import org.apache.lucene.store.IndexInput;
@@ -29,7 +28,7 @@ import org.apache.lucene.util.BytesRef;
  * Base class for disk resident source implementations
  * @lucene.internal
  */
-public abstract class DirectSource extends Source {
+abstract class DirectSource extends Source {
 
   protected final IndexInput data;
   private final ToNumeric toNumeric;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesReaderBase.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesReaderBase.java
new file mode 100644
index 0000000..71fb02f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesReaderBase.java
@@ -0,0 +1,151 @@
+package org.apache.lucene.codecs.lucene40.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.TreeMap;
+
+import org.apache.lucene.codecs.PerDocProducer;
+import org.apache.lucene.codecs.lucene40.values.Bytes;
+import org.apache.lucene.codecs.lucene40.values.Floats;
+import org.apache.lucene.codecs.lucene40.values.Ints;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValues.Type; // javadocs
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Abstract base class for PerDocProducer implementations
+ * @lucene.experimental
+ */
+public abstract class DocValuesReaderBase extends PerDocProducer {
+
+  protected abstract void closeInternal(Collection<? extends Closeable> closeables) throws IOException;
+  protected abstract Map<String, DocValues> docValues();
+  
+  @Override
+  public void close() throws IOException {
+    closeInternal(docValues().values());
+  }
+  
+  @Override
+  public DocValues docValues(String field) throws IOException {
+    return docValues().get(field);
+  }
+  
+  public Comparator<BytesRef> getComparator() throws IOException {
+    return BytesRef.getUTF8SortedAsUnicodeComparator();
+  }
+
+  // Only opens files... doesn't actually load any values
+  protected TreeMap<String, DocValues> load(FieldInfos fieldInfos,
+      String segment, int docCount, Directory dir, IOContext context)
+      throws IOException {
+    TreeMap<String, DocValues> values = new TreeMap<String, DocValues>();
+    boolean success = false;
+    try {
+
+      for (FieldInfo fieldInfo : fieldInfos) {
+        if (canLoad(fieldInfo)) {
+          final String field = fieldInfo.name;
+          // TODO can we have a compound file per segment and codec for
+          // docvalues?
+          final String id = DocValuesWriterBase.docValuesId(segment,
+              fieldInfo.number);
+          values.put(field,
+              loadDocValues(docCount, dir, id, getDocValuesType(fieldInfo), context));
+        }
+      }
+      success = true;
+    } finally {
+      if (!success) {
+        // if we fail we must close all opened resources if there are any
+        closeInternal(values.values());
+      }
+    }
+    return values;
+  }
+  
+  protected boolean canLoad(FieldInfo info) {
+    return info.hasDocValues();
+  }
+  
+  protected Type getDocValuesType(FieldInfo info) {
+    return info.getDocValuesType();
+  }
+  
+  protected boolean anyDocValuesFields(FieldInfos infos) {
+    return infos.anyDocValuesFields();
+  }
+  
+  /**
+   * Loads a {@link DocValues} instance depending on the given {@link Type}.
+   * Codecs that use different implementations for a certain {@link Type} can
+   * simply override this method and return their custom implementations.
+   * 
+   * @param docCount
+   *          number of documents in the segment
+   * @param dir
+   *          the {@link Directory} to load the {@link DocValues} from
+   * @param id
+   *          the unique file ID within the segment
+   * @param type
+   *          the type to load
+   * @return a {@link DocValues} instance for the given type
+   * @throws IOException
+   *           if an {@link IOException} occurs
+   * @throws IllegalArgumentException
+   *           if the given {@link Type} is not supported
+   */
+  protected DocValues loadDocValues(int docCount, Directory dir, String id,
+      DocValues.Type type, IOContext context) throws IOException {
+    switch (type) {
+    case FIXED_INTS_16:
+    case FIXED_INTS_32:
+    case FIXED_INTS_64:
+    case FIXED_INTS_8:
+    case VAR_INTS:
+      return Ints.getValues(dir, id, docCount, type, context);
+    case FLOAT_32:
+      return Floats.getValues(dir, id, docCount, context, type);
+    case FLOAT_64:
+      return Floats.getValues(dir, id, docCount, context, type);
+    case BYTES_FIXED_STRAIGHT:
+      return Bytes.getValues(dir, id, Bytes.Mode.STRAIGHT, true, docCount, getComparator(), context);
+    case BYTES_FIXED_DEREF:
+      return Bytes.getValues(dir, id, Bytes.Mode.DEREF, true, docCount, getComparator(), context);
+    case BYTES_FIXED_SORTED:
+      return Bytes.getValues(dir, id, Bytes.Mode.SORTED, true, docCount, getComparator(), context);
+    case BYTES_VAR_STRAIGHT:
+      return Bytes.getValues(dir, id, Bytes.Mode.STRAIGHT, false, docCount, getComparator(), context);
+    case BYTES_VAR_DEREF:
+      return Bytes.getValues(dir, id, Bytes.Mode.DEREF, false, docCount, getComparator(), context);
+    case BYTES_VAR_SORTED:
+      return Bytes.getValues(dir, id, Bytes.Mode.SORTED, false, docCount, getComparator(), context);
+    default:
+      throw new IllegalStateException("unrecognized index values mode " + type);
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesWriterBase.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesWriterBase.java
new file mode 100644
index 0000000..7b8483f2
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/DocValuesWriterBase.java
@@ -0,0 +1,96 @@
+package org.apache.lucene.codecs.lucene40.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Comparator;
+
+import org.apache.lucene.codecs.DocValuesConsumer;
+import org.apache.lucene.codecs.PerDocConsumer;
+import org.apache.lucene.codecs.lucene40.values.Writer;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.PerDocWriteState;
+import org.apache.lucene.index.DocValues.Type; // javadoc
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.Counter;
+
+/**
+ * Abstract base class for PerDocConsumer implementations
+ *
+ * @lucene.experimental
+ */
+public abstract class DocValuesWriterBase extends PerDocConsumer {
+  protected final String segmentName;
+  private final Counter bytesUsed;
+  protected final IOContext context;
+  private final boolean fasterButMoreRam;
+
+  /**
+   * Filename extension for index files
+   */
+  public static final String INDEX_EXTENSION = "idx";
+  
+  /**
+   * Filename extension for data files.
+   */
+  public static final String DATA_EXTENSION = "dat";
+
+  /**
+   * @param state The state to initiate a {@link PerDocConsumer} instance
+   */
+  protected DocValuesWriterBase(PerDocWriteState state) {
+    this(state, true);
+  }
+
+  /**
+   * @param state The state to initiate a {@link PerDocConsumer} instance
+   * @param fasterButMoreRam whether packed ints for docvalues should be optimized for speed by rounding up the bytes
+   *                         used for a value to either 8, 16, 32 or 64 bytes. This option is only applicable for
+   *                         docvalues of type {@link Type#BYTES_FIXED_SORTED} and {@link Type#BYTES_VAR_SORTED}.
+   */
+  protected DocValuesWriterBase(PerDocWriteState state, boolean fasterButMoreRam) {
+    this.segmentName = state.segmentName;
+    this.bytesUsed = state.bytesUsed;
+    this.context = state.context;
+    this.fasterButMoreRam = fasterButMoreRam;
+  }
+
+  protected abstract Directory getDirectory() throws IOException;
+  
+  @Override
+  public void close() throws IOException {   
+  }
+
+  @Override
+  public DocValuesConsumer addValuesField(Type valueType, FieldInfo field) throws IOException {
+    return Writer.create(valueType,
+        docValuesId(segmentName, field.number), 
+        getDirectory(), getComparator(), bytesUsed, context, fasterButMoreRam);
+  }
+
+  public static String docValuesId(String segmentsName, int fieldId) {
+    return segmentsName + "_" + fieldId;
+  }
+  
+  
+  public Comparator<BytesRef> getComparator() throws IOException {
+    return BytesRef.getUTF8SortedAsUnicodeComparator();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Floats.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Floats.java
index e96334c..8a2d073 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Floats.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Floats.java
@@ -39,7 +39,7 @@ import org.apache.lucene.util.IOUtils;
  * 
  * @lucene.experimental
  */
-public class Floats {
+class Floats {
   
   protected static final String CODEC_NAME = "Floats";
   protected static final int VERSION_START = 0;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Ints.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Ints.java
index 066bb4a..a9ba6c3 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Ints.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Ints.java
@@ -36,7 +36,7 @@ import org.apache.lucene.util.IOUtils;
  * 
  * @lucene.experimental
  */
-public final class Ints {
+final class Ints {
   protected static final String CODEC_NAME = "Ints";
   protected static final int VERSION_START = 0;
   protected static final int VERSION_CURRENT = VERSION_START;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
index 106321f..eb2acf7 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
@@ -169,7 +169,7 @@ class PackedIntValues {
     protected PackedIntsReader(Directory dir, String id, int numDocs,
         IOContext context) throws IOException {
       datIn = dir.openInput(
-                IndexFileNames.segmentFileName(id, Bytes.DV_SEGMENT_SUFFIX, Writer.DATA_EXTENSION),
+                IndexFileNames.segmentFileName(id, Bytes.DV_SEGMENT_SUFFIX, DocValuesWriterBase.DATA_EXTENSION),
           context);
       this.numDocs = numDocs;
       boolean success = false;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Writer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Writer.java
index a7f621b..13529d3 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Writer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Writer.java
@@ -38,7 +38,7 @@ import org.apache.lucene.util.Counter;
  * 
  * @lucene.experimental
  */
-public abstract class Writer extends DocValuesConsumer {
+abstract class Writer extends DocValuesConsumer {
   protected final Counter bytesUsed;
 
   /**
@@ -54,16 +54,6 @@ public abstract class Writer extends DocValuesConsumer {
   }
 
   /**
-   * Filename extension for index files
-   */
-  public static final String INDEX_EXTENSION = "idx";
-  
-  /**
-   * Filename extension for data files.
-   */
-  public static final String DATA_EXTENSION = "dat";
-
-  /**
    * Factory method to create a {@link Writer} instance for a given type. This
    * method returns default implementations for each of the different types
    * defined in the {@link Type} enumeration.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesConsumer.java
index 682c2c6..5a8472b 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesConsumer.java
@@ -21,8 +21,7 @@ import java.io.IOException;
 import java.util.HashSet;
 import java.util.Set;
 
-import org.apache.lucene.codecs.DocValuesWriterBase;
-import org.apache.lucene.codecs.lucene40.values.Writer;
+import org.apache.lucene.codecs.lucene40.values.DocValuesWriterBase;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
@@ -67,10 +66,10 @@ public class SepDocValuesConsumer extends DocValuesWriterBase {
           case BYTES_FIXED_SORTED:
           case BYTES_VAR_SORTED:
             files.add(IndexFileNames.segmentFileName(filename, "",
-                Writer.INDEX_EXTENSION));
+                INDEX_EXTENSION));
             try {
             assert dir.fileExists(IndexFileNames.segmentFileName(filename, "",
-                Writer.INDEX_EXTENSION));
+                INDEX_EXTENSION));
             } catch (IOException e) {
               // don't throw checked exception - dir is only used in assert 
               throw new RuntimeException(e);
@@ -85,10 +84,10 @@ public class SepDocValuesConsumer extends DocValuesWriterBase {
           case FIXED_INTS_64:
           case FIXED_INTS_8:
             files.add(IndexFileNames.segmentFileName(filename, "",
-                Writer.DATA_EXTENSION));
+                DATA_EXTENSION));
           try {
             assert dir.fileExists(IndexFileNames.segmentFileName(filename, "",
-                Writer.DATA_EXTENSION));
+                DATA_EXTENSION));
           } catch (IOException e) {
             // don't throw checked exception - dir is only used in assert
             throw new RuntimeException(e);
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesProducer.java b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesProducer.java
index c752825..6cfb2f6 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesProducer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepDocValuesProducer.java
@@ -22,7 +22,7 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.TreeMap;
 
-import org.apache.lucene.codecs.DocValuesReaderBase;
+import org.apache.lucene.codecs.lucene40.values.DocValuesReaderBase;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.util.IOUtils;
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestDocValues.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestDocValues.java
deleted file mode 100644
index c72a1e2..0000000
--- a/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestDocValues.java
+++ /dev/null
@@ -1,483 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Comparator;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.codecs.DocValuesConsumer;
-import org.apache.lucene.codecs.lucene40.values.Bytes;
-import org.apache.lucene.codecs.lucene40.values.Floats;
-import org.apache.lucene.codecs.lucene40.values.Ints;
-import org.apache.lucene.index.DocValues.SortedSource;
-import org.apache.lucene.index.DocValues.Source;
-import org.apache.lucene.index.DocValues.Type;
-import org.apache.lucene.index.DocValues;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.index.IndexableFieldType;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Counter;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.lucene.util._TestUtil;
-
-// TODO: some of this should be under lucene40 codec tests? is talking to codec directly?f
-public class TestDocValues extends LuceneTestCase {
-  private static final Comparator<BytesRef> COMP = BytesRef.getUTF8SortedAsUnicodeComparator();
-  // TODO -- for sorted test, do our own Sort of the
-  // values and verify it's identical
-
-  public void testBytesStraight() throws IOException {
-    runTestBytes(Bytes.Mode.STRAIGHT, true);
-    runTestBytes(Bytes.Mode.STRAIGHT, false);
-  }
-
-  public void testBytesDeref() throws IOException {
-    runTestBytes(Bytes.Mode.DEREF, true);
-    runTestBytes(Bytes.Mode.DEREF, false);
-  }
-  
-  public void testBytesSorted() throws IOException {
-    runTestBytes(Bytes.Mode.SORTED, true);
-    runTestBytes(Bytes.Mode.SORTED, false);
-  }
-
-  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)
-      throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    valueHolder.comp = COMP;
-    final BytesRef bytesRef = new BytesRef();
-
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Bytes.getWriter(dir, "test", mode, fixedSize, COMP, trackBytes, newIOContext(random),
-        random.nextBoolean());
-    int maxDoc = 220;
-    final String[] values = new String[maxDoc];
-    final int fixedLength = 1 + atLeast(50);
-    for (int i = 0; i < 100; i++) {
-      final String s;
-      if (i > 0 && random.nextInt(5) <= 2) {
-        // use prior value
-        s = values[2 * random.nextInt(i)];
-      } else {
-        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));
-      }
-      values[2 * i] = s;
-
-      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);
-      valueHolder.bytes = bytesRef;
-      w.add(2 * i, valueHolder);
-    }
-    w.finish(maxDoc);
-    assertEquals(0, trackBytes.get());
-
-    DocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc, COMP, newIOContext(random));
-
-    // Verify we can load source twice:
-    for (int iter = 0; iter < 2; iter++) {
-      Source s;
-      DocValues.SortedSource ss;
-      if (mode == Bytes.Mode.SORTED) {
-        // default is unicode so we can simply pass null here
-        s = ss = getSortedSource(r);  
-      } else {
-        s = getSource(r);
-        ss = null;
-      }
-      for (int i = 0; i < 100; i++) {
-        final int idx = 2 * i;
-        assertNotNull("doc " + idx + "; value=" + values[idx], s.getBytes(idx,
-            bytesRef));
-        assertEquals("doc " + idx, values[idx], s.getBytes(idx, bytesRef)
-            .utf8ToString());
-        if (ss != null) {
-          assertEquals("doc " + idx, values[idx], ss.getByOrd(ss.ord(idx),
-              bytesRef).utf8ToString());
-         int ord = ss
-              .getByValue(new BytesRef(values[idx]), new BytesRef());
-          assertTrue(ord >= 0);
-          assertEquals(ss.ord(idx), ord);
-        }
-      }
-
-      // Lookup random strings:
-      if (mode == Bytes.Mode.SORTED) {
-        final int valueCount = ss.getValueCount();
-        for (int i = 0; i < 1000; i++) {
-          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));
-          int ord = ss.getByValue(bytesValue, new BytesRef());
-          if (ord >= 0) {
-            assertTrue(bytesValue
-                .bytesEquals(ss.getByOrd(ord, bytesRef)));
-            int count = 0;
-            for (int k = 0; k < 100; k++) {
-              if (bytesValue.utf8ToString().equals(values[2 * k])) {
-                assertEquals(ss.ord(2 * k), ord);
-                count++;
-              }
-            }
-            assertTrue(count > 0);
-          } else {
-            assert ord < 0;
-            int insertIndex = (-ord)-1;
-            if (insertIndex == 0) {
-              final BytesRef firstRef = ss.getByOrd(1, bytesRef);
-              // random string was before our first
-              assertTrue(firstRef.compareTo(bytesValue) > 0);
-            } else if (insertIndex == valueCount) {
-              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);
-              // random string was after our last
-              assertTrue(lastRef.compareTo(bytesValue) < 0);
-            } else {
-              // TODO: I don't think this actually needs a deep copy?
-              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));
-              BytesRef after = ss.getByOrd(insertIndex, bytesRef);
-              assertTrue(COMP.compare(before, bytesValue) < 0);
-              assertTrue(COMP.compare(bytesValue, after) < 0);
-            }
-          }
-        }
-      }
-    }
-
-
-    r.close();
-    dir.close();
-  }
-
-  public void testVariableIntsLimits() throws IOException {
-    long[][] minMax = new long[][] { { Long.MIN_VALUE, Long.MAX_VALUE },
-        { Long.MIN_VALUE + 1, 1 }, { -1, Long.MAX_VALUE },
-        { Long.MIN_VALUE, -1 }, { 1, Long.MAX_VALUE },
-        { -1, Long.MAX_VALUE - 1 }, { Long.MIN_VALUE + 2, 1 }, };
-    Type[] expectedTypes = new Type[] { Type.FIXED_INTS_64,
-        Type.FIXED_INTS_64, Type.FIXED_INTS_64,
-        Type.FIXED_INTS_64, Type.VAR_INTS, Type.VAR_INTS,
-        Type.VAR_INTS, };
-    DocValueHolder valueHolder = new DocValueHolder();
-    for (int i = 0; i < minMax.length; i++) {
-      Directory dir = newDirectory();
-      final Counter trackBytes = Counter.newCounter();
-      DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.VAR_INTS, newIOContext(random));
-      valueHolder.numberValue = minMax[i][0];
-      w.add(0, valueHolder);
-      valueHolder.numberValue = minMax[i][1];
-      w.add(1, valueHolder);
-      w.finish(2);
-      assertEquals(0, trackBytes.get());
-      DocValues r = Ints.getValues(dir, "test", 2,  Type.VAR_INTS, newIOContext(random));
-      Source source = getSource(r);
-      assertEquals(i + " with min: " + minMax[i][0] + " max: " + minMax[i][1],
-          expectedTypes[i], source.type());
-      assertEquals(minMax[i][0], source.getInt(0));
-      assertEquals(minMax[i][1], source.getInt(1));
-
-      r.close();
-      dir.close();
-    }
-  }
-  
-  public void testVInts() throws IOException {
-    testInts(Type.VAR_INTS, 63);
-  }
-  
-  public void testFixedInts() throws IOException {
-    testInts(Type.FIXED_INTS_64, 63);
-    testInts(Type.FIXED_INTS_32, 31);
-    testInts(Type.FIXED_INTS_16, 15);
-    testInts(Type.FIXED_INTS_8, 7);
-
-  }
-  
-  public void testGetInt8Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    byte[] sourceArray = new byte[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_8, newIOContext(random));
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = (long) sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_8, newIOContext(random));
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    byte[] loaded = ((byte[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
-    }
-    r.close();
-    dir.close();
-  }
-  
-  public void testGetInt16Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    short[] sourceArray = new short[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_16, newIOContext(random));
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = (long) sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_16, newIOContext(random));
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    short[] loaded = ((short[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
-    }
-    r.close();
-    dir.close();
-  }
-  
-  public void testGetInt64Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    long[] sourceArray = new long[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_64, newIOContext(random));
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_64, newIOContext(random));
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    long[] loaded = ((long[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
-    }
-    r.close();
-    dir.close();
-  }
-  
-  public void testGetInt32Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    int[] sourceArray = new int[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_32, newIOContext(random));
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = (long) sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_32, newIOContext(random));
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    int[] loaded = ((int[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
-    }
-    r.close();
-    dir.close();
-  }
-  
-  public void testGetFloat32Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    float[] sourceArray = new float[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), Type.FLOAT_32);
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Floats.getValues(dir, "test", 3, newIOContext(random), Type.FLOAT_32);
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    float[] loaded = ((float[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i], 0.0f);
-    }
-    r.close();
-    dir.close();
-  }
-  
-  public void testGetFloat64Array() throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    double[] sourceArray = new double[] {1,2,3};
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), Type.FLOAT_64);
-    for (int i = 0; i < sourceArray.length; i++) {
-      valueHolder.numberValue = sourceArray[i];
-      w.add(i, valueHolder);
-    }
-    w.finish(sourceArray.length);
-    DocValues r = Floats.getValues(dir, "test", 3, newIOContext(random), Type.FLOAT_64);
-    Source source = r.getSource();
-    assertTrue(source.hasArray());
-    double[] loaded = ((double[])source.getArray());
-    assertEquals(loaded.length, sourceArray.length);
-    for (int i = 0; i < loaded.length; i++) {
-      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i], 0.0d);
-    }
-    r.close();
-    dir.close();
-  }
-
-  private void testInts(Type type, int maxBit) throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    long maxV = 1;
-    final int NUM_VALUES = 333 + random.nextInt(333);
-    final long[] values = new long[NUM_VALUES];
-    for (int rx = 1; rx < maxBit; rx++, maxV *= 2) {
-      Directory dir = newDirectory();
-      final Counter trackBytes = Counter.newCounter();
-      DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, type, newIOContext(random));
-      for (int i = 0; i < NUM_VALUES; i++) {
-        final long v = random.nextLong() % (1 + maxV);
-        valueHolder.numberValue = values[i] = v;
-        w.add(i, valueHolder);
-      }
-      final int additionalDocs = 1 + random.nextInt(9);
-      w.finish(NUM_VALUES + additionalDocs);
-      assertEquals(0, trackBytes.get());
-
-      DocValues r = Ints.getValues(dir, "test", NUM_VALUES + additionalDocs, type, newIOContext(random));
-      for (int iter = 0; iter < 2; iter++) {
-        Source s = getSource(r);
-        assertEquals(type, s.type());
-        for (int i = 0; i < NUM_VALUES; i++) {
-          final long v = s.getInt(i);
-          assertEquals("index " + i, values[i], v);
-        }
-      }
-
-      r.close();
-      dir.close();
-    }
-  }
-
-  public void testFloats4() throws IOException {
-    runTestFloats(Type.FLOAT_32);
-  }
-
-  private void runTestFloats(Type type) throws IOException {
-    DocValueHolder valueHolder = new DocValueHolder();
-    Directory dir = newDirectory();
-    final Counter trackBytes = Counter.newCounter();
-    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), type);
-    final int NUM_VALUES = 777 + random.nextInt(777);
-    final double[] values = new double[NUM_VALUES];
-    for (int i = 0; i < NUM_VALUES; i++) {
-      final double v = type == Type.FLOAT_32 ? random.nextFloat() : random
-          .nextDouble();
-      valueHolder.numberValue = values[i] = v;
-      w.add(i, valueHolder);
-    }
-    final int additionalValues = 1 + random.nextInt(10);
-    w.finish(NUM_VALUES + additionalValues);
-    assertEquals(0, trackBytes.get());
-
-    DocValues r = Floats.getValues(dir, "test", NUM_VALUES + additionalValues, newIOContext(random), type);
-    for (int iter = 0; iter < 2; iter++) {
-      Source s = getSource(r);
-      for (int i = 0; i < NUM_VALUES; i++) {
-        assertEquals("" + i, values[i], s.getFloat(i), 0.0f);
-      }
-    }
-    r.close();
-    dir.close();
-  }
-
-  public void testFloats8() throws IOException {
-    runTestFloats(Type.FLOAT_64);
-  }
-  
-
-  private Source getSource(DocValues values) throws IOException {
-    // getSource uses cache internally
-    switch(random.nextInt(5)) {
-    case 3:
-      return values.load();
-    case 2:
-      return values.getDirectSource();
-    case 1:
-      return values.getSource();
-    default:
-      return values.getSource();
-    }
-  }
-  
-  private SortedSource getSortedSource(DocValues values) throws IOException {
-    return getSource(values).asSortedSource();
-  }
-  
-  public static class DocValueHolder implements IndexableField {
-    BytesRef bytes;
-    Number numberValue;
-    Comparator<BytesRef> comp;
-
-    @Override
-    public TokenStream tokenStream(Analyzer a) {
-      return null;
-    }
-
-    @Override
-    public float boost() {
-      return 0.0f;
-    }
-
-    @Override
-    public String name() {
-      return "test";
-    }
-
-    @Override
-    public BytesRef binaryValue() {
-      return bytes;
-    }
-
-    @Override
-    public Number numericValue() {
-      return numberValue;
-    }
-
-    @Override
-    public String stringValue() {
-      return null;
-    }
-
-    @Override
-    public Reader readerValue() {
-      return null;
-    }
-
-    @Override
-    public IndexableFieldType fieldType() {
-      return null;
-    }
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues.java
new file mode 100644
index 0000000..5457483
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/codecs/lucene40/values/TestDocValues.java
@@ -0,0 +1,483 @@
+package org.apache.lucene.codecs.lucene40.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Comparator;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.codecs.DocValuesConsumer;
+import org.apache.lucene.codecs.lucene40.values.Bytes;
+import org.apache.lucene.codecs.lucene40.values.Floats;
+import org.apache.lucene.codecs.lucene40.values.Ints;
+import org.apache.lucene.index.DocValues.SortedSource;
+import org.apache.lucene.index.DocValues.Source;
+import org.apache.lucene.index.DocValues.Type;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.index.IndexableFieldType;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.Counter;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.UnicodeUtil;
+import org.apache.lucene.util._TestUtil;
+
+// TODO: some of this should be under lucene40 codec tests? is talking to codec directly?f
+public class TestDocValues extends LuceneTestCase {
+  private static final Comparator<BytesRef> COMP = BytesRef.getUTF8SortedAsUnicodeComparator();
+  // TODO -- for sorted test, do our own Sort of the
+  // values and verify it's identical
+
+  public void testBytesStraight() throws IOException {
+    runTestBytes(Bytes.Mode.STRAIGHT, true);
+    runTestBytes(Bytes.Mode.STRAIGHT, false);
+  }
+
+  public void testBytesDeref() throws IOException {
+    runTestBytes(Bytes.Mode.DEREF, true);
+    runTestBytes(Bytes.Mode.DEREF, false);
+  }
+  
+  public void testBytesSorted() throws IOException {
+    runTestBytes(Bytes.Mode.SORTED, true);
+    runTestBytes(Bytes.Mode.SORTED, false);
+  }
+
+  public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)
+      throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    valueHolder.comp = COMP;
+    final BytesRef bytesRef = new BytesRef();
+
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Bytes.getWriter(dir, "test", mode, fixedSize, COMP, trackBytes, newIOContext(random),
+        random.nextBoolean());
+    int maxDoc = 220;
+    final String[] values = new String[maxDoc];
+    final int fixedLength = 1 + atLeast(50);
+    for (int i = 0; i < 100; i++) {
+      final String s;
+      if (i > 0 && random.nextInt(5) <= 2) {
+        // use prior value
+        s = values[2 * random.nextInt(i)];
+      } else {
+        s = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39));
+      }
+      values[2 * i] = s;
+
+      UnicodeUtil.UTF16toUTF8(s, 0, s.length(), bytesRef);
+      valueHolder.bytes = bytesRef;
+      w.add(2 * i, valueHolder);
+    }
+    w.finish(maxDoc);
+    assertEquals(0, trackBytes.get());
+
+    DocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc, COMP, newIOContext(random));
+
+    // Verify we can load source twice:
+    for (int iter = 0; iter < 2; iter++) {
+      Source s;
+      DocValues.SortedSource ss;
+      if (mode == Bytes.Mode.SORTED) {
+        // default is unicode so we can simply pass null here
+        s = ss = getSortedSource(r);  
+      } else {
+        s = getSource(r);
+        ss = null;
+      }
+      for (int i = 0; i < 100; i++) {
+        final int idx = 2 * i;
+        assertNotNull("doc " + idx + "; value=" + values[idx], s.getBytes(idx,
+            bytesRef));
+        assertEquals("doc " + idx, values[idx], s.getBytes(idx, bytesRef)
+            .utf8ToString());
+        if (ss != null) {
+          assertEquals("doc " + idx, values[idx], ss.getByOrd(ss.ord(idx),
+              bytesRef).utf8ToString());
+         int ord = ss
+              .getByValue(new BytesRef(values[idx]), new BytesRef());
+          assertTrue(ord >= 0);
+          assertEquals(ss.ord(idx), ord);
+        }
+      }
+
+      // Lookup random strings:
+      if (mode == Bytes.Mode.SORTED) {
+        final int valueCount = ss.getValueCount();
+        for (int i = 0; i < 1000; i++) {
+          BytesRef bytesValue = new BytesRef(_TestUtil.randomFixedByteLengthUnicodeString(random, fixedSize? fixedLength : 1 + random.nextInt(39)));
+          int ord = ss.getByValue(bytesValue, new BytesRef());
+          if (ord >= 0) {
+            assertTrue(bytesValue
+                .bytesEquals(ss.getByOrd(ord, bytesRef)));
+            int count = 0;
+            for (int k = 0; k < 100; k++) {
+              if (bytesValue.utf8ToString().equals(values[2 * k])) {
+                assertEquals(ss.ord(2 * k), ord);
+                count++;
+              }
+            }
+            assertTrue(count > 0);
+          } else {
+            assert ord < 0;
+            int insertIndex = (-ord)-1;
+            if (insertIndex == 0) {
+              final BytesRef firstRef = ss.getByOrd(1, bytesRef);
+              // random string was before our first
+              assertTrue(firstRef.compareTo(bytesValue) > 0);
+            } else if (insertIndex == valueCount) {
+              final BytesRef lastRef = ss.getByOrd(valueCount-1, bytesRef);
+              // random string was after our last
+              assertTrue(lastRef.compareTo(bytesValue) < 0);
+            } else {
+              // TODO: I don't think this actually needs a deep copy?
+              final BytesRef before = BytesRef.deepCopyOf(ss.getByOrd(insertIndex-1, bytesRef));
+              BytesRef after = ss.getByOrd(insertIndex, bytesRef);
+              assertTrue(COMP.compare(before, bytesValue) < 0);
+              assertTrue(COMP.compare(bytesValue, after) < 0);
+            }
+          }
+        }
+      }
+    }
+
+
+    r.close();
+    dir.close();
+  }
+
+  public void testVariableIntsLimits() throws IOException {
+    long[][] minMax = new long[][] { { Long.MIN_VALUE, Long.MAX_VALUE },
+        { Long.MIN_VALUE + 1, 1 }, { -1, Long.MAX_VALUE },
+        { Long.MIN_VALUE, -1 }, { 1, Long.MAX_VALUE },
+        { -1, Long.MAX_VALUE - 1 }, { Long.MIN_VALUE + 2, 1 }, };
+    Type[] expectedTypes = new Type[] { Type.FIXED_INTS_64,
+        Type.FIXED_INTS_64, Type.FIXED_INTS_64,
+        Type.FIXED_INTS_64, Type.VAR_INTS, Type.VAR_INTS,
+        Type.VAR_INTS, };
+    DocValueHolder valueHolder = new DocValueHolder();
+    for (int i = 0; i < minMax.length; i++) {
+      Directory dir = newDirectory();
+      final Counter trackBytes = Counter.newCounter();
+      DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.VAR_INTS, newIOContext(random));
+      valueHolder.numberValue = minMax[i][0];
+      w.add(0, valueHolder);
+      valueHolder.numberValue = minMax[i][1];
+      w.add(1, valueHolder);
+      w.finish(2);
+      assertEquals(0, trackBytes.get());
+      DocValues r = Ints.getValues(dir, "test", 2,  Type.VAR_INTS, newIOContext(random));
+      Source source = getSource(r);
+      assertEquals(i + " with min: " + minMax[i][0] + " max: " + minMax[i][1],
+          expectedTypes[i], source.type());
+      assertEquals(minMax[i][0], source.getInt(0));
+      assertEquals(minMax[i][1], source.getInt(1));
+
+      r.close();
+      dir.close();
+    }
+  }
+  
+  public void testVInts() throws IOException {
+    testInts(Type.VAR_INTS, 63);
+  }
+  
+  public void testFixedInts() throws IOException {
+    testInts(Type.FIXED_INTS_64, 63);
+    testInts(Type.FIXED_INTS_32, 31);
+    testInts(Type.FIXED_INTS_16, 15);
+    testInts(Type.FIXED_INTS_8, 7);
+
+  }
+  
+  public void testGetInt8Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    byte[] sourceArray = new byte[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_8, newIOContext(random));
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = (long) sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_8, newIOContext(random));
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    byte[] loaded = ((byte[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
+    }
+    r.close();
+    dir.close();
+  }
+  
+  public void testGetInt16Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    short[] sourceArray = new short[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_16, newIOContext(random));
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = (long) sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_16, newIOContext(random));
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    short[] loaded = ((short[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
+    }
+    r.close();
+    dir.close();
+  }
+  
+  public void testGetInt64Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    long[] sourceArray = new long[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_64, newIOContext(random));
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_64, newIOContext(random));
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    long[] loaded = ((long[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
+    }
+    r.close();
+    dir.close();
+  }
+  
+  public void testGetInt32Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    int[] sourceArray = new int[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, Type.FIXED_INTS_32, newIOContext(random));
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = (long) sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Ints.getValues(dir, "test", sourceArray.length, Type.FIXED_INTS_32, newIOContext(random));
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    int[] loaded = ((int[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i]);
+    }
+    r.close();
+    dir.close();
+  }
+  
+  public void testGetFloat32Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    float[] sourceArray = new float[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), Type.FLOAT_32);
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Floats.getValues(dir, "test", 3, newIOContext(random), Type.FLOAT_32);
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    float[] loaded = ((float[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i], 0.0f);
+    }
+    r.close();
+    dir.close();
+  }
+  
+  public void testGetFloat64Array() throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    double[] sourceArray = new double[] {1,2,3};
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), Type.FLOAT_64);
+    for (int i = 0; i < sourceArray.length; i++) {
+      valueHolder.numberValue = sourceArray[i];
+      w.add(i, valueHolder);
+    }
+    w.finish(sourceArray.length);
+    DocValues r = Floats.getValues(dir, "test", 3, newIOContext(random), Type.FLOAT_64);
+    Source source = r.getSource();
+    assertTrue(source.hasArray());
+    double[] loaded = ((double[])source.getArray());
+    assertEquals(loaded.length, sourceArray.length);
+    for (int i = 0; i < loaded.length; i++) {
+      assertEquals("value didn't match at index " + i, sourceArray[i], loaded[i], 0.0d);
+    }
+    r.close();
+    dir.close();
+  }
+
+  private void testInts(Type type, int maxBit) throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    long maxV = 1;
+    final int NUM_VALUES = 333 + random.nextInt(333);
+    final long[] values = new long[NUM_VALUES];
+    for (int rx = 1; rx < maxBit; rx++, maxV *= 2) {
+      Directory dir = newDirectory();
+      final Counter trackBytes = Counter.newCounter();
+      DocValuesConsumer w = Ints.getWriter(dir, "test", trackBytes, type, newIOContext(random));
+      for (int i = 0; i < NUM_VALUES; i++) {
+        final long v = random.nextLong() % (1 + maxV);
+        valueHolder.numberValue = values[i] = v;
+        w.add(i, valueHolder);
+      }
+      final int additionalDocs = 1 + random.nextInt(9);
+      w.finish(NUM_VALUES + additionalDocs);
+      assertEquals(0, trackBytes.get());
+
+      DocValues r = Ints.getValues(dir, "test", NUM_VALUES + additionalDocs, type, newIOContext(random));
+      for (int iter = 0; iter < 2; iter++) {
+        Source s = getSource(r);
+        assertEquals(type, s.type());
+        for (int i = 0; i < NUM_VALUES; i++) {
+          final long v = s.getInt(i);
+          assertEquals("index " + i, values[i], v);
+        }
+      }
+
+      r.close();
+      dir.close();
+    }
+  }
+
+  public void testFloats4() throws IOException {
+    runTestFloats(Type.FLOAT_32);
+  }
+
+  private void runTestFloats(Type type) throws IOException {
+    DocValueHolder valueHolder = new DocValueHolder();
+    Directory dir = newDirectory();
+    final Counter trackBytes = Counter.newCounter();
+    DocValuesConsumer w = Floats.getWriter(dir, "test", trackBytes, newIOContext(random), type);
+    final int NUM_VALUES = 777 + random.nextInt(777);
+    final double[] values = new double[NUM_VALUES];
+    for (int i = 0; i < NUM_VALUES; i++) {
+      final double v = type == Type.FLOAT_32 ? random.nextFloat() : random
+          .nextDouble();
+      valueHolder.numberValue = values[i] = v;
+      w.add(i, valueHolder);
+    }
+    final int additionalValues = 1 + random.nextInt(10);
+    w.finish(NUM_VALUES + additionalValues);
+    assertEquals(0, trackBytes.get());
+
+    DocValues r = Floats.getValues(dir, "test", NUM_VALUES + additionalValues, newIOContext(random), type);
+    for (int iter = 0; iter < 2; iter++) {
+      Source s = getSource(r);
+      for (int i = 0; i < NUM_VALUES; i++) {
+        assertEquals("" + i, values[i], s.getFloat(i), 0.0f);
+      }
+    }
+    r.close();
+    dir.close();
+  }
+
+  public void testFloats8() throws IOException {
+    runTestFloats(Type.FLOAT_64);
+  }
+  
+
+  private Source getSource(DocValues values) throws IOException {
+    // getSource uses cache internally
+    switch(random.nextInt(5)) {
+    case 3:
+      return values.load();
+    case 2:
+      return values.getDirectSource();
+    case 1:
+      return values.getSource();
+    default:
+      return values.getSource();
+    }
+  }
+  
+  private SortedSource getSortedSource(DocValues values) throws IOException {
+    return getSource(values).asSortedSource();
+  }
+  
+  public static class DocValueHolder implements IndexableField {
+    BytesRef bytes;
+    Number numberValue;
+    Comparator<BytesRef> comp;
+
+    @Override
+    public TokenStream tokenStream(Analyzer a) {
+      return null;
+    }
+
+    @Override
+    public float boost() {
+      return 0.0f;
+    }
+
+    @Override
+    public String name() {
+      return "test";
+    }
+
+    @Override
+    public BytesRef binaryValue() {
+      return bytes;
+    }
+
+    @Override
+    public Number numericValue() {
+      return numberValue;
+    }
+
+    @Override
+    public String stringValue() {
+      return null;
+    }
+
+    @Override
+    public Reader readerValue() {
+      return null;
+    }
+
+    @Override
+    public IndexableFieldType fieldType() {
+      return null;
+    }
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java b/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
index b88405c..8223ad6 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
@@ -23,13 +23,13 @@ import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.lucene40.values.BytesRefUtils;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.DocValuesField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.DocValues.Source;
 import org.apache.lucene.index.DocValues.Type;
+import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -135,13 +135,17 @@ public class TestTypePromotion extends LuceneTestCase {
           value = bytes.bytes[bytes.offset];
           break;
         case 2:
-          value = BytesRefUtils.asShort(bytes);
+          value = ((bytes.bytes[bytes.offset] & 0xFF) << 8) | (bytes.bytes[bytes.offset+1] & 0xFF);
           break;
         case 4:
-          value = BytesRefUtils.asInt(bytes);
+          value = ((bytes.bytes[bytes.offset] & 0xFF) << 24)  | ((bytes.bytes[bytes.offset+1] & 0xFF) << 16)
+                | ((bytes.bytes[bytes.offset+2] & 0xFF) << 8) | (bytes.bytes[bytes.offset+3] & 0xFF);
           break;
         case 8:
-          value = BytesRefUtils.asLong(bytes);
+          value =  (((long)(bytes.bytes[bytes.offset] & 0xff) << 56) | ((long)(bytes.bytes[bytes.offset+1] & 0xff) << 48) |
+                  ((long)(bytes.bytes[bytes.offset+2] & 0xff) << 40) | ((long)(bytes.bytes[bytes.offset+3] & 0xff) << 32) |
+                  ((long)(bytes.bytes[bytes.offset+4] & 0xff) << 24) | ((long)(bytes.bytes[bytes.offset+5] & 0xff) << 16) |
+                  ((long)(bytes.bytes[bytes.offset+6] & 0xff) <<  8) | ((long)(bytes.bytes[bytes.offset+7] & 0xff)));
           break;
           
         default:
@@ -243,20 +247,27 @@ public class TestTypePromotion extends LuceneTestCase {
       case BYTES_FIXED_SORTED:
       case BYTES_FIXED_STRAIGHT:
         values[i] = random.nextLong();
-        BytesRefUtils.copyLong(ref, values[i]);
-        valField.setValue(ref);
+        byte bytes[] = new byte[8];
+        ByteArrayDataOutput out = new ByteArrayDataOutput(bytes, 0, 8);
+        out.writeLong(values[i]);
+        valField.setValue(new BytesRef(bytes));
         break;
       case BYTES_VAR_DEREF:
       case BYTES_VAR_SORTED:
       case BYTES_VAR_STRAIGHT:
+        byte lbytes[] = new byte[8];
+        ByteArrayDataOutput lout = new ByteArrayDataOutput(lbytes, 0, 8);
+        final int len;
         if (random.nextBoolean()) {
-          BytesRefUtils.copyInt(ref, random.nextInt());
-          values[i] = BytesRefUtils.asInt(ref);
+          values[i] = random.nextInt();
+          lout.writeInt((int)values[i]);
+          len = 4;
         } else {
-          BytesRefUtils.copyLong(ref, random.nextLong());
-          values[i] = BytesRefUtils.asLong(ref);
+          values[i] = random.nextLong();
+          lout.writeLong(values[i]);
+          len = 8;
         }
-        valField.setValue(ref);
+        valField.setValue(new BytesRef(lbytes, 0, len));
         break;
 
       default:

