GitDiffStart: a53c78d7ef1ba4ce689545ef8d302c1677cde396 | Sat Mar 29 01:01:05 2014 +0000
diff --git a/dev-tools/idea/solr/core/src/test/solr-core-tests.iml b/dev-tools/idea/solr/core/src/test/solr-core-tests.iml
index 0ece1b5..0561965 100644
--- a/dev-tools/idea/solr/core/src/test/solr-core-tests.iml
+++ b/dev-tools/idea/solr/core/src/test/solr-core-tests.iml
@@ -15,6 +15,7 @@
     <orderEntry type="library" scope="TEST" name="Solrj library" level="project" />
     <orderEntry type="library" scope="TEST" name="Solr example library" level="project" />
     <orderEntry type="library" scope="TEST" name="Solr test framework library" level="project" />
+    <orderEntry type="library" scope="TEST" name="ICU library" level="project" />
     <orderEntry type="module" scope="TEST" module-name="lucene-test-framework" />
     <orderEntry type="module" scope="TEST" module-name="solr-test-framework" />
     <orderEntry type="module" scope="TEST" module-name="solr-core-test-files" />
@@ -29,5 +30,7 @@
     <orderEntry type="module" scope="TEST" module-name="misc" />
     <orderEntry type="module" scope="TEST" module-name="join" />
     <orderEntry type="module" scope="TEST" module-name="expressions" />
+    <orderEntry type="module" scope="TEST" module-name="analysis-icu" />
+    <orderEntry type="module" scope="TEST" module-name="analysis-extras" />
   </component>
 </module>
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index c3da2a1..e237bc4 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -351,6 +351,9 @@ Bug Fixes
 * SOLR-5906: Collection create API ignores property.instanceDir parameter.
   (Varun Thacker, shalin)
 
+* SOLR-5920: Distributed sort on DateField, BoolField and BCD{Int,Long,Str}Field
+  returns string cast exception (Eric Bus, AJ Lemke, hossman, Steve Rowe)
+
 Other Changes
 ---------------------
 
diff --git a/solr/common-build.xml b/solr/common-build.xml
index 001488b..f2b168d 100644
--- a/solr/common-build.xml
+++ b/solr/common-build.xml
@@ -445,6 +445,12 @@
   </macrodef>
 
   <!-- Solr contrib targets -->
+  <target name="-compile-analysis-extras">
+    <ant dir="${common-solr.dir}/contrib/analysis-extras" target="compile" inheritAll="false">
+      <propertyset refid="uptodate.and.compiled.properties"/>
+    </ant>
+  </target>
+
   <target name="compile-contrib" description="Compile contrib modules">
   	<contrib-crawl target="compile-core"/>
   </target>
diff --git a/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java b/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
index bed79e6..b798bc9 100644
--- a/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
+++ b/solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
@@ -43,7 +43,6 @@ import org.apache.lucene.util.Version;
 import org.apache.lucene.analysis.util.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.util.Base64;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
@@ -303,20 +302,11 @@ public class ICUCollationField extends FieldType {
 
   @Override
   public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final BytesRef val = (BytesRef)value;
-    return Base64.byteArrayToBase64(val.bytes, val.offset, val.length);
+    return marshalBase64SortValue(value);
   }
 
   @Override
   public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final String val = (String)value;
-    final byte[] bytes = Base64.base64ToByteArray(val);
-    return new BytesRef(bytes);
+    return unmarshalBase64SortValue(value);
   }
 }
diff --git a/solr/core/build.xml b/solr/core/build.xml
index 90c4bc4..3d8d11f 100644
--- a/solr/core/build.xml
+++ b/solr/core/build.xml
@@ -32,9 +32,14 @@
 
   <target name="compile-core" depends="compile-solrj,common-solr.compile-core"/>
 
+  <target name="compile-test" depends="jar-analyzers-icu,-compile-analysis-extras,common-solr.compile-test"/>
+
   <path id="test.classpath">
     <path refid="solr.test.base.classpath"/>
     <fileset dir="${test.lib.dir}" includes="*.jar"/>
+    <pathelement location="${analyzers-icu.jar}"/>
+    <pathelement location="${common-solr.dir}/build/contrib/solr-analysis-extras/classes/java"/>
+    <fileset dir="${common-solr.dir}/contrib/analysis-extras/lib" includes="icu4j*.jar"/>
   </path>
 
   <!-- specialized to ONLY depend on solrj -->
diff --git a/solr/core/src/java/org/apache/solr/schema/BCDIntField.java b/solr/core/src/java/org/apache/solr/schema/BCDIntField.java
index 86efdf1..17679b6 100644
--- a/solr/core/src/java/org/apache/solr/schema/BCDIntField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BCDIntField.java
@@ -66,6 +66,16 @@ public class BCDIntField extends PrimitiveFieldType {
   public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
     writer.writeInt(name,toExternal(f));
   }
+
+  @Override
+  public Object marshalSortValue(Object value) {
+    return marshalStringSortValue(value);
+  }
+
+  @Override
+  public Object unmarshalSortValue(Object value) {
+    return unmarshalStringSortValue(value);
+  }
 }
 
 
diff --git a/solr/core/src/java/org/apache/solr/schema/BoolField.java b/solr/core/src/java/org/apache/solr/schema/BoolField.java
index 242de06..07f5089 100644
--- a/solr/core/src/java/org/apache/solr/schema/BoolField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BoolField.java
@@ -151,6 +151,16 @@ public class BoolField extends PrimitiveFieldType {
   public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
     writer.writeBool(name, f.stringValue().charAt(0) == 'T');
   }
+
+  @Override
+  public Object marshalSortValue(Object value) {
+    return marshalStringSortValue(value);
+  }
+
+  @Override
+  public Object unmarshalSortValue(Object value) {
+    return unmarshalStringSortValue(value);
+  }
 }
 
 // TODO - this can be much more efficient - use OpenBitSet or Bits
diff --git a/solr/core/src/java/org/apache/solr/schema/CollationField.java b/solr/core/src/java/org/apache/solr/schema/CollationField.java
index 13f35a8..bf0dc1d 100644
--- a/solr/core/src/java/org/apache/solr/schema/CollationField.java
+++ b/solr/core/src/java/org/apache/solr/schema/CollationField.java
@@ -47,7 +47,6 @@ import org.apache.lucene.util.Version;
 import org.apache.lucene.analysis.util.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.util.Base64;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
@@ -278,20 +277,11 @@ public class CollationField extends FieldType {
 
   @Override
   public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final BytesRef val = (BytesRef)value;
-    return Base64.byteArrayToBase64(val.bytes, val.offset, val.length);
+    return marshalBase64SortValue(value);
   }
 
   @Override
   public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final String val = (String)value;
-    final byte[] bytes = Base64.base64ToByteArray(val);
-    return new BytesRef(bytes);
+    return unmarshalBase64SortValue(value);
   }
 }
diff --git a/solr/core/src/java/org/apache/solr/schema/DateField.java b/solr/core/src/java/org/apache/solr/schema/DateField.java
index faf9c4f..52eac81 100644
--- a/solr/core/src/java/org/apache/solr/schema/DateField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DateField.java
@@ -248,6 +248,16 @@ public class DateField extends PrimitiveFieldType implements DateValueFieldType
   }
 
   @Override
+  public Object marshalSortValue(Object value) {
+    return marshalStringSortValue(value);
+  }
+
+  @Override
+  public Object unmarshalSortValue(Object value) {
+    return unmarshalStringSortValue(value);
+  }
+
+  @Override
   public void write(TextResponseWriter writer, String name, StorableField f) throws IOException {
     writer.writeDate(name, toExternal(f));
   }
diff --git a/solr/core/src/java/org/apache/solr/schema/FieldType.java b/solr/core/src/java/org/apache/solr/schema/FieldType.java
index 4d4ae5a..32c7a63 100644
--- a/solr/core/src/java/org/apache/solr/schema/FieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/FieldType.java
@@ -48,6 +48,7 @@ import org.apache.solr.analysis.SolrAnalyzer;
 import org.apache.solr.analysis.TokenizerChain;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.common.util.Base64;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.response.TextResponseWriter;
@@ -968,4 +969,52 @@ public abstract class FieldType extends FieldProperties {
   public Object unmarshalSortValue(Object value) {
     return value;
   }
+
+  /**
+   * Marshals a string-based field value.
+   */
+  protected static Object marshalStringSortValue(Object value) {
+    if (null == value) {
+      return null;
+    }
+    CharsRef spare = new CharsRef();
+    UnicodeUtil.UTF8toUTF16((BytesRef)value, spare);
+    return spare.toString();
+  }
+
+  /**
+   * Unmarshals a string-based field value.
+   */
+  protected static Object unmarshalStringSortValue(Object value) {
+    if (null == value) {
+      return null;
+    }
+    BytesRef spare = new BytesRef();
+    String stringVal = (String)value;
+    UnicodeUtil.UTF16toUTF8(stringVal, 0, stringVal.length(), spare);
+    return spare;
+  }
+
+  /**
+   * Marshals a binary field value.
+   */
+  protected static Object marshalBase64SortValue(Object value) {
+    if (null == value) {
+      return null;
+    }
+    final BytesRef val = (BytesRef)value;
+    return Base64.byteArrayToBase64(val.bytes, val.offset, val.length);
+  }
+
+  /**
+   * Unmarshals a binary field value.
+   */
+  protected static Object unmarshalBase64SortValue(Object value) {
+    if (null == value) {
+      return null;
+    }
+    final String val = (String)value;
+    final byte[] bytes = Base64.base64ToByteArray(val);
+    return new BytesRef(bytes);
+  }
 }
diff --git a/solr/core/src/java/org/apache/solr/schema/FloatField.java b/solr/core/src/java/org/apache/solr/schema/FloatField.java
index 7e23443..6d80535 100644
--- a/solr/core/src/java/org/apache/solr/schema/FloatField.java
+++ b/solr/core/src/java/org/apache/solr/schema/FloatField.java
@@ -70,7 +70,7 @@ public class FloatField extends PrimitiveFieldType implements FloatValueFieldTyp
   @Override
   public SortField getSortField(SchemaField field,boolean reverse) {
     field.checkSortability();
-    return new SortField(field.name,SortField.Type.FLOAT, reverse);
+    return new SortField(field.name, PARSER, reverse);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/schema/StrField.java b/solr/core/src/java/org/apache/solr/schema/StrField.java
index e39d7e6..9fc4320 100644
--- a/solr/core/src/java/org/apache/solr/schema/StrField.java
+++ b/solr/core/src/java/org/apache/solr/schema/StrField.java
@@ -29,8 +29,6 @@ import org.apache.lucene.index.StorableField;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.UnicodeUtil;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
@@ -86,23 +84,12 @@ public class StrField extends PrimitiveFieldType {
 
   @Override
   public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    CharsRef spare = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, spare);
-    return spare.toString();
+    return marshalStringSortValue(value);
   }
 
   @Override
   public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    BytesRef spare = new BytesRef();
-    String stringVal = (String)value;
-    UnicodeUtil.UTF16toUTF8(stringVal, 0, stringVal.length(), spare);
-    return spare;
+    return unmarshalStringSortValue(value);
   }
 }
 
diff --git a/solr/core/src/java/org/apache/solr/schema/TextField.java b/solr/core/src/java/org/apache/solr/schema/TextField.java
index f0741f5..68c740d 100644
--- a/solr/core/src/java/org/apache/solr/schema/TextField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TextField.java
@@ -23,9 +23,7 @@ import org.apache.lucene.index.StorableField;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.QueryBuilder;
-import org.apache.lucene.util.UnicodeUtil;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
@@ -170,22 +168,11 @@ public class TextField extends FieldType {
 
   @Override
   public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    CharsRef spare = new CharsRef();
-    UnicodeUtil.UTF8toUTF16((BytesRef)value, spare);
-    return spare.toString();
+    return marshalStringSortValue(value);
   }
 
   @Override
   public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    BytesRef spare = new BytesRef();
-    String stringVal = (String)value;
-    UnicodeUtil.UTF16toUTF8(stringVal, 0, stringVal.length(), spare);
-    return spare;
+    return unmarshalStringSortValue(value);
   }
 }
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieDateField.java b/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
index 0a652ef..e92d601 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieDateField.java
@@ -84,6 +84,16 @@ public class TrieDateField extends DateField implements DateValueFieldType {
   }
 
   @Override
+  public Object marshalSortValue(Object value) {
+    return value;
+  }
+
+  @Override
+  public Object unmarshalSortValue(Object value) {
+    return value;
+  }
+
+  @Override
   public ValueSource getValueSource(SchemaField field, QParser parser) {
     return wrappedField.getValueSource(field, parser);
   }
diff --git a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
index f5b711c..53433b0 100644
--- a/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/schema-sorts.xml
@@ -71,6 +71,94 @@ NOTE: Tests expect every field in this schema to be sortable.
     <field name="double_dv_last" type="double_dv_last" />
     <field name="double_dv_first" type="double_dv_first" />
 
+    <field name="date" type="date" />
+    <field name="date_last" type="date_last" />
+    <field name="date_first" type="date_first" />
+    <field name="date_dv" type="date_dv" />
+    <field name="date_dv_last" type="date_dv_last" />
+    <field name="date_dv_first" type="date_dv_first" />
+
+    <field name="uuid" type="uuid" />
+    <field name="uuid_last" type="uuid_last" />
+    <field name="uuid_first" type="uuid_first" />
+    <field name="uuid_dv" type="uuid_dv" />
+    <field name="uuid_dv_last" type="uuid_dv_last" />
+    <field name="uuid_dv_first" type="uuid_dv_first" />
+
+    <field name="currency" type="currency" />
+    <field name="currency_last" type="currency_last" />
+    <field name="currency_first" type="currency_first" />
+
+    <field name="collation_en_primary" type="collation_en_primary" />
+    <field name="collation_en_primary_last" type="collation_en_primary_last" />
+    <field name="collation_en_primary_first" type="collation_en_primary_first" />
+    <field name="collation_en_primary_dv" type="collation_en_primary_dv" />
+    <field name="collation_en_primary_dv_last" type="collation_en_primary_dv_last" />
+    <field name="collation_en_primary_dv_first" type="collation_en_primary_dv_first" />
+
+    <field name="icu_collation_en_primary" type="icu_collation_en_primary" />
+    <field name="icu_collation_en_primary_last" type="icu_collation_en_primary_last" />
+    <field name="icu_collation_en_primary_first" type="icu_collation_en_primary_first" />
+    <field name="icu_collation_en_primary_dv" type="icu_collation_en_primary_dv" />
+    <field name="icu_collation_en_primary_dv_last" type="icu_collation_en_primary_dv_last" />
+    <field name="icu_collation_en_primary_dv_first" type="icu_collation_en_primary_dv_first" />
+
+    <field name="bool" type="bool" />
+    <field name="bool_last" type="bool_last" />
+    <field name="bool_first" type="bool_first" />
+
+    <field name="enum" type="enum" />
+    <field name="enum_last" type="enum_last" />
+    <field name="enum_first" type="enum_first" />
+    <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
+    <!-- <field name="enum_dv" type="enum_dv" />                   -->
+    <!-- <field name="enum_dv_last" type="enum_dv_last" />         -->
+    <!-- <field name="enum_dv_first" type="enum_dv_first" />       -->
+
+    <field name="bcd_int" type="bcd_int" />
+    <field name="bcd_int_last" type="bcd_int_last" />
+    <field name="bcd_int_first" type="bcd_int_first" />
+
+    <field name="bcd_long" type="bcd_long" />
+    <field name="bcd_long_last" type="bcd_long_last" />
+    <field name="bcd_long_first" type="bcd_long_first" />
+
+    <field name="bcd_str" type="bcd_str" />
+    <field name="bcd_str_last" type="bcd_str_last" />
+    <field name="bcd_str_first" type="bcd_str_first" />
+
+    <!-- IntField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <field name="legacy_int" type="legacy_int" />
+
+    <field name="legacy_sortable_int" type="legacy_sortable_int" />
+    <field name="legacy_sortable_int_last" type="legacy_sortable_int_last" />
+    <field name="legacy_sortable_int_first" type="legacy_sortable_int_first" />
+
+    <!-- LongField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <field name="legacy_long" type="legacy_long" />
+
+    <field name="legacy_sortable_long" type="legacy_sortable_long" />
+    <field name="legacy_sortable_long_last" type="legacy_sortable_long_last" />
+    <field name="legacy_sortable_long_first" type="legacy_sortable_long_first" />
+
+    <!-- FloatField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <field name="legacy_float" type="legacy_float" />
+
+    <field name="legacy_sortable_float" type="legacy_sortable_float" />
+    <field name="legacy_sortable_float_last" type="legacy_sortable_float_last" />
+    <field name="legacy_sortable_float_first" type="legacy_sortable_float_first" />
+
+    <!-- DoubleField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <field name="legacy_double" type="legacy_double" />
+
+    <field name="legacy_sortable_double" type="legacy_sortable_double" />
+    <field name="legacy_sortable_double_last" type="legacy_sortable_double_last" />
+    <field name="legacy_sortable_double_first" type="legacy_sortable_double_first" />
+
+    <field name="legacy_date" type="legacy_date" />
+    <field name="legacy_date_last" type="legacy_date_last" />
+    <field name="legacy_date_first" type="legacy_date_first" />
+
     <!-- ensure function sorts don't mistakenly get interpreted as field sorts
          https://issues.apache.org/jira/browse/SOLR-5354?focusedCommentId=13835891&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13835891
     -->
@@ -82,6 +170,16 @@ NOTE: Tests expect every field in this schema to be sortable.
   <copyField source="str" dest="str_dv" />
   <copyField source="str" dest="str_dv_last" />
   <copyField source="str" dest="str_dv_first" />
+  <copyField source="str" dest="collation_en_primary_last" />
+  <copyField source="str" dest="collation_en_primary_first" />
+  <copyField source="str" dest="collation_en_primary_dv" />
+  <copyField source="str" dest="collation_en_primary_dv_last" />
+  <copyField source="str" dest="collation_en_primary_dv_first" />
+  <copyField source="str" dest="icu_collation_en_primary_last" />
+  <copyField source="str" dest="icu_collation_en_primary_first" />
+  <copyField source="str" dest="icu_collation_en_primary_dv" />
+  <copyField source="str" dest="icu_collation_en_primary_dv_last" />
+  <copyField source="str" dest="icu_collation_en_primary_dv_first" />
 
   <copyField source="bin" dest="bin_last" />
   <copyField source="bin" dest="bin_first" />
@@ -94,24 +192,76 @@ NOTE: Tests expect every field in this schema to be sortable.
   <copyField source="int" dest="int_dv" />
   <copyField source="int" dest="int_dv_last" />
   <copyField source="int" dest="int_dv_first" />
+  <copyField source="int" dest="bcd_int" />
+  <copyField source="int" dest="bcd_int_last" />
+  <copyField source="int" dest="bcd_int_first" />
+  <copyField source="int" dest="bcd_str" />
+  <copyField source="int" dest="bcd_str_last" />
+  <copyField source="int" dest="bcd_str_first" />
+  <copyField source="int" dest="legacy_int" />
+  <copyField source="int" dest="legacy_sortable_int" />
+  <copyField source="int" dest="legacy_sortable_int_last" />
+  <copyField source="int" dest="legacy_sortable_int_first" />
 
   <copyField source="long" dest="long_last" />
   <copyField source="long" dest="long_first" />
   <copyField source="long" dest="long_dv" />
   <copyField source="long" dest="long_dv_last" />
   <copyField source="long" dest="long_dv_first" />
+  <copyField source="long" dest="bcd_long" />
+  <copyField source="long" dest="bcd_long_last" />
+  <copyField source="long" dest="bcd_long_first" />
+  <copyField source="long" dest="legacy_long" />
+  <copyField source="long" dest="legacy_sortable_long" />
+  <copyField source="long" dest="legacy_sortable_long_last" />
+  <copyField source="long" dest="legacy_sortable_long_first" />
 
   <copyField source="float" dest="float_last" />
   <copyField source="float" dest="float_first" />
   <copyField source="float" dest="float_dv" />
   <copyField source="float" dest="float_dv_last" />
   <copyField source="float" dest="float_dv_first" />
+  <copyField source="float" dest="legacy_float" />
+  <copyField source="float" dest="legacy_sortable_float" />
+  <copyField source="float" dest="legacy_sortable_float_last" />
+  <copyField source="float" dest="legacy_sortable_float_first" />
 
   <copyField source="double" dest="double_last" />
   <copyField source="double" dest="double_first" />
   <copyField source="double" dest="double_dv" />
   <copyField source="double" dest="double_dv_last" />
   <copyField source="double" dest="double_dv_first" />
+  <copyField source="double" dest="legacy_double" />
+  <copyField source="double" dest="legacy_sortable_double" />
+  <copyField source="double" dest="legacy_sortable_double_last" />
+  <copyField source="double" dest="legacy_sortable_double_first" />
+
+  <copyField source="date" dest="date_last" />
+  <copyField source="date" dest="date_first" />
+  <copyField source="date" dest="date_dv" />
+  <copyField source="date" dest="date_dv_last" />
+  <copyField source="date" dest="date_dv_first" />
+  <copyField source="date" dest="legacy_date_last" />
+  <copyField source="date" dest="legacy_date_first" />
+
+  <copyField source="uuid" dest="uuid_last" />
+  <copyField source="uuid" dest="uuid_first" />
+  <copyField source="uuid" dest="uuid_dv" />
+  <copyField source="uuid" dest="uuid_dv_last" />
+  <copyField source="uuid" dest="uuid_dv_first" />
+
+  <copyField source="currency" dest="currency_last" />
+  <copyField source="currency" dest="currency_first" />
+
+  <copyField source="bool" dest="bool_last" />
+  <copyField source="bool" dest="bool_first" />
+
+  <copyField source="enum" dest="enum_last" />
+  <copyField source="enum" dest="enum_first" />
+  <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
+  <!-- <copyField source="enum" dest="enum_dv" />                -->
+  <!-- <copyField source="enum" dest="enum_dv_last" />           -->
+  <!-- <copyField source="enum" dest="enum_dv_first" />          -->
 
   <types>
 
@@ -157,6 +307,94 @@ NOTE: Tests expect every field in this schema to be sortable.
     <fieldtype name="double_dv_last" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
     <fieldtype name="double_dv_first" class="solr.TrieDoubleField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
 
+    <fieldtype name="date" class="solr.TrieDateField" stored="true" indexed="true" />
+    <fieldtype name="date_last" class="solr.TrieDateField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="date_first" class="solr.TrieDateField" stored="true" indexed="true" sortMissingFirst="true"/>
+    <fieldtype name="date_dv" class="solr.TrieDateField" stored="true" indexed="false" docValues="true"/>
+    <fieldtype name="date_dv_last" class="solr.TrieDateField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+    <fieldtype name="date_dv_first" class="solr.TrieDateField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+    <fieldtype name="uuid" class="solr.UUIDField" stored="true" indexed="true" />
+    <fieldtype name="uuid_last" class="solr.UUIDField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="uuid_first" class="solr.UUIDField" stored="true" indexed="true" sortMissingFirst="true"/>
+    <fieldtype name="uuid_dv" class="solr.UUIDField" stored="true" indexed="false" docValues="true"/>
+    <fieldtype name="uuid_dv_last" class="solr.UUIDField" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+    <fieldtype name="uuid_dv_first" class="solr.UUIDField" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+    <fieldtype name="currency" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider"/>
+    <fieldtype name="currency_last" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider" sortMissingLast="true"/>
+    <fieldtype name="currency_first" class="solr.CurrencyField" stored="true" indexed="true" foo="bar" providerClass="solr.MockExchangeRateProvider" sortMissingFirst="true"/>
+
+    <fieldtype name="collation_en_primary" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" />
+    <fieldtype name="collation_en_primary_last" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="collation_en_primary_first" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="true" sortMissingFirst="true"/>
+    <fieldtype name="collation_en_primary_dv" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true"/>
+    <fieldtype name="collation_en_primary_dv_last" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+    <fieldtype name="collation_en_primary_dv_first" class="solr.CollationField" language="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+    <fieldtype name="icu_collation_en_primary" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" />
+    <fieldtype name="icu_collation_en_primary_last" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="icu_collation_en_primary_first" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="true" sortMissingFirst="true"/>
+    <fieldtype name="icu_collation_en_primary_dv" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true"/>
+    <fieldtype name="icu_collation_en_primary_dv_last" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingLast="true"/>
+    <fieldtype name="icu_collation_en_primary_dv_first" class="solr.ICUCollationField" locale="en" strength="primary" stored="true" indexed="false" docValues="true" sortMissingFirst="true"/>
+
+    <!-- BoolField does not support DocValues - see SOLR-5933 -->
+    <fieldtype name="bool" class="solr.BoolField" stored="true" indexed="true" />
+    <fieldtype name="bool_last" class="solr.BoolField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="bool_first" class="solr.BoolField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <fieldType name="enum" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity"/>
+    <fieldType name="enum_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" sortMissingLast="true"/>
+    <fieldType name="enum_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" sortMissingFirst="true"/>
+    <!-- EnumField incorrectly disallows missing DocValues - see SOLR-5927 -->
+    <!-- <fieldType name="enum_dv" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true"/> -->
+    <!-- <fieldType name="enum_dv_last" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingLast="true"/> -->
+    <!-- <fieldType name="enum_dv_first" class="solr.EnumField" enumsConfig="enumsConfig.xml" enumName="severity" docValues="true" sortMissingFirst="true"/> -->
+
+    <fieldtype name="bcd_int" class="solr.BCDIntField" stored="true" indexed="true" />
+    <fieldtype name="bcd_int_last" class="solr.BCDIntField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="bcd_int_first" class="solr.BCDIntField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <fieldtype name="bcd_long" class="solr.BCDLongField" stored="true" indexed="true" />
+    <fieldtype name="bcd_long_last" class="solr.BCDLongField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="bcd_long_first" class="solr.BCDLongField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <fieldtype name="bcd_str" class="solr.BCDStrField" stored="true" indexed="true" />
+    <fieldtype name="bcd_str_last" class="solr.BCDStrField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="bcd_str_first" class="solr.BCDStrField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <!-- IntField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <fieldtype name="legacy_int" class="solr.IntField" stored="true" indexed="true" />
+
+    <fieldtype name="legacy_sortable_int" class="solr.SortableIntField" stored="true" indexed="true" />
+    <fieldtype name="legacy_sortable_int_last" class="solr.SortableIntField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="legacy_sortable_int_first" class="solr.SortableIntField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <!-- LongField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <fieldtype name="legacy_long" class="solr.LongField" stored="true" indexed="true" />
+
+    <fieldtype name="legacy_sortable_long" class="solr.SortableLongField" stored="true" indexed="true" />
+    <fieldtype name="legacy_sortable_long_last" class="solr.SortableLongField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="legacy_sortable_long_first" class="solr.SortableLongField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <!-- FloatField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <fieldtype name="legacy_float" class="solr.FloatField" stored="true" indexed="true" />
+
+    <fieldtype name="legacy_sortable_float" class="solr.SortableFloatField" stored="true" indexed="true" />
+    <fieldtype name="legacy_sortable_float_last" class="solr.SortableFloatField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="legacy_sortable_float_first" class="solr.SortableFloatField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <!-- DoubleField doesn't support sortMissingFirst or sortMissingLast variants -->
+    <fieldtype name="legacy_double" class="solr.DoubleField" stored="true" indexed="true" />
+
+    <fieldtype name="legacy_sortable_double" class="solr.SortableDoubleField" stored="true" indexed="true" />
+    <fieldtype name="legacy_sortable_double_last" class="solr.SortableDoubleField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="legacy_sortable_double_first" class="solr.SortableDoubleField" stored="true" indexed="true" sortMissingFirst="true"/>
+
+    <fieldtype name="legacy_date" class="solr.DateField" stored="true" indexed="true" />
+    <fieldtype name="legacy_date_last" class="solr.DateField" stored="true" indexed="true" sortMissingLast="true"/>
+    <fieldtype name="legacy_date_first" class="solr.DateField" stored="true" indexed="true" sortMissingFirst="true"/>
   </types>
 
 </schema>
diff --git a/solr/core/src/test/org/apache/solr/CursorPagingTest.java b/solr/core/src/test/org/apache/solr/CursorPagingTest.java
index e291d8c..95137fb 100644
--- a/solr/core/src/test/org/apache/solr/CursorPagingTest.java
+++ b/solr/core/src/test/org/apache/solr/CursorPagingTest.java
@@ -31,18 +31,21 @@ import static org.apache.solr.common.params.CursorMarkParams.CURSOR_MARK_START;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.DateField;
 import org.apache.solr.search.CursorMark; //jdoc
 
 import org.noggit.ObjectBuilder;
 
+import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
-import java.nio.ByteBuffer;
+import java.util.UUID;
 
 import org.junit.BeforeClass;
 import org.junit.After;
@@ -56,6 +59,9 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
   public final static String TEST_SOLRCONFIG_NAME = "solrconfig-deeppaging.xml";
   /** schema.xml file name, shared with other cursor related tests */
   public final static String TEST_SCHEMAXML_NAME = "schema-sorts.xml";
+  /** values from enumConfig.xml */
+  public static final String[] SEVERITY_ENUM_VALUES =
+      { "Not Available", "Low", "Medium", "High", "Critical" };
 
   @BeforeClass
   public static void beforeTests() throws Exception {
@@ -676,7 +682,7 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
     String cursorMark = CURSOR_MARK_START;
     int docsOnThisPage = Integer.MAX_VALUE;
     while (0 < docsOnThisPage) {
-      String json = assertJQ(req(params, 
+      String json = assertJQ(req(params,
                                  CURSOR_MARK_PARAM, cursorMark));
       Map rsp = (Map) ObjectBuilder.fromJSON(json);
       assertTrue("response doesn't contain " + CURSOR_MARK_NEXT + ": " + json,
@@ -893,7 +899,6 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
     if (useField()) {
       doc.addField("str", skewed(randomUsableUnicodeString(),
                                  TestUtil.randomSimpleString(random(), 1, 1)));
-
     }
     if (useField()) {
       int numBytes = (int) skewed(TestUtil.nextInt(random(), 20, 50), 2);
@@ -901,6 +906,23 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
       random().nextBytes(randBytes);
       doc.addField("bin", ByteBuffer.wrap(randBytes));
     }
+    if (useField()) {
+      doc.addField("date", skewed(randomDate(),
+                                  dateWithRandomSecondOn2010_10_31_at_10_31()));
+    }
+    if (useField()) {
+      doc.addField("uuid", UUID.randomUUID().toString());
+    }
+    if (useField()) {
+      doc.addField("currency", skewed("" + (random().nextInt() / 100.) + "," + randomCurrency(),
+                                      "" + TestUtil.nextInt(random(), 250, 320) + ",USD"));
+    }
+    if (useField()) {
+      doc.addField("bool", random().nextBoolean() ? "t" : "f");
+    }
+    if (useField()) {
+      doc.addField("enum", randomEnumValue());
+    }
     return doc;
   }
 
@@ -939,6 +961,25 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
     return result;
   }
 
+  private static String randomDate() {
+    return DateField.formatExternal(new Date(random().nextLong()));
+  }
+
+  private static String dateWithRandomSecondOn2010_10_31_at_10_31() {
+    return String.format("2010-10-31T10:31:%02d.000Z",
+                         TestUtil.nextInt(random(), 0, 59));
+  }
+
+  private static final String[] currencies = { "USD", "EUR", "NOK" };
+
+  public static String randomCurrency() {
+    return currencies[random().nextInt(currencies.length)];
+  }
+
+  private static String randomEnumValue() {
+    return SEVERITY_ENUM_VALUES[random().nextInt(SEVERITY_ENUM_VALUES.length)];
+  }
+
   /**
    * Given a list of fieldNames, builds up a random sort string which is guaranteed to
    * have at least 3 clauses, ending with the "id" field for tie breaking
@@ -956,15 +997,16 @@ public class CursorPagingTest extends SolrTestCaseJ4 {
       String field = shuffledNames.get(i);
 
       // wrap in a function sometimes
-      if ( (!"score".equals(field))
+      if ( (!"score".equals(field) && !field.contains("bcd"))
            && 
            (0 == TestUtil.nextInt(random(), 0, 7)) ) {
         // specific function doesn't matter, just proving that we can handle the concept.
         // but we do have to be careful with non numeric fields
-        if (field.startsWith("str") || field.startsWith("bin")) {
-          field = "if(exists(" + field + "),47,83)";
-        } else {
+        if (field.contains("float") || field.contains("double")
+            || field.contains("int") || field.contains("long")) {
           field = "abs(" + field + ")";
+        } else {
+          field = "if(exists(" + field + "),47,83)";
         }
       }
       result.append(field).append(random().nextBoolean() ? " asc, " : " desc, ");
diff --git a/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java b/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
index ea423ab..a01dbd1 100644
--- a/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
+++ b/solr/core/src/test/org/apache/solr/schema/SortableBinaryField.java
@@ -24,7 +24,6 @@ import org.apache.lucene.search.FieldComparator;
 import org.apache.lucene.search.FieldComparatorSource;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
-import org.apache.solr.common.util.Base64;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -81,20 +80,11 @@ public class SortableBinaryField extends BinaryField {
   
   @Override
   public Object marshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final BytesRef val = (BytesRef)value;
-    return Base64.byteArrayToBase64(val.bytes, val.offset, val.length);
+    return marshalBase64SortValue(value);
   }
   
   @Override
   public Object unmarshalSortValue(Object value) {
-    if (null == value) {
-      return null;
-    }
-    final String val = (String)value;
-    final byte[] bytes = Base64.base64ToByteArray(val);
-    return new BytesRef(bytes);
+    return unmarshalBase64SortValue(value);
   }
 }
diff --git a/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java b/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
index 950d936..28bca55 100644
--- a/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
+++ b/solr/core/src/test/org/apache/solr/search/CursorMarkTest.java
@@ -17,10 +17,14 @@
 
 package org.apache.solr.search;
 
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.schema.DateField;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.request.SolrQueryRequest;
@@ -28,11 +32,14 @@ import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.CursorPagingTest;
 import static org.apache.solr.common.params.CursorMarkParams.CURSOR_MARK_START;
 
+import java.io.IOException;
 import java.util.Arrays;
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.List;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.UUID;
 
 import org.junit.BeforeClass;
 
@@ -51,7 +58,7 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
     initCore(CursorPagingTest.TEST_SOLRCONFIG_NAME, CursorPagingTest.TEST_SCHEMAXML_NAME);
   }
 
-  public void testNextCursorMark() {
+  public void testNextCursorMark() throws IOException {
     final Collection<String> allFieldNames = getAllFieldNames();
     final SolrQueryRequest req = req();
     final IndexSchema schema = req.getSchema();
@@ -113,7 +120,7 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
   }
 
 
-  public void testGarbageParsing() {
+  public void testGarbageParsing() throws IOException {
     final SolrQueryRequest req = req();
     final IndexSchema schema = req.getSchema();
     final SortSpec ss = QueryParsing.parseSortSpec("str asc, float desc, id asc", req);
@@ -160,7 +167,7 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
     }
   }
 
-  public void testRoundTripParsing() {
+  public void testRoundTripParsing() throws IOException {
 
     // for any valid SortSpec, and any legal values, we should be able to round 
     // trip serialize the totem and get the same values back.
@@ -196,7 +203,7 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
     }
   }
 
-  private static Object[] buildRandomSortObjects(SortSpec ss) {
+  private static Object[] buildRandomSortObjects(SortSpec ss) throws IOException {
     List<SchemaField> fields = ss.getSchemaFields();
     assertNotNull(fields);
     Object[] results = new Object[fields.size()];
@@ -225,14 +232,64 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
           byte[] randBytes = new byte[TestUtil.nextInt(random(), 1, 50)];
           random().nextBytes(randBytes);
           val = new BytesRef(randBytes);
-        } else if (fieldName.startsWith("int")) {
-          val = (Integer) random().nextInt();
-        } else if (fieldName.startsWith("long")) {
-          val = (Long) random().nextLong();
-        } else if (fieldName.startsWith("float")) {
-          val = (Float) random().nextFloat() * random().nextInt(); break;
-        } else if (fieldName.startsWith("double")) {
-          val = (Double) random().nextDouble() * random().nextInt(); break;
+        } else if (fieldName.startsWith("bcd")) {
+          if (fieldName.startsWith("bcd_long")) {           // BCDLongField
+            val = Long.toString(random().nextLong());
+            val = sf.getType().toInternal((String)val);
+            val = sf.getType().unmarshalSortValue(val);
+          } else {                                          // BCDIntField & BCDStrField
+            val = Integer.toString(random().nextInt());
+            val = sf.getType().toInternal((String)val);
+            val = sf.getType().unmarshalSortValue(val);
+          }
+        } else if (fieldName.contains("int")) {
+          val = random().nextInt();                         // TrieIntField
+          if (fieldName.startsWith("legacy")) {             // IntField
+            val = Integer.toString((Integer)val);
+            if (fieldName.startsWith("legacy_sortable")) {  // SortableIntField
+              val = sf.getType().unmarshalSortValue(val);
+            }
+          }
+        } else if (fieldName.contains("long")) {
+          val = random().nextLong();                        // TrieLongField
+          if (fieldName.startsWith("legacy")) {             // LongField
+            val = Long.toString((Long)val);
+            if (fieldName.startsWith("legacy_sortable")) {  // SortableLongField
+              val = sf.getType().unmarshalSortValue(val);
+            }
+          }
+        } else if (fieldName.contains("float")) {
+          val = random().nextFloat() * random().nextInt();  // TrieFloatField
+          if (fieldName.startsWith("legacy")) {             // FloatField
+            val = Float.toString((Float)val);
+            if (fieldName.startsWith("legacy_sortable")) {  // SortableFloatField
+              val = sf.getType().unmarshalSortValue(val);
+            }
+          }
+        } else if (fieldName.contains("double")) {
+          val = random().nextDouble() * random().nextInt(); // TrieDoubleField
+          if (fieldName.startsWith("legacy")) {             // DoubleField
+            val = Double.toString((Double)val);
+            if (fieldName.startsWith("legacy_sortable")) {  // SortableDoubleField
+              val = sf.getType().unmarshalSortValue(val);
+            }
+          }
+        } else if (fieldName.contains("date")) {
+          val = random().nextLong();                        // TrieDateField
+          if (fieldName.startsWith("legacy_date")) {        // DateField
+            val = ((DateField)sf.getType()).toInternal(new Date((Long)val));
+            val = sf.getType().unmarshalSortValue(val);
+          }
+        } else if (fieldName.startsWith("currency")) {
+          val = random().nextDouble();
+        } else if (fieldName.startsWith("uuid")) {
+          val = sf.getType().unmarshalSortValue(UUID.randomUUID().toString());
+        } else if (fieldName.startsWith("bool")) {
+          val = sf.getType().unmarshalSortValue(random().nextBoolean() ? "t" : "f");
+        } else if (fieldName.startsWith("enum")) {
+          val = random().nextInt(CursorPagingTest.SEVERITY_ENUM_VALUES.length);
+        } else if (fieldName.contains("collation")) {
+          val = getRandomCollation(sf);
         } else {
           fail("fell through the rabbit hole, new field in schema? = " + fieldName);
         }
@@ -243,6 +300,19 @@ public class CursorMarkTest extends SolrTestCaseJ4 {
     }
     return results;
   }
+
+  private static Object getRandomCollation(SchemaField sf) throws IOException {
+    Object val;
+    Analyzer analyzer = sf.getType().getAnalyzer();
+    String term = TestUtil.randomRealisticUnicodeString(random());
+    try (TokenStream ts = analyzer.tokenStream("fake", term)) {
+      TermToBytesRefAttribute termAtt = ts.addAttribute(TermToBytesRefAttribute.class);
+      val = termAtt.getBytesRef();
+      ts.reset();
+      assertTrue(ts.incrementToken());
+    }
+    return val;
+  }
   
   /**
    * a list of the fields in the schema - excluding _version_

