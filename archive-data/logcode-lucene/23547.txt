GitDiffStart: e2b5047f9cc68f4e4df365b11e451589651529d7 | Tue Aug 22 13:41:33 2006 +0000
diff --git a/docs/scoring.html b/docs/scoring.html
new file mode 100644
index 0000000..6366cc5
--- /dev/null
+++ b/docs/scoring.html
@@ -0,0 +1,848 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+
+<!--
+Copyright 1999-2004 The Apache Software Foundation
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+
+
+<!-- Content Stylesheet for Site -->
+
+        
+<!-- start the processing -->
+    <!-- ====================================================================== -->
+    <!-- GENERATED FILE, DO NOT EDIT, EDIT THE XML FILE IN xdocs INSTEAD! -->
+    <!-- Main Page Section -->
+    <!-- ====================================================================== -->
+    <html>
+        <head>
+            <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
+
+                                                    <meta name="author" value="Grant Ingersoll">
+            <meta name="email" value="gsingers at apache.org">
+            
+           
+                                    
+                        
+            <title>Apache Lucene - Scoring - Apache Lucene</title>
+            <link rel="stylesheet" type="text/css" href="styles/lucene.css">
+        </head>
+
+        <body bgcolor="#ffffff" text="#000000" link="#525D76">        
+            <table border="0" width="100%" cellspacing="0">
+                <!-- TOP IMAGE -->
+                <tr>
+                    <td align="left">
+<a href="http://www.apache.org"><img src="http://lucene.apache.org/java/docs/images/asf-logo.gif" width="387" height="100" border="0"/></a>
+</td>
+<td align="right">
+<a href="http://lucene.apache.org/"><img src="./images/lucene_green_300.gif" alt="Apache Lucene" border="0"/></a>
+</td>
+                </tr>
+            </table>
+            <table border="0" width="100%" cellspacing="4">
+                <tr><td colspan="2">
+                    <hr noshade="" size="1"/>
+                </td></tr>
+                
+                <tr>
+                    <!-- LEFT SIDE NAVIGATION -->
+                    <td width="20%" valign="top" nowrap="true">
+                    
+    <!-- ============================================================ -->
+
+                <p><strong>About</strong></p>
+        <ul>
+                    <li>    <a href="./index.html">Overview</a>
+</li>
+                    <li>    <a href="./features.html">Features</a>
+</li>
+                    <li>    <a href="http://wiki.apache.org/jakarta-lucene/PoweredBy">Powered by Lucene</a>
+</li>
+                    <li>    <a href="./whoweare.html">Who We Are</a>
+</li>
+                    <li>    <a href="./mailinglists.html">Mailing Lists</a>
+</li>
+                </ul>
+            <p><strong>Resources</strong></p>
+        <ul>
+                    <li>    <a href="http://wiki.apache.org/jakarta-lucene">Wiki</a>
+</li>
+                    <li>    <a href="http://wiki.apache.org/jakarta-lucene/LuceneFAQ">FAQ</a>
+</li>
+                    <li>    <a href="./gettingstarted.html">Getting Started</a>
+</li>
+                    <li>    <a href="./queryparsersyntax.html">Query Syntax</a>
+</li>
+                    <li>    <a href="./fileformats.html">File Formats</a>
+</li>
+                    <li>    <a href="./api/index.html">Javadoc</a>
+</li>
+                    <li>    <a href="./contributions.html">Contributions</a>
+</li>
+                    <li>    <a href="./benchmarks.html">Benchmarks</a>
+</li>
+                    <li>    <a href="http://issues.apache.org/jira/browse/LUCENE">Issue Tracker</a>
+</li>
+                    <li>    <a href="./lucene-sandbox/">Lucene Sandbox</a>
+</li>
+                </ul>
+            <p><strong>Download</strong></p>
+        <ul>
+                    <li>    <a href="http://www.apache.org/dyn/closer.cgi/lucene/java/">Releases</a>
+</li>
+                    <li>    <a href="http://svn.apache.org/viewcvs.cgi/lucene/java/">Source Repository</a>
+</li>
+                </ul>
+                        </td>
+                    <td width="80%" align="left" valign="top">
+                                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Introduction"><strong>Introduction</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>Lucene scoring is the heart of why we all love Lucene.  It is blazingly fast and it hides almost all of the complexity from the user.
+                In a nutshell, it works.  At least, that is, until it doesn't work, or doesn't work as one would expect it to
+            work.  Then we are left digging into Lucene internals or asking for help on java-user@lucene.apache.org to figure out why a document with five of our query terms
+            scores lower than a different document with only one of the query terms. </p>
+                                                <p>While this document won't answer your specific scoring issues, it will, hopefully, point you to the places that can
+            help you figure out the what and why of Lucene scoring.</p>
+                                                <p>Lucene scoring uses a combination of the
+                <a href="http://en.wikipedia.org/wiki/Vector_Space_Model">Vector Space Model (VSM) of Information
+                    Retrieval</a> and the Boolean model
+                to determine
+                how relevant a given Document is to a User's query.  In general, the idea behind the VSM is the more
+                times a query term appears in a document relative to
+                the number of times the term appears in all the documents in the collection, the more relevant that
+                document is to the query.  It uses the Boolean model to first narrow down the documents that need to
+                be scored based on the use of boolean logic in the Query specification.  Lucene also adds some
+                capabilities and refinements onto this model to support boolean and fuzzy searching, but it
+                essentially remains a VSM based system at the heart.
+                For some valuable references on VSM and IR in general refer to the
+                <a href="http://wiki.apache.org/jakarta-lucene/InformationRetrieval">Lucene Wiki IR references</a>.
+            </p>
+                                                <p>The rest of this document will cover <a href="#Scoring">Scoring</a> basics and how to change your
+                <a href="api/org/apache/lucene/search/Similarity.html">Similarity</a>.  Next it will cover ways you can
+                customize the Lucene internals in <a href="#Changing your Scoring -- Expert Level">Changing your Scoring
+                -- Expert Level</a> which gives details on implementing your own
+                <a href="api/org/apache/lucene/search/Query.html">Query</a> class and related functionality.  Finally, we
+                will finish up with some reference material in the <a href="#Appendix">Appendix</a>.
+            </p>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Scoring"><strong>Scoring</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>Scoring is very much dependent on the way documents are indexed,
+                so it is important to understand indexing (see
+                <a href="gettingstarted.html">Apache Lucene - Getting Started Guide</a>
+                and the Lucene
+                <a href="fileformats.html">file formats</a>
+                before continuing on with this section.)  It is also assumed that readers know how to use the
+                <a href="api/org/apache/lucene/search/Searcher.html#explain(Query query, int doc)">Searcher.explain(Query query, int doc)</a> functionality,
+                which can go a long way in informing why a score is returned.
+            </p>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Fields and Documents"><strong>Fields and Documents</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>In Lucene, the objects we are scoring are
+                    <a href="api/org/apache/lucene/document/Document.html">Documents</a>.  A Document is a collection
+                of
+                    <a href="api/org/apache/lucene/document/Field.html">Fields</a>.  Each Field has semantics about how
+                it is created and stored (i.e. tokenized, untokenized, raw data, compressed, etc.)  It is important to
+                    note that Lucene scoring works on Fields and then combines the results to return Documents.  This is
+                    important because two Documents with the exact same content, but one having the content in two Fields
+                    and the other in one Field will return different scores for the same query due to length normalization
+                    (assumming the
+                    <a href="api/org/apache/lucene/search/DefaultSimilarity.html">DefaultSimilarity</a>
+                    on the Fields.
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Understanding the Scoring Formula"><strong>Understanding the Scoring Formula</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>
+                    Lucene's scoring formula, taken from
+                    <a href="api/org/apache/lucene/search/Similarity.html">Similarity</a>
+                    is
+                    <div class="formula">
+                        <!-- Anyone know how to specify sigma in Anakia?  It always seems to strip out my numeric character references-->
+                        score(q,d) =
+                        <span class="big" id="summation">
+                            sum </span><span class="summation-range">t in q</span><span>(
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#tf(int)">tf</A>
+                        (t in d) *
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#idf(org.apache.lucene.index.Term, org.apache.lucene.search.Searcher)">idf</A>
+                        (t)^2 *
+                        <A HREF="api/org/apache/lucene/search/Query.html#getBoost()">
+                        getBoost
+                        </A>
+                        (t in q) *
+                        getBoost
+                        (t.field in d) *
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#lengthNorm(java.lang.String, int)">
+                            lengthNorm
+                        </A>
+                        (t.field in d) )</span> <span> *
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#coord(int, int)">
+                            coord
+                        </A>
+                        (q,d) *
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#queryNorm(float)">
+                            queryNorm
+                        </A>(sumOfSqaredWeights)</span>
+                    </div>
+
+                </p>
+                                                <p>
+                    where
+                    <!-- Anyone know how to specify sigma in Anakia?  It always seems to strip out my numeric character references-->
+                    <div id="#sumOfSquares">
+                        sumOfSqaredWeights =
+                        <span class="big">sum</span><span class="summation-range">t in q</span><span>(
+                        <A HREF="api/org/apache/lucene/search/Similarity.html#idf(org.apache.lucene.index.Term, org.apache.lucene.search.Searcher)">
+                            idf
+                        </A>
+                        (t) *
+                        <A HREF="api/org/apache/lucene/search/Query.html#getBoost()">
+                            getBoost
+                        </A>
+                        (t in q) )^2</span>
+                    </div>
+                </p>
+                                                <p>This scoring formula is mostly incorporated into the
+                    <a href="api/org/apache/lucene/search/TermScorer.html">TermScorer</a> class, where it makes calls to the
+                    <a href="api/org/apache/lucene/search/Similarity.html">Similarity</a> class to retrieve values for the following:
+                    <ol>
+                        <li>tf - Term Frequency - The number of times the term <i>t</i> appears in the current document being scored.  </li>
+                        <li>idf - Inverse Document Frequency - One divided by the number of documents in which the term <i>t</i> appears in.</li>
+                        <li>getBoost(t in q) - The boost, specified in the query by the user, that should be applied to this term.</li>
+                        <li>lengthNorm(t.field in q) - The factor to apply to account for differing lengths in the fields that are being searched.  Usually longer fields return a smaller value.</li>
+                        <li>coord(q, d) - Score factor based on how many terms the specified document has in common with the query.</li>
+                        <li>queryNorm(sumOfSquaredWeights) - Factor used to make scores between queries comparable
+                            <span class="highlight-for-editing">GSI: might be interesting to have a note on why this formula was chosen.  I have always understood (but not 100% sure)
+                                that it is not a good idea to compare scores across queries or indexes, so any use of normalization may lead to false assumptions.</span></li>
+                    </ol>
+                    Note, the above definitions are summaries of the javadocs which can be accessed by clicking the links in the formula and are merely provided
+                    for context and are not authoratitive.
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="The Big Picture"><strong>The Big Picture</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>OK, so the tf-idf formula and the
+                    <a href="api/org/apache/lucene/search/Similarity.html">Similarity</a>
+                    is great for understanding the basics of Lucene scoring, but what really drives Lucene scoring are
+                    the use and interactions between the
+                    <a href="api/org/apache/lucene/search/Query.html">Query</a> classes, as created by each application in
+                    response to a user's information need.
+                </p>
+                                                <p>In this regard, Lucene offers a wide variety of Query implementations, most of which are in the
+                    org.apache.lucene.search package.
+                    These implementations can be combined in a wide variety of ways to provide complex querying
+                    capabilities along with
+                    information about where matches took place in the document collection. The <a href="#Query Classes">Query</a>
+                    section below will
+                    highlight some of the more important Query classes.  For information on the other ones, see the
+                    <a href="api/org/apache/lucene/search/package-summary.html">package summary</a>.  For details on implementing
+                    your own Query class, see <a href="#Changing your Scoring -- Expert Level">Changing your Scoring --
+                    Expert Level</a> below.
+                </p>
+                                                <p>Once a Query has been created and submitted to the
+                    <a href="api/org/apache/lucene/search/IndexSearcher.html">IndexSearcher</a>, the scoring process
+                begins.  (See the <a href="#Appendix">Appendix</a> Algorithm section for more notes on the process.)  After some infrastructure setup,
+                control finally passes to the Weight implementation and it's
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a> instance.  In the case of any type of
+                    <a href="api/org/apache/lucene/search/BooleanQuery.html">BooleanQuery</a>, scoring is handled by the
+                    <a href="http://svn.apache.org/viewvc/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java?view=log">BooleanWeight2</a> (link goes to ViewVC BooleanQuery java code which contains the BooleanWeight2 inner class),
+                    unless the static
+                    <a href="api/org/apache/lucene/search/BooleanQuery.html#setUseScorer14(boolean)">
+                        BooleanQuery#setUseScorer14(boolean)</a> method is set to true,
+                in which case the
+                    <a href="http://svn.apache.org/viewvc/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java?view=log">BooleanWeight</a>
+                    (link goes to ViewVC BooleanQuery java code, which contains the BooleanWeight inner class) from the 1.4 version of Lucene is used by default.
+                    See <a href="http://svn.apache.org/repos/asf/lucene/java/trunk/CHANGES.txt">CHANGES.txt</a> under release 1.9 RC1 for more information on choosing which Scorer to use.
+                </p>
+                                                <p>
+                    Assuming the use of the BooleanWeight2, a
+                    BooleanScorer2 is created by bringing together
+                    all of the
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>s from the sub-clauses of the BooleanQuery.
+                    When the BooleanScorer2 is asked to score it delegates its work to an internal Scorer based on the type
+                    of clauses in the Query.  This internal Scorer essentially loops over the sub scorers and sums the scores
+                    provided by each scorer while factoring in the coord() score.
+                    <!-- Do we want to fill in the details of the counting sum scorer, disjunction scorer, etc.? -->
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Query Classes"><strong>Query Classes</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <h4>
+                    <a href="api/org/apache/lucene/search/TermQuery.html">TermQuery</a>
+                </h4>
+                                                <p>Of the various implementations of
+                    Query, the
+                    <a href="api/org/apache/lucene/search/TermQuery.html">TermQuery</a>
+                    is the easiest to understand and the most often used in most applications. A TermQuery is a Query
+                    that matches all the documents that contain the specified
+                    <a href="api/org/apache/lucene/index/Term.html">Term</a>
+                    . A Term is a word that occurs in a specific
+                    <a href="api/org/apache/lucene/document/Field.html">Field</a>
+                    . Thus, a TermQuery identifies and scores all
+                    <a href="api/org/apache/lucene/document/Document.html">Document</a>
+                    s that have a Field with the specified string in it.
+                    Constructing a TermQuery is as simple as:
+                    <code>TermQuery tq = new TermQuery(new Term("fieldName", "term");</code>
+                    In this example, the Query would identify all Documents that have the Field named "fieldName" that
+                    contain the word "term".
+                </p>
+                                                <h4>
+                    <a href="api/org/apache/lucene/search/BooleanQuery.html">BooleanQuery</a>
+                </h4>
+                                                <p>Things start to get interesting when one starts to combine TermQuerys, which is handled by the
+                    <a href="api/org/apache/lucene/search/BooleanQuery.html">BooleanQuery</a>
+                    class. The BooleanQuery is a collection
+                    of other
+                    <a href="api/org/apache/lucene/search/Query.html">Query</a>
+                    classes along with semantics about how to combine the different subqueries.
+                    It currently supports three different operators for specifying the logic of the query (see
+                    <a href="api/org/apache/lucene/search/BooleanClause.html">BooleanClause</a>
+                    )
+                    <ol>
+                        <li>SHOULD -- Use this operator when a clause can occur in the result set, but is not required.
+                            If a query is made up of all SHOULD clauses, then a non-empty result
+                            set will have matched at least one of the clauses in the query.</li>
+                        <li>MUST -- Use this operator when a clause is required to occur in the result set.</li>
+                        <li>MUST NOT -- Use this operator when a clause must not occur in the result set.</li>
+                    </ol>
+                    Boolean queries are constructed by adding two or more
+                    <a href="api/org/apache/lucene/search/BooleanClause.html">BooleanClause</a>
+                    instances to the BooleanQuery instance. In some cases,
+                    too many clauses may be added to the BooleanQuery, which will cause a TooManyClauses exception to be
+                    thrown. This
+                    most often occurs when using a Query that is rewritten into many TermQuery instances, such as the
+                    <a href="api/org/apache/lucene/search/WildCardQuery.html">WildCardQuery</a>
+                    . The default
+                    setting for too many clauses is currently set to 1024, but it can be overridden via the
+                    <a href="api/org/apache/lucene/search/BooleanQuery.html#setMaxClauseCount(int)">BooleanQuery#setMaxClauseCount(int)</a> static method on BooleanQuery.
+                </p>
+                                                <h4>Phrases</h4>
+                                                <p>Another common task in search is to identify phrases, which can be handled in two different ways.
+                    <ol>
+                        <li>
+                            <a href="api/org/apache/lucene/search/PhraseQuery.html">PhraseQuery</a>
+                            -- Matches a sequence of
+                            <a href="api/org/apache/lucene/index/Term.html">Terms</a>
+                            . The PhraseQuery can specify a slop factor which determines
+                            how many positions may occur between any two terms and still be considered a match.
+                        </li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/spans/SpanNearQuery.html">SpanNearQuery</a>
+                            -- Matches a sequence of other
+                            <a href="api/org/apache/lucene/search/spans/SpanQuery.html">SpanQuery</a>
+                            instances. The SpanNearQuery allows for much more
+                            complicated phrasal queries to be built since it is constructed out of other SpanQuery
+                            objects, not just Terms.
+                        </li>
+                    </ol>
+                </p>
+                                                <h4>
+                    <a href="api/org/apache/lucene/search/RangeQuery.html">RangeQuery</a>
+                </h4>
+                                                <p>The
+                    <a href="api/org/apache/lucene/search/RangeQuery.html">RangeQuery</a>
+                    matches all documents that occur in the
+                    exclusive range of a lower
+                    <a href="api/org/apache/lucene/index/Term.html">Term</a>
+                    and an upper
+                    <a href="api/org/apache/lucene/index/Term.html">Term</a>
+                    . For instance, one could find all documents
+                    that have terms beginning with the letters a through c. This type of Query is most often used to
+                    find
+                    documents that occur in a specific date range.
+                </p>
+                                                <h4>
+                    <a href="api/org/apache/lucene/search/PrefixQuery.html">PrefixQuery</a>
+                    ,
+                    <a href="api/org/apache/lucene/search/WildcardQuery.html">WildcardQuery</a>
+                </h4>
+                                                <p>While the
+                    <a href="api/org/apache/lucene/search/PrefixQuery.html">PrefixQuery</a>
+                    has a different implementation, it is essentially a special case of the
+                    <a href="api/org/apache/lucene/search/WildcardQuery.html">WildcardQuery</a>
+                    . The PrefixQuery allows an application
+                    to identify all documents with terms that begin with a certain string. The WildcardQuery generalize
+                    this by allowing
+                    for the use of * and ? wildcards. Note that the WildcardQuery can be quite slow. Also note that
+                    WildcardQuerys should
+                    not start with * and ?, as these are extremely slow. For tricks on how to search using a wildcard at
+                    the beginning of a term, see
+                    <a href="http://www.gossamer-threads.com/lists/lucene/java-user/13373?search_string=WildcardQuery%20start;#13373">
+                        Starts With x and Ends With x Queries</a>
+                    from the Lucene archives.
+                </p>
+                                                <h4>
+                    <a href="api/org/apache/lucene/search/FuzzyQuery.html">FuzzyQuery</a>
+                </h4>
+                                                <p>A
+                    <a href="api/org/apache/lucene/search/FuzzyQuery.html">FuzzyQuery</a>
+                    matches documents that contain similar terms to the specified term. Similarity is
+                    determined using the
+                    <a href="http://en.wikipedia.org/wiki/Levenshtein">Levenshtein (edit distance) algorithm</a>
+                    . This type of query can be useful when accounting for spelling variations in the collection.
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Changing Similarity"><strong>Changing Similarity</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>Chances are, the
+                    <a href="api/org/apache/lucene/search/DefaultSimilarity.html">DefaultSimilarity</a> is sufficient for all your searching needs.
+                    However, in some applications it may be necessary to alter your Similarity.  For instance, some applications do not need to
+                    distinguish between shorter documents and longer documents (for example,
+                    see <a href="http://www.gossamer-threads.com/lists/lucene/java-user/38967?search_string=Similarity;#38967">a "fair" similarity</a>)
+                    To change the Similarity, one must do so for both indexing and searching and the changes must take place before
+                    any of these actions are undertaken (although in theory there is nothing stopping you from changing mid-stream, it just isn't well-defined what is going to happen).
+                    To make this change, implement your Similarity (you probably want to override
+                    <a href="api/org/apache/lucene/search/DefaultSimilarity.html">DefaultSimilarity</a>) and then set the new
+                    class on
+                    <a href="api/org/apache/lucene/index/IndexWriter.html#setSimilarity(org.apache.lucene.search.Similarity)">IndexWriter.setSimilarity(org.apache.lucene.search.Similarity)</a> for indexing and on
+                    <a href="api/org/apache/lucene/search/Searcher.html#setSimilarity(org.apache.lucene.search.Similarity)">Searcher.setSimilarity(org.apache.lucene.search.Similarity)</a>.
+                </p>
+                                                <p>
+                    If you are interested in use cases for changing your similarity, see the mailing list at <a href="http://www.nabble.com/Overriding-Similarity-tf2128934.html">Overriding Similarity</a>.
+                    In summary, here are a few use cases:
+                    <ol>
+                        <li>SweetSpotSimilarity -- SweetSpotSimilarity gives small increases as the frequency increases a small amount
+                        and then greater increases when you hit the "sweet spot", i.e. where you think the frequency of terms is more significant.</li>
+                        <li>Overriding tf -- In some applications, it doesn't matter what the score of a document is as long as a matching term occurs.  In these
+                        cases people have overridden Similarity to return 1 from the tf() method.</li>
+                        <li>Changing Length Normalization -- By overriding lengthNorm, it is possible to discount how the length of a field contributes
+                        to a score.  In the DefaultSimilarity, lengthNorm = 1/ (numTerms in field)^0.5, but if one changes this to be
+                        1 / (numTerms in field), all fields will be treated
+                            <a href="http://www.gossamer-threads.com/lists/lucene/java-user/38967?search_string=Similarity;#38967">"fairly"</a>.</li>
+                    </ol>
+                    In general, Chris Hostetter sums it up best in saying (from <a href="http://www.gossamer-threads.com/lists/lucene/java-user/39125">the mailing list</a>):
+                    <blockquote>[One would override the Similarity in] ... any situation where you know more about your data then just that
+                        it's "text" is a situation where it *might* make sense to to override your
+                        Similarity method.</blockquote>
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Changing your Scoring -- Expert Level"><strong>Changing your Scoring -- Expert Level</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>Changing scoring is an expert level task, so tread carefully and be prepared to share your code if
+                you want help.
+            </p>
+                                                <p>With the warning out of the way, it is possible to change a lot more than just the Similarity
+            when it comes to scoring in Lucene.  Lucene's scoring is a complex mechanism that is grounded by
+                <span class="highlight-for-editing">three main classes</span>:
+                <ol>
+                    <li>
+                        <a href="api/org/apache/lucene/search/Query.html">Query</a> -- The abstract object representation of the user's information need.</li>
+                    <li>
+                        <a href="api/org/apache/lucene/search/Weight.html">Weight</a> -- The internal interface representation of the user's Query, so that Query objects may be reused.</li>
+                    <li>
+                        <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a> -- An abstract class containing common functionality for scoring.  Provides both scoring and explanation capabilities.</li>
+                </ol>
+                Details on each of these classes, and their children can be found in the subsections below.
+            </p>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="The Query Class"><strong>The Query Class</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>In some sense, the
+                    <a href="api/org/apache/lucene/search/Query.html">Query</a>
+                    class is where it all begins. Without a Query, there would be
+                    nothing to score. Furthermore, the Query class is the catalyst for the other scoring classes as it
+                    is often responsible
+                    for creating them or coordinating the functionality between them. The
+                    <a href="api/org/apache/lucene/search/Query.html">Query</a> class has several methods that are important for
+                    derived classes:
+                    <ol>
+                        <li>createWeight(Searcher searcher) -- A
+                            <a href="api/org/apache/lucene/search/Weight.html">Weight</a> is the internal representation of the Query, so each Query implementation must
+                        provide an implementation of Weight.  See the subsection on <a href="#The Weight Interface">The Weight Interface</a> below for details on implementing the Weight interface.</li>
+                        <li>rewrite(IndexReader reader) -- Rewrites queries into primitive queries.  Primitive queries are:
+                            <a href="api/org/apache/lucene/search/TermQuery.html">TermQuery</a>,
+                            <a href="api/org/apache/lucene/search/BooleanQuery.html">BooleanQuery</a>, <span class="highlight-for-editing">OTHERS????</span></li>
+                    </ol>
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="The Weight Interface"><strong>The Weight Interface</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>The
+                    <a href="api/org/apache/lucene/search/Weight.html">Weight</a>
+                    interface provides an internal representation of the Query so that it can be reused. Any
+                    <a href="api/org/apache/lucene/search/Searcher.html">Searcher</a>
+                    dependent state should be stored in the Weight implementation,
+                    not in the Query class. The interface defines 6 methods that must be implemented:
+                    <ol>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#getQuery()">Weight#getQuery()</a> -- Pointer to the Query that this Weight represents.</li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#getValue()">Weight#getValue()</a> -- The weight for this Query. For example, the TermQuery.TermWeight value is
+                            equal to the idf^2 * boost * queryNorm <!-- DOUBLE CHECK THIS --></li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#sumOfSquaredWeights()">
+                                Weight#sumOfSquaredWeights()</a> -- The sum of squared weights. Tor TermQuery, this is (idf *
+                            boost)^2</li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#normalize(float)">
+                                Weight#normalize(float)</a> -- Determine the query normalization factor. The query normalization may
+                            allow for comparing scores between queries.</li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#scorer(IndexReader)">
+                                Weight#scorer(IndexReader)</a> -- Construct a new
+                            <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                            for this Weight. See
+                            <a href="#The Scorer Class">The Scorer Class</a>
+                            below for help defining a Scorer. As the name implies, the
+                            Scorer is responsible for doing the actual scoring of documents given the Query.
+                        </li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Weight.html#explain(IndexReader, int)">
+                                Weight#explain(IndexReader, int)</a> -- Provide a means for explaining why a given document was scored
+                            the way it was.</li>
+                    </ol>
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="The Scorer Class"><strong>The Scorer Class</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>The
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                    abstract class provides common scoring functionality for all Scorer implementations and
+                    is the heart of the Lucene scoring process. The Scorer defines the following abstract methods which
+                    must be implemented:
+                    <ol>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Scorer.html#next()">Scorer#next()</a> -- Advances to the next document that matches this Query, returning true if and only
+                            if there is another document that matches.</li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Scorer.html#doc()">Scorer#doc()</a> -- Returns the id of the
+                            <a href="api/org/apache/lucene/document/Document.html">Document</a>
+                            that contains the match. Is not valid until next() has been called at least once.
+                        </li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Scorer.html#score()">Scorer#score()</a> -- Return the score of the current document. This value can be determined in any
+                            appropriate way for an application. For instance, the
+                            <a href="http://svn.apache.org/viewvc/lucene/java/trunk/src/java/org/apache/lucene/search/TermScorer.java?view=log">TermScorer</a>
+                            returns the tf * Weight.getValue() * fieldNorm.
+                        </li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Scorer.html#skipTo(int)">Scorer#skipTo(int)</a> -- Skip ahead in the document matches to the document whose id is greater than
+                            or equal to the passed in value. In many instances, skipTo can be
+                            implemented more efficiently than simply looping through all the matching documents until
+                            the target document is identified.</li>
+                        <li>
+                            <a href="api/org/apache/lucene/search/Scorer.html#explain(int)">Scorer#explain(int)</a> -- Provides details on why the score came about.</li>
+                    </ol>
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Why would I want to add my own Query?"><strong>Why would I want to add my own Query?</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>In a nutshell, you want to add your own custom Query implementation when you think that Lucene's
+                    aren't appropriate for the
+                    task that you want to do. You might be doing some cutting edge research or you need more information
+                    back
+                    out of Lucene (similar to Doug adding SpanQuery functionality).</p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Examples"><strong>Examples</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p class="highlight-for-editing">FILL IN HERE</p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Appendix"><strong>Appendix</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                        <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Class Diagrams"><strong>Class Diagrams</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>
+                    <a href="http://wiki.apache.org/jakarta-lucene/KarlWettin?action=AttachFile&amp;do=view&amp;target=search_uml_1.jpg">
+                        Karl Wettin's UML on the Wiki</a>
+                </p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Sequence Diagrams"><strong>Sequence Diagrams</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p class="highlight-for-editing">FILL IN HERE. Volunteers?</p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#828DA6">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Algorithm"><strong>Algorithm</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>GSI Note: This section is mostly my notes on stepping through the Scoring process and serves as
+                    fertilizer for the earlier sections.</p>
+                                                <p>In the typical search application, a
+                    <a href="api/org/apache/lucene/search/Query.html">Query</a>
+                    is passed to the
+                    <a href="api/org/apache/lucene/search/Searcher.html">Searcher</a>
+                    , beginning the scoring process.
+                </p>
+                                                <p>Once inside the Searcher, a
+                    <a href="api/org/apache/lucene/search/Hits.html">Hits</a>
+                    object is constructed, which handles the scoring and caching of the search results.
+                    The Hits constructor stores references to three or four important objects:
+                    <ol>
+                        <li>The
+                            <a href="api/org/apache/lucene/search/Weight.html">Weight</a>
+                            object of the Query. The Weight object is an internal representation of the Query that
+                            allows the Query to be reused by the Searcher.
+                        </li>
+                        <li>The Searcher that initiated the call.</li>
+                        <li>A
+                            <a href="api/org/apache/lucene/search/Filter.html">Filter</a>
+                            for limiting the result set. Note, the Filter may be null.
+                        </li>
+                        <li>A
+                            <a href="api/org/apache/lucene/search/Sort.html">Sort</a>
+                            object for specifying how to sort the results if the standard score based sort method is not
+                            desired.
+                        </li>
+                    </ol>
+                </p>
+                                                <p>Now that the Hits object has been initialized, it begins the process of identifying documents that
+                    match the query by calling getMoreDocs method. Assuming we are not sorting (since sorting doesn't
+                    effect the raw Lucene score),
+                    we call on the "expert" search method of the Searcher, passing in our
+                    <a href="api/org/apache/lucene/search/Weight.html">Weight</a>
+                    object,
+                    <a href="api/org/apache/lucene/search/Filter.html">Filter</a>
+                    and the number of results we want. This method
+                    returns a
+                    <a href="api/org/apache/lucene/search/TopDocs.html">TopDocs</a>
+                    object, which is an internal collection of search results.
+                    The Searcher creates a
+                    <a href="api/org/apache/lucene/search/TopDocCollector.html">TopDocCollector</a>
+                    and passes it along with the Weight, Filter to another expert search method (for more on the
+                    <a href="api/org/apache/lucene/search/HitCollector.html">HitCollector</a>
+                    mechanism, see
+                    <a href="api/org/apache/lucene/search/Searcher.html">Searcher</a>
+                    .) The TopDocCollector uses a
+                    <a href="api/org/apache/lucene/util/PriorityQueue.html">PriorityQueue</a>
+                    to collect the top results for the search.
+                </p>
+                                                <p>If a Filter is being used, some initial setup is done to determine which docs to include. Otherwise,
+                    we ask the Weight for
+                    a
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                    for the
+                    <a href="api/org/apache/lucene/index/IndexReader.html">IndexReader</a>
+                    of the current searcher and we proceed by
+                    calling the score method on the
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                    .
+                </p>
+                                                <p>At last, we are actually going to score some documents. The score method takes in the HitCollector
+                    (most likely the TopDocCollector) and does its business.
+                    Of course, here is where things get involved. The
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                    that is returned by the
+                    <a href="api/org/apache/lucene/search/Weight.html">Weight</a>
+                    object depends on what type of Query was submitted. In most real world applications with multiple
+                    query terms,
+                    the
+                    <a href="api/org/apache/lucene/search/Scorer.html">Scorer</a>
+                    is going to be a
+                    <a href="http://svn.apache.org/viewvc/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanScorer2.java?view=log">BooleanScorer2</a>
+                    (see the section on customizing your scoring for info on changing this.)
+
+                </p>
+                                                <p>Assuming a BooleanScorer2 scorer, we first initialize the Coordinator, which is used to apply the
+                    coord() factor. We then
+                    get a internal Scorer based on the required, optional and prohibited parts of the query.
+                    Using this internal Scorer, the BooleanScorer2 then proceeds
+                    into a while loop based on the Scorer#next() method. The next() method advances to the next document
+                    matching the query. This is an
+                    abstract method in the Scorer class and is thus overriden by all derived
+                    implementations.  <!-- DOUBLE CHECK THIS -->If you have a simple OR query
+                    your internal Scorer is most likely a DisjunctionSumScorer, which essentially combines the scorers
+                    from the sub scorers of the OR'd terms.</p>
+                            </blockquote>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                        </td>
+                </tr>
+
+                <!-- FOOTER -->
+                <tr><td colspan="2">
+                    <hr noshade="" size="1"/>
+                </td></tr>
+                <tr><td colspan="2">
+                    <div align="center"><font color="#525D76" size="-1"><em>
+                    Copyright &#169; 1999-2005, The Apache Software Foundation
+                    </em></font></div>
+                </td></tr>
+            </table>
+        </body>
+    </html>
+<!-- end the processing -->
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+

