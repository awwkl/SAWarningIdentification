GitDiffStart: 649cad2a75ebc9d7380518a6ebd3edf5f3fb7861 | Thu Apr 12 01:32:29 2012 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index cdc8930..973c518 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -1,4 +1,4 @@
-ï»?                      Apache Solr Release Notes
+                      Apache Solr Release Notes
 
 Introduction
 ------------
@@ -486,6 +486,9 @@ Other Changes
 
 * SOLR-3322: Add more context to IndexReaderFactory.newReader (ab)
 
+* SOLR-3343: Moved FastWriter, FileUtils, RegexFileFilter, RTimer and SystemIdResolver
+  from org.apache.solr.common to org.apache.solr.util (Chris Male)
+
 Documentation
 ----------------------
 
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImportHandler.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImportHandler.java
index 32e9b1b..568ffd9 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImportHandler.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImportHandler.java
@@ -27,7 +27,7 @@ import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.StrUtils;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.RequestHandlerBase;
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
index 069a0b7..744d0f9 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
@@ -25,7 +25,7 @@ import org.apache.solr.schema.SchemaField;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.common.util.XMLErrorLogger;
 
 import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
index b6500b8..faa6a4e 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
@@ -20,7 +20,7 @@ import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVE
 import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.common.ResourceLoader;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.common.util.XMLErrorLogger;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/solr/core/src/java/org/apache/solr/core/Config.java b/solr/core/src/java/org/apache/solr/core/Config.java
index 795d78d..24ce9a1 100644
--- a/solr/core/src/java/org/apache/solr/core/Config.java
+++ b/solr/core/src/java/org/apache/solr/core/Config.java
@@ -19,8 +19,8 @@ package org.apache.solr.core;
 
 import org.apache.lucene.util.Version;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.DOMUtil;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.common.util.XMLErrorLogger;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
index 7862e1c..0b8084c 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
@@ -57,9 +57,9 @@ import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.cloud.ZooKeeperException;
 import org.apache.solr.common.params.CoreAdminParams;
-import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.FileUtils;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.DOMUtil;
+import org.apache.solr.util.FileUtils;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.core.SolrXMLSerializer.SolrCoreXMLDef;
 import org.apache.solr.core.SolrXMLSerializer.SolrXMLDef;
 import org.apache.solr.handler.admin.CoreAdminHandler;
diff --git a/solr/core/src/java/org/apache/solr/core/PluginInfo.java b/solr/core/src/java/org/apache/solr/core/PluginInfo.java
index ff31a72..682a9b1 100644
--- a/solr/core/src/java/org/apache/solr/core/PluginInfo.java
+++ b/solr/core/src/java/org/apache/solr/core/PluginInfo.java
@@ -17,7 +17,7 @@
 package org.apache.solr.core;
 
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
index dcb1865..fec79ad 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
@@ -19,8 +19,8 @@ package org.apache.solr.core;
 
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.util.DOMUtil;
-import org.apache.solr.common.util.RegexFileFilter;
+import org.apache.solr.util.DOMUtil;
+import org.apache.solr.util.RegexFileFilter;
 import org.apache.solr.handler.component.SearchComponent;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.QueryResponseWriter;
diff --git a/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java b/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
index b67de6e..ed3ed9d 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
@@ -47,7 +47,7 @@ import javax.naming.NoInitialContextException;
 import org.apache.solr.analysis.CharFilterFactory;
 import org.apache.solr.analysis.TokenFilterFactory;
 import org.apache.solr.analysis.TokenizerFactory;
-import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.util.FileUtils;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.handler.component.SearchComponent;
diff --git a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
index e23a4a1..c409f06 100644
--- a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
+++ b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
@@ -35,7 +35,7 @@ import org.apache.lucene.index.IndexCommit;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.FastInputStream;
-import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.util.FileUtils;
 import org.apache.solr.common.util.JavaBinCodec;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
diff --git a/solr/core/src/java/org/apache/solr/handler/SnapShooter.java b/solr/core/src/java/org/apache/solr/handler/SnapShooter.java
index e0415a8..ec470cd 100644
--- a/solr/core/src/java/org/apache/solr/handler/SnapShooter.java
+++ b/solr/core/src/java/org/apache/solr/handler/SnapShooter.java
@@ -58,7 +58,7 @@ public class SnapShooter {
     if (location == null) snapDir = core.getDataDir();
     else  {
       File base = new File(core.getCoreDescriptor().getInstanceDir());
-      snapDir = org.apache.solr.common.util.FileUtils.resolvePath(base, location).getAbsolutePath();
+      snapDir = org.apache.solr.util.FileUtils.resolvePath(base, location).getAbsolutePath();
       File dir = new File(snapDir);
       if (!dir.exists())  dir.mkdirs();
     }
diff --git a/solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java b/solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
index e5a910b..2104cb7 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
@@ -29,7 +29,7 @@ import org.apache.solr.cloud.ZkController;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.QueryElevationParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.Config;
diff --git a/solr/core/src/java/org/apache/solr/handler/component/ResponseBuilder.java b/solr/core/src/java/org/apache/solr/handler/component/ResponseBuilder.java
index f8ce46f..36ff9a9 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/ResponseBuilder.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/ResponseBuilder.java
@@ -25,7 +25,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.RTimer;
+import org.apache.solr.util.RTimer;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestInfo;
diff --git a/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java b/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
index 57eb621..006e993 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java
@@ -22,7 +22,7 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.ShardParams;
-import org.apache.solr.common.util.RTimer;
+import org.apache.solr.util.RTimer;
 import org.apache.solr.core.CloseHook;
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrCore;
diff --git a/solr/core/src/java/org/apache/solr/response/CSVResponseWriter.java b/solr/core/src/java/org/apache/solr/response/CSVResponseWriter.java
index d3e4f3e..e801327 100755
--- a/solr/core/src/java/org/apache/solr/response/CSVResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/CSVResponseWriter.java
@@ -25,7 +25,7 @@ import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.DateUtil;
-import org.apache.solr.common.util.FastWriter;
+import org.apache.solr.util.FastWriter;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.FieldType;
diff --git a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
index 06ccdd1..38fcd54 100644
--- a/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
+++ b/solr/core/src/java/org/apache/solr/response/TextResponseWriter.java
@@ -27,7 +27,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.util.Base64;
-import org.apache.solr.common.util.FastWriter;
+import org.apache.solr.util.FastWriter;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.response.transform.DocTransformer;
diff --git a/solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java b/solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
index e40b3a6..1d5e071 100644
--- a/solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
+++ b/solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
@@ -24,7 +24,7 @@ import org.apache.lucene.util.Version;
 import org.apache.solr.analysis.*;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.apache.solr.core.Config;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.util.plugin.AbstractPluginLoader;
diff --git a/solr/core/src/java/org/apache/solr/schema/IndexSchema.java b/solr/core/src/java/org/apache/solr/schema/IndexSchema.java
index 7cac899..205d73a 100644
--- a/solr/core/src/java/org/apache/solr/schema/IndexSchema.java
+++ b/solr/core/src/java/org/apache/solr/schema/IndexSchema.java
@@ -26,9 +26,9 @@ import org.apache.lucene.util.Version;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.Config;
 import org.apache.solr.core.SolrResourceLoader;
diff --git a/solr/core/src/java/org/apache/solr/search/CacheConfig.java b/solr/core/src/java/org/apache/solr/search/CacheConfig.java
index f4dc054..5b59b9a 100644
--- a/solr/core/src/java/org/apache/solr/search/CacheConfig.java
+++ b/solr/core/src/java/org/apache/solr/search/CacheConfig.java
@@ -23,7 +23,7 @@ import org.w3c.dom.NodeList;
 import java.util.Map;
 
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrResourceLoader;
 
diff --git a/solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java b/solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java
index 4a7b5eb..9c28fd7 100644
--- a/solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java
+++ b/solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java
@@ -51,7 +51,7 @@ import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.FastWriter;
+import org.apache.solr.util.FastWriter;
 import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.*;
 import org.apache.solr.handler.component.SearchHandler;
diff --git a/solr/core/src/java/org/apache/solr/util/DOMUtil.java b/solr/core/src/java/org/apache/solr/util/DOMUtil.java
new file mode 100644
index 0000000..969d01e
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/DOMUtil.java
@@ -0,0 +1,399 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.StrUtils;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ *
+ */
+public class DOMUtil {
+
+  public static Map<String,String> toMap(NamedNodeMap attrs) {
+    return toMapExcept(attrs);
+  }
+
+  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
+    Map<String,String> args = new HashMap<String,String>();
+    outer: for (int j=0; j<attrs.getLength(); j++) {
+      Node attr = attrs.item(j);
+      String attrName = attr.getNodeName();
+      for (String ex : exclusions)
+        if (ex.equals(attrName)) continue outer;
+      String val = attr.getNodeValue();
+      args.put(attrName, val);
+    }
+    return args;
+  }
+
+  public static Node getChild(Node node, String name) {
+    if (!node.hasChildNodes()) return null;
+    NodeList lst = node.getChildNodes();
+    if (lst == null) return null;
+    for (int i=0; i<lst.getLength(); i++) {
+      Node child = lst.item(i);
+      if (name.equals(child.getNodeName())) return child;
+    }
+    return null;
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name) {
+    return getAttr(attrs,name,null);
+  }
+
+  public static String getAttr(Node nd, String name) {
+    return getAttr(nd.getAttributes(), name);
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
+    Node attr = attrs==null? null : attrs.getNamedItem(name);
+    if (attr==null) {
+      if (missing_err==null) return null;
+      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
+    }
+    String val = attr.getNodeValue();
+    return val;
+  }
+
+  public static String getAttr(Node node, String name, String missing_err) {
+    return getAttr(node.getAttributes(), name, missing_err);
+  }
+
+  //////////////////////////////////////////////////////////
+  // Routines to parse XML in the syntax of the Solr query
+  // response schema.
+  // Should these be moved to Config?  Should all of these things?
+  //////////////////////////////////////////////////////////
+  public static NamedList<Object> childNodesToNamedList(Node nd) {
+    return nodesToNamedList(nd.getChildNodes());
+  }
+
+  public static List childNodesToList(Node nd) {
+    return nodesToList(nd.getChildNodes());
+  }
+
+  public static NamedList<Object> nodesToNamedList(NodeList nlst) {
+    NamedList<Object> clst = new NamedList<Object>();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), clst, null);
+    }
+    return clst;
+  }
+
+  public static List nodesToList(NodeList nlst) {
+    List lst = new ArrayList();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), null, lst);
+    }
+    return lst;
+  }
+
+  /**
+   * Examines a Node from the DOM representation of a NamedList and adds the
+   * contents of that node to both the specified NamedList and List passed
+   * as arguments.
+   *
+   * @param nd The Node whose type will be used to determine how to parse the
+   *           text content.  If there is a 'name' attribute it will be used
+   *           when adding to the NamedList
+   * @param nlst A NamedList to add the item to with name if application.
+   *             If this param is null it will be ignored.
+   * @param arr A List to add the item to.
+   *             If this param is null it will be ignored.
+   */
+  @SuppressWarnings("unchecked")
+  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
+    // Nodes often include whitespace, etc... so just return if this
+    // is not an Element.
+    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
+
+    final String type = nd.getNodeName();
+
+    final String name = getAttr(nd, "name");
+
+    Object val=null;
+
+    if ("lst".equals(type)) {
+      val = childNodesToNamedList(nd);
+    } else if ("arr".equals(type)) {
+      val = childNodesToList(nd);
+    } else {
+      final String textValue = getText(nd);
+      try {
+        if ("str".equals(type)) {
+          val = textValue;
+        } else if ("int".equals(type)) {
+          val = Integer.valueOf(textValue);
+        } else if ("long".equals(type)) {
+          val = Long.valueOf(textValue);
+        } else if ("float".equals(type)) {
+          val = Float.valueOf(textValue);
+        } else if ("double".equals(type)) {
+          val = Double.valueOf(textValue);
+        } else if ("bool".equals(type)) {
+          val = StrUtils.parseBool(textValue);
+        }
+        // :NOTE: Unexpected Node names are ignored
+        // :TODO: should we generate an error here?
+      } catch (NumberFormatException nfe) {
+        throw new SolrException
+          (SolrException.ErrorCode.SERVER_ERROR,
+           "Value " + (null != name ? ("of '" +name+ "' ") : "") +
+           "can not be parsed as '" +type+ "': \"" + textValue + "\"",
+           nfe);
+      }
+    }
+
+    if (nlst != null) nlst.add(name,val);
+    if (arr != null) arr.add(val);
+  }
+
+  /**
+   * Drop in replacement for Node.getTextContent().
+   *
+   * <p>
+   * This method is provided to support the same functionality as
+   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
+   * </p>
+   *
+   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
+   */
+  public static String getText(Node nd) {
+
+    short type = nd.getNodeType();
+
+    // for most node types, we can defer to the recursive helper method,
+    // but when asked for the text of these types, we must return null
+    // (Not the empty string)
+    switch (type) {
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+      return null;
+    }
+
+    StringBuilder sb = new StringBuilder();
+    getText(nd, sb);
+    return sb.toString();
+  }
+
+  /** @see #getText(Node) */
+  private static void getText(Node nd, StringBuilder buf) {
+
+    short type = nd.getNodeType();
+
+    switch (type) {
+
+    case Node.ELEMENT_NODE: /* fall through */
+    case Node.ENTITY_NODE: /* fall through */
+    case Node.ENTITY_REFERENCE_NODE: /* fall through */
+    case Node.DOCUMENT_FRAGMENT_NODE:
+      NodeList childs = nd.getChildNodes();
+      for (int i = 0; i < childs.getLength(); i++) {
+        Node child = childs.item(i);
+        short childType = child.getNodeType();
+        if (childType != Node.COMMENT_NODE &&
+            childType != Node.PROCESSING_INSTRUCTION_NODE) {
+          getText(child, buf);
+        }
+      }
+      break;
+
+    case Node.ATTRIBUTE_NODE: /* fall through */
+      /* Putting Attribute nodes in this section does not exactly
+         match the definition of how textContent should behave
+         according to the DOM Level-3 Core documentation - which
+         specifies that the Attr's children should have their
+         textContent concated (Attr's can have a single child which
+         is either Text node or an EntityRefrence).  In practice,
+         DOM implementations do not seem to use child nodes of
+         Attributes, storing the "text" directly as the nodeValue.
+         Fortunately, the DOM Spec indicates that when Attr.nodeValue
+         is read, it should return the nodeValue from the child Node,
+         so this approach should work both for strict implementations,
+         and implementations actually encountered.
+      */
+    case Node.TEXT_NODE: /* fall through */
+    case Node.CDATA_SECTION_NODE: /* fall through */
+    case Node.COMMENT_NODE: /* fall through */
+    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
+      buf.append(nd.getNodeValue());
+      break;
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+    default:
+      /* :NOOP: */
+
+    }
+  }
+
+  /**
+   * Replaces ${system.property[:default value]} references in all attributes
+   * and text nodes of supplied node.  If the system property is not defined and no
+   * default value is provided, a runtime exception is thrown.
+   *
+   * @param node DOM node to walk for substitutions
+   */
+  public static void substituteSystemProperties(Node node) {
+    substituteProperties(node, null);
+  }
+
+  /**
+   * Replaces ${property[:default value]} references in all attributes
+   * and text nodes of supplied node.  If the property is not defined neither in the
+   * given Properties instance nor in System.getProperty and no
+   * default value is provided, a runtime exception is thrown.
+   *
+   * @param node DOM node to walk for substitutions
+   * @param properties the Properties instance from which a value can be looked up
+   */
+  public static void substituteProperties(Node node, Properties properties) {
+    // loop through child nodes
+    Node child;
+    Node next = node.getFirstChild();
+    while ((child = next) != null) {
+
+      // set next before we change anything
+      next = child.getNextSibling();
+
+      // handle child by node type
+      if (child.getNodeType() == Node.TEXT_NODE) {
+        child.setNodeValue(substituteProperty(child.getNodeValue(), properties));
+      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
+        // handle child elements with recursive call
+        NamedNodeMap attributes = child.getAttributes();
+        for (int i = 0; i < attributes.getLength(); i++) {
+          Node attribute = attributes.item(i);
+          attribute.setNodeValue(substituteProperty(attribute.getNodeValue(), properties));
+        }
+        substituteProperties(child, properties);
+      }
+    }
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.replaceProperties:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  public static String substituteProperty(String value, Properties coreProperties) {
+    if (value == null || value.indexOf('$') == -1) {
+      return value;
+    }
+
+    List<String> fragments = new ArrayList<String>();
+    List<String> propertyRefs = new ArrayList<String>();
+    parsePropertyString(value, fragments, propertyRefs);
+
+    StringBuilder sb = new StringBuilder();
+    Iterator<String> i = fragments.iterator();
+    Iterator<String> j = propertyRefs.iterator();
+
+    while (i.hasNext()) {
+      String fragment = i.next();
+      if (fragment == null) {
+        String propertyName = j.next();
+        String defaultValue = null;
+        int colon_index = propertyName.indexOf(':');
+        if (colon_index > -1) {
+          defaultValue = propertyName.substring(colon_index + 1);
+          propertyName = propertyName.substring(0,colon_index);
+        }
+        if (coreProperties != null) {
+          fragment = coreProperties.getProperty(propertyName);
+        }
+        if (fragment == null) {
+          fragment = System.getProperty(propertyName, defaultValue);
+        }
+        if (fragment == null) {
+          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName + " value:" + value);
+        }
+      }
+      sb.append(fragment);
+    }
+    return sb.toString();
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
+      int prev = 0;
+      int pos;
+      //search for the next instance of $ from the 'prev' position
+      while ((pos = value.indexOf("$", prev)) >= 0) {
+
+          //if there was any text before this, add it as a fragment
+          //TODO, this check could be modified to go if pos>prev;
+          //seems like this current version could stick empty strings
+          //into the list
+          if (pos > 0) {
+              fragments.add(value.substring(prev, pos));
+          }
+          //if we are at the end of the string, we tack on a $
+          //then move past it
+          if (pos == (value.length() - 1)) {
+              fragments.add("$");
+              prev = pos + 1;
+          } else if (value.charAt(pos + 1) != '{') {
+              //peek ahead to see if the next char is a property or not
+              //not a property: insert the char as a literal
+              /*
+              fragments.addElement(value.substring(pos + 1, pos + 2));
+              prev = pos + 2;
+              */
+              if (value.charAt(pos + 1) == '$') {
+                  //backwards compatibility two $ map to one mode
+                  fragments.add("$");
+                  prev = pos + 2;
+              } else {
+                  //new behaviour: $X maps to $X for all values of X!='$'
+                  fragments.add(value.substring(pos, pos + 2));
+                  prev = pos + 2;
+              }
+
+          } else {
+              //property found, extract its name or bail on a typo
+              int endName = value.indexOf('}', pos);
+              if (endName < 0) {
+                throw new RuntimeException("Syntax error in property: " + value);
+              }
+              String propertyName = value.substring(pos + 2, endName);
+              fragments.add(null);
+              propertyRefs.add(propertyName);
+              prev = endName + 1;
+          }
+      }
+      //no more $ signs found
+      //if there is any tail to the string, append it
+      if (prev < value.length()) {
+          fragments.add(value.substring(prev));
+      }
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/util/FastWriter.java b/solr/core/src/java/org/apache/solr/util/FastWriter.java
new file mode 100755
index 0000000..1935322
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/FastWriter.java
@@ -0,0 +1,128 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.Writer;
+import java.io.IOException;
+
+/** Single threaded BufferedWriter
+ *  Internal Solr use only, subject to change.
+ */
+public class FastWriter extends Writer {
+  // use default BUFSIZE of BufferedWriter so if we wrap that
+  // it won't cause double buffering.
+  private static final int BUFSIZE = 8192;
+  protected final Writer sink;
+  protected final char[] buf;
+  protected int pos;
+
+  public FastWriter(Writer w) {
+    this(w, new char[BUFSIZE], 0);
+  }
+
+  public FastWriter(Writer sink, char[] tempBuffer, int start) {
+    this.sink = sink;
+    this.buf = tempBuffer;
+    this.pos = start;
+  }
+
+  public static FastWriter wrap(Writer sink) {
+    return (sink instanceof FastWriter) ? (FastWriter)sink : new FastWriter(sink);
+  }
+
+  @Override
+  public void write(int c) throws IOException {
+    write((char)c); 
+  }
+
+  public void write(char c) throws IOException {
+    if (pos >= buf.length) {
+      sink.write(buf,0,pos);
+      pos=0;
+    }
+    buf[pos++] = c;
+  }
+
+  @Override
+  public FastWriter append(char c) throws IOException {
+    if (pos >= buf.length) {
+      sink.write(buf,0,pos);
+      pos=0;
+    }
+    buf[pos++] = c;
+    return this;
+  }
+
+  @Override
+  public void write(char cbuf[], int off, int len) throws IOException {
+    int space = buf.length - pos;
+    if (len < space) {
+      System.arraycopy(cbuf, off, buf, pos, len);
+      pos += len;
+    } else if (len<BUFSIZE) {
+      // if the data to write is small enough, buffer it.
+      System.arraycopy(cbuf, off, buf, pos, space);
+      sink.write(buf, 0, buf.length);
+      pos = len-space;
+      System.arraycopy(cbuf, off+space, buf, 0, pos);
+    } else {
+      sink.write(buf,0,pos);  // flush
+      pos=0;
+      // don't buffer, just write to sink
+      sink.write(cbuf, off, len);
+    }
+  }
+
+  @Override
+  public void write(String str, int off, int len) throws IOException {
+    int space = buf.length - pos;
+    if (len < space) {
+      str.getChars(off, off+len, buf, pos);
+      pos += len;
+    } else if (len<BUFSIZE) {
+      // if the data to write is small enough, buffer it.
+      str.getChars(off, off+space, buf, pos);
+      sink.write(buf, 0, buf.length);
+      str.getChars(off+space, off+len, buf, 0);
+      pos = len-space;
+    } else {
+      sink.write(buf,0,pos);  // flush
+      pos=0;
+      // don't buffer, just write to sink
+      sink.write(str, off, len);
+    }
+  }
+
+  @Override
+  public void flush() throws IOException {
+    sink.write(buf,0,pos);
+    pos=0;
+    sink.flush();
+  }
+
+  @Override
+  public void close() throws IOException {
+    flush();
+    sink.close();
+  }
+
+  public void flushBuffer() throws IOException {
+    sink.write(buf, 0, pos);
+    pos=0;
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/util/FileUtils.java b/solr/core/src/java/org/apache/solr/util/FileUtils.java
new file mode 100644
index 0000000..e54634e
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/FileUtils.java
@@ -0,0 +1,97 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.*;
+import java.nio.channels.FileChannel;
+
+/**
+ *
+ */
+public class FileUtils {
+
+  /**
+   * Resolves a path relative a base directory.
+   *
+   * <p>
+   * This method does what "new File(base,path)" <b>Should</b> do, it wasn't
+   * completely lame: If path is absolute, then a File for that path is returned;
+   * if it's not absoluve, then a File is returnd using "path" as a child 
+   * of "base")
+   * </p>
+   */
+  public static File resolvePath(File base, String path) {
+    File r = new File(path);
+    return r.isAbsolute() ? r : new File(base, path);
+  }
+
+  public static void copyFile(File src , File destination) throws IOException {
+    FileChannel in = null;
+    FileChannel out = null;
+    try {
+      in = new FileInputStream(src).getChannel();
+      out = new FileOutputStream(destination).getChannel();
+      in.transferTo(0, in.size(), out);
+    } finally {
+      try { if (in != null) in.close(); } catch (IOException e) {}
+      try { if (out != null) out.close(); } catch (IOException e) {}
+    }
+  }
+
+  /**
+   * Copied from Lucene's FSDirectory.fsync(String) <!-- protected -->
+   *
+   * @param fullFile the File to be synced to disk
+   * @throws IOException if the file could not be synced
+   */
+  public static void sync(File fullFile) throws IOException  {
+    if (fullFile == null || !fullFile.exists())
+      throw new FileNotFoundException("File does not exist " + fullFile);
+
+    boolean success = false;
+    int retryCount = 0;
+    IOException exc = null;
+    while(!success && retryCount < 5) {
+      retryCount++;
+      RandomAccessFile file = null;
+      try {
+        try {
+          file = new RandomAccessFile(fullFile, "rw");
+          file.getFD().sync();
+          success = true;
+        } finally {
+          if (file != null)
+            file.close();
+        }
+      } catch (IOException ioe) {
+        if (exc == null)
+          exc = ioe;
+        try {
+          // Pause 5 msec
+          Thread.sleep(5);
+        } catch (InterruptedException ie) {
+          Thread.currentThread().interrupt();
+        }
+      }
+    }
+    if (!success)
+      // Throw original exception
+      throw exc;
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/util/RTimer.java b/solr/core/src/java/org/apache/solr/util/RTimer.java
new file mode 100644
index 0000000..2cbd044
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/RTimer.java
@@ -0,0 +1,157 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+import java.lang.System;
+import java.lang.Thread;
+import java.util.*;
+
+/** A recursive timer.
+ * 
+ * RTimers are started automatically when instantiated; subtimers are also
+ * started automatically when created.
+ *
+ * @since solr 1.3
+ *
+ */
+public class RTimer {
+
+  public static final int STARTED = 0;
+  public static final int STOPPED = 1;
+  public static final int PAUSED = 2;
+
+  protected int state;
+  protected double startTime;
+  protected double time;
+  protected double culmTime;
+  protected SimpleOrderedMap<RTimer> children;
+
+  public RTimer() {
+    time = 0;
+    culmTime = 0;
+    children = new SimpleOrderedMap<RTimer>();
+    startTime = now();
+    state = STARTED;
+  }
+
+  /** Get current time
+   *
+   * May override to implement a different timer (CPU time, etc).
+   */
+  protected double now() { return System.currentTimeMillis(); }
+
+  /** Recursively stop timer and sub timers */
+  public double stop() {
+    assert state == STARTED || state == PAUSED;
+    time = culmTime;
+    if(state == STARTED) 
+      time += now() - startTime;
+    state = STOPPED;
+    
+    for( Map.Entry<String,RTimer> entry : children ) {
+      RTimer child = entry.getValue();
+      if(child.state == STARTED || child.state == PAUSED) 
+        child.stop();
+    }
+    return time;
+  }
+
+  public void pause() {
+    assert state == STARTED;
+    culmTime += now() - startTime;
+    state = PAUSED;
+  }
+  
+  public void resume() {
+    if(state == STARTED)
+      return;
+    assert state == PAUSED;
+    state = STARTED;
+    startTime = now();
+  }
+
+  /** Get total elapsed time for this timer.
+   *
+   * Timer must be STOPped.
+   */
+  public double getTime() {
+    assert state == STOPPED;
+    return time;
+  }
+
+  /** Create new subtimer with given name
+   *
+   * Subtimer will be started.
+   */
+  public RTimer sub(String desc) {
+    RTimer child = children.get( desc );
+    if( child == null ) {
+      child = new RTimer();
+      children.add(desc, child);
+    }
+    return child;
+  }
+
+  @Override
+  public String toString() {
+    return asNamedList().toString();
+  }
+
+  public NamedList asNamedList() {
+    NamedList<Object> m = new SimpleOrderedMap<Object>();
+    m.add( "time", time );
+    if( children.size() > 0 ) {
+      for( Map.Entry<String, RTimer> entry : children ) {
+        m.add( entry.getKey(), entry.getValue().asNamedList() );
+      }
+    }
+    return m;
+  }
+  
+  /**
+   * Manipulating this map may have undefined results.
+   */
+  public SimpleOrderedMap<RTimer> getChildren()
+  {
+    return children;
+  }
+
+  /*************** Testing *******/
+  public static void main(String []argv) throws InterruptedException {
+    RTimer rt = new RTimer(), subt, st;
+    Thread.sleep(100);
+
+    subt = rt.sub("sub1");
+    Thread.sleep(50);
+    st = subt.sub("sub1.1");
+    st.resume();
+    Thread.sleep(10);
+    st.pause();
+    Thread.sleep(50);
+    st.resume();
+    Thread.sleep(10);
+    st.pause();
+    subt.stop();
+    rt.stop();
+
+    System.out.println( rt.toString());
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/util/RegexFileFilter.java b/solr/core/src/java/org/apache/solr/util/RegexFileFilter.java
new file mode 100644
index 0000000..346bf2d
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/RegexFileFilter.java
@@ -0,0 +1,44 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.FileFilter;
+import java.util.regex.*;
+
+/**
+ * Accepts any file whose name matches the pattern
+ *
+ */
+public final class RegexFileFilter implements FileFilter {
+
+  final Pattern pattern;
+  public RegexFileFilter(String regex) {
+    this(Pattern.compile(regex));
+  }
+  public RegexFileFilter(Pattern regex) {
+    pattern = regex;
+  }
+  public boolean accept(File f) {
+    return pattern.matcher(f.getName()).matches();
+  }
+  @Override
+  public String toString() {
+    return "regex:" + pattern.toString();
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/util/SystemIdResolver.java b/solr/core/src/java/org/apache/solr/util/SystemIdResolver.java
new file mode 100644
index 0000000..145bce7
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/util/SystemIdResolver.java
@@ -0,0 +1,176 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.solr.common.ResourceLoader;
+
+import org.xml.sax.InputSource;
+import org.xml.sax.EntityResolver;
+import org.xml.sax.ext.EntityResolver2;
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import javax.xml.transform.Source;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.URIResolver;
+import javax.xml.transform.sax.SAXSource;
+import javax.xml.stream.XMLResolver;
+import javax.xml.stream.XMLStreamException;
+
+/**
+ * This is a helper class to support resolving of XIncludes or other hrefs
+ * inside XML files on top of a {@link ResourceLoader}. Just plug this class
+ * on top of a {@link ResourceLoader} and pass it as {@link EntityResolver} to SAX parsers
+ * or via wrapper methods as {@link URIResolver} to XSL transformers or {@link XMLResolver} to STAX parsers.
+ * The resolver handles special SystemIds with an URI scheme of {@code solrres:} that point
+ * to resources. To produce such systemIds when you initially call the parser, use
+ * {@link #createSystemIdFromResourceName} which produces a SystemId that can
+ * be included along the InputStream coming from {@link ResourceLoader#openResource}.
+ * <p>In general create the {@link InputSource} to be passed to the parser like:</p>
+ * <pre class="prettyprint">
+ *  InputSource is = new InputSource(loader.openSchema(name));
+ *  is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(name));
+ *  final DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+ *  db.setEntityResolver(new SystemIdResolver(loader));
+ *  Document doc = db.parse(is);
+ * </pre>
+ */
+public final class SystemIdResolver implements EntityResolver, EntityResolver2 {
+  private static final Logger log = LoggerFactory.getLogger(SystemIdResolver.class);
+
+  public static final String RESOURCE_LOADER_URI_SCHEME = "solrres";
+  public static final String RESOURCE_LOADER_AUTHORITY_ABSOLUTE = "@";
+
+  private final ResourceLoader loader;
+
+  public SystemIdResolver(ResourceLoader loader) {
+    this.loader = loader;
+  }
+  
+  public EntityResolver asEntityResolver() {
+    return this;
+  }
+  
+  public URIResolver asURIResolver() {
+    return new URIResolver() {
+      public Source resolve(String href, String base) throws TransformerException {
+        try {
+          final InputSource src = SystemIdResolver.this.resolveEntity(null, null, base, href);
+          return (src == null) ? null : new SAXSource(src);
+        } catch (IOException ioe) {
+          throw new TransformerException("Cannot resolve entity", ioe);
+        }
+      }
+    };
+  }
+  
+  public XMLResolver asXMLResolver() {
+    return new XMLResolver() {
+      public Object resolveEntity(String publicId, String systemId, String baseURI, String namespace) throws XMLStreamException {
+        try {
+          final InputSource src = SystemIdResolver.this.resolveEntity(null, publicId, baseURI, systemId);
+          return (src == null) ? null : src.getByteStream();
+        } catch (IOException ioe) {
+          throw new XMLStreamException("Cannot resolve entity", ioe);
+        }
+      }
+    };
+  }
+  
+  URI resolveRelativeURI(String baseURI, String systemId) throws IOException,URISyntaxException {
+    URI uri;
+    
+    // special case for backwards compatibility: if relative systemId starts with "/" (we convert that to an absolute solrres:-URI)
+    if (systemId.startsWith("/")) {
+      uri = new URI(RESOURCE_LOADER_URI_SCHEME, RESOURCE_LOADER_AUTHORITY_ABSOLUTE, "/", null, null).resolve(systemId);
+    } else {
+      // simply parse as URI
+      uri = new URI(systemId);
+    }
+    
+    // do relative resolving
+    if (baseURI != null ) {
+      uri = new URI(baseURI).resolve(uri);
+    }
+    
+    return uri;
+  }
+  
+  // *** EntityResolver(2) methods:
+  
+  public InputSource getExternalSubset(String name, String baseURI) {
+    return null;
+  }
+  
+  public InputSource resolveEntity(String name, String publicId, String baseURI, String systemId) throws IOException {
+    if (systemId == null)
+      return null;
+    try {
+      final URI uri = resolveRelativeURI(baseURI, systemId);
+      
+      // check schema and resolve with ResourceLoader
+      if (RESOURCE_LOADER_URI_SCHEME.equals(uri.getScheme())) {
+        String path = uri.getPath(), authority = uri.getAuthority();
+        if (!RESOURCE_LOADER_AUTHORITY_ABSOLUTE.equals(authority)) {
+          path = path.substring(1);
+        }
+        try {
+          final InputSource is = new InputSource(loader.openResource(path));
+          is.setSystemId(uri.toASCIIString());
+          is.setPublicId(publicId);
+          return is;
+        } catch (RuntimeException re) {
+          // unfortunately XInclude fallback only works with IOException, but openResource() never throws that one
+          throw (IOException) (new IOException(re.getMessage()).initCause(re));
+        }
+      } else {
+        // resolve all other URIs using the standard resolver
+        return null;
+      }
+    } catch (URISyntaxException use) {
+      log.warn("An URI systax problem occurred during resolving SystemId, falling back to default resolver", use);
+      return null;
+    }
+  }
+
+  public InputSource resolveEntity(String publicId, String systemId) throws IOException {
+    return resolveEntity(null, publicId, null, systemId);
+  }
+  
+  public static String createSystemIdFromResourceName(String name) {
+    name = name.replace(File.separatorChar, '/');
+    final String authority;
+    if (name.startsWith("/")) {
+      // a hack to preserve absolute filenames and keep them absolute after resolving, we set the URI's authority to "@" on absolute filenames:
+      authority = RESOURCE_LOADER_AUTHORITY_ABSOLUTE;
+    } else {
+      authority = null;
+      name = "/" + name;
+    }
+    try {
+      return new URI(RESOURCE_LOADER_URI_SCHEME, authority, name, null, null).toASCIIString();
+    } catch (URISyntaxException use) {
+      throw new IllegalArgumentException("Invalid syntax of Solr Resource URI", use);
+    }
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/util/plugin/AbstractPluginLoader.java b/solr/core/src/java/org/apache/solr/util/plugin/AbstractPluginLoader.java
index f22091a..ec5bc60 100644
--- a/solr/core/src/java/org/apache/solr/util/plugin/AbstractPluginLoader.java
+++ b/solr/core/src/java/org/apache/solr/util/plugin/AbstractPluginLoader.java
@@ -25,7 +25,7 @@ import org.slf4j.LoggerFactory;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.apache.solr.core.SolrConfig;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
diff --git a/solr/core/src/java/org/apache/solr/util/plugin/MapPluginLoader.java b/solr/core/src/java/org/apache/solr/util/plugin/MapPluginLoader.java
index 3f28494..77a5bcf 100644
--- a/solr/core/src/java/org/apache/solr/util/plugin/MapPluginLoader.java
+++ b/solr/core/src/java/org/apache/solr/util/plugin/MapPluginLoader.java
@@ -19,7 +19,7 @@ package org.apache.solr.util.plugin;
 
 import java.util.Map;
 
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.w3c.dom.Node;
 
 /**
diff --git a/solr/core/src/java/org/apache/solr/util/plugin/NamedListPluginLoader.java b/solr/core/src/java/org/apache/solr/util/plugin/NamedListPluginLoader.java
index 13ad5fe..6d03480 100644
--- a/solr/core/src/java/org/apache/solr/util/plugin/NamedListPluginLoader.java
+++ b/solr/core/src/java/org/apache/solr/util/plugin/NamedListPluginLoader.java
@@ -19,7 +19,7 @@ package org.apache.solr.util.plugin;
 
 import java.util.Map;
 
-import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.util.DOMUtil;
 import org.w3c.dom.Node;
 
 /**
diff --git a/solr/core/src/java/org/apache/solr/util/xslt/TransformerProvider.java b/solr/core/src/java/org/apache/solr/util/xslt/TransformerProvider.java
index 8a2f58b..1ccfc49 100644
--- a/solr/core/src/java/org/apache/solr/util/xslt/TransformerProvider.java
+++ b/solr/core/src/java/org/apache/solr/util/xslt/TransformerProvider.java
@@ -30,7 +30,7 @@ import javax.xml.transform.TransformerFactory;
 import javax.xml.transform.stream.StreamSource;
 
 import org.apache.solr.common.ResourceLoader;
-import org.apache.solr.common.util.SystemIdResolver;
+import org.apache.solr.util.SystemIdResolver;
 import org.apache.solr.common.util.XMLErrorLogger;
 import org.apache.solr.core.SolrConfig;
 
diff --git a/solr/core/src/test/org/apache/solr/handler/component/DistributedQueryElevationComponentTest.java b/solr/core/src/test/org/apache/solr/handler/component/DistributedQueryElevationComponentTest.java
index 3a16039..05deb9e 100644
--- a/solr/core/src/test/org/apache/solr/handler/component/DistributedQueryElevationComponentTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/component/DistributedQueryElevationComponentTest.java
@@ -23,7 +23,7 @@ import java.io.IOException;
 import org.apache.solr.BaseDistributedSearchTestCase;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.util.FileUtils;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
diff --git a/solr/core/src/test/org/apache/solr/handler/component/QueryElevationComponentTest.java b/solr/core/src/test/org/apache/solr/handler/component/QueryElevationComponentTest.java
index ea9e5ca..ec59ea3 100644
--- a/solr/core/src/test/org/apache/solr/handler/component/QueryElevationComponentTest.java
+++ b/solr/core/src/test/org/apache/solr/handler/component/QueryElevationComponentTest.java
@@ -23,7 +23,7 @@ import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.QueryElevationParams;
-import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.util.FileUtils;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.component.QueryElevationComponent.ElevationObj;
diff --git a/solr/core/src/test/org/apache/solr/util/DOMUtilTest.java b/solr/core/src/test/org/apache/solr/util/DOMUtilTest.java
new file mode 100644
index 0000000..e7c7333
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/util/DOMUtilTest.java
@@ -0,0 +1,59 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.util.DOMUtilTestBase;
+
+public class DOMUtilTest extends DOMUtilTestBase {
+  
+  public void testAddToNamedListPrimitiveTypes() throws Exception {
+    NamedList<Object> namedList = new SimpleOrderedMap<Object>();
+    DOMUtil.addToNamedList( getNode( "<str name=\"String\">STRING</str>", "/str" ), namedList, null );
+    assertTypeAndValue( namedList, "String", "STRING" );
+    DOMUtil.addToNamedList( getNode( "<int name=\"Integer\">100</int>", "/int" ), namedList, null );
+    assertTypeAndValue( namedList, "Integer", Integer.valueOf( 100 ) );
+    DOMUtil.addToNamedList( getNode( "<long name=\"Long\">200</long>", "/long" ), namedList, null );
+    assertTypeAndValue( namedList, "Long", Long.valueOf( 200 ) );
+    DOMUtil.addToNamedList( getNode( "<float name=\"Float\">300</float>", "/float" ), namedList, null );
+    assertTypeAndValue( namedList, "Float", Float.valueOf( 300 ) );
+    DOMUtil.addToNamedList( getNode( "<double name=\"Double\">400</double>", "/double" ), namedList, null );
+    assertTypeAndValue( namedList, "Double", Double.valueOf( 400 ) );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">true</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", true );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">on</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", true );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">yes</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", true );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">false</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", false );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">off</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", false );
+    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">no</bool>", "/bool" ), namedList, null );
+    assertTypeAndValue( namedList, "Boolean", false );
+  }
+
+  private void assertTypeAndValue( NamedList<Object> namedList, String key, Object value ) throws Exception {
+    Object v = namedList.get( key );
+    assertNotNull( v );
+    assertEquals( key, v.getClass().getSimpleName() );
+    assertEquals( value, v );
+    namedList.remove( key );
+  }
+}
diff --git a/solr/core/src/test/org/apache/solr/util/FileUtilsTest.java b/solr/core/src/test/org/apache/solr/util/FileUtilsTest.java
new file mode 100644
index 0000000..ecf29a7
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/util/FileUtilsTest.java
@@ -0,0 +1,33 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.IOException;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class FileUtilsTest extends LuceneTestCase {  
+
+  public void testResolve() throws IOException {
+    String cwd = new File(".").getAbsolutePath();
+    assertEquals(new File("conf/data"), FileUtils.resolvePath(new File("conf"), "data"));
+    assertEquals(new File(cwd+"/conf/data"), FileUtils.resolvePath(new File(cwd+"/conf"), "data"));
+    assertEquals(new File(cwd+"/data"), FileUtils.resolvePath(new File("conf"), cwd+"/data"));
+  }
+}
diff --git a/solr/core/src/test/org/apache/solr/util/TestSystemIdResolver.java b/solr/core/src/test/org/apache/solr/util/TestSystemIdResolver.java
new file mode 100644
index 0000000..6cc3e0b
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/util/TestSystemIdResolver.java
@@ -0,0 +1,73 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.core.SolrResourceLoader;
+import org.apache.solr.common.ResourceLoader;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.solr.SolrTestCaseJ4;
+
+import java.io.File;
+import org.xml.sax.InputSource;
+import org.apache.commons.io.IOUtils;
+
+public class TestSystemIdResolver extends LuceneTestCase {
+  
+  private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {
+    final InputSource is = resolver.resolveEntity(null, null, base, systemId);
+    try {
+      assertEquals("Resolved SystemId does not match", expectedSystemId, is.getSystemId());
+    } finally {
+      IOUtils.closeQuietly(is.getByteStream());
+    }
+  }
+  
+  public void testResolving() throws Exception {
+    final String testHome = SolrTestCaseJ4.getFile("solr/conf").getParent();
+    final ResourceLoader loader = new SolrResourceLoader(testHome, this.getClass().getClassLoader());
+    final SystemIdResolver resolver = new SystemIdResolver(loader);
+    final String fileUri = new File(testHome+"/crazy-path-to-config.xml").toURI().toASCIIString();
+    
+    assertEquals("solrres:/test.xml", SystemIdResolver.createSystemIdFromResourceName("test.xml"));
+    assertEquals("solrres://@/usr/local/etc/test.xml", SystemIdResolver.createSystemIdFromResourceName("/usr/local/etc/test.xml"));
+    assertEquals("solrres://@/test.xml", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+"test.xml"));
+    
+    // check relative URI resolving
+    assertEquals("solrres:/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "test.xml").toASCIIString());
+    assertEquals("solrres://@/etc/test.xml",
+      resolver.resolveRelativeURI("solrres://@/usr/local/etc/base.xml", "../../../etc/test.xml").toASCIIString());
+    // special case: if relative URI starts with "/" convert to an absolute solrres://@/-URI
+    assertEquals("solrres://@/a/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "/a/test.xml").toASCIIString());
+    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved
+    assertEquals(fileUri, resolver.resolveRelativeURI("solrres:/base.xml", fileUri).toASCIIString());
+    assertEquals("solrres:/base.xml", resolver.resolveRelativeURI(fileUri, "solrres:/base.xml").toASCIIString());
+    
+    // do some real resolves to InputStreams with real existing files
+    assertEntityResolving(resolver, "solrres:/schema.xml", "solrres:/solrconfig.xml", "schema.xml");
+    assertEntityResolving(resolver, "solrres:/org/apache/solr/util/TestSystemIdResolver.class",
+      "solrres:/org/apache/solr/util/RTimer.class", "TestSystemIdResolver.class");
+    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/conf/schema.xml"),
+      SystemIdResolver.createSystemIdFromResourceName(testHome+"/conf/solrconfig.xml"), "schema.xml");
+    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-schema.xml"),
+      SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-config.xml"), "crazy-path-to-schema.xml");
+    
+    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, the resolver should return null (default fallback)
+    assertNull(resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", fileUri));
+  }
+
+}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/DOMUtil.java b/solr/solrj/src/java/org/apache/solr/common/util/DOMUtil.java
deleted file mode 100644
index d9e18e2..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/DOMUtil.java
+++ /dev/null
@@ -1,397 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.util.*;
-
-import org.apache.solr.common.SolrException;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-/**
- *
- */
-public class DOMUtil {
-
-  public static Map<String,String> toMap(NamedNodeMap attrs) {
-    return toMapExcept(attrs);
-  }
-
-  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
-    Map<String,String> args = new HashMap<String,String>();
-    outer: for (int j=0; j<attrs.getLength(); j++) {
-      Node attr = attrs.item(j);
-      String attrName = attr.getNodeName();
-      for (String ex : exclusions)
-        if (ex.equals(attrName)) continue outer;
-      String val = attr.getNodeValue();
-      args.put(attrName, val);
-    }
-    return args;
-  }
-
-  public static Node getChild(Node node, String name) {
-    if (!node.hasChildNodes()) return null;
-    NodeList lst = node.getChildNodes();
-    if (lst == null) return null;
-    for (int i=0; i<lst.getLength(); i++) {
-      Node child = lst.item(i);
-      if (name.equals(child.getNodeName())) return child;
-    }
-    return null;
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name) {
-    return getAttr(attrs,name,null);
-  }
-
-  public static String getAttr(Node nd, String name) {
-    return getAttr(nd.getAttributes(), name);
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
-    Node attr = attrs==null? null : attrs.getNamedItem(name);
-    if (attr==null) {
-      if (missing_err==null) return null;
-      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
-    }
-    String val = attr.getNodeValue();
-    return val;
-  }
-
-  public static String getAttr(Node node, String name, String missing_err) {
-    return getAttr(node.getAttributes(), name, missing_err);
-  }
-
-  //////////////////////////////////////////////////////////
-  // Routines to parse XML in the syntax of the Solr query
-  // response schema.
-  // Should these be moved to Config?  Should all of these things?
-  //////////////////////////////////////////////////////////
-  public static NamedList<Object> childNodesToNamedList(Node nd) {
-    return nodesToNamedList(nd.getChildNodes());
-  }
-
-  public static List childNodesToList(Node nd) {
-    return nodesToList(nd.getChildNodes());
-  }
-
-  public static NamedList<Object> nodesToNamedList(NodeList nlst) {
-    NamedList<Object> clst = new NamedList<Object>();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), clst, null);
-    }
-    return clst;
-  }
-
-  public static List nodesToList(NodeList nlst) {
-    List lst = new ArrayList();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), null, lst);
-    }
-    return lst;
-  }
-
-  /**
-   * Examines a Node from the DOM representation of a NamedList and adds the
-   * contents of that node to both the specified NamedList and List passed
-   * as arguments.
-   *
-   * @param nd The Node whose type will be used to determine how to parse the
-   *           text content.  If there is a 'name' attribute it will be used
-   *           when adding to the NamedList
-   * @param nlst A NamedList to add the item to with name if application.
-   *             If this param is null it will be ignored.
-   * @param arr A List to add the item to.
-   *             If this param is null it will be ignored.
-   */
-  @SuppressWarnings("unchecked")
-  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
-    // Nodes often include whitespace, etc... so just return if this
-    // is not an Element.
-    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
-
-    final String type = nd.getNodeName();
-
-    final String name = getAttr(nd, "name");
-
-    Object val=null;
-
-    if ("lst".equals(type)) {
-      val = childNodesToNamedList(nd);
-    } else if ("arr".equals(type)) {
-      val = childNodesToList(nd);
-    } else {
-      final String textValue = getText(nd);
-      try {
-        if ("str".equals(type)) {
-          val = textValue;
-        } else if ("int".equals(type)) {
-          val = Integer.valueOf(textValue);
-        } else if ("long".equals(type)) {
-          val = Long.valueOf(textValue);
-        } else if ("float".equals(type)) {
-          val = Float.valueOf(textValue);
-        } else if ("double".equals(type)) {
-          val = Double.valueOf(textValue);
-        } else if ("bool".equals(type)) {
-          val = StrUtils.parseBool(textValue);
-        }
-        // :NOTE: Unexpected Node names are ignored
-        // :TODO: should we generate an error here?
-      } catch (NumberFormatException nfe) {
-        throw new SolrException
-          (SolrException.ErrorCode.SERVER_ERROR,
-           "Value " + (null != name ? ("of '" +name+ "' ") : "") +
-           "can not be parsed as '" +type+ "': \"" + textValue + "\"",
-           nfe);
-      }
-    }
-
-    if (nlst != null) nlst.add(name,val);
-    if (arr != null) arr.add(val);
-  }
-
-  /**
-   * Drop in replacement for Node.getTextContent().
-   *
-   * <p>
-   * This method is provided to support the same functionality as
-   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
-   * </p>
-   *
-   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
-   */
-  public static String getText(Node nd) {
-
-    short type = nd.getNodeType();
-
-    // for most node types, we can defer to the recursive helper method,
-    // but when asked for the text of these types, we must return null
-    // (Not the empty string)
-    switch (type) {
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-      return null;
-    }
-
-    StringBuilder sb = new StringBuilder();
-    getText(nd, sb);
-    return sb.toString();
-  }
-
-  /** @see #getText(Node) */
-  private static void getText(Node nd, StringBuilder buf) {
-
-    short type = nd.getNodeType();
-
-    switch (type) {
-
-    case Node.ELEMENT_NODE: /* fall through */
-    case Node.ENTITY_NODE: /* fall through */
-    case Node.ENTITY_REFERENCE_NODE: /* fall through */
-    case Node.DOCUMENT_FRAGMENT_NODE:
-      NodeList childs = nd.getChildNodes();
-      for (int i = 0; i < childs.getLength(); i++) {
-        Node child = childs.item(i);
-        short childType = child.getNodeType();
-        if (childType != Node.COMMENT_NODE &&
-            childType != Node.PROCESSING_INSTRUCTION_NODE) {
-          getText(child, buf);
-        }
-      }
-      break;
-
-    case Node.ATTRIBUTE_NODE: /* fall through */
-      /* Putting Attribute nodes in this section does not exactly
-         match the definition of how textContent should behave
-         according to the DOM Level-3 Core documentation - which
-         specifies that the Attr's children should have their
-         textContent concated (Attr's can have a single child which
-         is either Text node or an EntityRefrence).  In practice,
-         DOM implementations do not seem to use child nodes of
-         Attributes, storing the "text" directly as the nodeValue.
-         Fortunately, the DOM Spec indicates that when Attr.nodeValue
-         is read, it should return the nodeValue from the child Node,
-         so this approach should work both for strict implementations,
-         and implementations actually encountered.
-      */
-    case Node.TEXT_NODE: /* fall through */
-    case Node.CDATA_SECTION_NODE: /* fall through */
-    case Node.COMMENT_NODE: /* fall through */
-    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
-      buf.append(nd.getNodeValue());
-      break;
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-    default:
-      /* :NOOP: */
-
-    }
-  }
-
-  /**
-   * Replaces ${system.property[:default value]} references in all attributes
-   * and text nodes of supplied node.  If the system property is not defined and no
-   * default value is provided, a runtime exception is thrown.
-   *
-   * @param node DOM node to walk for substitutions
-   */
-  public static void substituteSystemProperties(Node node) {
-    substituteProperties(node, null);
-  }
-
-  /**
-   * Replaces ${property[:default value]} references in all attributes
-   * and text nodes of supplied node.  If the property is not defined neither in the
-   * given Properties instance nor in System.getProperty and no
-   * default value is provided, a runtime exception is thrown.
-   *
-   * @param node DOM node to walk for substitutions
-   * @param properties the Properties instance from which a value can be looked up
-   */
-  public static void substituteProperties(Node node, Properties properties) {
-    // loop through child nodes
-    Node child;
-    Node next = node.getFirstChild();
-    while ((child = next) != null) {
-
-      // set next before we change anything
-      next = child.getNextSibling();
-
-      // handle child by node type
-      if (child.getNodeType() == Node.TEXT_NODE) {
-        child.setNodeValue(substituteProperty(child.getNodeValue(), properties));
-      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
-        // handle child elements with recursive call
-        NamedNodeMap attributes = child.getAttributes();
-        for (int i = 0; i < attributes.getLength(); i++) {
-          Node attribute = attributes.item(i);
-          attribute.setNodeValue(substituteProperty(attribute.getNodeValue(), properties));
-        }
-        substituteProperties(child, properties);
-      }
-    }
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.replaceProperties:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  public static String substituteProperty(String value, Properties coreProperties) {
-    if (value == null || value.indexOf('$') == -1) {
-      return value;
-    }
-
-    List<String> fragments = new ArrayList<String>();
-    List<String> propertyRefs = new ArrayList<String>();
-    parsePropertyString(value, fragments, propertyRefs);
-
-    StringBuilder sb = new StringBuilder();
-    Iterator<String> i = fragments.iterator();
-    Iterator<String> j = propertyRefs.iterator();
-
-    while (i.hasNext()) {
-      String fragment = i.next();
-      if (fragment == null) {
-        String propertyName = j.next();
-        String defaultValue = null;
-        int colon_index = propertyName.indexOf(':');
-        if (colon_index > -1) {
-          defaultValue = propertyName.substring(colon_index + 1);
-          propertyName = propertyName.substring(0,colon_index);
-        }
-        if (coreProperties != null) {
-          fragment = coreProperties.getProperty(propertyName);
-        }
-        if (fragment == null) {
-          fragment = System.getProperty(propertyName, defaultValue);
-        }
-        if (fragment == null) {
-          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName + " value:" + value);
-        }
-      }
-      sb.append(fragment);
-    }
-    return sb.toString();
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
-      int prev = 0;
-      int pos;
-      //search for the next instance of $ from the 'prev' position
-      while ((pos = value.indexOf("$", prev)) >= 0) {
-
-          //if there was any text before this, add it as a fragment
-          //TODO, this check could be modified to go if pos>prev;
-          //seems like this current version could stick empty strings
-          //into the list
-          if (pos > 0) {
-              fragments.add(value.substring(prev, pos));
-          }
-          //if we are at the end of the string, we tack on a $
-          //then move past it
-          if (pos == (value.length() - 1)) {
-              fragments.add("$");
-              prev = pos + 1;
-          } else if (value.charAt(pos + 1) != '{') {
-              //peek ahead to see if the next char is a property or not
-              //not a property: insert the char as a literal
-              /*
-              fragments.addElement(value.substring(pos + 1, pos + 2));
-              prev = pos + 2;
-              */
-              if (value.charAt(pos + 1) == '$') {
-                  //backwards compatibility two $ map to one mode
-                  fragments.add("$");
-                  prev = pos + 2;
-              } else {
-                  //new behaviour: $X maps to $X for all values of X!='$'
-                  fragments.add(value.substring(pos, pos + 2));
-                  prev = pos + 2;
-              }
-
-          } else {
-              //property found, extract its name or bail on a typo
-              int endName = value.indexOf('}', pos);
-              if (endName < 0) {
-                throw new RuntimeException("Syntax error in property: " + value);
-              }
-              String propertyName = value.substring(pos + 2, endName);
-              fragments.add(null);
-              propertyRefs.add(propertyName);
-              prev = endName + 1;
-          }
-      }
-      //no more $ signs found
-      //if there is any tail to the string, append it
-      if (prev < value.length()) {
-          fragments.add(value.substring(prev));
-      }
-  }
-
-}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/FastWriter.java b/solr/solrj/src/java/org/apache/solr/common/util/FastWriter.java
deleted file mode 100755
index 4ea49df..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/FastWriter.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.Writer;
-import java.io.IOException;
-
-/** Single threaded BufferedWriter
- *  Internal Solr use only, subject to change.
- */
-public class FastWriter extends Writer {
-  // use default BUFSIZE of BufferedWriter so if we wrap that
-  // it won't cause double buffering.
-  private static final int BUFSIZE = 8192;
-  protected final Writer sink;
-  protected final char[] buf;
-  protected int pos;
-
-  public FastWriter(Writer w) {
-    this(w, new char[BUFSIZE], 0);
-  }
-
-  public FastWriter(Writer sink, char[] tempBuffer, int start) {
-    this.sink = sink;
-    this.buf = tempBuffer;
-    this.pos = start;
-  }
-
-  public static FastWriter wrap(Writer sink) {
-    return (sink instanceof FastWriter) ? (FastWriter)sink : new FastWriter(sink);
-  }
-
-  @Override
-  public void write(int c) throws IOException {
-    write((char)c); 
-  }
-
-  public void write(char c) throws IOException {
-    if (pos >= buf.length) {
-      sink.write(buf,0,pos);
-      pos=0;
-    }
-    buf[pos++] = c;
-  }
-
-  @Override
-  public FastWriter append(char c) throws IOException {
-    if (pos >= buf.length) {
-      sink.write(buf,0,pos);
-      pos=0;
-    }
-    buf[pos++] = c;
-    return this;
-  }
-
-  @Override
-  public void write(char cbuf[], int off, int len) throws IOException {
-    int space = buf.length - pos;
-    if (len < space) {
-      System.arraycopy(cbuf, off, buf, pos, len);
-      pos += len;
-    } else if (len<BUFSIZE) {
-      // if the data to write is small enough, buffer it.
-      System.arraycopy(cbuf, off, buf, pos, space);
-      sink.write(buf, 0, buf.length);
-      pos = len-space;
-      System.arraycopy(cbuf, off+space, buf, 0, pos);
-    } else {
-      sink.write(buf,0,pos);  // flush
-      pos=0;
-      // don't buffer, just write to sink
-      sink.write(cbuf, off, len);
-    }
-  }
-
-  @Override
-  public void write(String str, int off, int len) throws IOException {
-    int space = buf.length - pos;
-    if (len < space) {
-      str.getChars(off, off+len, buf, pos);
-      pos += len;
-    } else if (len<BUFSIZE) {
-      // if the data to write is small enough, buffer it.
-      str.getChars(off, off+space, buf, pos);
-      sink.write(buf, 0, buf.length);
-      str.getChars(off+space, off+len, buf, 0);
-      pos = len-space;
-    } else {
-      sink.write(buf,0,pos);  // flush
-      pos=0;
-      // don't buffer, just write to sink
-      sink.write(str, off, len);
-    }
-  }
-
-  @Override
-  public void flush() throws IOException {
-    sink.write(buf,0,pos);
-    pos=0;
-    sink.flush();
-  }
-
-  @Override
-  public void close() throws IOException {
-    flush();
-    sink.close();
-  }
-
-  public void flushBuffer() throws IOException {
-    sink.write(buf, 0, pos);
-    pos=0;
-  }
-}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/FileUtils.java b/solr/solrj/src/java/org/apache/solr/common/util/FileUtils.java
deleted file mode 100644
index 94ef65e..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/FileUtils.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.*;
-import java.nio.channels.FileChannel;
-
-/**
- *
- */
-public class FileUtils {
-
-  /**
-   * Resolves a path relative a base directory.
-   *
-   * <p>
-   * This method does what "new File(base,path)" <b>Should</b> do, it wasn't
-   * completely lame: If path is absolute, then a File for that path is returned;
-   * if it's not absoluve, then a File is returnd using "path" as a child 
-   * of "base")
-   * </p>
-   */
-  public static File resolvePath(File base, String path) {
-    File r = new File(path);
-    return r.isAbsolute() ? r : new File(base, path);
-  }
-
-  public static void copyFile(File src , File destination) throws IOException {
-    FileChannel in = null;
-    FileChannel out = null;
-    try {
-      in = new FileInputStream(src).getChannel();
-      out = new FileOutputStream(destination).getChannel();
-      in.transferTo(0, in.size(), out);
-    } finally {
-      try { if (in != null) in.close(); } catch (IOException e) {}
-      try { if (out != null) out.close(); } catch (IOException e) {}
-    }
-  }
-
-  /**
-   * Copied from Lucene's FSDirectory.fsync(String) <!-- protected -->
-   *
-   * @param fullFile the File to be synced to disk
-   * @throws IOException if the file could not be synced
-   */
-  public static void sync(File fullFile) throws IOException  {
-    if (fullFile == null || !fullFile.exists())
-      throw new FileNotFoundException("File does not exist " + fullFile);
-
-    boolean success = false;
-    int retryCount = 0;
-    IOException exc = null;
-    while(!success && retryCount < 5) {
-      retryCount++;
-      RandomAccessFile file = null;
-      try {
-        try {
-          file = new RandomAccessFile(fullFile, "rw");
-          file.getFD().sync();
-          success = true;
-        } finally {
-          if (file != null)
-            file.close();
-        }
-      } catch (IOException ioe) {
-        if (exc == null)
-          exc = ioe;
-        try {
-          // Pause 5 msec
-          Thread.sleep(5);
-        } catch (InterruptedException ie) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    }
-    if (!success)
-      // Throw original exception
-      throw exc;
-  }
-
-}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/RTimer.java b/solr/solrj/src/java/org/apache/solr/common/util/RTimer.java
deleted file mode 100644
index db561d9..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/RTimer.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.lang.System;
-import java.lang.Thread;
-import java.util.*;
-
-/** A recursive timer.
- * 
- * RTimers are started automatically when instantiated; subtimers are also
- * started automatically when created.
- *
- * @since solr 1.3
- *
- */
-public class RTimer {
-
-  public static final int STARTED = 0;
-  public static final int STOPPED = 1;
-  public static final int PAUSED = 2;
-
-  protected int state;
-  protected double startTime;
-  protected double time;
-  protected double culmTime;
-  protected SimpleOrderedMap<RTimer> children;
-
-  public RTimer() {
-    time = 0;
-    culmTime = 0;
-    children = new SimpleOrderedMap<RTimer>();
-    startTime = now();
-    state = STARTED;
-  }
-
-  /** Get current time
-   *
-   * May override to implement a different timer (CPU time, etc).
-   */
-  protected double now() { return System.currentTimeMillis(); }
-
-  /** Recursively stop timer and sub timers */
-  public double stop() {
-    assert state == STARTED || state == PAUSED;
-    time = culmTime;
-    if(state == STARTED) 
-      time += now() - startTime;
-    state = STOPPED;
-    
-    for( Map.Entry<String,RTimer> entry : children ) {
-      RTimer child = entry.getValue();
-      if(child.state == STARTED || child.state == PAUSED) 
-        child.stop();
-    }
-    return time;
-  }
-
-  public void pause() {
-    assert state == STARTED;
-    culmTime += now() - startTime;
-    state = PAUSED;
-  }
-  
-  public void resume() {
-    if(state == STARTED)
-      return;
-    assert state == PAUSED;
-    state = STARTED;
-    startTime = now();
-  }
-
-  /** Get total elapsed time for this timer.
-   *
-   * Timer must be STOPped.
-   */
-  public double getTime() {
-    assert state == STOPPED;
-    return time;
-  }
-
-  /** Create new subtimer with given name
-   *
-   * Subtimer will be started.
-   */
-  public RTimer sub(String desc) {
-    RTimer child = children.get( desc );
-    if( child == null ) {
-      child = new RTimer();
-      children.add(desc, child);
-    }
-    return child;
-  }
-
-  @Override
-  public String toString() {
-    return asNamedList().toString();
-  }
-
-  public NamedList asNamedList() {
-    NamedList<Object> m = new SimpleOrderedMap<Object>();
-    m.add( "time", time );
-    if( children.size() > 0 ) {
-      for( Map.Entry<String, RTimer> entry : children ) {
-        m.add( entry.getKey(), entry.getValue().asNamedList() );
-      }
-    }
-    return m;
-  }
-  
-  /**
-   * Manipulating this map may have undefined results.
-   */
-  public SimpleOrderedMap<RTimer> getChildren()
-  {
-    return children;
-  }
-
-  /*************** Testing *******/
-  public static void main(String []argv) throws InterruptedException {
-    RTimer rt = new RTimer(), subt, st;
-    Thread.sleep(100);
-
-    subt = rt.sub("sub1");
-    Thread.sleep(50);
-    st = subt.sub("sub1.1");
-    st.resume();
-    Thread.sleep(10);
-    st.pause();
-    Thread.sleep(50);
-    st.resume();
-    Thread.sleep(10);
-    st.pause();
-    subt.stop();
-    rt.stop();
-
-    System.out.println( rt.toString());
-  }
-}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/RegexFileFilter.java b/solr/solrj/src/java/org/apache/solr/common/util/RegexFileFilter.java
deleted file mode 100644
index 6bba26e..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/RegexFileFilter.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.File;
-import java.io.FileFilter;
-import java.util.regex.*;
-
-/**
- * Accepts any file whose name matches the pattern
- *
- */
-public final class RegexFileFilter implements FileFilter {
-
-  final Pattern pattern;
-  public RegexFileFilter(String regex) {
-    this(Pattern.compile(regex));
-  }
-  public RegexFileFilter(Pattern regex) {
-    pattern = regex;
-  }
-  public boolean accept(File f) {
-    return pattern.matcher(f.getName()).matches();
-  }
-  @Override
-  public String toString() {
-    return "regex:" + pattern.toString();
-  }
-}
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/SystemIdResolver.java b/solr/solrj/src/java/org/apache/solr/common/util/SystemIdResolver.java
deleted file mode 100644
index b396735..0000000
--- a/solr/solrj/src/java/org/apache/solr/common/util/SystemIdResolver.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.apache.solr.common.ResourceLoader;
-
-import org.xml.sax.InputSource;
-import org.xml.sax.EntityResolver;
-import org.xml.sax.ext.EntityResolver2;
-import java.io.File;
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import javax.xml.transform.Source;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.URIResolver;
-import javax.xml.transform.sax.SAXSource;
-import javax.xml.stream.XMLResolver;
-import javax.xml.stream.XMLStreamException;
-
-/**
- * This is a helper class to support resolving of XIncludes or other hrefs
- * inside XML files on top of a {@link ResourceLoader}. Just plug this class
- * on top of a {@link ResourceLoader} and pass it as {@link EntityResolver} to SAX parsers
- * or via wrapper methods as {@link URIResolver} to XSL transformers or {@link XMLResolver} to STAX parsers.
- * The resolver handles special SystemIds with an URI scheme of {@code solrres:} that point
- * to resources. To produce such systemIds when you initially call the parser, use
- * {@link #createSystemIdFromResourceName} which produces a SystemId that can
- * be included along the InputStream coming from {@link ResourceLoader#openResource}.
- * <p>In general create the {@link InputSource} to be passed to the parser like:</p>
- * <pre class="prettyprint">
- *  InputSource is = new InputSource(loader.openSchema(name));
- *  is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(name));
- *  final DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
- *  db.setEntityResolver(new SystemIdResolver(loader));
- *  Document doc = db.parse(is);
- * </pre>
- */
-public final class SystemIdResolver implements EntityResolver, EntityResolver2 {
-  private static final Logger log = LoggerFactory.getLogger(SystemIdResolver.class);
-
-  public static final String RESOURCE_LOADER_URI_SCHEME = "solrres";
-  public static final String RESOURCE_LOADER_AUTHORITY_ABSOLUTE = "@";
-
-  private final ResourceLoader loader;
-
-  public SystemIdResolver(ResourceLoader loader) {
-    this.loader = loader;
-  }
-  
-  public EntityResolver asEntityResolver() {
-    return this;
-  }
-  
-  public URIResolver asURIResolver() {
-    return new URIResolver() {
-      public Source resolve(String href, String base) throws TransformerException {
-        try {
-          final InputSource src = SystemIdResolver.this.resolveEntity(null, null, base, href);
-          return (src == null) ? null : new SAXSource(src);
-        } catch (IOException ioe) {
-          throw new TransformerException("Cannot resolve entity", ioe);
-        }
-      }
-    };
-  }
-  
-  public XMLResolver asXMLResolver() {
-    return new XMLResolver() {
-      public Object resolveEntity(String publicId, String systemId, String baseURI, String namespace) throws XMLStreamException {
-        try {
-          final InputSource src = SystemIdResolver.this.resolveEntity(null, publicId, baseURI, systemId);
-          return (src == null) ? null : src.getByteStream();
-        } catch (IOException ioe) {
-          throw new XMLStreamException("Cannot resolve entity", ioe);
-        }
-      }
-    };
-  }
-  
-  URI resolveRelativeURI(String baseURI, String systemId) throws IOException,URISyntaxException {
-    URI uri;
-    
-    // special case for backwards compatibility: if relative systemId starts with "/" (we convert that to an absolute solrres:-URI)
-    if (systemId.startsWith("/")) {
-      uri = new URI(RESOURCE_LOADER_URI_SCHEME, RESOURCE_LOADER_AUTHORITY_ABSOLUTE, "/", null, null).resolve(systemId);
-    } else {
-      // simply parse as URI
-      uri = new URI(systemId);
-    }
-    
-    // do relative resolving
-    if (baseURI != null ) {
-      uri = new URI(baseURI).resolve(uri);
-    }
-    
-    return uri;
-  }
-  
-  // *** EntityResolver(2) methods:
-  
-  public InputSource getExternalSubset(String name, String baseURI) {
-    return null;
-  }
-  
-  public InputSource resolveEntity(String name, String publicId, String baseURI, String systemId) throws IOException {
-    if (systemId == null)
-      return null;
-    try {
-      final URI uri = resolveRelativeURI(baseURI, systemId);
-      
-      // check schema and resolve with ResourceLoader
-      if (RESOURCE_LOADER_URI_SCHEME.equals(uri.getScheme())) {
-        String path = uri.getPath(), authority = uri.getAuthority();
-        if (!RESOURCE_LOADER_AUTHORITY_ABSOLUTE.equals(authority)) {
-          path = path.substring(1);
-        }
-        try {
-          final InputSource is = new InputSource(loader.openResource(path));
-          is.setSystemId(uri.toASCIIString());
-          is.setPublicId(publicId);
-          return is;
-        } catch (RuntimeException re) {
-          // unfortunately XInclude fallback only works with IOException, but openResource() never throws that one
-          throw (IOException) (new IOException(re.getMessage()).initCause(re));
-        }
-      } else {
-        // resolve all other URIs using the standard resolver
-        return null;
-      }
-    } catch (URISyntaxException use) {
-      log.warn("An URI systax problem occurred during resolving SystemId, falling back to default resolver", use);
-      return null;
-    }
-  }
-
-  public InputSource resolveEntity(String publicId, String systemId) throws IOException {
-    return resolveEntity(null, publicId, null, systemId);
-  }
-  
-  public static String createSystemIdFromResourceName(String name) {
-    name = name.replace(File.separatorChar, '/');
-    final String authority;
-    if (name.startsWith("/")) {
-      // a hack to preserve absolute filenames and keep them absolute after resolving, we set the URI's authority to "@" on absolute filenames:
-      authority = RESOURCE_LOADER_AUTHORITY_ABSOLUTE;
-    } else {
-      authority = null;
-      name = "/" + name;
-    }
-    try {
-      return new URI(RESOURCE_LOADER_URI_SCHEME, authority, name, null, null).toASCIIString();
-    } catch (URISyntaxException use) {
-      throw new IllegalArgumentException("Invalid syntax of Solr Resource URI", use);
-    }
-  }
-
-}
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java b/solr/solrj/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
index 312035b..7be9118 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
@@ -28,7 +28,7 @@ import org.apache.solr.client.solrj.request.QueryRequest;
 import org.apache.solr.client.solrj.request.UpdateRequest;
 import org.apache.solr.client.solrj.response.CoreAdminResponse;
 import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.util.FileUtils;
+import org.apache.solr.util.FileUtils;
 import org.apache.solr.core.CoreContainer;
 import org.junit.Rule;
 import org.junit.Test;
diff --git a/solr/solrj/src/test/org/apache/solr/common/util/DOMUtilTest.java b/solr/solrj/src/test/org/apache/solr/common/util/DOMUtilTest.java
deleted file mode 100644
index 85bbfe9..0000000
--- a/solr/solrj/src/test/org/apache/solr/common/util/DOMUtilTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import org.apache.solr.util.DOMUtilTestBase;
-
-public class DOMUtilTest extends DOMUtilTestBase {
-  
-  public void testAddToNamedListPrimitiveTypes() throws Exception {
-    NamedList<Object> namedList = new SimpleOrderedMap<Object>();
-    DOMUtil.addToNamedList( getNode( "<str name=\"String\">STRING</str>", "/str" ), namedList, null );
-    assertTypeAndValue( namedList, "String", "STRING" );
-    DOMUtil.addToNamedList( getNode( "<int name=\"Integer\">100</int>", "/int" ), namedList, null );
-    assertTypeAndValue( namedList, "Integer", Integer.valueOf( 100 ) );
-    DOMUtil.addToNamedList( getNode( "<long name=\"Long\">200</long>", "/long" ), namedList, null );
-    assertTypeAndValue( namedList, "Long", Long.valueOf( 200 ) );
-    DOMUtil.addToNamedList( getNode( "<float name=\"Float\">300</float>", "/float" ), namedList, null );
-    assertTypeAndValue( namedList, "Float", Float.valueOf( 300 ) );
-    DOMUtil.addToNamedList( getNode( "<double name=\"Double\">400</double>", "/double" ), namedList, null );
-    assertTypeAndValue( namedList, "Double", Double.valueOf( 400 ) );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">true</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", true );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">on</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", true );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">yes</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", true );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">false</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", false );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">off</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", false );
-    DOMUtil.addToNamedList( getNode( "<bool name=\"Boolean\">no</bool>", "/bool" ), namedList, null );
-    assertTypeAndValue( namedList, "Boolean", false );
-  }
-
-  private void assertTypeAndValue( NamedList<Object> namedList, String key, Object value ) throws Exception {
-    Object v = namedList.get( key );
-    assertNotNull( v );
-    assertEquals( key, v.getClass().getSimpleName() );
-    assertEquals( value, v );
-    namedList.remove( key );
-  }
-}
diff --git a/solr/solrj/src/test/org/apache/solr/common/util/FileUtilsTest.java b/solr/solrj/src/test/org/apache/solr/common/util/FileUtilsTest.java
deleted file mode 100644
index c96c204..0000000
--- a/solr/solrj/src/test/org/apache/solr/common/util/FileUtilsTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.File;
-import java.io.IOException;
-
-import org.apache.lucene.util.LuceneTestCase;
-
-public class FileUtilsTest extends LuceneTestCase {  
-
-  public void testResolve() throws IOException {
-    String cwd = new File(".").getAbsolutePath();
-    assertEquals(new File("conf/data"), FileUtils.resolvePath(new File("conf"), "data"));
-    assertEquals(new File(cwd+"/conf/data"), FileUtils.resolvePath(new File(cwd+"/conf"), "data"));
-    assertEquals(new File(cwd+"/data"), FileUtils.resolvePath(new File("conf"), cwd+"/data"));
-  }
-}
diff --git a/solr/solrj/src/test/org/apache/solr/common/util/TestSystemIdResolver.java b/solr/solrj/src/test/org/apache/solr/common/util/TestSystemIdResolver.java
deleted file mode 100644
index c40ed4d..0000000
--- a/solr/solrj/src/test/org/apache/solr/common/util/TestSystemIdResolver.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import org.apache.solr.core.SolrResourceLoader;
-import org.apache.solr.common.ResourceLoader;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.solr.SolrTestCaseJ4;
-
-import java.io.File;
-import org.xml.sax.InputSource;
-import org.apache.commons.io.IOUtils;
-
-public class TestSystemIdResolver extends LuceneTestCase {
-  
-  private void assertEntityResolving(SystemIdResolver resolver, String expectedSystemId, String base, String systemId) throws Exception {
-    final InputSource is = resolver.resolveEntity(null, null, base, systemId);
-    try {
-      assertEquals("Resolved SystemId does not match", expectedSystemId, is.getSystemId());
-    } finally {
-      IOUtils.closeQuietly(is.getByteStream());
-    }
-  }
-  
-  public void testResolving() throws Exception {
-    final String testHome = SolrTestCaseJ4.getFile("solrj/solr/conf").getParent();
-    final ResourceLoader loader = new SolrResourceLoader(testHome, this.getClass().getClassLoader());
-    final SystemIdResolver resolver = new SystemIdResolver(loader);
-    final String fileUri = new File(testHome+"/crazy-path-to-config.xml").toURI().toASCIIString();
-    
-    assertEquals("solrres:/test.xml", SystemIdResolver.createSystemIdFromResourceName("test.xml"));
-    assertEquals("solrres://@/usr/local/etc/test.xml", SystemIdResolver.createSystemIdFromResourceName("/usr/local/etc/test.xml"));
-    assertEquals("solrres://@/test.xml", SystemIdResolver.createSystemIdFromResourceName(File.separatorChar+"test.xml"));
-    
-    // check relative URI resolving
-    assertEquals("solrres:/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "test.xml").toASCIIString());
-    assertEquals("solrres://@/etc/test.xml",
-      resolver.resolveRelativeURI("solrres://@/usr/local/etc/base.xml", "../../../etc/test.xml").toASCIIString());
-    // special case: if relative URI starts with "/" convert to an absolute solrres://@/-URI
-    assertEquals("solrres://@/a/test.xml", resolver.resolveRelativeURI("solrres:/base.xml", "/a/test.xml").toASCIIString());
-    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, it should be preserved
-    assertEquals(fileUri, resolver.resolveRelativeURI("solrres:/base.xml", fileUri).toASCIIString());
-    assertEquals("solrres:/base.xml", resolver.resolveRelativeURI(fileUri, "solrres:/base.xml").toASCIIString());
-    
-    // do some real resolves to I nputStreams with real existing files
-    assertEntityResolving(resolver, "solrres:/schema.xml", "solrres:/solrconfig.xml", "schema.xml");
-    assertEntityResolving(resolver, "solrres:/org/apache/solr/common/util/TestSystemIdResolver.class",
-      "solrres:/org/apache/solr/common/ResourceLoader.class", "util/TestSystemIdResolver.class");
-    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/conf/schema.xml"),
-      SystemIdResolver.createSystemIdFromResourceName(testHome+"/conf/solrconfig.xml"), "schema.xml");
-    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-schema.xml"),
-      SystemIdResolver.createSystemIdFromResourceName(testHome+"/crazy-path-to-config.xml"), "crazy-path-to-schema.xml");
-    
-    // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, the resolver should return null (default fallback)
-    assertNull(resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", fileUri));
-  }
-
-}

