GitDiffStart: 0c7a172d4f3e7aa5c5fccea5425203851239c9dc | Fri Apr 1 14:41:09 2011 +0000
diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index 987ea9f..a5d64f9 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -57,6 +57,7 @@
 	<classpathentry kind="src" path="solr/src/webapp/src"/>
 	<classpathentry kind="src" path="solr/src/common"/>
 	<classpathentry kind="src" path="solr/src/solrj"/>
+	<classpathentry kind="src" path="solr/src/test-framework"/>
 	<classpathentry kind="src" path="solr/src/test"/>
 	<classpathentry kind="src" path="solr/src/test-files"/>
 	<classpathentry kind="src" path="solr/contrib/analysis-extras/src/java"/>
diff --git a/dev-tools/idea/solr/solr.iml b/dev-tools/idea/solr/solr.iml
index 0a45dd1..0f0ba62 100644
--- a/dev-tools/idea/solr/solr.iml
+++ b/dev-tools/idea/solr/solr.iml
@@ -12,6 +12,7 @@
       <sourceFolder url="file://$MODULE_DIR$/src/java" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/src/test" isTestSource="true" />
       <sourceFolder url="file://$MODULE_DIR$/src/test-files" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test-framework" isTestSource="true" />
       <excludeFolder url="file://$MODULE_DIR$/build" />
       <excludeFolder url="file://$MODULE_DIR$/dist" />
       <excludeFolder url="file://$MODULE_DIR$/lucene-libs" />
diff --git a/dev-tools/maven/solr/contrib/analysis-extras/pom.xml.template b/dev-tools/maven/solr/contrib/analysis-extras/pom.xml.template
index 4ecff92..59b0d0a 100644
--- a/dev-tools/maven/solr/contrib/analysis-extras/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/analysis-extras/pom.xml.template
@@ -44,9 +44,8 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/contrib/clustering/pom.xml.template b/dev-tools/maven/solr/contrib/clustering/pom.xml.template
index 8a10434..fd205c1 100644
--- a/dev-tools/maven/solr/contrib/clustering/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/clustering/pom.xml.template
@@ -44,9 +44,8 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/contrib/dataimporthandler/src/extras/pom.xml.template b/dev-tools/maven/solr/contrib/dataimporthandler/src/extras/pom.xml.template
index 20de6cb..a9ee1f7 100644
--- a/dev-tools/maven/solr/contrib/dataimporthandler/src/extras/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/dataimporthandler/src/extras/pom.xml.template
@@ -44,9 +44,8 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/contrib/dataimporthandler/src/pom.xml.template b/dev-tools/maven/solr/contrib/dataimporthandler/src/pom.xml.template
index ba247a3..302ac33 100644
--- a/dev-tools/maven/solr/contrib/dataimporthandler/src/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/dataimporthandler/src/pom.xml.template
@@ -43,10 +43,9 @@
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <groupId>org.apache.solr</groupId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/contrib/extraction/pom.xml.template b/dev-tools/maven/solr/contrib/extraction/pom.xml.template
index e1a2581..da012e5 100644
--- a/dev-tools/maven/solr/contrib/extraction/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/extraction/pom.xml.template
@@ -47,9 +47,8 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/contrib/uima/pom.xml.template b/dev-tools/maven/solr/contrib/uima/pom.xml.template
index 6e58ddb..62b8a4b 100644
--- a/dev-tools/maven/solr/contrib/uima/pom.xml.template
+++ b/dev-tools/maven/solr/contrib/uima/pom.xml.template
@@ -44,9 +44,8 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>solr-core</artifactId>
+      <artifactId>solr-test-framework</artifactId>
       <version>${project.version}</version>
-      <type>test-jar</type>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/dev-tools/maven/solr/pom.xml.template b/dev-tools/maven/solr/pom.xml.template
index f866ca1..1b552ff 100644
--- a/dev-tools/maven/solr/pom.xml.template
+++ b/dev-tools/maven/solr/pom.xml.template
@@ -35,6 +35,7 @@
     <module>src</module>
     <module>src/solrj</module>
     <module>src/webapp</module>
+    <module>src/test-framework</module>
     <module>contrib</module>
   </modules>
   <properties>
diff --git a/dev-tools/maven/solr/src/pom.xml.template b/dev-tools/maven/solr/src/pom.xml.template
index 2457615..1a30379 100644
--- a/dev-tools/maven/solr/src/pom.xml.template
+++ b/dev-tools/maven/solr/src/pom.xml.template
@@ -199,17 +199,6 @@
       </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <executions>
-          <execution>
-            <goals>
-              <goal>test-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-surefire-plugin</artifactId>
         <configuration>
           <systemPropertyVariables>
@@ -248,6 +237,24 @@
           </programs>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>build-helper-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>add-test-source</id>
+            <phase>generate-test-sources</phase>
+            <goals>
+              <goal>add-test-source</goal>
+            </goals>
+            <configuration>
+              <sources>
+                <source>test-framework</source>
+              </sources>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/dev-tools/maven/solr/src/solrj/pom.xml.template b/dev-tools/maven/solr/src/solrj/pom.xml.template
index a0d67eb..072e1ef 100644
--- a/dev-tools/maven/solr/src/solrj/pom.xml.template
+++ b/dev-tools/maven/solr/src/solrj/pom.xml.template
@@ -44,12 +44,6 @@
     </dependency>
     <dependency>
       <groupId>org.apache.lucene</groupId>
-      <artifactId>lucene-test-framework</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.lucene</groupId>
       <artifactId>lucene-analyzers-common</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
@@ -88,11 +82,6 @@
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-api</artifactId>
     </dependency> 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
   <build>
     <directory>${build-directory}</directory>
diff --git a/dev-tools/maven/solr/src/test-framework/pom.xml.template b/dev-tools/maven/solr/src/test-framework/pom.xml.template
new file mode 100644
index 0000000..fc78757
--- /dev/null
+++ b/dev-tools/maven/solr/src/test-framework/pom.xml.template
@@ -0,0 +1,76 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <!--
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+  -->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.solr</groupId>
+    <artifactId>solr-parent</artifactId>
+    <version>@version@</version>
+    <relativePath>../../pom.xml</relativePath>
+  </parent>
+  <groupId>org.apache.solr</groupId>
+  <artifactId>solr-test-framework</artifactId>
+  <packaging>jar</packaging>
+  <name>Apache Solr Test Framework</name>
+  <description>Apache Solr Test Framework</description>
+  <properties>
+    <module-directory>solr/src/test-framework</module-directory>
+    <build-directory>../../build</build-directory>
+  </properties>
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>solr-core</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.lucene</groupId>
+      <artifactId>lucene-test-framework</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+    </dependency>
+  </dependencies>
+  <build>
+    <directory>${build-directory}</directory>
+    <outputDirectory>${build-directory}/classes/test-framework</outputDirectory>
+    <sourceDirectory>.</sourceDirectory>
+    <resources>
+      <resource>
+        <directory>.</directory>
+        <excludes>
+          <exclude>**/*.java</exclude>
+        </excludes>
+      </resource>
+    </resources>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/solr/build.xml b/solr/build.xml
index 5821f99..bc1999e 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -176,6 +176,24 @@
     </sequential>
   </target>
 
+  <target name="javadoc-test-framework" depends="compileTestFramework,javadoc-dep"
+          description="Generates javadoc documentation for the Solr test-framework.">
+    <sequential>
+      <mkdir dir="${build.javadoc}/test-framework"/>
+
+      <path id="javadoc.classpath">
+        <path refid="testframework.compile.classpath"/>
+      </path>
+
+      <invoke-javadoc
+        destdir="${build.javadoc}/test-framework"
+      	title="${Name} ${version} Test Framework API (${specversion})">
+        <sources>
+          <packageset dir="${src}/test-framework" />
+        </sources>
+      </invoke-javadoc>
+    </sequential>
+  </target>
 
   <target name="javadoc-all" depends="compile,javadoc-dep" description="Generate javadoc for core, client and contrib">
     <sequential>
@@ -221,7 +239,7 @@
                    failonerror="true"/>
   </target>
 
-  <target name="javadoc" depends="javadoc-core, javadoc-contrib, javadoc-solrj, javadoc-all">
+  <target name="javadoc" depends="javadoc-core, javadoc-test-framework, javadoc-contrib, javadoc-solrj, javadoc-all">
   </target>
   <target name="javadocs" depends="javadoc"/>
 
@@ -320,13 +338,18 @@
 
   <!-- Classpath for unit test compilation. -->
   <!-- For now, it's the same as main classpath.  Later it will have JUnit, Clover, etc. -->
-  <path id="test.compile.classpath">
+  <path id="testframework.compile.classpath">
     <path refid="compile.classpath" />
     <path refid="compile.classpath.solrj" />
     <pathelement location="${dest}/solr"/>
     <pathelement location="${dest}/solrj"/> <!-- include solrj -->
     <pathelement location="${common-solr.dir}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
   </path>
+	
+  <path id="test.compile.classpath">
+    <path refid="testframework.compile.classpath"/>
+    <pathelement location="${dest}/test-framework"/> <!-- include some solr test code -->
+  </path>
 
   <path id="test.run.classpath">
     <path refid="test.compile.classpath" />
@@ -337,10 +360,19 @@
     <pathelement path="${java.class.path}"/>
   </path>
 
+  <target name="compileTestFramework" depends="compile,compile-solrj">
+    <mkdir dir="${dest}/test-framework"/>
+  	<solr-javac
+      destdir="${dest}/test-framework"
+  	  classpathref="testframework.compile.classpath">
+        <src path="${src}/test-framework"/>
+  	</solr-javac>
+  </target>
+
   <!-- Compile unit tests. -->
   <target name="compileTests"
           description="Compile unit tests."
-          depends="compile,compile-solrj">
+          depends="compileTestFramework">
 
     <mkdir dir="${dest}/tests" />
     <solr-javac 
@@ -577,7 +609,7 @@
   <!-- Creates the Solr distribution files. -->
   <target name="dist"
           description="Creates the Solr distribution files."
-          depends="dist-solrj, dist-jar, dist-contrib, dist-war" />
+          depends="dist-solrj, dist-jar, dist-test-framework, dist-contrib, dist-war" />
 
   <!-- Creates the Solr WAR file. -->
   <target name="dist-war"
@@ -625,6 +657,9 @@
       <fileset dir="${src}/webapp/src"/>
     </solr-jar>
   	
+    <solr-jar destfile="${dist}/${fullname}-test-framework-src-${version}.jar"
+              basedir="${src}/test-framework" />
+
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-src-${version}.jar"
               basedir="contrib/dataimporthandler/src/main/java" />
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-extras-src-${version}.jar"
@@ -650,6 +685,8 @@
               basedir="${build.javadoc}/solr" />
     <solr-jar destfile="${dist}/${fullname}-solrj-docs-${version}.jar"
               basedir="${build.javadoc}/solrj" />
+    <solr-jar destfile="${dist}/${fullname}-test-framework-docs-${version}.jar"
+              basedir="${build.javadoc}/test-framework" />
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-docs-${version}.jar"
               basedir="${build.javadoc}/contrib-solr-dataimporthandler" />
     <solr-jar destfile="${dist}/apache-solr-clustering-docs-${version}.jar"
@@ -673,6 +710,16 @@
 
   </target>
 
+  <!-- Creates the test-framework jar -->
+  <target name="dist-test-framework"
+          description="Creates the Solr test-framework JAR."
+          depends="compileTestFramework">
+    <mkdir dir="${dist}" />
+    <solr-jar destfile="${dist}/${fullname}-test-framework-${version}.jar">
+      <fileset dir="${dest}/test-framework" />
+    </solr-jar>
+  </target>
+
   <!-- Creates the solr jar. -->
   <target name="dist-solrj"
           description="Creates the Solr JAR Distribution file."
@@ -914,6 +961,7 @@
     <sign-maven-artifacts artifact.id="solr-dataimporthandler-extras" gpg.passphrase="${gpg.passphrase}"/>
     <sign-maven-artifacts artifact.id="solr-solrj" gpg.passphrase="${gpg.passphrase}"/>
     <sign-maven-artifacts artifact.id="solr-uima" gpg.passphrase="${gpg.passphrase}"/>
+    <sign-maven-artifacts artifact.id="solr-test-framework" gpg.passphrase="${gpg.passphrase}"/>
 
     <!-- These are special since there are no jars, just poms -->
     <sign-artifact input.file="${maven.dist.prefix}/solr-parent/${version}/solr-parent-${version}.pom" gpg.passphrase="${gpg.passphrase}"/>
@@ -1054,6 +1102,14 @@
 
       <m2-deploy pom.xml="src/webapp/pom.xml"
                  jar.file="${dist}/apache-solr-${version}.war"/>
+
+      <m2-deploy pom.xml="${src}/test-framework/pom.xml"
+                 jar.file="${dist}/${fullname}-test-framework-${version}.jar">
+        <artifact-attachments>
+          <attach file="${dist}/${fullname}-test-framework-src-${version}.jar" classifier="sources"/>
+          <attach file="${dist}/${fullname}-test-framework-docs-${version}.jar" classifier="javadoc"/>
+        </artifact-attachments>
+      </m2-deploy>
     </sequential>
   </target>
 
diff --git a/solr/contrib/analysis-extras/build.xml b/solr/contrib/analysis-extras/build.xml
index 1b135e3..9cc5aa2 100644
--- a/solr/contrib/analysis-extras/build.xml
+++ b/solr/contrib/analysis-extras/build.xml
@@ -72,7 +72,7 @@
     <pathelement path="${dest}/classes"/>
     <pathelement path="${dest}/test-classes"/>
     <pathelement path="${java.class.path}"/>
-    <pathelement location="${common-solr.dir}/build/tests"/> <!-- include solr test code -->
+    <pathelement location="${common-solr.dir}/build/test-framework"/> <!-- include solr test code -->
     <pathelement location="${common-solr.dir}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <path refid="common.classpath"/>
   </path>
@@ -92,7 +92,7 @@
     <mkdir dir="${dest}/classes"/>
     
     <mkdir dir="${build.javadoc}"/>
-    <subant target="compileTests">
+    <subant target="compileTestFramework">
       <fileset dir="${solr-path}" includes="build.xml"/>
     </subant>
     <subant target="make-manifest">
diff --git a/solr/contrib/clustering/build.xml b/solr/contrib/clustering/build.xml
index 7090ca7..aee297e 100644
--- a/solr/contrib/clustering/build.xml
+++ b/solr/contrib/clustering/build.xml
@@ -41,8 +41,8 @@
     <pathelement path="${dest}/classes"/>
     <pathelement path="${dest}/test-classes"/>
     <pathelement path="${java.class.path}"/>
-    <pathelement location="${common-solr.dir}/build/tests"/> <!-- include solr test code -->
-    <pathelement location="${common-solr.dir}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
+    <pathelement location="${solr-path}/build/test-framework"/> <!-- include solr test code -->
+    <pathelement location="${solr-path}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <path refid="common.classpath"/>
     <!-- DistributedClusteringComponentTest uses Jetty -->
     <fileset dir="${solr-path}/example/lib">
@@ -64,7 +64,7 @@
     <mkdir dir="${dest}/classes"/>
     
     <mkdir dir="${build.javadoc}"/>
-    <subant target="compileTests">
+    <subant target="compileTestFramework">
       <fileset dir="${solr-path}" includes="build.xml"/>
     </subant>
     <subant target="make-manifest">
diff --git a/solr/contrib/dataimporthandler/build.xml b/solr/contrib/dataimporthandler/build.xml
index 5b9ddc1..bd6ea50 100644
--- a/solr/contrib/dataimporthandler/build.xml
+++ b/solr/contrib/dataimporthandler/build.xml
@@ -55,7 +55,7 @@
   	<path refid="classpath.jetty" />
 	  <pathelement path="target/classes" />
   	<pathelement path="target/test-classes" />
-    <pathelement location="${solr-path}/build/tests"/> <!-- include solr test code -->
+    <pathelement location="${solr-path}/build/test-framework"/> <!-- include solr test code -->
     <pathelement location="${solr-path}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <pathelement path="${java.class.path}"/>
   </path>
@@ -67,7 +67,7 @@
 	  <pathelement path="target/extras/classes" />
   	<pathelement path="target/test-classes" />
   	<pathelement path="target/extras/test-classes" />
-    <pathelement location="${solr-path}/build/tests"/> <!-- include solr test code -->
+    <pathelement location="${solr-path}/build/test-framework"/> <!-- include solr test code -->
     <pathelement location="${solr-path}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <pathelement path="${java.class.path}"/>
   </path>
@@ -89,7 +89,7 @@
   <target name="init">
   	<mkdir dir="target/classes"/>
     <mkdir dir="${build.javadoc}" />
-    <subant target="compileTests">
+    <subant target="compileTestFramework">
       <fileset dir="${solr-path}" includes="build.xml"/>
     </subant>
     <subant target="make-manifest">
diff --git a/solr/contrib/extraction/build.xml b/solr/contrib/extraction/build.xml
index de7542d..01aa60e 100644
--- a/solr/contrib/extraction/build.xml
+++ b/solr/contrib/extraction/build.xml
@@ -39,7 +39,7 @@
     <path refid="common.classpath" />
     <pathelement path="${dest}/classes" />
     <pathelement path="${dest}/test-classes" />
-    <pathelement location="${solr-path}/build/tests"/> <!-- include solr test code -->
+    <pathelement location="${solr-path}/build/test-framework"/> <!-- include solr test code -->
     <pathelement location="${solr-path}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <pathelement path="${java.class.path}"/>
   </path>
@@ -51,7 +51,7 @@
   <target name="init">
     <mkdir dir="${dest}/classes"/>
     <mkdir dir="${build.javadoc}" />
-    <subant target="compileTests">
+    <subant target="compileTestFramework">
       <fileset dir="${solr-path}" includes="build.xml"/>
     </subant>
     <subant target="make-manifest">
diff --git a/solr/contrib/uima/build.xml b/solr/contrib/uima/build.xml
index 34dbefe..631f8a8 100644
--- a/solr/contrib/uima/build.xml
+++ b/solr/contrib/uima/build.xml
@@ -40,7 +40,7 @@
     <path refid="common.classpath" />
     <pathelement path="${dest}/classes" />
     <pathelement path="${dest}/test-classes" />
-    <pathelement location="${solr-path}/build/tests"/> <!-- include solr test code -->
+    <pathelement location="${solr-path}/build/test-framework"/> <!-- include solr test code -->
     <pathelement location="${solr-path}/../lucene/build/classes/test-framework" />  <!-- include some lucene test code -->
     <pathelement path="${java.class.path}"/>
   </path>
@@ -52,7 +52,7 @@
   <target name="init">
     <mkdir dir="${dest}/classes"/>
     <mkdir dir="${build.javadoc}" />
-    <subant target="compileTests">
+    <subant target="compileTestFramework">
       <fileset dir="${solr-path}" includes="build.xml"/>
     </subant>
     <subant target="make-manifest">
diff --git a/solr/site/features.html b/solr/site/features.html
index 6874449..f64d00e 100755
--- a/solr/site/features.html
+++ b/solr/site/features.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Resources</div>
 <div id="menu_1.3" class="menuitemgroup">
diff --git a/solr/site/index.html b/solr/site/index.html
index 36b9a3d..06d93df 100755
--- a/solr/site/index.html
+++ b/solr/site/index.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Resources</div>
 <div id="menu_1.3" class="menuitemgroup">
diff --git a/solr/site/issue_tracking.html b/solr/site/issue_tracking.html
index 51742eb..afa8d89 100755
--- a/solr/site/issue_tracking.html
+++ b/solr/site/issue_tracking.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_selected_1.3', 'skin/')" id="menu_selected_1.3Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Resources</div>
 <div id="menu_selected_1.3" class="selectedmenuitemgroup" style="display: block;">
diff --git a/solr/site/linkmap.html b/solr/site/linkmap.html
index 7d722ba..e8ab9ea 100755
--- a/solr/site/linkmap.html
+++ b/solr/site/linkmap.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Resources</div>
 <div id="menu_1.3" class="menuitemgroup">
@@ -285,6 +288,12 @@ document.write("Last Published: " + document.lastModified);
 <a href="api/solrj/index.html">SolrJ Javadoc</a>&nbsp;&nbsp;___________________&nbsp;&nbsp;<em>apidocs</em>
 </li>
 </ul>
+    
+<ul>
+<li>
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>&nbsp;&nbsp;___________________&nbsp;&nbsp;<em>apidocs</em>
+</li>
+</ul>
   
 </ul>
 </ul>
diff --git a/solr/site/linkmap.pdf b/solr/site/linkmap.pdf
index a897152..d482d8a 100755
--- a/solr/site/linkmap.pdf
+++ b/solr/site/linkmap.pdf
@@ -14,6 +14,7 @@ This is a map of the complete site and its structure.
                   ?? FAQ ___________________ faq
                   ?? All Javadoc ___________________ apidocs
                   ?? SolrJ Javadoc ___________________ apidocs
+                  ?? Test Framework Javadoc ___________________ apidocs
 
          ?? Resources ___________________ resources
                   ?? Download ___________________ download
diff --git a/solr/site/mailing_lists.html b/solr/site/mailing_lists.html
index 79af6c5..3ecfd9a 100755
--- a/solr/site/mailing_lists.html
+++ b/solr/site/mailing_lists.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_selected_1.3', 'skin/')" id="menu_selected_1.3Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Resources</div>
 <div id="menu_selected_1.3" class="selectedmenuitemgroup" style="display: block;">
diff --git a/solr/site/skin/basic.css b/solr/site/skin/basic.css
index eb24c32..4ed58b9 100755
--- a/solr/site/skin/basic.css
+++ b/solr/site/skin/basic.css
@@ -163,4 +163,4 @@ p {
 .codefrag {
   font-family: "Courier New", Courier, monospace;
   font-size: 110%;
-}
\ No newline at end of file
+}
diff --git a/solr/site/skin/print.css b/solr/site/skin/print.css
index aaa9931..8916b9f 100755
--- a/solr/site/skin/print.css
+++ b/solr/site/skin/print.css
@@ -51,4 +51,4 @@ a:link, a:visited {
 
 acronym {
   border: 0;
-}
\ No newline at end of file
+}
diff --git a/solr/site/skin/profile.css b/solr/site/skin/profile.css
index 2ed9554..ca72cdb 100755
--- a/solr/site/skin/profile.css
+++ b/solr/site/skin/profile.css
@@ -172,4 +172,4 @@ a:hover { color:#6587ff}
     }
       
     
-  
\ No newline at end of file
+  
diff --git a/solr/site/skin/screen.css b/solr/site/skin/screen.css
index ef52153..4e2e040 100755
--- a/solr/site/skin/screen.css
+++ b/solr/site/skin/screen.css
@@ -584,4 +584,4 @@ p.instruction {
   list-style-image: url('../images/instruction_arrow.png');
   list-style-position: outside;
   margin-left: 2em;
-} 
\ No newline at end of file
+} 
diff --git a/solr/site/tutorial.html b/solr/site/tutorial.html
index ba065d1..18ecd53 100755
--- a/solr/site/tutorial.html
+++ b/solr/site/tutorial.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Resources</div>
 <div id="menu_1.3" class="menuitemgroup">
diff --git a/solr/site/version_control.html b/solr/site/version_control.html
index d66a66d..2bd2a80 100755
--- a/solr/site/version_control.html
+++ b/solr/site/version_control.html
@@ -130,6 +130,9 @@ document.write("Last Published: " + document.lastModified);
 <div class="menuitem">
 <a href="api/solrj/index.html">SolrJ Javadoc</a>
 </div>
+<div class="menuitem">
+<a href="api/test-framework/index.html">Test Framework Javadoc</a>
+</div>
 </div>
 <div onclick="SwitchMenu('menu_selected_1.3', 'skin/')" id="menu_selected_1.3Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Resources</div>
 <div id="menu_selected_1.3" class="selectedmenuitemgroup" style="display: block;">
diff --git a/solr/src/java/org/apache/solr/util/TestHarness.java b/solr/src/java/org/apache/solr/util/TestHarness.java
deleted file mode 100644
index ea5a703..0000000
--- a/solr/src/java/org/apache/solr/util/TestHarness.java
+++ /dev/null
@@ -1,576 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.core.SolrConfig;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.CoreContainer;
-import org.apache.solr.core.CoreDescriptor;
-import org.apache.solr.core.SolrResourceLoader;
-import org.apache.solr.handler.JsonUpdateRequestHandler;
-import org.apache.solr.handler.XmlUpdateRequestHandler;
-import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.SolrRequestInfo;
-import org.apache.solr.response.QueryResponseWriter;
-import org.apache.solr.response.SolrQueryResponse;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.servlet.DirectSolrConnection;
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
-import org.apache.solr.common.util.NamedList.NamedListEntry;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-import javax.xml.xpath.XPathFactory;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.StringReader;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
-import java.util.HashMap;
-import java.util.Map;
-
-
-/**
- * This class provides a simple harness that may be useful when
- * writing testcases.
- *
- * <p>
- * This class lives in the main source tree (and not in the test source
- * tree), so that it will be included with even the most minimal solr
- * distribution, in order to encourage plugin writers to create unit 
- * tests for their plugins.
- *
- * @version $Id$
- */
-public class TestHarness {
-  protected CoreContainer container;
-  private SolrCore core;
-  private XPath xpath = XPathFactory.newInstance().newXPath();
-  private DocumentBuilder builder;
-  public XmlUpdateRequestHandler updater;
-        
-  public static SolrConfig createConfig(String confFile) {
-      // set some system properties for use by tests
-      System.setProperty("solr.test.sys.prop1", "propone");
-      System.setProperty("solr.test.sys.prop2", "proptwo");
-      try {
-      return new SolrConfig(confFile);
-      }
-      catch(Exception xany) {
-        throw new RuntimeException(xany);
-      }
-  }
-        
-  /**
-   * Assumes "solrconfig.xml" is the config file to use, and
-   * "schema.xml" is the schema path to use.
-   *
-   * @param dataDirectory path for index data, will not be cleaned up
-   */
-  public TestHarness( String dataDirectory) {
-    this( dataDirectory, "schema.xml");
-  }
-  
-  /**
-   * Assumes "solrconfig.xml" is the config file to use.
-   *
-   * @param dataDirectory path for index data, will not be cleaned up
-   * @param schemaFile path of schema file
-   */
-  public TestHarness( String dataDirectory, String schemaFile) {
-    this( dataDirectory, "solrconfig.xml", schemaFile);
-  }
-  /**
-   * @param dataDirectory path for index data, will not be cleaned up
-   * @param configFile solrconfig filename
-   * @param schemaFile schema filename
-   */
-   public TestHarness( String dataDirectory, String configFile, String schemaFile) {
-     this( dataDirectory, createConfig(configFile), schemaFile);
-   }
-   /**
-    * @param dataDirectory path for index data, will not be cleaned up
-    * @param solrConfig solronfig instance
-    * @param schemaFile schema filename
-    */
-      public TestHarness( String dataDirectory,
-                          SolrConfig solrConfig,
-                          String schemaFile) {
-     this( dataDirectory, solrConfig, new IndexSchema(solrConfig, schemaFile, null));
-   }
-   /**
-    * @param dataDirectory path for index data, will not be cleaned up
-    * @param solrConfig solrconfig instance
-    * @param indexSchema schema instance
-    */
-  public TestHarness( String dataDirectory,
-                      SolrConfig solrConfig,
-                      IndexSchema indexSchema) {
-      this("", new Initializer("", dataDirectory, solrConfig, indexSchema));
-  }
-  
-  public TestHarness(String coreName, CoreContainer.Initializer init) {
-    try {
-      container = init.initialize();
-      if (coreName == null)
-        coreName = "";
-      // get the core & decrease its refcount:
-      // the container holds the core for the harness lifetime
-      core = container.getCore(coreName);
-      if (core != null)
-        core.close();
-      builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
-      
-      updater = new XmlUpdateRequestHandler();
-      updater.init( null );
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
-  }
-  
-  // Creates a container based on infos needed to create one core
-  static class Initializer extends CoreContainer.Initializer {
-    String coreName;
-    String dataDirectory;
-    SolrConfig solrConfig;
-    IndexSchema indexSchema;
-    public Initializer(String coreName,
-                      String dataDirectory,
-                      SolrConfig solrConfig,
-                      IndexSchema indexSchema) {
-      if (coreName == null)
-        coreName = "";
-      this.coreName = coreName;
-      this.dataDirectory = dataDirectory;
-      this.solrConfig = solrConfig;
-      this.indexSchema = indexSchema;
-    }
-    public String getCoreName() {
-      return coreName;
-    }
-    @Override
-    public CoreContainer initialize() {
-      CoreContainer container = new CoreContainer(new SolrResourceLoader(SolrResourceLoader.locateSolrHome())) {
-        {
-          hostPort = System.getProperty("hostPort");
-          hostContext = "solr";
-          defaultCoreName = "collection1";
-          initZooKeeper(System.getProperty("zkHost"), 10000);
-        }
-      };
-      
-      CoreDescriptor dcore = new CoreDescriptor(container, coreName, solrConfig.getResourceLoader().getInstanceDir());
-      dcore.setConfigName(solrConfig.getResourceName());
-      dcore.setSchemaName(indexSchema.getResourceName());
-      SolrCore core = new SolrCore("collection1", dataDirectory, solrConfig, indexSchema, dcore);
-      container.register(coreName, core, false);
-
-      return container;
-    }
-  }
-  
-  public CoreContainer getCoreContainer() {
-    return container;
-  }
-
-  public SolrCore getCore() {
-    return core;
-  }
-        
-  /**
-   * Processes an "update" (add, commit or optimize) and
-   * returns the response as a String.
-   *
-   * @param xml The XML of the update
-   * @return The XML response to the update
-   */
-  public String update(String xml) {
-    DirectSolrConnection connection = new DirectSolrConnection(core);
-    SolrRequestHandler handler = core.getRequestHandler("/update");
-    // prefer the handler mapped to /update, but use our generic backup handler
-    // if that lookup fails
-    if (handler == null) {
-      handler = updater;
-    }
-    try {
-      return connection.request(handler, null, xml);
-    } catch (SolrException e) {
-      throw (SolrException)e;
-    } catch (Exception e) {
-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
-    }
-  }
-  
-        
-  /**
-   * Validates that an "update" (add, commit or optimize) results in success.
-   *
-   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
-   * 
-   * @param xml The XML of the update
-   * @return null if successful, otherwise the XML response to the update
-   */
-  public String validateUpdate(String xml) throws SAXException {
-    return checkUpdateStatus(xml, "0");
-  }
-
-  /**
-   * Validates that an "update" (add, commit or optimize) results in success.
-   *
-   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
-   * 
-   * @param xml The XML of the update
-   * @return null if successful, otherwise the XML response to the update
-   */
-  public String validateErrorUpdate(String xml) throws SAXException {
-    try {
-      return checkUpdateStatus(xml, "1");
-    } catch (SolrException e) {
-      // return ((SolrException)e).getMessage();
-      return null;  // success
-    }
-  }
-
-  /**
-   * Validates that an "update" (add, commit or optimize) results in success.
-   *
-   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
-   * 
-   * @param xml The XML of the update
-   * @return null if successful, otherwise the XML response to the update
-   */
-  public String checkUpdateStatus(String xml, String code) throws SAXException {
-    try {
-      String res = update(xml);
-      String valid = validateXPath(res, "//int[@name='status']="+code );
-      return (null == valid) ? null : res;
-    } catch (XPathExpressionException e) {
-      throw new RuntimeException
-        ("?!? static xpath has bug?", e);
-    }
-  }
-
-    
-  /**
-   * Validates a "query" response against an array of XPath test strings
-   *
-   * @param req the Query to process
-   * @return null if all good, otherwise the first test that fails.
-   * @exception Exception any exception in the response.
-   * @exception IOException if there is a problem writing the XML
-   * @see LocalSolrQueryRequest
-   */
-  public String validateQuery(SolrQueryRequest req, String... tests)
-    throws IOException, Exception {
-                
-    String res = query(req);
-    return validateXPath(res, tests);
-  }
-            
-  /**
-   * Processes a "query" using a user constructed SolrQueryRequest
-   *
-   * @param req the Query to process, will be closed.
-   * @return The XML response to the query
-   * @exception Exception any exception in the response.
-   * @exception IOException if there is a problem writing the XML
-   * @see LocalSolrQueryRequest
-   */
-  public String query(SolrQueryRequest req) throws IOException, Exception {
-    return query(req.getParams().get(CommonParams.QT), req);
-  }
-
-  /**
-   * Processes a "query" using a user constructed SolrQueryRequest, and closes the request at the end.
-   *
-   * @param handler the name of the request handler to process the request
-   * @param req the Query to process, will be closed.
-   * @return The XML response to the query
-   * @exception Exception any exception in the response.
-   * @exception IOException if there is a problem writing the XML
-   * @see LocalSolrQueryRequest
-   */
-  public String query(String handler, SolrQueryRequest req) throws IOException, Exception {
-    try {
-      SolrQueryResponse rsp = new SolrQueryResponse();
-      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));
-      core.execute(core.getRequestHandler(handler),req,rsp);
-      if (rsp.getException() != null) {
-        throw rsp.getException();
-      }
-      StringWriter sw = new StringWriter(32000);
-      QueryResponseWriter responseWriter = core.getQueryResponseWriter(req);
-      responseWriter.write(sw,req,rsp);
-
-      req.close();
-
-      return sw.toString();
-    } finally {
-      req.close();
-      SolrRequestInfo.clearRequestInfo();
-    }
-  }
-
-  /** It is the users responsibility to close the request object when done with it.
-   * This method does not set/clear SolrRequestInfo */
-  public SolrQueryResponse queryAndResponse(String handler, SolrQueryRequest req) throws Exception {
-    SolrQueryResponse rsp = new SolrQueryResponse();
-    core.execute(core.getRequestHandler(handler),req,rsp);
-    if (rsp.getException() != null) {
-      throw rsp.getException();
-    }
-    return rsp;
-  }
-
-
-  /**
-   * A helper method which valides a String against an array of XPath test
-   * strings.
-   *
-   * @param xml The xml String to validate
-   * @param tests Array of XPath strings to test (in boolean mode) on the xml
-   * @return null if all good, otherwise the first test that fails.
-   */
-  public String validateXPath(String xml, String... tests)
-    throws XPathExpressionException, SAXException {
-        
-    if (tests==null || tests.length == 0) return null;
-                
-    Document document=null;
-    try {
-      document = builder.parse(new ByteArrayInputStream
-                               (xml.getBytes("UTF-8")));
-    } catch (UnsupportedEncodingException e1) {
-      throw new RuntimeException("Totally weird UTF-8 exception", e1);
-    } catch (IOException e2) {
-      throw new RuntimeException("Totally weird io exception", e2);
-    }
-                
-    for (String xp : tests) {
-      xp=xp.trim();
-      Boolean bool = (Boolean) xpath.evaluate(xp, document,
-                                              XPathConstants.BOOLEAN);
-
-      if (!bool) {
-        return xp;
-      }
-    }
-    return null;
-                
-  }
-
-  /**
-   * Shuts down and frees any resources
-   */
-  public void close() {
-    if (container != null) {
-      for (SolrCore c : container.getCores()) {
-        if (c.getOpenCount() > 1)
-          throw new RuntimeException("SolrCore.getOpenCount()=="+core.getOpenCount());
-      }      
-    }
-
-    if (container != null) {
-      container.shutdown();
-      container = null;
-    }
-  }
-
-  /**
-   * A helper that creates an xml &lt;doc&gt; containing all of the
-   * fields and values specified
-   *
-   * @param fieldsAndValues 0 and Even numbered args are fields names odds are field values.
-   */
-  public static StringBuffer makeSimpleDoc(String... fieldsAndValues) {
-
-    try {
-      StringWriter w = new StringWriter();
-      w.append("<doc>");
-      for (int i = 0; i < fieldsAndValues.length; i+=2) {
-        XML.writeXML(w, "field", fieldsAndValues[i+1], "name",
-                     fieldsAndValues[i]);
-      }
-      w.append("</doc>");
-      return w.getBuffer();
-    } catch (IOException e) {
-      throw new RuntimeException
-        ("this should never happen with a StringWriter", e);
-    }
-  }
-
-  /**
-   * Generates a delete by query xml string
-   * @param q Query that has not already been xml escaped
-   */
-  public static String deleteByQuery(String q) {
-    return delete("query", q);
-  }
-  /**
-   * Generates a delete by id xml string
-   * @param id ID that has not already been xml escaped
-   */
-  public static String deleteById(String id) {
-    return delete("id", id);
-  }
-        
-  /**
-   * Generates a delete xml string
-   * @param val text that has not already been xml escaped
-   */
-  private static String delete(String deltype, String val) {
-    try {
-      StringWriter r = new StringWriter();
-            
-      r.write("<delete>");
-      XML.writeXML(r, deltype, val);
-      r.write("</delete>");
-            
-      return r.getBuffer().toString();
-    } catch (IOException e) {
-      throw new RuntimeException
-        ("this should never happen with a StringWriter", e);
-    }
-  }
-    
-  /**
-   * Helper that returns an &lt;optimize&gt; String with
-   * optional key/val pairs.
-   *
-   * @param args 0 and Even numbered args are params, Odd numbered args are values.
-   */
-  public static String optimize(String... args) {
-    return simpleTag("optimize", args);
-  }
-
-  private static String simpleTag(String tag, String... args) {
-    try {
-      StringWriter r = new StringWriter();
-
-      // this is annoying
-      if (null == args || 0 == args.length) {
-        XML.writeXML(r, tag, null);
-      } else {
-        XML.writeXML(r, tag, null, (Object[])args);
-      }
-      return r.getBuffer().toString();
-    } catch (IOException e) {
-      throw new RuntimeException
-        ("this should never happen with a StringWriter", e);
-    }
-  }
-    
-  /**
-   * Helper that returns an &lt;commit&gt; String with
-   * optional key/val pairs.
-   *
-   * @param args 0 and Even numbered args are params, Odd numbered args are values.
-   */
-  public static String commit(String... args) {
-    return simpleTag("commit", args);
-  }
-    
-  public LocalRequestFactory getRequestFactory(String qtype,
-                                               int start,
-                                               int limit) {
-    LocalRequestFactory f = new LocalRequestFactory();
-    f.qtype = qtype;
-    f.start = start;
-    f.limit = limit;
-    return f;
-  }
-    
-  /**
-   * 0 and Even numbered args are keys, Odd numbered args are values.
-   */
-  public LocalRequestFactory getRequestFactory(String qtype,
-                                               int start, int limit,
-                                               String... args) {
-    LocalRequestFactory f = getRequestFactory(qtype, start, limit);
-    for (int i = 0; i < args.length; i+=2) {
-      f.args.put(args[i], args[i+1]);
-    }
-    return f;
-        
-  }
-    
-  public LocalRequestFactory getRequestFactory(String qtype,
-                                               int start, int limit,
-                                               Map<String,String> args) {
-
-    LocalRequestFactory f = getRequestFactory(qtype, start, limit);
-    f.args.putAll(args);
-    return f;
-  }
-    
-  /**
-   * A Factory that generates LocalSolrQueryRequest objects using a
-   * specified set of default options.
-   */
-  public class LocalRequestFactory {
-    public String qtype = "standard";
-    public int start = 0;
-    public int limit = 1000;
-    public Map<String,String> args = new HashMap<String,String>();
-    public LocalRequestFactory() {
-    }
-    /**
-     * Creates a LocalSolrQueryRequest based on variable args; for
-     * historical reasons, this method has some peculiar behavior:
-     * <ul>
-     *   <li>If there is a single arg, then it is treated as the "q"
-     *       param, and the LocalSolrQueryRequest consists of that query
-     *       string along with "qt", "start", and "rows" params (based
-     *       on the qtype, start, and limit properties of this factory)
-     *       along with any other default "args" set on this factory.
-     *   </li>
-     *   <li>If there are multiple args, then there must be an even number
-     *       of them, and each pair of args is used as a key=value param in
-     *       the LocalSolrQueryRequest.  <b>NOTE: In this usage, the "qtype",
-     *       "start", "limit", and "args" properties of this factory are
-     *       ignored.</b>
-     *   </li>
-     * </ul>
-     */
-    public LocalSolrQueryRequest makeRequest(String ... q) {
-      if (q.length==1) {
-        return new LocalSolrQueryRequest(TestHarness.this.getCore(),
-                                       q[0], qtype, start, limit, args);
-      }
-      if (q.length%2 != 0) { 
-        throw new RuntimeException("The length of the string array (query arguments) needs to be even");
-      }
-      Map.Entry<String, String> [] entries = new NamedListEntry[q.length / 2];
-      for (int i = 0; i < q.length; i += 2) {
-        entries[i/2] = new NamedListEntry<String>(q[i], q[i+1]);
-      }
-      return new LocalSolrQueryRequest(TestHarness.this.getCore(), new NamedList(entries));
-    }
-  }
-}
diff --git a/solr/src/site/src/documentation/content/xdocs/site.xml b/solr/src/site/src/documentation/content/xdocs/site.xml
index 879508b..58fe3f7 100755
--- a/solr/src/site/src/documentation/content/xdocs/site.xml
+++ b/solr/src/site/src/documentation/content/xdocs/site.xml
@@ -42,12 +42,13 @@ See http://forrest.apache.org/docs/linking.html for more info
   </about>
 
   <docs label="Documentation">
-    <features    label="Features"         href="features.html" />
-    <tutorial    label="Tutorial"         href="tutorial.html" />
-    <wiki        label="Docs (Wiki)" href="ext:wiki" />
-    <faq         label="FAQ"              href="ext:faq" />
-    <apidocs     label="All Javadoc"     href="api/index.html" />
-    <apidocs     label="SolrJ Javadoc"     href="api/solrj/index.html" />
+    <features    label="Features"                href="features.html" />
+    <tutorial    label="Tutorial"                href="tutorial.html" />
+    <wiki        label="Docs (Wiki)"             href="ext:wiki" />
+    <faq         label="FAQ"                     href="ext:faq" />
+    <apidocs     label="All Javadoc"             href="api/index.html" />
+    <apidocs     label="SolrJ Javadoc"           href="api/solrj/index.html" />
+    <apidocs     label="Test Framework Javadoc"  href="api/test-framework/index.html" />
   </docs>
 
   <resources label="Resources">
diff --git a/solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase.java b/solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase.java
new file mode 100644
index 0000000..1ec2654
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/BaseDistributedSearchTestCase.java
@@ -0,0 +1,638 @@
+package org.apache.solr;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+
+import junit.framework.TestCase;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.embedded.JettySolrRunner;
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.schema.TrieDateField;
+import org.apache.solr.util.AbstractSolrTestCase;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Helper base class for distributed search test cases
+ *
+ * @since solr 1.5
+ */
+public abstract class BaseDistributedSearchTestCase extends SolrTestCaseJ4 {
+  public static Random r = random;
+
+  protected int shardCount = 4;
+  /**
+   * Sub classes can set this flag in their constructor to true if they
+   * want to fix the number of shards to 'shardCount'
+   *
+   * The default is false which means that test will be executed with
+   * 1, 2, 3, ....shardCount number of shards repeatedly
+   */
+  protected boolean fixShardCount = false;
+
+  protected JettySolrRunner controlJetty;
+  protected List<SolrServer> clients = new ArrayList<SolrServer>();
+  protected List<JettySolrRunner> jettys = new ArrayList<JettySolrRunner>();
+  protected String context = "/solr";
+  protected String shards;
+  protected String[] shardsArr;
+  // Some ISPs redirect to their own web site for domains that don't exist, causing this to fail
+  // protected String[] deadServers = {"does_not_exist_54321.com:33331/solr","localhost:33332/solr"};
+  protected String[] deadServers = {"[::1]:33332/solr"};
+  protected File testDir;
+  protected SolrServer controlClient;
+
+  // to stress with higher thread counts and requests, make sure the junit
+  // xml formatter is not being used (all output will be buffered before
+  // transformation to xml and cause an OOM exception).
+  protected int stress = 2;
+  protected boolean verifyStress = true;
+  protected int nThreads = 3;
+
+
+  public static int ORDERED = 1;
+  public static int SKIP = 2;
+  public static int SKIPVAL = 4;
+  public static int UNORDERED = 8;
+
+  protected int flags;
+  protected Map<String, Integer> handle = new HashMap<String, Integer>();
+
+  protected String id = "id";
+  public static Logger log = LoggerFactory.getLogger(BaseDistributedSearchTestCase.class);
+  
+  public static RandVal rint = new RandVal() {
+    @Override
+    public Object val() {
+      return r.nextInt();
+    }
+  };
+
+  public static RandVal rlong = new RandVal() {
+    @Override
+    public Object val() {
+      return r.nextLong();
+    }
+  };
+
+  public static RandVal rfloat = new RandVal() {
+    @Override
+    public Object val() {
+      return r.nextFloat();
+    }
+  };
+
+  public static RandVal rdouble = new RandVal() {
+    @Override
+    public Object val() {
+      return r.nextDouble();
+    }
+  };
+
+  public static RandVal rdate = new RandDate();
+
+  /**
+   * Perform the actual tests here
+   *
+   * @throws Exception on error
+   */
+  public abstract void doTest() throws Exception;
+
+  public static String[] fieldNames = new String[]{"n_ti1", "n_f1", "n_tf1", "n_d1", "n_td1", "n_l1", "n_tl1", "n_dt1", "n_tdt1"};
+  public static RandVal[] randVals = new RandVal[]{rint, rfloat, rfloat, rdouble, rdouble, rlong, rlong, rdate, rdate};
+
+  protected String[] getFieldNames() {
+    return fieldNames;
+  }
+
+  protected RandVal[] getRandValues() {
+    return randVals;
+  }
+
+  /**
+   * Subclasses can override this to change a test's solr home
+   * (default is in test-files)
+   */
+  public String getSolrHome() {
+    return SolrTestCaseJ4.TEST_HOME();
+  }
+  
+  @Override
+  public void setUp() throws Exception {
+    SolrTestCaseJ4.resetExceptionIgnores();  // ignore anything with ignore_exception in it
+    super.setUp();
+    System.setProperty("solr.test.sys.prop1", "propone");
+    System.setProperty("solr.test.sys.prop2", "proptwo");
+    System.setProperty("solr.solr.home", getSolrHome());
+    testDir = new File(TEMP_DIR,
+            getClass().getName() + "-" + System.currentTimeMillis());
+    testDir.mkdirs();
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    destroyServers();
+    if (!AbstractSolrTestCase.recurseDelete(testDir)) {
+      System.err.println("!!!! WARNING: best effort to remove " + testDir.getAbsolutePath() + " FAILED !!!!!");
+    }
+    super.tearDown();
+  }
+
+  protected void createServers(int numShards) throws Exception {
+    controlJetty = createJetty(testDir, testDir + "/control/data");
+    controlClient = createNewSolrServer(controlJetty.getLocalPort());
+
+    shardsArr = new String[numShards];
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < numShards; i++) {
+      if (sb.length() > 0) sb.append(',');
+      JettySolrRunner j = createJetty(testDir, testDir + "/shard" + i + "/data");
+      jettys.add(j);
+      clients.add(createNewSolrServer(j.getLocalPort()));
+      String shardStr = "localhost:" + j.getLocalPort() + context;
+      shardsArr[i] = shardStr;
+      sb.append(shardStr);
+    }
+
+    shards = sb.toString();
+  }
+
+
+  protected void setDistributedParams(ModifiableSolrParams params) {
+    params.set("shards", getShardsString());
+  }
+
+  protected String getShardsString() {
+    if (deadServers == null) return shards;
+    
+    StringBuilder sb = new StringBuilder();
+    for (String shard : shardsArr) {
+      if (sb.length() > 0) sb.append(',');
+      int nDeadServers = r.nextInt(deadServers.length+1);
+      if (nDeadServers > 0) {
+        List<String> replicas = new ArrayList<String>(Arrays.asList(deadServers));
+        Collections.shuffle(replicas, r);
+        replicas.add(r.nextInt(nDeadServers+1), shard);
+        for (int i=0; i<nDeadServers+1; i++) {
+          if (i!=0) sb.append('|');
+          sb.append(replicas.get(i));
+        }
+      } else {
+        sb.append(shard);
+      }
+    }
+
+    return sb.toString();
+  }
+
+  protected void destroyServers() throws Exception {
+    controlJetty.stop();
+    for (JettySolrRunner jetty : jettys) jetty.stop();
+    clients.clear();
+    jettys.clear();
+  }
+  
+  public JettySolrRunner createJetty(File baseDir, String dataDir) throws Exception {
+    return createJetty(baseDir, dataDir, null, null);
+  }
+
+  public JettySolrRunner createJetty(File baseDir, String dataDir, String shardId) throws Exception {
+    return createJetty(baseDir, dataDir, shardId, null);
+  }
+  
+  public JettySolrRunner createJetty(File baseDir, String dataDir, String shardList, String solrConfigOverride) throws Exception {
+    System.setProperty("solr.data.dir", dataDir);
+    JettySolrRunner jetty = new JettySolrRunner("/solr", 0, solrConfigOverride);
+    if(shardList != null) {
+      System.setProperty("shard", shardList);
+    }
+    jetty.start();
+    System.clearProperty("shard");
+    return jetty;
+  }
+  
+  protected SolrServer createNewSolrServer(int port) {
+    try {
+      // setup the server...
+      String url = "http://localhost:" + port + context;
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer(url);
+      s.setConnectionTimeout(100); // 1/10th sec
+      s.setDefaultMaxConnectionsPerHost(100);
+      s.setMaxTotalConnections(100);
+      return s;
+    }
+    catch (Exception ex) {
+      throw new RuntimeException(ex);
+    }
+  }
+
+  protected void addFields(SolrInputDocument doc, Object... fields) {
+    for (int i = 0; i < fields.length; i += 2) {
+      doc.addField((String) (fields[i]), fields[i + 1]);
+    }
+  }// add random fields to the documet before indexing
+
+  protected void indexr(Object... fields) throws Exception {
+    SolrInputDocument doc = new SolrInputDocument();
+    addFields(doc, fields);
+    addFields(doc, "rnd_b", true);
+    addFields(doc, getRandFields(getFieldNames(), getRandValues()));
+    indexDoc(doc);
+  }
+
+  protected void index(Object... fields) throws Exception {
+    SolrInputDocument doc = new SolrInputDocument();
+    addFields(doc, fields);
+    indexDoc(doc);
+  }
+
+  protected void indexDoc(SolrInputDocument doc) throws IOException, SolrServerException {
+    controlClient.add(doc);
+
+    int which = (doc.getField(id).toString().hashCode() & 0x7fffffff) % clients.size();
+    SolrServer client = clients.get(which);
+    client.add(doc);
+  }
+
+  protected void index_specific(int serverNumber, Object... fields) throws Exception {
+    SolrInputDocument doc = new SolrInputDocument();
+    for (int i = 0; i < fields.length; i += 2) {
+      doc.addField((String) (fields[i]), fields[i + 1]);
+    }
+    controlClient.add(doc);
+
+    SolrServer client = clients.get(serverNumber);
+    client.add(doc);
+  }
+
+  protected void del(String q) throws Exception {
+    controlClient.deleteByQuery(q);
+    for (SolrServer client : clients) {
+      client.deleteByQuery(q);
+    }
+  }// serial commit...
+
+  protected void commit() throws Exception {
+    controlClient.commit();
+    for (SolrServer client : clients) client.commit();
+  }
+
+  protected QueryResponse queryServer(ModifiableSolrParams params) throws SolrServerException {
+    // query a random server
+    int which = r.nextInt(clients.size());
+    SolrServer client = clients.get(which);
+    QueryResponse rsp = client.query(params);
+    return rsp;
+  }
+
+  protected void query(Object... q) throws Exception {
+    final ModifiableSolrParams params = new ModifiableSolrParams();
+
+    for (int i = 0; i < q.length; i += 2) {
+      params.add(q[i].toString(), q[i + 1].toString());
+    }
+
+    final QueryResponse controlRsp = controlClient.query(params);
+
+    setDistributedParams(params);
+
+    QueryResponse rsp = queryServer(params);
+
+    compareResponses(rsp, controlRsp);
+
+    if (stress > 0) {
+      log.info("starting stress...");
+      Thread[] threads = new Thread[nThreads];
+      for (int i = 0; i < threads.length; i++) {
+        threads[i] = new Thread() {
+          @Override
+          public void run() {
+            for (int j = 0; j < stress; j++) {
+              int which = r.nextInt(clients.size());
+              SolrServer client = clients.get(which);
+              try {
+                QueryResponse rsp = client.query(new ModifiableSolrParams(params));
+                if (verifyStress) {
+                  compareResponses(rsp, controlRsp);
+                }
+              } catch (SolrServerException e) {
+                throw new RuntimeException(e);
+              }
+            }
+          }
+        };
+        threads[i].start();
+      }
+
+      for (Thread thread : threads) {
+        thread.join();
+      }
+    }
+  }
+
+  public static boolean eq(String a, String b) {
+    return a == b || (a != null && a.equals(b));
+  }
+
+  public static int flags(Map<String, Integer> handle, Object key) {
+    if (handle == null) return 0;
+    Integer f = handle.get(key);
+    return f == null ? 0 : f;
+  }
+
+  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {
+    boolean ordered = (flags & UNORDERED) == 0;
+
+    int posa = 0, posb = 0;
+    int aSkipped = 0, bSkipped = 0;
+
+    for (; ;) {
+      if (posa >= a.size() || posb >= b.size()) {
+        break;
+      }
+
+      String namea, nameb;
+      Object vala, valb = null;
+
+      int flagsa, flagsb;
+      for (; ;) {
+        namea = a.getName(posa);
+        vala = a.getVal(posa);
+        posa++;
+        flagsa = flags(handle, namea);
+        if ((flagsa & SKIP) != 0) {
+          aSkipped++;
+          continue;
+        }
+        break;
+      }
+
+      if (!ordered) posb = 0;  // reset if not ordered
+
+      while (posb < b.size()) {
+        nameb = b.getName(posb);
+        valb = b.getVal(posb);
+        posb++;
+        flagsb = flags(handle, nameb);
+        if ((flagsb & SKIP) != 0) {
+          bSkipped++;
+          continue;
+        }
+        if (eq(namea, nameb)) {
+          break;
+        }
+        if (ordered) {
+          return "." + namea + "!=" + nameb + " (unordered or missing)";
+        }
+        // if unordered, continue until we find the right field.
+      }
+
+      // ok, namea and nameb should be equal here already.
+      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough
+
+      String cmp = compare(vala, valb, flagsa, handle);
+      if (cmp != null) return "." + namea + cmp;
+    }
+
+
+    if (a.size() - aSkipped != b.size() - bSkipped) {
+      return ".size()==" + a.size() + "," + b.size() + "skipped=" + aSkipped + "," + bSkipped;
+    }
+
+    return null;
+  }
+
+  public static String compare1(Map a, Map b, int flags, Map<String, Integer> handle) {
+    String cmp;
+
+    for (Object keya : a.keySet()) {
+      Object vala = a.get(keya);
+      int flagsa = flags(handle, keya);
+      if ((flagsa & SKIP) != 0) continue;
+      if (!b.containsKey(keya)) {
+        return "[" + keya + "]==null";
+      }
+      if ((flagsa & SKIPVAL) != 0) continue;
+      Object valb = b.get(keya);
+      cmp = compare(vala, valb, flagsa, handle);
+      if (cmp != null) return "[" + keya + "]" + cmp;
+    }
+    return null;
+  }
+
+  public static String compare(Map a, Map b, int flags, Map<String, Integer> handle) {
+    String cmp;
+    cmp = compare1(a, b, flags, handle);
+    if (cmp != null) return cmp;
+    return compare1(b, a, flags, handle);
+  }
+
+  public static String compare(SolrDocument a, SolrDocument b, int flags, Map<String, Integer> handle) {
+    return compare(a.getFieldValuesMap(), b.getFieldValuesMap(), flags, handle);
+  }
+
+  public static String compare(SolrDocumentList a, SolrDocumentList b, int flags, Map<String, Integer> handle) {
+    boolean ordered = (flags & UNORDERED) == 0;
+
+    String cmp;
+    int f = flags(handle, "maxScore");
+    if ((f & SKIPVAL) == 0) {
+      cmp = compare(a.getMaxScore(), b.getMaxScore(), 0, handle);
+      if (cmp != null) return ".maxScore" + cmp;
+    } else {
+      if (b.getMaxScore() != null) {
+        if (a.getMaxScore() == null) {
+          return ".maxScore missing";
+        }
+      }
+    }
+
+    cmp = compare(a.getNumFound(), b.getNumFound(), 0, handle);
+    if (cmp != null) return ".numFound" + cmp;
+
+    cmp = compare(a.getStart(), b.getStart(), 0, handle);
+    if (cmp != null) return ".start" + cmp;
+
+    cmp = compare(a.size(), b.size(), 0, handle);
+    if (cmp != null) return ".size()" + cmp;
+
+    // only for completely ordered results (ties might be in a different order)
+    if (ordered) {
+      for (int i = 0; i < a.size(); i++) {
+        cmp = compare(a.get(i), b.get(i), 0, handle);
+        if (cmp != null) return "[" + i + "]" + cmp;
+      }
+      return null;
+    }
+
+    // unordered case
+    for (int i = 0; i < a.size(); i++) {
+      SolrDocument doc = a.get(i);
+      Object key = doc.getFirstValue("id");
+      SolrDocument docb = null;
+      if (key == null) {
+        // no id field to correlate... must compare ordered
+        docb = b.get(i);
+      } else {
+        for (int j = 0; j < b.size(); j++) {
+          docb = b.get(j);
+          if (key.equals(docb.getFirstValue("id"))) break;
+        }
+      }
+      // if (docb == null) return "[id="+key+"]";
+      cmp = compare(doc, docb, 0, handle);
+      if (cmp != null) return "[id=" + key + "]" + cmp;
+    }
+    return null;
+  }
+
+  public static String compare(Object[] a, Object[] b, int flags, Map<String, Integer> handle) {
+    if (a.length != b.length) {
+      return ".length:" + a.length + "!=" + b.length;
+    }
+    for (int i = 0; i < a.length; i++) {
+      String cmp = compare(a[i], b[i], flags, handle);
+      if (cmp != null) return "[" + i + "]" + cmp;
+    }
+    return null;
+  }
+
+  public static String compare(Object a, Object b, int flags, Map<String, Integer> handle) {
+    if (a == b) return null;
+    if (a == null || b == null) return ":" + a + "!=" + b;
+
+    if (a instanceof NamedList && b instanceof NamedList) {
+      return compare((NamedList) a, (NamedList) b, flags, handle);
+    }
+
+    if (a instanceof SolrDocumentList && b instanceof SolrDocumentList) {
+      return compare((SolrDocumentList) a, (SolrDocumentList) b, flags, handle);
+    }
+
+    if (a instanceof SolrDocument && b instanceof SolrDocument) {
+      return compare((SolrDocument) a, (SolrDocument) b, flags, handle);
+    }
+
+    if (a instanceof Map && b instanceof Map) {
+      return compare((Map) a, (Map) b, flags, handle);
+    }
+
+    if (a instanceof Object[] && b instanceof Object[]) {
+      return compare((Object[]) a, (Object[]) b, flags, handle);
+    }
+
+    if (a instanceof byte[] && b instanceof byte[]) {
+      if (!Arrays.equals((byte[]) a, (byte[]) b)) {
+        return ":" + a + "!=" + b;
+      }
+      return null;
+    }
+
+    if (a instanceof List && b instanceof List) {
+      return compare(((List) a).toArray(), ((List) b).toArray(), flags, handle);
+
+    }
+
+    if (!(a.equals(b))) {
+      return ":" + a + "!=" + b;
+    }
+
+    return null;
+  }
+
+  protected void compareResponses(QueryResponse a, QueryResponse b) {
+    String cmp;
+    cmp = compare(a.getResponse(), b.getResponse(), flags, handle);
+    if (cmp != null) {
+      log.info("Mismatched responses:\n" + a + "\n" + b);
+      TestCase.fail(cmp);
+    }
+  }
+
+  @Test
+  public void testDistribSearch() throws Exception {
+    if (fixShardCount) {
+      createServers(shardCount);
+      RandVal.uniqueValues = new HashSet(); //reset random values
+      doTest();
+      destroyServers();
+    } else {
+      for (int nServers = 1; nServers < shardCount; nServers++) {
+        createServers(nServers);
+        RandVal.uniqueValues = new HashSet(); //reset random values
+        doTest();
+        destroyServers();
+      }
+    }
+  }
+
+  public static Object[] getRandFields(String[] fields, RandVal[] randVals) {
+    Object[] o = new Object[fields.length * 2];
+    for (int i = 0; i < fields.length; i++) {
+      o[i * 2] = fields[i];
+      o[i * 2 + 1] = randVals[i].uval();
+    }
+    return o;
+  }
+
+  public static abstract class RandVal {
+    public static Random r = random;
+    public static Set uniqueValues = new HashSet();
+
+    public abstract Object val();
+
+    public Object uval() {
+      for (; ;) {
+        Object v = val();
+        if (uniqueValues.add(v)) return v;
+      }
+    }
+  }
+
+  public static class RandDate extends RandVal {
+    public static TrieDateField df = new TrieDateField();
+
+    @Override
+    public Object val() {
+      long v = r.nextLong();
+      Date d = new Date(v);
+      return df.toExternal(d);
+    }
+  }
+}
diff --git a/solr/src/test-framework/org/apache/solr/JSONTestUtil.java b/solr/src/test-framework/org/apache/solr/JSONTestUtil.java
new file mode 100644
index 0000000..8bd5a79
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/JSONTestUtil.java
@@ -0,0 +1,346 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr;
+
+import org.apache.noggit.ObjectBuilder;
+import org.apache.solr.common.util.StrUtils;
+
+import java.util.*;
+
+
+public class JSONTestUtil {
+
+  public static String match(String input, String pathAndExpected) throws Exception {
+    int pos = pathAndExpected.indexOf("==");
+    String path = pos>=0 ? pathAndExpected.substring(0,pos) : null;
+    String expected = pos>=0 ? pathAndExpected.substring(pos+2) : pathAndExpected;
+    return match(path, input, expected);
+  }
+
+  public static String match(String path, String input, String expected) throws Exception {
+    Object inputObj = ObjectBuilder.fromJSON(input);
+    Object expectObj = ObjectBuilder.fromJSON(expected);
+    return matchObj(path, inputObj, expectObj);
+  }
+
+  /**
+  public static Object fromJSON(String json) {
+    try {
+      Object out = ObjectBuilder.fromJSON(json);
+    } finally {
+
+  }
+  **/
+  
+  public static String matchObj(String path, Object input, Object expected) throws Exception {
+    CollectionTester tester = new CollectionTester(input);
+    boolean reversed = path.startsWith("!");
+    String positivePath = reversed ? path.substring(1) : path;
+    if (!tester.seek(positivePath) ^ reversed) {
+      return "Path not found: " + path;
+    }
+    if (expected != null && (!tester.match(expected) ^ reversed)) {
+      return tester.err + " @ " + tester.getPath();
+    }
+    return null;
+  }
+}
+
+
+/** Tests simple object graphs, like those generated by the noggit JSON parser */
+class CollectionTester {
+  public Object valRoot;
+  public Object val;
+  public Object expectedRoot;
+  public Object expected;
+  public List<Object> path;
+  public String err;
+
+  public CollectionTester(Object val) {
+    this.val = val;
+    this.valRoot = val;
+    path = new ArrayList<Object>();
+  }
+
+  public String getPath() {
+    StringBuilder sb = new StringBuilder();
+    boolean first=true;
+    for (Object seg : path) {
+      if (seg==null) break;
+      if (!first) sb.append('/');
+      else first=false;
+
+      if (seg instanceof Integer) {
+        sb.append('[');
+        sb.append(seg);
+        sb.append(']');
+      } else {
+        sb.append(seg.toString());
+      }
+    }
+    return sb.toString();
+  }
+
+  void setPath(Object lastSeg) {
+    path.set(path.size()-1, lastSeg);
+  }
+  Object popPath() {
+    return path.remove(path.size()-1);
+  }
+  void pushPath(Object lastSeg) {
+    path.add(lastSeg);
+  }
+
+  void setErr(String msg) {
+    err = msg;
+  }
+
+  public boolean match(Object expected) {
+    this.expectedRoot = expected;
+    this.expected = expected;
+    return match();
+  }
+
+  boolean match() {
+    if (expected == val) {
+      return true;
+    }
+    if (expected == null || val == null) {
+      setErr("mismatch: '" + expected + "'!='" + val + "'");
+      return false;
+    }
+    if (expected instanceof List) {
+      return matchList();
+    }
+    if (expected instanceof Map) {
+      return matchMap();
+    }
+
+    // generic fallback
+    if (!expected.equals(val)) {
+
+      // make an exception for some numerics
+      if ((expected instanceof Integer && val instanceof Long || expected instanceof Long && val instanceof Integer)
+          && ((Number)expected).longValue() == ((Number)val).longValue())
+      {
+        return true;
+      } else if ((expected instanceof Float && val instanceof Double || expected instanceof Double && val instanceof Float)) {
+        double a = ((Number)expected).doubleValue();
+        double b = ((Number)val).doubleValue();
+        if (Double.compare(a,b) == 0) return true;
+        if (Math.abs(a-b) < 1e-5) return true;
+        return false;
+      } else {
+        setErr("mismatch: '" + expected + "'!='" + val + "'");
+        return false;
+      }
+    }
+
+    // setErr("unknown expected type " + expected.getClass().getName());
+    return true;
+  }
+
+  boolean matchList() {
+    List expectedList = (List)expected;
+    List v = asList();
+    if (v == null) return false;
+    int a = 0;
+    int b = 0;
+    pushPath(null);
+    for (;;) {
+      if (a >= expectedList.size() &&  b >=v.size()) {
+        break;
+      }
+
+      if (a >= expectedList.size() || b >=v.size()) {
+        popPath();
+        setErr("List size mismatch");
+        return false;
+      }
+
+      expected = expectedList.get(a);
+      val = v.get(b);
+      setPath(b);
+      if (!match()) return false;
+
+      a++; b++;
+    }
+    
+    popPath();
+    return true;
+  }
+
+  private static Set<String> reserved = new HashSet<String>(Arrays.asList("_SKIP_","_MATCH_","_ORDERED_","_UNORDERED_"));
+
+  boolean matchMap() {
+    Map<String,Object> expectedMap = (Map<String,Object>)expected;
+    Map<String,Object> v = asMap();
+    if (v == null) return false;
+
+    boolean ordered = false;
+    String skipList = (String)expectedMap.get("_SKIP_");
+    String matchList = (String)expectedMap.get("_MATCH_");
+    Object orderedStr = expectedMap.get("_ORDERED_");
+    Object unorderedStr = expectedMap.get("_UNORDERED_");
+
+    if (orderedStr != null) ordered = true;
+    if (unorderedStr != null) ordered = false;
+
+    Set<String> match = null;
+    if (matchList != null) {
+      match = new HashSet(StrUtils.splitSmart(matchList,",",false));
+    }
+
+    Set<String> skips = null;
+    if (skipList != null) {
+      skips = new HashSet(StrUtils.splitSmart(skipList,",",false));
+    }
+
+    Set<String> keys = match != null ? match : expectedMap.keySet();
+    Set<String> visited = new HashSet<String>();
+
+    Iterator<Map.Entry<String,Object>> iter = ordered ? v.entrySet().iterator() : null;
+
+    int numExpected=0;
+
+    pushPath(null);
+    for (String expectedKey : keys) {
+      if (reserved.contains(expectedKey)) continue;
+      numExpected++;
+
+      setPath(expectedKey);
+      if (!v.containsKey(expectedKey)) {
+        popPath();
+        setErr("expected key '" + expectedKey + "'");
+        return false;
+      }
+
+      expected = expectedMap.get(expectedKey);
+
+      if (ordered) {
+        Map.Entry<String,Object> entry;
+        String foundKey;
+        for(;;) {
+          if (!iter.hasNext()) {
+            popPath();
+            setErr("expected key '" + expectedKey + "' in ordered map");
+            return false;           
+          }
+          entry = iter.next();
+          foundKey = entry.getKey();
+          if (skips != null && skips.contains(foundKey))continue;
+          if (match != null && !match.contains(foundKey)) continue;
+          break;
+        }
+
+        if (!entry.getKey().equals(expectedKey)) {
+          popPath();          
+          setErr("expected key '" + expectedKey + "' instead of '"+entry.getKey()+"' in ordered map");
+          return false;
+        }
+        val = entry.getValue();
+      } else {
+        if (skips != null && skips.contains(expectedKey)) continue;
+        val = v.get(expectedKey);
+      }
+
+      if (!match()) return false;
+    }
+
+    popPath();
+
+    // now check if there were any extra keys in the value (as long as there wasn't a specific list to include)
+    if (match == null) {
+      int skipped = 0;
+      if (skips != null) {
+        for (String skipStr : skips)
+          if (v.containsKey(skipStr)) skipped++;
+      }
+      if (numExpected != (v.size() - skipped)) {
+        HashSet<String> set = new HashSet<String>(v.keySet());
+        set.removeAll(expectedMap.keySet());
+        setErr("unexpected map keys " + set); 
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  public boolean seek(String seekPath) {
+    if (path == null) return true;
+    if (seekPath.startsWith("/")) {
+      seekPath = seekPath.substring(1);
+    }
+    if (seekPath.endsWith("/")) {
+      seekPath = seekPath.substring(0,seekPath.length()-1);
+    }
+    List<String> pathList = StrUtils.splitSmart(seekPath, "/", false);
+    return seek(pathList);
+  }
+
+  List asList() {
+    // TODO: handle native arrays
+    if (val instanceof List) {
+      return (List)val;
+    }
+    setErr("expected List");
+    return null;
+  }
+  
+  Map<String,Object> asMap() {
+    // TODO: handle NamedList
+    if (val instanceof Map) {
+      return (Map<String,Object>)val;
+    }
+    setErr("expected Map");
+    return null;
+  }
+
+  public boolean seek(List<String> seekPath) {
+    if (seekPath.size() == 0) return true;
+    String seg = seekPath.get(0);
+
+    if (seg.charAt(0)=='[') {
+      List listVal = asList();
+      if (listVal==null) return false;
+
+      int arrIdx = Integer.parseInt(seg.substring(1, seg.length()-1));
+
+      if (arrIdx >= listVal.size()) return false;
+
+      val = listVal.get(arrIdx);
+      pushPath(arrIdx);
+    } else {
+      Map<String,Object> mapVal = asMap();
+      if (mapVal==null) return false;
+
+      // use containsKey rather than get to handle null values
+      if (!mapVal.containsKey(seg)) return false;
+
+      val = mapVal.get(seg);
+      pushPath(seg);
+    }
+
+    // recurse after removing head of the path
+    return seek(seekPath.subList(1,seekPath.size()));
+  }
+
+
+
+}
diff --git a/solr/src/test-framework/org/apache/solr/SolrTestCaseJ4.java b/solr/src/test-framework/org/apache/solr/SolrTestCaseJ4.java
new file mode 100755
index 0000000..da5d837
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/SolrTestCaseJ4.java
@@ -0,0 +1,1071 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.solr;
+
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.noggit.CharArr;
+import org.apache.noggit.JSONUtil;
+import org.apache.noggit.ObjectBuilder;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.SolrInputField;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.handler.JsonUpdateRequestHandler;
+import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.schema.SchemaField;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.servlet.DirectSolrConnection;
+import org.apache.solr.util.TestHarness;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.SAXException;
+
+import javax.xml.xpath.XPathExpressionException;
+import java.io.File;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.*;
+
+/**
+ * A junit4 Solr test harness that extends LuceneTestCaseJ4.
+ * Unlike AbstractSolrTestCase, a new core is not created for each test method.
+ *
+ */
+public abstract class SolrTestCaseJ4 extends LuceneTestCase {
+
+  @BeforeClass
+  public static void beforeClassSolrTestCase() throws Exception {
+    ignoreException("ignore_exception");
+  }
+
+  @AfterClass
+  public static void afterClassSolrTestCase() throws Exception {
+    deleteCore();
+    resetExceptionIgnores();
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    log.info("###Starting " + getName());  // returns <unknown>???
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    log.info("###Ending " + getName());    
+    super.tearDown();
+  }
+
+  /** Call initCore in @BeforeClass to instantiate a solr core in your test class.
+   * deleteCore will be called for you via SolrTestCaseJ4 @AfterClass */
+  public static void initCore(String config, String schema) throws Exception {
+    initCore(config, schema, TEST_HOME());
+  }
+
+  /** Call initCore in @BeforeClass to instantiate a solr core in your test class.
+   * deleteCore will be called for you via SolrTestCaseJ4 @AfterClass */
+  public static void initCore(String config, String schema, String solrHome) throws Exception {
+    startTrackingSearchers();
+    configString = config;
+    schemaString = schema;
+    if (solrHome != null) {
+      System.setProperty("solr.solr.home", solrHome);
+    }
+    initCore();
+  }
+
+
+  static long numOpens;
+  static long numCloses;
+  protected static void startTrackingSearchers() {
+    numOpens = SolrIndexSearcher.numOpens.get();
+    numCloses = SolrIndexSearcher.numCloses.get();
+  }
+
+  protected static void endTrackingSearchers() {
+     long endNumOpens = SolrIndexSearcher.numOpens.get();
+     long endNumCloses = SolrIndexSearcher.numCloses.get();
+
+     if (endNumOpens-numOpens != endNumCloses-numCloses) {
+       String msg = "ERROR: SolrIndexSearcher opens=" + (endNumOpens-numOpens) + " closes=" + (endNumCloses-numCloses);
+       log.error(msg);
+       fail(msg);
+     }
+  }
+
+  /** Causes an exception matching the regex pattern to not be logged. */
+  public static void ignoreException(String pattern) {
+    if (SolrException.ignorePatterns == null)
+      SolrException.ignorePatterns = new HashSet<String>();
+    SolrException.ignorePatterns.add(pattern);
+  }
+
+  public static void resetExceptionIgnores() {
+    SolrException.ignorePatterns = null;
+    ignoreException("ignore_exception");  // always ignore "ignore_exception"    
+  }
+
+  protected static String getClassName() {
+    StackTraceElement[] stack = new RuntimeException("WhoAmI").fillInStackTrace().getStackTrace();
+    for (int i = stack.length-1; i>=0; i--) {
+      StackTraceElement ste = stack[i];
+      String cname = ste.getClassName();
+      if (cname.indexOf(".lucene.")>=0 || cname.indexOf(".solr.")>=0) {
+        return cname;
+      }
+    }
+    return SolrTestCaseJ4.class.getName();
+  }
+
+  protected static String getSimpleClassName() {
+    String cname = getClassName();
+    return cname.substring(cname.lastIndexOf('.')+1);
+  }
+
+  protected static String configString;
+  protected static String schemaString;
+
+  protected static SolrConfig solrConfig;
+  /**
+   * Harness initialized by initTestHarness.
+   *
+   * <p>
+   * For use in test methods as needed.
+   * </p>
+   */
+  protected static TestHarness h;
+  /**
+   * LocalRequestFactory initialized by initTestHarness using sensible
+   * defaults.
+   *
+   * <p>
+   * For use in test methods as needed.
+   * </p>
+   */
+  protected static TestHarness.LocalRequestFactory lrf;
+
+
+  /**
+   * Subclasses must define this method to return the name of the
+   * schema.xml they wish to use.
+   */
+  public static  String getSchemaFile() {
+    return schemaString;
+  };
+
+  /**
+   * Subclasses must define this method to return the name of the
+   * solrconfig.xml they wish to use.
+   */
+  public static  String getSolrConfigFile() {
+    return configString;
+  };
+
+  /**
+   * The directory used to story the index managed by the TestHarness h
+   */
+  protected static File dataDir;
+
+  /**
+   * Initializes things your test might need
+   *
+   * <ul>
+   * <li>Creates a dataDir in the "java.io.tmpdir"</li>
+   * <li>initializes the TestHarness h using this data directory, and getSchemaPath()</li>
+   * <li>initializes the LocalRequestFactory lrf using sensible defaults.</li>
+   * </ul>
+   *
+   */
+
+  public static Logger log = LoggerFactory.getLogger(SolrTestCaseJ4.class);
+
+  private static String factoryProp;
+
+  public static void createTempDir() {
+    String cname = getSimpleClassName();
+    dataDir = new File(TEMP_DIR,
+            "solrtest-" + cname + "-" + System.currentTimeMillis());
+    dataDir.mkdirs();
+  }
+
+  public static void initCore() throws Exception {
+    log.info("####initCore");
+
+    ignoreException("ignore_exception");
+    factoryProp = System.getProperty("solr.directoryFactory");
+    if (factoryProp == null) {
+      System.setProperty("solr.directoryFactory","solr.RAMDirectoryFactory");
+    }
+    if (dataDir == null) {
+      createTempDir();
+    }
+
+    // other  methods like starting a jetty instance need these too
+    System.setProperty("solr.test.sys.prop1", "propone");
+    System.setProperty("solr.test.sys.prop2", "proptwo");
+
+    String configFile = getSolrConfigFile();
+    if (configFile != null) {
+
+      solrConfig = h.createConfig(getSolrConfigFile());
+      h = new TestHarness( dataDir.getAbsolutePath(),
+              solrConfig,
+              getSchemaFile());
+      lrf = h.getRequestFactory
+              ("standard",0,20,CommonParams.VERSION,"2.2");
+    }
+    log.info("####initCore end");
+  }
+
+  /** Subclasses that override setUp can optionally call this method
+   * to log the fact that their setUp process has ended.
+   */
+  public void postSetUp() {
+    log.info("####POSTSETUP " + getName());
+  }
+
+
+  /** Subclasses that override tearDown can optionally call this method
+   * to log the fact that the tearDown process has started.  This is necessary
+   * since subclasses will want to call super.tearDown() at the *end* of their
+   * tearDown method.
+   */
+  public void preTearDown() {
+    log.info("####PRETEARDOWN " + getName());
+  }
+
+  /**
+   * Shuts down the test harness, and makes the best attempt possible
+   * to delete dataDir, unless the system property "solr.test.leavedatadir"
+   * is set.
+   */
+  public static void deleteCore() throws Exception {
+    log.info("###deleteCore" );
+    if (h != null) { h.close(); }
+    if (dataDir != null) {
+      String skip = System.getProperty("solr.test.leavedatadir");
+      if (null != skip && 0 != skip.trim().length()) {
+        System.err.println("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
+      } else {
+        if (!recurseDelete(dataDir)) {
+          System.err.println("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
+        }
+      }
+    }
+
+    if (factoryProp == null) {
+      System.clearProperty("solr.directoryFactory");
+    }
+    
+    dataDir = null;
+    solrConfig = null;
+    h = null;
+    lrf = null;
+    configString = schemaString = null;
+
+    endTrackingSearchers();
+  }
+
+
+  /** Validates an update XML String is successful
+   */
+  public static void assertU(String update) {
+    assertU(null, update);
+  }
+
+  /** Validates an update XML String is successful
+   */
+  public static void assertU(String message, String update) {
+    checkUpdateU(message, update, true);
+  }
+
+  /** Validates an update XML String failed
+   */
+  public static void assertFailedU(String update) {
+    assertFailedU(null, update);
+  }
+
+  /** Validates an update XML String failed
+   */
+  public static void assertFailedU(String message, String update) {
+    checkUpdateU(message, update, false);
+  }
+
+  /** Checks the success or failure of an update message
+   */
+  private static void checkUpdateU(String message, String update, boolean shouldSucceed) {
+    try {
+      String m = (null == message) ? "" : message + " ";
+      if (shouldSucceed) {
+           String res = h.validateUpdate(update);
+         if (res != null) fail(m + "update was not successful: " + res);
+      } else {
+           String res = h.validateErrorUpdate(update);
+         if (res != null) fail(m + "update succeeded, but should have failed: " + res);
+      }
+    } catch (SAXException e) {
+      throw new RuntimeException("Invalid XML", e);
+    }
+  }
+
+  /** Validates a query matches some XPath test expressions and closes the query */
+  public static void assertQ(SolrQueryRequest req, String... tests) {
+    assertQ(null, req, tests);
+  }
+
+  /** Validates a query matches some XPath test expressions and closes the query */
+  public static void assertQ(String message, SolrQueryRequest req, String... tests) {
+    try {
+      String m = (null == message) ? "" : message + " ";
+      String response = h.query(req);
+
+      if (req.getParams().getBool("facet", false)) {
+        // add a test to ensure that faceting did not throw an exception
+        // internally, where it would be added to facet_counts/exception
+        String[] allTests = new String[tests.length+1];
+        System.arraycopy(tests,0,allTests,1,tests.length);
+        allTests[0] = "*[count(//lst[@name='facet_counts']/*[@name='exception'])=0]";
+        tests = allTests;
+      }
+
+      String results = h.validateXPath(response, tests);
+
+      if (null != results) {
+        String msg = "REQUEST FAILED: xpath=" + results
+            + "\n\txml response was: " + response
+            + "\n\trequest was:" + req.getParamString();
+
+        log.error(msg);
+        throw new RuntimeException(msg);
+      }
+
+    } catch (XPathExpressionException e1) {
+      throw new RuntimeException("XPath is invalid", e1);
+    } catch (Exception e2) {
+      SolrException.log(log,"REQUEST FAILED: " + req.getParamString(), e2);
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+  /** Validates a query matches some JSON test expressions and closes the query.
+   * The text expression is of the form path:JSON.  To facilitate easy embedding
+   * in Java strings, the JSON can have double quotes replaced with single quotes.
+   *
+   * Please use this with care: this makes it easy to match complete structures, but doing so
+   * can result in fragile tests if you are matching more than what you want to test.
+   *
+   **/
+  public static void assertJQ(SolrQueryRequest req, String... tests) throws Exception {
+    SolrParams params =  null;
+    try {
+      params = req.getParams();
+      if (!"json".equals(params.get("wt","xml")) || params.get("indent")==null) {
+        ModifiableSolrParams newParams = new ModifiableSolrParams(params);
+        newParams.set("wt","json");
+        if (params.get("indent")==null) newParams.set("indent","true");
+        req.setParams(newParams);
+      }
+
+      String response;
+      boolean failed=true;
+      try {
+        response = h.query(req);
+        failed = false;
+      } finally {
+        if (failed) {
+          log.error("REQUEST FAILED: " + req.getParamString());
+        }
+      }
+
+      for (String test : tests) {
+        String testJSON = test.replace('\'', '"');
+
+        try {
+          failed = true;
+          String err = JSONTestUtil.match(response, testJSON);
+          failed = false;
+          if (err != null) {
+            log.error("query failed JSON validation. error=" + err +
+                "\n expected =" + testJSON +
+                "\n response = " + response +
+                "\n request = " + req.getParamString()
+            );
+            throw new RuntimeException(err);
+          }
+        } finally {
+          if (failed) {
+            log.error("JSON query validation threw an exception." + 
+                "\n expected =" + testJSON +
+                "\n response = " + response +
+                "\n request = " + req.getParamString()
+            );
+          }
+        }
+      }
+    } finally {
+      // restore the params
+      if (params != null && params != req.getParams()) req.setParams(params);
+    }
+  }  
+
+
+  /** Makes sure a query throws a SolrException with the listed response code */
+  public static void assertQEx(String message, SolrQueryRequest req, int code ) {
+    try {
+      h.query(req);
+      fail( message );
+    } catch (SolrException sex) {
+      assertEquals( code, sex.code() );
+    } catch (Exception e2) {
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+  public static void assertQEx(String message, SolrQueryRequest req, SolrException.ErrorCode code ) {
+    try {
+      h.query(req);
+      fail( message );
+    } catch (SolrException e) {
+      assertEquals( code.code, e.code() );
+    } catch (Exception e2) {
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+
+  /**
+   * @see TestHarness#optimize
+   */
+  public static String optimize(String... args) {
+    return h.optimize(args);
+  }
+  /**
+   * @see TestHarness#commit
+   */
+  public static String commit(String... args) {
+    return h.commit(args);
+  }
+
+  /**
+   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
+   *
+   * @param fieldsAndValues 0th and Even numbered args are fields names odds are field values.
+   * @see #add
+   * @see #doc
+   */
+  public static String adoc(String... fieldsAndValues) {
+    XmlDoc d = doc(fieldsAndValues);
+    return add(d);
+  }
+
+  /**
+   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
+   */
+  public static String adoc(SolrInputDocument sdoc) {
+    List<String> fields = new ArrayList<String>();
+    for (SolrInputField sf : sdoc) {
+      for (Object o : sf.getValues()) {
+        fields.add(sf.getName());
+        fields.add(o.toString());
+      }
+    }
+    return adoc(fields.toArray(new String[fields.size()]));
+  }
+
+
+  /**
+   * Generates an &lt;add&gt;&lt;doc&gt;... XML String with options
+   * on the add.
+   *
+   * @param doc the Document to add
+   * @param args 0th and Even numbered args are param names, Odds are param values.
+   * @see #add
+   * @see #doc
+   */
+  public static String add(XmlDoc doc, String... args) {
+    try {
+      StringWriter r = new StringWriter();
+
+      // this is anoying
+      if (null == args || 0 == args.length) {
+        r.write("<add>");
+        r.write(doc.xml);
+        r.write("</add>");
+      } else {
+        XML.writeUnescapedXML(r, "add", doc.xml, (Object[])args);
+      }
+
+      return r.getBuffer().toString();
+    } catch (IOException e) {
+      throw new RuntimeException
+        ("this should never happen with a StringWriter", e);
+    }
+  }
+
+  /**
+   * Generates a &lt;delete&gt;... XML string for an ID
+   *
+   * @see TestHarness#deleteById
+   */
+  public static String delI(String id) {
+    return h.deleteById(id);
+  }
+  /**
+   * Generates a &lt;delete&gt;... XML string for an query
+   *
+   * @see TestHarness#deleteByQuery
+   */
+  public static String delQ(String q) {
+    return h.deleteByQuery(q);
+  }
+
+  /**
+   * Generates a simple &lt;doc&gt;... XML String with no options
+   *
+   * @param fieldsAndValues 0th and Even numbered args are fields names, Odds are field values.
+   * @see TestHarness#makeSimpleDoc
+   */
+  public static XmlDoc doc(String... fieldsAndValues) {
+    XmlDoc d = new XmlDoc();
+    d.xml = h.makeSimpleDoc(fieldsAndValues).toString();
+    return d;
+  }
+
+  public static ModifiableSolrParams params(String... params) {
+    ModifiableSolrParams msp = new ModifiableSolrParams();
+    for (int i=0; i<params.length; i+=2) {
+      msp.add(params[i], params[i+1]);
+    }
+    return msp;
+  }
+
+  /**
+   * Generates a SolrQueryRequest using the LocalRequestFactory
+   * @see #lrf
+   */
+  public static SolrQueryRequest req(String... q) {
+    return lrf.makeRequest(q);
+  }
+
+  /**
+   * Generates a SolrQueryRequest using the LocalRequestFactory
+   * @see #lrf
+   */
+  public static SolrQueryRequest req(String[] params, String... moreParams) {
+    String[] allParams = moreParams;
+    if (params.length!=0) {
+      int len = params.length + moreParams.length;
+      allParams = new String[len];
+      System.arraycopy(params,0,allParams,0,params.length);
+      System.arraycopy(moreParams,0,allParams,params.length,moreParams.length);
+    }
+
+    return lrf.makeRequest(allParams);
+  }
+
+  /**
+   * Generates a SolrQueryRequest
+   */
+  public static SolrQueryRequest req(SolrParams params, String... moreParams) {
+    ModifiableSolrParams mp = new ModifiableSolrParams(params);
+    for (int i=0; i<moreParams.length; i+=2) {
+      mp.add(moreParams[i], moreParams[i+1]);
+    }
+    return new LocalSolrQueryRequest(h.getCore(), mp);
+  }
+
+  /** Neccessary to make method signatures un-ambiguous */
+  public static class XmlDoc {
+    public String xml;
+    @Override
+    public String toString() { return xml; }
+  }
+
+  public static boolean recurseDelete(File f) {
+    if (f.isDirectory()) {
+      for (File sub : f.listFiles()) {
+        if (!recurseDelete(sub)) {
+          System.err.println("!!!! WARNING: best effort to remove " + sub.getAbsolutePath() + " FAILED !!!!!");
+          return false;
+        }
+      }
+    }
+    return f.delete();
+  }
+  
+  public void clearIndex() {
+    assertU(delQ("*:*"));
+  }
+
+  /** Send JSON update commands */
+  public static String updateJ(String json, SolrParams args) throws Exception {
+    SolrCore core = h.getCore();
+    DirectSolrConnection connection = new DirectSolrConnection(core);
+    SolrRequestHandler handler = core.getRequestHandler("/udate/json");
+    if (handler == null) {
+      handler = new JsonUpdateRequestHandler();
+      handler.init(null);
+    }
+    return connection.request(handler, args, json);
+  }
+
+
+  /////////////////////////////////////////////////////////////////////////////////////
+  //////////////////////////// random document / index creation ///////////////////////
+  /////////////////////////////////////////////////////////////////////////////////////
+  
+  public abstract static class Vals {
+    public abstract Comparable get();
+    public String toJSON(Comparable val) {
+      return JSONUtil.toJSON(val);
+    }
+
+    protected int between(int min, int max) {
+      return min != max ? random.nextInt(max-min+1) + min : min;
+    }
+  }
+
+  public abstract static class IVals extends Vals {
+    public abstract int getInt();
+  }
+
+  public static class IRange extends IVals {
+    final int min;
+    final int max;
+    public IRange(int min, int max) {
+      this.min = min;
+      this.max = max;
+    }
+
+    @Override
+    public int getInt() {
+      return between(min,max);
+    }
+
+    @Override
+    public Comparable get() {
+      return getInt();
+    }
+  }
+
+  public static class FVal extends Vals {
+    final float min;
+    final float max;
+    public FVal(float min, float max) {
+      this.min = min;
+      this.max = max;
+    }
+
+    public float getFloat() {
+      if (min >= max) return min;
+      return min + random.nextFloat() *  (max - min);
+    }
+
+    @Override
+    public Comparable get() {
+      return getFloat();
+    }
+  }  
+
+  public static class SVal extends Vals {
+    char start;
+    char end;
+    int minLength;
+    int maxLength;
+
+    public SVal() {
+      this('a','z',1,10);
+    }
+
+    public SVal(char start, char end, int minLength, int maxLength) {
+      this.start = start;
+      this.end = end;
+      this.minLength = minLength;
+      this.maxLength = maxLength;
+    }
+
+    @Override
+    public Comparable get() {
+      char[] arr = new char[between(minLength,maxLength)];
+      for (int i=0; i<arr.length; i++) {
+        arr[i] = (char)between(start, end);
+      }
+      return new String(arr);
+    }
+  }
+
+  public static final IRange ZERO_ONE = new IRange(0,1);
+  public static final IRange ONE_ONE = new IRange(1,1);
+
+  public static class Doc implements Comparable{
+    public Comparable id;
+    public List<Fld> fields;
+    public int order; // the order this document was added to the index
+
+
+    @Override
+    public String toString() {
+      return "Doc("+order+"):"+fields.toString();
+    }
+
+    @Override
+    public int hashCode() {
+      return id.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (!(o instanceof Doc)) return false;
+      Doc other = (Doc)o;
+      return this==other || id != null && id.equals(other.id);
+    }
+
+    @Override
+    public int compareTo(Object o) {
+      if (!(o instanceof Doc)) return this.getClass().hashCode() - o.getClass().hashCode();
+      Doc other = (Doc)o;
+      return this.id.compareTo(other.id);
+    }
+
+    public List<Comparable> getValues(String field) {
+      for (Fld fld : fields) {
+        if (fld.ftype.fname.equals(field)) return fld.vals;
+      }
+      return null;
+    }
+
+    public Comparable getFirstValue(String field) {
+      List<Comparable> vals = getValues(field);
+      return vals==null || vals.size()==0 ? null : vals.get(0);
+    }
+
+    public Map<String,Object> toObject(IndexSchema schema) {
+      Map<String,Object> result = new HashMap<String,Object>();
+      for (Fld fld : fields) {
+        SchemaField sf = schema.getField(fld.ftype.fname);
+        if (!sf.multiValued()) {
+          result.put(fld.ftype.fname, fld.vals.get(0));
+        } else {
+          result.put(fld.ftype.fname, fld.vals);
+        }
+      }
+      return result;
+    }
+
+  }
+
+  public static class Fld {
+    public FldType ftype;
+    public List<Comparable> vals;
+    @Override
+    public String toString() {
+      return ftype.fname + "=" + (vals.size()==1 ? vals.get(0).toString() : vals.toString());
+    }
+  }
+
+  class FldType {
+    public String fname;
+    public IRange numValues;
+    public Vals vals;
+
+    public FldType(String fname, Vals vals) {
+      this(fname, ZERO_ONE, vals);
+    }
+
+    public FldType(String fname, IRange numValues, Vals vals) {
+      this.fname = fname;
+      this.numValues = numValues;
+      this.vals = vals;      
+    }
+
+    public Comparable createValue() {
+      return vals.get();
+    }
+
+    public List<Comparable> createValues() {
+      int nVals = numValues.getInt();
+      if (nVals <= 0) return null;
+      List<Comparable> vals = new ArrayList<Comparable>(nVals);
+      for (int i=0; i<nVals; i++)
+        vals.add(createValue());
+      return vals;
+    }
+
+    public Fld createField() {
+      List<Comparable> vals = createValues();
+      if (vals == null) return null;
+
+      Fld fld = new Fld();
+      fld.ftype = this;
+      fld.vals = vals;
+      return fld;          
+    }
+
+  }
+
+
+  public Map<Comparable,Doc> indexDocs(List<FldType> descriptor, Map<Comparable,Doc> model, int nDocs) throws Exception {
+    if (model == null) {
+      model = new LinkedHashMap<Comparable,Doc>();
+    }
+
+    // commit an average of 10 times for large sets, or 10% of the time for small sets
+    int commitOneOutOf = Math.max(nDocs/10, 10);
+
+    for (int i=0; i<nDocs; i++) {
+      Doc doc = createDoc(descriptor);
+      // doc.order = order++;
+      updateJ(toJSON(doc), null);
+      model.put(doc.id, doc);
+
+      // commit 10% of the time
+      if (random.nextInt(commitOneOutOf)==0) {
+        assertU(commit());
+      }
+
+      // duplicate 10% of the docs
+      if (random.nextInt(10)==0) {
+        updateJ(toJSON(doc), null);
+        model.put(doc.id, doc);        
+      }
+    }
+
+    // optimize 10% of the time
+    if (random.nextInt(10)==0) {
+      assertU(optimize());
+    } else {
+      assertU(commit());
+    }
+
+    // merging segments no longer selects just adjacent segments hence ids (doc.order) can be shuffled.
+    // we need to look at the index to determine the order.
+    String responseStr = h.query(req("q","*:*", "fl","id", "sort","_docid_ asc", "rows",Integer.toString(model.size()*2), "wt","json", "indent","true"));
+    Object response = ObjectBuilder.fromJSON(responseStr);
+
+    response = ((Map)response).get("response");
+    response = ((Map)response).get("docs");
+    List<Map> docList = (List<Map>)response;
+    int order = 0;
+    for (Map doc : docList) {
+      Object id = doc.get("id");
+      Doc modelDoc = model.get(id);
+      if (modelDoc == null) continue;  // may be some docs in the index that aren't modeled
+      modelDoc.order = order++;
+    }
+
+    // make sure we updated the order of all docs in the model
+    assertEquals(order, model.size());
+
+    return model;
+  }
+
+  public static Doc createDoc(List<FldType> descriptor) {
+    Doc doc = new Doc();
+    doc.fields = new ArrayList<Fld>();
+    for (FldType ftype : descriptor) {
+      Fld fld = ftype.createField();
+      if (fld != null) {
+        doc.fields.add(fld);
+        if ("id".equals(ftype.fname))
+          doc.id = fld.vals.get(0);
+      }
+    }
+    return doc;
+  }
+
+  public static Comparator<Doc> createSort(IndexSchema schema, List<FldType> fieldTypes, String[] out) {
+    StringBuilder sortSpec = new StringBuilder();
+    int nSorts = random.nextInt(4);
+    List<Comparator<Doc>> comparators = new ArrayList<Comparator<Doc>>();
+    for (int i=0; i<nSorts; i++) {
+      if (i>0) sortSpec.append(',');
+
+      int which = random.nextInt(fieldTypes.size()+2);
+      boolean asc = random.nextBoolean();
+      if (which == fieldTypes.size()) {
+        // sort by score
+        sortSpec.append("score").append(asc ? " asc" : " desc");
+        comparators.add(createComparator("score", asc, false, false, false));
+      } else if (which == fieldTypes.size() + 1) {
+        // sort by docid
+        sortSpec.append("_docid_").append(asc ? " asc" : " desc");
+        comparators.add(createComparator("_docid_", asc, false, false, false));
+      } else {
+        String field = fieldTypes.get(which).fname;
+        sortSpec.append(field).append(asc ? " asc" : " desc");
+        SchemaField sf = schema.getField(field);
+        comparators.add(createComparator(field, asc, sf.sortMissingLast(), sf.sortMissingFirst(), !(sf.sortMissingLast()||sf.sortMissingFirst()) ));
+      }
+    }
+
+    out[0] = sortSpec.length() > 0 ? sortSpec.toString() : null;
+
+    if (comparators.size() == 0) {
+      // default sort is by score desc
+      comparators.add(createComparator("score", false, false, false, false));      
+    }
+
+    return createComparator(comparators);
+  }
+
+  public static Comparator<Doc> createComparator(final String field, final boolean asc, final boolean sortMissingLast, final boolean sortMissingFirst, final boolean sortMissingAsZero) {
+    final int mul = asc ? 1 : -1;
+
+    if (field.equals("_docid_")) {
+     return new Comparator<Doc>() {
+      @Override
+      public int compare(Doc o1, Doc o2) {
+        return (o1.order - o2.order) * mul;
+      }
+     };
+    }
+
+    if (field.equals("score")) {
+      return createComparator("score_f", asc, sortMissingLast, sortMissingFirst, sortMissingAsZero);
+    }
+
+    return new Comparator<Doc>() {
+      private Comparable zeroVal(Comparable template) {
+        if (template == null) return null;
+        if (template instanceof String) return null;  // fast-path for string
+        if (template instanceof Integer) return 0;
+        if (template instanceof Long) return (long)0;
+        if (template instanceof Float) return (float)0;
+        if (template instanceof Double) return (double)0;
+        if (template instanceof Short) return (short)0;
+        if (template instanceof Byte) return (byte)0;
+        if (template instanceof Character) return (char)0;
+        return null;
+      }
+
+      @Override
+      public int compare(Doc o1, Doc o2) {
+        Comparable v1 = o1.getFirstValue(field);
+        Comparable v2 = o2.getFirstValue(field);
+
+        v1 = v1 == null ? zeroVal(v2) : v1;
+        v2 = v2 == null ? zeroVal(v1) : v2;
+
+        int c = 0;
+        if (v1 == v2) {
+          c = 0;
+        } else if (v1 == null) {
+          if (sortMissingLast) c = mul;
+          else if (sortMissingFirst) c = -mul;
+          else c = -1;
+        } else if (v2 == null) {
+          if (sortMissingLast) c = -mul;
+          else if (sortMissingFirst) c = mul;
+          else c = 1;
+        } else {
+          c = v1.compareTo(v2);
+        }
+
+        c = c * mul;
+
+        return c;
+      }
+    };
+  }
+
+  public static Comparator<Doc> createComparator(final List<Comparator<Doc>> comparators) {
+    return new Comparator<Doc>() {
+      @Override
+      public int compare(Doc o1, Doc o2) {
+        int c = 0;
+        for (Comparator<Doc> comparator : comparators) {
+          c = comparator.compare(o1, o2);
+          if (c!=0) return c;
+        }
+        return o1.order - o2.order;
+      }
+    };
+  }
+
+
+  public static String toJSON(Doc doc) {
+    CharArr out = new CharArr();
+    try {
+      out.append("{\"add\":{\"doc\":{");
+      boolean firstField = true;
+      for (Fld fld : doc.fields) {
+        if (firstField) firstField=false;
+        else out.append(',');
+        JSONUtil.writeString(fld.ftype.fname, 0, fld.ftype.fname.length(), out);
+        out.append(':');
+        if (fld.vals.size() > 1) {
+          out.append('[');
+        }
+        boolean firstVal = true;
+        for (Comparable val : fld.vals) {
+          if (firstVal) firstVal=false;
+          else out.append(',');
+          out.append(JSONUtil.toJSON(val));
+        }
+        if (fld.vals.size() > 1) {
+          out.append(']');
+        }
+      }
+      out.append("}}}");
+    } catch (IOException e) {
+      // should never happen
+    }
+    return out.toString();
+  }
+
+  /** Gets a resource from the context classloader as {@link File}. This method should only be used,
+   * if a real file is needed. To get a stream, code should prefer
+   * {@link Class#getResourceAsStream} using {@code this.getClass()}.
+   */
+  public static File getFile(String name) {
+    try {
+      File file = new File(name);
+      if (!file.exists()) {
+        file = new File(Thread.currentThread().getContextClassLoader().getResource(name).toURI());
+      }
+      return file;
+    } catch (Exception e) {
+      /* more friendly than NPE */
+      throw new RuntimeException("Cannot find resource: " + name);
+    }
+  }
+  
+  public static String TEST_HOME() {
+    return getFile("solr/conf").getParent();
+  }
+
+  public static Throwable getRootCause(Throwable t) {
+    Throwable result = t;
+    for (Throwable cause = t; null != cause; cause = cause.getCause()) {
+      result = cause;
+    }
+    return result;
+  }
+}
diff --git a/solr/src/test-framework/org/apache/solr/analysis/BaseTokenTestCase.java b/solr/src/test-framework/org/apache/solr/analysis/BaseTokenTestCase.java
new file mode 100644
index 0000000..ce3338d
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/analysis/BaseTokenTestCase.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.analysis;
+
+import java.util.Collections;
+import java.util.Map;
+
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.util.Version;
+import org.apache.solr.core.Config;
+
+/**
+ * General token testing helper functions
+ */
+public abstract class BaseTokenTestCase extends BaseTokenStreamTestCase
+{
+  /** a map containing the default test version param for easy testing */
+  protected static final Map<String,String> DEFAULT_VERSION_PARAM = 
+    Collections.singletonMap("luceneMatchVersion", System.getProperty("tests.luceneMatchVersion", "LUCENE_CURRENT"));
+
+  /** The default test version for easy testing */
+  public static final Version DEFAULT_VERSION = Config.parseLuceneVersionString(DEFAULT_VERSION_PARAM.get("luceneMatchVersion"));
+}
diff --git a/solr/src/test-framework/org/apache/solr/util/AbstractSolrTestCase.java b/solr/src/test-framework/org/apache/solr/util/AbstractSolrTestCase.java
new file mode 100644
index 0000000..e26cfda
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/util/AbstractSolrTestCase.java
@@ -0,0 +1,429 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.apache.solr.util;
+
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.SolrInputField;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.request.*;
+import org.apache.solr.util.TestHarness;
+
+import org.xml.sax.SAXException;
+import org.slf4j.LoggerFactory;
+import org.slf4j.Logger;
+import javax.xml.xpath.XPathExpressionException;
+
+import java.io.*;
+import java.util.HashSet;
+import java.util.List;
+import java.util.ArrayList;
+
+/**
+ * An Abstract base class that makes writing Solr JUnit tests "easier"
+ *
+ * <p>
+ * Test classes that subclass this need only specify the path to the
+ * schema.xml file (:TODO: the solrconfig.xml as well) and write some
+ * testMethods.  This class takes care of creating/destroying the index,
+ * and provides several assert methods to assist you.
+ * </p>
+ *
+ * @see #setUp
+ * @see #tearDown
+ */
+public abstract class AbstractSolrTestCase extends LuceneTestCase {
+    protected SolrConfig solrConfig;
+  /**
+   * Harness initialized by initTestHarness.
+   *
+   * <p>
+   * For use in test methods as needed.
+   * </p>
+   */
+  protected TestHarness h;
+  /**
+   * LocalRequestFactory initialized by initTestHarness using sensible
+   * defaults.
+   *
+   * <p>
+   * For use in test methods as needed.
+   * </p>
+   */
+  protected TestHarness.LocalRequestFactory lrf;
+    
+  /**
+   * Subclasses must define this method to return the name of the
+   * schema.xml they wish to use.
+   */
+  public abstract String getSchemaFile();
+    
+  /**
+   * Subclasses must define this method to return the name of the
+   * solrconfig.xml they wish to use.
+   */
+  public abstract String getSolrConfigFile();
+
+  /**
+   * Subclasses can override this to change a test's solr home
+   * (default is in test-files)
+   */
+  public String getSolrHome() {
+    return SolrTestCaseJ4.TEST_HOME();
+  }
+  
+  /**
+   * The directory used to story the index managed by the TestHarness h
+   */
+  protected File dataDir;
+    
+  /**
+   * Initializes things your test might need
+   *
+   * <ul>
+   * <li>Creates a dataDir in the "java.io.tmpdir"</li>
+   * <li>initializes the TestHarness h using this data directory, and getSchemaPath()</li>
+   * <li>initializes the LocalRequestFactory lrf using sensible defaults.</li>
+   * </ul>
+   *
+   */
+
+  public static Logger log = LoggerFactory.getLogger(AbstractSolrTestCase.class);
+
+  private String factoryProp;
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    log.info("####SETUP_START " + getName());
+    ignoreException("ignore_exception");
+    factoryProp = System.getProperty("solr.directoryFactory");
+    if (factoryProp == null) {
+      System.setProperty("solr.directoryFactory","solr.RAMDirectoryFactory");
+    }
+    dataDir = new File(TEMP_DIR,
+            getClass().getName() + "-" + System.currentTimeMillis());
+    dataDir.mkdirs();
+    String configFile = getSolrConfigFile();
+    System.setProperty("solr.solr.home", getSolrHome());
+    if (configFile != null) {
+
+      solrConfig = h.createConfig(getSolrConfigFile());
+      h = new TestHarness( dataDir.getAbsolutePath(),
+              solrConfig,
+              getSchemaFile());
+      lrf = h.getRequestFactory
+              ("standard",0,20,CommonParams.VERSION,"2.2");
+    }
+    log.info("####SETUP_END " + getName());
+  }
+
+    /** Causes an exception matching the regex pattern to not be logged. */
+  public static void ignoreException(String pattern) {
+    if (SolrException.ignorePatterns == null)
+      SolrException.ignorePatterns = new HashSet<String>();
+    SolrException.ignorePatterns.add(pattern);
+  }
+
+  public static void resetExceptionIgnores() {
+    SolrException.ignorePatterns = null;
+    ignoreException("ignore_exception");  // always ignore "ignore_exception"
+  }
+
+  /** Subclasses that override setUp can optionally call this method
+   * to log the fact that their setUp process has ended.
+   */
+  public void postSetUp() {
+    log.info("####POSTSETUP " + getName());
+  }
+
+
+  /** Subclasses that override tearDown can optionally call this method
+   * to log the fact that the tearDown process has started.  This is necessary
+   * since subclasses will want to call super.tearDown() at the *end* of their
+   * tearDown method.
+   */
+  public void preTearDown() {
+    log.info("####PRETEARDOWN " + getName());      
+  }
+
+  /**
+   * Shuts down the test harness, and makes the best attempt possible
+   * to delete dataDir, unless the system property "solr.test.leavedatadir"
+   * is set.
+   */
+  @Override
+  public void tearDown() throws Exception {
+    log.info("####TEARDOWN_START " + getName());
+    if (factoryProp == null) {
+      System.clearProperty("solr.directoryFactory");
+    }
+
+    if (h != null) { h.close(); }
+    String skip = System.getProperty("solr.test.leavedatadir");
+    if (null != skip && 0 != skip.trim().length()) {
+      System.err.println("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
+    } else {
+      if (!recurseDelete(dataDir)) {
+        System.err.println("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
+      }
+    }
+
+    resetExceptionIgnores();  
+    super.tearDown();
+  }
+
+  /** Validates an update XML String is successful
+   */
+  public void assertU(String update) {
+    assertU(null, update);
+  }
+
+  /** Validates an update XML String is successful
+   */
+  public void assertU(String message, String update) {
+    checkUpdateU(message, update, true);
+  }
+
+  /** Validates an update XML String failed
+   */
+  public void assertFailedU(String update) {
+    assertFailedU(null, update);
+  }
+
+  /** Validates an update XML String failed
+   */
+  public void assertFailedU(String message, String update) {
+    checkUpdateU(message, update, false);
+  }
+
+  /** Checks the success or failure of an update message
+   */
+  private void checkUpdateU(String message, String update, boolean shouldSucceed) {
+    try {
+      String m = (null == message) ? "" : message + " ";
+      if (shouldSucceed) {
+           String res = h.validateUpdate(update);
+         if (res != null) fail(m + "update was not successful: " + res);
+      } else {
+           String res = h.validateErrorUpdate(update);
+         if (res != null) fail(m + "update succeeded, but should have failed: " + res);        
+      }
+    } catch (SAXException e) {
+      throw new RuntimeException("Invalid XML", e);
+    }
+  }
+
+  /** Validates a query matches some XPath test expressions and closes the query */
+  public void assertQ(SolrQueryRequest req, String... tests) {
+    assertQ(null, req, tests);
+  }
+  
+  /** Validates a query matches some XPath test expressions and closes the query */
+  public void assertQ(String message, SolrQueryRequest req, String... tests) {
+    try {
+      String m = (null == message) ? "" : message + " ";
+      String response = h.query(req);
+      String results = h.validateXPath(response, tests);
+      if (null != results) {
+        fail(m + "query failed XPath: " + results +
+             "\n xml response was: " + response +
+             "\n request was: " + req.getParamString());
+      }
+    } catch (XPathExpressionException e1) {
+      throw new RuntimeException("XPath is invalid", e1);
+    } catch (Exception e2) {
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+  /** Makes sure a query throws a SolrException with the listed response code */
+  public void assertQEx(String message, SolrQueryRequest req, int code ) {
+    try {
+      h.query(req);
+      fail( message );
+    } catch (SolrException sex) {
+      assertEquals( code, sex.code() );
+    } catch (Exception e2) {
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+  public void assertQEx(String message, SolrQueryRequest req, SolrException.ErrorCode code ) {
+    try {
+      h.query(req);
+      fail( message );
+    } catch (SolrException e) {
+      assertEquals( code.code, e.code() );
+    } catch (Exception e2) {
+      throw new RuntimeException("Exception during query", e2);
+    }
+  }
+
+  
+  /**
+   * @see TestHarness#optimize
+   */
+  public String optimize(String... args) {
+    return h.optimize(args);
+  }
+  /**
+   * @see TestHarness#commit
+   */
+  public String commit(String... args) {
+    return h.commit(args);
+  }
+
+  /**
+   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
+   *
+   * @param fieldsAndValues 0th and Even numbered args are fields names odds are field values.
+   * @see #add
+   * @see #doc
+   */
+  public String adoc(String... fieldsAndValues) {
+    Doc d = doc(fieldsAndValues);
+    return add(d);
+  }
+
+  /**
+   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
+   */
+  public String adoc(SolrInputDocument sdoc) {
+    List<String> fields = new ArrayList<String>();
+    for (SolrInputField sf : sdoc) {
+      for (Object o : sf.getValues()) {
+        fields.add(sf.getName());
+        fields.add(o.toString());
+      }
+    }
+    return adoc(fields.toArray(new String[fields.size()]));
+  }
+
+    
+  /**
+   * Generates an &lt;add&gt;&lt;doc&gt;... XML String with options
+   * on the add.
+   *
+   * @param doc the Document to add
+   * @param args 0th and Even numbered args are param names, Odds are param values.
+   * @see #add
+   * @see #doc
+   */
+  public String add(Doc doc, String... args) {
+    try {
+      StringWriter r = new StringWriter();
+            
+      // this is anoying
+      if (null == args || 0 == args.length) {
+        r.write("<add>");
+        r.write(doc.xml);
+        r.write("</add>");
+      } else {
+        XML.writeUnescapedXML(r, "add", doc.xml, (Object[])args);
+      }
+            
+      return r.getBuffer().toString();
+    } catch (IOException e) {
+      throw new RuntimeException
+        ("this should never happen with a StringWriter", e);
+    }
+  }
+
+  /**
+   * Generates a &lt;delete&gt;... XML string for an ID
+   *
+   * @see TestHarness#deleteById
+   */
+  public String delI(String id) {
+    return h.deleteById(id);
+  }
+  /**
+   * Generates a &lt;delete&gt;... XML string for an query
+   *
+   * @see TestHarness#deleteByQuery
+   */
+  public String delQ(String q) {
+    return h.deleteByQuery(q);
+  }
+  
+  /**
+   * Generates a simple &lt;doc&gt;... XML String with no options
+   *
+   * @param fieldsAndValues 0th and Even numbered args are fields names, Odds are field values.
+   * @see TestHarness#makeSimpleDoc
+   */
+  public Doc doc(String... fieldsAndValues) {
+    Doc d = new Doc();
+    d.xml = h.makeSimpleDoc(fieldsAndValues).toString();
+    return d;
+  }
+
+  /**
+   * Generates a SolrQueryRequest using the LocalRequestFactory
+   * @see #lrf
+   */
+  public SolrQueryRequest req(String... q) {
+    return lrf.makeRequest(q);
+  }
+
+  /**
+   * Generates a SolrQueryRequest using the LocalRequestFactory
+   * @see #lrf
+   */
+  public SolrQueryRequest req(String[] params, String... moreParams) {
+    String[] allParams = moreParams;
+    if (params.length!=0) {
+      int len = params.length + moreParams.length;
+      allParams = new String[len];
+      System.arraycopy(params,0,allParams,0,params.length);
+      System.arraycopy(moreParams,0,allParams,params.length,moreParams.length);
+    }
+
+    return lrf.makeRequest(allParams);
+  }
+
+  /** Neccessary to make method signatures un-ambiguous */
+  public static class Doc {
+    public String xml;
+    @Override
+    public String toString() { return xml; }
+  }
+
+  public static boolean recurseDelete(File f) {
+    if (f.isDirectory()) {
+      for (File sub : f.listFiles()) {
+        if (!recurseDelete(sub)) {
+          System.err.println("!!!! WARNING: best effort to remove " + sub.getAbsolutePath() + " FAILED !!!!!");
+          return false;
+        }
+      }
+    }
+    return f.delete();
+  }
+
+  /** @see SolrTestCaseJ4#getFile */
+  public static File getFile(String name) throws IOException {
+    return SolrTestCaseJ4.getFile(name);
+  }
+}
diff --git a/solr/src/test-framework/org/apache/solr/util/TestHarness.java b/solr/src/test-framework/org/apache/solr/util/TestHarness.java
new file mode 100644
index 0000000..4eee02b
--- /dev/null
+++ b/solr/src/test-framework/org/apache/solr/util/TestHarness.java
@@ -0,0 +1,576 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.util;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.core.CoreDescriptor;
+import org.apache.solr.core.SolrResourceLoader;
+import org.apache.solr.handler.JsonUpdateRequestHandler;
+import org.apache.solr.handler.XmlUpdateRequestHandler;
+import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.request.SolrRequestInfo;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.servlet.DirectSolrConnection;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+import org.apache.solr.common.util.NamedList.NamedListEntry;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.util.HashMap;
+import java.util.Map;
+
+
+/**
+ * This class provides a simple harness that may be useful when
+ * writing testcases.
+ *
+ * <p>
+ * This class lives in the tests-framework source tree (and not in the test source
+ * tree), so that it will be included with even the most minimal solr
+ * distribution, in order to encourage plugin writers to create unit 
+ * tests for their plugins.
+ *
+ * @version $Id$
+ */
+public class TestHarness {
+  protected CoreContainer container;
+  private SolrCore core;
+  private XPath xpath = XPathFactory.newInstance().newXPath();
+  private DocumentBuilder builder;
+  public XmlUpdateRequestHandler updater;
+        
+  public static SolrConfig createConfig(String confFile) {
+      // set some system properties for use by tests
+      System.setProperty("solr.test.sys.prop1", "propone");
+      System.setProperty("solr.test.sys.prop2", "proptwo");
+      try {
+      return new SolrConfig(confFile);
+      }
+      catch(Exception xany) {
+        throw new RuntimeException(xany);
+      }
+  }
+        
+  /**
+   * Assumes "solrconfig.xml" is the config file to use, and
+   * "schema.xml" is the schema path to use.
+   *
+   * @param dataDirectory path for index data, will not be cleaned up
+   */
+  public TestHarness( String dataDirectory) {
+    this( dataDirectory, "schema.xml");
+  }
+  
+  /**
+   * Assumes "solrconfig.xml" is the config file to use.
+   *
+   * @param dataDirectory path for index data, will not be cleaned up
+   * @param schemaFile path of schema file
+   */
+  public TestHarness( String dataDirectory, String schemaFile) {
+    this( dataDirectory, "solrconfig.xml", schemaFile);
+  }
+  /**
+   * @param dataDirectory path for index data, will not be cleaned up
+   * @param configFile solrconfig filename
+   * @param schemaFile schema filename
+   */
+   public TestHarness( String dataDirectory, String configFile, String schemaFile) {
+     this( dataDirectory, createConfig(configFile), schemaFile);
+   }
+   /**
+    * @param dataDirectory path for index data, will not be cleaned up
+    * @param solrConfig solronfig instance
+    * @param schemaFile schema filename
+    */
+      public TestHarness( String dataDirectory,
+                          SolrConfig solrConfig,
+                          String schemaFile) {
+     this( dataDirectory, solrConfig, new IndexSchema(solrConfig, schemaFile, null));
+   }
+   /**
+    * @param dataDirectory path for index data, will not be cleaned up
+    * @param solrConfig solrconfig instance
+    * @param indexSchema schema instance
+    */
+  public TestHarness( String dataDirectory,
+                      SolrConfig solrConfig,
+                      IndexSchema indexSchema) {
+      this("", new Initializer("", dataDirectory, solrConfig, indexSchema));
+  }
+  
+  public TestHarness(String coreName, CoreContainer.Initializer init) {
+    try {
+      container = init.initialize();
+      if (coreName == null)
+        coreName = "";
+      // get the core & decrease its refcount:
+      // the container holds the core for the harness lifetime
+      core = container.getCore(coreName);
+      if (core != null)
+        core.close();
+      builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+      
+      updater = new XmlUpdateRequestHandler();
+      updater.init( null );
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+  
+  // Creates a container based on infos needed to create one core
+  static class Initializer extends CoreContainer.Initializer {
+    String coreName;
+    String dataDirectory;
+    SolrConfig solrConfig;
+    IndexSchema indexSchema;
+    public Initializer(String coreName,
+                      String dataDirectory,
+                      SolrConfig solrConfig,
+                      IndexSchema indexSchema) {
+      if (coreName == null)
+        coreName = "";
+      this.coreName = coreName;
+      this.dataDirectory = dataDirectory;
+      this.solrConfig = solrConfig;
+      this.indexSchema = indexSchema;
+    }
+    public String getCoreName() {
+      return coreName;
+    }
+    @Override
+    public CoreContainer initialize() {
+      CoreContainer container = new CoreContainer(new SolrResourceLoader(SolrResourceLoader.locateSolrHome())) {
+        {
+          hostPort = System.getProperty("hostPort");
+          hostContext = "solr";
+          defaultCoreName = "collection1";
+          initZooKeeper(System.getProperty("zkHost"), 10000);
+        }
+      };
+      
+      CoreDescriptor dcore = new CoreDescriptor(container, coreName, solrConfig.getResourceLoader().getInstanceDir());
+      dcore.setConfigName(solrConfig.getResourceName());
+      dcore.setSchemaName(indexSchema.getResourceName());
+      SolrCore core = new SolrCore("collection1", dataDirectory, solrConfig, indexSchema, dcore);
+      container.register(coreName, core, false);
+
+      return container;
+    }
+  }
+  
+  public CoreContainer getCoreContainer() {
+    return container;
+  }
+
+  public SolrCore getCore() {
+    return core;
+  }
+        
+  /**
+   * Processes an "update" (add, commit or optimize) and
+   * returns the response as a String.
+   *
+   * @param xml The XML of the update
+   * @return The XML response to the update
+   */
+  public String update(String xml) {
+    DirectSolrConnection connection = new DirectSolrConnection(core);
+    SolrRequestHandler handler = core.getRequestHandler("/update");
+    // prefer the handler mapped to /update, but use our generic backup handler
+    // if that lookup fails
+    if (handler == null) {
+      handler = updater;
+    }
+    try {
+      return connection.request(handler, null, xml);
+    } catch (SolrException e) {
+      throw (SolrException)e;
+    } catch (Exception e) {
+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
+    }
+  }
+  
+        
+  /**
+   * Validates that an "update" (add, commit or optimize) results in success.
+   *
+   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
+   * 
+   * @param xml The XML of the update
+   * @return null if successful, otherwise the XML response to the update
+   */
+  public String validateUpdate(String xml) throws SAXException {
+    return checkUpdateStatus(xml, "0");
+  }
+
+  /**
+   * Validates that an "update" (add, commit or optimize) results in success.
+   *
+   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
+   * 
+   * @param xml The XML of the update
+   * @return null if successful, otherwise the XML response to the update
+   */
+  public String validateErrorUpdate(String xml) throws SAXException {
+    try {
+      return checkUpdateStatus(xml, "1");
+    } catch (SolrException e) {
+      // return ((SolrException)e).getMessage();
+      return null;  // success
+    }
+  }
+
+  /**
+   * Validates that an "update" (add, commit or optimize) results in success.
+   *
+   * :TODO: currently only deals with one add/doc at a time, this will need changed if/when SOLR-2 is resolved
+   * 
+   * @param xml The XML of the update
+   * @return null if successful, otherwise the XML response to the update
+   */
+  public String checkUpdateStatus(String xml, String code) throws SAXException {
+    try {
+      String res = update(xml);
+      String valid = validateXPath(res, "//int[@name='status']="+code );
+      return (null == valid) ? null : res;
+    } catch (XPathExpressionException e) {
+      throw new RuntimeException
+        ("?!? static xpath has bug?", e);
+    }
+  }
+
+    
+  /**
+   * Validates a "query" response against an array of XPath test strings
+   *
+   * @param req the Query to process
+   * @return null if all good, otherwise the first test that fails.
+   * @exception Exception any exception in the response.
+   * @exception IOException if there is a problem writing the XML
+   * @see LocalSolrQueryRequest
+   */
+  public String validateQuery(SolrQueryRequest req, String... tests)
+    throws IOException, Exception {
+                
+    String res = query(req);
+    return validateXPath(res, tests);
+  }
+            
+  /**
+   * Processes a "query" using a user constructed SolrQueryRequest
+   *
+   * @param req the Query to process, will be closed.
+   * @return The XML response to the query
+   * @exception Exception any exception in the response.
+   * @exception IOException if there is a problem writing the XML
+   * @see LocalSolrQueryRequest
+   */
+  public String query(SolrQueryRequest req) throws IOException, Exception {
+    return query(req.getParams().get(CommonParams.QT), req);
+  }
+
+  /**
+   * Processes a "query" using a user constructed SolrQueryRequest, and closes the request at the end.
+   *
+   * @param handler the name of the request handler to process the request
+   * @param req the Query to process, will be closed.
+   * @return The XML response to the query
+   * @exception Exception any exception in the response.
+   * @exception IOException if there is a problem writing the XML
+   * @see LocalSolrQueryRequest
+   */
+  public String query(String handler, SolrQueryRequest req) throws IOException, Exception {
+    try {
+      SolrQueryResponse rsp = new SolrQueryResponse();
+      SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));
+      core.execute(core.getRequestHandler(handler),req,rsp);
+      if (rsp.getException() != null) {
+        throw rsp.getException();
+      }
+      StringWriter sw = new StringWriter(32000);
+      QueryResponseWriter responseWriter = core.getQueryResponseWriter(req);
+      responseWriter.write(sw,req,rsp);
+
+      req.close();
+
+      return sw.toString();
+    } finally {
+      req.close();
+      SolrRequestInfo.clearRequestInfo();
+    }
+  }
+
+  /** It is the users responsibility to close the request object when done with it.
+   * This method does not set/clear SolrRequestInfo */
+  public SolrQueryResponse queryAndResponse(String handler, SolrQueryRequest req) throws Exception {
+    SolrQueryResponse rsp = new SolrQueryResponse();
+    core.execute(core.getRequestHandler(handler),req,rsp);
+    if (rsp.getException() != null) {
+      throw rsp.getException();
+    }
+    return rsp;
+  }
+
+
+  /**
+   * A helper method which valides a String against an array of XPath test
+   * strings.
+   *
+   * @param xml The xml String to validate
+   * @param tests Array of XPath strings to test (in boolean mode) on the xml
+   * @return null if all good, otherwise the first test that fails.
+   */
+  public String validateXPath(String xml, String... tests)
+    throws XPathExpressionException, SAXException {
+        
+    if (tests==null || tests.length == 0) return null;
+                
+    Document document=null;
+    try {
+      document = builder.parse(new ByteArrayInputStream
+                               (xml.getBytes("UTF-8")));
+    } catch (UnsupportedEncodingException e1) {
+      throw new RuntimeException("Totally weird UTF-8 exception", e1);
+    } catch (IOException e2) {
+      throw new RuntimeException("Totally weird io exception", e2);
+    }
+                
+    for (String xp : tests) {
+      xp=xp.trim();
+      Boolean bool = (Boolean) xpath.evaluate(xp, document,
+                                              XPathConstants.BOOLEAN);
+
+      if (!bool) {
+        return xp;
+      }
+    }
+    return null;
+                
+  }
+
+  /**
+   * Shuts down and frees any resources
+   */
+  public void close() {
+    if (container != null) {
+      for (SolrCore c : container.getCores()) {
+        if (c.getOpenCount() > 1)
+          throw new RuntimeException("SolrCore.getOpenCount()=="+core.getOpenCount());
+      }      
+    }
+
+    if (container != null) {
+      container.shutdown();
+      container = null;
+    }
+  }
+
+  /**
+   * A helper that creates an xml &lt;doc&gt; containing all of the
+   * fields and values specified
+   *
+   * @param fieldsAndValues 0 and Even numbered args are fields names odds are field values.
+   */
+  public static StringBuffer makeSimpleDoc(String... fieldsAndValues) {
+
+    try {
+      StringWriter w = new StringWriter();
+      w.append("<doc>");
+      for (int i = 0; i < fieldsAndValues.length; i+=2) {
+        XML.writeXML(w, "field", fieldsAndValues[i+1], "name",
+                     fieldsAndValues[i]);
+      }
+      w.append("</doc>");
+      return w.getBuffer();
+    } catch (IOException e) {
+      throw new RuntimeException
+        ("this should never happen with a StringWriter", e);
+    }
+  }
+
+  /**
+   * Generates a delete by query xml string
+   * @param q Query that has not already been xml escaped
+   */
+  public static String deleteByQuery(String q) {
+    return delete("query", q);
+  }
+  /**
+   * Generates a delete by id xml string
+   * @param id ID that has not already been xml escaped
+   */
+  public static String deleteById(String id) {
+    return delete("id", id);
+  }
+        
+  /**
+   * Generates a delete xml string
+   * @param val text that has not already been xml escaped
+   */
+  private static String delete(String deltype, String val) {
+    try {
+      StringWriter r = new StringWriter();
+            
+      r.write("<delete>");
+      XML.writeXML(r, deltype, val);
+      r.write("</delete>");
+            
+      return r.getBuffer().toString();
+    } catch (IOException e) {
+      throw new RuntimeException
+        ("this should never happen with a StringWriter", e);
+    }
+  }
+    
+  /**
+   * Helper that returns an &lt;optimize&gt; String with
+   * optional key/val pairs.
+   *
+   * @param args 0 and Even numbered args are params, Odd numbered args are values.
+   */
+  public static String optimize(String... args) {
+    return simpleTag("optimize", args);
+  }
+
+  private static String simpleTag(String tag, String... args) {
+    try {
+      StringWriter r = new StringWriter();
+
+      // this is annoying
+      if (null == args || 0 == args.length) {
+        XML.writeXML(r, tag, null);
+      } else {
+        XML.writeXML(r, tag, null, (Object[])args);
+      }
+      return r.getBuffer().toString();
+    } catch (IOException e) {
+      throw new RuntimeException
+        ("this should never happen with a StringWriter", e);
+    }
+  }
+    
+  /**
+   * Helper that returns an &lt;commit&gt; String with
+   * optional key/val pairs.
+   *
+   * @param args 0 and Even numbered args are params, Odd numbered args are values.
+   */
+  public static String commit(String... args) {
+    return simpleTag("commit", args);
+  }
+    
+  public LocalRequestFactory getRequestFactory(String qtype,
+                                               int start,
+                                               int limit) {
+    LocalRequestFactory f = new LocalRequestFactory();
+    f.qtype = qtype;
+    f.start = start;
+    f.limit = limit;
+    return f;
+  }
+    
+  /**
+   * 0 and Even numbered args are keys, Odd numbered args are values.
+   */
+  public LocalRequestFactory getRequestFactory(String qtype,
+                                               int start, int limit,
+                                               String... args) {
+    LocalRequestFactory f = getRequestFactory(qtype, start, limit);
+    for (int i = 0; i < args.length; i+=2) {
+      f.args.put(args[i], args[i+1]);
+    }
+    return f;
+        
+  }
+    
+  public LocalRequestFactory getRequestFactory(String qtype,
+                                               int start, int limit,
+                                               Map<String,String> args) {
+
+    LocalRequestFactory f = getRequestFactory(qtype, start, limit);
+    f.args.putAll(args);
+    return f;
+  }
+    
+  /**
+   * A Factory that generates LocalSolrQueryRequest objects using a
+   * specified set of default options.
+   */
+  public class LocalRequestFactory {
+    public String qtype = "standard";
+    public int start = 0;
+    public int limit = 1000;
+    public Map<String,String> args = new HashMap<String,String>();
+    public LocalRequestFactory() {
+    }
+    /**
+     * Creates a LocalSolrQueryRequest based on variable args; for
+     * historical reasons, this method has some peculiar behavior:
+     * <ul>
+     *   <li>If there is a single arg, then it is treated as the "q"
+     *       param, and the LocalSolrQueryRequest consists of that query
+     *       string along with "qt", "start", and "rows" params (based
+     *       on the qtype, start, and limit properties of this factory)
+     *       along with any other default "args" set on this factory.
+     *   </li>
+     *   <li>If there are multiple args, then there must be an even number
+     *       of them, and each pair of args is used as a key=value param in
+     *       the LocalSolrQueryRequest.  <b>NOTE: In this usage, the "qtype",
+     *       "start", "limit", and "args" properties of this factory are
+     *       ignored.</b>
+     *   </li>
+     * </ul>
+     */
+    public LocalSolrQueryRequest makeRequest(String ... q) {
+      if (q.length==1) {
+        return new LocalSolrQueryRequest(TestHarness.this.getCore(),
+                                       q[0], qtype, start, limit, args);
+      }
+      if (q.length%2 != 0) { 
+        throw new RuntimeException("The length of the string array (query arguments) needs to be even");
+      }
+      Map.Entry<String, String> [] entries = new NamedListEntry[q.length / 2];
+      for (int i = 0; i < q.length; i += 2) {
+        entries[i/2] = new NamedListEntry<String>(q[i], q[i+1]);
+      }
+      return new LocalSolrQueryRequest(TestHarness.this.getCore(), new NamedList(entries));
+    }
+  }
+}
diff --git a/solr/src/test/org/apache/solr/BaseDistributedSearchTestCase.java b/solr/src/test/org/apache/solr/BaseDistributedSearchTestCase.java
deleted file mode 100644
index c32ccc5..0000000
--- a/solr/src/test/org/apache/solr/BaseDistributedSearchTestCase.java
+++ /dev/null
@@ -1,638 +0,0 @@
-package org.apache.solr;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-
-import junit.framework.TestCase;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.embedded.JettySolrRunner;
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.schema.TrieDateField;
-import org.apache.solr.util.AbstractSolrTestCase;
-import org.junit.Test;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Helper base class for distributed search test cases
- *
- * @since solr 1.5
- */
-public abstract class BaseDistributedSearchTestCase extends SolrTestCaseJ4 {
-  public static Random r = random;
-
-  protected int shardCount = 4;
-  /**
-   * Sub classes can set this flag in their constructor to true if they
-   * want to fix the number of shards to 'shardCount'
-   *
-   * The default is false which means that test will be executed with
-   * 1, 2, 3, ....shardCount number of shards repeatedly
-   */
-  protected boolean fixShardCount = false;
-
-  protected JettySolrRunner controlJetty;
-  protected List<SolrServer> clients = new ArrayList<SolrServer>();
-  protected List<JettySolrRunner> jettys = new ArrayList<JettySolrRunner>();
-  protected String context = "/solr";
-  protected String shards;
-  protected String[] shardsArr;
-  // Some ISPs redirect to their own web site for domains that don't exist, causing this to fail
-  // protected String[] deadServers = {"does_not_exist_54321.com:33331/solr","localhost:33332/solr"};
-  protected String[] deadServers = {"[::1]:33332/solr"};
-  protected File testDir;
-  protected SolrServer controlClient;
-
-  // to stress with higher thread counts and requests, make sure the junit
-  // xml formatter is not being used (all output will be buffered before
-  // transformation to xml and cause an OOM exception).
-  protected int stress = 2;
-  protected boolean verifyStress = true;
-  protected int nThreads = 3;
-
-
-  public static int ORDERED = 1;
-  public static int SKIP = 2;
-  public static int SKIPVAL = 4;
-  public static int UNORDERED = 8;
-
-  protected int flags;
-  protected Map<String, Integer> handle = new HashMap<String, Integer>();
-
-  protected String id = "id";
-  public static Logger log = LoggerFactory.getLogger(BaseDistributedSearchTestCase.class);
-  
-  public static RandVal rint = new RandVal() {
-    @Override
-    public Object val() {
-      return r.nextInt();
-    }
-  };
-
-  public static RandVal rlong = new RandVal() {
-    @Override
-    public Object val() {
-      return r.nextLong();
-    }
-  };
-
-  public static RandVal rfloat = new RandVal() {
-    @Override
-    public Object val() {
-      return r.nextFloat();
-    }
-  };
-
-  public static RandVal rdouble = new RandVal() {
-    @Override
-    public Object val() {
-      return r.nextDouble();
-    }
-  };
-
-  public static RandVal rdate = new RandDate();
-
-  /**
-   * Perform the actual tests here
-   *
-   * @throws Exception on error
-   */
-  public abstract void doTest() throws Exception;
-
-  public static String[] fieldNames = new String[]{"n_ti1", "n_f1", "n_tf1", "n_d1", "n_td1", "n_l1", "n_tl1", "n_dt1", "n_tdt1"};
-  public static RandVal[] randVals = new RandVal[]{rint, rfloat, rfloat, rdouble, rdouble, rlong, rlong, rdate, rdate};
-
-  protected String[] getFieldNames() {
-    return fieldNames;
-  }
-
-  protected RandVal[] getRandValues() {
-    return randVals;
-  }
-
-  /**
-   * Subclasses can override this to change a test's solr home
-   * (default is in test-files)
-   */
-  public String getSolrHome() {
-    return SolrTestCaseJ4.TEST_HOME;
-  }
-  
-  @Override
-  public void setUp() throws Exception {
-    SolrTestCaseJ4.resetExceptionIgnores();  // ignore anything with ignore_exception in it
-    super.setUp();
-    System.setProperty("solr.test.sys.prop1", "propone");
-    System.setProperty("solr.test.sys.prop2", "proptwo");
-    System.setProperty("solr.solr.home", getSolrHome());
-    testDir = new File(TEMP_DIR,
-            getClass().getName() + "-" + System.currentTimeMillis());
-    testDir.mkdirs();
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    destroyServers();
-    if (!AbstractSolrTestCase.recurseDelete(testDir)) {
-      System.err.println("!!!! WARNING: best effort to remove " + testDir.getAbsolutePath() + " FAILED !!!!!");
-    }
-    super.tearDown();
-  }
-
-  protected void createServers(int numShards) throws Exception {
-    controlJetty = createJetty(testDir, testDir + "/control/data");
-    controlClient = createNewSolrServer(controlJetty.getLocalPort());
-
-    shardsArr = new String[numShards];
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < numShards; i++) {
-      if (sb.length() > 0) sb.append(',');
-      JettySolrRunner j = createJetty(testDir, testDir + "/shard" + i + "/data");
-      jettys.add(j);
-      clients.add(createNewSolrServer(j.getLocalPort()));
-      String shardStr = "localhost:" + j.getLocalPort() + context;
-      shardsArr[i] = shardStr;
-      sb.append(shardStr);
-    }
-
-    shards = sb.toString();
-  }
-
-
-  protected void setDistributedParams(ModifiableSolrParams params) {
-    params.set("shards", getShardsString());
-  }
-
-  protected String getShardsString() {
-    if (deadServers == null) return shards;
-    
-    StringBuilder sb = new StringBuilder();
-    for (String shard : shardsArr) {
-      if (sb.length() > 0) sb.append(',');
-      int nDeadServers = r.nextInt(deadServers.length+1);
-      if (nDeadServers > 0) {
-        List<String> replicas = new ArrayList<String>(Arrays.asList(deadServers));
-        Collections.shuffle(replicas, r);
-        replicas.add(r.nextInt(nDeadServers+1), shard);
-        for (int i=0; i<nDeadServers+1; i++) {
-          if (i!=0) sb.append('|');
-          sb.append(replicas.get(i));
-        }
-      } else {
-        sb.append(shard);
-      }
-    }
-
-    return sb.toString();
-  }
-
-  protected void destroyServers() throws Exception {
-    controlJetty.stop();
-    for (JettySolrRunner jetty : jettys) jetty.stop();
-    clients.clear();
-    jettys.clear();
-  }
-  
-  public JettySolrRunner createJetty(File baseDir, String dataDir) throws Exception {
-    return createJetty(baseDir, dataDir, null, null);
-  }
-
-  public JettySolrRunner createJetty(File baseDir, String dataDir, String shardId) throws Exception {
-    return createJetty(baseDir, dataDir, shardId, null);
-  }
-  
-  public JettySolrRunner createJetty(File baseDir, String dataDir, String shardList, String solrConfigOverride) throws Exception {
-    System.setProperty("solr.data.dir", dataDir);
-    JettySolrRunner jetty = new JettySolrRunner("/solr", 0, solrConfigOverride);
-    if(shardList != null) {
-      System.setProperty("shard", shardList);
-    }
-    jetty.start();
-    System.clearProperty("shard");
-    return jetty;
-  }
-  
-  protected SolrServer createNewSolrServer(int port) {
-    try {
-      // setup the server...
-      String url = "http://localhost:" + port + context;
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer(url);
-      s.setConnectionTimeout(100); // 1/10th sec
-      s.setDefaultMaxConnectionsPerHost(100);
-      s.setMaxTotalConnections(100);
-      return s;
-    }
-    catch (Exception ex) {
-      throw new RuntimeException(ex);
-    }
-  }
-
-  protected void addFields(SolrInputDocument doc, Object... fields) {
-    for (int i = 0; i < fields.length; i += 2) {
-      doc.addField((String) (fields[i]), fields[i + 1]);
-    }
-  }// add random fields to the documet before indexing
-
-  protected void indexr(Object... fields) throws Exception {
-    SolrInputDocument doc = new SolrInputDocument();
-    addFields(doc, fields);
-    addFields(doc, "rnd_b", true);
-    addFields(doc, getRandFields(getFieldNames(), getRandValues()));
-    indexDoc(doc);
-  }
-
-  protected void index(Object... fields) throws Exception {
-    SolrInputDocument doc = new SolrInputDocument();
-    addFields(doc, fields);
-    indexDoc(doc);
-  }
-
-  protected void indexDoc(SolrInputDocument doc) throws IOException, SolrServerException {
-    controlClient.add(doc);
-
-    int which = (doc.getField(id).toString().hashCode() & 0x7fffffff) % clients.size();
-    SolrServer client = clients.get(which);
-    client.add(doc);
-  }
-
-  protected void index_specific(int serverNumber, Object... fields) throws Exception {
-    SolrInputDocument doc = new SolrInputDocument();
-    for (int i = 0; i < fields.length; i += 2) {
-      doc.addField((String) (fields[i]), fields[i + 1]);
-    }
-    controlClient.add(doc);
-
-    SolrServer client = clients.get(serverNumber);
-    client.add(doc);
-  }
-
-  protected void del(String q) throws Exception {
-    controlClient.deleteByQuery(q);
-    for (SolrServer client : clients) {
-      client.deleteByQuery(q);
-    }
-  }// serial commit...
-
-  protected void commit() throws Exception {
-    controlClient.commit();
-    for (SolrServer client : clients) client.commit();
-  }
-
-  protected QueryResponse queryServer(ModifiableSolrParams params) throws SolrServerException {
-    // query a random server
-    int which = r.nextInt(clients.size());
-    SolrServer client = clients.get(which);
-    QueryResponse rsp = client.query(params);
-    return rsp;
-  }
-
-  protected void query(Object... q) throws Exception {
-    final ModifiableSolrParams params = new ModifiableSolrParams();
-
-    for (int i = 0; i < q.length; i += 2) {
-      params.add(q[i].toString(), q[i + 1].toString());
-    }
-
-    final QueryResponse controlRsp = controlClient.query(params);
-
-    setDistributedParams(params);
-
-    QueryResponse rsp = queryServer(params);
-
-    compareResponses(rsp, controlRsp);
-
-    if (stress > 0) {
-      log.info("starting stress...");
-      Thread[] threads = new Thread[nThreads];
-      for (int i = 0; i < threads.length; i++) {
-        threads[i] = new Thread() {
-          @Override
-          public void run() {
-            for (int j = 0; j < stress; j++) {
-              int which = r.nextInt(clients.size());
-              SolrServer client = clients.get(which);
-              try {
-                QueryResponse rsp = client.query(new ModifiableSolrParams(params));
-                if (verifyStress) {
-                  compareResponses(rsp, controlRsp);
-                }
-              } catch (SolrServerException e) {
-                throw new RuntimeException(e);
-              }
-            }
-          }
-        };
-        threads[i].start();
-      }
-
-      for (Thread thread : threads) {
-        thread.join();
-      }
-    }
-  }
-
-  public static boolean eq(String a, String b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
-  public static int flags(Map<String, Integer> handle, Object key) {
-    if (handle == null) return 0;
-    Integer f = handle.get(key);
-    return f == null ? 0 : f;
-  }
-
-  public static String compare(NamedList a, NamedList b, int flags, Map<String, Integer> handle) {
-    boolean ordered = (flags & UNORDERED) == 0;
-
-    int posa = 0, posb = 0;
-    int aSkipped = 0, bSkipped = 0;
-
-    for (; ;) {
-      if (posa >= a.size() || posb >= b.size()) {
-        break;
-      }
-
-      String namea, nameb;
-      Object vala, valb = null;
-
-      int flagsa, flagsb;
-      for (; ;) {
-        namea = a.getName(posa);
-        vala = a.getVal(posa);
-        posa++;
-        flagsa = flags(handle, namea);
-        if ((flagsa & SKIP) != 0) {
-          aSkipped++;
-          continue;
-        }
-        break;
-      }
-
-      if (!ordered) posb = 0;  // reset if not ordered
-
-      while (posb < b.size()) {
-        nameb = b.getName(posb);
-        valb = b.getVal(posb);
-        posb++;
-        flagsb = flags(handle, nameb);
-        if ((flagsb & SKIP) != 0) {
-          bSkipped++;
-          continue;
-        }
-        if (eq(namea, nameb)) {
-          break;
-        }
-        if (ordered) {
-          return "." + namea + "!=" + nameb + " (unordered or missing)";
-        }
-        // if unordered, continue until we find the right field.
-      }
-
-      // ok, namea and nameb should be equal here already.
-      if ((flagsa & SKIPVAL) != 0) continue;  // keys matching is enough
-
-      String cmp = compare(vala, valb, flagsa, handle);
-      if (cmp != null) return "." + namea + cmp;
-    }
-
-
-    if (a.size() - aSkipped != b.size() - bSkipped) {
-      return ".size()==" + a.size() + "," + b.size() + "skipped=" + aSkipped + "," + bSkipped;
-    }
-
-    return null;
-  }
-
-  public static String compare1(Map a, Map b, int flags, Map<String, Integer> handle) {
-    String cmp;
-
-    for (Object keya : a.keySet()) {
-      Object vala = a.get(keya);
-      int flagsa = flags(handle, keya);
-      if ((flagsa & SKIP) != 0) continue;
-      if (!b.containsKey(keya)) {
-        return "[" + keya + "]==null";
-      }
-      if ((flagsa & SKIPVAL) != 0) continue;
-      Object valb = b.get(keya);
-      cmp = compare(vala, valb, flagsa, handle);
-      if (cmp != null) return "[" + keya + "]" + cmp;
-    }
-    return null;
-  }
-
-  public static String compare(Map a, Map b, int flags, Map<String, Integer> handle) {
-    String cmp;
-    cmp = compare1(a, b, flags, handle);
-    if (cmp != null) return cmp;
-    return compare1(b, a, flags, handle);
-  }
-
-  public static String compare(SolrDocument a, SolrDocument b, int flags, Map<String, Integer> handle) {
-    return compare(a.getFieldValuesMap(), b.getFieldValuesMap(), flags, handle);
-  }
-
-  public static String compare(SolrDocumentList a, SolrDocumentList b, int flags, Map<String, Integer> handle) {
-    boolean ordered = (flags & UNORDERED) == 0;
-
-    String cmp;
-    int f = flags(handle, "maxScore");
-    if ((f & SKIPVAL) == 0) {
-      cmp = compare(a.getMaxScore(), b.getMaxScore(), 0, handle);
-      if (cmp != null) return ".maxScore" + cmp;
-    } else {
-      if (b.getMaxScore() != null) {
-        if (a.getMaxScore() == null) {
-          return ".maxScore missing";
-        }
-      }
-    }
-
-    cmp = compare(a.getNumFound(), b.getNumFound(), 0, handle);
-    if (cmp != null) return ".numFound" + cmp;
-
-    cmp = compare(a.getStart(), b.getStart(), 0, handle);
-    if (cmp != null) return ".start" + cmp;
-
-    cmp = compare(a.size(), b.size(), 0, handle);
-    if (cmp != null) return ".size()" + cmp;
-
-    // only for completely ordered results (ties might be in a different order)
-    if (ordered) {
-      for (int i = 0; i < a.size(); i++) {
-        cmp = compare(a.get(i), b.get(i), 0, handle);
-        if (cmp != null) return "[" + i + "]" + cmp;
-      }
-      return null;
-    }
-
-    // unordered case
-    for (int i = 0; i < a.size(); i++) {
-      SolrDocument doc = a.get(i);
-      Object key = doc.getFirstValue("id");
-      SolrDocument docb = null;
-      if (key == null) {
-        // no id field to correlate... must compare ordered
-        docb = b.get(i);
-      } else {
-        for (int j = 0; j < b.size(); j++) {
-          docb = b.get(j);
-          if (key.equals(docb.getFirstValue("id"))) break;
-        }
-      }
-      // if (docb == null) return "[id="+key+"]";
-      cmp = compare(doc, docb, 0, handle);
-      if (cmp != null) return "[id=" + key + "]" + cmp;
-    }
-    return null;
-  }
-
-  public static String compare(Object[] a, Object[] b, int flags, Map<String, Integer> handle) {
-    if (a.length != b.length) {
-      return ".length:" + a.length + "!=" + b.length;
-    }
-    for (int i = 0; i < a.length; i++) {
-      String cmp = compare(a[i], b[i], flags, handle);
-      if (cmp != null) return "[" + i + "]" + cmp;
-    }
-    return null;
-  }
-
-  public static String compare(Object a, Object b, int flags, Map<String, Integer> handle) {
-    if (a == b) return null;
-    if (a == null || b == null) return ":" + a + "!=" + b;
-
-    if (a instanceof NamedList && b instanceof NamedList) {
-      return compare((NamedList) a, (NamedList) b, flags, handle);
-    }
-
-    if (a instanceof SolrDocumentList && b instanceof SolrDocumentList) {
-      return compare((SolrDocumentList) a, (SolrDocumentList) b, flags, handle);
-    }
-
-    if (a instanceof SolrDocument && b instanceof SolrDocument) {
-      return compare((SolrDocument) a, (SolrDocument) b, flags, handle);
-    }
-
-    if (a instanceof Map && b instanceof Map) {
-      return compare((Map) a, (Map) b, flags, handle);
-    }
-
-    if (a instanceof Object[] && b instanceof Object[]) {
-      return compare((Object[]) a, (Object[]) b, flags, handle);
-    }
-
-    if (a instanceof byte[] && b instanceof byte[]) {
-      if (!Arrays.equals((byte[]) a, (byte[]) b)) {
-        return ":" + a + "!=" + b;
-      }
-      return null;
-    }
-
-    if (a instanceof List && b instanceof List) {
-      return compare(((List) a).toArray(), ((List) b).toArray(), flags, handle);
-
-    }
-
-    if (!(a.equals(b))) {
-      return ":" + a + "!=" + b;
-    }
-
-    return null;
-  }
-
-  protected void compareResponses(QueryResponse a, QueryResponse b) {
-    String cmp;
-    cmp = compare(a.getResponse(), b.getResponse(), flags, handle);
-    if (cmp != null) {
-      log.info("Mismatched responses:\n" + a + "\n" + b);
-      TestCase.fail(cmp);
-    }
-  }
-
-  @Test
-  public void testDistribSearch() throws Exception {
-    if (fixShardCount) {
-      createServers(shardCount);
-      RandVal.uniqueValues = new HashSet(); //reset random values
-      doTest();
-      destroyServers();
-    } else {
-      for (int nServers = 1; nServers < shardCount; nServers++) {
-        createServers(nServers);
-        RandVal.uniqueValues = new HashSet(); //reset random values
-        doTest();
-        destroyServers();
-      }
-    }
-  }
-
-  public static Object[] getRandFields(String[] fields, RandVal[] randVals) {
-    Object[] o = new Object[fields.length * 2];
-    for (int i = 0; i < fields.length; i++) {
-      o[i * 2] = fields[i];
-      o[i * 2 + 1] = randVals[i].uval();
-    }
-    return o;
-  }
-
-  public static abstract class RandVal {
-    public static Random r = random;
-    public static Set uniqueValues = new HashSet();
-
-    public abstract Object val();
-
-    public Object uval() {
-      for (; ;) {
-        Object v = val();
-        if (uniqueValues.add(v)) return v;
-      }
-    }
-  }
-
-  public static class RandDate extends RandVal {
-    public static TrieDateField df = new TrieDateField();
-
-    @Override
-    public Object val() {
-      long v = r.nextLong();
-      Date d = new Date(v);
-      return df.toExternal(d);
-    }
-  }
-}
diff --git a/solr/src/test/org/apache/solr/JSONTestUtil.java b/solr/src/test/org/apache/solr/JSONTestUtil.java
deleted file mode 100644
index 8bd5a79..0000000
--- a/solr/src/test/org/apache/solr/JSONTestUtil.java
+++ /dev/null
@@ -1,346 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr;
-
-import org.apache.noggit.ObjectBuilder;
-import org.apache.solr.common.util.StrUtils;
-
-import java.util.*;
-
-
-public class JSONTestUtil {
-
-  public static String match(String input, String pathAndExpected) throws Exception {
-    int pos = pathAndExpected.indexOf("==");
-    String path = pos>=0 ? pathAndExpected.substring(0,pos) : null;
-    String expected = pos>=0 ? pathAndExpected.substring(pos+2) : pathAndExpected;
-    return match(path, input, expected);
-  }
-
-  public static String match(String path, String input, String expected) throws Exception {
-    Object inputObj = ObjectBuilder.fromJSON(input);
-    Object expectObj = ObjectBuilder.fromJSON(expected);
-    return matchObj(path, inputObj, expectObj);
-  }
-
-  /**
-  public static Object fromJSON(String json) {
-    try {
-      Object out = ObjectBuilder.fromJSON(json);
-    } finally {
-
-  }
-  **/
-  
-  public static String matchObj(String path, Object input, Object expected) throws Exception {
-    CollectionTester tester = new CollectionTester(input);
-    boolean reversed = path.startsWith("!");
-    String positivePath = reversed ? path.substring(1) : path;
-    if (!tester.seek(positivePath) ^ reversed) {
-      return "Path not found: " + path;
-    }
-    if (expected != null && (!tester.match(expected) ^ reversed)) {
-      return tester.err + " @ " + tester.getPath();
-    }
-    return null;
-  }
-}
-
-
-/** Tests simple object graphs, like those generated by the noggit JSON parser */
-class CollectionTester {
-  public Object valRoot;
-  public Object val;
-  public Object expectedRoot;
-  public Object expected;
-  public List<Object> path;
-  public String err;
-
-  public CollectionTester(Object val) {
-    this.val = val;
-    this.valRoot = val;
-    path = new ArrayList<Object>();
-  }
-
-  public String getPath() {
-    StringBuilder sb = new StringBuilder();
-    boolean first=true;
-    for (Object seg : path) {
-      if (seg==null) break;
-      if (!first) sb.append('/');
-      else first=false;
-
-      if (seg instanceof Integer) {
-        sb.append('[');
-        sb.append(seg);
-        sb.append(']');
-      } else {
-        sb.append(seg.toString());
-      }
-    }
-    return sb.toString();
-  }
-
-  void setPath(Object lastSeg) {
-    path.set(path.size()-1, lastSeg);
-  }
-  Object popPath() {
-    return path.remove(path.size()-1);
-  }
-  void pushPath(Object lastSeg) {
-    path.add(lastSeg);
-  }
-
-  void setErr(String msg) {
-    err = msg;
-  }
-
-  public boolean match(Object expected) {
-    this.expectedRoot = expected;
-    this.expected = expected;
-    return match();
-  }
-
-  boolean match() {
-    if (expected == val) {
-      return true;
-    }
-    if (expected == null || val == null) {
-      setErr("mismatch: '" + expected + "'!='" + val + "'");
-      return false;
-    }
-    if (expected instanceof List) {
-      return matchList();
-    }
-    if (expected instanceof Map) {
-      return matchMap();
-    }
-
-    // generic fallback
-    if (!expected.equals(val)) {
-
-      // make an exception for some numerics
-      if ((expected instanceof Integer && val instanceof Long || expected instanceof Long && val instanceof Integer)
-          && ((Number)expected).longValue() == ((Number)val).longValue())
-      {
-        return true;
-      } else if ((expected instanceof Float && val instanceof Double || expected instanceof Double && val instanceof Float)) {
-        double a = ((Number)expected).doubleValue();
-        double b = ((Number)val).doubleValue();
-        if (Double.compare(a,b) == 0) return true;
-        if (Math.abs(a-b) < 1e-5) return true;
-        return false;
-      } else {
-        setErr("mismatch: '" + expected + "'!='" + val + "'");
-        return false;
-      }
-    }
-
-    // setErr("unknown expected type " + expected.getClass().getName());
-    return true;
-  }
-
-  boolean matchList() {
-    List expectedList = (List)expected;
-    List v = asList();
-    if (v == null) return false;
-    int a = 0;
-    int b = 0;
-    pushPath(null);
-    for (;;) {
-      if (a >= expectedList.size() &&  b >=v.size()) {
-        break;
-      }
-
-      if (a >= expectedList.size() || b >=v.size()) {
-        popPath();
-        setErr("List size mismatch");
-        return false;
-      }
-
-      expected = expectedList.get(a);
-      val = v.get(b);
-      setPath(b);
-      if (!match()) return false;
-
-      a++; b++;
-    }
-    
-    popPath();
-    return true;
-  }
-
-  private static Set<String> reserved = new HashSet<String>(Arrays.asList("_SKIP_","_MATCH_","_ORDERED_","_UNORDERED_"));
-
-  boolean matchMap() {
-    Map<String,Object> expectedMap = (Map<String,Object>)expected;
-    Map<String,Object> v = asMap();
-    if (v == null) return false;
-
-    boolean ordered = false;
-    String skipList = (String)expectedMap.get("_SKIP_");
-    String matchList = (String)expectedMap.get("_MATCH_");
-    Object orderedStr = expectedMap.get("_ORDERED_");
-    Object unorderedStr = expectedMap.get("_UNORDERED_");
-
-    if (orderedStr != null) ordered = true;
-    if (unorderedStr != null) ordered = false;
-
-    Set<String> match = null;
-    if (matchList != null) {
-      match = new HashSet(StrUtils.splitSmart(matchList,",",false));
-    }
-
-    Set<String> skips = null;
-    if (skipList != null) {
-      skips = new HashSet(StrUtils.splitSmart(skipList,",",false));
-    }
-
-    Set<String> keys = match != null ? match : expectedMap.keySet();
-    Set<String> visited = new HashSet<String>();
-
-    Iterator<Map.Entry<String,Object>> iter = ordered ? v.entrySet().iterator() : null;
-
-    int numExpected=0;
-
-    pushPath(null);
-    for (String expectedKey : keys) {
-      if (reserved.contains(expectedKey)) continue;
-      numExpected++;
-
-      setPath(expectedKey);
-      if (!v.containsKey(expectedKey)) {
-        popPath();
-        setErr("expected key '" + expectedKey + "'");
-        return false;
-      }
-
-      expected = expectedMap.get(expectedKey);
-
-      if (ordered) {
-        Map.Entry<String,Object> entry;
-        String foundKey;
-        for(;;) {
-          if (!iter.hasNext()) {
-            popPath();
-            setErr("expected key '" + expectedKey + "' in ordered map");
-            return false;           
-          }
-          entry = iter.next();
-          foundKey = entry.getKey();
-          if (skips != null && skips.contains(foundKey))continue;
-          if (match != null && !match.contains(foundKey)) continue;
-          break;
-        }
-
-        if (!entry.getKey().equals(expectedKey)) {
-          popPath();          
-          setErr("expected key '" + expectedKey + "' instead of '"+entry.getKey()+"' in ordered map");
-          return false;
-        }
-        val = entry.getValue();
-      } else {
-        if (skips != null && skips.contains(expectedKey)) continue;
-        val = v.get(expectedKey);
-      }
-
-      if (!match()) return false;
-    }
-
-    popPath();
-
-    // now check if there were any extra keys in the value (as long as there wasn't a specific list to include)
-    if (match == null) {
-      int skipped = 0;
-      if (skips != null) {
-        for (String skipStr : skips)
-          if (v.containsKey(skipStr)) skipped++;
-      }
-      if (numExpected != (v.size() - skipped)) {
-        HashSet<String> set = new HashSet<String>(v.keySet());
-        set.removeAll(expectedMap.keySet());
-        setErr("unexpected map keys " + set); 
-        return false;
-      }
-    }
-
-    return true;
-  }
-
-  public boolean seek(String seekPath) {
-    if (path == null) return true;
-    if (seekPath.startsWith("/")) {
-      seekPath = seekPath.substring(1);
-    }
-    if (seekPath.endsWith("/")) {
-      seekPath = seekPath.substring(0,seekPath.length()-1);
-    }
-    List<String> pathList = StrUtils.splitSmart(seekPath, "/", false);
-    return seek(pathList);
-  }
-
-  List asList() {
-    // TODO: handle native arrays
-    if (val instanceof List) {
-      return (List)val;
-    }
-    setErr("expected List");
-    return null;
-  }
-  
-  Map<String,Object> asMap() {
-    // TODO: handle NamedList
-    if (val instanceof Map) {
-      return (Map<String,Object>)val;
-    }
-    setErr("expected Map");
-    return null;
-  }
-
-  public boolean seek(List<String> seekPath) {
-    if (seekPath.size() == 0) return true;
-    String seg = seekPath.get(0);
-
-    if (seg.charAt(0)=='[') {
-      List listVal = asList();
-      if (listVal==null) return false;
-
-      int arrIdx = Integer.parseInt(seg.substring(1, seg.length()-1));
-
-      if (arrIdx >= listVal.size()) return false;
-
-      val = listVal.get(arrIdx);
-      pushPath(arrIdx);
-    } else {
-      Map<String,Object> mapVal = asMap();
-      if (mapVal==null) return false;
-
-      // use containsKey rather than get to handle null values
-      if (!mapVal.containsKey(seg)) return false;
-
-      val = mapVal.get(seg);
-      pushPath(seg);
-    }
-
-    // recurse after removing head of the path
-    return seek(seekPath.subList(1,seekPath.size()));
-  }
-
-
-
-}
diff --git a/solr/src/test/org/apache/solr/SolrTestCaseJ4.java b/solr/src/test/org/apache/solr/SolrTestCaseJ4.java
deleted file mode 100755
index 546850a..0000000
--- a/solr/src/test/org/apache/solr/SolrTestCaseJ4.java
+++ /dev/null
@@ -1,1085 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.solr;
-
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.noggit.CharArr;
-import org.apache.noggit.JSONUtil;
-import org.apache.noggit.ObjectBuilder;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.core.SolrConfig;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.handler.JsonUpdateRequestHandler;
-import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.schema.SchemaField;
-import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.servlet.DirectSolrConnection;
-import org.apache.solr.util.TestHarness;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.xml.sax.SAXException;
-
-import javax.xml.xpath.XPathExpressionException;
-import java.io.File;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.*;
-
-/**
- * A junit4 Solr test harness that extends LuceneTestCaseJ4.
- * Unlike AbstractSolrTestCase, a new core is not created for each test method.
- *
- */
-public abstract class SolrTestCaseJ4 extends LuceneTestCase {
-
-  @BeforeClass
-  public static void beforeClassSolrTestCase() throws Exception {
-    ignoreException("ignore_exception");
-  }
-
-  @AfterClass
-  public static void afterClassSolrTestCase() throws Exception {
-    deleteCore();
-    resetExceptionIgnores();
-  }
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    log.info("###Starting " + getName());  // returns <unknown>???
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    log.info("###Ending " + getName());    
-    super.tearDown();
-  }
-
-  /** Call initCore in @BeforeClass to instantiate a solr core in your test class.
-   * deleteCore will be called for you via SolrTestCaseJ4 @AfterClass */
-  public static void initCore(String config, String schema) throws Exception {
-    initCore(config, schema, TEST_HOME);
-  }
-
-  /** Call initCore in @BeforeClass to instantiate a solr core in your test class.
-   * deleteCore will be called for you via SolrTestCaseJ4 @AfterClass */
-  public static void initCore(String config, String schema, String solrHome) throws Exception {
-    startTrackingSearchers();
-    configString = config;
-    schemaString = schema;
-    if (solrHome != null) {
-      System.setProperty("solr.solr.home", solrHome);
-    }
-    initCore();
-  }
-
-
-  static long numOpens;
-  static long numCloses;
-  protected static void startTrackingSearchers() {
-    numOpens = SolrIndexSearcher.numOpens.get();
-    numCloses = SolrIndexSearcher.numCloses.get();
-  }
-
-  protected static void endTrackingSearchers() {
-     long endNumOpens = SolrIndexSearcher.numOpens.get();
-     long endNumCloses = SolrIndexSearcher.numCloses.get();
-
-     if (endNumOpens-numOpens != endNumCloses-numCloses) {
-       String msg = "ERROR: SolrIndexSearcher opens=" + (endNumOpens-numOpens) + " closes=" + (endNumCloses-numCloses);
-       log.error(msg);
-       fail(msg);
-     }
-  }
-
-  /** Causes an exception matching the regex pattern to not be logged. */
-  public static void ignoreException(String pattern) {
-    if (SolrException.ignorePatterns == null)
-      SolrException.ignorePatterns = new HashSet<String>();
-    SolrException.ignorePatterns.add(pattern);
-  }
-
-  public static void resetExceptionIgnores() {
-    SolrException.ignorePatterns = null;
-    ignoreException("ignore_exception");  // always ignore "ignore_exception"    
-  }
-
-  protected static String getClassName() {
-    StackTraceElement[] stack = new RuntimeException("WhoAmI").fillInStackTrace().getStackTrace();
-    for (int i = stack.length-1; i>=0; i--) {
-      StackTraceElement ste = stack[i];
-      String cname = ste.getClassName();
-      if (cname.indexOf(".lucene.")>=0 || cname.indexOf(".solr.")>=0) {
-        return cname;
-      }
-    }
-    return SolrTestCaseJ4.class.getName();
-  }
-
-  protected static String getSimpleClassName() {
-    String cname = getClassName();
-    return cname.substring(cname.lastIndexOf('.')+1);
-  }
-
-  protected static String configString;
-  protected static String schemaString;
-
-  protected static SolrConfig solrConfig;
-  /**
-   * Harness initialized by initTestHarness.
-   *
-   * <p>
-   * For use in test methods as needed.
-   * </p>
-   */
-  protected static TestHarness h;
-  /**
-   * LocalRequestFactory initialized by initTestHarness using sensible
-   * defaults.
-   *
-   * <p>
-   * For use in test methods as needed.
-   * </p>
-   */
-  protected static TestHarness.LocalRequestFactory lrf;
-
-
-  /**
-   * Subclasses must define this method to return the name of the
-   * schema.xml they wish to use.
-   */
-  public static  String getSchemaFile() {
-    return schemaString;
-  };
-
-  /**
-   * Subclasses must define this method to return the name of the
-   * solrconfig.xml they wish to use.
-   */
-  public static  String getSolrConfigFile() {
-    return configString;
-  };
-
-  /**
-   * The directory used to story the index managed by the TestHarness h
-   */
-  protected static File dataDir;
-
-  /**
-   * Initializes things your test might need
-   *
-   * <ul>
-   * <li>Creates a dataDir in the "java.io.tmpdir"</li>
-   * <li>initializes the TestHarness h using this data directory, and getSchemaPath()</li>
-   * <li>initializes the LocalRequestFactory lrf using sensible defaults.</li>
-   * </ul>
-   *
-   */
-
-  public static Logger log = LoggerFactory.getLogger(SolrTestCaseJ4.class);
-
-  private static String factoryProp;
-
-  public static void createTempDir() {
-    String cname = getSimpleClassName();
-    dataDir = new File(TEMP_DIR,
-            "solrtest-" + cname + "-" + System.currentTimeMillis());
-    dataDir.mkdirs();
-  }
-
-  public static void initCore() throws Exception {
-    log.info("####initCore");
-
-    ignoreException("ignore_exception");
-    factoryProp = System.getProperty("solr.directoryFactory");
-    if (factoryProp == null) {
-      System.setProperty("solr.directoryFactory","solr.RAMDirectoryFactory");
-    }
-    if (dataDir == null) {
-      createTempDir();
-    }
-
-    // other  methods like starting a jetty instance need these too
-    System.setProperty("solr.test.sys.prop1", "propone");
-    System.setProperty("solr.test.sys.prop2", "proptwo");
-
-    String configFile = getSolrConfigFile();
-    if (configFile != null) {
-
-      solrConfig = h.createConfig(getSolrConfigFile());
-      h = new TestHarness( dataDir.getAbsolutePath(),
-              solrConfig,
-              getSchemaFile());
-      lrf = h.getRequestFactory
-              ("standard",0,20,CommonParams.VERSION,"2.2");
-    }
-    log.info("####initCore end");
-  }
-
-  /** Subclasses that override setUp can optionally call this method
-   * to log the fact that their setUp process has ended.
-   */
-  public void postSetUp() {
-    log.info("####POSTSETUP " + getName());
-  }
-
-
-  /** Subclasses that override tearDown can optionally call this method
-   * to log the fact that the tearDown process has started.  This is necessary
-   * since subclasses will want to call super.tearDown() at the *end* of their
-   * tearDown method.
-   */
-  public void preTearDown() {
-    log.info("####PRETEARDOWN " + getName());
-  }
-
-  /**
-   * Shuts down the test harness, and makes the best attempt possible
-   * to delete dataDir, unless the system property "solr.test.leavedatadir"
-   * is set.
-   */
-  public static void deleteCore() throws Exception {
-    log.info("###deleteCore" );
-    if (h != null) { h.close(); }
-    if (dataDir != null) {
-      String skip = System.getProperty("solr.test.leavedatadir");
-      if (null != skip && 0 != skip.trim().length()) {
-        System.err.println("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
-      } else {
-        if (!recurseDelete(dataDir)) {
-          System.err.println("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
-        }
-      }
-    }
-
-    if (factoryProp == null) {
-      System.clearProperty("solr.directoryFactory");
-    }
-    
-    dataDir = null;
-    solrConfig = null;
-    h = null;
-    lrf = null;
-    configString = schemaString = null;
-
-    endTrackingSearchers();
-  }
-
-
-  /** Validates an update XML String is successful
-   */
-  public static void assertU(String update) {
-    assertU(null, update);
-  }
-
-  /** Validates an update XML String is successful
-   */
-  public static void assertU(String message, String update) {
-    checkUpdateU(message, update, true);
-  }
-
-  /** Validates an update XML String failed
-   */
-  public static void assertFailedU(String update) {
-    assertFailedU(null, update);
-  }
-
-  /** Validates an update XML String failed
-   */
-  public static void assertFailedU(String message, String update) {
-    checkUpdateU(message, update, false);
-  }
-
-  /** Checks the success or failure of an update message
-   */
-  private static void checkUpdateU(String message, String update, boolean shouldSucceed) {
-    try {
-      String m = (null == message) ? "" : message + " ";
-      if (shouldSucceed) {
-           String res = h.validateUpdate(update);
-         if (res != null) fail(m + "update was not successful: " + res);
-      } else {
-           String res = h.validateErrorUpdate(update);
-         if (res != null) fail(m + "update succeeded, but should have failed: " + res);
-      }
-    } catch (SAXException e) {
-      throw new RuntimeException("Invalid XML", e);
-    }
-  }
-
-  /** Validates a query matches some XPath test expressions and closes the query */
-  public static void assertQ(SolrQueryRequest req, String... tests) {
-    assertQ(null, req, tests);
-  }
-
-  /** Validates a query matches some XPath test expressions and closes the query */
-  public static void assertQ(String message, SolrQueryRequest req, String... tests) {
-    try {
-      String m = (null == message) ? "" : message + " ";
-      String response = h.query(req);
-
-      if (req.getParams().getBool("facet", false)) {
-        // add a test to ensure that faceting did not throw an exception
-        // internally, where it would be added to facet_counts/exception
-        String[] allTests = new String[tests.length+1];
-        System.arraycopy(tests,0,allTests,1,tests.length);
-        allTests[0] = "*[count(//lst[@name='facet_counts']/*[@name='exception'])=0]";
-        tests = allTests;
-      }
-
-      String results = h.validateXPath(response, tests);
-
-      if (null != results) {
-        String msg = "REQUEST FAILED: xpath=" + results
-            + "\n\txml response was: " + response
-            + "\n\trequest was:" + req.getParamString();
-
-        log.error(msg);
-        throw new RuntimeException(msg);
-      }
-
-    } catch (XPathExpressionException e1) {
-      throw new RuntimeException("XPath is invalid", e1);
-    } catch (Exception e2) {
-      SolrException.log(log,"REQUEST FAILED: " + req.getParamString(), e2);
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-  /** Validates a query matches some JSON test expressions and closes the query.
-   * The text expression is of the form path:JSON.  To facilitate easy embedding
-   * in Java strings, the JSON can have double quotes replaced with single quotes.
-   *
-   * Please use this with care: this makes it easy to match complete structures, but doing so
-   * can result in fragile tests if you are matching more than what you want to test.
-   *
-   **/
-  public static void assertJQ(SolrQueryRequest req, String... tests) throws Exception {
-    SolrParams params =  null;
-    try {
-      params = req.getParams();
-      if (!"json".equals(params.get("wt","xml")) || params.get("indent")==null) {
-        ModifiableSolrParams newParams = new ModifiableSolrParams(params);
-        newParams.set("wt","json");
-        if (params.get("indent")==null) newParams.set("indent","true");
-        req.setParams(newParams);
-      }
-
-      String response;
-      boolean failed=true;
-      try {
-        response = h.query(req);
-        failed = false;
-      } finally {
-        if (failed) {
-          log.error("REQUEST FAILED: " + req.getParamString());
-        }
-      }
-
-      for (String test : tests) {
-        String testJSON = test.replace('\'', '"');
-
-        try {
-          failed = true;
-          String err = JSONTestUtil.match(response, testJSON);
-          failed = false;
-          if (err != null) {
-            log.error("query failed JSON validation. error=" + err +
-                "\n expected =" + testJSON +
-                "\n response = " + response +
-                "\n request = " + req.getParamString()
-            );
-            throw new RuntimeException(err);
-          }
-        } finally {
-          if (failed) {
-            log.error("JSON query validation threw an exception." + 
-                "\n expected =" + testJSON +
-                "\n response = " + response +
-                "\n request = " + req.getParamString()
-            );
-          }
-        }
-      }
-    } finally {
-      // restore the params
-      if (params != null && params != req.getParams()) req.setParams(params);
-    }
-  }  
-
-
-  /** Makes sure a query throws a SolrException with the listed response code */
-  public static void assertQEx(String message, SolrQueryRequest req, int code ) {
-    try {
-      h.query(req);
-      fail( message );
-    } catch (SolrException sex) {
-      assertEquals( code, sex.code() );
-    } catch (Exception e2) {
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-  public static void assertQEx(String message, SolrQueryRequest req, SolrException.ErrorCode code ) {
-    try {
-      h.query(req);
-      fail( message );
-    } catch (SolrException e) {
-      assertEquals( code.code, e.code() );
-    } catch (Exception e2) {
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-
-  /**
-   * @see TestHarness#optimize
-   */
-  public static String optimize(String... args) {
-    return h.optimize(args);
-  }
-  /**
-   * @see TestHarness#commit
-   */
-  public static String commit(String... args) {
-    return h.commit(args);
-  }
-
-  /**
-   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
-   *
-   * @param fieldsAndValues 0th and Even numbered args are fields names odds are field values.
-   * @see #add
-   * @see #doc
-   */
-  public static String adoc(String... fieldsAndValues) {
-    XmlDoc d = doc(fieldsAndValues);
-    return add(d);
-  }
-
-  /**
-   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
-   */
-  public static String adoc(SolrInputDocument sdoc) {
-    List<String> fields = new ArrayList<String>();
-    for (SolrInputField sf : sdoc) {
-      for (Object o : sf.getValues()) {
-        fields.add(sf.getName());
-        fields.add(o.toString());
-      }
-    }
-    return adoc(fields.toArray(new String[fields.size()]));
-  }
-
-
-  /**
-   * Generates an &lt;add&gt;&lt;doc&gt;... XML String with options
-   * on the add.
-   *
-   * @param doc the Document to add
-   * @param args 0th and Even numbered args are param names, Odds are param values.
-   * @see #add
-   * @see #doc
-   */
-  public static String add(XmlDoc doc, String... args) {
-    try {
-      StringWriter r = new StringWriter();
-
-      // this is anoying
-      if (null == args || 0 == args.length) {
-        r.write("<add>");
-        r.write(doc.xml);
-        r.write("</add>");
-      } else {
-        XML.writeUnescapedXML(r, "add", doc.xml, (Object[])args);
-      }
-
-      return r.getBuffer().toString();
-    } catch (IOException e) {
-      throw new RuntimeException
-        ("this should never happen with a StringWriter", e);
-    }
-  }
-
-  /**
-   * Generates a &lt;delete&gt;... XML string for an ID
-   *
-   * @see TestHarness#deleteById
-   */
-  public static String delI(String id) {
-    return h.deleteById(id);
-  }
-  /**
-   * Generates a &lt;delete&gt;... XML string for an query
-   *
-   * @see TestHarness#deleteByQuery
-   */
-  public static String delQ(String q) {
-    return h.deleteByQuery(q);
-  }
-
-  /**
-   * Generates a simple &lt;doc&gt;... XML String with no options
-   *
-   * @param fieldsAndValues 0th and Even numbered args are fields names, Odds are field values.
-   * @see TestHarness#makeSimpleDoc
-   */
-  public static XmlDoc doc(String... fieldsAndValues) {
-    XmlDoc d = new XmlDoc();
-    d.xml = h.makeSimpleDoc(fieldsAndValues).toString();
-    return d;
-  }
-
-  public static ModifiableSolrParams params(String... params) {
-    ModifiableSolrParams msp = new ModifiableSolrParams();
-    for (int i=0; i<params.length; i+=2) {
-      msp.add(params[i], params[i+1]);
-    }
-    return msp;
-  }
-
-  /**
-   * Generates a SolrQueryRequest using the LocalRequestFactory
-   * @see #lrf
-   */
-  public static SolrQueryRequest req(String... q) {
-    return lrf.makeRequest(q);
-  }
-
-  /**
-   * Generates a SolrQueryRequest using the LocalRequestFactory
-   * @see #lrf
-   */
-  public static SolrQueryRequest req(String[] params, String... moreParams) {
-    String[] allParams = moreParams;
-    if (params.length!=0) {
-      int len = params.length + moreParams.length;
-      allParams = new String[len];
-      System.arraycopy(params,0,allParams,0,params.length);
-      System.arraycopy(moreParams,0,allParams,params.length,moreParams.length);
-    }
-
-    return lrf.makeRequest(allParams);
-  }
-
-  /**
-   * Generates a SolrQueryRequest
-   */
-  public static SolrQueryRequest req(SolrParams params, String... moreParams) {
-    ModifiableSolrParams mp = new ModifiableSolrParams(params);
-    for (int i=0; i<moreParams.length; i+=2) {
-      mp.add(moreParams[i], moreParams[i+1]);
-    }
-    return new LocalSolrQueryRequest(h.getCore(), mp);
-  }
-
-  /** Neccessary to make method signatures un-ambiguous */
-  public static class XmlDoc {
-    public String xml;
-    @Override
-    public String toString() { return xml; }
-  }
-
-  public static boolean recurseDelete(File f) {
-    if (f.isDirectory()) {
-      for (File sub : f.listFiles()) {
-        if (!recurseDelete(sub)) {
-          System.err.println("!!!! WARNING: best effort to remove " + sub.getAbsolutePath() + " FAILED !!!!!");
-          return false;
-        }
-      }
-    }
-    return f.delete();
-  }
-  
-  public void clearIndex() {
-    assertU(delQ("*:*"));
-  }
-
-  /** Send JSON update commands */
-  public static String updateJ(String json, SolrParams args) throws Exception {
-    SolrCore core = h.getCore();
-    DirectSolrConnection connection = new DirectSolrConnection(core);
-    SolrRequestHandler handler = core.getRequestHandler("/udate/json");
-    if (handler == null) {
-      handler = new JsonUpdateRequestHandler();
-      handler.init(null);
-    }
-    return connection.request(handler, args, json);
-  }
-
-
-  /////////////////////////////////////////////////////////////////////////////////////
-  //////////////////////////// random document / index creation ///////////////////////
-  /////////////////////////////////////////////////////////////////////////////////////
-  
-  public abstract static class Vals {
-    public abstract Comparable get();
-    public String toJSON(Comparable val) {
-      return JSONUtil.toJSON(val);
-    }
-
-    protected int between(int min, int max) {
-      return min != max ? random.nextInt(max-min+1) + min : min;
-    }
-  }
-
-  public abstract static class IVals extends Vals {
-    public abstract int getInt();
-  }
-
-  public static class IRange extends IVals {
-    final int min;
-    final int max;
-    public IRange(int min, int max) {
-      this.min = min;
-      this.max = max;
-    }
-
-    @Override
-    public int getInt() {
-      return between(min,max);
-    }
-
-    @Override
-    public Comparable get() {
-      return getInt();
-    }
-  }
-
-  public static class FVal extends Vals {
-    final float min;
-    final float max;
-    public FVal(float min, float max) {
-      this.min = min;
-      this.max = max;
-    }
-
-    public float getFloat() {
-      if (min >= max) return min;
-      return min + random.nextFloat() *  (max - min);
-    }
-
-    @Override
-    public Comparable get() {
-      return getFloat();
-    }
-  }  
-
-  public static class SVal extends Vals {
-    char start;
-    char end;
-    int minLength;
-    int maxLength;
-
-    public SVal() {
-      this('a','z',1,10);
-    }
-
-    public SVal(char start, char end, int minLength, int maxLength) {
-      this.start = start;
-      this.end = end;
-      this.minLength = minLength;
-      this.maxLength = maxLength;
-    }
-
-    @Override
-    public Comparable get() {
-      char[] arr = new char[between(minLength,maxLength)];
-      for (int i=0; i<arr.length; i++) {
-        arr[i] = (char)between(start, end);
-      }
-      return new String(arr);
-    }
-  }
-
-  public static final IRange ZERO_ONE = new IRange(0,1);
-  public static final IRange ONE_ONE = new IRange(1,1);
-
-  public static class Doc implements Comparable{
-    public Comparable id;
-    public List<Fld> fields;
-    public int order; // the order this document was added to the index
-
-
-    @Override
-    public String toString() {
-      return "Doc("+order+"):"+fields.toString();
-    }
-
-    @Override
-    public int hashCode() {
-      return id.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (!(o instanceof Doc)) return false;
-      Doc other = (Doc)o;
-      return this==other || id != null && id.equals(other.id);
-    }
-
-    @Override
-    public int compareTo(Object o) {
-      if (!(o instanceof Doc)) return this.getClass().hashCode() - o.getClass().hashCode();
-      Doc other = (Doc)o;
-      return this.id.compareTo(other.id);
-    }
-
-    public List<Comparable> getValues(String field) {
-      for (Fld fld : fields) {
-        if (fld.ftype.fname.equals(field)) return fld.vals;
-      }
-      return null;
-    }
-
-    public Comparable getFirstValue(String field) {
-      List<Comparable> vals = getValues(field);
-      return vals==null || vals.size()==0 ? null : vals.get(0);
-    }
-
-    public Map<String,Object> toObject(IndexSchema schema) {
-      Map<String,Object> result = new HashMap<String,Object>();
-      for (Fld fld : fields) {
-        SchemaField sf = schema.getField(fld.ftype.fname);
-        if (!sf.multiValued()) {
-          result.put(fld.ftype.fname, fld.vals.get(0));
-        } else {
-          result.put(fld.ftype.fname, fld.vals);
-        }
-      }
-      return result;
-    }
-
-  }
-
-  public static class Fld {
-    public FldType ftype;
-    public List<Comparable> vals;
-    @Override
-    public String toString() {
-      return ftype.fname + "=" + (vals.size()==1 ? vals.get(0).toString() : vals.toString());
-    }
-  }
-
-  class FldType {
-    public String fname;
-    public IRange numValues;
-    public Vals vals;
-
-    public FldType(String fname, Vals vals) {
-      this(fname, ZERO_ONE, vals);
-    }
-
-    public FldType(String fname, IRange numValues, Vals vals) {
-      this.fname = fname;
-      this.numValues = numValues;
-      this.vals = vals;      
-    }
-
-    public Comparable createValue() {
-      return vals.get();
-    }
-
-    public List<Comparable> createValues() {
-      int nVals = numValues.getInt();
-      if (nVals <= 0) return null;
-      List<Comparable> vals = new ArrayList<Comparable>(nVals);
-      for (int i=0; i<nVals; i++)
-        vals.add(createValue());
-      return vals;
-    }
-
-    public Fld createField() {
-      List<Comparable> vals = createValues();
-      if (vals == null) return null;
-
-      Fld fld = new Fld();
-      fld.ftype = this;
-      fld.vals = vals;
-      return fld;          
-    }
-
-  }
-
-
-  public Map<Comparable,Doc> indexDocs(List<FldType> descriptor, Map<Comparable,Doc> model, int nDocs) throws Exception {
-    if (model == null) {
-      model = new LinkedHashMap<Comparable,Doc>();
-    }
-
-    // commit an average of 10 times for large sets, or 10% of the time for small sets
-    int commitOneOutOf = Math.max(nDocs/10, 10);
-
-    for (int i=0; i<nDocs; i++) {
-      Doc doc = createDoc(descriptor);
-      // doc.order = order++;
-      updateJ(toJSON(doc), null);
-      model.put(doc.id, doc);
-
-      // commit 10% of the time
-      if (random.nextInt(commitOneOutOf)==0) {
-        assertU(commit());
-      }
-
-      // duplicate 10% of the docs
-      if (random.nextInt(10)==0) {
-        updateJ(toJSON(doc), null);
-        model.put(doc.id, doc);        
-      }
-    }
-
-    // optimize 10% of the time
-    if (random.nextInt(10)==0) {
-      assertU(optimize());
-    } else {
-      assertU(commit());
-    }
-
-    // merging segments no longer selects just adjacent segments hence ids (doc.order) can be shuffled.
-    // we need to look at the index to determine the order.
-    String responseStr = h.query(req("q","*:*", "fl","id", "sort","_docid_ asc", "rows",Integer.toString(model.size()*2), "wt","json", "indent","true"));
-    Object response = ObjectBuilder.fromJSON(responseStr);
-
-    response = ((Map)response).get("response");
-    response = ((Map)response).get("docs");
-    List<Map> docList = (List<Map>)response;
-    int order = 0;
-    for (Map doc : docList) {
-      Object id = doc.get("id");
-      Doc modelDoc = model.get(id);
-      if (modelDoc == null) continue;  // may be some docs in the index that aren't modeled
-      modelDoc.order = order++;
-    }
-
-    // make sure we updated the order of all docs in the model
-    assertEquals(order, model.size());
-
-    return model;
-  }
-
-  public static Doc createDoc(List<FldType> descriptor) {
-    Doc doc = new Doc();
-    doc.fields = new ArrayList<Fld>();
-    for (FldType ftype : descriptor) {
-      Fld fld = ftype.createField();
-      if (fld != null) {
-        doc.fields.add(fld);
-        if ("id".equals(ftype.fname))
-          doc.id = fld.vals.get(0);
-      }
-    }
-    return doc;
-  }
-
-  public static Comparator<Doc> createSort(IndexSchema schema, List<FldType> fieldTypes, String[] out) {
-    StringBuilder sortSpec = new StringBuilder();
-    int nSorts = random.nextInt(4);
-    List<Comparator<Doc>> comparators = new ArrayList<Comparator<Doc>>();
-    for (int i=0; i<nSorts; i++) {
-      if (i>0) sortSpec.append(',');
-
-      int which = random.nextInt(fieldTypes.size()+2);
-      boolean asc = random.nextBoolean();
-      if (which == fieldTypes.size()) {
-        // sort by score
-        sortSpec.append("score").append(asc ? " asc" : " desc");
-        comparators.add(createComparator("score", asc, false, false, false));
-      } else if (which == fieldTypes.size() + 1) {
-        // sort by docid
-        sortSpec.append("_docid_").append(asc ? " asc" : " desc");
-        comparators.add(createComparator("_docid_", asc, false, false, false));
-      } else {
-        String field = fieldTypes.get(which).fname;
-        sortSpec.append(field).append(asc ? " asc" : " desc");
-        SchemaField sf = schema.getField(field);
-        comparators.add(createComparator(field, asc, sf.sortMissingLast(), sf.sortMissingFirst(), !(sf.sortMissingLast()||sf.sortMissingFirst()) ));
-      }
-    }
-
-    out[0] = sortSpec.length() > 0 ? sortSpec.toString() : null;
-
-    if (comparators.size() == 0) {
-      // default sort is by score desc
-      comparators.add(createComparator("score", false, false, false, false));      
-    }
-
-    return createComparator(comparators);
-  }
-
-  public static Comparator<Doc> createComparator(final String field, final boolean asc, final boolean sortMissingLast, final boolean sortMissingFirst, final boolean sortMissingAsZero) {
-    final int mul = asc ? 1 : -1;
-
-    if (field.equals("_docid_")) {
-     return new Comparator<Doc>() {
-      @Override
-      public int compare(Doc o1, Doc o2) {
-        return (o1.order - o2.order) * mul;
-      }
-     };
-    }
-
-    if (field.equals("score")) {
-      return createComparator("score_f", asc, sortMissingLast, sortMissingFirst, sortMissingAsZero);
-    }
-
-    return new Comparator<Doc>() {
-      private Comparable zeroVal(Comparable template) {
-        if (template == null) return null;
-        if (template instanceof String) return null;  // fast-path for string
-        if (template instanceof Integer) return 0;
-        if (template instanceof Long) return (long)0;
-        if (template instanceof Float) return (float)0;
-        if (template instanceof Double) return (double)0;
-        if (template instanceof Short) return (short)0;
-        if (template instanceof Byte) return (byte)0;
-        if (template instanceof Character) return (char)0;
-        return null;
-      }
-
-      @Override
-      public int compare(Doc o1, Doc o2) {
-        Comparable v1 = o1.getFirstValue(field);
-        Comparable v2 = o2.getFirstValue(field);
-
-        v1 = v1 == null ? zeroVal(v2) : v1;
-        v2 = v2 == null ? zeroVal(v1) : v2;
-
-        int c = 0;
-        if (v1 == v2) {
-          c = 0;
-        } else if (v1 == null) {
-          if (sortMissingLast) c = mul;
-          else if (sortMissingFirst) c = -mul;
-          else c = -1;
-        } else if (v2 == null) {
-          if (sortMissingLast) c = -mul;
-          else if (sortMissingFirst) c = mul;
-          else c = 1;
-        } else {
-          c = v1.compareTo(v2);
-        }
-
-        c = c * mul;
-
-        return c;
-      }
-    };
-  }
-
-  public static Comparator<Doc> createComparator(final List<Comparator<Doc>> comparators) {
-    return new Comparator<Doc>() {
-      @Override
-      public int compare(Doc o1, Doc o2) {
-        int c = 0;
-        for (Comparator<Doc> comparator : comparators) {
-          c = comparator.compare(o1, o2);
-          if (c!=0) return c;
-        }
-        return o1.order - o2.order;
-      }
-    };
-  }
-
-
-  public static String toJSON(Doc doc) {
-    CharArr out = new CharArr();
-    try {
-      out.append("{\"add\":{\"doc\":{");
-      boolean firstField = true;
-      for (Fld fld : doc.fields) {
-        if (firstField) firstField=false;
-        else out.append(',');
-        JSONUtil.writeString(fld.ftype.fname, 0, fld.ftype.fname.length(), out);
-        out.append(':');
-        if (fld.vals.size() > 1) {
-          out.append('[');
-        }
-        boolean firstVal = true;
-        for (Comparable val : fld.vals) {
-          if (firstVal) firstVal=false;
-          else out.append(',');
-          out.append(JSONUtil.toJSON(val));
-        }
-        if (fld.vals.size() > 1) {
-          out.append(']');
-        }
-      }
-      out.append("}}}");
-    } catch (IOException e) {
-      // should never happen
-    }
-    return out.toString();
-  }
-
-  /** Gets a resource from the context classloader as {@link File}. This method should only be used,
-   * if a real file is needed. To get a stream, code should prefer
-   * {@link Class#getResourceAsStream} using {@code this.getClass()}.
-   */
-  public static File getFile(String name) {
-    try {
-      File file = new File(name);
-      if (!file.exists()) {
-        file = new File(Thread.currentThread().getContextClassLoader().getResource(name).toURI());
-      }
-      return file;
-    } catch (Exception e) {
-      /* more friendly than NPE */
-      throw new RuntimeException("Cannot find resource: " + name);
-    }
-  }
-  
-  private static final String SOURCE_HOME = determineSourceHome();
-  public static String TEST_HOME = getFile("solr/conf").getParent();
-  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
-  public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
-  public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
-  public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
-  public static String EXAMPLE_CONFIG=EXAMPLE_HOME+"/conf/solrconfig.xml";
-  
-  static String determineSourceHome() {
-    // ugly, ugly hack to determine the example home without depending on the CWD
-    // this is needed for example/multicore tests which reside outside the classpath
-    File base = getFile("solr/conf/").getAbsoluteFile();
-    while (!new File(base, "solr/CHANGES.txt").exists()) {
-      base = base.getParentFile();
-    }
-    return new File(base, "solr/").getAbsolutePath();
-  }
-
-  public static Throwable getRootCause(Throwable t) {
-    Throwable result = t;
-    for (Throwable cause = t; null != cause; cause = cause.getCause()) {
-      result = cause;
-    }
-    return result;
-  }
-}
diff --git a/solr/src/test/org/apache/solr/analysis/BaseTokenTestCase.java b/solr/src/test/org/apache/solr/analysis/BaseTokenTestCase.java
deleted file mode 100644
index ce3338d..0000000
--- a/solr/src/test/org/apache/solr/analysis/BaseTokenTestCase.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.analysis;
-
-import java.util.Collections;
-import java.util.Map;
-
-import org.apache.lucene.analysis.BaseTokenStreamTestCase;
-import org.apache.lucene.util.Version;
-import org.apache.solr.core.Config;
-
-/**
- * General token testing helper functions
- */
-public abstract class BaseTokenTestCase extends BaseTokenStreamTestCase
-{
-  /** a map containing the default test version param for easy testing */
-  protected static final Map<String,String> DEFAULT_VERSION_PARAM = 
-    Collections.singletonMap("luceneMatchVersion", System.getProperty("tests.luceneMatchVersion", "LUCENE_CURRENT"));
-
-  /** The default test version for easy testing */
-  public static final Version DEFAULT_VERSION = Config.parseLuceneVersionString(DEFAULT_VERSION_PARAM.get("luceneMatchVersion"));
-}
diff --git a/solr/src/test/org/apache/solr/client/solrj/MergeIndexesExampleTestBase.java b/solr/src/test/org/apache/solr/client/solrj/MergeIndexesExampleTestBase.java
index 6ff0546..3c6b2d1 100644
--- a/solr/src/test/org/apache/solr/client/solrj/MergeIndexesExampleTestBase.java
+++ b/solr/src/test/org/apache/solr/client/solrj/MergeIndexesExampleTestBase.java
@@ -24,6 +24,7 @@ import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrCore;
+import org.apache.solr.util.ExternalPaths;
 
 /**
  * Abstract base class for testing merge indexes command
@@ -37,7 +38,7 @@ public abstract class MergeIndexesExampleTestBase extends SolrExampleTestBase {
 
   @Override
   public String getSolrHome() {
-    return SolrJettyTestBase.EXAMPLE_MULTICORE_HOME;
+    return ExternalPaths.EXAMPLE_MULTICORE_HOME;
   }
 
   @Override
diff --git a/solr/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java b/solr/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
index 6aa5851..39fae68 100644
--- a/solr/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
+++ b/solr/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
@@ -25,6 +25,7 @@ import org.apache.solr.client.solrj.response.CoreAdminResponse;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrCore;
+import org.apache.solr.util.ExternalPaths;
 
 
 /**
@@ -36,7 +37,7 @@ public abstract class MultiCoreExampleTestBase extends SolrExampleTestBase
   // protected static final CoreContainer cores = new CoreContainer();
   protected static CoreContainer cores;
 
-  @Override public String getSolrHome() { return SolrJettyTestBase.EXAMPLE_MULTICORE_HOME; }
+  @Override public String getSolrHome() { return ExternalPaths.EXAMPLE_MULTICORE_HOME; }
   
   @Override public String getSchemaFile()     { return getSolrHome()+"/core0/conf/schema.xml";     }
   @Override public String getSolrConfigFile() { return getSolrHome()+"/core0/conf/solrconfig.xml"; }
diff --git a/solr/src/test/org/apache/solr/client/solrj/SolrExampleBinaryTest.java b/solr/src/test/org/apache/solr/client/solrj/SolrExampleBinaryTest.java
index 220c64c..6baa377 100644
--- a/solr/src/test/org/apache/solr/client/solrj/SolrExampleBinaryTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/SolrExampleBinaryTest.java
@@ -22,6 +22,7 @@ import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.impl.BinaryRequestWriter;
 import org.apache.solr.client.solrj.impl.BinaryResponseParser;
 import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 
@@ -32,7 +33,7 @@ import org.junit.BeforeClass;
 public class SolrExampleBinaryTest extends SolrExampleTests {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 
   @Override
diff --git a/solr/src/test/org/apache/solr/client/solrj/SolrJettyTestBase.java b/solr/src/test/org/apache/solr/client/solrj/SolrJettyTestBase.java
index ad8a70a..4ca9a75 100755
--- a/solr/src/test/org/apache/solr/client/solrj/SolrJettyTestBase.java
+++ b/solr/src/test/org/apache/solr/client/solrj/SolrJettyTestBase.java
@@ -24,6 +24,7 @@ import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;
 import org.apache.solr.client.solrj.embedded.JettySolrRunner;
 import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.AfterClass;
 
 abstract public class SolrJettyTestBase extends SolrTestCaseJ4 
@@ -32,7 +33,7 @@ abstract public class SolrJettyTestBase extends SolrTestCaseJ4
   // using configs in the test directory allows more flexibility to change "example"
   // without breaking configs.
 
-  public String getSolrHome() { return EXAMPLE_HOME; }
+  public String getSolrHome() { return ExternalPaths.EXAMPLE_HOME; }
 
   public static JettySolrRunner jetty;
   public static int port;
diff --git a/solr/src/test/org/apache/solr/client/solrj/TestBatchUpdate.java b/solr/src/test/org/apache/solr/client/solrj/TestBatchUpdate.java
index 9f5a4b5..69fb792 100644
--- a/solr/src/test/org/apache/solr/client/solrj/TestBatchUpdate.java
+++ b/solr/src/test/org/apache/solr/client/solrj/TestBatchUpdate.java
@@ -22,6 +22,7 @@ import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
 import org.apache.solr.client.solrj.request.RequestWriter;
 import org.apache.solr.client.solrj.response.QueryResponse;
 import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -38,7 +39,7 @@ public class TestBatchUpdate extends SolrJettyTestBase {
 
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 
   static final int numdocs = 1000;  
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
index cce5d3d..ab67aad 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
@@ -26,6 +26,7 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.apache.commons.io.IOUtils;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.SolrJettyTestBase;
+import org.apache.solr.util.ExternalPaths;
 import org.mortbay.jetty.Connector;
 import org.mortbay.jetty.Server;
 import org.mortbay.jetty.bio.SocketConnector;
@@ -47,13 +48,13 @@ public class JettyWebappTest extends LuceneTestCase
   public void setUp() throws Exception 
   {
     super.setUp();
-    System.setProperty("solr.solr.home", SolrJettyTestBase.EXAMPLE_HOME);
+    System.setProperty("solr.solr.home", ExternalPaths.EXAMPLE_HOME);
     
     File dataDir = new File(SolrTestCaseJ4.TEMP_DIR,
         getClass().getName() + "-" + System.currentTimeMillis());
     dataDir.mkdirs();
     System.setProperty("solr.data.dir", dataDir.getCanonicalPath());
-    String path = SolrJettyTestBase.WEBAPP_HOME;
+    String path = ExternalPaths.WEBAPP_HOME;
 
     server = new Server(port);
     // insecure: only use for tests!!!!
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeBinaryJettyTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeBinaryJettyTest.java
index 69b13fa..0e4a507 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeBinaryJettyTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeBinaryJettyTest.java
@@ -17,6 +17,7 @@
 package org.apache.solr.client.solrj.embedded;
 
 import org.apache.solr.client.solrj.LargeVolumeTestBase;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 /**
@@ -26,6 +27,6 @@ import org.junit.BeforeClass;
 public class LargeVolumeBinaryJettyTest extends LargeVolumeTestBase {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 }
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
index b72098a..a01e6a7 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
@@ -18,11 +18,12 @@
 package org.apache.solr.client.solrj.embedded;
 
 import org.apache.solr.client.solrj.LargeVolumeTestBase;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 public class LargeVolumeEmbeddedTest extends LargeVolumeTestBase {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    initCore(EXAMPLE_CONFIG, EXAMPLE_SCHEMA, EXAMPLE_HOME);
+    initCore(ExternalPaths.EXAMPLE_CONFIG, ExternalPaths.EXAMPLE_SCHEMA, ExternalPaths.EXAMPLE_HOME);
   }
 }
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
index 4303164..25040b0 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
@@ -18,11 +18,12 @@
 package org.apache.solr.client.solrj.embedded;
 
 import org.apache.solr.client.solrj.LargeVolumeTestBase;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 public class LargeVolumeJettyTest extends LargeVolumeTestBase {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 }
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
index 7483972..6a569bc 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
@@ -18,6 +18,7 @@
 package org.apache.solr.client.solrj.embedded;
 
 import org.apache.solr.client.solrj.SolrExampleTests;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 /**
@@ -30,6 +31,6 @@ public class SolrExampleEmbeddedTest extends SolrExampleTests {
 
   @BeforeClass
   public static void beforeTest() throws Exception {
-    initCore(EXAMPLE_CONFIG, EXAMPLE_SCHEMA, EXAMPLE_HOME);
+    initCore(ExternalPaths.EXAMPLE_CONFIG, ExternalPaths.EXAMPLE_SCHEMA, ExternalPaths.EXAMPLE_HOME);
   }
 }
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
index b18605a..41bbaeb 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
@@ -19,6 +19,7 @@ package org.apache.solr.client.solrj.embedded;
 
 import org.apache.solr.client.solrj.SolrExampleTests;
 import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -33,7 +34,7 @@ public class SolrExampleJettyTest extends SolrExampleTests {
 
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 
   @Test
diff --git a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleStreamingTest.java b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleStreamingTest.java
index 66e1ed0..a7747d0 100644
--- a/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleStreamingTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/embedded/SolrExampleStreamingTest.java
@@ -21,6 +21,7 @@ import org.apache.solr.client.solrj.SolrExampleTests;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
 import org.apache.solr.client.solrj.impl.StreamingUpdateSolrServer;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 
 
@@ -32,7 +33,7 @@ import org.junit.BeforeClass;
 public class SolrExampleStreamingTest extends SolrExampleTests {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(EXAMPLE_HOME, null, null);
+    createJetty(ExternalPaths.EXAMPLE_HOME, null, null);
   }
 
   @Override
diff --git a/solr/src/test/org/apache/solr/client/solrj/response/TermsResponseTest.java b/solr/src/test/org/apache/solr/client/solrj/response/TermsResponseTest.java
index 5e0eed5..4a599f0 100644
--- a/solr/src/test/org/apache/solr/client/solrj/response/TermsResponseTest.java
+++ b/solr/src/test/org/apache/solr/client/solrj/response/TermsResponseTest.java
@@ -24,6 +24,7 @@ import org.apache.solr.client.solrj.SolrQuery;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.client.solrj.request.QueryRequest;
 import org.apache.solr.client.solrj.response.TermsResponse.Term;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -35,7 +36,7 @@ public class TermsResponseTest extends SolrJettyTestBase {
 
   @BeforeClass
   public static void beforeTest() throws Exception {
-    initCore(EXAMPLE_CONFIG, EXAMPLE_SCHEMA, EXAMPLE_HOME);
+    initCore(ExternalPaths.EXAMPLE_CONFIG, ExternalPaths.EXAMPLE_SCHEMA, ExternalPaths.EXAMPLE_HOME);
   }
   
   @Before
diff --git a/solr/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java b/solr/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
index ff789f5..646d8bc 100644
--- a/solr/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
+++ b/solr/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
@@ -25,6 +25,7 @@ import org.apache.solr.client.solrj.response.SpellCheckResponse.Correction;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SpellingParams;
+import org.apache.solr.util.ExternalPaths;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -40,7 +41,7 @@ public class TestSpellCheckResponse extends SolrJettyTestBase {
   @BeforeClass
   public static void beforeTest() throws Exception {
     // createJetty(EXAMPLE_HOME, null, null);
-    initCore(EXAMPLE_CONFIG, EXAMPLE_SCHEMA, EXAMPLE_HOME);
+    initCore(ExternalPaths.EXAMPLE_CONFIG, ExternalPaths.EXAMPLE_SCHEMA, ExternalPaths.EXAMPLE_HOME);
     // initCore("solrconfig.xml", "schema.xml", null);
   }
   
diff --git a/solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java b/solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
index 2452a90..23b420c 100644
--- a/solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
+++ b/solr/src/test/org/apache/solr/cloud/BasicDistributedZkTest.java
@@ -60,7 +60,7 @@ public class BasicDistributedZkTest extends AbstractDistributedZkTestCase {
   
   @BeforeClass
   public static void beforeClass() throws Exception {
-    System.setProperty("solr.solr.home", SolrTestCaseJ4.TEST_HOME);
+    System.setProperty("solr.solr.home", SolrTestCaseJ4.TEST_HOME());
   }
   
   @Override
diff --git a/solr/src/test/org/apache/solr/common/util/TestSystemIdResolver.java b/solr/src/test/org/apache/solr/common/util/TestSystemIdResolver.java
index a827db9..d8ffdeb 100644
--- a/solr/src/test/org/apache/solr/common/util/TestSystemIdResolver.java
+++ b/solr/src/test/org/apache/solr/common/util/TestSystemIdResolver.java
@@ -38,9 +38,9 @@ public class TestSystemIdResolver extends LuceneTestCase {
   }
   
   public void testResolving() throws Exception {
-    final ResourceLoader loader = new SolrResourceLoader(SolrTestCaseJ4.TEST_HOME, this.getClass().getClassLoader());
+    final ResourceLoader loader = new SolrResourceLoader(SolrTestCaseJ4.TEST_HOME(), this.getClass().getClassLoader());
     final SystemIdResolver resolver = new SystemIdResolver(loader);
-    final String fileUri = new File(SolrTestCaseJ4.TEST_HOME+"/crazy-path-to-config.xml").toURI().toASCIIString();
+    final String fileUri = new File(SolrTestCaseJ4.TEST_HOME()+"/crazy-path-to-config.xml").toURI().toASCIIString();
     
     assertEquals("solrres:/test.xml", SystemIdResolver.createSystemIdFromResourceName("test.xml"));
     assertEquals("solrres://@/usr/local/etc/test.xml", SystemIdResolver.createSystemIdFromResourceName("/usr/local/etc/test.xml"));
@@ -60,10 +60,10 @@ public class TestSystemIdResolver extends LuceneTestCase {
     assertEntityResolving(resolver, "solrres:/schema.xml", "solrres:/solrconfig.xml", "schema.xml");
     assertEntityResolving(resolver, "solrres:/org/apache/solr/common/util/TestSystemIdResolver.class",
       "solrres:/org/apache/solr/common/ResourceLoader.class", "util/TestSystemIdResolver.class");
-    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME+"/conf/schema.xml"),
-      SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME+"/conf/solrconfig.xml"), "schema.xml");
-    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME+"/crazy-path-to-schema.xml"),
-      SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME+"/crazy-path-to-config.xml"), "crazy-path-to-schema.xml");
+    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME()+"/conf/schema.xml"),
+      SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME()+"/conf/solrconfig.xml"), "schema.xml");
+    assertEntityResolving(resolver, SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME()+"/crazy-path-to-schema.xml"),
+      SystemIdResolver.createSystemIdFromResourceName(SolrTestCaseJ4.TEST_HOME()+"/crazy-path-to-config.xml"), "crazy-path-to-schema.xml");
     
     // test, that resolving works if somebody uses an absolute file:-URI in a href attribute, the resolver should return null (default fallback)
     assertNull(resolver.resolveEntity(null, null, "solrres:/solrconfig.xml", fileUri));
diff --git a/solr/src/test/org/apache/solr/servlet/NoCacheHeaderTest.java b/solr/src/test/org/apache/solr/servlet/NoCacheHeaderTest.java
index e1d5bc6..ee360bf 100644
--- a/solr/src/test/org/apache/solr/servlet/NoCacheHeaderTest.java
+++ b/solr/src/test/org/apache/solr/servlet/NoCacheHeaderTest.java
@@ -31,7 +31,7 @@ import org.junit.Test;
 public class NoCacheHeaderTest extends CacheHeaderTestBase {
   @BeforeClass
   public static void beforeTest() throws Exception {
-    createJetty(TEST_HOME, "solr/conf/solrconfig-nocache.xml", null);
+    createJetty(TEST_HOME(), "solr/conf/solrconfig-nocache.xml", null);
   }
 
   // The tests
diff --git a/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest.java b/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest.java
index 4e4c899..58997c5 100644
--- a/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest.java
+++ b/solr/src/test/org/apache/solr/spelling/suggest/PersistenceTest.java
@@ -49,7 +49,7 @@ public class PersistenceTest extends SolrTestCaseJ4 {
     for (String k : keys) {
       lookup.add(k, new Float(k.length()));
     }
-    File storeDir = new File(TEST_HOME);
+    File storeDir = new File(TEST_HOME());
     lookup.store(storeDir);
     lookup = new TSTLookup();
     lookup.load(storeDir);
@@ -66,7 +66,7 @@ public class PersistenceTest extends SolrTestCaseJ4 {
     for (String k : keys) {
       lookup.add(k, new Float(k.length()));
     }
-    File storeDir = new File(TEST_HOME);
+    File storeDir = new File(TEST_HOME());
     lookup.store(storeDir);
     lookup = new JaspellLookup();
     lookup.load(storeDir);
diff --git a/solr/src/test/org/apache/solr/util/AbstractSolrTestCase.java b/solr/src/test/org/apache/solr/util/AbstractSolrTestCase.java
deleted file mode 100644
index 26aa202..0000000
--- a/solr/src/test/org/apache/solr/util/AbstractSolrTestCase.java
+++ /dev/null
@@ -1,429 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-package org.apache.solr.util;
-
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.solr.SolrTestCaseJ4;
-import org.apache.solr.core.SolrConfig;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.request.*;
-import org.apache.solr.util.TestHarness;
-
-import org.xml.sax.SAXException;
-import org.slf4j.LoggerFactory;
-import org.slf4j.Logger;
-import javax.xml.xpath.XPathExpressionException;
-
-import java.io.*;
-import java.util.HashSet;
-import java.util.List;
-import java.util.ArrayList;
-
-/**
- * An Abstract base class that makes writing Solr JUnit tests "easier"
- *
- * <p>
- * Test classes that subclass this need only specify the path to the
- * schema.xml file (:TODO: the solrconfig.xml as well) and write some
- * testMethods.  This class takes care of creating/destroying the index,
- * and provides several assert methods to assist you.
- * </p>
- *
- * @see #setUp
- * @see #tearDown
- */
-public abstract class AbstractSolrTestCase extends LuceneTestCase {
-    protected SolrConfig solrConfig;
-  /**
-   * Harness initialized by initTestHarness.
-   *
-   * <p>
-   * For use in test methods as needed.
-   * </p>
-   */
-  protected TestHarness h;
-  /**
-   * LocalRequestFactory initialized by initTestHarness using sensible
-   * defaults.
-   *
-   * <p>
-   * For use in test methods as needed.
-   * </p>
-   */
-  protected TestHarness.LocalRequestFactory lrf;
-    
-  /**
-   * Subclasses must define this method to return the name of the
-   * schema.xml they wish to use.
-   */
-  public abstract String getSchemaFile();
-    
-  /**
-   * Subclasses must define this method to return the name of the
-   * solrconfig.xml they wish to use.
-   */
-  public abstract String getSolrConfigFile();
-
-  /**
-   * Subclasses can override this to change a test's solr home
-   * (default is in test-files)
-   */
-  public String getSolrHome() {
-    return SolrTestCaseJ4.TEST_HOME;
-  }
-  
-  /**
-   * The directory used to story the index managed by the TestHarness h
-   */
-  protected File dataDir;
-    
-  /**
-   * Initializes things your test might need
-   *
-   * <ul>
-   * <li>Creates a dataDir in the "java.io.tmpdir"</li>
-   * <li>initializes the TestHarness h using this data directory, and getSchemaPath()</li>
-   * <li>initializes the LocalRequestFactory lrf using sensible defaults.</li>
-   * </ul>
-   *
-   */
-
-  public static Logger log = LoggerFactory.getLogger(AbstractSolrTestCase.class);
-
-  private String factoryProp;
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    log.info("####SETUP_START " + getName());
-    ignoreException("ignore_exception");
-    factoryProp = System.getProperty("solr.directoryFactory");
-    if (factoryProp == null) {
-      System.setProperty("solr.directoryFactory","solr.RAMDirectoryFactory");
-    }
-    dataDir = new File(TEMP_DIR,
-            getClass().getName() + "-" + System.currentTimeMillis());
-    dataDir.mkdirs();
-    String configFile = getSolrConfigFile();
-    System.setProperty("solr.solr.home", getSolrHome());
-    if (configFile != null) {
-
-      solrConfig = h.createConfig(getSolrConfigFile());
-      h = new TestHarness( dataDir.getAbsolutePath(),
-              solrConfig,
-              getSchemaFile());
-      lrf = h.getRequestFactory
-              ("standard",0,20,CommonParams.VERSION,"2.2");
-    }
-    log.info("####SETUP_END " + getName());
-  }
-
-    /** Causes an exception matching the regex pattern to not be logged. */
-  public static void ignoreException(String pattern) {
-    if (SolrException.ignorePatterns == null)
-      SolrException.ignorePatterns = new HashSet<String>();
-    SolrException.ignorePatterns.add(pattern);
-  }
-
-  public static void resetExceptionIgnores() {
-    SolrException.ignorePatterns = null;
-    ignoreException("ignore_exception");  // always ignore "ignore_exception"
-  }
-
-  /** Subclasses that override setUp can optionally call this method
-   * to log the fact that their setUp process has ended.
-   */
-  public void postSetUp() {
-    log.info("####POSTSETUP " + getName());
-  }
-
-
-  /** Subclasses that override tearDown can optionally call this method
-   * to log the fact that the tearDown process has started.  This is necessary
-   * since subclasses will want to call super.tearDown() at the *end* of their
-   * tearDown method.
-   */
-  public void preTearDown() {
-    log.info("####PRETEARDOWN " + getName());      
-  }
-
-  /**
-   * Shuts down the test harness, and makes the best attempt possible
-   * to delete dataDir, unless the system property "solr.test.leavedatadir"
-   * is set.
-   */
-  @Override
-  public void tearDown() throws Exception {
-    log.info("####TEARDOWN_START " + getName());
-    if (factoryProp == null) {
-      System.clearProperty("solr.directoryFactory");
-    }
-
-    if (h != null) { h.close(); }
-    String skip = System.getProperty("solr.test.leavedatadir");
-    if (null != skip && 0 != skip.trim().length()) {
-      System.err.println("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
-    } else {
-      if (!recurseDelete(dataDir)) {
-        System.err.println("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
-      }
-    }
-
-    resetExceptionIgnores();  
-    super.tearDown();
-  }
-
-  /** Validates an update XML String is successful
-   */
-  public void assertU(String update) {
-    assertU(null, update);
-  }
-
-  /** Validates an update XML String is successful
-   */
-  public void assertU(String message, String update) {
-    checkUpdateU(message, update, true);
-  }
-
-  /** Validates an update XML String failed
-   */
-  public void assertFailedU(String update) {
-    assertFailedU(null, update);
-  }
-
-  /** Validates an update XML String failed
-   */
-  public void assertFailedU(String message, String update) {
-    checkUpdateU(message, update, false);
-  }
-
-  /** Checks the success or failure of an update message
-   */
-  private void checkUpdateU(String message, String update, boolean shouldSucceed) {
-    try {
-      String m = (null == message) ? "" : message + " ";
-      if (shouldSucceed) {
-           String res = h.validateUpdate(update);
-         if (res != null) fail(m + "update was not successful: " + res);
-      } else {
-           String res = h.validateErrorUpdate(update);
-         if (res != null) fail(m + "update succeeded, but should have failed: " + res);        
-      }
-    } catch (SAXException e) {
-      throw new RuntimeException("Invalid XML", e);
-    }
-  }
-
-  /** Validates a query matches some XPath test expressions and closes the query */
-  public void assertQ(SolrQueryRequest req, String... tests) {
-    assertQ(null, req, tests);
-  }
-  
-  /** Validates a query matches some XPath test expressions and closes the query */
-  public void assertQ(String message, SolrQueryRequest req, String... tests) {
-    try {
-      String m = (null == message) ? "" : message + " ";
-      String response = h.query(req);
-      String results = h.validateXPath(response, tests);
-      if (null != results) {
-        fail(m + "query failed XPath: " + results +
-             "\n xml response was: " + response +
-             "\n request was: " + req.getParamString());
-      }
-    } catch (XPathExpressionException e1) {
-      throw new RuntimeException("XPath is invalid", e1);
-    } catch (Exception e2) {
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-  /** Makes sure a query throws a SolrException with the listed response code */
-  public void assertQEx(String message, SolrQueryRequest req, int code ) {
-    try {
-      h.query(req);
-      fail( message );
-    } catch (SolrException sex) {
-      assertEquals( code, sex.code() );
-    } catch (Exception e2) {
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-  public void assertQEx(String message, SolrQueryRequest req, SolrException.ErrorCode code ) {
-    try {
-      h.query(req);
-      fail( message );
-    } catch (SolrException e) {
-      assertEquals( code.code, e.code() );
-    } catch (Exception e2) {
-      throw new RuntimeException("Exception during query", e2);
-    }
-  }
-
-  
-  /**
-   * @see TestHarness#optimize
-   */
-  public String optimize(String... args) {
-    return h.optimize(args);
-  }
-  /**
-   * @see TestHarness#commit
-   */
-  public String commit(String... args) {
-    return h.commit(args);
-  }
-
-  /**
-   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
-   *
-   * @param fieldsAndValues 0th and Even numbered args are fields names odds are field values.
-   * @see #add
-   * @see #doc
-   */
-  public String adoc(String... fieldsAndValues) {
-    Doc d = doc(fieldsAndValues);
-    return add(d);
-  }
-
-  /**
-   * Generates a simple &lt;add&gt;&lt;doc&gt;... XML String with no options
-   */
-  public String adoc(SolrInputDocument sdoc) {
-    List<String> fields = new ArrayList<String>();
-    for (SolrInputField sf : sdoc) {
-      for (Object o : sf.getValues()) {
-        fields.add(sf.getName());
-        fields.add(o.toString());
-      }
-    }
-    return adoc(fields.toArray(new String[fields.size()]));
-  }
-
-    
-  /**
-   * Generates an &lt;add&gt;&lt;doc&gt;... XML String with options
-   * on the add.
-   *
-   * @param doc the Document to add
-   * @param args 0th and Even numbered args are param names, Odds are param values.
-   * @see #add
-   * @see #doc
-   */
-  public String add(Doc doc, String... args) {
-    try {
-      StringWriter r = new StringWriter();
-            
-      // this is anoying
-      if (null == args || 0 == args.length) {
-        r.write("<add>");
-        r.write(doc.xml);
-        r.write("</add>");
-      } else {
-        XML.writeUnescapedXML(r, "add", doc.xml, (Object[])args);
-      }
-            
-      return r.getBuffer().toString();
-    } catch (IOException e) {
-      throw new RuntimeException
-        ("this should never happen with a StringWriter", e);
-    }
-  }
-
-  /**
-   * Generates a &lt;delete&gt;... XML string for an ID
-   *
-   * @see TestHarness#deleteById
-   */
-  public String delI(String id) {
-    return h.deleteById(id);
-  }
-  /**
-   * Generates a &lt;delete&gt;... XML string for an query
-   *
-   * @see TestHarness#deleteByQuery
-   */
-  public String delQ(String q) {
-    return h.deleteByQuery(q);
-  }
-  
-  /**
-   * Generates a simple &lt;doc&gt;... XML String with no options
-   *
-   * @param fieldsAndValues 0th and Even numbered args are fields names, Odds are field values.
-   * @see TestHarness#makeSimpleDoc
-   */
-  public Doc doc(String... fieldsAndValues) {
-    Doc d = new Doc();
-    d.xml = h.makeSimpleDoc(fieldsAndValues).toString();
-    return d;
-  }
-
-  /**
-   * Generates a SolrQueryRequest using the LocalRequestFactory
-   * @see #lrf
-   */
-  public SolrQueryRequest req(String... q) {
-    return lrf.makeRequest(q);
-  }
-
-  /**
-   * Generates a SolrQueryRequest using the LocalRequestFactory
-   * @see #lrf
-   */
-  public SolrQueryRequest req(String[] params, String... moreParams) {
-    String[] allParams = moreParams;
-    if (params.length!=0) {
-      int len = params.length + moreParams.length;
-      allParams = new String[len];
-      System.arraycopy(params,0,allParams,0,params.length);
-      System.arraycopy(moreParams,0,allParams,params.length,moreParams.length);
-    }
-
-    return lrf.makeRequest(allParams);
-  }
-
-  /** Neccessary to make method signatures un-ambiguous */
-  public static class Doc {
-    public String xml;
-    @Override
-    public String toString() { return xml; }
-  }
-
-  public static boolean recurseDelete(File f) {
-    if (f.isDirectory()) {
-      for (File sub : f.listFiles()) {
-        if (!recurseDelete(sub)) {
-          System.err.println("!!!! WARNING: best effort to remove " + sub.getAbsolutePath() + " FAILED !!!!!");
-          return false;
-        }
-      }
-    }
-    return f.delete();
-  }
-
-  /** @see SolrTestCaseJ4#getFile */
-  public static File getFile(String name) throws IOException {
-    return SolrTestCaseJ4.getFile(name);
-  }
-}
diff --git a/solr/src/test/org/apache/solr/util/ExternalPaths.java b/solr/src/test/org/apache/solr/util/ExternalPaths.java
new file mode 100644
index 0000000..21e14cc
--- /dev/null
+++ b/solr/src/test/org/apache/solr/util/ExternalPaths.java
@@ -0,0 +1,46 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+
+import org.apache.solr.SolrTestCaseJ4;
+
+/**
+ * Some tests need to reach outside the classpath to get certain resources (e.g. the example configuration).
+ * This class provides some paths to allow them to do this.
+ * @lucene.internal
+ */
+public class ExternalPaths {
+  private static final String SOURCE_HOME = determineSourceHome();
+  public static String WEBAPP_HOME = new File(SOURCE_HOME, "src/webapp/web").getAbsolutePath();
+  public static String EXAMPLE_HOME = new File(SOURCE_HOME, "example/solr").getAbsolutePath();
+  public static String EXAMPLE_MULTICORE_HOME = new File(SOURCE_HOME, "example/multicore").getAbsolutePath();
+  public static String EXAMPLE_SCHEMA=EXAMPLE_HOME+"/conf/schema.xml";
+  public static String EXAMPLE_CONFIG=EXAMPLE_HOME+"/conf/solrconfig.xml";
+  
+  static String determineSourceHome() {
+    // ugly, ugly hack to determine the example home without depending on the CWD
+    // this is needed for example/multicore tests which reside outside the classpath
+    File base = SolrTestCaseJ4.getFile("solr/conf").getAbsoluteFile();
+    while (!new File(base, "solr/CHANGES.txt").exists()) {
+      base = base.getParentFile();
+    }
+    return new File(base, "solr/").getAbsolutePath();
+  }
+}

