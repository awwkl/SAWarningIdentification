GitDiffStart: a886c663d30d1fd09cc046338ca8766e14543113 | Mon Jul 13 18:10:56 2015 +0000
diff --git a/dev-tools/scripts/checkJavaDocs.py b/dev-tools/scripts/checkJavaDocs.py
index afa5dc1..9af1bb1 100644
--- a/dev-tools/scripts/checkJavaDocs.py
+++ b/dev-tools/scripts/checkJavaDocs.py
@@ -26,7 +26,9 @@ reJ8Caption = re.compile('<h3>(.*?) Summary</h3>')
 reTDLastNested = re.compile('^<td class="colLast"><code><strong><a href="[^>]*\.([^>]*?)\.html" title="class in[^>]*">', re.IGNORECASE)
 reTDLast = re.compile('^<td class="colLast"><code><strong><a href="[^>]*#([^>]*?)">', re.IGNORECASE)
 reColOne = re.compile('^<td class="colOne"><code><strong><a href="[^>]*#([^>]*?)">', re.IGNORECASE)
-reMemberNameLink = re.compile('^<td class="colLast"><code><span class="memberNameLink"><a href="[^>]*#([^>]*?)">', re.IGNORECASE)
+reMemberNameLink = re.compile('^<td class="colLast"><code><span class="memberNameLink"><a href="[^>]*#([^>]*?)"', re.IGNORECASE)
+reNestedClassMemberNameLink = re.compile('^<td class="colLast"><code><span class="memberNameLink"><a href="[^>]*?".*?>(.*?)</a>', re.IGNORECASE)
+reMemberNameOneLink = re.compile('^<td class="colOne"><code><span class="memberNameLink"><a href="[^>]*#([^>]*?)"', re.IGNORECASE)
 
 # the Method detail section at the end
 reMethodDetail = re.compile('^<h3>Method Detail</h3>$', re.IGNORECASE)
@@ -203,7 +205,9 @@ def checkClassSummaries(fullPath):
     for matcher in (reTDLastNested, # nested classes
                     reTDLast, # methods etc.
                     reColOne, # ctors etc.
-                    reMemberNameLink): # java 8
+                    reMemberNameLink, # java 8
+                    reNestedClassMemberNameLink, # java 8, nested class
+                    reMemberNameOneLink): # java 8 ctors
       m = matcher.search(line)
       if m is not None:
         lastItem = m.group(1)
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
index 377ad06..42eb43d 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dShapeRectRelationTestCase.java
@@ -117,7 +117,7 @@ public abstract class Geo3dShapeRectRelationTestCase extends RandomizedShapeTest
 
       @Override
       protected Point randomPointInEmptyShape(Geo3dShape shape) {
-        GeoPoint geoPoint = ((GeoCircle)shape.shape).center;
+        GeoPoint geoPoint = ((GeoCircle)shape.shape).getCenter();
         return geoPointToSpatial4jPoint(geoPoint);
       }
 
@@ -215,7 +215,7 @@ public abstract class Geo3dShapeRectRelationTestCase extends RandomizedShapeTest
         while (true) {
           try {
             final GeoPath path = new GeoPath(planetModel, width);
-            while (path.points.size() < pointCount) {
+            for (int i = 0; i < pointCount; i++) {
               final Point nextPoint = randomPointIn(pointZone);
               path.addPoint(nextPoint.getY() * DEGREES_TO_RADIANS, nextPoint.getX() * DEGREES_TO_RADIANS);
             }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/ArcDistance.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/ArcDistance.java
index 8649b5f..30d4a90 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/ArcDistance.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/ArcDistance.java
@@ -24,6 +24,7 @@ package org.apache.lucene.geo3d;
  */
 public class ArcDistance implements DistanceStyle {
   
+  /** An instance of the ArcDistance DistanceStyle. */
   public final static ArcDistance INSTANCE = new ArcDistance();
   
   @Override
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/BasePlanetObject.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/BasePlanetObject.java
index 13ca8da..5e2481b 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/BasePlanetObject.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/BasePlanetObject.java
@@ -25,8 +25,13 @@ package org.apache.lucene.geo3d;
  */
 public abstract class BasePlanetObject {
 
+  /** This is the planet model embedded in all objects derived from this
+   * class. */
   protected final PlanetModel planetModel;
   
+  /** Constructor creating class instance given a planet model.
+   * @param planetModel is the planet model.
+   */
   public BasePlanetObject(final PlanetModel planetModel) {
     this.planetModel = planetModel;
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/Bounds.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/Bounds.java
index d4303b0..ac931f1 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/Bounds.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/Bounds.java
@@ -31,11 +31,17 @@ package org.apache.lucene.geo3d;
  * @lucene.experimental
  */
 public class Bounds {
+
+  /** Set to true if no longitude bounds can be stated */
   protected boolean noLongitudeBound = false;
+  /** Set to true if no top latitude bound can be stated */
   protected boolean noTopLatitudeBound = false;
+  /** Set to true if no bottom latitude bound can be stated */
   protected boolean noBottomLatitudeBound = false;
 
+  /** If non-null, the minimum latitude bound */
   protected Double minLatitude = null;
+  /** If non-null, the maximum latitude bound */
   protected Double maxLatitude = null;
 
   // For longitude bounds, this class needs to worry about keeping track of the distinction
@@ -90,40 +96,69 @@ public class Bounds {
   // to the right.  We choose the direction with the least longitude difference.  (If we aren't sure,
   // and can recognize that, we can set "unconstrained in longitude".)
 
+  /** If non-null, the left longitude bound */
   protected Double leftLongitude = null;
+  /** If non-null, the right longitude bound */
   protected Double rightLongitude = null;
 
+  /** Construct an empty bounds object */
   public Bounds() {
   }
 
+  /** Get maximum latitude, if any.
+   *@return maximum latitude or null.
+   */
   public Double getMaxLatitude() {
     return maxLatitude;
   }
 
+  /** Get minimum latitude, if any.
+   *@return minimum latitude or null.
+   */
   public Double getMinLatitude() {
     return minLatitude;
   }
 
+  /** Get left longitude, if any.
+   *@return left longitude, or null.
+   */
   public Double getLeftLongitude() {
     return leftLongitude;
   }
 
+  /** Get right longitude, if any.
+   *@return right longitude, or null.
+   */
   public Double getRightLongitude() {
     return rightLongitude;
   }
 
+  /** Check if there's no longitude bound.
+   *@return true if no longitude bound.
+   */
   public boolean checkNoLongitudeBound() {
     return noLongitudeBound;
   }
 
+  /** Check if there's no top latitude bound.
+   *@return true if no top latitude bound.
+   */
   public boolean checkNoTopLatitudeBound() {
     return noTopLatitudeBound;
   }
 
+  /** Check if there's no bottom latitude bound.
+   *@return true if no bottom latitude bound.
+   */
   public boolean checkNoBottomLatitudeBound() {
     return noBottomLatitudeBound;
   }
 
+  /** Add a constraint representing a horizontal circle with a
+   * specified z value.
+   *@param z is the z value.
+   *@return the updated Bounds object.
+   */
   public Bounds addHorizontalCircle(double z) {
     if (!noTopLatitudeBound || !noBottomLatitudeBound) {
       // Compute a latitude value
@@ -133,6 +168,11 @@ public class Bounds {
     return this;
   }
 
+  /** Add a constraint representing a horizontal circle at
+   * a specific latitude.
+   *@param latitude is the latitude.
+   *@return the updated Bounds object.
+   */
   public Bounds addLatitudeZone(double latitude) {
     if (!noTopLatitudeBound || !noBottomLatitudeBound) {
       addLatitudeBound(latitude);
@@ -140,6 +180,11 @@ public class Bounds {
     return this;
   }
 
+  /** Add a constraint representing a longitude slice.
+   *@param newLeftLongitude is the left longitude value.
+   *@param newRightLongitude is the right longitude value.
+   *@return the updated Bounds object.
+   */
   public Bounds addLongitudeSlice(double newLeftLongitude, double newRightLongitude) {
     if (!noLongitudeBound) {
       addLongitudeBound(newLeftLongitude, newRightLongitude);
@@ -147,6 +192,9 @@ public class Bounds {
     return this;
   }
 
+  /** Update latitude bound.
+   *@param latitude is the latitude.
+   */
   protected void addLatitudeBound(double latitude) {
     if (!noTopLatitudeBound && (maxLatitude == null || latitude > maxLatitude))
       maxLatitude = latitude;
@@ -154,6 +202,10 @@ public class Bounds {
       minLatitude = latitude;
   }
 
+  /** Update longitude bound.
+   *@param newLeftLongitude is the left longitude.
+   *@param newRightLongitude is the right longitude.
+   */
   protected void addLongitudeBound(double newLeftLongitude, double newRightLongitude) {
     if (leftLongitude == null && rightLongitude == null) {
       leftLongitude = newLeftLongitude;
@@ -197,6 +249,9 @@ public class Bounds {
     }
   }
 
+  /** Update longitude bound.
+   *@param longitude is the new longitude value.
+   */
   protected void addLongitudeBound(double longitude) {
     // If this point is within the current bounds, we're done; otherwise
     // expand one side or the other.
@@ -254,10 +309,20 @@ public class Bounds {
     }
   }
 
+  /** Add a single point.
+   *@param v is the point vector.
+   *@return the updated Bounds object.
+   */
   public Bounds addPoint(final Vector v) {
     return addPoint(v.x, v.y, v.z);
   }
 
+  /** Add a single point.
+   *@param x is the point x.
+   *@param y is the point y.
+   *@param z is the point z.
+   *@return the updated Bounds object.
+   */
   public Bounds addPoint(final double x, final double y, final double z) {
     if (!noLongitudeBound) {
       // Get a longitude value
@@ -273,6 +338,11 @@ public class Bounds {
     return this;
   }
 
+  /** Add a single point.
+   *@param latitude is the point's latitude.
+   *@param longitude is the point's longitude.
+   *@return the updated Bounds object.
+   */
   public Bounds addPoint(double latitude, double longitude) {
     if (!noLongitudeBound) {
       // Get a longitude value
@@ -285,6 +355,9 @@ public class Bounds {
     return this;
   }
 
+  /** Signal that there is no longitude bound.
+   *@return the updated Bounds object.
+   */
   public Bounds noLongitudeBound() {
     noLongitudeBound = true;
     leftLongitude = null;
@@ -292,12 +365,18 @@ public class Bounds {
     return this;
   }
 
+  /** Signal that there is no top latitude bound.
+   *@return the updated Bounds object.
+   */
   public Bounds noTopLatitudeBound() {
     noTopLatitudeBound = true;
     maxLatitude = null;
     return this;
   }
 
+  /** Signal that there is no bottom latitude bound.
+   *@return the updated Bounds object.
+   */
   public Bounds noBottomLatitudeBound() {
     noBottomLatitudeBound = true;
     minLatitude = null;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/DistanceStyle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/DistanceStyle.java
index 330a393..a6e3836 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/DistanceStyle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/DistanceStyle.java
@@ -27,10 +27,15 @@ public interface DistanceStyle {
 
   // convenient access to built-in styles:
 
+  /** Arc distance calculator */
   public static final ArcDistance ARC = ArcDistance.INSTANCE;
+  /** Linear distance calculator */
   public static final LinearDistance LINEAR = LinearDistance.INSTANCE;
+  /** Linear distance squared calculator */
   public static final LinearSquaredDistance LINEAR_SQUARED = LinearSquaredDistance.INSTANCE;
+  /** Normal distance calculator */
   public static final NormalDistance NORMAL = NormalDistance.INSTANCE;
+  /** Normal distance squared calculator */
   public static final NormalSquaredDistance NORMAL_SQUARED = NormalSquaredDistance.INSTANCE;
 
   /** Compute the distance from a point to another point.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoArea.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoArea.java
index 566ece4..fb7b5b7 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoArea.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoArea.java
@@ -31,9 +31,15 @@ public interface GeoArea extends Membership {
   // This will, of course, rely heavily on methods provided by
   // the underlying GeoShape class.
 
+  // Relationship values for "getRelationship()"
+  
+  /** The referenced shape CONTAINS this shape */
   public static final int CONTAINS = 0;
+  /** The referenced shape IS WITHIN this shape */
   public static final int WITHIN = 1;
+  /** The referenced shape OVERLAPS this shape */
   public static final int OVERLAPS = 2;
+  /** The referenced shape has no relation to this shape */
   public static final int DISJOINT = 3;
 
   /**
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseBBox.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseBBox.java
index b2a133e..205aaeb 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseBBox.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseBBox.java
@@ -25,14 +25,27 @@ package org.apache.lucene.geo3d;
  */
 public abstract class GeoBaseBBox extends GeoBaseMembershipShape implements GeoBBox {
 
+  /** Construct, given planet model.
+   *@param planetModel is the planet model.
+   */
   public GeoBaseBBox(final PlanetModel planetModel) {
     super(planetModel);
   }
 
+  // Signals for relationship of edge points to shape
+  
+  /** All edgepoints inside shape */
   protected final static int ALL_INSIDE = 0;
+  /** Some edgepoints inside shape */
   protected final static int SOME_INSIDE = 1;
+  /** No edgepoints inside shape */
   protected final static int NONE_INSIDE = 2;
 
+  /** Determine the relationship between this BBox and the provided
+   * shape's edgepoints.
+   *@param path is the shape.
+   *@return the relationship.
+   */
   protected int isShapeInsideBBox(final GeoShape path) {
     final GeoPoint[] pathPoints = path.getEdgePoints();
     boolean foundOutside = false;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseDistanceShape.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseDistanceShape.java
index 7b0a3b7..b8760d1 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseDistanceShape.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseDistanceShape.java
@@ -25,6 +25,9 @@ package org.apache.lucene.geo3d;
  */
 public abstract class GeoBaseDistanceShape extends GeoBaseMembershipShape implements GeoDistanceShape {
 
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   */
   public GeoBaseDistanceShape(final PlanetModel planetModel) {
     super(planetModel);
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseMembershipShape.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseMembershipShape.java
index ba8536e..3868b8f 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseMembershipShape.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseMembershipShape.java
@@ -25,6 +25,9 @@ package org.apache.lucene.geo3d;
  */
 public abstract class GeoBaseMembershipShape extends GeoBaseShape implements GeoMembershipShape {
 
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   */
   public GeoBaseMembershipShape(final PlanetModel planetModel) {
     super(planetModel);
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseShape.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseShape.java
index e0a35d4..07a3d52 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseShape.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoBaseShape.java
@@ -24,6 +24,9 @@ package org.apache.lucene.geo3d;
  */
 public abstract class GeoBaseShape extends BasePlanetObject implements GeoShape {
 
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   */
   public GeoBaseShape(final PlanetModel planetModel) {
     super(planetModel);
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
index 0b914af..cba0cbe 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCircle.java
@@ -23,12 +23,23 @@ package org.apache.lucene.geo3d;
  * @lucene.experimental
  */
 public class GeoCircle extends GeoBaseDistanceShape implements GeoSizeable {
-  public final GeoPoint center;
-  public final double cutoffAngle;
-  public final SidedPlane circlePlane;
-  public final GeoPoint[] edgePoints;
-  public static final GeoPoint[] circlePoints = new GeoPoint[0];
+  /** Center of circle */
+  protected final GeoPoint center;
+  /** Cutoff angle of circle (not quite the same thing as radius) */
+  protected final double cutoffAngle;
+  /** The plane describing the circle (really an ellipse on a non-spherical world) */
+  protected final SidedPlane circlePlane;
+  /** A point that is on the world and on the circle plane */
+  protected final GeoPoint[] edgePoints;
+  /** Notable points for a circle -- there aren't any */
+  protected static final GeoPoint[] circlePoints = new GeoPoint[0];
 
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param lat is the center latitude.
+   *@param lon is the center longitude.
+   *@param cutoffAngle is the cutoff angle for the circle.
+   */
   public GeoCircle(final PlanetModel planetModel, final double lat, final double lon, final double cutoffAngle) {
     super(planetModel);
     if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositeMembershipShape.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositeMembershipShape.java
index bf5c58d..f1fe114 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositeMembershipShape.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoCompositeMembershipShape.java
@@ -26,13 +26,17 @@ import java.util.List;
  * @lucene.experimental
  */
 public class GeoCompositeMembershipShape implements GeoMembershipShape {
+  /** The list of shapes. */
   protected final List<GeoMembershipShape> shapes = new ArrayList<GeoMembershipShape>();
 
+  /** Constructor.
+   */
   public GeoCompositeMembershipShape() {
   }
 
   /**
    * Add a shape to the composite.
+   *@param shape is the shape to add.
    */
   public void addShape(final GeoMembershipShape shape) {
     shapes.add(shape);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
index d69ff32..a3579d3 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoConvexPolygon.java
@@ -30,21 +30,27 @@ import java.util.List;
  * @lucene.experimental
  */
 public class GeoConvexPolygon extends GeoBaseMembershipShape {
+  /** The list of polygon points */
   protected final List<GeoPoint> points;
+  /** A bitset describing, for each edge, whether it is internal or not */
   protected final BitSet isInternalEdges;
 
+  /** A list of edges */
   protected SidedPlane[] edges = null;
+  /** The set of notable points for each edge */
   protected GeoPoint[][] notableEdgePoints = null;
-
+  /** A point which is on the boundary of the polygon */
   protected GeoPoint[] edgePoints = null;
-
+  /** Tracking the maximum distance we go at any one time, so to be sure it's legal */
   protected double fullDistance = 0.0;
-
+  /** Set to true when the polygon is complete */
   protected boolean isDone = false;
   
   /**
    * Create a convex polygon from a list of points.  The first point must be on the
    * external edge.
+   *@param planetModel is the planet model.
+   *@param pointList is the list of points to create the polygon from.
    */
   public GeoConvexPolygon(final PlanetModel planetModel, final List<GeoPoint> pointList) {
     super(planetModel);
@@ -56,6 +62,10 @@ public class GeoConvexPolygon extends GeoBaseMembershipShape {
   /**
    * Create a convex polygon from a list of points, keeping track of which boundaries
    * are internal.  This is used when creating a polygon as a building block for another shape.
+   *@param planetModel is the planet model.
+   *@param pointList is the set of points to create the polygon from.
+   *@param internalEdgeFlags is a bitset describing whether each edge is internal or not.
+   *@param returnEdgeInternal is true when the final return edge is an internal one.
    */
   public GeoConvexPolygon(final PlanetModel planetModel, final List<GeoPoint> pointList, final BitSet internalEdgeFlags,
                           final boolean returnEdgeInternal) {
@@ -68,6 +78,9 @@ public class GeoConvexPolygon extends GeoBaseMembershipShape {
   /**
    * Create a convex polygon, with a starting latitude and longitude.
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param startLatitude is the latitude of the first point.
+   *@param startLongitude is the longitude of the first point.
    */
   public GeoConvexPolygon(final PlanetModel planetModel, final double startLatitude, final double startLongitude) {
     super(planetModel);
@@ -95,6 +108,7 @@ public class GeoConvexPolygon extends GeoBaseMembershipShape {
 
   /**
    * Finish the polygon, by connecting the last added point with the starting point.
+   *@param isInternalReturnEdge is true if the return edge (back to start) is an internal one.
    */
   public void done(final boolean isInternalReturnEdge) {
     if (isDone)
@@ -128,6 +142,8 @@ public class GeoConvexPolygon extends GeoBaseMembershipShape {
     createCenterPoint();
   }
 
+  /** Compute a reasonable center point.
+   */
   protected void createCenterPoint() {
     // In order to naively confirm that the polygon is convex, I would need to
     // check every edge, and verify that every point (other than the edge endpoints)
@@ -145,6 +161,10 @@ public class GeoConvexPolygon extends GeoBaseMembershipShape {
     edgePoints = new GeoPoint[]{points.get(0)};
   }
 
+  /** Compute a legal point index from a possibly illegal one, that may have wrapped.
+   *@param index is the index.
+   *@return the normalized index.
+   */
   protected int legalIndex(int index) {
     while (index >= points.size())
       index -= points.size();
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateHorizontalLine.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateHorizontalLine.java
index fa03aa5..dc8f569 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateHorizontalLine.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateHorizontalLine.java
@@ -25,24 +25,39 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoDegenerateHorizontalLine extends GeoBaseBBox {
-  public final double latitude;
-  public final double leftLon;
-  public final double rightLon;
-
-  public final GeoPoint LHC;
-  public final GeoPoint RHC;
-
-  public final Plane plane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
-
-  public final GeoPoint[] planePoints;
-
-  public final GeoPoint centerPoint;
-  public final GeoPoint[] edgePoints;
+  /** Latitude of horizontal line */
+  protected final double latitude;
+  /** Left bounding longitude of line */
+  protected final double leftLon;
+  /** Right bounding longitude of line */
+  protected final double rightLon;
+
+  /** Left hand endpoint of line */
+  protected final GeoPoint LHC;
+  /** Right hand endpoint of line */
+  protected final GeoPoint RHC;
+
+  /** The plane describing the line */
+  protected final Plane plane;
+  /** The left side end plane */
+  protected final SidedPlane leftPlane;
+  /** The right side end plane */
+  protected final SidedPlane rightPlane;
+
+  /** Notable points for the line */
+  protected final GeoPoint[] planePoints;
+
+  /** Center of line */
+  protected final GeoPoint centerPoint;
+  /** A point that's on the line */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param latitude is the latitude of the line.
+   *@param leftLon is the left end longitude.
+   *@param rightLon is the right end longitude.
    */
   public GeoDegenerateHorizontalLine(final PlanetModel planetModel, final double latitude, final double leftLon, double rightLon) {
     super(planetModel);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLatitudeZone.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLatitudeZone.java
index 539b9ac..c46a0f4 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLatitudeZone.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLatitudeZone.java
@@ -24,14 +24,23 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoDegenerateLatitudeZone extends GeoBaseBBox {
-  public final double latitude;
-
-  public final double sinLatitude;
-  public final Plane plane;
-  public final GeoPoint interiorPoint;
-  public final GeoPoint[] edgePoints;
-  public final static GeoPoint[] planePoints = new GeoPoint[0];
-
+  /** The latitude */
+  protected final double latitude;
+  /** Sine of the latitude */
+  protected final double sinLatitude;
+  /** Plane describing the latitude zone */
+  protected final Plane plane;
+  /** A point on the world that's also on the zone */
+  protected final GeoPoint interiorPoint;
+  /** An array consisting of the interiorPoint */
+  protected final GeoPoint[] edgePoints;
+  /** No notable points */
+  protected final static GeoPoint[] planePoints = new GeoPoint[0];
+
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   *@param latitude is the latitude of the latitude zone.
+   */
   public GeoDegenerateLatitudeZone(final PlanetModel planetModel, final double latitude) {
     super(planetModel);
     this.latitude = latitude;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLongitudeSlice.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLongitudeSlice.java
index 8f72659..8e71bbc 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLongitudeSlice.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateLongitudeSlice.java
@@ -23,16 +23,19 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoDegenerateLongitudeSlice extends GeoBaseBBox {
-  public final double longitude;
-
-  public final double sinLongitude;
-  public final double cosLongitude;
-  public final SidedPlane boundingPlane;
-  public final Plane plane;
-  public final GeoPoint interiorPoint;
-  public final GeoPoint[] edgePoints;
-
-  public final GeoPoint[] planePoints;
+  /** The longitude of the slice */
+  protected final double longitude;
+
+  /** The bounding plane for the slice (through both poles, perpendicular to the slice) */
+  protected final SidedPlane boundingPlane;
+  /** The plane of the slice */
+  protected final Plane plane;
+  /** A point on the slice */
+  protected final GeoPoint interiorPoint;
+  /** An array consisting of the one point chosen on the slice */
+  protected final GeoPoint[] edgePoints;
+  /** Notable points for the slice (north and south poles) */
+  protected final GeoPoint[] planePoints;
 
   /**
    * Accepts only values in the following ranges: lon: {@code -PI -> PI}
@@ -44,8 +47,8 @@ public class GeoDegenerateLongitudeSlice extends GeoBaseBBox {
       throw new IllegalArgumentException("Longitude out of range");
     this.longitude = longitude;
 
-    this.sinLongitude = Math.sin(longitude);
-    this.cosLongitude = Math.cos(longitude);
+    final double sinLongitude = Math.sin(longitude);
+    final double cosLongitude = Math.cos(longitude);
 
     this.plane = new Plane(cosLongitude, sinLongitude);
     // We need a bounding plane too, which is perpendicular to the longitude plane and sided so that the point (0.0, longitude) is inside.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegeneratePoint.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegeneratePoint.java
index 528ff89..0be9cec 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegeneratePoint.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegeneratePoint.java
@@ -24,11 +24,20 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoDegeneratePoint extends GeoPoint implements GeoBBox {
-  public final double latitude;
-  public final double longitude;
-  public final PlanetModel planetModel;
-  public final GeoPoint[] edgePoints;
-
+  /** The latitude of the point */
+  protected final double latitude;
+  /** The longitude of the point */
+  protected final double longitude;
+  /** Current planet model, since we don't extend BasePlanetObject */
+  protected final PlanetModel planetModel;
+  /** Edge point is an area containing just this */
+  protected final GeoPoint[] edgePoints;
+
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   *@param lat is the latitude.
+   *@param lon is the longitude.
+   */
   public GeoDegeneratePoint(final PlanetModel planetModel, final double lat, final double lon) {
     super(planetModel, lat, lon);
     this.planetModel = planetModel;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateVerticalLine.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateVerticalLine.java
index 11f7182..970d4be 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateVerticalLine.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoDegenerateVerticalLine.java
@@ -23,22 +23,32 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoDegenerateVerticalLine extends GeoBaseBBox {
-  public final double topLat;
-  public final double bottomLat;
-  public final double longitude;
-
-  public final GeoPoint UHC;
-  public final GeoPoint LHC;
-
-  public final SidedPlane topPlane;
-  public final SidedPlane bottomPlane;
-  public final SidedPlane boundingPlane;
-  public final Plane plane;
-
-  public final GeoPoint[] planePoints;
-
-  public final GeoPoint centerPoint;
-  public final GeoPoint[] edgePoints;
+  /** Top latitude of the vertical line */
+  protected final double topLat;
+  /** Bottom latitude of the vertical line */
+  protected final double bottomLat;
+  /** Longitude of the vertical line */
+  protected final double longitude;
+
+  /** Point at the upper end of the vertical line */
+  protected final GeoPoint UHC;
+  /** Point at the lower end of the vertical line */
+  protected final GeoPoint LHC;
+
+  /** Top end cutoff plane */
+  protected final SidedPlane topPlane;
+  /** Bottom end cutoff plane */
+  protected final SidedPlane bottomPlane;
+  /** Back-side cutoff plane */
+  protected final SidedPlane boundingPlane;
+  /** The vertical line plane */
+  protected final Plane plane;
+  /** Notable points for the line (end points) */
+  protected final GeoPoint[] planePoints;
+  /** A computed center point for the line */
+  protected final GeoPoint centerPoint;
+  /** A point that's on the line */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, longitude: {@code -PI -> PI}
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLatitudeZone.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLatitudeZone.java
index 83ee559..b20f741 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLatitudeZone.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLatitudeZone.java
@@ -23,23 +23,38 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoLatitudeZone extends GeoBaseBBox {
-  public final double topLat;
-  public final double bottomLat;
-  public final double cosTopLat;
-  public final double cosBottomLat;
-  public final SidedPlane topPlane;
-  public final SidedPlane bottomPlane;
-  public final GeoPoint interiorPoint;
-  public final static GeoPoint[] planePoints = new GeoPoint[0];
+  /** The top latitude of the zone */
+  protected final double topLat;
+  /** The bottom latitude of the zone */
+  protected final double bottomLat;
+  /** Cosine of the top lat */
+  protected final double cosTopLat;
+  /** Cosine of the bottom lat */
+  protected final double cosBottomLat;
+  /** The top plane */
+  protected final SidedPlane topPlane;
+  /** The bottom plane */
+  protected final SidedPlane bottomPlane;
+  /** An interior point */
+  protected final GeoPoint interiorPoint;
+  /** Notable points (none) */
+  protected final static GeoPoint[] planePoints = new GeoPoint[0];
 
   // We need two additional points because a latitude zone's boundaries don't intersect.  This is a very
   // special case that most GeoBBox's do not have.
-  public final GeoPoint topBoundaryPoint;
-  public final GeoPoint bottomBoundaryPoint;
-
-  // Edge points
-  public final GeoPoint[] edgePoints;
-
+  
+  /** Top boundary point */
+  protected final GeoPoint topBoundaryPoint;
+  /** Bottom boundary point */
+  protected final GeoPoint bottomBoundaryPoint;
+  /** A point on each distinct edge */
+  protected final GeoPoint[] edgePoints;
+
+  /** Constructor.
+   *@param planetModel is the planet model to use.
+   *@param topLat is the top latitude.
+   *@param bottomLat is the bottom latitude.
+   */
   public GeoLatitudeZone(final PlanetModel planetModel, final double topLat, final double bottomLat) {
     super(planetModel);
     this.topLat = topLat;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLongitudeSlice.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLongitudeSlice.java
index cff754c..ff9d371 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLongitudeSlice.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoLongitudeSlice.java
@@ -25,20 +25,26 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoLongitudeSlice extends GeoBaseBBox {
-  public final double leftLon;
-  public final double rightLon;
-
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
-
-  public final GeoPoint[] planePoints;
-
-  public final GeoPoint centerPoint;
-
-  public final GeoPoint[] edgePoints;
+  /** The left longitude of the slice */
+  protected final double leftLon;
+  /** The right longitude of the slice */
+  protected final double rightLon;
+  /** The left plane of the slice */
+  protected final SidedPlane leftPlane;
+  /** The right plane of the slice */
+  protected final SidedPlane rightPlane;
+  /** The notable points for the slice (north and south poles) */
+  protected final GeoPoint[] planePoints;
+  /** The center point of the slice */
+  protected final GeoPoint centerPoint;
+  /** A point on the edge of the slice */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param leftLon is the left longitude of the slice.
+   *@param rightLon is the right longitude of the slice.
    */
   public GeoLongitudeSlice(final PlanetModel planetModel, final double leftLon, double rightLon) {
     super(planetModel);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthLatitudeZone.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthLatitudeZone.java
index 2cb576e..0e7083e 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthLatitudeZone.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthLatitudeZone.java
@@ -23,17 +23,25 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoNorthLatitudeZone extends GeoBaseBBox {
-  public final double bottomLat;
-  public final double cosBottomLat;
-  public final SidedPlane bottomPlane;
-  public final GeoPoint interiorPoint;
-  public final static GeoPoint[] planePoints = new GeoPoint[0];
-
-  public final GeoPoint bottomBoundaryPoint;
-
-  // Edge points
-  public final GeoPoint[] edgePoints;
-
+  /** The bottom latitude of the zone */
+  protected final double bottomLat;
+  /** Cosine of the bottom latitude of the zone */
+  protected final double cosBottomLat;
+  /** The bottom plane of the zone */
+  protected final SidedPlane bottomPlane;
+  /** An interior point of the zone */
+  protected final GeoPoint interiorPoint;
+  /** Notable points: none */
+  protected final static GeoPoint[] planePoints = new GeoPoint[0];
+  /** A point on the bottom boundary */
+  protected final GeoPoint bottomBoundaryPoint;
+  /** A reference to the point on the boundary */
+  protected final GeoPoint[] edgePoints;
+
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param bottomLat is the bottom latitude.
+   */
   public GeoNorthLatitudeZone(final PlanetModel planetModel, final double bottomLat) {
     super(planetModel);
     this.bottomLat = bottomLat;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthRectangle.java
index fcb764c..c10a1d7 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoNorthRectangle.java
@@ -26,29 +26,41 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoNorthRectangle extends GeoBaseBBox {
-  public final double bottomLat;
-  public final double leftLon;
-  public final double rightLon;
-
-  public final double cosMiddleLat;
-
-  public final GeoPoint LRHC;
-  public final GeoPoint LLHC;
-
-  public final SidedPlane bottomPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
-
-  public final GeoPoint[] bottomPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
-
-  public final GeoPoint centerPoint;
-
-  public final GeoPoint[] edgePoints;
+  /** The bottom latitude of the rectangle */
+  protected final double bottomLat;
+  /** The left longitude */
+  protected final double leftLon;
+  /** The right longitude */
+  protected final double rightLon;
+  /** Cosine of the middle latitude */
+  protected final double cosMiddleLat;
+  /** Lower right hand corner point */
+  protected final GeoPoint LRHC;
+  /** Lower left hand corner point */
+  protected final GeoPoint LLHC;
+  /** Bottom edge plane */
+  protected final SidedPlane bottomPlane;
+  /** Left-side plane */
+  protected final SidedPlane leftPlane;
+  /** Right-side plane */
+  protected final SidedPlane rightPlane;
+  /** Bottom plane notable points */
+  protected final GeoPoint[] bottomPlanePoints;
+  /** Left plane notable points */
+  protected final GeoPoint[] leftPlanePoints;
+  /** Right plane notable points */
+  protected final GeoPoint[] rightPlanePoints;
+  /** Center point */
+  protected final GeoPoint centerPoint;
+  /** A point on the edge */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param bottomLat is the bottom latitude.
+   *@param leftLon is the left longitude.
+   *@param rightLon is the right longitude.
    */
   public GeoNorthRectangle(final PlanetModel planetModel, final double bottomLat, final double leftLon, double rightLon) {
     super(planetModel);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath.java
index d9977ce..25c435a 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPath.java
@@ -32,27 +32,43 @@ import java.util.Map;
  * @lucene.experimental
  */
 public class GeoPath extends GeoBaseDistanceShape {
-  
-  public final double cutoffAngle;
+  /** The cutoff angle (width) */
+  protected final double cutoffAngle;
 
-  public final double sinAngle; // sine of cutoffAngle
-  public final double cosAngle; // cosine of cutoffAngle
+  /** Sine of cutoff angle */
+  protected final double sinAngle;
+  /** Cosine of cutoff angle */
+  protected final double cosAngle;
 
-  public final List<GeoPoint> points = new ArrayList<GeoPoint>();
+  /** The original list of path points */
+  protected final List<GeoPoint> points = new ArrayList<GeoPoint>();
   
-  public List<SegmentEndpoint> endPoints;
-  public List<PathSegment> segments;
+  /** A list of SegmentEndpoints */
+  protected List<SegmentEndpoint> endPoints;
+  /** A list of PathSegments */
+  protected List<PathSegment> segments;
 
-  public GeoPoint[] edgePoints;
+  /** A point on the edge */
+  protected GeoPoint[] edgePoints;
 
-  public boolean isDone = false;
+  /** Set to true if path has been completely constructed */
+  protected boolean isDone = false;
   
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param maxCutoffAngle is the width of the path, measured as an angle.
+   *@param pathPoints are the points in the path.
+   */
   public GeoPath(final PlanetModel planetModel, final double maxCutoffAngle, final GeoPoint[] pathPoints) {
     this(planetModel, maxCutoffAngle);
     Collections.addAll(points, pathPoints);
     done();
   }
   
+  /** Piece-wise constructor.  Use in conjunction with addPoint() and done().
+   *@param planetModel is the planet model.
+   *@param maxCutoffAngle is the width of the path, measured as an angle.
+   */
   public GeoPath(final PlanetModel planetModel, final double maxCutoffAngle) {
     super(planetModel);
     if (maxCutoffAngle <= 0.0 || maxCutoffAngle > Math.PI * 0.5)
@@ -62,12 +78,18 @@ public class GeoPath extends GeoBaseDistanceShape {
     this.sinAngle = Math.sin(maxCutoffAngle);
   }
 
-  public void addPoint(double lat, double lon) {
+  /** Add a point to the path.
+   *@param lat is the latitude of the point.
+   *@param lon is the longitude of the point.
+   */
+  public void addPoint(final double lat, final double lon) {
     if (isDone)
       throw new IllegalStateException("Can't call addPoint() if done() already called");
     points.add(new GeoPoint(planetModel, lat, lon));
   }
   
+  /** Complete the path.
+   */
   public void done() {
     if (isDone)
       throw new IllegalStateException("Can't call done() twice");
@@ -307,11 +329,15 @@ public class GeoPath extends GeoBaseDistanceShape {
    *    cutoff plane/edge plane points.
    */
   public static class SegmentEndpoint {
+    /** The center point of the endpoint */
     public final GeoPoint point;
+    /** A plane describing the circle */
     public final SidedPlane circlePlane;
+    /** Pertinent cutoff planes from adjoining segments */
     public final Membership[] cutoffPlanes;
+    /** Notable points for this segment endpoint */
     public final GeoPoint[] notablePoints;
-
+    /** No notable points from the circle itself */
     public final static GeoPoint[] circlePoints = new GeoPoint[0];
 
     /** Base case.  Does nothing at all.
@@ -325,6 +351,9 @@ public class GeoPath extends GeoBaseDistanceShape {
     
     /** Constructor for case (1).
      * Generate a simple circle cutoff plane.
+     *@param point is the center point.
+     *@param upperPoint is a point that must be on the circle plane.
+     *@param lowerPoint is another point that must be on the circle plane.
      */
     public SegmentEndpoint(final GeoPoint point, final GeoPoint upperPoint, final GeoPoint lowerPoint) {
       this.point = point;
@@ -338,6 +367,10 @@ public class GeoPath extends GeoBaseDistanceShape {
     
     /** Constructor for case (2).
      * Generate an endpoint, given a single cutoff plane plus upper and lower edge points.
+     *@param point is the center point.
+     *@param cutoffPlane is the plane from the adjoining path segment marking the boundary between this endpoint and that segment.
+     *@param topEdgePoint is a point on the cutoffPlane that should be also on the circle plane.
+     *@param bottomEdgePoint is another point on the cutoffPlane that should be also on the circle plane.
      */
     public SegmentEndpoint(final GeoPoint point,
       final SidedPlane cutoffPlane, final GeoPoint topEdgePoint, final GeoPoint bottomEdgePoint) {
@@ -350,6 +383,11 @@ public class GeoPath extends GeoBaseDistanceShape {
 
     /** Constructor for case (2.5).
      * Generate an endpoint, given two cutoff planes plus upper and lower edge points.
+     *@param point is the center.
+     *@param cutoffPlane1 is one adjoining path segment cutoff plane.
+     *@param cutoffPlane2 is another adjoining path segment cutoff plane.
+     *@param topEdgePoint is a point on the cutoffPlane that should be also on the circle plane.
+     *@param bottomEdgePoint is another point on the cutoffPlane that should be also on the circle plane.
      */
     public SegmentEndpoint(final GeoPoint point,
       final SidedPlane cutoffPlane1, final SidedPlane cutoffPlane2, final GeoPoint topEdgePoint, final GeoPoint bottomEdgePoint) {
@@ -362,6 +400,17 @@ public class GeoPath extends GeoBaseDistanceShape {
     
     /** Constructor for case (3).
      * Generate an endpoint for an intersection, given four points.
+     *@param point is the center.
+     *@param prevCutoffPlane is the previous adjoining segment cutoff plane.
+     *@param nextCutoffPlane is the next path segment cutoff plane.
+     *@param notCand2Point is a point NOT on candidate2.
+     *@param notCand1Point is a point NOT on candidate1.
+     *@param notCand3Point is a point NOT on candidate3.
+     *@param notCand4Point is a point NOT on candidate4.
+     *@param candidate1 one of four candidate circle planes.
+     *@param candidate2 one of four candidate circle planes.
+     *@param candidate3 one of four candidate circle planes.
+     *@param candidate4 one of four candidate circle planes.
      */
     public SegmentEndpoint(final GeoPoint point,
       final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,
@@ -416,28 +465,59 @@ public class GeoPath extends GeoBaseDistanceShape {
       }
     }
 
+    /** Check if point is within this endpoint.
+     *@param point is the point.
+     *@return true of within.
+     */
     public boolean isWithin(final Vector point) {
       if (circlePlane == null)
         return false;
       return circlePlane.isWithin(point);
     }
 
+    /** Check if point is within this endpoint.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return true of within.
+     */
     public boolean isWithin(final double x, final double y, final double z) {
       if (circlePlane == null)
         return false;
       return circlePlane.isWithin(x, y, z);
     }
 
+    /** Compute interior path distance.
+     *@param distanceStyle is the distance style.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return the distance metric.
+     */
     public double pathDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
       if (!isWithin(x,y,z))
         return Double.MAX_VALUE;
       return distanceStyle.computeDistance(this.point, x, y, z);
     }
 
+    /** Compute external distance.
+     *@param distanceStyle is the distance style.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return the distance metric.
+     */
     public double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
       return distanceStyle.computeDistance(this.point, x, y, z);
     }
 
+    /** Determine if this endpoint intersects a specified plane.
+     *@param planetModel is the planet model.
+     *@param p is the plane.
+     *@param notablePoints are the points associated with the plane.
+     *@param bounds are any bounds which the intersection must lie within.
+     *@return true if there is a matching intersection.
+     */
     public boolean intersects(final PlanetModel planetModel, final Plane p, final GeoPoint[] notablePoints, final Membership[] bounds) {
       //System.err.println("  looking for intersection between plane "+p+" and circle "+circlePlane+" on proper side of "+cutoffPlanes+" within "+bounds);
       if (circlePlane == null)
@@ -445,6 +525,10 @@ public class GeoPath extends GeoBaseDistanceShape {
       return circlePlane.intersects(planetModel, p, notablePoints, this.notablePoints, bounds, this.cutoffPlanes);
     }
 
+    /** Get the bounds for a segment endpoint.
+     *@param planetModel is the planet model.
+     *@param bounds are the bounds to be modified.
+     */
     public void getBounds(final PlanetModel planetModel, Bounds bounds) {
       bounds.addPoint(point);
       if (circlePlane == null)
@@ -475,31 +559,45 @@ public class GeoPath extends GeoBaseDistanceShape {
    * This is the pre-calculated data for a path segment.
    */
   public static class PathSegment {
+    /** Starting point of the segment */
     public final GeoPoint start;
+    /** End point of the segment */
     public final GeoPoint end;
+    /** Place to keep any complete segment distances we've calculated so far */
     public final Map<DistanceStyle,Double> fullDistanceCache = new HashMap<DistanceStyle,Double>();
+    /** Normalized plane connecting the two points and going through world center */
     public final Plane normalizedConnectingPlane;
+    /** Cutoff plane parallel to connecting plane representing one side of the path segment */
     public final SidedPlane upperConnectingPlane;
+    /** Cutoff plane parallel to connecting plane representing the other side of the path segment */
     public final SidedPlane lowerConnectingPlane;
+    /** Plane going through the center and start point, marking the start edge of the segment */
     public final SidedPlane startCutoffPlane;
+    /** Plane going through the center and end point, marking the end edge of the segment */
     public final SidedPlane endCutoffPlane;
+    /** Upper right hand corner of segment */
     public final GeoPoint URHC;
+    /** Lower right hand corner of segment */
     public final GeoPoint LRHC;
+    /** Upper left hand corner of segment */
     public final GeoPoint ULHC;
+    /** Lower left hand corner of segment */
     public final GeoPoint LLHC;
+    /** Notable points for the upper connecting plane */
     public final GeoPoint[] upperConnectingPlanePoints;
+    /** Notable points for the lower connecting plane */
     public final GeoPoint[] lowerConnectingPlanePoints;
+    /** Notable points for the start cutoff plane */
     public final GeoPoint[] startCutoffPlanePoints;
+    /** Notable points for the end cutoff plane */
     public final GeoPoint[] endCutoffPlanePoints;
-    public final double planeBoundingOffset;
 
     public PathSegment(final PlanetModel planetModel, final GeoPoint start, final GeoPoint end,
       final Plane normalizedConnectingPlane, final double planeBoundingOffset) {
       this.start = start;
       this.end = end;
       this.normalizedConnectingPlane = normalizedConnectingPlane;
-      this.planeBoundingOffset = planeBoundingOffset;
-
+        
       // Either start or end should be on the correct side
       upperConnectingPlane = new SidedPlane(start, normalizedConnectingPlane, -planeBoundingOffset);
       lowerConnectingPlane = new SidedPlane(start, normalizedConnectingPlane, planeBoundingOffset);
@@ -537,6 +635,10 @@ public class GeoPath extends GeoBaseDistanceShape {
       endCutoffPlanePoints = new GeoPoint[]{URHC, LRHC};
     }
 
+    /** Compute the full distance along this path segment.
+     *@param distanceStyle is the distance style.
+     *@return the distance metric.
+     */
     public double fullPathDistance(final DistanceStyle distanceStyle) {
       synchronized (fullDistanceCache) {
         Double dist = fullDistanceCache.get(distanceStyle);
@@ -547,20 +649,24 @@ public class GeoPath extends GeoBaseDistanceShape {
         return dist.doubleValue();
       }
     }
-    
+  
+    /** Check if point is within this segment.
+     *@param point is the point.
+     *@return true of within.
+     */
     public boolean isWithin(final Vector point) {
-      //System.err.println(" assessing whether point "+point+" is within path segment "+this);
-      //System.err.println("  within "+startCutoffPlane+": "+startCutoffPlane.isWithin(point));
-      //System.err.println("  within "+endCutoffPlane+": "+endCutoffPlane.isWithin(point));
-      //System.err.println("  within "+upperConnectingPlane+": "+upperConnectingPlane.isWithin(point));
-      //System.err.println("  within "+lowerConnectingPlane+": "+lowerConnectingPlane.isWithin(point));
-
       return startCutoffPlane.isWithin(point) &&
           endCutoffPlane.isWithin(point) &&
           upperConnectingPlane.isWithin(point) &&
           lowerConnectingPlane.isWithin(point);
     }
 
+    /** Check if point is within this segment.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return true of within.
+     */
     public boolean isWithin(final double x, final double y, final double z) {
       return startCutoffPlane.isWithin(x, y, z) &&
           endCutoffPlane.isWithin(x, y, z) &&
@@ -568,6 +674,14 @@ public class GeoPath extends GeoBaseDistanceShape {
           lowerConnectingPlane.isWithin(x, y, z);
     }
 
+    /** Compute interior path distance.
+     *@param planetModel is the planet model.
+     *@param distanceStyle is the distance style.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return the distance metric.
+     */
     public double pathDistance(final PlanetModel planetModel, final DistanceStyle distanceStyle, final double x, final double y, final double z) {
       if (!isWithin(x,y,z))
         return Double.MAX_VALUE;
@@ -604,6 +718,14 @@ public class GeoPath extends GeoBaseDistanceShape {
       return distanceStyle.computeDistance(thePoint, x, y, z) + distanceStyle.computeDistance(start, thePoint.x, thePoint.y, thePoint.z);
     }
 
+    /** Compute external distance.
+     *@param planetModel is the planet model.
+     *@param distanceStyle is the distance style.
+     *@param x is the point x.
+     *@param y is the point y.
+     *@param z is the point z.
+     *@return the distance metric.
+     */
     public double outsideDistance(final PlanetModel planetModel, final DistanceStyle distanceStyle, final double x, final double y, final double z) {
       final double upperDistance = distanceStyle.computeDistance(planetModel, upperConnectingPlane, x,y,z, lowerConnectingPlane, startCutoffPlane, endCutoffPlane);
       final double lowerDistance = distanceStyle.computeDistance(planetModel, lowerConnectingPlane, x,y,z, upperConnectingPlane, startCutoffPlane, endCutoffPlane);
@@ -622,11 +744,22 @@ public class GeoPath extends GeoBaseDistanceShape {
           Math.min(LLHCDistance, LRHCDistance)));
     }
 
+    /** Determine if this endpoint intersects a specified plane.
+     *@param planetModel is the planet model.
+     *@param p is the plane.
+     *@param notablePoints are the points associated with the plane.
+     *@param bounds are any bounds which the intersection must lie within.
+     *@return true if there is a matching intersection.
+     */
     public boolean intersects(final PlanetModel planetModel, final Plane p, final GeoPoint[] notablePoints, final Membership[] bounds) {
       return upperConnectingPlane.intersects(planetModel, p, notablePoints, upperConnectingPlanePoints, bounds, lowerConnectingPlane, startCutoffPlane, endCutoffPlane) ||
           lowerConnectingPlane.intersects(planetModel, p, notablePoints, lowerConnectingPlanePoints, bounds, upperConnectingPlane, startCutoffPlane, endCutoffPlane);
     }
 
+    /** Get the bounds for a segment endpoint.
+     *@param planetModel is the planet model.
+     *@param bounds are the bounds to be modified.
+     */
     public void getBounds(final PlanetModel planetModel, Bounds bounds) {
       // We need to do all bounding planes as well as corner points
       bounds.addPoint(start).addPoint(end);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
index 2e6f49f..d3ff22d 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoPolygonFactory.java
@@ -47,6 +47,14 @@ public class GeoPolygonFactory {
         false);
   }
 
+  /** Build a GeoMembershipShape given points, starting edge, and whether starting edge is internal or not.
+   * @param pointsList        is a list of the GeoPoints to build an arbitrary polygon out of.
+   * @param startPointIndex is one of the points constituting the starting edge.
+   * @param endPointIndex is another of the points constituting the starting edge.
+   * @param startingEdge is the plane describing the starting edge.
+   * @param isInternalEdge is true if the specified edge is an internal one.
+   * @return a GeoMembershipShape corresponding to what was specified.
+   */
   public static GeoMembershipShape buildPolygonShape(final PlanetModel planetModel, final List<GeoPoint> pointsList, final int startPointIndex, final int endPointIndex, final SidedPlane startingEdge, final boolean isInternalEdge) {
     // Algorithm as follows:
     // Start with sided edge.  Go through all points in some order.  For each new point, determine if the point is within all edges considered so far.
@@ -149,7 +157,12 @@ public class GeoPolygonFactory {
     return rval;
   }
 
-  protected static boolean isWithin(GeoPoint newPoint, List<SidedPlane> currentPlanes) {
+  /** Check if a point is within a described list of planes.
+   *@param newPoint is the point. 
+   *@param currentPlanes is the list of planes.
+   *@return true if within.
+   */
+  protected static boolean isWithin(final GeoPoint newPoint, final List<SidedPlane> currentPlanes) {
     for (SidedPlane p : currentPlanes) {
       if (!p.isWithin(newPoint))
         return false;
@@ -157,6 +170,11 @@ public class GeoPolygonFactory {
     return true;
   }
 
+  /** Convert raw point index into valid array position.
+   *@param index is the array index.
+   *@param size is the array size.
+   *@return an updated index.
+   */
   protected static int getLegalIndex(int index, int size) {
     while (index < 0) {
       index += size;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoRectangle.java
index 4beb8e8..545ee61 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoRectangle.java
@@ -25,34 +25,57 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoRectangle extends GeoBaseBBox {
-  public final double topLat;
-  public final double bottomLat;
-  public final double leftLon;
-  public final double rightLon;
-
-  public final double cosMiddleLat;
-
-  public final GeoPoint ULHC;
-  public final GeoPoint URHC;
-  public final GeoPoint LRHC;
-  public final GeoPoint LLHC;
-
-  public final SidedPlane topPlane;
-  public final SidedPlane bottomPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
-
-  public final GeoPoint[] topPlanePoints;
-  public final GeoPoint[] bottomPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
-
-  public final GeoPoint centerPoint;
-
-  public final GeoPoint[] edgePoints;
+  /** The top latitude of the rect */
+  protected final double topLat;
+  /** The bottom latitude of the rect */
+  protected final double bottomLat;
+  /** The left longitude of the rect */
+  protected final double leftLon;
+  /** The right longitude of the rect */
+  protected final double rightLon;
+  /** The cosine of a middle latitude */
+  protected final double cosMiddleLat;
+
+  /** The upper left hand corner point */
+  protected final GeoPoint ULHC;
+  /** The upper right hand corner point */
+  protected final GeoPoint URHC;
+  /** The lower right hand corner point */
+  protected final GeoPoint LRHC;
+  /** The lower left hand corner point */
+  protected final GeoPoint LLHC;
+
+  /** The top plane */
+  protected final SidedPlane topPlane;
+  /** The bottom plane */
+  protected final SidedPlane bottomPlane;
+  /** The left plane */
+  protected final SidedPlane leftPlane;
+  /** The right plane */
+  protected final SidedPlane rightPlane;
+
+  /** Notable points for the top plane */
+  protected final GeoPoint[] topPlanePoints;
+  /** Notable points for the bottom plane */
+  protected final GeoPoint[] bottomPlanePoints;
+  /** Notable points for the left plane */
+  protected final GeoPoint[] leftPlanePoints;
+  /** Notable points for the right plane */
+  protected final GeoPoint[] rightPlanePoints;
+
+  /** Center point */
+  protected final GeoPoint centerPoint;
+
+  /** Edge point for this rectangle */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param topLat is the top latitude.
+   *@param bottomLat is the bottom latitude.
+   *@param leftLon is the left longitude.
+   *@param rightLon is the right longitude.
    */
   public GeoRectangle(final PlanetModel planetModel, final double topLat, final double bottomLat, final double leftLon, double rightLon) {
     super(planetModel);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthLatitudeZone.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthLatitudeZone.java
index 5248d24..7c5c517 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthLatitudeZone.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthLatitudeZone.java
@@ -23,17 +23,25 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoSouthLatitudeZone extends GeoBaseBBox {
-  public final double topLat;
-  public final double cosTopLat;
-  public final SidedPlane topPlane;
-  public final GeoPoint interiorPoint;
-  public final static GeoPoint[] planePoints = new GeoPoint[0];
-
-  public final GeoPoint topBoundaryPoint;
-
-  // Edge points
-  public final GeoPoint[] edgePoints;
-
+  /** The top latitude of the zone */
+  protected final double topLat;
+  /** The cosine of the top latitude of the zone */
+  protected final double cosTopLat;
+  /** The top plane of the zone */
+  protected final SidedPlane topPlane;
+  /** An interior point of the zone */
+  protected final GeoPoint interiorPoint;
+  /** Notable points for the plane (none) */
+  protected final static GeoPoint[] planePoints = new GeoPoint[0];
+  /** A point on the top boundary */
+  protected final GeoPoint topBoundaryPoint;
+  /** Edge points; a reference to the topBoundaryPoint */
+  protected final GeoPoint[] edgePoints;
+
+  /** Constructor.
+   *@param planetModel is the planet model.
+   *@param topLat is the top latitude of the zone.
+   */
   public GeoSouthLatitudeZone(final PlanetModel planetModel, final double topLat) {
     super(planetModel);
     this.topLat = topLat;
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthRectangle.java
index 39cd47c..1ddcf88 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoSouthRectangle.java
@@ -26,29 +26,45 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoSouthRectangle extends GeoBaseBBox {
-  public final double topLat;
-  public final double leftLon;
-  public final double rightLon;
-
-  public final double cosMiddleLat;
-
-  public final GeoPoint ULHC;
-  public final GeoPoint URHC;
-
-  public final SidedPlane topPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
-
-  public final GeoPoint[] topPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
-
-  public final GeoPoint centerPoint;
-
-  public final GeoPoint[] edgePoints;
+  /** The top latitude of the rect */
+  protected final double topLat;
+  /** The left longitude of the rect */
+  protected final double leftLon;
+  /** The right longitude of the rect */
+  protected final double rightLon;
+  /** The cosine of a middle latitude */
+  protected final double cosMiddleLat;
+  /** The upper left hand corner of the rectangle */
+  protected final GeoPoint ULHC;
+  /** The upper right hand corner of the rectangle */
+  protected final GeoPoint URHC;
+
+  /** The top plane */
+  protected final SidedPlane topPlane;
+  /** The left plane */
+  protected final SidedPlane leftPlane;
+  /** The right plane */
+  protected final SidedPlane rightPlane;
+
+  /** Notable points for the top plane */
+  protected final GeoPoint[] topPlanePoints;
+  /** Notable points for the left plane */
+  protected final GeoPoint[] leftPlanePoints;
+  /** Notable points for the right plane */
+  protected final GeoPoint[] rightPlanePoints;
+
+  /** The center point */
+  protected final GeoPoint centerPoint;
+
+  /** A point on the edge */
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}
+   *@param planetModel is the planet model.
+   *@param topLat is the top latitude.
+   *@param leftLon is the left longitude.
+   *@param rightLon is the right longitude.
    */
   public GeoSouthRectangle(final PlanetModel planetModel, final double topLat, final double leftLon, double rightLon) {
     super(planetModel);
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideDegenerateHorizontalLine.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideDegenerateHorizontalLine.java
index d697117..6f0dded 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideDegenerateHorizontalLine.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideDegenerateHorizontalLine.java
@@ -23,24 +23,24 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoWideDegenerateHorizontalLine extends GeoBaseBBox {
-  public final double latitude;
-  public final double leftLon;
-  public final double rightLon;
+  protected final double latitude;
+  protected final double leftLon;
+  protected final double rightLon;
 
-  public final GeoPoint LHC;
-  public final GeoPoint RHC;
+  protected final GeoPoint LHC;
+  protected final GeoPoint RHC;
 
-  public final Plane plane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
+  protected final Plane plane;
+  protected final SidedPlane leftPlane;
+  protected final SidedPlane rightPlane;
 
-  public final GeoPoint[] planePoints;
+  protected final GeoPoint[] planePoints;
 
-  public final GeoPoint centerPoint;
+  protected final GeoPoint centerPoint;
 
-  public final EitherBound eitherBound;
+  protected final EitherBound eitherBound;
 
-  public final GeoPoint[] edgePoints;
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideLongitudeSlice.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideLongitudeSlice.java
index a7f98d2..55f44ef 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideLongitudeSlice.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideLongitudeSlice.java
@@ -24,17 +24,17 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoWideLongitudeSlice extends GeoBaseBBox {
-  public final double leftLon;
-  public final double rightLon;
+  protected final double leftLon;
+  protected final double rightLon;
 
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
+  protected final SidedPlane leftPlane;
+  protected final SidedPlane rightPlane;
 
-  public final GeoPoint[] planePoints;
+  protected final GeoPoint[] planePoints;
 
-  public final GeoPoint centerPoint;
+  protected final GeoPoint centerPoint;
 
-  public final GeoPoint[] edgePoints; 
+  protected final GeoPoint[] edgePoints; 
 
   /**
    * Accepts only values in the following ranges: lon: {@code -PI -> PI}.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideNorthRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideNorthRectangle.java
index 8596d72..df111a3 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideNorthRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideNorthRectangle.java
@@ -24,28 +24,28 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoWideNorthRectangle extends GeoBaseBBox {
-  public final double bottomLat;
-  public final double leftLon;
-  public final double rightLon;
+  protected final double bottomLat;
+  protected final double leftLon;
+  protected final double rightLon;
 
-  public final double cosMiddleLat;
+  protected final double cosMiddleLat;
 
-  public final GeoPoint LRHC;
-  public final GeoPoint LLHC;
+  protected final GeoPoint LRHC;
+  protected final GeoPoint LLHC;
 
-  public final SidedPlane bottomPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
+  protected final SidedPlane bottomPlane;
+  protected final SidedPlane leftPlane;
+  protected final SidedPlane rightPlane;
 
-  public final GeoPoint[] bottomPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
+  protected final GeoPoint[] bottomPlanePoints;
+  protected final GeoPoint[] leftPlanePoints;
+  protected final GeoPoint[] rightPlanePoints;
 
-  public final GeoPoint centerPoint;
+  protected final GeoPoint centerPoint;
 
-  public final EitherBound eitherBound;
+  protected final EitherBound eitherBound;
 
-  public final GeoPoint[] edgePoints;
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideRectangle.java
index 424d6cd..46bd4b8 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideRectangle.java
@@ -24,33 +24,33 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoWideRectangle extends GeoBaseBBox {
-  public final double topLat;
-  public final double bottomLat;
-  public final double leftLon;
-  public final double rightLon;
+  protected final double topLat;
+  protected final double bottomLat;
+  protected final double leftLon;
+  protected final double rightLon;
 
-  public final double cosMiddleLat;
+  protected final double cosMiddleLat;
 
-  public final GeoPoint ULHC;
-  public final GeoPoint URHC;
-  public final GeoPoint LRHC;
-  public final GeoPoint LLHC;
+  protected final GeoPoint ULHC;
+  protected final GeoPoint URHC;
+  protected final GeoPoint LRHC;
+  protected final GeoPoint LLHC;
 
-  public final SidedPlane topPlane;
-  public final SidedPlane bottomPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
+  protected final SidedPlane topPlane;
+  protected final SidedPlane bottomPlane;
+  protected final SidedPlane leftPlane;
+  protected final SidedPlane rightPlane;
 
-  public final GeoPoint[] topPlanePoints;
-  public final GeoPoint[] bottomPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
+  protected final GeoPoint[] topPlanePoints;
+  protected final GeoPoint[] bottomPlanePoints;
+  protected final GeoPoint[] leftPlanePoints;
+  protected final GeoPoint[] rightPlanePoints;
 
-  public final GeoPoint centerPoint;
+  protected final GeoPoint centerPoint;
 
-  public final EitherBound eitherBound;
+  protected final EitherBound eitherBound;
 
-  public final GeoPoint[] edgePoints;
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideSouthRectangle.java b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideSouthRectangle.java
index d950e72..09abea7 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideSouthRectangle.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/geo3d/GeoWideSouthRectangle.java
@@ -24,28 +24,28 @@ package org.apache.lucene.geo3d;
  * @lucene.internal
  */
 public class GeoWideSouthRectangle extends GeoBaseBBox {
-  public final double topLat;
-  public final double leftLon;
-  public final double rightLon;
+  protected final double topLat;
+  protected final double leftLon;
+  protected final double rightLon;
 
-  public final double cosMiddleLat;
+  protected final double cosMiddleLat;
 
-  public final GeoPoint ULHC;
-  public final GeoPoint URHC;
+  protected final GeoPoint ULHC;
+  protected final GeoPoint URHC;
 
-  public final SidedPlane topPlane;
-  public final SidedPlane leftPlane;
-  public final SidedPlane rightPlane;
+  protected final SidedPlane topPlane;
+  protected final SidedPlane leftPlane;
+  protected final SidedPlane rightPlane;
 
-  public final GeoPoint[] topPlanePoints;
-  public final GeoPoint[] leftPlanePoints;
-  public final GeoPoint[] rightPlanePoints;
+  protected final GeoPoint[] topPlanePoints;
+  protected final GeoPoint[] leftPlanePoints;
+  protected final GeoPoint[] rightPlanePoints;
 
-  public final GeoPoint centerPoint;
+  protected final GeoPoint centerPoint;
 
-  public final EitherBound eitherBound;
+  protected final EitherBound eitherBound;
 
-  public final GeoPoint[] edgePoints;
+  protected final GeoPoint[] edgePoints;
 
   /**
    * Accepts only values in the following ranges: lat: {@code -PI/2 -> PI/2}, lon: {@code -PI -> PI}.

