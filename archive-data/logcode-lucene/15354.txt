GitDiffStart: 2266c70ce4239814e291d01ff7de819c3b01b099 | Thu Jun 30 02:31:22 2011 +0000
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
index c3abb7b..62af470 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
@@ -35,8 +35,6 @@ import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.function.CustomScoreQuery;
-import org.apache.lucene.search.function.CustomScoreProvider;
 import org.apache.lucene.search.function.FieldScoreQuery;
 import org.apache.lucene.search.function.FieldScoreQuery.Type;
 import org.apache.lucene.spatial.DistanceUtils;
@@ -216,33 +214,6 @@ public class TestCartesian extends LuceneTestCase {
     if (VERBOSE) System.out.println(dq);
     //create a term query to search against all documents
     Query tq = new TermQuery(new Term("metafile", "doc"));
-
-    FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-
-    CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-
-      @Override
-      protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-        return new CustomScoreProvider(context) {
-          @Override // TODO: broken, as reader is not used!
-          public float customScore(int doc, float subQueryScore, float valSrcScore){
-            if (VERBOSE) System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = (float) ((miles - distance) / miles );
-            return score * subQueryScore;
-          }
-        };
-      }
-      
-    };
     // Create a distance sort
     // As the radius filter has performed the distance calculations
     // already, pass in the filter to reuse the results.
@@ -252,7 +223,7 @@ public class TestCartesian extends LuceneTestCase {
 
     // Perform the search, using the term query, the serial chain filter, and the
     // distance sort
-    TopDocs hits = searcher.search(customScore,null, 1000, sort);
+    TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
     int results = hits.totalHits;
     ScoreDoc[] scoreDocs = hits.scoreDocs; 
     
@@ -312,33 +283,6 @@ public class TestCartesian extends LuceneTestCase {
     if (VERBOSE) System.out.println(dq);
     //create a term query to search against all documents
     Query tq = new TermQuery(new Term("metafile", "doc"));
-
-    FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-
-    CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-
-      @Override
-      protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-        return new CustomScoreProvider(context) {
-          @Override // TODO: broken, as reader is not used!
-          public float customScore(int doc, float subQueryScore, float valSrcScore){
-            if (VERBOSE) System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = (float) ((miles - distance) / miles );
-            return score * subQueryScore;
-          }
-        };
-      }
-      
-    };
     // Create a distance sort
     // As the radius filter has performed the distance calculations
     // already, pass in the filter to reuse the results.
@@ -348,7 +292,7 @@ public class TestCartesian extends LuceneTestCase {
 
     // Perform the search, using the term query, the serial chain filter, and the
     // distance sort
-    TopDocs hits = searcher.search(customScore,null, 1000, sort);
+    TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
     int results = hits.totalHits;
     ScoreDoc[] scoreDocs = hits.scoreDocs; 
 
@@ -410,31 +354,6 @@ public class TestCartesian extends LuceneTestCase {
       if (VERBOSE) System.out.println(dq);
       //create a term query to search against all documents
       Query tq = new TermQuery(new Term("metafile", "doc"));
-    
-      FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-    
-      CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-        @Override
-        protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-          return new CustomScoreProvider(context) {
-            @Override // TODO: broken, as reader is not used!
-            public float customScore(int doc, float subQueryScore, float valSrcScore){
-              if (VERBOSE) System.out.println(doc);
-              if (dq.distanceFilter.getDistance(doc) == null)
-                return 0;
-          
-              double distance = dq.distanceFilter.getDistance(doc);
-              // boost score shouldn't exceed 1
-              if (distance < 1.0d)
-                distance = 1.0d;
-              //boost by distance is invertly proportional to
-              // to distance from center point to location
-              float score = (float) ( (miles - distance) / miles );
-              return score * subQueryScore;
-            }
-          };
-        }
-      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.
@@ -444,7 +363,7 @@ public class TestCartesian extends LuceneTestCase {
     
       // Perform the search, using the term query, the serial chain filter, and the
       // distance sort
-      TopDocs hits = searcher.search(customScore,null, 1000, sort);
+      TopDocs hits = searcher.search(dq.getQuery(tq),null, 1000, sort);
       int results = hits.totalHits;
       ScoreDoc[] scoreDocs = hits.scoreDocs; 
     
@@ -506,30 +425,6 @@ public class TestCartesian extends LuceneTestCase {
       if (VERBOSE) System.out.println(dq);
       //create a term query to search against all documents
       Query tq = new TermQuery(new Term("metafile", "doc"));
-	    
-      FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-      CustomScoreQuery customScore = new CustomScoreQuery(tq,fsQuery){
-        @Override
-        protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-          return new CustomScoreProvider(context) {
-              @Override // TODO: broken, as reader is not used!
-              public float customScore(int doc, float subQueryScore, float valSrcScore){
-              if (VERBOSE) System.out.println(doc);
-              if (dq.distanceFilter.getDistance(doc) == null)
-                return 0;
-            
-              double distance = dq.distanceFilter.getDistance(doc);
-              // boost score shouldn't exceed 1
-              if (distance < 1.0d)
-                distance = 1.0d;
-              //boost by distance is invertly proportional to
-              // to distance from center point to location
-              float score = (float) ( (miles - distance) / miles );
-              return score * subQueryScore;
-            }
-          };
-        }
-      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.
@@ -539,7 +434,7 @@ public class TestCartesian extends LuceneTestCase {
 	    
       // Perform the search, using the term query, the serial chain filter, and the
       // distance sort
-      TopDocs hits = searcher.search(customScore,dq.getFilter(), 1000); //,sort);
+      TopDocs hits = searcher.search(tq,dq.getFilter(), 1000); //,sort);
       int results = hits.totalHits;
       ScoreDoc[] scoreDocs = hits.scoreDocs; 
 	    
diff --git a/lucene/src/java/org/apache/lucene/search/function/CustomScoreProvider.java b/lucene/src/java/org/apache/lucene/search/function/CustomScoreProvider.java
deleted file mode 100644
index c80422f..0000000
--- a/lucene/src/java/org/apache/lucene/search/function/CustomScoreProvider.java
+++ /dev/null
@@ -1,163 +0,0 @@
-package org.apache.lucene.search.function;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.index.IndexReader; // for javadocs
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.FieldCache; // for javadocs
-
-/**
- * An instance of this subclass should be returned by
- * {@link CustomScoreQuery#getCustomScoreProvider}, if you want
- * to modify the custom score calculation of a {@link CustomScoreQuery}.
- * <p>Since Lucene 2.9, queries operate on each segment of an index separately,
- * so the protected {@link #context} field can be used to resolve doc IDs,
- * as the supplied <code>doc</code> ID is per-segment and without knowledge
- * of the IndexReader you cannot access the document or {@link FieldCache}.
- * 
- * @lucene.experimental
- * @since 2.9.2
- */
-public class CustomScoreProvider {
-
-  protected final AtomicReaderContext context;
-
-  /**
-   * Creates a new instance of the provider class for the given {@link IndexReader}.
-   */
-  public CustomScoreProvider(AtomicReaderContext context) {
-    this.context = context;
-  }
-
-  /**
-   * Compute a custom score by the subQuery score and a number of 
-   * {@link ValueSourceQuery} scores.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.  
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override the other 
-   * {@link #customScore(int, float, float) customScore()} 
-   * method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of given scores:
-   * <pre>
-   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScores scores of that doc by the ValueSourceQuery.
-   * @return custom score.
-   */
-  public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
-    if (valSrcScores.length == 1) {
-      return customScore(doc, subQueryScore, valSrcScores[0]);
-    }
-    if (valSrcScores.length == 0) {
-      return customScore(doc, subQueryScore, 1);
-    }
-    float score = subQueryScore;
-    for(int i = 0; i < valSrcScores.length; i++) {
-      score *= valSrcScores[i];
-    }
-    return score;
-  }
-
-  /**
-   * Compute a custom score by the subQuery score and the ValueSourceQuery score.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override this customScore() method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of the two scores:
-   * <pre>
-   *     ModifiedScore = subQueryScore * valSrcScore
-   * </pre>
-   *
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScore score of that doc by the ValueSourceQuery.
-   * @return custom score.
-   */
-  public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
-    return subQueryScore * valSrcScore;
-  }
-
-  /**
-   * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float[])}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpls explanation for the value source part.
-   * @return an explanation for the custom score
-   */
-  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
-    if (valSrcExpls.length == 1) {
-      return customExplain(doc, subQueryExpl, valSrcExpls[0]);
-    }
-    if (valSrcExpls.length == 0) {
-      return subQueryExpl;
-    }
-    float valSrcScore = 1;
-    for (int i = 0; i < valSrcExpls.length; i++) {
-      valSrcScore *= valSrcExpls[i].getValue();
-    }
-    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
-    exp.addDetail(subQueryExpl);
-    for (int i = 0; i < valSrcExpls.length; i++) {
-      exp.addDetail(valSrcExpls[i]);
-    }
-    return exp;
-  }
-  
-  /**
-   * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float)}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpl explanation for the value source part.
-   * @return an explanation for the custom score
-   */
-  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
-    float valSrcScore = 1;
-    if (valSrcExpl != null) {
-      valSrcScore *= valSrcExpl.getValue();
-    }
-    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
-    exp.addDetail(subQueryExpl);
-    exp.addDetail(valSrcExpl);
-    return exp;
-  }
-
-}
diff --git a/lucene/src/java/org/apache/lucene/search/function/CustomScoreQuery.java b/lucene/src/java/org/apache/lucene/search/function/CustomScoreQuery.java
deleted file mode 100755
index 2de9509..0000000
--- a/lucene/src/java/org/apache/lucene/search/function/CustomScoreQuery.java
+++ /dev/null
@@ -1,384 +0,0 @@
-package org.apache.lucene.search.function;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Set;
-import java.util.Arrays;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.ComplexExplanation;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.ToStringUtils;
-
-/**
- * Query that sets document score as a programmatic function of several (sub) scores:
- * <ol>
- *    <li>the score of its subQuery (any query)</li>
- *    <li>(optional) the score of its ValueSourceQuery (or queries).
- *        For most simple/convenient use cases this query is likely to be a 
- *        {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}</li>
- * </ol>
- * Subclasses can modify the computation by overriding {@link #getCustomScoreProvider}.
- * 
- * @lucene.experimental
- */
-public class CustomScoreQuery extends Query {
-
-  private Query subQuery;
-  private ValueSourceQuery[] valSrcQueries; // never null (empty array if there are no valSrcQueries).
-  private boolean strict = false; // if true, valueSource part of query does not take part in weights normalization.  
-  
-  /**
-   * Create a CustomScoreQuery over input subQuery.
-   * @param subQuery the sub query whose scored is being customized. Must not be null. 
-   */
-  public CustomScoreQuery(Query subQuery) {
-    this(subQuery, new ValueSourceQuery[0]);
-  }
-
-  /**
-   * Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.
-   * @param subQuery the sub query whose score is being customized. Must not be null.
-   * @param valSrcQuery a value source query whose scores are used in the custom score
-   * computation. For most simple/convenient use case this would be a 
-   * {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}.
-   * This parameter is optional - it can be null.
-   */
-  public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQuery) {
-	  this(subQuery, valSrcQuery!=null ? // don't want an array that contains a single null.. 
-        new ValueSourceQuery[] {valSrcQuery} : new ValueSourceQuery[0]);
-  }
-
-  /**
-   * Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.
-   * @param subQuery the sub query whose score is being customized. Must not be null.
-   * @param valSrcQueries value source queries whose scores are used in the custom score
-   * computation. For most simple/convenient use case these would be 
-   * {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQueries}.
-   * This parameter is optional - it can be null or even an empty array.
-   */
-  public CustomScoreQuery(Query subQuery, ValueSourceQuery... valSrcQueries) {
-    this.subQuery = subQuery;
-    this.valSrcQueries = valSrcQueries!=null?
-        valSrcQueries : new ValueSourceQuery[0];
-    if (subQuery == null) throw new IllegalArgumentException("<subquery> must not be null!");
-  }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    CustomScoreQuery clone = null;
-    
-    final Query sq = subQuery.rewrite(reader);
-    if (sq != subQuery) {
-      clone = (CustomScoreQuery) clone();
-      clone.subQuery = sq;
-    }
-
-    for(int i = 0; i < valSrcQueries.length; i++) {
-      final ValueSourceQuery v = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
-      if (v != valSrcQueries[i]) {
-        if (clone == null) clone = (CustomScoreQuery) clone();
-        clone.valSrcQueries[i] = v;
-      }
-    }
-    
-    return (clone == null) ? this : clone;
-  }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
-  @Override
-  public void extractTerms(Set<Term> terms) {
-    subQuery.extractTerms(terms);
-    for(int i = 0; i < valSrcQueries.length; i++) {
-      valSrcQueries[i].extractTerms(terms);
-    }
-  }
-
-  /*(non-Javadoc) @see org.apache.lucene.search.Query#clone() */
-  @Override
-  public Object clone() {
-    CustomScoreQuery clone = (CustomScoreQuery)super.clone();
-    clone.subQuery = (Query) subQuery.clone();
-    clone.valSrcQueries = new ValueSourceQuery[valSrcQueries.length];
-    for(int i = 0; i < valSrcQueries.length; i++) {
-      clone.valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i].clone();
-    }
-    return clone;
-  }
-
-  /* (non-Javadoc) @see org.apache.lucene.search.Query#toString(java.lang.String) */
-  @Override
-  public String toString(String field) {
-    StringBuilder sb = new StringBuilder(name()).append("(");
-    sb.append(subQuery.toString(field));
-    for(int i = 0; i < valSrcQueries.length; i++) {
-      sb.append(", ").append(valSrcQueries[i].toString(field));
-    }
-    sb.append(")");
-    sb.append(strict?" STRICT" : "");
-    return sb.toString() + ToStringUtils.boost(getBoost());
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o)
-      return true;
-    if (!super.equals(o))
-      return false;
-    if (getClass() != o.getClass()) {
-      return false;
-    }
-    CustomScoreQuery other = (CustomScoreQuery)o;
-    if (this.getBoost() != other.getBoost() ||
-        !this.subQuery.equals(other.subQuery) ||
-        this.strict != other.strict ||
-        this.valSrcQueries.length != other.valSrcQueries.length) {
-      return false;
-    }
-    return Arrays.equals(valSrcQueries, other.valSrcQueries);
-  }
-
-  /** Returns a hash code value for this object. */
-  @Override
-  public int hashCode() {
-    return (getClass().hashCode() + subQuery.hashCode() + Arrays.hashCode(valSrcQueries))
-      ^ Float.floatToIntBits(getBoost()) ^ (strict ? 1234 : 4321);
-  }
-  
-  /**
-   * Returns a {@link CustomScoreProvider} that calculates the custom scores
-   * for the given {@link IndexReader}. The default implementation returns a default
-   * implementation as specified in the docs of {@link CustomScoreProvider}.
-   * @since 2.9.2
-   */
-  protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) throws IOException {
-    return new CustomScoreProvider(context);
-  }
-
-  //=========================== W E I G H T ============================
-  
-  private class CustomWeight extends Weight {
-    Weight subQueryWeight;
-    Weight[] valSrcWeights;
-    boolean qStrict;
-
-    public CustomWeight(IndexSearcher searcher) throws IOException {
-      this.subQueryWeight = subQuery.createWeight(searcher);
-      this.valSrcWeights = new Weight[valSrcQueries.length];
-      for(int i = 0; i < valSrcQueries.length; i++) {
-        this.valSrcWeights[i] = valSrcQueries[i].createWeight(searcher);
-      }
-      this.qStrict = strict;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getQuery() */
-    @Override
-    public Query getQuery() {
-      return CustomScoreQuery.this;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getValue() */
-    @Override
-    public float getValue() {
-      return getBoost();
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#sumOfSquaredWeights() */
-    @Override
-    public float sumOfSquaredWeights() throws IOException {
-      float sum = subQueryWeight.sumOfSquaredWeights();
-      for(int i = 0; i < valSrcWeights.length; i++) {
-        if (qStrict) {
-          valSrcWeights[i].sumOfSquaredWeights(); // do not include ValueSource part in the query normalization
-        } else {
-          sum += valSrcWeights[i].sumOfSquaredWeights();
-        }
-      }
-      sum *= getBoost() * getBoost(); // boost each sub-weight
-      return sum ;
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Weight#normalize(float) */
-    @Override
-    public void normalize(float norm) {
-      norm *= getBoost(); // incorporate boost
-      subQueryWeight.normalize(norm);
-      for(int i = 0; i < valSrcWeights.length; i++) {
-        if (qStrict) {
-          valSrcWeights[i].normalize(1); // do not normalize the ValueSource part
-        } else {
-          valSrcWeights[i].normalize(norm);
-        }
-      }
-    }
-
-    @Override
-    public Scorer scorer(AtomicReaderContext context, ScorerContext scorerContext) throws IOException {
-      // Pass true for "scoresDocsInOrder", because we
-      // require in-order scoring, even if caller does not,
-      // since we call advance on the valSrcScorers.  Pass
-      // false for "topScorer" because we will not invoke
-      // score(Collector) on these scorers:
-      Scorer subQueryScorer = subQueryWeight.scorer(context, ScorerContext.def());
-      if (subQueryScorer == null) {
-        return null;
-      }
-      Scorer[] valSrcScorers = new Scorer[valSrcWeights.length];
-      for(int i = 0; i < valSrcScorers.length; i++) {
-         valSrcScorers[i] = valSrcWeights[i].scorer(context, scorerContext.scoreDocsInOrder(true));
-      }
-      return new CustomScorer(CustomScoreQuery.this.getCustomScoreProvider(context), this, subQueryScorer, valSrcScorers);
-    }
-
-    @Override
-    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {
-      Explanation explain = doExplain(context, doc);
-      return explain == null ? new Explanation(0.0f, "no matching docs") : explain;
-    }
-    
-    private Explanation doExplain(AtomicReaderContext info, int doc) throws IOException {
-      Explanation subQueryExpl = subQueryWeight.explain(info, doc);
-      if (!subQueryExpl.isMatch()) {
-        return subQueryExpl;
-      }
-      // match
-      Explanation[] valSrcExpls = new Explanation[valSrcWeights.length];
-      for(int i = 0; i < valSrcWeights.length; i++) {
-        valSrcExpls[i] = valSrcWeights[i].explain(info, doc);
-      }
-      Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(info).customExplain(doc,subQueryExpl,valSrcExpls);
-      float sc = getValue() * customExp.getValue();
-      Explanation res = new ComplexExplanation(
-        true, sc, CustomScoreQuery.this.toString() + ", product of:");
-      res.addDetail(customExp);
-      res.addDetail(new Explanation(getValue(), "queryBoost")); // actually using the q boost as q weight (== weight value)
-      return res;
-    }
-
-    @Override
-    public boolean scoresDocsOutOfOrder() {
-      return false;
-    }
-    
-  }
-
-
-  //=========================== S C O R E R ============================
-  
-  /**
-   * A scorer that applies a (callback) function on scores of the subQuery.
-   */
-  private class CustomScorer extends Scorer {
-    private final float qWeight;
-    private Scorer subQueryScorer;
-    private Scorer[] valSrcScorers;
-    private final CustomScoreProvider provider;
-    private float vScores[]; // reused in score() to avoid allocating this array for each doc 
-
-    // constructor
-    private CustomScorer(CustomScoreProvider provider, CustomWeight w,
-        Scorer subQueryScorer, Scorer[] valSrcScorers) throws IOException {
-      super(w);
-      this.qWeight = w.getValue();
-      this.subQueryScorer = subQueryScorer;
-      this.valSrcScorers = valSrcScorers;
-      this.vScores = new float[valSrcScorers.length];
-      this.provider = provider;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      int doc = subQueryScorer.nextDoc();
-      if (doc != NO_MORE_DOCS) {
-        for (int i = 0; i < valSrcScorers.length; i++) {
-          valSrcScorers[i].advance(doc);
-        }
-      }
-      return doc;
-    }
-
-    @Override
-    public int docID() {
-      return subQueryScorer.docID();
-    }
-    
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */
-    @Override
-    public float score() throws IOException {
-      for (int i = 0; i < valSrcScorers.length; i++) {
-        vScores[i] = valSrcScorers[i].score();
-      }
-      return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      int doc = subQueryScorer.advance(target);
-      if (doc != NO_MORE_DOCS) {
-        for (int i = 0; i < valSrcScorers.length; i++) {
-          valSrcScorers[i].advance(doc);
-        }
-      }
-      return doc;
-    }
-  }
-
-  @Override
-  public Weight createWeight(IndexSearcher searcher) throws IOException {
-    return new CustomWeight(searcher);
-  }
-
-  /**
-   * Checks if this is strict custom scoring.
-   * In strict custom scoring, the ValueSource part does not participate in weight normalization.
-   * This may be useful when one wants full control over how scores are modified, and does 
-   * not care about normalizing by the ValueSource part.
-   * One particular case where this is useful if for testing this query.   
-   * <P>
-   * Note: only has effect when the ValueSource part is not null.
-   */
-  public boolean isStrict() {
-    return strict;
-  }
-
-  /**
-   * Set the strict mode of this query. 
-   * @param strict The strict mode to set.
-   * @see #isStrict()
-   */
-  public void setStrict(boolean strict) {
-    this.strict = strict;
-  }
-
-  /**
-   * A short name of this query, used in {@link #toString(String)}.
-   */
-  public String name() {
-    return "custom";
-  }
-
-}
diff --git a/lucene/src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java b/lucene/src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
deleted file mode 100755
index fed4bee..0000000
--- a/lucene/src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
+++ /dev/null
@@ -1,349 +0,0 @@
-package org.apache.lucene.search.function;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.queryParser.ParseException;
-import org.apache.lucene.search.*;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.index.Term;
-
-/**
- * Test CustomScoreQuery search.
- */
-public class TestCustomScoreQuery extends FunctionTestSetup {
-
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    createIndex(true);
-  }
-
-  /**
-   * Test that CustomScoreQuery of Type.BYTE returns the expected scores.
-   */
-  @Test
-  public void testCustomScoreByte() throws Exception, ParseException {
-    // INT field values are small enough to be parsed as byte
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.BYTE, 1.0);
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.BYTE, 2.0);
-  }
-
-  /**
-   * Test that CustomScoreQuery of Type.SHORT returns the expected scores.
-   */
-  @Test
-  public void testCustomScoreShort() throws Exception, ParseException {
-    // INT field values are small enough to be parsed as short
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.SHORT, 1.0);
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.SHORT, 3.0);
-  }
-
-  /**
-   * Test that CustomScoreQuery of Type.INT returns the expected scores.
-   */
-  @Test
-  public void testCustomScoreInt() throws Exception, ParseException {
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.INT, 1.0);
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.INT, 4.0);
-  }
-
-  /**
-   * Test that CustomScoreQuery of Type.FLOAT returns the expected scores.
-   */
-  @Test
-  public void testCustomScoreFloat() throws Exception, ParseException {
-    // INT field can be parsed as float
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.FLOAT, 1.0);
-    doTestCustomScore(INT_FIELD, FieldScoreQuery.Type.FLOAT, 5.0);
-    // same values, but in float format
-    doTestCustomScore(FLOAT_FIELD, FieldScoreQuery.Type.FLOAT, 1.0);
-    doTestCustomScore(FLOAT_FIELD, FieldScoreQuery.Type.FLOAT, 6.0);
-  }
-
-  // must have static class otherwise serialization tests fail
-  private static class CustomAddQuery extends CustomScoreQuery {
-    // constructor
-    CustomAddQuery(Query q, ValueSourceQuery qValSrc) {
-      super(q, qValSrc);
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
-    @Override
-    public String name() {
-      return "customAdd";
-    }
-    
-    @Override
-    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-      return new CustomScoreProvider(context) {
-        @Override
-        public float customScore(int doc, float subQueryScore, float valSrcScore) {
-          return subQueryScore + valSrcScore;
-        }
-
-        @Override
-        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
-          float valSrcScore = valSrcExpl == null ? 0 : valSrcExpl.getValue();
-          Explanation exp = new Explanation(valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
-          exp.addDetail(subQueryExpl);
-          if (valSrcExpl != null) {
-            exp.addDetail(valSrcExpl);
-          }
-          return exp;
-        }
-      };
-    }
-  }
-
-  // must have static class otherwise serialization tests fail
-  private static class CustomMulAddQuery extends CustomScoreQuery {
-    // constructor
-    CustomMulAddQuery(Query q, ValueSourceQuery qValSrc1, ValueSourceQuery qValSrc2) {
-      super(q, qValSrc1, qValSrc2);
-    }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
-    @Override
-    public String name() {
-      return "customMulAdd";
-    }
-
-    @Override
-    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
-      return new CustomScoreProvider(context) {
-        @Override
-        public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
-          if (valSrcScores.length == 0) {
-            return subQueryScore;
-          }
-          if (valSrcScores.length == 1) {
-            return subQueryScore + valSrcScores[0];
-            // confirm that skipping beyond the last doc, on the
-            // previous reader, hits NO_MORE_DOCS
-          }
-          return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
-        }
-
-        @Override
-        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
-          if (valSrcExpls.length == 0) {
-            return subQueryExpl;
-          }
-          Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
-          exp.addDetail(subQueryExpl);
-          exp.addDetail(valSrcExpls[0]);
-          if (valSrcExpls.length == 1) {
-            exp.setDescription("CustomMulAdd, sum of:");
-            return exp;
-          }
-          Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
-          exp2.addDetail(valSrcExpls[1]);
-          exp2.addDetail(exp);
-          return exp2;
-        }
-      };
-    }
-  }
-
-  private final class CustomExternalQuery extends CustomScoreQuery {
-
-    @Override
-    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) throws IOException {
-      final int[] values = FieldCache.DEFAULT.getInts(context.reader, INT_FIELD);
-      return new CustomScoreProvider(context) {
-        @Override
-        public float customScore(int doc, float subScore, float valSrcScore) throws IOException {
-          assertTrue(doc <= context.reader.maxDoc());
-          return values[doc];
-        }
-      };
-    }
-
-    public CustomExternalQuery(Query q) {
-      super(q);
-    }
-  }
-
-  @Test
-  public void testCustomExternalQuery() throws Exception {
-    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD,anlzr); 
-    String qtxt = "first aid text"; // from the doc texts in FunctionQuerySetup.
-    Query q1 = qp.parse(qtxt); 
-    
-    final Query q = new CustomExternalQuery(q1);
-    log(q);
-
-    IndexSearcher s = new IndexSearcher(dir, true);
-    TopDocs hits = s.search(q, 1000);
-    assertEquals(N_DOCS, hits.totalHits);
-    for(int i=0;i<N_DOCS;i++) {
-      final int doc = hits.scoreDocs[i].doc;
-      final float score = hits.scoreDocs[i].score;
-      assertEquals("doc=" + doc, (float) 1+(4*doc) % N_DOCS, score, 0.0001);
-    }
-    s.close();
-  }
-  
-  @Test
-  public void testRewrite() throws Exception {
-    final IndexSearcher s = new IndexSearcher(dir, true);
-
-    Query q = new TermQuery(new Term(TEXT_FIELD, "first"));
-    CustomScoreQuery original = new CustomScoreQuery(q);
-    CustomScoreQuery rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
-    assertTrue("rewritten query should be identical, as TermQuery does not rewrite", original == rewritten);
-    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
-    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
-
-    q = new TermRangeQuery(TEXT_FIELD, null, null, true, true); // everything
-    original = new CustomScoreQuery(q);
-    rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
-    assertTrue("rewritten query should not be identical, as TermRangeQuery rewrites", original != rewritten);
-    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
-    assertEquals(s.search(q,1).totalHits, s.search(original,1).totalHits);
-    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
-    
-    s.close();
-  }
-  
-  // Test that FieldScoreQuery returns docs with expected score.
-  private void doTestCustomScore(String field, FieldScoreQuery.Type tp, double dboost) throws Exception, ParseException {
-    float boost = (float) dboost;
-    IndexSearcher s = new IndexSearcher(dir, true);
-    FieldScoreQuery qValSrc = new FieldScoreQuery(field, tp); // a query that would score by the field
-    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD, anlzr);
-    String qtxt = "first aid text"; // from the doc texts in FunctionQuerySetup.
-
-    // regular (boolean) query.
-    Query q1 = qp.parse(qtxt);
-    log(q1);
-
-    // custom query, that should score the same as q1.
-    Query q2CustomNeutral = new CustomScoreQuery(q1);
-    q2CustomNeutral.setBoost(boost);
-    log(q2CustomNeutral);
-
-    // custom query, that should (by default) multiply the scores of q1 by that of the field
-    CustomScoreQuery q3CustomMul = new CustomScoreQuery(q1, qValSrc);
-    q3CustomMul.setStrict(true);
-    q3CustomMul.setBoost(boost);
-    log(q3CustomMul);
-
-    // custom query, that should add the scores of q1 to that of the field
-    CustomScoreQuery q4CustomAdd = new CustomAddQuery(q1, qValSrc);
-    q4CustomAdd.setStrict(true);
-    q4CustomAdd.setBoost(boost);
-    log(q4CustomAdd);
-
-    // custom query, that multiplies and adds the field score to that of q1
-    CustomScoreQuery q5CustomMulAdd = new CustomMulAddQuery(q1, qValSrc, qValSrc);
-    q5CustomMulAdd.setStrict(true);
-    q5CustomMulAdd.setBoost(boost);
-    log(q5CustomMulAdd);
-
-    // do al the searches 
-    TopDocs td1 = s.search(q1, null, 1000);
-    TopDocs td2CustomNeutral = s.search(q2CustomNeutral, null, 1000);
-    TopDocs td3CustomMul = s.search(q3CustomMul, null, 1000);
-    TopDocs td4CustomAdd = s.search(q4CustomAdd, null, 1000);
-    TopDocs td5CustomMulAdd = s.search(q5CustomMulAdd, null, 1000);
-
-    // put results in map so we can verify the scores although they have changed
-    Map<Integer,Float> h1               = topDocsToMap(td1);
-    Map<Integer,Float> h2CustomNeutral  = topDocsToMap(td2CustomNeutral);
-    Map<Integer,Float> h3CustomMul      = topDocsToMap(td3CustomMul);
-    Map<Integer,Float> h4CustomAdd      = topDocsToMap(td4CustomAdd);
-    Map<Integer,Float> h5CustomMulAdd   = topDocsToMap(td5CustomMulAdd);
-    
-    verifyResults(boost, s, 
-        h1, h2CustomNeutral, h3CustomMul, h4CustomAdd, h5CustomMulAdd,
-        q1, q2CustomNeutral, q3CustomMul, q4CustomAdd, q5CustomMulAdd);
-    s.close();
-  }
-
-  // verify results are as expected.
-  private void verifyResults(float boost, IndexSearcher s, 
-      Map<Integer,Float> h1, Map<Integer,Float> h2customNeutral, Map<Integer,Float> h3CustomMul, Map<Integer,Float> h4CustomAdd, Map<Integer,Float> h5CustomMulAdd,
-      Query q1, Query q2, Query q3, Query q4, Query q5) throws Exception {
-    
-    // verify numbers of matches
-    log("#hits = "+h1.size());
-    assertEquals("queries should have same #hits",h1.size(),h2customNeutral.size());
-    assertEquals("queries should have same #hits",h1.size(),h3CustomMul.size());
-    assertEquals("queries should have same #hits",h1.size(),h4CustomAdd.size());
-    assertEquals("queries should have same #hits",h1.size(),h5CustomMulAdd.size());
-
-    QueryUtils.check(random, q1,s);
-    QueryUtils.check(random, q2,s);
-    QueryUtils.check(random, q3,s);
-    QueryUtils.check(random, q4,s);
-    QueryUtils.check(random, q5,s);
-
-    // verify scores ratios
-    for (final Integer doc : h1.keySet()) {
-
-      log("doc = "+doc);
-
-      float fieldScore = expectedFieldScore(s.getIndexReader().document(doc).get(ID_FIELD));
-      log("fieldScore = " + fieldScore);
-      assertTrue("fieldScore should not be 0", fieldScore > 0);
-
-      float score1 = h1.get(doc);
-      logResult("score1=", s, q1, doc, score1);
-      
-      float score2 = h2customNeutral.get(doc);
-      logResult("score2=", s, q2, doc, score2);
-      assertEquals("same score (just boosted) for neutral", boost * score1, score2, TEST_SCORE_TOLERANCE_DELTA);
-
-      float score3 = h3CustomMul.get(doc);
-      logResult("score3=", s, q3, doc, score3);
-      assertEquals("new score for custom mul", boost * fieldScore * score1, score3, TEST_SCORE_TOLERANCE_DELTA);
-      
-      float score4 = h4CustomAdd.get(doc);
-      logResult("score4=", s, q4, doc, score4);
-      assertEquals("new score for custom add", boost * (fieldScore + score1), score4, TEST_SCORE_TOLERANCE_DELTA);
-      
-      float score5 = h5CustomMulAdd.get(doc);
-      logResult("score5=", s, q5, doc, score5);
-      assertEquals("new score for custom mul add", boost * fieldScore * (score1 + fieldScore), score5, TEST_SCORE_TOLERANCE_DELTA);
-    }
-  }
-
-  private void logResult(String msg, IndexSearcher s, Query q, int doc, float score1) throws IOException {
-    log(msg+" "+score1);
-    log("Explain by: "+q);
-    log(s.explain(q,doc));
-  }
-
-  // since custom scoring modifies the order of docs, map results 
-  // by doc ids so that we can later compare/verify them 
-  private Map<Integer,Float> topDocsToMap(TopDocs td) {
-    Map<Integer,Float> h = new HashMap<Integer,Float>();
-    for (int i=0; i<td.totalHits; i++) {
-      h.put(td.scoreDocs[i].doc, td.scoreDocs[i].score);
-    }
-    return h;
-  }
-
-}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/CustomScoreProvider.java b/modules/queries/src/java/org/apache/lucene/queries/CustomScoreProvider.java
new file mode 100644
index 0000000..24c48e7
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/CustomScoreProvider.java
@@ -0,0 +1,163 @@
+package org.apache.lucene.queries;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexReader; // for javadocs
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.FieldCache; // for javadocs
+
+/**
+ * An instance of this subclass should be returned by
+ * {@link CustomScoreQuery#getCustomScoreProvider}, if you want
+ * to modify the custom score calculation of a {@link CustomScoreQuery}.
+ * <p>Since Lucene 2.9, queries operate on each segment of an index separately,
+ * so the protected {@link #context} field can be used to resolve doc IDs,
+ * as the supplied <code>doc</code> ID is per-segment and without knowledge
+ * of the IndexReader you cannot access the document or {@link FieldCache}.
+ * 
+ * @lucene.experimental
+ * @since 2.9.2
+ */
+public class CustomScoreProvider {
+
+  protected final AtomicReaderContext context;
+
+  /**
+   * Creates a new instance of the provider class for the given {@link IndexReader}.
+   */
+  public CustomScoreProvider(AtomicReaderContext context) {
+    this.context = context;
+  }
+
+  /**
+   * Compute a custom score by the subQuery score and a number of 
+   * {@link org.apache.lucene.queries.function.FunctionQuery} scores.
+   * <p> 
+   * Subclasses can override this method to modify the custom score.  
+   * <p>
+   * If your custom scoring is different than the default herein you 
+   * should override at least one of the two customScore() methods.
+   * If the number of ValueSourceQueries is always &lt; 2 it is 
+   * sufficient to override the other 
+   * {@link #customScore(int, float, float) customScore()} 
+   * method, which is simpler. 
+   * <p>
+   * The default computation herein is a multiplication of given scores:
+   * <pre>
+   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
+   * </pre>
+   * 
+   * @param doc id of scored doc. 
+   * @param subQueryScore score of that doc by the subQuery.
+   * @param valSrcScores scores of that doc by the ValueSourceQuery.
+   * @return custom score.
+   */
+  public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
+    if (valSrcScores.length == 1) {
+      return customScore(doc, subQueryScore, valSrcScores[0]);
+    }
+    if (valSrcScores.length == 0) {
+      return customScore(doc, subQueryScore, 1);
+    }
+    float score = subQueryScore;
+    for(int i = 0; i < valSrcScores.length; i++) {
+      score *= valSrcScores[i];
+    }
+    return score;
+  }
+
+  /**
+   * Compute a custom score by the subQuery score and the ValueSourceQuery score.
+   * <p> 
+   * Subclasses can override this method to modify the custom score.
+   * <p>
+   * If your custom scoring is different than the default herein you 
+   * should override at least one of the two customScore() methods.
+   * If the number of ValueSourceQueries is always &lt; 2 it is 
+   * sufficient to override this customScore() method, which is simpler. 
+   * <p>
+   * The default computation herein is a multiplication of the two scores:
+   * <pre>
+   *     ModifiedScore = subQueryScore * valSrcScore
+   * </pre>
+   *
+   * @param doc id of scored doc. 
+   * @param subQueryScore score of that doc by the subQuery.
+   * @param valSrcScore score of that doc by the ValueSourceQuery.
+   * @return custom score.
+   */
+  public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
+    return subQueryScore * valSrcScore;
+  }
+
+  /**
+   * Explain the custom score.
+   * Whenever overriding {@link #customScore(int, float, float[])}, 
+   * this method should also be overridden to provide the correct explanation
+   * for the part of the custom scoring.
+   *  
+   * @param doc doc being explained.
+   * @param subQueryExpl explanation for the sub-query part.
+   * @param valSrcExpls explanation for the value source part.
+   * @return an explanation for the custom score
+   */
+  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
+    if (valSrcExpls.length == 1) {
+      return customExplain(doc, subQueryExpl, valSrcExpls[0]);
+    }
+    if (valSrcExpls.length == 0) {
+      return subQueryExpl;
+    }
+    float valSrcScore = 1;
+    for (int i = 0; i < valSrcExpls.length; i++) {
+      valSrcScore *= valSrcExpls[i].getValue();
+    }
+    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
+    exp.addDetail(subQueryExpl);
+    for (int i = 0; i < valSrcExpls.length; i++) {
+      exp.addDetail(valSrcExpls[i]);
+    }
+    return exp;
+  }
+  
+  /**
+   * Explain the custom score.
+   * Whenever overriding {@link #customScore(int, float, float)}, 
+   * this method should also be overridden to provide the correct explanation
+   * for the part of the custom scoring.
+   *  
+   * @param doc doc being explained.
+   * @param subQueryExpl explanation for the sub-query part.
+   * @param valSrcExpl explanation for the value source part.
+   * @return an explanation for the custom score
+   */
+  public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
+    float valSrcScore = 1;
+    if (valSrcExpl != null) {
+      valSrcScore *= valSrcExpl.getValue();
+    }
+    Explanation exp = new Explanation( valSrcScore * subQueryExpl.getValue(), "custom score: product of:");
+    exp.addDetail(subQueryExpl);
+    exp.addDetail(valSrcExpl);
+    return exp;
+  }
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java b/modules/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java
new file mode 100755
index 0000000..7842a90
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/CustomScoreQuery.java
@@ -0,0 +1,378 @@
+package org.apache.lucene.queries;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+import java.util.Arrays;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.ToStringUtils;
+
+/**
+ * Query that sets document score as a programmatic function of several (sub) scores:
+ * <ol>
+ *    <li>the score of its subQuery (any query)</li>
+ *    <li>(optional) the score of its ValueSourceQuery (or queries).</li>
+ * </ol>
+ * Subclasses can modify the computation by overriding {@link #getCustomScoreProvider}.
+ * 
+ * @lucene.experimental
+ */
+public class CustomScoreQuery extends Query {
+
+  private Query subQuery;
+  private Query[] scoringQueries; // never null (empty array if there are no valSrcQueries).
+  private boolean strict = false; // if true, valueSource part of query does not take part in weights normalization.
+
+  /**
+   * Create a CustomScoreQuery over input subQuery.
+   * @param subQuery the sub query whose scored is being customized. Must not be null. 
+   */
+  public CustomScoreQuery(Query subQuery) {
+    this(subQuery, new Query[0]);
+  }
+
+  /**
+   * Create a CustomScoreQuery over input subQuery and a {@link org.apache.lucene.queries.function.FunctionQuery}.
+   * @param subQuery the sub query whose score is being customized. Must not be null.
+   * @param scoringQuery a value source query whose scores are used in the custom score
+   * computation.  This parameter is optional - it can be null.
+   */
+  public CustomScoreQuery(Query subQuery, Query scoringQuery) {
+	  this(subQuery, scoringQuery!=null ? // don't want an array that contains a single null..
+        new Query[] {scoringQuery} : new Query[0]);
+  }
+
+  /**
+   * Create a CustomScoreQuery over input subQuery and a {@link org.apache.lucene.queries.function.FunctionQuery}.
+   * @param subQuery the sub query whose score is being customized. Must not be null.
+   * @param scoringQueries value source queries whose scores are used in the custom score
+   * computation.  This parameter is optional - it can be null or even an empty array.
+   */
+  public CustomScoreQuery(Query subQuery, Query... scoringQueries) {
+    this.subQuery = subQuery;
+    this.scoringQueries = scoringQueries !=null?
+        scoringQueries : new Query[0];
+    if (subQuery == null) throw new IllegalArgumentException("<subquery> must not be null!");
+  }
+
+  /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    CustomScoreQuery clone = null;
+    
+    final Query sq = subQuery.rewrite(reader);
+    if (sq != subQuery) {
+      clone = (CustomScoreQuery) clone();
+      clone.subQuery = sq;
+    }
+
+    for(int i = 0; i < scoringQueries.length; i++) {
+      final Query v = scoringQueries[i].rewrite(reader);
+      if (v != scoringQueries[i]) {
+        if (clone == null) clone = (CustomScoreQuery) clone();
+        clone.scoringQueries[i] = v;
+      }
+    }
+    
+    return (clone == null) ? this : clone;
+  }
+
+  /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    subQuery.extractTerms(terms);
+    for(int i = 0; i < scoringQueries.length; i++) {
+      scoringQueries[i].extractTerms(terms);
+    }
+  }
+
+  /*(non-Javadoc) @see org.apache.lucene.search.Query#clone() */
+  @Override
+  public Object clone() {
+    CustomScoreQuery clone = (CustomScoreQuery)super.clone();
+    clone.subQuery = (Query) subQuery.clone();
+    clone.scoringQueries = new Query[scoringQueries.length];
+    for(int i = 0; i < scoringQueries.length; i++) {
+      clone.scoringQueries[i] = (Query) scoringQueries[i].clone();
+    }
+    return clone;
+  }
+
+  /* (non-Javadoc) @see org.apache.lucene.search.Query#toString(java.lang.String) */
+  @Override
+  public String toString(String field) {
+    StringBuilder sb = new StringBuilder(name()).append("(");
+    sb.append(subQuery.toString(field));
+    for(int i = 0; i < scoringQueries.length; i++) {
+      sb.append(", ").append(scoringQueries[i].toString(field));
+    }
+    sb.append(")");
+    sb.append(strict?" STRICT" : "");
+    return sb.toString() + ToStringUtils.boost(getBoost());
+  }
+
+  /** Returns true if <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (this == o)
+      return true;
+    if (!super.equals(o))
+      return false;
+    if (getClass() != o.getClass()) {
+      return false;
+    }
+    CustomScoreQuery other = (CustomScoreQuery)o;
+    if (this.getBoost() != other.getBoost() ||
+        !this.subQuery.equals(other.subQuery) ||
+        this.strict != other.strict ||
+        this.scoringQueries.length != other.scoringQueries.length) {
+      return false;
+    }
+    return Arrays.equals(scoringQueries, other.scoringQueries);
+  }
+
+  /** Returns a hash code value for this object. */
+  @Override
+  public int hashCode() {
+    return (getClass().hashCode() + subQuery.hashCode() + Arrays.hashCode(scoringQueries))
+      ^ Float.floatToIntBits(getBoost()) ^ (strict ? 1234 : 4321);
+  }
+  
+  /**
+   * Returns a {@link CustomScoreProvider} that calculates the custom scores
+   * for the given {@link IndexReader}. The default implementation returns a default
+   * implementation as specified in the docs of {@link CustomScoreProvider}.
+   * @since 2.9.2
+   */
+  protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) throws IOException {
+    return new CustomScoreProvider(context);
+  }
+
+  //=========================== W E I G H T ============================
+  
+  private class CustomWeight extends Weight {
+    Weight subQueryWeight;
+    Weight[] valSrcWeights;
+    boolean qStrict;
+
+    public CustomWeight(IndexSearcher searcher) throws IOException {
+      this.subQueryWeight = subQuery.createWeight(searcher);
+      this.valSrcWeights = new Weight[scoringQueries.length];
+      for(int i = 0; i < scoringQueries.length; i++) {
+        this.valSrcWeights[i] = scoringQueries[i].createWeight(searcher);
+      }
+      this.qStrict = strict;
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getQuery() */
+    @Override
+    public Query getQuery() {
+      return CustomScoreQuery.this;
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.Weight#getValue() */
+    @Override
+    public float getValue() {
+      return getBoost();
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.Weight#sumOfSquaredWeights() */
+    @Override
+    public float sumOfSquaredWeights() throws IOException {
+      float sum = subQueryWeight.sumOfSquaredWeights();
+      for(int i = 0; i < valSrcWeights.length; i++) {
+        if (qStrict) {
+          valSrcWeights[i].sumOfSquaredWeights(); // do not include ValueSource part in the query normalization
+        } else {
+          sum += valSrcWeights[i].sumOfSquaredWeights();
+        }
+      }
+      sum *= getBoost() * getBoost(); // boost each sub-weight
+      return sum ;
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.Weight#normalize(float) */
+    @Override
+    public void normalize(float norm) {
+      norm *= getBoost(); // incorporate boost
+      subQueryWeight.normalize(norm);
+      for(int i = 0; i < valSrcWeights.length; i++) {
+        if (qStrict) {
+          valSrcWeights[i].normalize(1); // do not normalize the ValueSource part
+        } else {
+          valSrcWeights[i].normalize(norm);
+        }
+      }
+    }
+
+    @Override
+    public Scorer scorer(AtomicReaderContext context, ScorerContext scorerContext) throws IOException {
+      // Pass true for "scoresDocsInOrder", because we
+      // require in-order scoring, even if caller does not,
+      // since we call advance on the valSrcScorers.  Pass
+      // false for "topScorer" because we will not invoke
+      // score(Collector) on these scorers:
+      Scorer subQueryScorer = subQueryWeight.scorer(context, ScorerContext.def());
+      if (subQueryScorer == null) {
+        return null;
+      }
+      Scorer[] valSrcScorers = new Scorer[valSrcWeights.length];
+      for(int i = 0; i < valSrcScorers.length; i++) {
+         valSrcScorers[i] = valSrcWeights[i].scorer(context, scorerContext.scoreDocsInOrder(true));
+      }
+      return new CustomScorer(CustomScoreQuery.this.getCustomScoreProvider(context), this, subQueryScorer, valSrcScorers);
+    }
+
+    @Override
+    public Explanation explain(AtomicReaderContext context, int doc) throws IOException {
+      Explanation explain = doExplain(context, doc);
+      return explain == null ? new Explanation(0.0f, "no matching docs") : explain;
+    }
+    
+    private Explanation doExplain(AtomicReaderContext info, int doc) throws IOException {
+      Explanation subQueryExpl = subQueryWeight.explain(info, doc);
+      if (!subQueryExpl.isMatch()) {
+        return subQueryExpl;
+      }
+      // match
+      Explanation[] valSrcExpls = new Explanation[valSrcWeights.length];
+      for(int i = 0; i < valSrcWeights.length; i++) {
+        valSrcExpls[i] = valSrcWeights[i].explain(info, doc);
+      }
+      Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(info).customExplain(doc,subQueryExpl,valSrcExpls);
+      float sc = getValue() * customExp.getValue();
+      Explanation res = new ComplexExplanation(
+        true, sc, CustomScoreQuery.this.toString() + ", product of:");
+      res.addDetail(customExp);
+      res.addDetail(new Explanation(getValue(), "queryBoost")); // actually using the q boost as q weight (== weight value)
+      return res;
+    }
+
+    @Override
+    public boolean scoresDocsOutOfOrder() {
+      return false;
+    }
+    
+  }
+
+
+  //=========================== S C O R E R ============================
+  
+  /**
+   * A scorer that applies a (callback) function on scores of the subQuery.
+   */
+  private class CustomScorer extends Scorer {
+    private final float qWeight;
+    private Scorer subQueryScorer;
+    private Scorer[] valSrcScorers;
+    private final CustomScoreProvider provider;
+    private float vScores[]; // reused in score() to avoid allocating this array for each doc 
+
+    // constructor
+    private CustomScorer(CustomScoreProvider provider, CustomWeight w,
+        Scorer subQueryScorer, Scorer[] valSrcScorers) throws IOException {
+      super(w);
+      this.qWeight = w.getValue();
+      this.subQueryScorer = subQueryScorer;
+      this.valSrcScorers = valSrcScorers;
+      this.vScores = new float[valSrcScorers.length];
+      this.provider = provider;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      int doc = subQueryScorer.nextDoc();
+      if (doc != NO_MORE_DOCS) {
+        for (int i = 0; i < valSrcScorers.length; i++) {
+          valSrcScorers[i].advance(doc);
+        }
+      }
+      return doc;
+    }
+
+    @Override
+    public int docID() {
+      return subQueryScorer.docID();
+    }
+    
+    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */
+    @Override
+    public float score() throws IOException {
+      for (int i = 0; i < valSrcScorers.length; i++) {
+        vScores[i] = valSrcScorers[i].score();
+      }
+      return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      int doc = subQueryScorer.advance(target);
+      if (doc != NO_MORE_DOCS) {
+        for (int i = 0; i < valSrcScorers.length; i++) {
+          valSrcScorers[i].advance(doc);
+        }
+      }
+      return doc;
+    }
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher) throws IOException {
+    return new CustomWeight(searcher);
+  }
+
+  /**
+   * Checks if this is strict custom scoring.
+   * In strict custom scoring, the ValueSource part does not participate in weight normalization.
+   * This may be useful when one wants full control over how scores are modified, and does 
+   * not care about normalizing by the ValueSource part.
+   * One particular case where this is useful if for testing this query.   
+   * <P>
+   * Note: only has effect when the ValueSource part is not null.
+   */
+  public boolean isStrict() {
+    return strict;
+  }
+
+  /**
+   * Set the strict mode of this query. 
+   * @param strict The strict mode to set.
+   * @see #isStrict()
+   */
+  public void setStrict(boolean strict) {
+    this.strict = strict;
+  }
+
+  /**
+   * A short name of this query, used in {@link #toString(String)}.
+   */
+  public String name() {
+    return "custom";
+  }
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java b/modules/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java
new file mode 100755
index 0000000..1fafb07
--- /dev/null
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java
@@ -0,0 +1,208 @@
+package org.apache.lucene.queries.function;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.*;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.Set;
+import java.util.Map;
+
+/**
+ * Query that is boosted by a ValueSource
+ */
+public class BoostedQuery extends Query {
+  private Query q;
+  private ValueSource boostVal; // optional, can be null
+
+  public BoostedQuery(Query subQuery, ValueSource boostVal) {
+    this.q = subQuery;
+    this.boostVal = boostVal;
+  }
+
+  public Query getQuery() { return q; }
+  public ValueSource getValueSource() { return boostVal; }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    Query newQ = q.rewrite(reader);
+    if (newQ == q) return this;
+    BoostedQuery bq = (BoostedQuery)this.clone();
+    bq.q = newQ;
+    return bq;
+  }
+
+  @Override
+  public void extractTerms(Set terms) {
+    q.extractTerms(terms);
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher) throws IOException {
+    return new BoostedQuery.BoostedWeight(searcher);
+  }
+
+  private class BoostedWeight extends Weight {
+    IndexSearcher searcher;
+    Weight qWeight;
+    Map fcontext;
+
+    public BoostedWeight(IndexSearcher searcher) throws IOException {
+      this.searcher = searcher;
+      this.qWeight = q.createWeight(searcher);
+      this.fcontext = boostVal.newContext(searcher);
+      boostVal.createWeight(fcontext,searcher);
+    }
+
+    @Override
+    public Query getQuery() {
+      return BoostedQuery.this;
+    }
+
+    @Override
+    public float getValue() {
+      return getBoost();
+    }
+
+    @Override
+    public float sumOfSquaredWeights() throws IOException {
+      float sum = qWeight.sumOfSquaredWeights();
+      sum *= getBoost() * getBoost();
+      return sum ;
+    }
+
+    @Override
+    public void normalize(float norm) {
+      norm *= getBoost();
+      qWeight.normalize(norm);
+    }
+
+    @Override
+    public Scorer scorer(AtomicReaderContext context, ScorerContext scorerContext) throws IOException {
+      Scorer subQueryScorer = qWeight.scorer(context, ScorerContext.def());
+      if(subQueryScorer == null) {
+        return null;
+      }
+      return new BoostedQuery.CustomScorer(context, this, subQueryScorer, boostVal);
+    }
+
+    @Override
+    public Explanation explain(AtomicReaderContext readerContext, int doc) throws IOException {
+      Explanation subQueryExpl = qWeight.explain(readerContext,doc);
+      if (!subQueryExpl.isMatch()) {
+        return subQueryExpl;
+      }
+      DocValues vals = boostVal.getValues(fcontext, readerContext);
+      float sc = subQueryExpl.getValue() * vals.floatVal(doc);
+      Explanation res = new ComplexExplanation(
+        true, sc, BoostedQuery.this.toString() + ", product of:");
+      res.addDetail(subQueryExpl);
+      res.addDetail(vals.explain(doc));
+      return res;
+    }
+  }
+
+
+  private class CustomScorer extends Scorer {
+    private final BoostedQuery.BoostedWeight weight;
+    private final float qWeight;
+    private final Scorer scorer;
+    private final DocValues vals;
+    private final AtomicReaderContext readerContext;
+
+    private CustomScorer(AtomicReaderContext readerContext, BoostedQuery.BoostedWeight w,
+        Scorer scorer, ValueSource vs) throws IOException {
+      super(w);
+      this.weight = w;
+      this.qWeight = w.getValue();
+      this.scorer = scorer;
+      this.readerContext = readerContext;
+      this.vals = vs.getValues(weight.fcontext, readerContext);
+    }
+
+    @Override
+    public int docID() {
+      return scorer.docID();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return scorer.advance(target);
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return scorer.nextDoc();
+    }
+
+    @Override   
+    public float score() throws IOException {
+      float score = qWeight * scorer.score() * vals.floatVal(scorer.docID());
+
+      // Current Lucene priority queues can't handle NaN and -Infinity, so
+      // map to -Float.MAX_VALUE. This conditional handles both -infinity
+      // and NaN since comparisons with NaN are always false.
+      return score>Float.NEGATIVE_INFINITY ? score : -Float.MAX_VALUE;
+    }
+
+    public Explanation explain(int doc) throws IOException {
+      Explanation subQueryExpl = weight.qWeight.explain(readerContext ,doc);
+      if (!subQueryExpl.isMatch()) {
+        return subQueryExpl;
+      }
+      float sc = subQueryExpl.getValue() * vals.floatVal(doc);
+      Explanation res = new ComplexExplanation(
+        true, sc, BoostedQuery.this.toString() + ", product of:");
+      res.addDetail(subQueryExpl);
+      res.addDetail(vals.explain(doc));
+      return res;
+    }
+  }
+
+
+  @Override
+  public String toString(String field) {
+    StringBuilder sb = new StringBuilder();
+    sb.append("boost(").append(q.toString(field)).append(',').append(boostVal).append(')');
+    sb.append(ToStringUtils.boost(getBoost()));
+    return sb.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (getClass() != o.getClass()) return false;
+    BoostedQuery other = (BoostedQuery)o;
+    return this.getBoost() == other.getBoost()
+           && this.q.equals(other.q)
+           && this.boostVal.equals(other.boostVal);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = q.hashCode();
+    h ^= (h << 17) | (h >>> 16);
+    h += boostVal.hashCode();
+    h ^= (h << 8) | (h >>> 25);
+    h += Float.floatToIntBits(getBoost());
+    return h;
+  }
+
+}
diff --git a/modules/queries/src/java/org/apache/lucene/queries/function/FunctionQuery.java b/modules/queries/src/java/org/apache/lucene/queries/function/FunctionQuery.java
index 6624d70..066377b 100644
--- a/modules/queries/src/java/org/apache/lucene/queries/function/FunctionQuery.java
+++ b/modules/queries/src/java/org/apache/lucene/queries/function/FunctionQuery.java
@@ -197,7 +197,7 @@ public class FunctionQuery extends Query {
   /** Returns true if <code>o</code> is equal to this. */
   @Override
   public boolean equals(Object o) {
-    if (FunctionQuery.class != o.getClass()) return false;
+    if (!FunctionQuery.class.isInstance(o)) return false;
     FunctionQuery other = (FunctionQuery)o;
     return this.getBoost() == other.getBoost()
             && this.func.equals(other.func);
diff --git a/modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java b/modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
new file mode 100755
index 0000000..3879d89
--- /dev/null
+++ b/modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
@@ -0,0 +1,370 @@
+package org.apache.lucene.queries;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.FunctionTestSetup;
+import org.apache.lucene.queries.function.valuesource.ByteFieldSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
+import org.apache.lucene.queries.function.valuesource.IntFieldSource;
+import org.apache.lucene.queries.function.valuesource.ShortFieldSource;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.*;
+import org.apache.lucene.search.cache.*;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.Term;
+
+/**
+ * Test CustomScoreQuery search.
+ */
+public class TestCustomScoreQuery extends FunctionTestSetup {
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    createIndex(true);
+  }
+
+  /**
+   * Test that CustomScoreQuery of Type.BYTE returns the expected scores.
+   */
+  @Test
+  public void testCustomScoreByte() throws Exception {
+    // INT field values are small enough to be parsed as byte
+    ByteValuesCreator valuesCreator = new ByteValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
+    FunctionQuery functionQuery = new FunctionQuery(new ByteFieldSource(valuesCreator));
+
+    doTestCustomScore(functionQuery, 1.0);
+    doTestCustomScore(functionQuery, 2.0);
+  }
+
+  /**
+   * Test that CustomScoreQuery of Type.SHORT returns the expected scores.
+   */
+  @Test
+  public void testCustomScoreShort() throws Exception {
+    // INT field values are small enough to be parsed as short
+    ShortValuesCreator valuesCreator = new ShortValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
+    FunctionQuery functionQuery = new FunctionQuery(new ShortFieldSource(valuesCreator));
+
+    doTestCustomScore(functionQuery, 1.0);
+    doTestCustomScore(functionQuery, 3.0);
+  }
+
+  /**
+   * Test that CustomScoreQuery of Type.INT returns the expected scores.
+   */
+  @Test
+  public void testCustomScoreInt() throws Exception {
+    IntValuesCreator valuesCreator = new IntValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
+    FunctionQuery functionQuery = new FunctionQuery(new IntFieldSource(valuesCreator));
+
+    doTestCustomScore(functionQuery, 1.0);
+    doTestCustomScore(functionQuery, 4.0);
+  }
+
+  /**
+   * Test that CustomScoreQuery of Type.FLOAT returns the expected scores.
+   */
+  @Test
+  public void testCustomScoreFloat() throws Exception {
+    // INT field can be parsed as float
+    FloatValuesCreator valuesCreator = new FloatValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
+    FunctionQuery functionQuery = new FunctionQuery(new FloatFieldSource(valuesCreator));
+
+    doTestCustomScore(functionQuery, 1.0);
+    doTestCustomScore(functionQuery, 5.0);
+
+    // same values, but in float format
+    valuesCreator = new FloatValuesCreator(FLOAT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
+    functionQuery = new FunctionQuery(new FloatFieldSource(valuesCreator));
+
+    doTestCustomScore(functionQuery, 1.0);
+    doTestCustomScore(functionQuery, 6.0);
+  }
+
+  // must have static class otherwise serialization tests fail
+  private static class CustomAddQuery extends CustomScoreQuery {
+    // constructor
+    CustomAddQuery(Query q, FunctionQuery qValSrc) {
+      super(q, qValSrc);
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
+    @Override
+    public String name() {
+      return "customAdd";
+    }
+    
+    @Override
+    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
+      return new CustomScoreProvider(context) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScore) {
+          return subQueryScore + valSrcScore;
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
+          float valSrcScore = valSrcExpl == null ? 0 : valSrcExpl.getValue();
+          Explanation exp = new Explanation(valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
+          exp.addDetail(subQueryExpl);
+          if (valSrcExpl != null) {
+            exp.addDetail(valSrcExpl);
+          }
+          return exp;
+        }
+      };
+    }
+  }
+
+  // must have static class otherwise serialization tests fail
+  private static class CustomMulAddQuery extends CustomScoreQuery {
+    // constructor
+    CustomMulAddQuery(Query q, FunctionQuery qValSrc1, FunctionQuery qValSrc2) {
+      super(q, qValSrc1, qValSrc2);
+    }
+
+    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
+    @Override
+    public String name() {
+      return "customMulAdd";
+    }
+
+    @Override
+    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) {
+      return new CustomScoreProvider(context) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
+          if (valSrcScores.length == 0) {
+            return subQueryScore;
+          }
+          if (valSrcScores.length == 1) {
+            return subQueryScore + valSrcScores[0];
+            // confirm that skipping beyond the last doc, on the
+            // previous reader, hits NO_MORE_DOCS
+          }
+          return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
+          if (valSrcExpls.length == 0) {
+            return subQueryExpl;
+          }
+          Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
+          exp.addDetail(subQueryExpl);
+          exp.addDetail(valSrcExpls[0]);
+          if (valSrcExpls.length == 1) {
+            exp.setDescription("CustomMulAdd, sum of:");
+            return exp;
+          }
+          Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
+          exp2.addDetail(valSrcExpls[1]);
+          exp2.addDetail(exp);
+          return exp2;
+        }
+      };
+    }
+  }
+
+  private final class CustomExternalQuery extends CustomScoreQuery {
+
+    @Override
+    protected CustomScoreProvider getCustomScoreProvider(AtomicReaderContext context) throws IOException {
+      final int[] values = FieldCache.DEFAULT.getInts(context.reader, INT_FIELD);
+      return new CustomScoreProvider(context) {
+        @Override
+        public float customScore(int doc, float subScore, float valSrcScore) throws IOException {
+          assertTrue(doc <= context.reader.maxDoc());
+          return values[doc];
+        }
+      };
+    }
+
+    public CustomExternalQuery(Query q) {
+      super(q);
+    }
+  }
+
+  @Test
+  public void testCustomExternalQuery() throws Exception {
+    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD,anlzr); 
+    String qtxt = "first aid text"; // from the doc texts in FunctionQuerySetup.
+    Query q1 = qp.parse(qtxt); 
+    
+    final Query q = new CustomExternalQuery(q1);
+    log(q);
+
+    IndexSearcher s = new IndexSearcher(dir, true);
+    TopDocs hits = s.search(q, 1000);
+    assertEquals(N_DOCS, hits.totalHits);
+    for(int i=0;i<N_DOCS;i++) {
+      final int doc = hits.scoreDocs[i].doc;
+      final float score = hits.scoreDocs[i].score;
+      assertEquals("doc=" + doc, (float) 1+(4*doc) % N_DOCS, score, 0.0001);
+    }
+    s.close();
+  }
+  
+  @Test
+  public void testRewrite() throws Exception {
+    final IndexSearcher s = new IndexSearcher(dir, true);
+
+    Query q = new TermQuery(new Term(TEXT_FIELD, "first"));
+    CustomScoreQuery original = new CustomScoreQuery(q);
+    CustomScoreQuery rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
+    assertTrue("rewritten query should be identical, as TermQuery does not rewrite", original == rewritten);
+    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
+    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
+
+    q = new TermRangeQuery(TEXT_FIELD, null, null, true, true); // everything
+    original = new CustomScoreQuery(q);
+    rewritten = (CustomScoreQuery) original.rewrite(s.getIndexReader());
+    assertTrue("rewritten query should not be identical, as TermRangeQuery rewrites", original != rewritten);
+    assertTrue("no hits for query", s.search(rewritten,1).totalHits > 0);
+    assertEquals(s.search(q,1).totalHits, s.search(original,1).totalHits);
+    assertEquals(s.search(q,1).totalHits, s.search(rewritten,1).totalHits);
+    
+    s.close();
+  }
+  
+  // Test that FieldScoreQuery returns docs with expected score.
+  private void doTestCustomScore(FunctionQuery functionQuery, double dboost) throws Exception {
+    float boost = (float) dboost;
+    IndexSearcher s = new IndexSearcher(dir, true);
+    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD, anlzr);
+    String qtxt = "first aid text"; // from the doc texts in FunctionQuerySetup.
+
+    // regular (boolean) query.
+    Query q1 = qp.parse(qtxt);
+    log(q1);
+
+    // custom query, that should score the same as q1.
+    Query q2CustomNeutral = new CustomScoreQuery(q1);
+    q2CustomNeutral.setBoost(boost);
+    log(q2CustomNeutral);
+
+    // custom query, that should (by default) multiply the scores of q1 by that of the field
+    CustomScoreQuery q3CustomMul = new CustomScoreQuery(q1, functionQuery);
+    q3CustomMul.setStrict(true);
+    q3CustomMul.setBoost(boost);
+    log(q3CustomMul);
+
+    // custom query, that should add the scores of q1 to that of the field
+    CustomScoreQuery q4CustomAdd = new CustomAddQuery(q1, functionQuery);
+    q4CustomAdd.setStrict(true);
+    q4CustomAdd.setBoost(boost);
+    log(q4CustomAdd);
+
+    // custom query, that multiplies and adds the field score to that of q1
+    CustomScoreQuery q5CustomMulAdd = new CustomMulAddQuery(q1, functionQuery, functionQuery);
+    q5CustomMulAdd.setStrict(true);
+    q5CustomMulAdd.setBoost(boost);
+    log(q5CustomMulAdd);
+
+    // do al the searches 
+    TopDocs td1 = s.search(q1, null, 1000);
+    TopDocs td2CustomNeutral = s.search(q2CustomNeutral, null, 1000);
+    TopDocs td3CustomMul = s.search(q3CustomMul, null, 1000);
+    TopDocs td4CustomAdd = s.search(q4CustomAdd, null, 1000);
+    TopDocs td5CustomMulAdd = s.search(q5CustomMulAdd, null, 1000);
+
+    // put results in map so we can verify the scores although they have changed
+    Map<Integer,Float> h1               = topDocsToMap(td1);
+    Map<Integer,Float> h2CustomNeutral  = topDocsToMap(td2CustomNeutral);
+    Map<Integer,Float> h3CustomMul      = topDocsToMap(td3CustomMul);
+    Map<Integer,Float> h4CustomAdd      = topDocsToMap(td4CustomAdd);
+    Map<Integer,Float> h5CustomMulAdd   = topDocsToMap(td5CustomMulAdd);
+    
+    verifyResults(boost, s, 
+        h1, h2CustomNeutral, h3CustomMul, h4CustomAdd, h5CustomMulAdd,
+        q1, q2CustomNeutral, q3CustomMul, q4CustomAdd, q5CustomMulAdd);
+    s.close();
+  }
+
+  // verify results are as expected.
+  private void verifyResults(float boost, IndexSearcher s, 
+      Map<Integer,Float> h1, Map<Integer,Float> h2customNeutral, Map<Integer,Float> h3CustomMul, Map<Integer,Float> h4CustomAdd, Map<Integer,Float> h5CustomMulAdd,
+      Query q1, Query q2, Query q3, Query q4, Query q5) throws Exception {
+    
+    // verify numbers of matches
+    log("#hits = "+h1.size());
+    assertEquals("queries should have same #hits",h1.size(),h2customNeutral.size());
+    assertEquals("queries should have same #hits",h1.size(),h3CustomMul.size());
+    assertEquals("queries should have same #hits",h1.size(),h4CustomAdd.size());
+    assertEquals("queries should have same #hits",h1.size(),h5CustomMulAdd.size());
+
+    QueryUtils.check(random, q1,s);
+    QueryUtils.check(random, q2,s);
+    QueryUtils.check(random, q3,s);
+    QueryUtils.check(random, q4,s);
+    QueryUtils.check(random, q5,s);
+
+    // verify scores ratios
+    for (final Integer doc : h1.keySet()) {
+
+      log("doc = "+doc);
+
+      float fieldScore = expectedFieldScore(s.getIndexReader().document(doc).get(ID_FIELD));
+      log("fieldScore = " + fieldScore);
+      assertTrue("fieldScore should not be 0", fieldScore > 0);
+
+      float score1 = h1.get(doc);
+      logResult("score1=", s, q1, doc, score1);
+      
+      float score2 = h2customNeutral.get(doc);
+      logResult("score2=", s, q2, doc, score2);
+      assertEquals("same score (just boosted) for neutral", boost * score1, score2, TEST_SCORE_TOLERANCE_DELTA);
+
+      float score3 = h3CustomMul.get(doc);
+      logResult("score3=", s, q3, doc, score3);
+      assertEquals("new score for custom mul", boost * fieldScore * score1, score3, TEST_SCORE_TOLERANCE_DELTA);
+      
+      float score4 = h4CustomAdd.get(doc);
+      logResult("score4=", s, q4, doc, score4);
+      assertEquals("new score for custom add", boost * (fieldScore + score1), score4, TEST_SCORE_TOLERANCE_DELTA);
+      
+      float score5 = h5CustomMulAdd.get(doc);
+      logResult("score5=", s, q5, doc, score5);
+      assertEquals("new score for custom mul add", boost * fieldScore * (score1 + fieldScore), score5, TEST_SCORE_TOLERANCE_DELTA);
+    }
+  }
+
+  private void logResult(String msg, IndexSearcher s, Query q, int doc, float score1) throws IOException {
+    log(msg+" "+score1);
+    log("Explain by: "+q);
+    log(s.explain(q,doc));
+  }
+
+  // since custom scoring modifies the order of docs, map results 
+  // by doc ids so that we can later compare/verify them 
+  private Map<Integer,Float> topDocsToMap(TopDocs td) {
+    Map<Integer,Float> h = new HashMap<Integer,Float>();
+    for (int i=0; i<td.totalHits; i++) {
+      h.put(td.scoreDocs[i].doc, td.scoreDocs[i].score);
+    }
+    return h;
+  }
+
+}
diff --git a/modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java b/modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java
new file mode 100644
index 0000000..4c7dce0
--- /dev/null
+++ b/modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java
@@ -0,0 +1,165 @@
+package org.apache.lucene.queries.function;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+import org.junit.AfterClass;
+import org.junit.Ignore;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Setup for function tests
+ */
+@Ignore
+public abstract class FunctionTestSetup extends LuceneTestCase {
+
+  /**
+   * Actual score computation order is slightly different than assumptios
+   * this allows for a small amount of variation
+   */
+  protected static float TEST_SCORE_TOLERANCE_DELTA = 0.001f;
+
+  protected static final int N_DOCS = 17; // select a primary number > 2
+
+  protected static final String ID_FIELD = "id";
+  protected static final String TEXT_FIELD = "text";
+  protected static final String INT_FIELD = "iii";
+  protected static final String FLOAT_FIELD = "fff";
+
+  private static final String DOC_TEXT_LINES[] = {
+          "Well, this is just some plain text we use for creating the ",
+          "test documents. It used to be a text from an online collection ",
+          "devoted to first aid, but if there was there an (online) lawyers ",
+          "first aid collection with legal advices, \"it\" might have quite ",
+          "probably advised one not to include \"it\"'s text or the text of ",
+          "any other online collection in one's code, unless one has money ",
+          "that one don't need and one is happy to donate for lawyers ",
+          "charity. Anyhow at some point, rechecking the usage of this text, ",
+          "it became uncertain that this text is free to use, because ",
+          "the web site in the disclaimer of he eBook containing that text ",
+          "was not responding anymore, and at the same time, in projGut, ",
+          "searching for first aid no longer found that eBook as well. ",
+          "So here we are, with a perhaps much less interesting ",
+          "text for the test, but oh much much safer. ",
+  };
+
+  protected static Directory dir;
+  protected static Analyzer anlzr;
+
+  @AfterClass
+  public static void afterClassFunctionTestSetup() throws Exception {
+    dir.close();
+    dir = null;
+    anlzr = null;
+  }
+
+  protected static void createIndex(boolean doMultiSegment) throws Exception {
+    if (VERBOSE) {
+      System.out.println("TEST: setUp");
+    }
+    // prepare a small index with just a few documents.
+    dir = newDirectory();
+    anlzr = new MockAnalyzer(random);
+    IndexWriterConfig iwc = newIndexWriterConfig( TEST_VERSION_CURRENT, anlzr).setMergePolicy(newLogMergePolicy());
+    if (doMultiSegment) {
+      iwc.setMaxBufferedDocs(_TestUtil.nextInt(random, 2, 7));
+    }
+    RandomIndexWriter iw = new RandomIndexWriter(random, dir, iwc);
+    iw.w.setInfoStream(VERBOSE ? System.out : null);
+    // add docs not exactly in natural ID order, to verify we do check the order of docs by scores
+    int remaining = N_DOCS;
+    boolean done[] = new boolean[N_DOCS];
+    int i = 0;
+    while (remaining > 0) {
+      if (done[i]) {
+        throw new Exception("to set this test correctly N_DOCS=" + N_DOCS + " must be primary and greater than 2!");
+      }
+      addDoc(iw, i);
+      done[i] = true;
+      i = (i + 4) % N_DOCS;
+      remaining --;
+    }
+    if (!doMultiSegment) {
+      if (VERBOSE) {
+        System.out.println("TEST: setUp optimize");
+      }
+      iw.optimize();
+    }
+    iw.close();
+    if (VERBOSE) {
+      System.out.println("TEST: setUp done close");
+    }
+  }
+
+  private static void addDoc(RandomIndexWriter iw, int i) throws Exception {
+    Document d = new Document();
+    Fieldable f;
+    int scoreAndID = i + 1;
+
+    f = newField(ID_FIELD, id2String(scoreAndID), Field.Store.YES, Field.Index.NOT_ANALYZED); // for debug purposes
+    f.setOmitNorms(true);
+    d.add(f);
+
+    f = newField(TEXT_FIELD, "text of doc" + scoreAndID + textLine(i), Field.Store.NO, Field.Index.ANALYZED); // for regular search
+    f.setOmitNorms(true);
+    d.add(f);
+
+    f = newField(INT_FIELD, "" + scoreAndID, Field.Store.NO, Field.Index.NOT_ANALYZED); // for function scoring
+    f.setOmitNorms(true);
+    d.add(f);
+
+    f = newField(FLOAT_FIELD, scoreAndID + ".000", Field.Store.NO, Field.Index.NOT_ANALYZED); // for function scoring
+    f.setOmitNorms(true);
+    d.add(f);
+
+    iw.addDocument(d);
+    log("added: " + d);
+  }
+
+  // 17 --> ID00017
+  protected static String id2String(int scoreAndID) {
+    String s = "000000000" + scoreAndID;
+    int n = ("" + N_DOCS).length() + 3;
+    int k = s.length() - n;
+    return "ID" + s.substring(k);
+  }
+
+  // some text line for regular search
+  private static String textLine(int docNum) {
+    return DOC_TEXT_LINES[docNum % DOC_TEXT_LINES.length];
+  }
+
+  // extract expected doc score from its ID Field: "ID7" --> 7.0
+  protected static float expectedFieldScore(String docIDFieldVal) {
+    return Float.parseFloat(docIDFieldVal.substring(2));
+  }
+
+  // debug messages (change DBG to true for anything to print)
+  protected static void log(Object o) {
+    if (VERBOSE) {
+      System.out.println(o.toString());
+    }
+  }
+}
diff --git a/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java b/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
index 3e7bb14..1c194c8 100755
--- a/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/BoostQParserPlugin.java
@@ -16,6 +16,7 @@
  */
 package org.apache.solr.search;
 
+import org.apache.lucene.queries.function.BoostedQuery;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.QueryValueSource;
@@ -24,7 +25,6 @@ import org.apache.lucene.search.Query;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.search.function.BoostedQuery;
 
 /**
  * Create a boosted query from the input value.  The main value is the query to be boosted.
diff --git a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
index 44480ec..11139ab 100755
--- a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
@@ -22,6 +22,7 @@
 
 package org.apache.solr.search;
 
+import org.apache.lucene.queries.function.BoostedQuery;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.ProductFloatFunction;
@@ -38,7 +39,6 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.search.QueryUtils;
-import org.apache.solr.search.function.BoostedQuery;
 import org.apache.solr.util.SolrPluginUtils;
 import org.apache.solr.analysis.*;
 
diff --git a/solr/src/java/org/apache/solr/search/ValueSourceParser.java b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
index 19055cd..fca81c0 100755
--- a/solr/src/java/org/apache/solr/search/ValueSourceParser.java
+++ b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
@@ -18,6 +18,7 @@ package org.apache.solr.search;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.queries.function.BoostedQuery;
 import org.apache.lucene.queries.function.DocValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.BoolDocValues;
@@ -38,7 +39,6 @@ import org.apache.lucene.util.UnicodeUtil;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.schema.*;
-import org.apache.solr.search.function.*;
 
 import org.apache.solr.search.function.distance.*;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
diff --git a/solr/src/java/org/apache/solr/search/function/BoostedQuery.java b/solr/src/java/org/apache/solr/search/function/BoostedQuery.java
deleted file mode 100755
index 592bb43..0000000
--- a/solr/src/java/org/apache/solr/search/function/BoostedQuery.java
+++ /dev/null
@@ -1,210 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.search.function;
-
-import org.apache.lucene.queries.function.DocValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.*;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Set;
-import java.util.Map;
-
-/**
- * Query that is boosted by a ValueSource
- */
-public class BoostedQuery extends Query {
-  private Query q;
-  private ValueSource boostVal; // optional, can be null
-
-  public BoostedQuery(Query subQuery, ValueSource boostVal) {
-    this.q = subQuery;
-    this.boostVal = boostVal;
-  }
-
-  public Query getQuery() { return q; }
-  public ValueSource getValueSource() { return boostVal; }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query newQ = q.rewrite(reader);
-    if (newQ == q) return this;
-    BoostedQuery bq = (BoostedQuery)this.clone();
-    bq.q = newQ;
-    return bq;
-  }
-
-  @Override
-  public void extractTerms(Set terms) {
-    q.extractTerms(terms);
-  }
-
-  @Override
-  public Weight createWeight(IndexSearcher searcher) throws IOException {
-    return new BoostedQuery.BoostedWeight(searcher);
-  }
-
-  private class BoostedWeight extends Weight {
-    IndexSearcher searcher;
-    Weight qWeight;
-    Map fcontext;
-
-    public BoostedWeight(IndexSearcher searcher) throws IOException {
-      this.searcher = searcher;
-      this.qWeight = q.createWeight(searcher);
-      this.fcontext = boostVal.newContext(searcher);
-      boostVal.createWeight(fcontext,searcher);
-    }
-
-    @Override
-    public Query getQuery() {
-      return BoostedQuery.this;
-    }
-
-    @Override
-    public float getValue() {
-      return getBoost();
-    }
-
-    @Override
-    public float sumOfSquaredWeights() throws IOException {
-      float sum = qWeight.sumOfSquaredWeights();
-      sum *= getBoost() * getBoost();
-      return sum ;
-    }
-
-    @Override
-    public void normalize(float norm) {
-      norm *= getBoost();
-      qWeight.normalize(norm);
-    }
-
-    @Override
-    public Scorer scorer(AtomicReaderContext context, ScorerContext scorerContext) throws IOException {
-      Scorer subQueryScorer = qWeight.scorer(context, ScorerContext.def());
-      if(subQueryScorer == null) {
-        return null;
-      }
-      return new BoostedQuery.CustomScorer(context, this, subQueryScorer, boostVal);
-    }
-
-    @Override
-    public Explanation explain(AtomicReaderContext readerContext, int doc) throws IOException {
-      Explanation subQueryExpl = qWeight.explain(readerContext,doc);
-      if (!subQueryExpl.isMatch()) {
-        return subQueryExpl;
-      }
-      DocValues vals = boostVal.getValues(fcontext, readerContext);
-      float sc = subQueryExpl.getValue() * vals.floatVal(doc);
-      Explanation res = new ComplexExplanation(
-        true, sc, BoostedQuery.this.toString() + ", product of:");
-      res.addDetail(subQueryExpl);
-      res.addDetail(vals.explain(doc));
-      return res;
-    }
-  }
-
-
-  private class CustomScorer extends Scorer {
-    private final BoostedQuery.BoostedWeight weight;
-    private final float qWeight;
-    private final Scorer scorer;
-    private final DocValues vals;
-    private final AtomicReaderContext readerContext;
-
-    private CustomScorer(AtomicReaderContext readerContext, BoostedQuery.BoostedWeight w,
-        Scorer scorer, ValueSource vs) throws IOException {
-      super(w);
-      this.weight = w;
-      this.qWeight = w.getValue();
-      this.scorer = scorer;
-      this.readerContext = readerContext;
-      this.vals = vs.getValues(weight.fcontext, readerContext);
-    }
-
-    @Override
-    public int docID() {
-      return scorer.docID();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      return scorer.advance(target);
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      return scorer.nextDoc();
-    }
-
-    @Override   
-    public float score() throws IOException {
-      float score = qWeight * scorer.score() * vals.floatVal(scorer.docID());
-
-      // Current Lucene priority queues can't handle NaN and -Infinity, so
-      // map to -Float.MAX_VALUE. This conditional handles both -infinity
-      // and NaN since comparisons with NaN are always false.
-      return score>Float.NEGATIVE_INFINITY ? score : -Float.MAX_VALUE;
-    }
-
-    public Explanation explain(int doc) throws IOException {
-      Explanation subQueryExpl = weight.qWeight.explain(readerContext ,doc);
-      if (!subQueryExpl.isMatch()) {
-        return subQueryExpl;
-      }
-      float sc = subQueryExpl.getValue() * vals.floatVal(doc);
-      Explanation res = new ComplexExplanation(
-        true, sc, BoostedQuery.this.toString() + ", product of:");
-      res.addDetail(subQueryExpl);
-      res.addDetail(vals.explain(doc));
-      return res;
-    }
-  }
-
-
-  @Override
-  public String toString(String field) {
-    StringBuilder sb = new StringBuilder();
-    sb.append("boost(").append(q.toString(field)).append(',').append(boostVal).append(')');
-    sb.append(ToStringUtils.boost(getBoost()));
-    return sb.toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (getClass() != o.getClass()) return false;
-    BoostedQuery other = (BoostedQuery)o;
-    return this.getBoost() == other.getBoost()
-           && this.q.equals(other.q)
-           && this.boostVal.equals(other.boostVal);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = q.hashCode();
-    h ^= (h << 17) | (h >>> 16);
-    h += boostVal.hashCode();
-    h ^= (h << 8) | (h >>> 25);
-    h += Float.floatToIntBits(getBoost());
-    return h;
-  }
-
-}

