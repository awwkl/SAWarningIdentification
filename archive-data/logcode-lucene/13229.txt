GitDiffStart: 27fedb096ba7cb6da37f3ded4671d4df9aa9201b | Thu Mar 15 09:31:06 2012 +0000
diff --git a/lucene/contrib/CHANGES.txt b/lucene/contrib/CHANGES.txt
index 6e57df0..4a089a0 100644
--- a/lucene/contrib/CHANGES.txt
+++ b/lucene/contrib/CHANGES.txt
@@ -72,7 +72,7 @@ New Features
    start/endOffset, if offsets are indexed. (Alan Woodward via Mike
    McCandless)
 
- * LUCENE-3802: Support for grouped faceting. (Martijn van Groningen)
+ * LUCENE-3802, LUCENE-3856: Support for grouped faceting. (Martijn van Groningen)
 
 API Changes
 
diff --git a/modules/grouping/src/java/org/apache/lucene/search/grouping/AbstractGroupFacetCollector.java b/modules/grouping/src/java/org/apache/lucene/search/grouping/AbstractGroupFacetCollector.java
index 23e855a..0a6526f 100644
--- a/modules/grouping/src/java/org/apache/lucene/search/grouping/AbstractGroupFacetCollector.java
+++ b/modules/grouping/src/java/org/apache/lucene/search/grouping/AbstractGroupFacetCollector.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search.grouping;
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.PriorityQueue;
 
 import java.io.IOException;
 import java.util.*;
@@ -34,11 +35,18 @@ public abstract class AbstractGroupFacetCollector extends Collector {
   protected final String groupField;
   protected final String facetField;
   protected final BytesRef facetPrefix;
+  protected final List<SegmentResult> segmentResults;
+
+  protected int[] segmentFacetCounts;
+  protected int segmentTotalCount;
+  protected int startFacetOrd;
+  protected int endFacetOrd;
 
   protected AbstractGroupFacetCollector(String groupField, String facetField, BytesRef facetPrefix) {
     this.groupField = groupField;
     this.facetField = facetField;
     this.facetPrefix = facetPrefix;
+    segmentResults = new ArrayList<SegmentResult>();
   }
 
   /**
@@ -52,7 +60,49 @@ public abstract class AbstractGroupFacetCollector extends Collector {
    * @return grouped facet results
    * @throws IOException If I/O related errors occur during merging segment grouped facet counts.
    */
-  public abstract GroupedFacetResult mergeSegmentResults(int size, int minCount, boolean orderByCount) throws IOException;
+  public GroupedFacetResult mergeSegmentResults(int size, int minCount, boolean orderByCount) throws IOException {
+    if (segmentFacetCounts != null) {
+      segmentResults.add(createSegmentResult());
+      segmentFacetCounts = null; // reset
+    }
+
+    int totalCount = 0;
+    int missingCount = 0;
+    SegmentResultPriorityQueue segments = new SegmentResultPriorityQueue(segmentResults.size());
+    for (SegmentResult segmentResult : segmentResults) {
+      missingCount += segmentResult.missing;
+      if (segmentResult.mergePos >= segmentResult.maxTermPos) {
+        continue;
+      }
+      totalCount += segmentResult.total;
+      segments.add(segmentResult);
+    }
+
+    GroupedFacetResult facetResult = new GroupedFacetResult(size, minCount, orderByCount, totalCount, missingCount);
+    while (segments.size() > 0) {
+      SegmentResult segmentResult = segments.top();
+      BytesRef currentFacetValue = BytesRef.deepCopyOf(segmentResult.mergeTerm);
+      int count = 0;
+
+      do {
+        count += segmentResult.counts[segmentResult.mergePos++];
+        if (segmentResult.mergePos < segmentResult.maxTermPos) {
+          segmentResult.nextTerm();
+          segmentResult = segments.updateTop();
+        } else {
+          segments.pop();
+          segmentResult = segments.top();
+          if (segmentResult == null) {
+            break;
+          }
+        }
+      } while (currentFacetValue.equals(segmentResult.mergeTerm));
+      facetResult.addFacetCount(currentFacetValue, count);
+    }
+    return facetResult;
+  }
+
+  protected abstract SegmentResult createSegmentResult() throws IOException;
 
   public void setScorer(Scorer scorer) throws IOException {
   }
@@ -221,4 +271,45 @@ public abstract class AbstractGroupFacetCollector extends Collector {
     }
   }
 
+  /**
+   * Contains the local grouped segment counts for a particular segment.
+   * Each <code>SegmentResult</code> must be added together.
+   */
+  protected abstract static class SegmentResult {
+
+    protected final int[] counts;
+    protected final int total;
+    protected final int missing;
+    protected final int maxTermPos;
+
+    protected BytesRef mergeTerm;
+    protected int mergePos;
+
+    protected SegmentResult(int[] counts, int total, int missing, int maxTermPos) {
+      this.counts = counts;
+      this.total = total;
+      this.missing = missing;
+      this.maxTermPos = maxTermPos;
+    }
+
+    /**
+     * Go to next term in this <code>SegmentResult</code> in order to retrieve the grouped facet counts.
+     *
+     * @throws IOException If I/O related errors occur
+     */
+    protected abstract void nextTerm() throws IOException;
+
+  }
+
+  private static class SegmentResultPriorityQueue extends PriorityQueue<SegmentResult> {
+
+    SegmentResultPriorityQueue(int maxSize) {
+      super(maxSize);
+    }
+
+    protected boolean lessThan(SegmentResult a, SegmentResult b) {
+      return a.mergeTerm.compareTo(b.mergeTerm) < 0;
+    }
+  }
+
 }
diff --git a/modules/grouping/src/java/org/apache/lucene/search/grouping/dv/DVGroupFacetCollector.java b/modules/grouping/src/java/org/apache/lucene/search/grouping/dv/DVGroupFacetCollector.java
new file mode 100644
index 0000000..a542224
--- /dev/null
+++ b/modules/grouping/src/java/org/apache/lucene/search/grouping/dv/DVGroupFacetCollector.java
@@ -0,0 +1,288 @@
+package org.apache.lucene.search.grouping.dv;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.AtomicReader;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.search.grouping.AbstractGroupFacetCollector;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.PriorityQueue;
+import org.apache.lucene.util.SentinelIntSet;
+import org.apache.lucene.util.UnicodeUtil;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An implementation of {@link AbstractGroupFacetCollector} that computes grouped facets based on docvalues.
+ *
+ * @lucene.experimental
+ */
+public abstract class DVGroupFacetCollector extends AbstractGroupFacetCollector {
+
+  final DocValues.Type groupDvType;
+  final boolean groupDiskResident;
+  final DocValues.Type facetFieldDvType;
+  final boolean facetDiskResident;
+
+  final List<GroupedFacetHit> groupedFacetHits;
+  final SentinelIntSet segmentGroupedFacetHits;
+
+  /**
+   * Factory method for creating the right implementation based on the group docvalues type and the facet docvalues
+   * type.
+   *
+   * Currently only the {@link DocValues.Type#BYTES_VAR_SORTED} and the {@link DocValues.Type#BYTES_FIXED_SORTED} are
+   * the only docvalues type supported for both the group and facet field.
+   *
+   * @param groupField        The group field
+   * @param groupDvType       The docvalues type for the group field
+   * @param groupDiskResident Whether the group docvalues should be disk resident
+   * @param facetField        The facet field
+   * @param facetDvType       The docvalues type for the facet field
+   * @param facetDiskResident Whether the facet docvalues should be disk resident
+   * @param facetPrefix       The facet prefix a facet entry should start with to be included.
+   * @param initialSize       The initial allocation size of the internal int set and group facet list which should roughly
+   *                          match the total number of expected unique groups. Be aware that the heap usage is
+   *                          4 bytes * initialSize.
+   * @return a <code>DVGroupFacetCollector</code> implementation
+   */
+  public static DVGroupFacetCollector createDvGroupFacetCollector(String groupField,
+                                                                  DocValues.Type groupDvType,
+                                                                  boolean groupDiskResident,
+                                                                  String facetField,
+                                                                  DocValues.Type facetDvType,
+                                                                  boolean facetDiskResident,
+                                                                  BytesRef facetPrefix,
+                                                                  int initialSize) {
+    switch (groupDvType) {
+      case VAR_INTS:
+      case FIXED_INTS_8:
+      case FIXED_INTS_16:
+      case FIXED_INTS_32:
+      case FIXED_INTS_64:
+      case FLOAT_32:
+      case FLOAT_64:
+      case BYTES_FIXED_STRAIGHT:
+      case BYTES_FIXED_DEREF:
+      case BYTES_VAR_STRAIGHT:
+      case BYTES_VAR_DEREF:
+        throw new IllegalArgumentException(String.format("Group valueType %s not supported", groupDvType));
+      case BYTES_VAR_SORTED:
+      case BYTES_FIXED_SORTED:
+        return GroupSortedBR.createGroupSortedFacetCollector(groupField, groupDvType, groupDiskResident, facetField, facetDvType, facetDiskResident, facetPrefix, initialSize);
+      default:
+        throw new IllegalArgumentException(String.format("Group valueType %s not supported", groupDvType));
+    }
+  }
+
+  DVGroupFacetCollector(String groupField, DocValues.Type groupDvType, boolean groupDiskResident, String facetField, DocValues.Type facetFieldDvType, boolean facetDiskResident, BytesRef facetPrefix, int initialSize) {
+    super(groupField, facetField, facetPrefix);
+    this.groupDvType = groupDvType;
+    this.groupDiskResident = groupDiskResident;
+    this.facetFieldDvType = facetFieldDvType;
+    this.facetDiskResident = facetDiskResident;
+    groupedFacetHits = new ArrayList<GroupedFacetHit>(initialSize);
+    segmentGroupedFacetHits = new SentinelIntSet(initialSize, -1);
+  }
+
+  static abstract class GroupSortedBR extends DVGroupFacetCollector {
+
+    final BytesRef facetSpare = new BytesRef();
+    final BytesRef groupSpare = new BytesRef();
+    DocValues.SortedSource groupFieldSource;
+
+    GroupSortedBR(String groupField, DocValues.Type groupDvType, boolean groupDiskResident, String facetField, DocValues.Type facetFieldDvType, boolean facetDiskResident, BytesRef facetPrefix, int initialSize) {
+      super(groupField, groupDvType, groupDiskResident, facetField, facetFieldDvType, facetDiskResident, facetPrefix, initialSize);
+    }
+
+    static DVGroupFacetCollector createGroupSortedFacetCollector(String groupField,
+                                                                 DocValues.Type groupDvType,
+                                                                 boolean groupDiskResident,
+                                                                 String facetField,
+                                                                 DocValues.Type facetDvType,
+                                                                 boolean facetDiskResident,
+                                                                 BytesRef facetPrefix,
+                                                                 int initialSize) {
+      switch (facetDvType) {
+        case VAR_INTS:
+        case FIXED_INTS_8:
+        case FIXED_INTS_16:
+        case FIXED_INTS_32:
+        case FIXED_INTS_64:
+        case FLOAT_32:
+        case FLOAT_64:
+        case BYTES_FIXED_STRAIGHT:
+        case BYTES_FIXED_DEREF:
+        case BYTES_VAR_STRAIGHT:
+        case BYTES_VAR_DEREF:
+          throw new IllegalArgumentException(String.format("Facet valueType %s not supported", facetDvType));
+        case BYTES_VAR_SORTED:
+        case BYTES_FIXED_SORTED:
+          return new FacetSortedBR(groupField, groupDvType, groupDiskResident, facetField, facetDvType, facetDiskResident, facetPrefix, initialSize);
+        default:
+          throw new IllegalArgumentException(String.format("Facet valueType %s not supported", facetDvType));
+      }
+    }
+
+
+    static class FacetSortedBR extends GroupSortedBR {
+
+      private DocValues.SortedSource facetFieldSource;
+
+      FacetSortedBR(String groupField, DocValues.Type groupDvType, boolean groupDiskResident, String facetField, DocValues.Type facetDvType, boolean diskResident, BytesRef facetPrefix, int initialSize) {
+        super(groupField, groupDvType, groupDiskResident, facetField, facetDvType, diskResident, facetPrefix, initialSize);
+      }
+
+      public void collect(int doc) throws IOException {
+        int facetOrd = facetFieldSource.ord(doc);
+        if (facetOrd < startFacetOrd || facetOrd >= endFacetOrd) {
+          return;
+        }
+
+        int groupOrd = groupFieldSource.ord(doc);
+        int segmentGroupedFacetsIndex = (groupOrd * facetFieldSource.getValueCount()) + facetOrd;
+        if (segmentGroupedFacetHits.exists(segmentGroupedFacetsIndex)) {
+          return;
+        }
+
+        segmentTotalCount++;
+        segmentFacetCounts[facetOrd]++;
+
+        segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);
+        groupedFacetHits.add(
+            new GroupedFacetHit(
+                groupFieldSource.getByOrd(groupOrd, new BytesRef()),
+                facetFieldSource.getByOrd(facetOrd, new BytesRef())
+            )
+        );
+      }
+
+      public void setNextReader(AtomicReaderContext context) throws IOException {
+        if (segmentFacetCounts != null) {
+          segmentResults.add(createSegmentResult());
+        }
+
+        groupFieldSource = getDocValuesSortedSource(groupField, groupDvType, groupDiskResident, context.reader());
+        facetFieldSource = getDocValuesSortedSource(facetField, facetFieldDvType, facetDiskResident, context.reader());
+        segmentFacetCounts = new int[facetFieldSource.getValueCount()];
+        segmentTotalCount = 0;
+
+        segmentGroupedFacetHits.clear();
+        for (GroupedFacetHit groupedFacetHit : groupedFacetHits) {
+          int facetOrd = facetFieldSource.getOrdByValue(groupedFacetHit.facetValue, facetSpare);
+          if (facetOrd < 0) {
+            continue;
+          }
+
+          int groupOrd = groupFieldSource.getOrdByValue(groupedFacetHit.groupValue, groupSpare);
+          if (groupOrd < 0) {
+            continue;
+          }
+
+          int segmentGroupedFacetsIndex = (groupOrd * facetFieldSource.getValueCount()) + facetOrd;
+          segmentGroupedFacetHits.put(segmentGroupedFacetsIndex);
+        }
+
+        if (facetPrefix != null) {
+          startFacetOrd = facetFieldSource.getOrdByValue(facetPrefix, facetSpare);
+          if (startFacetOrd < 0) {
+            // Points to the ord one higher than facetPrefix
+            startFacetOrd = -startFacetOrd - 1;
+          }
+          BytesRef facetEndPrefix = BytesRef.deepCopyOf(facetPrefix);
+          facetEndPrefix.append(UnicodeUtil.BIG_TERM);
+          endFacetOrd = facetFieldSource.getOrdByValue(facetEndPrefix, facetSpare);
+          endFacetOrd = -endFacetOrd - 1; // Points to the ord one higher than facetEndPrefix
+        } else {
+          startFacetOrd = 0;
+          endFacetOrd = facetFieldSource.getValueCount();
+        }
+      }
+
+      protected SegmentResult createSegmentResult() throws IOException {
+        if (startFacetOrd == 0 && facetFieldSource.getByOrd(startFacetOrd, facetSpare).length == 0) {
+          int missing = segmentFacetCounts[0];
+          int total = segmentTotalCount - segmentFacetCounts[0];
+          return new SegmentResult(segmentFacetCounts, total, missing, facetFieldSource, endFacetOrd);
+        } else {
+          return new SegmentResult(segmentFacetCounts, segmentTotalCount, facetFieldSource, startFacetOrd, endFacetOrd);
+        }
+      }
+
+      private DocValues.SortedSource getDocValuesSortedSource(String field, DocValues.Type dvType, boolean diskResident, AtomicReader reader) throws IOException {
+        DocValues dv = reader.docValues(field);
+        DocValues.Source dvSource;
+        if (dv != null) {
+          dvSource = diskResident ? dv.getDirectSource() : dv.getSource();
+        } else {
+          dvSource = DocValues.getDefaultSortedSource(dvType, reader.maxDoc());
+        }
+        return dvSource.asSortedSource();
+      }
+
+      private static class SegmentResult extends AbstractGroupFacetCollector.SegmentResult {
+
+        final DocValues.SortedSource facetFieldSource;
+        final BytesRef spare = new BytesRef();
+
+        SegmentResult(int[] counts, int total, int missing, DocValues.SortedSource facetFieldSource, int endFacetOrd) {
+          super(counts, total, missing, endFacetOrd);
+          this.facetFieldSource = facetFieldSource;
+          this.mergePos = 1;
+          if (mergePos < maxTermPos) {
+            mergeTerm = facetFieldSource.getByOrd(mergePos, spare);
+          }
+        }
+
+        SegmentResult(int[] counts, int total, DocValues.SortedSource facetFieldSource, int startFacetOrd, int endFacetOrd) {
+          super(counts, total, 0, endFacetOrd);
+          this.facetFieldSource = facetFieldSource;
+          this.mergePos = startFacetOrd;
+          if (mergePos < maxTermPos) {
+            mergeTerm = facetFieldSource.getByOrd(mergePos, spare);
+          }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        protected void nextTerm() throws IOException {
+          mergeTerm = facetFieldSource.getByOrd(mergePos, spare);
+        }
+
+      }
+
+    }
+
+  }
+
+}
+
+class GroupedFacetHit {
+
+  final BytesRef groupValue;
+  final BytesRef facetValue;
+
+  GroupedFacetHit(BytesRef groupValue, BytesRef facetValue) {
+    this.groupValue = groupValue;
+    this.facetValue = facetValue;
+  }
+}
diff --git a/modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java b/modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java
index 4a9326e..0012561 100644
--- a/modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java
+++ b/modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermGroupFacetCollector.java
@@ -38,14 +38,9 @@ public abstract class TermGroupFacetCollector extends AbstractGroupFacetCollecto
 
   final List<GroupedFacetHit> groupedFacetHits;
   final SentinelIntSet segmentGroupedFacetHits;
-  final List<SegmentResult> segmentResults;
   final BytesRef spare = new BytesRef();
 
   FieldCache.DocTermsIndex groupFieldTermsIndex;
-  int[] segmentFacetCounts;
-  int segmentTotalCount;
-  int startFacetOrd;
-  int endFacetOrd;
 
   /**
    * Factory method for creating the right implementation based on the fact whether the facet field contains
@@ -76,57 +71,8 @@ public abstract class TermGroupFacetCollector extends AbstractGroupFacetCollecto
     super(groupField, facetField, facetPrefix);
     groupedFacetHits = new ArrayList<GroupedFacetHit>(initialSize);
     segmentGroupedFacetHits = new SentinelIntSet(initialSize, -1);
-    segmentResults = new ArrayList<SegmentResult>();
   }
 
-  /**
-   * {@inheritDoc}
-   */
-  public GroupedFacetResult mergeSegmentResults(int size, int minCount, boolean orderByCount) throws IOException {
-    if (segmentFacetCounts != null) {
-      segmentResults.add(createSegmentResult());
-      segmentFacetCounts = null; // reset
-    }
-
-    int totalCount = 0;
-    int missingCount = 0;
-    SegmentResultPriorityQueue segments = new SegmentResultPriorityQueue(segmentResults.size());
-    for (SegmentResult segmentResult : segmentResults) {
-      missingCount += segmentResult.missing;
-      if (segmentResult.mergePos >= segmentResult.maxTermPos) {
-        continue;
-      }
-      totalCount += segmentResult.total;
-      segmentResult.initializeForMerge();
-      segments.add(segmentResult);
-    }
-
-    GroupedFacetResult facetResult = new GroupedFacetResult(size, minCount, orderByCount, totalCount, missingCount);
-    while (segments.size() > 0) {
-      SegmentResult segmentResult = segments.top();
-      BytesRef currentFacetValue = BytesRef.deepCopyOf(segmentResult.mergeTerm);
-      int count = 0;
-
-      do {
-        count += segmentResult.counts[segmentResult.mergePos++];
-        if (segmentResult.mergePos < segmentResult.maxTermPos) {
-          segmentResult.nextTerm();
-          segmentResult = segments.updateTop();
-        } else {
-          segments.pop();
-          segmentResult = segments.top();
-          if (segmentResult == null) {
-            break;
-          }
-        }
-      } while (currentFacetValue.equals(segmentResult.mergeTerm));
-      facetResult.addFacetCount(currentFacetValue, count);
-    }
-    return facetResult;
-  }
-
-  protected abstract SegmentResult createSegmentResult();
-
   // Implementation for single valued facet fields.
   static class SV extends TermGroupFacetCollector {
 
@@ -202,9 +148,30 @@ public abstract class TermGroupFacetCollector extends AbstractGroupFacetCollecto
       }
     }
 
-    protected SegmentResult createSegmentResult() {
+    protected SegmentResult createSegmentResult() throws IOException {
       return new SegmentResult(segmentFacetCounts, segmentTotalCount, facetFieldTermsIndex.getTermsEnum(), startFacetOrd, endFacetOrd);
     }
+
+    private static class SegmentResult extends AbstractGroupFacetCollector.SegmentResult {
+
+      final TermsEnum tenum;
+
+      SegmentResult(int[] counts, int total, TermsEnum tenum, int startFacetOrd, int endFacetOrd) throws IOException {
+        super(counts, total - counts[0], counts[0], endFacetOrd);
+        this.tenum = tenum;
+        this.mergePos = startFacetOrd == 0 ? 1 : startFacetOrd;
+        if (mergePos < maxTermPos) {
+          tenum.seekExact(mergePos);
+          mergeTerm = tenum.term();
+        }
+      }
+
+      protected void nextTerm() throws IOException {
+        mergeTerm = tenum.next();
+      }
+
+    }
+
   }
 
   // Implementation for multi valued facet fields.
@@ -316,54 +283,28 @@ public abstract class TermGroupFacetCollector extends AbstractGroupFacetCollecto
       }
     }
 
-    protected SegmentResult createSegmentResult() {
+    protected SegmentResult createSegmentResult() throws IOException {
       return new SegmentResult(segmentFacetCounts, segmentTotalCount, facetFieldDocTermOrds.numTerms(), facetOrdTermsEnum, startFacetOrd, endFacetOrd);
     }
-  }
 
-}
+    private static class SegmentResult extends AbstractGroupFacetCollector.SegmentResult {
 
-class SegmentResult {
-
-  final int[] counts;
-  final int total;
-  final int missing;
-
-  // Used for merging the segment results
-  BytesRef mergeTerm;
-  int mergePos;
-  final int maxTermPos;
-  final TermsEnum tenum;
-
-  SegmentResult(int[] counts, int total, TermsEnum tenum, int startFacetOrd, int endFacetOrd) {
-    this.counts = counts;
-    this.missing = counts[0];
-    this.total = total - missing;
-    this.tenum = tenum;
-    this.mergePos = startFacetOrd == 0 ? 1 : startFacetOrd;
-    this.maxTermPos = endFacetOrd;
-  }
+      final TermsEnum tenum;
 
-  SegmentResult(int[] counts, int total, int missingCountIndex, TermsEnum tenum, int startFacetOrd, int endFacetOrd) {
-    this.counts = counts;
-    this.missing = counts[missingCountIndex];
-    this.total = total - missing;
-    this.tenum = tenum;
-    this.mergePos = startFacetOrd;
-    if (endFacetOrd == missingCountIndex + 1) {
-      this.maxTermPos = missingCountIndex;
-    } else {
-      this.maxTermPos = endFacetOrd;
-    }
-  }
+      SegmentResult(int[] counts, int total, int missingCountIndex, TermsEnum tenum, int startFacetOrd, int endFacetOrd) throws IOException {
+        super(counts, total - counts[missingCountIndex], counts[missingCountIndex],
+            endFacetOrd == missingCountIndex + 1 ?  missingCountIndex : endFacetOrd);
+        this.tenum = tenum;
+        this.mergePos = startFacetOrd;
+        tenum.seekExact(mergePos);
+        mergeTerm = tenum.term();
+      }
 
-  void initializeForMerge() throws IOException {
-    tenum.seekExact(mergePos);
-    mergeTerm = tenum.term();
-  }
+      protected void nextTerm() throws IOException {
+        mergeTerm = tenum.next();
+      }
 
-  void nextTerm() throws IOException {
-    mergeTerm = tenum.next();
+    }
   }
 
 }
@@ -377,15 +318,4 @@ class GroupedFacetHit {
     this.groupValue = groupValue;
     this.facetValue = facetValue;
   }
-}
-
-class SegmentResultPriorityQueue extends PriorityQueue<SegmentResult> {
-
-  SegmentResultPriorityQueue(int maxSize) {
-    super(maxSize);
-  }
-
-  protected boolean lessThan(SegmentResult a, SegmentResult b) {
-    return a.mergeTerm.compareTo(b.mergeTerm) < 0;
-  }
-}
+}
\ No newline at end of file
diff --git a/modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java b/modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java
new file mode 100644
index 0000000..f1cc065
--- /dev/null
+++ b/modules/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java
@@ -0,0 +1,645 @@
+package org.apache.lucene.search.grouping;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.*;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.grouping.dv.DVGroupFacetCollector;
+import org.apache.lucene.search.grouping.term.TermGroupFacetCollector;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util._TestUtil;
+
+import java.io.IOException;
+import java.util.*;
+
+public class GroupFacetCollectorTest extends AbstractGroupingTestCase {
+
+  public void testSimple() throws Exception {
+    final String groupField = "hotel";
+    FieldType customType = new FieldType();
+    customType.setStored(true);
+
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(
+        random,
+        dir,
+        newIndexWriterConfig(TEST_VERSION_CURRENT,
+            new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));
+    boolean canUseDV = !"Lucene3x".equals(w.w.getConfig().getCodec().getName());
+    boolean useDv = canUseDV && random.nextBoolean();
+
+    // 0
+    Document doc = new Document();
+    addField(doc, groupField, "a", canUseDV);
+    addField(doc, "airport", "ams", canUseDV);
+    addField(doc, "duration", "5", canUseDV);
+    w.addDocument(doc);
+
+    // 1
+    doc = new Document();
+    addField(doc, groupField, "a", canUseDV);
+    addField(doc, "airport", "dus", canUseDV);
+    addField(doc, "duration", "10", canUseDV);
+    w.addDocument(doc);
+
+    // 2
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "airport", "ams", canUseDV);
+    addField(doc, "duration", "10", canUseDV);
+    w.addDocument(doc);
+    w.commit(); // To ensure a second segment
+
+    // 3
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "airport", "ams", canUseDV);
+    addField(doc, "duration", "5", canUseDV);
+    w.addDocument(doc);
+
+    // 4
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "airport", "ams", canUseDV);
+    addField(doc, "duration", "5", canUseDV);
+    w.addDocument(doc);
+
+    IndexSearcher indexSearcher = new IndexSearcher(w.getReader());
+    AbstractGroupFacetCollector groupedAirportFacetCollector = createRandomCollector(groupField, "airport", null, false, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
+    TermGroupFacetCollector.GroupedFacetResult airportResult = groupedAirportFacetCollector.mergeSegmentResults(10, 0, false);
+    assertEquals(3, airportResult.getTotalCount());
+    assertEquals(0, airportResult.getTotalMissingCount());
+
+    List<TermGroupFacetCollector.FacetEntry> entries = airportResult.getFacetEntries(0, 10);
+    assertEquals(2, entries.size());
+    assertEquals("ams", entries.get(0).getValue().utf8ToString());
+    assertEquals(2, entries.get(0).getCount());
+    assertEquals("dus", entries.get(1).getValue().utf8ToString());
+    assertEquals(1, entries.get(1).getCount());
+
+
+    AbstractGroupFacetCollector groupedDurationFacetCollector = createRandomCollector(groupField, "duration", null, false, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
+    TermGroupFacetCollector.GroupedFacetResult durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 0, false);
+    assertEquals(4, durationResult.getTotalCount());
+    assertEquals(0, durationResult.getTotalMissingCount());
+
+    entries = durationResult.getFacetEntries(0, 10);
+    assertEquals(2, entries.size());
+    assertEquals("10", entries.get(0).getValue().utf8ToString());
+    assertEquals(2, entries.get(0).getCount());
+    assertEquals("5", entries.get(1).getValue().utf8ToString());
+    assertEquals(2, entries.get(1).getCount());
+
+    // 5
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "duration", "5", canUseDV);
+    w.addDocument(doc);
+
+    // 6
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "airport", "bru", canUseDV);
+    addField(doc, "duration", "10", canUseDV);
+    w.addDocument(doc);
+
+    // 7
+    doc = new Document();
+    addField(doc, groupField, "b", canUseDV);
+    addField(doc, "airport", "bru", canUseDV);
+    addField(doc, "duration", "15", canUseDV);
+    w.addDocument(doc);
+
+    // 8
+    doc = new Document();
+    addField(doc, groupField, "a", canUseDV);
+    addField(doc, "airport", "bru", canUseDV);
+    addField(doc, "duration", "10", canUseDV);
+    w.addDocument(doc);
+
+    indexSearcher.getIndexReader().close();
+    indexSearcher = new IndexSearcher(w.getReader());
+    groupedAirportFacetCollector = createRandomCollector(groupField, "airport", null, true, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
+    airportResult = groupedAirportFacetCollector.mergeSegmentResults(3, 0, true);
+    assertEquals(5, airportResult.getTotalCount());
+    assertEquals(1, airportResult.getTotalMissingCount());
+
+    entries = airportResult.getFacetEntries(1, 2);
+    assertEquals(2, entries.size());
+    assertEquals("bru", entries.get(0).getValue().utf8ToString());
+    assertEquals(2, entries.get(0).getCount());
+    assertEquals("dus", entries.get(1).getValue().utf8ToString());
+    assertEquals(1, entries.get(1).getCount());
+
+    groupedDurationFacetCollector = createRandomCollector(groupField, "duration", null, false, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
+    durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 2, true);
+    assertEquals(5, durationResult.getTotalCount());
+    assertEquals(0, durationResult.getTotalMissingCount());
+
+    entries = durationResult.getFacetEntries(1, 1);
+    assertEquals(1, entries.size());
+    assertEquals("5", entries.get(0).getValue().utf8ToString());
+    assertEquals(2, entries.get(0).getCount());
+
+    // 9
+    doc = new Document();
+    addField(doc, groupField, "c", canUseDV);
+    addField(doc, "airport", "bru", canUseDV);
+    addField(doc, "duration", "15", canUseDV);
+    w.addDocument(doc);
+
+    // 10
+    doc = new Document();
+    addField(doc, groupField, "c", canUseDV);
+    addField(doc, "airport", "dus", canUseDV);
+    addField(doc, "duration", "10", canUseDV);
+    w.addDocument(doc);
+
+    indexSearcher.getIndexReader().close();
+    indexSearcher = new IndexSearcher(w.getReader());
+    groupedAirportFacetCollector = createRandomCollector(groupField, "airport", null, false, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
+    airportResult = groupedAirportFacetCollector.mergeSegmentResults(10, 0, false);
+    assertEquals(7, airportResult.getTotalCount());
+    assertEquals(1, airportResult.getTotalMissingCount());
+
+    entries = airportResult.getFacetEntries(0, 10);
+    assertEquals(3, entries.size());
+    assertEquals("ams", entries.get(0).getValue().utf8ToString());
+    assertEquals(2, entries.get(0).getCount());
+    assertEquals("bru", entries.get(1).getValue().utf8ToString());
+    assertEquals(3, entries.get(1).getCount());
+    assertEquals("dus", entries.get(2).getValue().utf8ToString());
+    assertEquals(2, entries.get(2).getCount());
+
+    groupedDurationFacetCollector = createRandomCollector(groupField, "duration", "1", false, useDv);
+    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
+    durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 0, true);
+    assertEquals(5, durationResult.getTotalCount());
+    assertEquals(0, durationResult.getTotalMissingCount());
+
+    entries = durationResult.getFacetEntries(0, 10);
+    assertEquals(2, entries.size());
+    assertEquals("10", entries.get(0).getValue().utf8ToString());
+    assertEquals(3, entries.get(0).getCount());
+    assertEquals("15", entries.get(1).getValue().utf8ToString());
+    assertEquals(2, entries.get(1).getCount());
+
+    w.close();
+    indexSearcher.getIndexReader().close();
+    dir.close();
+  }
+
+  private void addField(Document doc, String field, String value, boolean canUseIDV) {
+    doc.add(new Field(field, value, StringField.TYPE_UNSTORED));
+    if (canUseIDV) {
+      doc.add(new DocValuesField(field, new BytesRef(value), DocValues.Type.BYTES_VAR_SORTED));
+    }
+  }
+
+  public void testRandom() throws Exception {
+    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);
+    for (int indexIter = 0; indexIter < numberOfRuns; indexIter++) {
+      boolean multipleFacetsPerDocument = random.nextBoolean();
+      IndexContext context = createIndexContext(multipleFacetsPerDocument);
+      final IndexSearcher searcher = newSearcher(context.indexReader);
+
+      for (int searchIter = 0; searchIter < 100; searchIter++) {
+        boolean useDv = context.useDV && random.nextBoolean();
+        String searchTerm = context.contentStrings[random.nextInt(context.contentStrings.length)];
+        int limit = random.nextInt(context.facetValues.size());
+        int offset = random.nextInt(context.facetValues.size() - limit);
+        int size = offset + limit;
+        int minCount = random.nextBoolean() ? 0 : random.nextInt(1 + context.facetWithMostGroups / 10);
+        boolean orderByCount = random.nextBoolean();
+        String randomStr = getFromSet(context.facetValues, random.nextInt(context.facetValues.size()));
+        final String facetPrefix;
+        if (randomStr == null) {
+          facetPrefix = null;
+        } else {
+          int codePointLen = randomStr.codePointCount(0, randomStr.length());
+          int randomLen = random.nextInt(codePointLen);
+          if (codePointLen == randomLen - 1) {
+            facetPrefix = null;
+          } else {
+            int end = randomStr.offsetByCodePoints(0, randomLen);
+            facetPrefix = random.nextBoolean() ? null : randomStr.substring(end);
+          }
+        }
+
+        GroupedFacetResult expectedFacetResult = createExpectedFacetResult(searchTerm, context, offset, limit, minCount, orderByCount, facetPrefix);
+        AbstractGroupFacetCollector groupFacetCollector = createRandomCollector("group", "facet", facetPrefix, multipleFacetsPerDocument, useDv);
+        searcher.search(new TermQuery(new Term("content", searchTerm)), groupFacetCollector);
+        TermGroupFacetCollector.GroupedFacetResult actualFacetResult = groupFacetCollector.mergeSegmentResults(size, minCount, orderByCount);
+
+        List<TermGroupFacetCollector.FacetEntry> expectedFacetEntries = expectedFacetResult.getFacetEntries();
+        List<TermGroupFacetCollector.FacetEntry> actualFacetEntries = actualFacetResult.getFacetEntries(offset, limit);
+
+        if (VERBOSE) {
+          System.out.println("Collector: " + groupFacetCollector.getClass().getSimpleName());
+          System.out.println("Num group: " + context.numGroups);
+          System.out.println("Num doc: " + context.numDocs);
+          System.out.println("Index iter: " + indexIter);
+          System.out.println("multipleFacetsPerDocument: " + multipleFacetsPerDocument);
+          System.out.println("Search iter: " + searchIter);
+
+          System.out.println("Search term: " + searchTerm);
+          System.out.println("Min count: " + minCount);
+          System.out.println("Facet offset: " + offset);
+          System.out.println("Facet limit: " + limit);
+          System.out.println("Facet prefix: " + facetPrefix);
+          System.out.println("Order by count: " + orderByCount);
+
+          System.out.println("\n=== Expected: \n");
+          System.out.println("Total count " + expectedFacetResult.getTotalCount());
+          System.out.println("Total missing count " + expectedFacetResult.getTotalMissingCount());
+          int counter = 1;
+          for (TermGroupFacetCollector.FacetEntry expectedFacetEntry : expectedFacetEntries) {
+            System.out.println(
+                String.format(
+                    "%d. Expected facet value %s with count %d",
+                    counter++, expectedFacetEntry.getValue().utf8ToString(), expectedFacetEntry.getCount()
+                )
+            );
+          }
+
+          System.out.println("\n=== Actual: \n");
+          System.out.println("Total count " + actualFacetResult.getTotalCount());
+          System.out.println("Total missing count " + actualFacetResult.getTotalMissingCount());
+          counter = 1;
+          for (TermGroupFacetCollector.FacetEntry actualFacetEntry : actualFacetEntries) {
+            System.out.println(
+                String.format(
+                    "%d. Actual facet value %s with count %d",
+                    counter++, actualFacetEntry.getValue().utf8ToString(), actualFacetEntry.getCount()
+                )
+            );
+          }
+          System.out.println("\n===================================================================================");
+        }
+
+        assertEquals(expectedFacetResult.getTotalCount(), actualFacetResult.getTotalCount());
+        assertEquals(expectedFacetResult.getTotalMissingCount(), actualFacetResult.getTotalMissingCount());
+        assertEquals(expectedFacetEntries.size(), actualFacetEntries.size());
+        for (int i = 0; i < expectedFacetEntries.size(); i++) {
+          TermGroupFacetCollector.FacetEntry expectedFacetEntry = expectedFacetEntries.get(i);
+          TermGroupFacetCollector.FacetEntry actualFacetEntry = actualFacetEntries.get(i);
+          assertEquals(expectedFacetEntry.getValue().utf8ToString() + " != " + actualFacetEntry.getValue().utf8ToString(), expectedFacetEntry.getValue(), actualFacetEntry.getValue());
+          assertEquals(expectedFacetEntry.getCount() + " != " + actualFacetEntry.getCount(), expectedFacetEntry.getCount(), actualFacetEntry.getCount());
+        }
+      }
+
+      context.indexReader.close();
+      context.dir.close();
+    }
+  }
+
+  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {
+    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;
+    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);
+    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);
+
+    if (VERBOSE) {
+      System.out.println("TEST: numDocs=" + numDocs + " numGroups=" + numGroups);
+    }
+
+    final List<String> groups = new ArrayList<String>();
+    for (int i = 0; i < numGroups; i++) {
+      groups.add(generateRandomNonEmptyString());
+    }
+    final List<String> facetValues = new ArrayList<String>();
+    for (int i = 0; i < numFacets; i++) {
+      facetValues.add(generateRandomNonEmptyString());
+    }
+    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];
+    if (VERBOSE) {
+      System.out.println("TEST: create fake content");
+    }
+    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {
+      contentBrs[contentIDX] = generateRandomNonEmptyString();
+      if (VERBOSE) {
+        System.out.println("  content=" + contentBrs[contentIDX]);
+      }
+    }
+
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(
+        random,
+        dir,
+        newIndexWriterConfig(
+            TEST_VERSION_CURRENT,
+            new MockAnalyzer(random)
+        )
+    );
+    boolean canUseDV = !"Lucene3x".equals(writer.w.getConfig().getCodec().getName());
+    boolean useDv = canUseDV && random.nextBoolean();
+
+    Document doc = new Document();
+    Document docNoGroup = new Document();
+    Document docNoFacet = new Document();
+    Document docNoGroupNoFacet = new Document();
+    Field group = newField("group", "", StringField.TYPE_UNSTORED);
+    DocValuesField groupDc = new DocValuesField("group", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);
+    if (useDv) {
+      doc.add(groupDc);
+      docNoFacet.add(groupDc);
+    }
+    doc.add(group);
+    docNoFacet.add(group);
+    Field[] facetFields;
+    if (useDv) {
+      facetFields = new Field[2];
+      facetFields[0] = newField("facet", "", StringField.TYPE_UNSTORED);
+      doc.add(facetFields[0]);
+      docNoGroup.add(facetFields[0]);
+      facetFields[1] = new DocValuesField("facet", new BytesRef(), DocValues.Type.BYTES_VAR_SORTED);
+      doc.add(facetFields[1]);
+      docNoGroup.add(facetFields[1]);
+    } else {
+      facetFields = multipleFacetValuesPerDocument ? new Field[2 + random.nextInt(6)] : new Field[1];
+      for (int i = 0; i < facetFields.length; i++) {
+        facetFields[i] = newField("facet", "", StringField.TYPE_UNSTORED);
+        doc.add(facetFields[i]);
+        docNoGroup.add(facetFields[i]);
+      }
+    }
+    Field content = newField("content", "", StringField.TYPE_UNSTORED);
+    doc.add(content);
+    docNoGroup.add(content);
+    docNoFacet.add(content);
+    docNoGroupNoFacet.add(content);
+
+    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {
+
+      public int compare(String a, String b) {
+        if (a == b) {
+          return 0;
+        } else if (a == null) {
+          return -1;
+        } else if (b == null) {
+          return 1;
+        } else {
+          return a.compareTo(b);
+        }
+      }
+
+    });
+    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();
+    int facetWithMostGroups = 0;
+    for (int i = 0; i < numDocs; i++) {
+      final String groupValue;
+      if (random.nextInt(24) == 17) {
+        // So we test the "doc doesn't have the group'd
+        // field" case:
+        groupValue = null;
+      } else {
+        groupValue = groups.get(random.nextInt(groups.size()));
+      }
+
+      String contentStr = contentBrs[random.nextInt(contentBrs.length)];
+      if (!searchTermToFacetToGroups.containsKey(contentStr)) {
+        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());
+      }
+      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);
+
+      List<String> facetVals = new ArrayList<String>();
+      if (random.nextInt(24) != 18) {
+        if (useDv) {
+          String facetValue = facetValues.get(random.nextInt(facetValues.size()));
+          uniqueFacetValues.add(facetValue);
+          if (!facetToGroups.containsKey(facetValue)) {
+            facetToGroups.put(facetValue, new HashSet<String>());
+          }
+          Set<String> groupsInFacet = facetToGroups.get(facetValue);
+          groupsInFacet.add(groupValue);
+          if (groupsInFacet.size() > facetWithMostGroups) {
+            facetWithMostGroups = groupsInFacet.size();
+          }
+          facetFields[0].setStringValue(facetValue);
+          facetFields[1].setBytesValue(new BytesRef(facetValue));
+          facetVals.add(facetValue);
+        } else {
+          for (Field facetField : facetFields) {
+            String facetValue = facetValues.get(random.nextInt(facetValues.size()));
+            uniqueFacetValues.add(facetValue);
+            if (!facetToGroups.containsKey(facetValue)) {
+              facetToGroups.put(facetValue, new HashSet<String>());
+            }
+            Set<String> groupsInFacet = facetToGroups.get(facetValue);
+            groupsInFacet.add(groupValue);
+            if (groupsInFacet.size() > facetWithMostGroups) {
+              facetWithMostGroups = groupsInFacet.size();
+            }
+            facetField.setStringValue(facetValue);
+            facetVals.add(facetValue);
+          }
+        }
+      } else {
+        uniqueFacetValues.add(null);
+        if (!facetToGroups.containsKey(null)) {
+          facetToGroups.put(null, new HashSet<String>());
+        }
+        Set<String> groupsInFacet = facetToGroups.get(null);
+        groupsInFacet.add(groupValue);
+        if (groupsInFacet.size() > facetWithMostGroups) {
+          facetWithMostGroups = groupsInFacet.size();
+        }
+      }
+
+      if (VERBOSE) {
+        System.out.println("  doc content=" + contentStr + " group=" + (groupValue == null ? "null" : groupValue) + " facetVals=" + facetVals);
+      }
+
+      if (groupValue != null) {
+        if (useDv) {
+          groupDc.setBytesValue(new BytesRef(groupValue));
+        }
+        group.setStringValue(groupValue);
+      }
+      content.setStringValue(contentStr);
+      if (groupValue == null && facetVals.isEmpty()) {
+        writer.addDocument(docNoGroupNoFacet);
+      } else if (facetVals.isEmpty()) {
+        writer.addDocument(docNoFacet);
+      } else if (groupValue == null) {
+        writer.addDocument(docNoGroup);
+      } else {
+        writer.addDocument(doc);
+      }
+    }
+
+    DirectoryReader reader = writer.getReader();
+    writer.close();
+
+    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues, useDv);
+  }
+
+  private GroupedFacetResult createExpectedFacetResult(String searchTerm, IndexContext context, int offset, int limit, int minCount, final boolean orderByCount, String facetPrefix) {
+    Map<String, Set<String>> facetGroups = context.searchTermToFacetGroups.get(searchTerm);
+    if (facetGroups == null) {
+      facetGroups = new HashMap<String, Set<String>>();
+    }
+
+    int totalCount = 0;
+    int totalMissCount = 0;
+    Set<String> facetValues;
+    if (facetPrefix != null) {
+      facetValues = new HashSet<String>();
+      for (String facetValue : context.facetValues) {
+        if (facetValue != null && facetValue.startsWith(facetPrefix)) {
+          facetValues.add(facetValue);
+        }
+      }
+    } else {
+      facetValues = context.facetValues;
+    }
+
+    List<TermGroupFacetCollector.FacetEntry> entries = new ArrayList<TermGroupFacetCollector.FacetEntry>(facetGroups.size());
+    // also includes facets with count 0
+    for (String facetValue : facetValues) {
+      if (facetValue == null) {
+        continue;
+      }
+
+      Set<String> groups = facetGroups.get(facetValue);
+      int count = groups != null ? groups.size() : 0;
+      if (count >= minCount) {
+        entries.add(new TermGroupFacetCollector.FacetEntry(new BytesRef(facetValue), count));
+      }
+      totalCount += count;
+    }
+
+    // Only include null count when no facet prefix is specified
+    if (facetPrefix == null) {
+      Set<String> groups = facetGroups.get(null);
+      if (groups != null) {
+        totalMissCount = groups.size();
+      }
+    }
+
+    Collections.sort(entries, new Comparator<TermGroupFacetCollector.FacetEntry>() {
+
+      public int compare(TermGroupFacetCollector.FacetEntry a, TermGroupFacetCollector.FacetEntry b) {
+        if (orderByCount) {
+          int cmp = b.getCount() - a.getCount();
+          if (cmp != 0) {
+            return cmp;
+          }
+        }
+        return a.getValue().compareTo(b.getValue());
+      }
+
+    });
+
+    int endOffset = offset + limit;
+    List<TermGroupFacetCollector.FacetEntry> entriesResult;
+    if (offset >= entries.size()) {
+      entriesResult = Collections.emptyList();
+    } else if (endOffset >= entries.size()) {
+      entriesResult = entries.subList(offset, entries.size());
+    } else {
+      entriesResult = entries.subList(offset, endOffset);
+    }
+    return new GroupedFacetResult(totalCount, totalMissCount, entriesResult);
+  }
+
+  private AbstractGroupFacetCollector createRandomCollector(String groupField, String facetField, String facetPrefix, boolean multipleFacetsPerDocument, boolean useDv) {
+    BytesRef facetPrefixBR = facetPrefix == null ? null : new BytesRef(facetPrefix);
+    if (useDv) {
+      return DVGroupFacetCollector.createDvGroupFacetCollector(groupField, DocValues.Type.BYTES_VAR_SORTED,
+          random.nextBoolean(), facetField, DocValues.Type.BYTES_VAR_SORTED, random.nextBoolean(), facetPrefixBR, random.nextInt(1024));
+    } else {
+      return TermGroupFacetCollector.createTermGroupFacetCollector(groupField, facetField, multipleFacetsPerDocument, facetPrefixBR, random.nextInt(1024));
+    }
+  }
+
+  private String getFromSet(Set<String> set, int index) {
+    int currentIndex = 0;
+    for (String bytesRef : set) {
+      if (currentIndex++ == index) {
+        return bytesRef;
+      }
+    }
+
+    return null;
+  }
+
+  private class IndexContext {
+
+    final int numDocs;
+    final DirectoryReader indexReader;
+    final Map<String, Map<String, Set<String>>> searchTermToFacetGroups;
+    final NavigableSet<String> facetValues;
+    final Directory dir;
+    final int facetWithMostGroups;
+    final int numGroups;
+    final String[] contentStrings;
+    final boolean useDV;
+
+    public IndexContext(Map<String, Map<String, Set<String>>> searchTermToFacetGroups, DirectoryReader r,
+                        int numDocs, Directory dir, int facetWithMostGroups, int numGroups, String[] contentStrings, NavigableSet<String> facetValues, boolean useDV) {
+      this.searchTermToFacetGroups = searchTermToFacetGroups;
+      this.indexReader = r;
+      this.numDocs = numDocs;
+      this.dir = dir;
+      this.facetWithMostGroups = facetWithMostGroups;
+      this.numGroups = numGroups;
+      this.contentStrings = contentStrings;
+      this.facetValues = facetValues;
+      this.useDV = useDV;
+    }
+  }
+
+  private class GroupedFacetResult {
+
+    final int totalCount;
+    final int totalMissingCount;
+    final List<TermGroupFacetCollector.FacetEntry> facetEntries;
+
+    private GroupedFacetResult(int totalCount, int totalMissingCount, List<TermGroupFacetCollector.FacetEntry> facetEntries) {
+      this.totalCount = totalCount;
+      this.totalMissingCount = totalMissingCount;
+      this.facetEntries = facetEntries;
+    }
+
+    public int getTotalCount() {
+      return totalCount;
+    }
+
+    public int getTotalMissingCount() {
+      return totalMissingCount;
+    }
+
+    public List<TermGroupFacetCollector.FacetEntry> getFacetEntries() {
+      return facetEntries;
+    }
+  }
+
+}
diff --git a/modules/grouping/src/test/org/apache/lucene/search/grouping/TermGroupFacetCollectorTest.java b/modules/grouping/src/test/org/apache/lucene/search/grouping/TermGroupFacetCollectorTest.java
deleted file mode 100644
index 4dfea35..0000000
--- a/modules/grouping/src/test/org/apache/lucene/search/grouping/TermGroupFacetCollectorTest.java
+++ /dev/null
@@ -1,600 +0,0 @@
-package org.apache.lucene.search.grouping;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.*;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.DocValues;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.grouping.term.TermGroupFacetCollector;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util._TestUtil;
-
-import java.io.IOException;
-import java.util.*;
-
-public class TermGroupFacetCollectorTest extends AbstractGroupingTestCase {
-
-  public void testSimple() throws Exception {
-    final String groupField = "hotel";
-    FieldType customType = new FieldType();
-    customType.setStored(true);
-
-    Directory dir = newDirectory();
-    RandomIndexWriter w = new RandomIndexWriter(
-        random,
-        dir,
-        newIndexWriterConfig(TEST_VERSION_CURRENT,
-            new MockAnalyzer(random)).setMergePolicy(newLogMergePolicy()));
-    boolean canUseIDV = false;// Enable later... !"Lucene3x".equals(w.w.getConfig().getCodec().getName());
-
-    // 0
-    Document doc = new Document();
-    addGroupField(doc, groupField, "a", canUseIDV);
-    doc.add(new Field("airport", "ams", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "5", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 1
-    doc = new Document();
-    addGroupField(doc, groupField, "a", canUseIDV);
-    doc.add(new Field("airport", "dus", TextField.TYPE_STORED));
-    doc.add(new Field("duration", "10", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 2
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("airport", "ams", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "10", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-    w.commit(); // To ensure a second segment
-
-    // 3
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("airport", "ams", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "5", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 4
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("airport", "ams", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "5", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    IndexSearcher indexSearcher = new IndexSearcher(w.getReader());
-    TermGroupFacetCollector groupedAirportFacetCollector =
-        TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "airport", false, null, 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
-    TermGroupFacetCollector.GroupedFacetResult airportResult = groupedAirportFacetCollector.mergeSegmentResults(10, 0, false);
-    assertEquals(3, airportResult.getTotalCount());
-    assertEquals(0, airportResult.getTotalMissingCount());
-
-    List<TermGroupFacetCollector.FacetEntry> entries = airportResult.getFacetEntries(0, 10);
-    assertEquals(2, entries.size());
-    assertEquals("ams", entries.get(0).getValue().utf8ToString());
-    assertEquals(2, entries.get(0).getCount());
-    assertEquals("dus", entries.get(1).getValue().utf8ToString());
-    assertEquals(1, entries.get(1).getCount());
-
-
-    TermGroupFacetCollector groupedDurationFacetCollector =
-        TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "duration", false, null, 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
-    TermGroupFacetCollector.GroupedFacetResult durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 0, false);
-    assertEquals(4, durationResult.getTotalCount());
-    assertEquals(0, durationResult.getTotalMissingCount());
-
-    entries = durationResult.getFacetEntries(0, 10);
-    assertEquals(2, entries.size());
-    assertEquals("10", entries.get(0).getValue().utf8ToString());
-    assertEquals(2, entries.get(0).getCount());
-    assertEquals("5", entries.get(1).getValue().utf8ToString());
-    assertEquals(2, entries.get(1).getCount());
-
-    // 5
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("duration", "5", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 6
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("airport", "bru", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "10", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 7
-    doc = new Document();
-    addGroupField(doc, groupField, "b", canUseIDV);
-    doc.add(new Field("airport", "bru", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "15", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 8
-    doc = new Document();
-    addGroupField(doc, groupField, "a", canUseIDV);
-    doc.add(new Field("airport", "bru", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "10", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    indexSearcher.getIndexReader().close();
-    indexSearcher = new IndexSearcher(w.getReader());
-    groupedAirportFacetCollector = TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "airport", true, null, 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
-    airportResult = groupedAirportFacetCollector.mergeSegmentResults(3, 0, true);
-    assertEquals(5, airportResult.getTotalCount());
-    assertEquals(1, airportResult.getTotalMissingCount());
-
-    entries = airportResult.getFacetEntries(1, 2);
-    assertEquals(2, entries.size());
-    assertEquals("bru", entries.get(0).getValue().utf8ToString());
-    assertEquals(2, entries.get(0).getCount());
-    assertEquals("dus", entries.get(1).getValue().utf8ToString());
-    assertEquals(1, entries.get(1).getCount());
-
-    groupedDurationFacetCollector = TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "duration", false, null, 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
-    durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 2, true);
-    assertEquals(5, durationResult.getTotalCount());
-    assertEquals(0, durationResult.getTotalMissingCount());
-
-    entries = durationResult.getFacetEntries(1, 1);
-    assertEquals(1, entries.size());
-    assertEquals("5", entries.get(0).getValue().utf8ToString());
-    assertEquals(2, entries.get(0).getCount());
-
-    // 9
-    doc = new Document();
-    addGroupField(doc, groupField, "c", canUseIDV);
-    doc.add(new Field("airport", "bru", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "15", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    // 10
-    doc = new Document();
-    addGroupField(doc, groupField, "c", canUseIDV);
-    doc.add(new Field("airport", "dus", TextField.TYPE_UNSTORED));
-    doc.add(new Field("duration", "10", TextField.TYPE_UNSTORED));
-    w.addDocument(doc);
-
-    indexSearcher.getIndexReader().close();
-    indexSearcher = new IndexSearcher(w.getReader());
-    groupedAirportFacetCollector = TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "airport", false, null, 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedAirportFacetCollector);
-    airportResult = groupedAirportFacetCollector.mergeSegmentResults(10, 0, false);
-    assertEquals(7, airportResult.getTotalCount());
-    assertEquals(1, airportResult.getTotalMissingCount());
-
-    entries = airportResult.getFacetEntries(0, 10);
-    assertEquals(3, entries.size());
-    assertEquals("ams", entries.get(0).getValue().utf8ToString());
-    assertEquals(2, entries.get(0).getCount());
-    assertEquals("bru", entries.get(1).getValue().utf8ToString());
-    assertEquals(3, entries.get(1).getCount());
-    assertEquals("dus", entries.get(2).getValue().utf8ToString());
-    assertEquals(2, entries.get(2).getCount());
-
-    groupedDurationFacetCollector = TermGroupFacetCollector.createTermGroupFacetCollector(groupField, "duration", false, new BytesRef("1"), 128);
-    indexSearcher.search(new MatchAllDocsQuery(), groupedDurationFacetCollector);
-    durationResult = groupedDurationFacetCollector.mergeSegmentResults(10, 0, true);
-    assertEquals(5, durationResult.getTotalCount());
-    assertEquals(0, durationResult.getTotalMissingCount());
-
-    entries = durationResult.getFacetEntries(0, 10);
-    assertEquals(2, entries.size());
-    assertEquals("10", entries.get(0).getValue().utf8ToString());
-    assertEquals(3, entries.get(0).getCount());
-    assertEquals("15", entries.get(1).getValue().utf8ToString());
-    assertEquals(2, entries.get(1).getCount());
-
-    w.close();
-    indexSearcher.getIndexReader().close();
-    dir.close();
-  }
-
-  private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
-    doc.add(new Field(groupField, value, TextField.TYPE_UNSTORED));
-    if (canUseIDV) {
-      doc.add(new DocValuesField(groupField, new BytesRef(value), DocValues.Type.BYTES_VAR_SORTED));
-    }
-  }
-
-  public void testRandom() throws Exception {
-    int numberOfRuns = _TestUtil.nextInt(random, 3, 6);
-    for (int indexIter = 0; indexIter < numberOfRuns; indexIter++) {
-      boolean multipleFacetsPerDocument = random.nextBoolean();
-      IndexContext context = createIndexContext(multipleFacetsPerDocument);
-      final IndexSearcher searcher = newSearcher(context.indexReader);
-
-      for (int searchIter = 0; searchIter < 100; searchIter++) {
-        String searchTerm = context.contentStrings[random.nextInt(context.contentStrings.length)];
-        int limit = random.nextInt(context.facetValues.size());
-        int offset = random.nextInt(context.facetValues.size() - limit);
-        int size = offset + limit;
-        int minCount = random.nextBoolean() ? 0 : random.nextInt(1 + context.facetWithMostGroups / 10);
-        boolean orderByCount = random.nextBoolean();
-        String randomStr = getFromSet(context.facetValues, random.nextInt(context.facetValues.size()));
-        final String facetPrefix;
-        if (randomStr == null) {
-          facetPrefix = null;
-        } else {
-          int codePointLen = randomStr.codePointCount(0, randomStr.length());
-          int randomLen = random.nextInt(codePointLen);
-          if (codePointLen == randomLen - 1) {
-            facetPrefix = null;
-          } else {
-            int end = randomStr.offsetByCodePoints(0, randomLen);
-            facetPrefix = random.nextBoolean() ? null : randomStr.substring(end);
-          }
-        }
-
-        GroupedFacetResult expectedFacetResult = createExpectedFacetResult(searchTerm, context, offset, limit, minCount, orderByCount, facetPrefix);
-        TermGroupFacetCollector groupFacetCollector = createRandomCollector("group", "facet", facetPrefix, multipleFacetsPerDocument);
-        searcher.search(new TermQuery(new Term("content", searchTerm)), groupFacetCollector);
-        TermGroupFacetCollector.GroupedFacetResult actualFacetResult = groupFacetCollector.mergeSegmentResults(size, minCount, orderByCount);
-
-        List<TermGroupFacetCollector.FacetEntry> expectedFacetEntries = expectedFacetResult.getFacetEntries();
-        List<TermGroupFacetCollector.FacetEntry> actualFacetEntries = actualFacetResult.getFacetEntries(offset, limit);
-
-        if (VERBOSE) {
-          System.out.println("Collector: " + groupFacetCollector.getClass().getSimpleName());
-          System.out.println("Num group: " + context.numGroups);
-          System.out.println("Num doc: " + context.numDocs);
-          System.out.println("Index iter: " + indexIter);
-          System.out.println("multipleFacetsPerDocument: " + multipleFacetsPerDocument);
-          System.out.println("Search iter: " + searchIter);
-
-          System.out.println("Search term: " + searchTerm);
-          System.out.println("Min count: " + minCount);
-          System.out.println("Facet offset: " + offset);
-          System.out.println("Facet limit: " + limit);
-          System.out.println("Facet prefix: " + facetPrefix);
-          System.out.println("Order by count: " + orderByCount);
-
-          System.out.println("\n=== Expected: \n");
-          System.out.println("Total count " + expectedFacetResult.getTotalCount());
-          System.out.println("Total missing count " + expectedFacetResult.getTotalMissingCount());
-          int counter = 1;
-          for (TermGroupFacetCollector.FacetEntry expectedFacetEntry : expectedFacetEntries) {
-            System.out.println(
-                String.format(
-                    "%d. Expected facet value %s with count %d",
-                    counter++, expectedFacetEntry.getValue().utf8ToString(), expectedFacetEntry.getCount()
-                )
-            );
-          }
-
-          System.out.println("\n=== Actual: \n");
-          System.out.println("Total count " + actualFacetResult.getTotalCount());
-          System.out.println("Total missing count " + actualFacetResult.getTotalMissingCount());
-          counter = 1;
-          for (TermGroupFacetCollector.FacetEntry actualFacetEntry : actualFacetEntries) {
-            System.out.println(
-                String.format(
-                    "%d. Actual facet value %s with count %d",
-                    counter++, actualFacetEntry.getValue().utf8ToString(), actualFacetEntry.getCount()
-                )
-            );
-          }
-          System.out.println("\n===================================================================================");
-        }
-
-        assertEquals(expectedFacetResult.getTotalCount(), actualFacetResult.getTotalCount());
-        assertEquals(expectedFacetResult.getTotalMissingCount(), actualFacetResult.getTotalMissingCount());
-        assertEquals(expectedFacetEntries.size(), actualFacetEntries.size());
-        for (int i = 0; i < expectedFacetEntries.size(); i++) {
-          TermGroupFacetCollector.FacetEntry expectedFacetEntry = expectedFacetEntries.get(i);
-          TermGroupFacetCollector.FacetEntry actualFacetEntry = actualFacetEntries.get(i);
-          assertEquals(expectedFacetEntry.getValue().utf8ToString() + " != " + actualFacetEntry.getValue().utf8ToString(), expectedFacetEntry.getValue(), actualFacetEntry.getValue());
-          assertEquals(expectedFacetEntry.getCount() + " != " + actualFacetEntry.getCount(), expectedFacetEntry.getCount(), actualFacetEntry.getCount());
-        }
-      }
-
-      context.indexReader.close();
-      context.dir.close();
-    }
-  }
-
-  private IndexContext createIndexContext(boolean multipleFacetValuesPerDocument) throws IOException {
-    final int numDocs = _TestUtil.nextInt(random, 138, 1145) * RANDOM_MULTIPLIER;
-    final int numGroups = _TestUtil.nextInt(random, 1, numDocs / 4);
-    final int numFacets = _TestUtil.nextInt(random, 1, numDocs / 6);
-
-    if (VERBOSE) {
-      System.out.println("TEST: numDocs=" + numDocs + " numGroups=" + numGroups);
-    }
-
-    final List<String> groups = new ArrayList<String>();
-    for (int i = 0; i < numGroups; i++) {
-      groups.add(generateRandomNonEmptyString());
-    }
-    final List<String> facetValues = new ArrayList<String>();
-    for (int i = 0; i < numFacets; i++) {
-      facetValues.add(generateRandomNonEmptyString());
-    }
-    final String[] contentBrs = new String[_TestUtil.nextInt(random, 2, 20)];
-    if (VERBOSE) {
-      System.out.println("TEST: create fake content");
-    }
-    for (int contentIDX = 0; contentIDX < contentBrs.length; contentIDX++) {
-      contentBrs[contentIDX] = generateRandomNonEmptyString();
-      if (VERBOSE) {
-        System.out.println("  content=" + contentBrs[contentIDX]);
-      }
-    }
-
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(
-        random,
-        dir,
-        newIndexWriterConfig(
-            TEST_VERSION_CURRENT,
-            new MockAnalyzer(random)
-        )
-    );
-
-    Document doc = new Document();
-    Document docNoGroup = new Document();
-    Document docNoFacet = new Document();
-    Document docNoGroupNoFacet = new Document();
-    Field group = newField("group", "", StringField.TYPE_UNSTORED);
-    doc.add(group);
-    docNoFacet.add(group);
-    Field[] facetFields = multipleFacetValuesPerDocument? new Field[2 + random.nextInt(6)] : new Field[1];
-    for (int i = 0; i < facetFields.length; i++) {
-      facetFields[i] = newField("facet", "", StringField.TYPE_UNSTORED);
-      doc.add(facetFields[i]);
-      docNoGroup.add(facetFields[i]);
-    }
-    Field content = newField("content", "", StringField.TYPE_UNSTORED);
-    doc.add(content);
-    docNoGroup.add(content);
-    docNoFacet.add(content);
-    docNoGroupNoFacet.add(content);
-
-    NavigableSet<String> uniqueFacetValues = new TreeSet<String>(new Comparator<String>() {
-
-      public int compare(String a, String b) {
-        if (a == b) {
-          return 0;
-        } else if (a == null) {
-          return -1;
-        } else if (b == null) {
-          return 1;
-        } else {
-          return a.compareTo(b);
-        }
-      }
-
-    });
-    Map<String, Map<String, Set<String>>> searchTermToFacetToGroups = new HashMap<String, Map<String, Set<String>>>();
-    int facetWithMostGroups = 0;
-    for (int i = 0; i < numDocs; i++) {
-      final String groupValue;
-      if (random.nextInt(24) == 17) {
-        // So we test the "doc doesn't have the group'd
-        // field" case:
-        groupValue = null;
-      } else {
-        groupValue = groups.get(random.nextInt(groups.size()));
-      }
-
-      String contentStr = contentBrs[random.nextInt(contentBrs.length)];
-      if (!searchTermToFacetToGroups.containsKey(contentStr)) {
-        searchTermToFacetToGroups.put(contentStr, new HashMap<String, Set<String>>());
-      }
-      Map<String, Set<String>> facetToGroups = searchTermToFacetToGroups.get(contentStr);
-
-      List<String> facetVals = new ArrayList<String>();
-      if (random.nextInt(24) != 18) {
-        for (Field facetField : facetFields) {
-          String facetValue = facetValues.get(random.nextInt(facetValues.size()));
-          uniqueFacetValues.add(facetValue);
-          if (!facetToGroups.containsKey(facetValue)) {
-            facetToGroups.put(facetValue, new HashSet<String>());
-          }
-          Set<String> groupsInFacet = facetToGroups.get(facetValue);
-          groupsInFacet.add(groupValue);
-          if (groupsInFacet.size() > facetWithMostGroups) {
-            facetWithMostGroups = groupsInFacet.size();
-          }
-          facetField.setStringValue(facetValue);
-          facetVals.add(facetValue);
-        }
-      } else {
-        uniqueFacetValues.add(null);
-        if (!facetToGroups.containsKey(null)) {
-          facetToGroups.put(null, new HashSet<String>());
-        }
-        Set<String> groupsInFacet = facetToGroups.get(null);
-        groupsInFacet.add(groupValue);
-        if (groupsInFacet.size() > facetWithMostGroups) {
-          facetWithMostGroups = groupsInFacet.size();
-        }
-      }
-
-      if (VERBOSE) {
-        System.out.println("  doc content=" + contentStr + " group=" + (groupValue == null ? "null" : groupValue) + " facetVals=" + facetVals);
-      }
-
-      if (groupValue != null) {
-        group.setStringValue(groupValue);
-      }
-      content.setStringValue(contentStr);
-      if (groupValue == null && facetVals.isEmpty()) {
-        writer.addDocument(docNoGroupNoFacet);
-      } else if (facetVals.isEmpty()) {
-        writer.addDocument(docNoFacet);
-      } else if (groupValue == null) {
-        writer.addDocument(docNoGroup);
-      } else {
-        writer.addDocument(doc);
-      }
-    }
-
-    DirectoryReader reader = writer.getReader();
-    writer.close();
-
-    return new IndexContext(searchTermToFacetToGroups, reader, numDocs, dir, facetWithMostGroups, numGroups, contentBrs, uniqueFacetValues);
-  }
-
-  private GroupedFacetResult createExpectedFacetResult(String searchTerm, IndexContext context, int offset, int limit, int minCount, final boolean orderByCount, String facetPrefix) {
-    Map<String, Set<String>> facetGroups = context.searchTermToFacetGroups.get(searchTerm);
-    if (facetGroups == null) {
-      facetGroups = new HashMap<String, Set<String>>();
-    }
-
-    int totalCount = 0;
-    int totalMissCount = 0;
-    Set<String> facetValues;
-    if (facetPrefix != null) {
-      facetValues = new HashSet<String>();
-      for (String facetValue : context.facetValues) {
-        if (facetValue != null && facetValue.startsWith(facetPrefix)) {
-          facetValues.add(facetValue);
-        }
-      }
-    } else {
-      facetValues = context.facetValues;
-    }
-
-    List<TermGroupFacetCollector.FacetEntry> entries = new ArrayList<TermGroupFacetCollector.FacetEntry>(facetGroups.size());
-    // also includes facets with count 0
-    for (String facetValue : facetValues) {
-      if (facetValue == null) {
-        continue;
-      }
-
-      Set<String> groups = facetGroups.get(facetValue);
-      int count = groups != null ? groups.size() : 0;
-      if (count >= minCount) {
-        entries.add(new TermGroupFacetCollector.FacetEntry(new BytesRef(facetValue), count));
-      }
-      totalCount += count;
-    }
-
-    // Only include null count when no facet prefix is specified
-    if (facetPrefix == null) {
-      Set<String> groups = facetGroups.get(null);
-      if (groups != null) {
-        totalMissCount = groups.size();
-      }
-    }
-
-    Collections.sort(entries, new Comparator<TermGroupFacetCollector.FacetEntry>() {
-
-      public int compare(TermGroupFacetCollector.FacetEntry a, TermGroupFacetCollector.FacetEntry b) {
-        if (orderByCount) {
-          int cmp = b.getCount() - a.getCount();
-          if (cmp != 0) {
-            return cmp;
-          }
-        }
-        return a.getValue().compareTo(b.getValue());
-      }
-
-    });
-
-    int endOffset = offset + limit;
-    List<TermGroupFacetCollector.FacetEntry> entriesResult;
-    if (offset >= entries.size()) {
-      entriesResult = Collections.emptyList();
-    } else if (endOffset >= entries.size()) {
-      entriesResult = entries.subList(offset, entries.size());
-    } else {
-      entriesResult = entries.subList(offset, endOffset);
-    }
-    return new GroupedFacetResult(totalCount, totalMissCount, entriesResult);
-  }
-
-  private TermGroupFacetCollector createRandomCollector(String groupField, String facetField, String facetPrefix, boolean multipleFacetsPerDocument) {
-    BytesRef facetPrefixBR = facetPrefix == null ? null : new BytesRef(facetPrefix);
-    return TermGroupFacetCollector.createTermGroupFacetCollector(groupField, facetField, multipleFacetsPerDocument, facetPrefixBR, random.nextInt(1024));
-  }
-
-  private String getFromSet(Set<String> set, int index) {
-    int currentIndex = 0;
-    for (String bytesRef : set) {
-      if (currentIndex++ == index) {
-        return bytesRef;
-      }
-    }
-
-    return null;
-  }
-
-  private class IndexContext {
-
-    final int numDocs;
-    final DirectoryReader indexReader;
-    final Map<String, Map<String, Set<String>>> searchTermToFacetGroups;
-    final NavigableSet<String> facetValues;
-    final Directory dir;
-    final int facetWithMostGroups;
-    final int numGroups;
-    final String[] contentStrings;
-
-    public IndexContext(Map<String, Map<String, Set<String>>> searchTermToFacetGroups, DirectoryReader r,
-                        int numDocs, Directory dir, int facetWithMostGroups, int numGroups, String[] contentStrings, NavigableSet<String> facetValues) {
-      this.searchTermToFacetGroups = searchTermToFacetGroups;
-      this.indexReader = r;
-      this.numDocs = numDocs;
-      this.dir = dir;
-      this.facetWithMostGroups = facetWithMostGroups;
-      this.numGroups = numGroups;
-      this.contentStrings = contentStrings;
-      this.facetValues = facetValues;
-    }
-  }
-
-  private class GroupedFacetResult {
-
-    final int totalCount;
-    final int totalMissingCount;
-    final List<TermGroupFacetCollector.FacetEntry> facetEntries;
-
-    private GroupedFacetResult(int totalCount, int totalMissingCount, List<TermGroupFacetCollector.FacetEntry> facetEntries) {
-      this.totalCount = totalCount;
-      this.totalMissingCount = totalMissingCount;
-      this.facetEntries = facetEntries;
-    }
-
-    public int getTotalCount() {
-      return totalCount;
-    }
-
-    public int getTotalMissingCount() {
-      return totalMissingCount;
-    }
-
-    public List<TermGroupFacetCollector.FacetEntry> getFacetEntries() {
-      return facetEntries;
-    }
-  }
-
-}

