GitDiffStart: 8571b92efd55e61e923d8a671c1d4b68f2e0d2d7 | Sun Mar 8 20:21:22 2015 +0000
diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
index 580849a..11e693d 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
@@ -107,13 +107,13 @@ public class CoreContainer {
   public static final String COLLECTIONS_HANDLER_PATH = "/admin/collections";
   public static final String INFO_HANDLER_PATH = "/admin/info";
 
-  private PluginRegistry<SolrRequestHandler> containerHandlers = new PluginRegistry<>(SolrRequestHandler.class, null);
+  private PluginBag<SolrRequestHandler> containerHandlers = new PluginBag<>(SolrRequestHandler.class, null);
 
   public SolrRequestHandler getRequestHandler(String path) {
     return RequestHandlerBase.getRequestHandler(path, containerHandlers);
   }
 
-  public PluginRegistry<SolrRequestHandler> getRequestHandlers() {
+  public PluginBag<SolrRequestHandler> getRequestHandlers() {
     return this.containerHandlers;
   }
 
diff --git a/solr/core/src/java/org/apache/solr/core/MemClassLoader.java b/solr/core/src/java/org/apache/solr/core/MemClassLoader.java
index 6c28daf..2e6eb17 100644
--- a/solr/core/src/java/org/apache/solr/core/MemClassLoader.java
+++ b/solr/core/src/java/org/apache/solr/core/MemClassLoader.java
@@ -29,7 +29,6 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.lucene.analysis.util.ResourceLoader;
@@ -42,11 +41,11 @@ public class MemClassLoader extends ClassLoader implements AutoCloseable, Resour
   static final Logger log =  LoggerFactory.getLogger(MemClassLoader.class);
   private boolean allJarsLoaded = false;
   private final SolrResourceLoader parentLoader;
-  private List<PluginRegistry.RuntimeLib> libs = new ArrayList<>();
+  private List<PluginBag.RuntimeLib> libs = new ArrayList<>();
   private Map<String, Class> classCache = new HashMap<>();
 
 
-  public MemClassLoader(List<PluginRegistry.RuntimeLib> libs, SolrResourceLoader resourceLoader) {
+  public MemClassLoader(List<PluginBag.RuntimeLib> libs, SolrResourceLoader resourceLoader) {
     this.parentLoader = resourceLoader;
     this.libs = libs;
   }
@@ -55,7 +54,7 @@ public class MemClassLoader extends ClassLoader implements AutoCloseable, Resour
   public synchronized void loadJars() {
     if (allJarsLoaded) return;
 
-    for (PluginRegistry.RuntimeLib lib : libs) {
+    for (PluginBag.RuntimeLib lib : libs) {
       try {
         lib.loadJar();
       } catch (Exception exception) {
@@ -113,7 +112,7 @@ public class MemClassLoader extends ClassLoader implements AutoCloseable, Resour
 
     String path = name.replace('.', '/').concat(".class");
     ByteBuffer buf = null;
-    for (PluginRegistry.RuntimeLib lib : libs) {
+    for (PluginBag.RuntimeLib lib : libs) {
       try {
         buf = lib.getFileContent(path);
         if (buf != null) {
@@ -130,7 +129,7 @@ public class MemClassLoader extends ClassLoader implements AutoCloseable, Resour
 
   @Override
   public void close() throws Exception {
-    for (PluginRegistry.RuntimeLib lib : libs) {
+    for (PluginBag.RuntimeLib lib : libs) {
       try {
         lib.close();
       } catch (Exception e) {
diff --git a/solr/core/src/java/org/apache/solr/core/PluginBag.java b/solr/core/src/java/org/apache/solr/core/PluginBag.java
new file mode 100644
index 0000000..059df44
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/core/PluginBag.java
@@ -0,0 +1,376 @@
+package org.apache.solr.core;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.analysis.util.ResourceLoader;
+import org.apache.lucene.analysis.util.ResourceLoaderAware;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.handler.RequestHandlerBase;
+import org.apache.solr.handler.component.SearchComponent;
+import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.util.plugin.NamedListInitializedPlugin;
+import org.apache.solr.util.plugin.PluginInfoInitialized;
+import org.apache.solr.util.plugin.SolrCoreAware;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * This manages the lifecycle of a set of plugin of the same type .
+ */
+public class PluginBag<T> implements AutoCloseable {
+  public static Logger log = LoggerFactory.getLogger(PluginBag.class);
+
+  private Map<String, PluginHolder<T>> registry = new HashMap<>();
+  private Map<String, PluginHolder<T>> immutableRegistry = Collections.unmodifiableMap(registry);
+  private String def;
+  private Class klass;
+  private SolrCore core;
+  private SolrConfig.SolrPluginInfo meta;
+
+  public PluginBag(Class<T> klass, SolrCore core) {
+    this.core = core;
+    this.klass = klass;
+    meta = SolrConfig.classVsSolrPluginInfo.get(klass.getName());
+    if (meta == null) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown Plugin : " + klass.getName());
+    }
+  }
+
+  static void initInstance(Object inst, PluginInfo info, SolrCore core) {
+    if (inst instanceof PluginInfoInitialized) {
+      ((PluginInfoInitialized) inst).init(info);
+    } else if (inst instanceof NamedListInitializedPlugin) {
+      ((NamedListInitializedPlugin) inst).init(info.initArgs);
+    } else if (inst instanceof SolrRequestHandler) {
+      ((SolrRequestHandler) inst).init(info.initArgs);
+    }
+    if (inst instanceof SearchComponent) {
+      ((SearchComponent) inst).setName(info.name);
+    }
+    if (inst instanceof RequestHandlerBase) {
+      ((RequestHandlerBase) inst).setPluginInfo(info);
+    }
+
+  }
+
+  PluginHolder<T> createPlugin(PluginInfo info, SolrCore core) {
+    if ("true".equals(String.valueOf(info.attributes.get("runtimeLib")))) {
+      log.info(" {} : '{}'  created with runtimeLib=true ", meta.tag, info.name);
+      return new LazyPluginHolder<>(meta, info, core, core.getMemClassLoader());
+    } else if ("lazy".equals(info.attributes.get("startup")) && meta.options.contains(SolrConfig.PluginOpts.LAZY)) {
+      log.info("{} : '{}' created with startup=lazy ", meta.tag, info.name);
+      return new LazyPluginHolder<T>(meta, info, core, core.getResourceLoader());
+    } else {
+      T inst = core.createInstance(info.className, (Class<T>) meta.clazz, meta.tag, null, core.getResourceLoader());
+      initInstance(inst, info, core);
+      return new PluginHolder<>(info, inst);
+    }
+  }
+
+  boolean alias(String src, String target) {
+    PluginHolder<T> a = registry.get(src);
+    if (a == null) return false;
+    PluginHolder<T> b = registry.get(target);
+    if (b != null) return false;
+    registry.put(target, a);
+    return true;
+  }
+
+  /**
+   * Get a plugin by name. If the plugin is not already instantiated, it is
+   * done here
+   */
+  public T get(String name) {
+    PluginHolder<T> result = registry.get(name);
+    return result == null ? null : result.get();
+  }
+
+  /**
+   * Fetches a plugin by name , or the default
+   *
+   * @param name       name using which it is registered
+   * @param useDefault Return the default , if a plugin by that name does not exist
+   */
+  public T get(String name, boolean useDefault) {
+    T result = get(name);
+    if (useDefault && result == null) return get(def);
+    return result;
+  }
+
+  public Set<String> keySet() {
+    return immutableRegistry.keySet();
+  }
+
+  /**
+   * register a plugin by a name
+   */
+  public T put(String name, T plugin) {
+    if (plugin == null) return null;
+    PluginHolder<T> old = put(name, new PluginHolder<T>(null, plugin));
+    return old == null ? null : old.get();
+  }
+
+
+  PluginHolder<T> put(String name, PluginHolder<T> plugin) {
+    PluginHolder<T> old = registry.put(name, plugin);
+    if (plugin.pluginInfo != null && plugin.pluginInfo.isDefault()) {
+      setDefault(name);
+    }
+    if (plugin.isLoaded()) registerMBean(plugin.get(), core, name);
+    return old;
+  }
+
+  void setDefault(String def) {
+    if (!registry.containsKey(def)) return;
+    if (this.def != null) log.warn("Multiple defaults for : " + meta.tag);
+    this.def = def;
+  }
+
+  public Map<String, PluginHolder<T>> getRegistry() {
+    return immutableRegistry;
+  }
+
+  public boolean contains(String name) {
+    return registry.containsKey(name);
+  }
+
+  String getDefault() {
+    return def;
+  }
+
+  T remove(String name) {
+    PluginHolder<T> removed = registry.remove(name);
+    return removed == null ? null : removed.get();
+  }
+
+  void init(Map<String, T> defaults, SolrCore solrCore) {
+    init(defaults, solrCore, solrCore.getSolrConfig().getPluginInfos(klass.getName()));
+  }
+
+  /**
+   * Initializes the plugins after reading the meta data from {@link org.apache.solr.core.SolrConfig}.
+   *
+   * @param defaults These will be registered if not explicitly specified
+   */
+  void init(Map<String, T> defaults, SolrCore solrCore, List<PluginInfo> infos) {
+    core = solrCore;
+    for (PluginInfo info : infos) {
+      PluginHolder<T> o = createPlugin(info, solrCore);
+      String name = info.name;
+      if (meta.clazz.equals(SolrRequestHandler.class)) name = RequestHandlers.normalize(info.name);
+      PluginHolder<T> old = put(name, o);
+      if (old != null) log.warn("Multiple entries of {} with name {}", meta.tag, name);
+    }
+    for (Map.Entry<String, T> e : defaults.entrySet()) {
+      if (!contains(e.getKey())) {
+        put(e.getKey(), new PluginHolder<T>(null, e.getValue()));
+      }
+    }
+  }
+
+  /**
+   * To check if a plugin by a specified name is already loaded
+   */
+  public boolean isLoaded(String name) {
+    PluginHolder<T> result = registry.get(name);
+    if (result == null) return false;
+    return result.isLoaded();
+  }
+
+  private static void registerMBean(Object inst, SolrCore core, String pluginKey) {
+    if (core == null) return;
+    if (inst instanceof SolrInfoMBean) {
+      SolrInfoMBean mBean = (SolrInfoMBean) inst;
+      String name = (inst instanceof SolrRequestHandler) ? pluginKey : mBean.getName();
+      core.registerInfoBean(name, mBean);
+    }
+  }
+
+
+  /**
+   * Close this registry. This will in turn call a close on all the contained plugins
+   */
+  @Override
+  public void close() {
+    for (Map.Entry<String, PluginHolder<T>> e : registry.entrySet()) {
+      try {
+        e.getValue().close();
+      } catch (Exception exp) {
+        log.error("Error closing plugin " + e.getKey() + " of type : " + meta.tag, exp);
+      }
+    }
+  }
+
+  /**
+   * An indirect reference to a plugin. It just wraps a plugin instance.
+   * subclasses may choose to lazily load the plugin
+   */
+  public static class PluginHolder<T> implements AutoCloseable {
+    protected T inst;
+    protected final PluginInfo pluginInfo;
+
+    public PluginHolder(PluginInfo info) {
+      this.pluginInfo = info;
+    }
+
+    public PluginHolder(PluginInfo info, T inst) {
+      this.inst = inst;
+      this.pluginInfo = info;
+    }
+
+    public T get() {
+      return inst;
+    }
+
+    public boolean isLoaded() {
+      return inst != null;
+    }
+
+    @Override
+    public void close() throws Exception {
+      if (inst != null && inst instanceof AutoCloseable) ((AutoCloseable) inst).close();
+
+    }
+  }
+
+  /**
+   * A class that loads plugins Lazily. When the get() method is invoked
+   * the Plugin is initialized and returned.
+   */
+  public static class LazyPluginHolder<T> extends PluginHolder<T> {
+    private final SolrConfig.SolrPluginInfo pluginMeta;
+    protected SolrException solrException;
+    private final SolrCore core;
+    protected ResourceLoader resourceLoader;
+
+
+    LazyPluginHolder(SolrConfig.SolrPluginInfo pluginMeta, PluginInfo pluginInfo, SolrCore core, ResourceLoader loader) {
+      super(pluginInfo);
+      this.pluginMeta = pluginMeta;
+      this.core = core;
+      this.resourceLoader = loader;
+      if (loader instanceof MemClassLoader) {
+        if (!"true".equals(System.getProperty("enable.runtime.lib"))) {
+          String s = "runtime library loading is not enabled, start Solr with -Denable.runtime.lib=true";
+          log.warn(s);
+          solrException = new SolrException(SolrException.ErrorCode.SERVER_ERROR, s);
+        }
+      }
+    }
+
+    @Override
+    public T get() {
+      if (inst != null) return inst;
+      if (solrException != null) throw solrException;
+      createInst();
+      registerMBean(inst, core, pluginInfo.name);
+      return inst;
+    }
+
+    protected synchronized void createInst() {
+      if (inst != null) return;
+      log.info("Going to create a new {} with {} ", pluginMeta.tag, pluginInfo.toString());
+      if (resourceLoader instanceof MemClassLoader) {
+        MemClassLoader loader = (MemClassLoader) resourceLoader;
+        loader.loadJars();
+      }
+      Class<T> clazz = (Class<T>) pluginMeta.clazz;
+      inst = core.createInstance(pluginInfo.className, clazz, pluginMeta.tag, null, resourceLoader);
+      initInstance(inst, pluginInfo, core);
+      if (inst instanceof SolrCoreAware) {
+        SolrResourceLoader.assertAwareCompatibility(SolrCoreAware.class, inst);
+        ((SolrCoreAware) inst).inform(core);
+      }
+      if (inst instanceof ResourceLoaderAware) {
+        SolrResourceLoader.assertAwareCompatibility(ResourceLoaderAware.class, inst);
+        try {
+          ((ResourceLoaderAware) inst).inform(core.getResourceLoader());
+        } catch (IOException e) {
+          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "error initializing component", e);
+        }
+      }
+    }
+
+
+  }
+
+  /**
+   * This represents a Runtime Jar. A jar requires two details , name and version
+   */
+  public static class RuntimeLib implements PluginInfoInitialized, AutoCloseable {
+    String name;
+    String version;
+    private JarRepository.JarContentRef jarContent;
+    private final JarRepository jarRepository;
+
+    @Override
+    public void init(PluginInfo info) {
+      name = info.attributes.get("name");
+      Object v = info.attributes.get("version");
+      if (name == null || v == null) {
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "runtimeLib must have name and version");
+      }
+      version = String.valueOf(v);
+    }
+
+    public RuntimeLib(SolrCore core) {
+      jarRepository = core.getCoreDescriptor().getCoreContainer().getJarRepository();
+    }
+
+
+    void loadJar() {
+      if (jarContent != null) return;
+      synchronized (this) {
+        if (jarContent != null) return;
+        jarContent = jarRepository.getJarIncRef(name + "/" + version);
+      }
+    }
+
+    public ByteBuffer getFileContent(String entryName) throws IOException {
+      if (jarContent == null)
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "jar not available: " + name + "/" + version);
+      return jarContent.jar.getFileContent(entryName);
+
+    }
+
+    @Override
+    public void close() throws Exception {
+      if (jarContent != null) jarRepository.decrementJarRefCount(jarContent);
+    }
+
+    public static List<RuntimeLib> getLibObjects(SolrCore core, List<PluginInfo> libs) {
+      List<RuntimeLib> l = new ArrayList<>(libs.size());
+      for (PluginInfo lib : libs) {
+        RuntimeLib rtl = new RuntimeLib(core);
+        rtl.init(lib);
+        l.add(rtl);
+      }
+      return l;
+    }
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/core/PluginRegistry.java b/solr/core/src/java/org/apache/solr/core/PluginRegistry.java
deleted file mode 100644
index 850d44e..0000000
--- a/solr/core/src/java/org/apache/solr/core/PluginRegistry.java
+++ /dev/null
@@ -1,378 +0,0 @@
-package org.apache.solr.core;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.analysis.util.ResourceLoader;
-import org.apache.lucene.analysis.util.ResourceLoaderAware;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.handler.RequestHandlerBase;
-import org.apache.solr.handler.component.SearchComponent;
-import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.util.plugin.NamedListInitializedPlugin;
-import org.apache.solr.util.plugin.PluginInfoInitialized;
-import org.apache.solr.util.plugin.SolrCoreAware;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import static java.util.Collections.singletonList;
-
-/**
- * This manages the lifecycle of a set of plugin of the same type .
- */
-public class PluginRegistry<T> implements AutoCloseable {
-  public static Logger log = LoggerFactory.getLogger(PluginRegistry.class);
-
-  private Map<String, PluginHolder<T>> registry = new HashMap<>();
-  private Map<String, PluginHolder<T>> immutableRegistry = Collections.unmodifiableMap(registry);
-  private String def;
-  private Class klass;
-  private SolrCore core;
-  private SolrConfig.SolrPluginInfo meta;
-
-  public PluginRegistry(Class<T> klass, SolrCore core) {
-    this.core = core;
-    this.klass = klass;
-    meta = SolrConfig.classVsSolrPluginInfo.get(klass.getName());
-    if (meta == null) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown Plugin : " + klass.getName());
-    }
-  }
-
-  static void initInstance(Object inst, PluginInfo info, SolrCore core) {
-    if (inst instanceof PluginInfoInitialized) {
-      ((PluginInfoInitialized) inst).init(info);
-    } else if (inst instanceof NamedListInitializedPlugin) {
-      ((NamedListInitializedPlugin) inst).init(info.initArgs);
-    } else if (inst instanceof SolrRequestHandler) {
-      ((SolrRequestHandler) inst).init(info.initArgs);
-    }
-    if (inst instanceof SearchComponent) {
-      ((SearchComponent) inst).setName(info.name);
-    }
-    if (inst instanceof RequestHandlerBase) {
-      ((RequestHandlerBase) inst).setPluginInfo(info);
-    }
-
-  }
-
-  PluginHolder<T> createPlugin(PluginInfo info, SolrCore core) {
-    if ("true".equals(String.valueOf(info.attributes.get("runtimeLib")))) {
-      log.info(" {} : '{}'  created with runtimeLib=true ", meta.tag, info.name);
-      return new LazyPluginHolder<>(meta, info, core, core.getMemClassLoader());
-    } else if ("lazy".equals(info.attributes.get("startup")) && meta.options.contains(SolrConfig.PluginOpts.LAZY)) {
-      log.info("{} : '{}' created with startup=lazy ", meta.tag, info.name);
-      return new LazyPluginHolder<T>(meta, info, core, core.getResourceLoader());
-    } else {
-      T inst = core.createInstance(info.className, (Class<T>) meta.clazz, meta.tag, null, core.getResourceLoader());
-      initInstance(inst, info, core);
-      return new PluginHolder<>(info, inst);
-    }
-  }
-
-  boolean alias(String src, String target) {
-    PluginHolder<T> a = registry.get(src);
-    if (a == null) return false;
-    PluginHolder<T> b = registry.get(target);
-    if (b != null) return false;
-    registry.put(target, a);
-    return true;
-  }
-
-  /**
-   * Get a plugin by name. If the plugin is not already instantiated, it is
-   * done here
-   */
-  public T get(String name) {
-    PluginHolder<T> result = registry.get(name);
-    return result == null ? null : result.get();
-  }
-
-  /**
-   * Fetches a plugin by name , or the default
-   *
-   * @param name       name using which it is registered
-   * @param useDefault Return the default , if a plugin by that name does not exist
-   */
-  public T get(String name, boolean useDefault) {
-    T result = get(name);
-    if (useDefault && result == null) return get(def);
-    return result;
-  }
-
-  public Set<String> keySet() {
-    return immutableRegistry.keySet();
-  }
-
-  /**
-   * register a plugin by a name
-   */
-  public T put(String name, T plugin) {
-    if (plugin == null) return null;
-    PluginHolder<T> old = put(name, new PluginHolder<T>(null, plugin));
-    return old == null ? null : old.get();
-  }
-
-
-  PluginHolder<T> put(String name, PluginHolder<T> plugin) {
-    PluginHolder<T> old = registry.put(name, plugin);
-    if (plugin.pluginInfo != null && plugin.pluginInfo.isDefault()) {
-      setDefault(name);
-    }
-    if (plugin.isLoaded()) registerMBean(plugin.get(), core, name);
-    return old;
-  }
-
-  void setDefault(String def) {
-    if (!registry.containsKey(def)) return;
-    if (this.def != null) log.warn("Multiple defaults for : " + meta.tag);
-    this.def = def;
-  }
-
-  public Map<String, PluginHolder<T>> getRegistry() {
-    return immutableRegistry;
-  }
-
-  public boolean contains(String name) {
-    return registry.containsKey(name);
-  }
-
-  String getDefault() {
-    return def;
-  }
-
-  T remove(String name) {
-    PluginHolder<T> removed = registry.remove(name);
-    return removed == null ? null : removed.get();
-  }
-
-  void init(Map<String, T> defaults, SolrCore solrCore) {
-    init(defaults, solrCore, solrCore.getSolrConfig().getPluginInfos(klass.getName()));
-  }
-
-  /**
-   * Initializes the plugins after reading the meta data from {@link org.apache.solr.core.SolrConfig}.
-   *
-   * @param defaults These will be registered if not explicitly specified
-   */
-  void init(Map<String, T> defaults, SolrCore solrCore, List<PluginInfo> infos) {
-    core = solrCore;
-    for (PluginInfo info : infos) {
-      PluginHolder<T> o = createPlugin(info, solrCore);
-      String name = info.name;
-      if (meta.clazz.equals(SolrRequestHandler.class)) name = RequestHandlers.normalize(info.name);
-      PluginHolder<T> old = put(name, o);
-      if (old != null) log.warn("Multiple entries of {} with name {}", meta.tag, name);
-    }
-    for (Map.Entry<String, T> e : defaults.entrySet()) {
-      if (!contains(e.getKey())) {
-        put(e.getKey(), new PluginHolder<T>(null, e.getValue()));
-      }
-    }
-  }
-
-  /**
-   * To check if a plugin by a specified name is already loaded
-   */
-  public boolean isLoaded(String name) {
-    PluginHolder<T> result = registry.get(name);
-    if (result == null) return false;
-    return result.isLoaded();
-  }
-
-  private static void registerMBean(Object inst, SolrCore core, String pluginKey) {
-    if (core == null) return;
-    if (inst instanceof SolrInfoMBean) {
-      SolrInfoMBean mBean = (SolrInfoMBean) inst;
-      String name = (inst instanceof SolrRequestHandler) ? pluginKey : mBean.getName();
-      core.registerInfoBean(name, mBean);
-    }
-  }
-
-
-  /**
-   * Close this registry. This will in turn call a close on all the contained plugins
-   */
-  @Override
-  public void close() {
-    for (Map.Entry<String, PluginHolder<T>> e : registry.entrySet()) {
-      try {
-        e.getValue().close();
-      } catch (Exception exp) {
-        log.error("Error closing plugin " + e.getKey() + " of type : " + meta.tag, exp);
-      }
-    }
-  }
-
-  /**
-   * An indirect reference to a plugin. It just wraps a plugin instance.
-   * subclasses may choose to lazily load the plugin
-   */
-  public static class PluginHolder<T> implements AutoCloseable {
-    protected T inst;
-    protected final PluginInfo pluginInfo;
-
-    public PluginHolder(PluginInfo info) {
-      this.pluginInfo = info;
-    }
-
-    public PluginHolder(PluginInfo info, T inst) {
-      this.inst = inst;
-      this.pluginInfo = info;
-    }
-
-    public T get() {
-      return inst;
-    }
-
-    public boolean isLoaded() {
-      return inst != null;
-    }
-
-    @Override
-    public void close() throws Exception {
-      if (inst != null && inst instanceof AutoCloseable) ((AutoCloseable) inst).close();
-
-    }
-  }
-
-  /**
-   * A class that loads plugins Lazily. When the get() method is invoked
-   * the Plugin is initialized and returned.
-   */
-  public static class LazyPluginHolder<T> extends PluginHolder<T> {
-    private final SolrConfig.SolrPluginInfo pluginMeta;
-    protected SolrException solrException;
-    private final SolrCore core;
-    protected ResourceLoader resourceLoader;
-
-
-    LazyPluginHolder(SolrConfig.SolrPluginInfo pluginMeta, PluginInfo pluginInfo, SolrCore core, ResourceLoader loader) {
-      super(pluginInfo);
-      this.pluginMeta = pluginMeta;
-      this.core = core;
-      this.resourceLoader = loader;
-      if (loader instanceof MemClassLoader) {
-        if (!"true".equals(System.getProperty("enable.runtime.lib"))) {
-          String s = "runtime library loading is not enabled, start Solr with -Denable.runtime.lib=true";
-          log.warn(s);
-          solrException = new SolrException(SolrException.ErrorCode.SERVER_ERROR, s);
-        }
-      }
-    }
-
-    @Override
-    public T get() {
-      if (inst != null) return inst;
-      if (solrException != null) throw solrException;
-      createInst();
-      registerMBean(inst, core, pluginInfo.name);
-      return inst;
-    }
-
-    protected synchronized void createInst() {
-      if (inst != null) return;
-      log.info("Going to create a new {} with {} ", pluginMeta.tag, pluginInfo.toString());
-      if (resourceLoader instanceof MemClassLoader) {
-        MemClassLoader loader = (MemClassLoader) resourceLoader;
-        loader.loadJars();
-      }
-      Class<T> clazz = (Class<T>) pluginMeta.clazz;
-      inst = core.createInstance(pluginInfo.className, clazz, pluginMeta.tag, null, resourceLoader);
-      initInstance(inst, pluginInfo, core);
-      if (inst instanceof SolrCoreAware) {
-        SolrResourceLoader.assertAwareCompatibility(SolrCoreAware.class, inst);
-        ((SolrCoreAware) inst).inform(core);
-      }
-      if (inst instanceof ResourceLoaderAware) {
-        SolrResourceLoader.assertAwareCompatibility(ResourceLoaderAware.class, inst);
-        try {
-          ((ResourceLoaderAware) inst).inform(core.getResourceLoader());
-        } catch (IOException e) {
-          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "error initializing component", e);
-        }
-      }
-    }
-
-
-  }
-
-  /**
-   * This represents a Runtime Jar. A jar requires two details , name and version
-   */
-  public static class RuntimeLib implements PluginInfoInitialized, AutoCloseable {
-    String name;
-    String version;
-    private JarRepository.JarContentRef jarContent;
-    private final JarRepository jarRepository;
-
-    @Override
-    public void init(PluginInfo info) {
-      name = info.attributes.get("name");
-      Object v = info.attributes.get("version");
-      if (name == null || v == null) {
-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "runtimeLib must have name and version");
-      }
-      version = String.valueOf(v);
-    }
-
-    public RuntimeLib(SolrCore core) {
-      jarRepository = core.getCoreDescriptor().getCoreContainer().getJarRepository();
-    }
-
-
-    void loadJar() {
-      if (jarContent != null) return;
-      synchronized (this) {
-        if (jarContent != null) return;
-        jarContent = jarRepository.getJarIncRef(name + "/" + version);
-      }
-    }
-
-    public ByteBuffer getFileContent(String entryName) throws IOException {
-      if (jarContent == null)
-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "jar not available: " + name + "/" + version);
-      return jarContent.jar.getFileContent(entryName);
-
-    }
-
-    @Override
-    public void close() throws Exception {
-      if (jarContent != null) jarRepository.decrementJarRefCount(jarContent);
-    }
-
-    public static List<RuntimeLib> getLibObjects(SolrCore core, List<PluginInfo> libs) {
-      List<RuntimeLib> l = new ArrayList<>(libs.size());
-      for (PluginInfo lib : libs) {
-        RuntimeLib rtl = new RuntimeLib(core);
-        rtl.init(lib);
-        l.add(rtl);
-      }
-      return l;
-    }
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/core/RequestHandlers.java b/solr/core/src/java/org/apache/solr/core/RequestHandlers.java
index 5bd1209..44fa89d 100644
--- a/solr/core/src/java/org/apache/solr/core/RequestHandlers.java
+++ b/solr/core/src/java/org/apache/solr/core/RequestHandlers.java
@@ -35,7 +35,7 @@ public final class RequestHandlers {
 
   protected final SolrCore core;
 
-  final PluginRegistry<SolrRequestHandler> handlers;
+  final PluginBag<SolrRequestHandler> handlers;
 
   /**
    * Trim the trailing '/' if it's there, and convert null to empty string.
@@ -57,7 +57,7 @@ public final class RequestHandlers {
   
   public RequestHandlers(SolrCore core) {
       this.core = core;
-    handlers =  new PluginRegistry<>(SolrRequestHandler.class, core);
+    handlers =  new PluginBag<>(SolrRequestHandler.class, core);
   }
 
   /**
@@ -88,7 +88,7 @@ public final class RequestHandlers {
   /**
    * Returns an unmodifiable Map containing the registered handlers
    */
-  public PluginRegistry<SolrRequestHandler> getRequestHandlers() {
+  public PluginBag<SolrRequestHandler> getRequestHandlers() {
     return handlers;
   }
 
diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
index 408856a..0458635 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
@@ -26,7 +26,6 @@ import org.apache.solr.cloud.ZkSolrResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.util.NamedList;
 import org.apache.solr.handler.component.SearchComponent;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.QueryResponseWriter;
@@ -76,14 +75,11 @@ import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static java.util.Collections.unmodifiableMap;
-import static org.apache.solr.common.params.CoreAdminParams.NAME;
 import static org.apache.solr.core.SolrConfig.PluginOpts.LAZY;
 import static org.apache.solr.core.SolrConfig.PluginOpts.MULTI_OK;
 import static org.apache.solr.core.SolrConfig.PluginOpts.NOOP;
 import static org.apache.solr.core.SolrConfig.PluginOpts.REQUIRE_CLASS;
 import static org.apache.solr.core.SolrConfig.PluginOpts.REQUIRE_NAME;
-import static org.apache.solr.schema.FieldType.CLASS_NAME;
 
 
 /**
@@ -311,7 +307,7 @@ public class SolrConfig extends Config implements MapSerializable{
       // and even then -- only if there is a single SpellCheckComponent
       // because of queryConverter.setIndexAnalyzer
       .add(new SolrPluginInfo(QueryConverter.class, "queryConverter", REQUIRE_NAME, REQUIRE_CLASS))
-      .add(new SolrPluginInfo(PluginRegistry.RuntimeLib.class, "runtimeLib", REQUIRE_NAME, MULTI_OK))
+      .add(new SolrPluginInfo(PluginBag.RuntimeLib.class, "runtimeLib", REQUIRE_NAME, MULTI_OK))
       // this is hackish, since it picks up all SolrEventListeners,
       // regardless of when/how/why they are used (or even if they are
       // declared outside of the appropriate context) but there's no nice
diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java
index 2ae596f..e1ae0ba 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -175,7 +175,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
 
   private final long startTime;
   private final RequestHandlers reqHandlers;
-  private final PluginRegistry<SearchComponent> searchComponents = new PluginRegistry<>(SearchComponent.class, this);
+  private final PluginBag<SearchComponent> searchComponents = new PluginBag<>(SearchComponent.class, this);
   private final Map<String,UpdateRequestProcessorChain> updateProcessorChains;
   private final Map<String, SolrInfoMBean> infoRegistry;
   private IndexDeletionPolicyWrapper solrDelPolicy;
@@ -788,7 +788,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
         directoryFactory = solrCoreState.getDirectoryFactory();
         this.isReloaded = true;
       }
-      memClassLoader = new MemClassLoader(PluginRegistry.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginRegistry.RuntimeLib.class.getName())), getResourceLoader());
+      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());
       initIndex(prev != null);
 
       initWriters();
@@ -1249,7 +1249,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
   /**
    * Returns an unmodifiable Map containing the registered handlers
    */
-  public PluginRegistry<SolrRequestHandler> getRequestHandlers() {
+  public PluginBag<SolrRequestHandler> getRequestHandlers() {
     return reqHandlers.handlers;
   }
 
@@ -1305,7 +1305,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
    * Accessor for all the Search Components
    * @return An unmodifiable Map of Search Components
    */
-  public PluginRegistry<SearchComponent> getSearchComponents() {
+  public PluginBag<SearchComponent> getSearchComponents() {
     return searchComponents;
   }
 
@@ -2050,11 +2050,11 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
     SolrException.log(log,null,e);
   }
 
-  public PluginRegistry<QueryResponseWriter> getResponseWriters() {
+  public PluginBag<QueryResponseWriter> getResponseWriters() {
     return responseWriters;
   }
 
-  private final PluginRegistry<QueryResponseWriter> responseWriters = new PluginRegistry<>(QueryResponseWriter.class, this);
+  private final PluginBag<QueryResponseWriter> responseWriters = new PluginBag<>(QueryResponseWriter.class, this);
   public static final Map<String ,QueryResponseWriter> DEFAULT_RESPONSE_WRITERS ;
   static{
     HashMap<String, QueryResponseWriter> m= new HashMap<>();
@@ -2119,15 +2119,15 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
   }
 
 
-  private final PluginRegistry<QParserPlugin> qParserPlugins = new PluginRegistry<>(QParserPlugin.class, this);
+  private final PluginBag<QParserPlugin> qParserPlugins = new PluginBag<>(QParserPlugin.class, this);
 
   public QParserPlugin getQueryPlugin(String parserName) {
     return qParserPlugins.get(parserName);
   }
 
-  private final PluginRegistry<ValueSourceParser> valueSourceParsers = new PluginRegistry<>(ValueSourceParser.class, this);
+  private final PluginBag<ValueSourceParser> valueSourceParsers = new PluginBag<>(ValueSourceParser.class, this);
 
-  private final PluginRegistry<TransformerFactory> transformerFactories = new PluginRegistry<>(TransformerFactory.class, this);
+  private final PluginBag<TransformerFactory> transformerFactories = new PluginBag<>(TransformerFactory.class, this);
 
   <T> Map<String, T> createInstances(Map<String, Class<? extends T>> map) {
     Map<String, T> result = new LinkedHashMap<>();
diff --git a/solr/core/src/java/org/apache/solr/handler/RequestHandlerBase.java b/solr/core/src/java/org/apache/solr/handler/RequestHandlerBase.java
index a1391db..c79cea6 100644
--- a/solr/core/src/java/org/apache/solr/handler/RequestHandlerBase.java
+++ b/solr/core/src/java/org/apache/solr/handler/RequestHandlerBase.java
@@ -22,7 +22,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.PluginInfo;
-import org.apache.solr.core.PluginRegistry;
+import org.apache.solr.core.PluginBag;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.request.SolrQueryRequest;
@@ -35,7 +35,6 @@ import org.apache.solr.util.stats.Timer;
 import org.apache.solr.util.stats.TimerContext;
 
 import java.net.URL;
-import java.util.Map;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static org.apache.solr.core.RequestParams.USEPARAM;
@@ -214,7 +213,7 @@ public abstract class RequestHandlerBase implements SolrRequestHandler, SolrInfo
    *
    * This function is thread safe.
    */
-  public static SolrRequestHandler getRequestHandler(String handlerName, PluginRegistry<SolrRequestHandler> reqHandlers) {
+  public static SolrRequestHandler getRequestHandler(String handlerName, PluginBag<SolrRequestHandler> reqHandlers) {
     if(handlerName == null) return null;
     SolrRequestHandler handler = reqHandlers.get(handlerName);
     int idx = 0;
diff --git a/solr/core/src/test/org/apache/solr/OutputWriterTest.java b/solr/core/src/test/org/apache/solr/OutputWriterTest.java
index f58b6ca..2602375 100644
--- a/solr/core/src/test/org/apache/solr/OutputWriterTest.java
+++ b/solr/core/src/test/org/apache/solr/OutputWriterTest.java
@@ -22,7 +22,7 @@ import java.io.Writer;
 
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.core.PluginRegistry;
+import org.apache.solr.core.PluginBag;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.response.QueryResponseWriter;
 import org.apache.solr.response.SolrQueryResponse;
@@ -91,12 +91,12 @@ public class OutputWriterTest extends SolrTestCaseJ4 {
     }
 
     public void testLazy() {
-        PluginRegistry.PluginHolder<QueryResponseWriter> qrw = h.getCore().getResponseWriters().getRegistry().get("useless");
-        assertTrue("Should be a lazy class", qrw instanceof PluginRegistry.LazyPluginHolder);
+        PluginBag.PluginHolder<QueryResponseWriter> qrw = h.getCore().getResponseWriters().getRegistry().get("useless");
+        assertTrue("Should be a lazy class", qrw instanceof PluginBag.LazyPluginHolder);
 
         qrw = h.getCore().getResponseWriters().getRegistry().get("xml");
         assertTrue("Should not be a lazy class", qrw.isLoaded());
-        assertTrue("Should not be a lazy class", qrw.getClass() == PluginRegistry.PluginHolder.class);
+        assertTrue("Should not be a lazy class", qrw.getClass() == PluginBag.PluginHolder.class);
 
     }
     
diff --git a/solr/core/src/test/org/apache/solr/core/RequestHandlersTest.java b/solr/core/src/test/org/apache/solr/core/RequestHandlersTest.java
index 815aa6a..6d855dd 100644
--- a/solr/core/src/test/org/apache/solr/core/RequestHandlersTest.java
+++ b/solr/core/src/test/org/apache/solr/core/RequestHandlersTest.java
@@ -48,7 +48,7 @@ public class RequestHandlersTest extends SolrTestCaseJ4 {
   @Test
   public void testLazyLoading() {
     SolrCore core = h.getCore();
-    PluginRegistry.PluginHolder<SolrRequestHandler> handler = core.getRequestHandlers().getRegistry().get("lazy");
+    PluginBag.PluginHolder<SolrRequestHandler> handler = core.getRequestHandlers().getRegistry().get("lazy");
     assertFalse(handler.isLoaded());
     
     assertU(adoc("id", "42",

