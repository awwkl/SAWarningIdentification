GitDiffStart: 396229f18d851203b44ca7c6c9de7b0935a37399 | Wed Dec 28 13:57:40 2005 +0000
diff --git a/contrib/regex/build.xml b/contrib/regex/build.xml
new file mode 100644
index 0000000..cbdbf8f
--- /dev/null
+++ b/contrib/regex/build.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+
+<project name="regex" default="default">
+
+  <description>
+    Regular expression query
+  </description>
+
+  <path id="additional.dependencies">
+    <fileset dir="lib" includes="*-oro-*.jar,*-regexp-*.jar"/>
+  </path>
+
+  <pathconvert property="project.classpath"
+               targetos="unix"
+               refid="additional.dependencies"
+  />
+
+  <import file="../contrib-build.xml"/>
+</project>
diff --git a/contrib/regex/lib/jakarta-regexp-1.4.jar b/contrib/regex/lib/jakarta-regexp-1.4.jar
new file mode 100644
index 0000000..0366f23
--- /dev/null
+++ b/contrib/regex/lib/jakarta-regexp-1.4.jar
@@ -0,0 +1,2 @@
+AnyObjectId[5d70c357a1e6c4c702af313c94aaf3168d300dcf] was removed in git history.
+Apache SVN contains full history.
\ No newline at end of file
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/JakartaRegexpCapabilities.java b/contrib/regex/src/java/org/apache/lucene/search/regex/JakartaRegexpCapabilities.java
new file mode 100644
index 0000000..d325548
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/JakartaRegexpCapabilities.java
@@ -0,0 +1,21 @@
+package org.apache.lucene.search.regex;
+
+import org.apache.regexp.RE;
+import org.apache.regexp.RegexpTunnel;
+
+public class JakartaRegexpCapabilities implements RegexCapabilities {
+  private RE regexp;
+
+  public void compile(String pattern) {
+    regexp = new RE(pattern);
+  }
+
+  public boolean match(String string) {
+    return regexp.match(string);
+  }
+
+  public String prefix() {
+    char[] prefix = RegexpTunnel.getPrefix(regexp);
+    return prefix == null ? null : new String(prefix);
+  }
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/JavaUtilRegexCapabilities.java b/contrib/regex/src/java/org/apache/lucene/search/regex/JavaUtilRegexCapabilities.java
new file mode 100644
index 0000000..90720b5
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/JavaUtilRegexCapabilities.java
@@ -0,0 +1,19 @@
+package org.apache.lucene.search.regex;
+
+import java.util.regex.Pattern;
+
+public class JavaUtilRegexCapabilities implements RegexCapabilities {
+  private Pattern pattern;
+
+  public void compile(String pattern) {
+    this.pattern = Pattern.compile(pattern);
+  }
+
+  public boolean match(String string) {
+    return pattern.matcher(string).lookingAt();
+  }
+
+  public String prefix() {
+    return null;
+  }
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/RegexCapabilities.java b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexCapabilities.java
new file mode 100644
index 0000000..fb1224e
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexCapabilities.java
@@ -0,0 +1,7 @@
+package org.apache.lucene.search.regex;
+
+public interface RegexCapabilities {
+  void compile(String pattern);
+  boolean match(String string);
+  String prefix();
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQuery.java b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQuery.java
new file mode 100644
index 0000000..a0843ba
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQuery.java
@@ -0,0 +1,47 @@
+package org.apache.lucene.search.regex;
+
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.FilteredTermEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+public class RegexQuery extends MultiTermQuery implements RegexQueryCapable {
+  private RegexCapabilities regexImpl = new JavaUtilRegexCapabilities();
+
+  public RegexQuery(Term term) {
+    super(term);
+  }
+
+  public void setRegexImplementation(RegexCapabilities impl) {
+    this.regexImpl = impl;
+  }
+
+  public RegexCapabilities getRegexImplementation() {
+    return regexImpl;
+  }
+
+  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
+    Term term = new Term(getTerm().field(), getTerm().text());
+    return new RegexTermEnum(reader, term, regexImpl);
+  }
+
+  /* generated by IntelliJ IDEA */
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    final RegexQuery that = (RegexQuery) o;
+
+    return regexImpl.equals(that.regexImpl);
+  }
+
+  /* generated by IntelliJ IDEA */
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 29 * result + regexImpl.hashCode();
+    return result;
+  }
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQueryCapable.java b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQueryCapable.java
new file mode 100644
index 0000000..79ca08a
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexQueryCapable.java
@@ -0,0 +1,6 @@
+package org.apache.lucene.search.regex;
+
+public interface RegexQueryCapable {
+  void setRegexImplementation(RegexCapabilities impl);
+  RegexCapabilities getRegexImplementation();
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/RegexTermEnum.java b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexTermEnum.java
new file mode 100644
index 0000000..19b2739
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/RegexTermEnum.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.search.regex;
+
+import org.apache.lucene.search.FilteredTermEnum;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+
+import java.io.IOException;
+
+public class RegexTermEnum extends FilteredTermEnum {
+  private String field = "";
+  private String pre = "";
+  private boolean endEnum = false;
+  private RegexCapabilities regexImpl;
+
+  public RegexTermEnum(IndexReader reader, Term term, RegexCapabilities regexImpl) throws IOException {
+    super();
+    field = term.field();
+    String text = term.text();
+    this.regexImpl = regexImpl;
+
+    regexImpl.compile(text);
+
+    pre = regexImpl.prefix();
+    if (pre == null) pre = "";
+
+    setEnum(reader.terms(new Term(term.field(), pre)));
+  }
+
+  protected final boolean termCompare(Term term) {
+    if (field == term.field()) {
+      String searchText = term.text();
+      if (searchText.startsWith(pre)) {
+        return regexImpl.match(searchText);
+      }
+    }
+    endEnum = true;
+    return false;
+  }
+
+  public final float difference() {
+// TODO: adjust difference based on distance of searchTerm.text() and term().text()
+    return 1.0f;
+  }
+
+  public final boolean endEnum() {
+    return endEnum;
+  }
+
+  public void close() throws IOException {
+    super.close();
+    field = null;
+  }
+}
diff --git a/contrib/regex/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java b/contrib/regex/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java
new file mode 100644
index 0000000..37c649e
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java
@@ -0,0 +1,105 @@
+package org.apache.lucene.search.regex;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.ArrayList;
+
+public class SpanRegexQuery extends SpanQuery implements RegexQueryCapable {
+  private RegexCapabilities regexImpl = new JavaUtilRegexCapabilities();
+  private Term term;
+
+  public SpanRegexQuery(Term term) {
+    this.term = term;
+  }
+
+  public Term getTerm() { return term; }
+
+  public Query rewrite(IndexReader reader) throws IOException {
+    RegexQuery orig = new RegexQuery(term);
+    orig.setRegexImplementation(regexImpl);
+
+    // RegexQuery (via MultiTermQuery).rewrite always returns a BooleanQuery
+    BooleanQuery bq = (BooleanQuery) orig.rewrite(reader);
+
+    BooleanClause[] clauses = bq.getClauses();
+    SpanQuery[] sqs = new SpanQuery[clauses.length];
+    for (int i = 0; i < clauses.length; i++) {
+      BooleanClause clause = clauses[i];
+
+      // Clauses from RegexQuery.rewrite are always TermQuery's
+      TermQuery tq = (TermQuery) clause.getQuery();
+
+      sqs[i] = new SpanTermQuery(tq.getTerm());
+      sqs[i].setBoost(tq.getBoost());
+    }
+
+    SpanOrQuery query = new SpanOrQuery(sqs);
+    query.setBoost(orig.getBoost());
+
+    return query;
+  }
+
+  public Spans getSpans(IndexReader reader) throws IOException {
+    throw new UnsupportedOperationException("Query should have been rewritten");
+  }
+
+  public String getField() {
+    return term.field();
+  }
+
+  public Collection getTerms() {
+    Collection terms = new ArrayList();
+    terms.add(term);
+    return terms;
+  }
+
+  /* generated by IntelliJ IDEA */
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    final SpanRegexQuery that = (SpanRegexQuery) o;
+
+    if (!regexImpl.equals(that.regexImpl)) return false;
+    if (!term.equals(that.term)) return false;
+
+    return true;
+  }
+
+  /* generated by IntelliJ IDEA */
+  public int hashCode() {
+    int result;
+    result = regexImpl.hashCode();
+    result = 29 * result + term.hashCode();
+    return result;
+  }
+
+  public String toString(String field) {
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("spanRegexQuery(");
+    buffer.append(term);
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  public void setRegexImplementation(RegexCapabilities impl) {
+    this.regexImpl = impl;
+  }
+
+  public RegexCapabilities getRegexImplementation() {
+    return regexImpl;
+  }
+}
diff --git a/contrib/regex/src/java/org/apache/regexp/RegexpTunnel.java b/contrib/regex/src/java/org/apache/regexp/RegexpTunnel.java
new file mode 100644
index 0000000..5861956
--- /dev/null
+++ b/contrib/regex/src/java/org/apache/regexp/RegexpTunnel.java
@@ -0,0 +1,11 @@
+package org.apache.regexp;
+
+/**
+ * This class exists as a gateway to access useful Jakarta Regexp package protected data.
+ */
+public class RegexpTunnel {
+  public static char[] getPrefix(RE regexp) {
+    REProgram program = regexp.getProgram();
+    return program.prefix;
+  }
+}
diff --git a/contrib/regex/src/test/org/apache/lucene/search/regex/TestRegexQuery.java b/contrib/regex/src/test/org/apache/lucene/search/regex/TestRegexQuery.java
new file mode 100644
index 0000000..74b105d
--- /dev/null
+++ b/contrib/regex/src/test/org/apache/lucene/search/regex/TestRegexQuery.java
@@ -0,0 +1,101 @@
+package org.apache.lucene.search.regex;
+
+/**
+ * Copyright 2005 Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.TestCase;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.search.IndexSearcher;
+
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+
+public class TestRegexQuery extends TestCase {
+  private IndexSearcher searcher;
+  private final String FN = "field";
+
+  public void setUp() {
+    RAMDirectory directory = new RAMDirectory();
+    try {
+      IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true);
+      Document doc = new Document();
+      doc.add(new Field(FN, "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.TOKENIZED));
+      writer.addDocument(doc);
+      writer.optimize();
+      writer.close();
+      searcher = new IndexSearcher(directory);
+    } catch (Exception e) {
+      fail(e.toString());
+    }
+  }
+
+  public void tearDown() {
+    try {
+      searcher.close();
+    } catch (Exception e) {
+      fail(e.toString());
+    }
+  }
+
+  private Term newTerm(String value) { return new Term(FN, value); }
+
+  private int  regexQueryNrHits(String regex) throws Exception {
+    RegexQuery query = new RegexQuery( newTerm(regex));
+    return searcher.search(query).length();
+  }
+
+  private int  spanRegexQueryNrHits(String regex1, String regex2, int slop, boolean ordered) throws Exception {
+    SpanRegexQuery srq1 = new SpanRegexQuery( newTerm(regex1));
+    SpanRegexQuery srq2 = new SpanRegexQuery( newTerm(regex2));
+    SpanNearQuery query = new SpanNearQuery( new SpanQuery[]{srq1, srq2}, slop, ordered);
+    return searcher.search(query).length();
+  }
+
+  public void testRegex1() throws Exception {
+    assertEquals(1, regexQueryNrHits("^q.[aeiou]c.*$"));
+  }
+
+  public void testRegex2() throws Exception {
+    assertEquals(0, regexQueryNrHits("^.[aeiou]c.*$"));
+  }
+
+  public void testRegex3() throws Exception {
+    assertEquals(0, regexQueryNrHits("^q.[aeiou]c$"));
+  }
+
+  public void testSpanRegex1() throws Exception {
+    assertEquals(1, spanRegexQueryNrHits("^q.[aeiou]c.*$", "dog", 6, true));
+  }
+
+  public void testSpanRegex2() throws Exception {
+    assertEquals(0, spanRegexQueryNrHits("^q.[aeiou]c.*$", "dog", 5, true));
+  }
+
+  public void testEquals() throws Exception {
+    RegexQuery query1 = new RegexQuery( newTerm("foo.*"));
+    query1.setRegexImplementation(new JakartaRegexpCapabilities());
+
+    RegexQuery query2 = new RegexQuery( newTerm("foo.*"));
+    assertFalse(query1.equals(query2));
+  }
+
+}
+
diff --git a/contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java b/contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java
new file mode 100644
index 0000000..6b662bc
--- /dev/null
+++ b/contrib/regex/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java
@@ -0,0 +1,33 @@
+package org.apache.lucene.search.regex;
+
+import junit.framework.TestCase;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+
+public class TestSpanRegexQuery extends TestCase {
+  public void testSpanRegex() throws Exception {
+    RAMDirectory directory = new RAMDirectory();
+    IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true);
+    Document doc = new Document();
+    doc.add(new Field("field", "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.TOKENIZED));
+    writer.addDocument(doc);
+    writer.optimize();
+    writer.close();
+
+    IndexSearcher searcher = new IndexSearcher(directory);
+    SpanRegexQuery srq = new SpanRegexQuery(new Term("field", "q.[aeiou]c.*"));
+    SpanTermQuery stq = new SpanTermQuery(new Term("field","dog"));
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {srq, stq}, 6, true);
+    Hits hits = searcher.search(query);
+    assertEquals(1, hits.length());
+  }
+}
diff --git a/src/java/org/apache/lucene/search/regex/RegexQuery.java b/src/java/org/apache/lucene/search/regex/RegexQuery.java
deleted file mode 100644
index 38ce8a5..0000000
--- a/src/java/org/apache/lucene/search/regex/RegexQuery.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.apache.lucene.search.regex;
-
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.FilteredTermEnum;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-
-import java.io.IOException;
-
-public class RegexQuery extends MultiTermQuery {
-  public RegexQuery(Term term) {
-    super(term);
-  }
-
-  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
-    Term term = new Term(getTerm().field(), getTerm().text());
-    return new RegexTermEnum(reader, term);
-  }
-
-  public boolean equals(Object o) {
-    if (o instanceof RegexQuery)
-      return super.equals(o);
-
-    return false;
-  }
-}
diff --git a/src/java/org/apache/lucene/search/regex/RegexTermEnum.java b/src/java/org/apache/lucene/search/regex/RegexTermEnum.java
deleted file mode 100644
index 528e621..0000000
--- a/src/java/org/apache/lucene/search/regex/RegexTermEnum.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package org.apache.lucene.search.regex;
-
-import org.apache.lucene.search.FilteredTermEnum;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-
-import java.util.regex.Pattern;
-import java.io.IOException;
-
-public class RegexTermEnum extends FilteredTermEnum {
-  private String field = "";
-  private String pre = "";
-  boolean endEnum = false;
-  private Pattern pattern;
-
-  public RegexTermEnum(IndexReader reader, Term term) throws IOException {
-    super();
-    field = term.field();
-    String text = term.text();
-
-    pattern = Pattern.compile(text);
-
-    // Find the first regex character position, to find the
-    // maximum prefix to use for term enumeration
-    int index = 0;
-    while (index < text.length()) {
-      char c = text.charAt(index);
-
-      if (!Character.isLetterOrDigit(c)) break;
-
-      index++;
-    }
-
-    pre = text.substring(0, index);
-
-    setEnum(reader.terms(new Term(term.field(), pre)));
-  }
-
-  protected final boolean termCompare(Term term) {
-    if (field == term.field()) {
-      String searchText = term.text();
-      if (searchText.startsWith(pre)) {
-        return pattern.matcher(searchText).matches();
-      }
-    }
-    endEnum = true;
-    return false;
-  }
-
-  public final float difference() {
-// TODO: adjust difference based on distance of searchTerm.text() and term().text()
-    return 1.0f;
-  }
-
-  public final boolean endEnum() {
-    return endEnum;
-  }
-
-  public void close() throws IOException {
-    super.close();
-    field = null;
-  }
-}
diff --git a/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java b/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java
deleted file mode 100644
index a679a52..0000000
--- a/src/java/org/apache/lucene/search/regex/SpanRegexQuery.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package org.apache.lucene.search.regex;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Collection;
-import java.util.ArrayList;
-
-public class SpanRegexQuery extends SpanQuery {
-  private Term term;
-
-  public SpanRegexQuery(Term term) {
-    this.term = term;
-  }
-
-  public Term getTerm() { return term; }
-
-  public Query rewrite(IndexReader reader) throws IOException {
-    Query orig = new RegexQuery(term).rewrite(reader);
-
-    // RegexQuery (via MultiTermQuery).rewrite always returns a BooleanQuery
-    BooleanQuery bq = (BooleanQuery) orig;
-
-    BooleanClause[] clauses = bq.getClauses();
-    SpanQuery[] sqs = new SpanQuery[clauses.length];
-    for (int i = 0; i < clauses.length; i++) {
-      BooleanClause clause = clauses[i];
-
-      // Clauses from RegexQuery.rewrite are always TermQuery's
-      TermQuery tq = (TermQuery) clause.getQuery();
-
-      sqs[i] = new SpanTermQuery(tq.getTerm());
-      sqs[i].setBoost(tq.getBoost());
-    }
-
-    SpanOrQuery query = new SpanOrQuery(sqs);
-    query.setBoost(orig.getBoost());
-
-    return query;
-  }
-
-  public Spans getSpans(IndexReader reader) throws IOException {
-    throw new UnsupportedOperationException("Query should have been rewritten");
-  }
-
-  public String getField() {
-    return term.field();
-  }
-
-  public Collection getTerms() {
-    Collection terms = new ArrayList();
-    terms.add(term);
-    return terms;
-  }
-
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof SpanRegexQuery)) return false;
-    final SpanRegexQuery that = (SpanRegexQuery) o;
-    return term.equals(that.term) && getBoost() == that.getBoost();
-  }
-
-  public int hashCode() {
-    return term.hashCode() ^ Float.floatToRawIntBits(getBoost()) ^ 0x4BCEF3A9;
-  }
-
-  public String toString(String field) {
-    StringBuffer buffer = new StringBuffer();
-    buffer.append("spanRegexQuery(");
-    buffer.append(term);
-    buffer.append(")");
-    buffer.append(ToStringUtils.boost(getBoost()));
-    return buffer.toString();
-  }
-}
diff --git a/src/test/org/apache/lucene/search/regex/TestRegexQuery.java b/src/test/org/apache/lucene/search/regex/TestRegexQuery.java
deleted file mode 100644
index caa9e32..0000000
--- a/src/test/org/apache/lucene/search/regex/TestRegexQuery.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package org.apache.lucene.search.regex;
-
-/**
- * Copyright 2005 Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.TestCase;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-
-public class TestRegexQuery extends TestCase {
-  private IndexSearcher searcher;
-  private final String FN = "field";
-
-  public void setUp() {
-    RAMDirectory directory = new RAMDirectory();
-    try {
-      IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true);
-      Document doc = new Document();
-      doc.add(new Field(FN, "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.TOKENIZED));
-      writer.addDocument(doc);
-      writer.optimize();
-      writer.close();
-      searcher = new IndexSearcher(directory);
-    } catch (Exception e) {
-      fail(e.toString());
-    }
-  }
-
-  public void tearDown() {
-    try {
-      searcher.close();
-    } catch (Exception e) {
-      fail(e.toString());
-    }
-  }
-
-  private Term newTerm(String value) { return new Term(FN, value); }
-
-  private int  regexQueryNrHits(String regex) throws Exception {
-    Query query = new RegexQuery( newTerm(regex));
-    return searcher.search(query).length();
-  }
-
-  private int  spanRegexQueryNrHits(String regex1, String regex2, int slop, boolean ordered) throws Exception {
-    SpanRegexQuery srq1 = new SpanRegexQuery( newTerm(regex1));
-    SpanRegexQuery srq2 = new SpanRegexQuery( newTerm(regex2));
-    SpanNearQuery query = new SpanNearQuery( new SpanQuery[]{srq1, srq2}, slop, ordered);
-    return searcher.search(query).length();
-  }
-
-  public void testRegex1() throws Exception {
-    assertEquals(1, regexQueryNrHits("q.[aeiou]c.*"));
-  }
-
-  public void testRegex2() throws Exception {
-    assertEquals(0, regexQueryNrHits(".[aeiou]c.*"));
-  }
-
-  public void testRegex3() throws Exception {
-    assertEquals(0, regexQueryNrHits("q.[aeiou]c"));
-  }
-
-  public void testSpanRegex1() throws Exception {
-    assertEquals(1, spanRegexQueryNrHits("q.[aeiou]c.*", "dog", 6, true));
-  }
-
-  public void testSpanRegex2() throws Exception {
-    assertEquals(0, spanRegexQueryNrHits("q.[aeiou]c.*", "dog", 5, true));
-  }
-
-//  public void testPrefix() throws Exception {
-      // This test currently fails because RegexTermEnum picks "r" as the prefix
-      // but the following "?" makes the "r" optional and should be a hit for the
-      // document matching "over".
-//    assertEquals(1, regexQueryNrHits("r?over"));
-//  }
-}
-
diff --git a/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java b/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java
deleted file mode 100644
index 8438532..0000000
--- a/src/test/org/apache/lucene/search/regex/TestSpanRegexQuery.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.apache.lucene.search.regex;
-
-import junit.framework.TestCase;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-
-public class TestSpanRegexQuery extends TestCase {
-  public void testSpanRegex() throws Exception {
-    RAMDirectory directory = new RAMDirectory();
-    IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true);
-    Document doc = new Document();
-    doc.add(new Field("field", "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.TOKENIZED));
-    writer.addDocument(doc);
-    writer.optimize();
-    writer.close();
-
-    IndexSearcher searcher = new IndexSearcher(directory);
-    SpanRegexQuery srq = new SpanRegexQuery(new Term("field", "q.[aeiou]c.*"));
-    SpanTermQuery stq = new SpanTermQuery(new Term("field","dog"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {srq, stq}, 6, true);
-    Hits hits = searcher.search(query);
-    assertEquals(1, hits.length());
-    QueryUtils.check(srq);
-    QueryUtils.checkUnequal(srq,stq);
-    QueryUtils.checkUnequal(srq,query);
-  }
-}

