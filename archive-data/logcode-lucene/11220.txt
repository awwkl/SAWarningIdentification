GitDiffStart: 3f9aa4dcbba0271fcf99ece0f0d2852c7a21c9eb | Thu Sep 6 08:02:36 2012 +0000
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilterFactory.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilterFactory.java
index 43fda30..4196c6e 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilterFactory.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilterFactory.java
@@ -17,7 +17,6 @@ package org.apache.lucene.codecs.bloom;
  */
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.util.FuzzySet;
 
 
 /**
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java
index 72cd94d..525a0ac 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/BloomFilteringPostingsFormat.java
@@ -33,6 +33,7 @@ import org.apache.lucene.codecs.PostingsConsumer;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.TermStats;
 import org.apache.lucene.codecs.TermsConsumer;
+import org.apache.lucene.codecs.bloom.FuzzySet.ContainsResult;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
@@ -46,11 +47,8 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.FuzzySet;
-import org.apache.lucene.util.FuzzySet.ContainsResult;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
-import org.apache.lucene.util.hash.MurmurHash2;
 
 /**
  * <p>
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/DefaultBloomFilterFactory.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/DefaultBloomFilterFactory.java
index 804f56b..e65f83c 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/DefaultBloomFilterFactory.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/DefaultBloomFilterFactory.java
@@ -17,9 +17,6 @@ package org.apache.lucene.codecs.bloom;
  */
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.util.FuzzySet;
-import org.apache.lucene.util.hash.HashFunction;
-import org.apache.lucene.util.hash.MurmurHash2;
 
 /**
  * Default policy is to allocate a bitset with 10% saturation given a unique term per document.
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet.java
new file mode 100644
index 0000000..1ff03ba
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet.java
@@ -0,0 +1,307 @@
+package org.apache.lucene.codecs.bloom;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+
+import org.apache.lucene.store.DataInput;
+import org.apache.lucene.store.DataOutput;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FixedBitSet;
+
+/**
+ * <p>
+ * A class used to represent a set of many, potentially large, values (e.g. many
+ * long strings such as URLs), using a significantly smaller amount of memory.
+ * </p>
+ * <p>
+ * The set is "lossy" in that it cannot definitively state that is does contain
+ * a value but it <em>can</em> definitively say if a value is <em>not</em> in
+ * the set. It can therefore be used as a Bloom Filter.
+ * </p> 
+ * Another application of the set is that it can be used to perform fuzzy counting because
+ * it can estimate reasonably accurately how many unique values are contained in the set. 
+ * </p>
+ * <p>This class is NOT threadsafe.</p>
+ * <p>
+ * Internally a Bitset is used to record values and once a client has finished recording
+ * a stream of values the {@link #downsize(float)} method can be used to create a suitably smaller set that
+ * is sized appropriately for the number of values recorded and desired saturation levels. 
+ * 
+ * </p>
+ * @lucene.experimental
+ */
+public class FuzzySet {
+
+  public static final int VERSION_SPI = 1; // HashFunction used to be loaded through a SPI
+  public static final int VERSION_START = VERSION_SPI;
+  public static final int VERSION_CURRENT = 2;
+
+  public static HashFunction hashFunctionForVersion(int version) {
+    if (version < VERSION_START) {
+      throw new IllegalArgumentException("Version " + version + " is too old, expected at least " + VERSION_START);
+    } else if (version > VERSION_CURRENT) {
+      throw new IllegalArgumentException("Version " + version + " is too new, expected at most " + VERSION_CURRENT);
+    }
+    return MurmurHash2.INSTANCE;
+  }
+
+  /**
+   * Result from {@link FuzzySet#contains(BytesRef)}:
+   * can never return definitively YES (always MAYBE), 
+   * but can sometimes definitely return NO.
+   */
+  public enum ContainsResult {
+    MAYBE, NO
+  };
+  private HashFunction hashFunction;
+  private FixedBitSet filter;
+  private int bloomSize;
+  
+  //The sizes of BitSet used are all numbers that, when expressed in binary form,
+  //are all ones. This is to enable fast downsizing from one bitset to another
+  //by simply ANDing each set index in one bitset with the size of the target bitset
+  // - this provides a fast modulo of the number. Values previously accumulated in
+  // a large bitset and then mapped to a smaller set can be looked up using a single
+  // AND operation of the query term's hash rather than needing to perform a 2-step
+  // translation of the query term that mirrors the stored content's reprojections.
+  static final int usableBitSetSizes[];
+  static
+  {
+    usableBitSetSizes=new int[30];
+    int mask=1;
+    int size=mask;
+    for (int i = 0; i < usableBitSetSizes.length; i++) {
+        size=(size<<1)|mask;
+        usableBitSetSizes[i]=size;
+    }    
+  }
+
+  /**
+   * Rounds down required maxNumberOfBits to the nearest number that is made up
+   * of all ones as a binary number.  
+   * Use this method where controlling memory use is paramount.
+   */
+  public static int getNearestSetSize(int maxNumberOfBits)
+  {
+    int result=usableBitSetSizes[0];
+    for (int i = 0; i < usableBitSetSizes.length; i++) {
+      if(usableBitSetSizes[i]<=maxNumberOfBits)
+      {
+        result=usableBitSetSizes[i];
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Use this method to choose a set size where accuracy (low content saturation) is more important
+   * than deciding how much memory to throw at the problem.
+   * @param maxNumberOfValuesExpected
+   * @param desiredSaturation A number between 0 and 1 expressing the % of bits set once all values have been recorded
+   * @return The size of the set nearest to the required size
+   */
+  public static int getNearestSetSize(int maxNumberOfValuesExpected,
+      float desiredSaturation) {
+    // Iterate around the various scales of bitset from smallest to largest looking for the first that
+    // satisfies value volumes at the chosen saturation level
+    for (int i = 0; i < usableBitSetSizes.length; i++) {
+      int numSetBitsAtDesiredSaturation = (int) (usableBitSetSizes[i] * desiredSaturation);
+      int estimatedNumUniqueValues = getEstimatedNumberUniqueValuesAllowingForCollisions(
+          usableBitSetSizes[i], numSetBitsAtDesiredSaturation);
+      if (estimatedNumUniqueValues > maxNumberOfValuesExpected) {
+        return usableBitSetSizes[i];
+      }
+    }
+    return -1;    
+  }
+  
+  public static FuzzySet createSetBasedOnMaxMemory(int maxNumBytes, HashFunction hashFunction)
+  {
+      int setSize=getNearestSetSize(maxNumBytes);
+      return new FuzzySet(new FixedBitSet(setSize+1),setSize,hashFunction);
+  }
+  
+  public static FuzzySet createSetBasedOnQuality(int maxNumUniqueValues, float desiredMaxSaturation, HashFunction hashFunction)
+  {
+      int setSize=getNearestSetSize(maxNumUniqueValues,desiredMaxSaturation);
+      return new FuzzySet(new FixedBitSet(setSize+1),setSize,hashFunction);
+  }
+  
+
+  
+  
+  private FuzzySet(FixedBitSet filter, int bloomSize, HashFunction hashFunction) {
+    super();
+    this.filter = filter;
+    this.bloomSize = bloomSize;
+    this.hashFunction=hashFunction;
+  }
+  
+  /**
+   * The main method required for a Bloom filter which, given a value determines set membership.
+   * Unlike a conventional set, the fuzzy set returns NO or MAYBE rather than true or false.
+   * @param value
+   * @return NO or MAYBE
+   */
+  public ContainsResult contains(BytesRef value) {
+    int hash = hashFunction.hash(value);
+    if (hash < 0) {
+      hash = hash * -1;
+    }
+    return mayContainValue(hash);
+  }
+  
+  /**
+   * Serializes the data set to file using the following format:
+   * <ul>
+   *  <li>FuzzySet --&gt;FuzzySetVersion,HashFunctionName,BloomSize,
+   * NumBitSetWords,BitSetWord<sup>NumBitSetWords</sup></li> 
+   * <li>HashFunctionName --&gt; {@link DataOutput#writeString(String) String} The
+   * name of a ServiceProvider registered {@link HashFunction}</li>
+   * <li>FuzzySetVersion --&gt; {@link DataOutput#writeInt Uint32} The version number of the {@link FuzzySet} class</li>
+   * <li>BloomSize --&gt; {@link DataOutput#writeInt Uint32} The modulo value used
+   * to project hashes into the field's Bitset</li>
+   * <li>NumBitSetWords --&gt; {@link DataOutput#writeInt Uint32} The number of
+   * longs (as returned from {@link FixedBitSet#getBits})</li>
+   * <li>BitSetWord --&gt; {@link DataOutput#writeLong Long} A long from the array
+   * returned by {@link FixedBitSet#getBits}</li>
+   * </ul>
+   * @param out Data output stream
+   * @throws IOException
+   */
+  public void serialize(DataOutput out) throws IOException
+  {
+      out.writeInt(VERSION_CURRENT);
+      out.writeInt(bloomSize);
+      long[] bits = filter.getBits();
+      out.writeInt(bits.length);
+      for (int i = 0; i < bits.length; i++) {
+        // Can't used VLong encoding because cant cope with negative numbers
+        // output by FixedBitSet
+        out.writeLong(bits[i]);
+      }
+  }
+  public static FuzzySet deserialize(DataInput in) throws IOException
+  {
+    int version=in.readInt();
+    if (version == VERSION_SPI) {
+      in.readString();
+    }
+    final HashFunction hashFunction = hashFunctionForVersion(version);
+    int bloomSize=in.readInt();
+    int numLongs=in.readInt();
+    long[]longs=new long[numLongs];
+    for (int i = 0; i < numLongs; i++) {
+      longs[i]=in.readLong();
+    }
+    FixedBitSet bits = new FixedBitSet(longs,bloomSize+1);
+    return new FuzzySet(bits,bloomSize,hashFunction);
+  }
+  
+  private ContainsResult mayContainValue(int positiveHash) {
+    assert positiveHash >= 0;
+    // Bloom sizes are always base 2 and so can be ANDed for a fast modulo
+    int pos = positiveHash & bloomSize;
+    if (filter.get(pos)) {
+      // This term may be recorded in this index (but could be a collision)
+      return ContainsResult.MAYBE;
+    }
+    // definitely NOT in this segment
+    return ContainsResult.NO;
+  }
+  
+  /**
+   * Records a value in the set. The referenced bytes are hashed and then modulo n'd where n is the
+   * chosen size of the internal bitset.
+   * @param value the key value to be hashed
+   * @throws IOException
+   */
+  public void addValue(BytesRef value) throws IOException {    
+      int hash = hashFunction.hash(value);
+      if (hash < 0) {
+        hash = hash * -1;
+      }
+      // Bitmasking using bloomSize is effectively a modulo operation.
+      int bloomPos = hash & bloomSize;
+      filter.set(bloomPos);
+  }  
+  
+  
+  /**
+   * 
+   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the 
+   * result. Lower values have better qccuracy but require more space.
+   * @return a smaller FuzzySet or null if the current set is already over-saturated
+   */
+  public FuzzySet downsize(float targetMaxSaturation)
+  {
+    int numBitsSet = filter.cardinality();
+    FixedBitSet rightSizedBitSet = filter;
+    int rightSizedBitSetSize = bloomSize;
+    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level
+    for (int i = 0; i < usableBitSetSizes.length; i++) {
+      int candidateBitsetSize = usableBitSetSizes[i];
+      float candidateSaturation = (float) numBitsSet
+          / (float) candidateBitsetSize;
+      if (candidateSaturation <= targetMaxSaturation) {
+        rightSizedBitSetSize = candidateBitsetSize;
+        break;
+      }
+    }
+    // Re-project the numbers to a smaller space if necessary
+    if (rightSizedBitSetSize < bloomSize) {
+      // Reset the choice of bitset to the smaller version
+      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);
+      // Map across the bits from the large set to the smaller one
+      int bitIndex = 0;
+      do {
+        bitIndex = filter.nextSetBit(bitIndex);
+        if (bitIndex >= 0) {
+          // Project the larger number into a smaller one effectively
+          // modulo-ing by using the target bitset size as a mask
+          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;
+          rightSizedBitSet.set(downSizedBitIndex);
+          bitIndex++;
+        }
+      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));
+    } else {
+      return null;
+    }
+    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);
+  }
+  
+  public int getEstimatedUniqueValues()
+  {
+       return getEstimatedNumberUniqueValuesAllowingForCollisions(bloomSize, filter.cardinality());
+  }
+  
+  // Given a set size and a the number of set bits, produces an estimate of the number of unique values recorded
+  public static int getEstimatedNumberUniqueValuesAllowingForCollisions(
+      int setSize, int numRecordedBits) {
+    double setSizeAsDouble = setSize;
+    double numRecordedBitsAsDouble = numRecordedBits;
+    double saturation = numRecordedBitsAsDouble / setSizeAsDouble;
+    double logInverseSaturation = Math.log(1 - saturation) * -1;
+    return (int) (setSizeAsDouble * logInverseSaturation);
+  }
+
+  public float getSaturation() {
+    int numBitsSet = filter.cardinality();
+    return (float) numBitsSet / (float) bloomSize;
+  }
+}
\ No newline at end of file
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/HashFunction.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/HashFunction.java
new file mode 100644
index 0000000..abc1050
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/HashFunction.java
@@ -0,0 +1,36 @@
+package org.apache.lucene.codecs.bloom;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import org.apache.lucene.util.BytesRef;
+
+
+/**
+ * Base class for hashing functions that can be referred to by name.
+ * Subclasses are expected to provide threadsafe implementations of the hash function
+ * on the range of bytes referenced in the provided {@link BytesRef}
+ * @lucene.experimental
+ */
+public abstract class HashFunction {
+
+  /**
+   * Hashes the contents of the referenced bytes
+   * @param bytes the data to be hashed
+   * @return the hash of the bytes referenced by bytes.offset and length bytes.length
+   */
+  public abstract int hash(BytesRef bytes);
+
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/MurmurHash2.java b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/MurmurHash2.java
new file mode 100644
index 0000000..cb68903
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/bloom/MurmurHash2.java
@@ -0,0 +1,102 @@
+package org.apache.lucene.codecs.bloom;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * This is a very fast, non-cryptographic hash suitable for general hash-based
+ * lookup. See http://murmurhash.googlepages.com/ for more details.
+ * <p>
+ * The C version of MurmurHash 2.0 found at that site was ported to Java by
+ * Andrzej Bialecki (ab at getopt org).
+ * </p>
+ * <p>
+ *  The code from getopt.org was adapted by Mark Harwood in the form here as one of a pluggable choice of 
+ *  hashing functions as the core function had to be adapted to work with BytesRefs with offsets and lengths
+ *  rather than raw byte arrays.  
+ * </p>
+ * @lucene.experimental
+ */
+public final class MurmurHash2 extends HashFunction{
+
+  public static final MurmurHash2 INSTANCE = new MurmurHash2();
+
+  private MurmurHash2() {}
+
+  public static int hash(byte[] data, int seed, int offset, int len) {
+    int m = 0x5bd1e995;
+    int r = 24;
+    int h = seed ^ len;
+    int len_4 = len >> 2;
+    for (int i = 0; i < len_4; i++) {
+      int i_4 = offset + (i << 2);
+      int k = data[i_4 + 3];
+      k = k << 8;
+      k = k | (data[i_4 + 2] & 0xff);
+      k = k << 8;
+      k = k | (data[i_4 + 1] & 0xff);
+      k = k << 8;
+      k = k | (data[i_4 + 0] & 0xff);
+      k *= m;
+      k ^= k >>> r;
+      k *= m;
+      h *= m;
+      h ^= k;
+    }
+    int len_m = len_4 << 2;
+    int left = len - len_m;
+    if (left != 0) {
+      if (left >= 3) {
+        h ^= data[offset + len - 3] << 16;
+      }
+      if (left >= 2) {
+        h ^= data[offset + len - 2] << 8;
+      }
+      if (left >= 1) {
+        h ^= data[offset + len - 1];
+      }
+      h *= m;
+    }
+    h ^= h >>> 13;
+    h *= m;
+    h ^= h >>> 15;
+    return h;
+  }
+  
+  /**
+   * Generates 32 bit hash from byte array with default seed value.
+   * 
+   * @param data 
+   *          byte array to hash
+   * @param offset
+   *          the start position in the array to hash
+   * @param len
+   *          length of the array elements to hash
+   * @return 32 bit hash of the given array
+   */
+  public static final int hash32(final byte[] data, int offset, int len) {
+    return MurmurHash2.hash(data, 0x9747b28c, offset, len);
+  }
+  
+
+  @Override
+  public final int hash(BytesRef br) {
+    return hash32(br.bytes, br.offset, br.length);
+  }
+  
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/FuzzySet.java b/lucene/core/src/java/org/apache/lucene/util/FuzzySet.java
deleted file mode 100644
index a759376..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/FuzzySet.java
+++ /dev/null
@@ -1,297 +0,0 @@
-package org.apache.lucene.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.util.hash.HashFunction;
-
-/**
- * <p>
- * A class used to represent a set of many, potentially large, values (e.g. many
- * long strings such as URLs), using a significantly smaller amount of memory.
- * </p>
- * <p>
- * The set is "lossy" in that it cannot definitively state that is does contain
- * a value but it <em>can</em> definitively say if a value is <em>not</em> in
- * the set. It can therefore be used as a Bloom Filter.
- * </p> 
- * Another application of the set is that it can be used to perform fuzzy counting because
- * it can estimate reasonably accurately how many unique values are contained in the set. 
- * </p>
- * <p>This class is NOT threadsafe.</p>
- * <p>
- * Internally a Bitset is used to record values and once a client has finished recording
- * a stream of values the {@link #downsize(float)} method can be used to create a suitably smaller set that
- * is sized appropriately for the number of values recorded and desired saturation levels. 
- * 
- * </p>
- * @lucene.experimental
- */
-public class FuzzySet {
-  
-  public static final int FUZZY_SERIALIZATION_VERSION=1;
-  
-  /**
-   * Result from {@link FuzzySet#contains(BytesRef)}:
-   * can never return definitively YES (always MAYBE), 
-   * but can sometimes definitely return NO.
-   */
-  public enum ContainsResult {
-    MAYBE, NO
-  };
-  private HashFunction hashFunction;
-  private FixedBitSet filter;
-  private int bloomSize;
-  
-  //The sizes of BitSet used are all numbers that, when expressed in binary form,
-  //are all ones. This is to enable fast downsizing from one bitset to another
-  //by simply ANDing each set index in one bitset with the size of the target bitset
-  // - this provides a fast modulo of the number. Values previously accumulated in
-  // a large bitset and then mapped to a smaller set can be looked up using a single
-  // AND operation of the query term's hash rather than needing to perform a 2-step
-  // translation of the query term that mirrors the stored content's reprojections.
-  static final int usableBitSetSizes[];
-  static
-  {
-    usableBitSetSizes=new int[30];
-    int mask=1;
-    int size=mask;
-    for (int i = 0; i < usableBitSetSizes.length; i++) {
-        size=(size<<1)|mask;
-        usableBitSetSizes[i]=size;
-    }    
-  }
-
-  /**
-   * Rounds down required maxNumberOfBits to the nearest number that is made up
-   * of all ones as a binary number.  
-   * Use this method where controlling memory use is paramount.
-   */
-  public static int getNearestSetSize(int maxNumberOfBits)
-  {
-    int result=usableBitSetSizes[0];
-    for (int i = 0; i < usableBitSetSizes.length; i++) {
-      if(usableBitSetSizes[i]<=maxNumberOfBits)
-      {
-        result=usableBitSetSizes[i];
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Use this method to choose a set size where accuracy (low content saturation) is more important
-   * than deciding how much memory to throw at the problem.
-   * @param maxNumberOfValuesExpected
-   * @param desiredSaturation A number between 0 and 1 expressing the % of bits set once all values have been recorded
-   * @return The size of the set nearest to the required size
-   */
-  public static int getNearestSetSize(int maxNumberOfValuesExpected,
-      float desiredSaturation) {
-    // Iterate around the various scales of bitset from smallest to largest looking for the first that
-    // satisfies value volumes at the chosen saturation level
-    for (int i = 0; i < usableBitSetSizes.length; i++) {
-      int numSetBitsAtDesiredSaturation = (int) (usableBitSetSizes[i] * desiredSaturation);
-      int estimatedNumUniqueValues = getEstimatedNumberUniqueValuesAllowingForCollisions(
-          usableBitSetSizes[i], numSetBitsAtDesiredSaturation);
-      if (estimatedNumUniqueValues > maxNumberOfValuesExpected) {
-        return usableBitSetSizes[i];
-      }
-    }
-    return -1;    
-  }
-  
-  public static FuzzySet createSetBasedOnMaxMemory(int maxNumBytes, HashFunction hashFunction)
-  {
-      int setSize=getNearestSetSize(maxNumBytes);
-      return new FuzzySet(new FixedBitSet(setSize+1),setSize,hashFunction);
-  }
-  
-  public static FuzzySet createSetBasedOnQuality(int maxNumUniqueValues, float desiredMaxSaturation, HashFunction hashFunction)
-  {
-      int setSize=getNearestSetSize(maxNumUniqueValues,desiredMaxSaturation);
-      return new FuzzySet(new FixedBitSet(setSize+1),setSize,hashFunction);
-  }
-  
-
-  
-  
-  private FuzzySet(FixedBitSet filter, int bloomSize, HashFunction hashFunction) {
-    super();
-    this.filter = filter;
-    this.bloomSize = bloomSize;
-    this.hashFunction=hashFunction;
-  }
-  
-  /**
-   * The main method required for a Bloom filter which, given a value determines set membership.
-   * Unlike a conventional set, the fuzzy set returns NO or MAYBE rather than true or false.
-   * @param value
-   * @return NO or MAYBE
-   */
-  public ContainsResult contains(BytesRef value) {
-    int hash = hashFunction.hash(value);
-    if (hash < 0) {
-      hash = hash * -1;
-    }
-    return mayContainValue(hash);
-  }
-  
-  /**
-   * Serializes the data set to file using the following format:
-   * <ul>
-   *  <li>FuzzySet --&gt;FuzzySetVersion,HashFunctionName,BloomSize,
-   * NumBitSetWords,BitSetWord<sup>NumBitSetWords</sup></li> 
-   * <li>HashFunctionName --&gt; {@link DataOutput#writeString(String) String} The
-   * name of a ServiceProvider registered {@link HashFunction}</li>
-   * <li>FuzzySetVersion --&gt; {@link DataOutput#writeInt Uint32} The version number of the {@link FuzzySet} class</li>
-   * <li>BloomSize --&gt; {@link DataOutput#writeInt Uint32} The modulo value used
-   * to project hashes into the field's Bitset</li>
-   * <li>NumBitSetWords --&gt; {@link DataOutput#writeInt Uint32} The number of
-   * longs (as returned from {@link FixedBitSet#getBits})</li>
-   * <li>BitSetWord --&gt; {@link DataOutput#writeLong Long} A long from the array
-   * returned by {@link FixedBitSet#getBits}</li>
-   * </ul>
-   * @param out Data output stream
-   * @throws IOException
-   */
-  public void serialize(DataOutput out) throws IOException
-  {
-      out.writeInt(FUZZY_SERIALIZATION_VERSION);
-      out.writeString(hashFunction.getName());
-      out.writeInt(bloomSize);
-      long[] bits = filter.getBits();
-      out.writeInt(bits.length);
-      for (int i = 0; i < bits.length; i++) {
-        // Can't used VLong encoding because cant cope with negative numbers
-        // output by FixedBitSet
-        out.writeLong(bits[i]);
-      }
-  }
-  public static FuzzySet deserialize(DataInput in) throws IOException
-  {
-    int version=in.readInt();
-    if(version!=FUZZY_SERIALIZATION_VERSION)
-    {
-      throw new IOException("Error deserializing: set version is not "+FUZZY_SERIALIZATION_VERSION);
-    }
-    HashFunction hashFunction=HashFunction.forName(in.readString());
-    int bloomSize=in.readInt();
-    int numLongs=in.readInt();
-    long[]longs=new long[numLongs];
-    for (int i = 0; i < numLongs; i++) {
-      longs[i]=in.readLong();
-    }
-    FixedBitSet bits = new FixedBitSet(longs,bloomSize+1);
-    return new FuzzySet(bits,bloomSize,hashFunction);
-  }
-  
-  private ContainsResult mayContainValue(int positiveHash) {
-    assert positiveHash >= 0;
-    // Bloom sizes are always base 2 and so can be ANDed for a fast modulo
-    int pos = positiveHash & bloomSize;
-    if (filter.get(pos)) {
-      // This term may be recorded in this index (but could be a collision)
-      return ContainsResult.MAYBE;
-    }
-    // definitely NOT in this segment
-    return ContainsResult.NO;
-  }
-  
-  /**
-   * Records a value in the set. The referenced bytes are hashed and then modulo n'd where n is the
-   * chosen size of the internal bitset.
-   * @param value the key value to be hashed
-   * @throws IOException
-   */
-  public void addValue(BytesRef value) throws IOException {    
-      int hash = hashFunction.hash(value);
-      if (hash < 0) {
-        hash = hash * -1;
-      }
-      // Bitmasking using bloomSize is effectively a modulo operation.
-      int bloomPos = hash & bloomSize;
-      filter.set(bloomPos);
-  }  
-  
-  
-  /**
-   * 
-   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the 
-   * result. Lower values have better qccuracy but require more space.
-   * @return a smaller FuzzySet or null if the current set is already over-saturated
-   */
-  public FuzzySet downsize(float targetMaxSaturation)
-  {
-    int numBitsSet = filter.cardinality();
-    FixedBitSet rightSizedBitSet = filter;
-    int rightSizedBitSetSize = bloomSize;
-    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level
-    for (int i = 0; i < usableBitSetSizes.length; i++) {
-      int candidateBitsetSize = usableBitSetSizes[i];
-      float candidateSaturation = (float) numBitsSet
-          / (float) candidateBitsetSize;
-      if (candidateSaturation <= targetMaxSaturation) {
-        rightSizedBitSetSize = candidateBitsetSize;
-        break;
-      }
-    }
-    // Re-project the numbers to a smaller space if necessary
-    if (rightSizedBitSetSize < bloomSize) {
-      // Reset the choice of bitset to the smaller version
-      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);
-      // Map across the bits from the large set to the smaller one
-      int bitIndex = 0;
-      do {
-        bitIndex = filter.nextSetBit(bitIndex);
-        if (bitIndex >= 0) {
-          // Project the larger number into a smaller one effectively
-          // modulo-ing by using the target bitset size as a mask
-          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;
-          rightSizedBitSet.set(downSizedBitIndex);
-          bitIndex++;
-        }
-      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));
-    } else {
-      return null;
-    }
-    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);
-  }
-  
-  public int getEstimatedUniqueValues()
-  {
-       return getEstimatedNumberUniqueValuesAllowingForCollisions(bloomSize, filter.cardinality());
-  }
-  
-  // Given a set size and a the number of set bits, produces an estimate of the number of unique values recorded
-  public static int getEstimatedNumberUniqueValuesAllowingForCollisions(
-      int setSize, int numRecordedBits) {
-    double setSizeAsDouble = setSize;
-    double numRecordedBitsAsDouble = numRecordedBits;
-    double saturation = numRecordedBitsAsDouble / setSizeAsDouble;
-    double logInverseSaturation = Math.log(1 - saturation) * -1;
-    return (int) (setSizeAsDouble * logInverseSaturation);
-  }
-
-  public float getSaturation() {
-    int numBitsSet = filter.cardinality();
-    return (float) numBitsSet / (float) bloomSize;
-  }
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/util/hash/HashFunction.java b/lucene/core/src/java/org/apache/lucene/util/hash/HashFunction.java
deleted file mode 100644
index e25a5d9..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/hash/HashFunction.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.apache.lucene.util.hash;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.util.Set;
-
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.NamedSPILoader;
-
-
-/**
- * Base class for hashing functions that can be referred to by name.
- * Subclasses are expected to provide threadsafe implementations of the hash function
- * on the range of bytes referenced in the provided {@link BytesRef}
- * @lucene.experimental
- */
-public abstract class HashFunction implements NamedSPILoader.NamedSPI {
-
-  /**
-   * Hashes the contents of the referenced bytes
-   * @param bytes the data to be hashed
-   * @return the hash of the bytes referenced by bytes.offset and length bytes.length
-   */
-  public abstract int hash(BytesRef bytes);
-  
-  private static final NamedSPILoader<HashFunction> loader =
-    new NamedSPILoader<HashFunction>(HashFunction.class);
-
-  private final String name;
-
-  public HashFunction(String name) {
-    NamedSPILoader.checkServiceName(name);
-    this.name = name;
-  }
-  
-  /** Returns this codec's name */
-  @Override
-  public final String getName() {
-    return name;
-  }
-  
-  /** looks up a hash function by name */
-  public static HashFunction forName(String name) {
-    return loader.lookup(name);
-  }
-  
-  /** returns a list of all available hash function names */
-  public static Set<String> availableHashFunctionNames() {
-    return loader.availableServices();
-  }
-  
-  /** 
-   * Reloads the hash function list from the given {@link ClassLoader}.
-   * Changes to the function list are visible after the method ends, all
-   * iterators ({@link #availableHashFunctionNames()},...) stay consistent. 
-   * 
-   * <p><b>NOTE:</b> Only new functions are added, existing ones are
-   * never removed or replaced.
-   * 
-   * <p><em>This method is expensive and should only be called for discovery
-   * of new functions on the given classpath/classloader!</em>
-   */
-  public static void reloadHashFunctions(ClassLoader classloader) {
-    loader.reload(classloader);
-  }
-  
-  @Override
-  public String toString() {
-    return name;
-  }  
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/hash/MurmurHash2.java b/lucene/core/src/java/org/apache/lucene/util/hash/MurmurHash2.java
deleted file mode 100644
index 6f8b946..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/hash/MurmurHash2.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package org.apache.lucene.util.hash;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * This is a very fast, non-cryptographic hash suitable for general hash-based
- * lookup. See http://murmurhash.googlepages.com/ for more details.
- * <p>
- * The C version of MurmurHash 2.0 found at that site was ported to Java by
- * Andrzej Bialecki (ab at getopt org).
- * </p>
- * <p>
- *  The code from getopt.org was adapted by Mark Harwood in the form here as one of a pluggable choice of 
- *  hashing functions as the core function had to be adapted to work with BytesRefs with offsets and lengths
- *  rather than raw byte arrays.  
- * </p>
- * @lucene.experimental
- */
-public class MurmurHash2 extends HashFunction{
-  
-  
-  public static final String HASH_NAME="MurmurHash2";
-  
-  public MurmurHash2() {
-    super(HASH_NAME);
-  }
-
-  public static int hash(byte[] data, int seed, int offset, int len) {
-    int m = 0x5bd1e995;
-    int r = 24;
-    int h = seed ^ len;
-    int len_4 = len >> 2;
-    for (int i = 0; i < len_4; i++) {
-      int i_4 = offset + (i << 2);
-      int k = data[i_4 + 3];
-      k = k << 8;
-      k = k | (data[i_4 + 2] & 0xff);
-      k = k << 8;
-      k = k | (data[i_4 + 1] & 0xff);
-      k = k << 8;
-      k = k | (data[i_4 + 0] & 0xff);
-      k *= m;
-      k ^= k >>> r;
-      k *= m;
-      h *= m;
-      h ^= k;
-    }
-    int len_m = len_4 << 2;
-    int left = len - len_m;
-    if (left != 0) {
-      if (left >= 3) {
-        h ^= data[offset + len - 3] << 16;
-      }
-      if (left >= 2) {
-        h ^= data[offset + len - 2] << 8;
-      }
-      if (left >= 1) {
-        h ^= data[offset + len - 1];
-      }
-      h *= m;
-    }
-    h ^= h >>> 13;
-    h *= m;
-    h ^= h >>> 15;
-    return h;
-  }
-  
-  /**
-   * Generates 32 bit hash from byte array with default seed value.
-   * 
-   * @param data 
-   *          byte array to hash
-   * @param offset
-   *          the start position in the array to hash
-   * @param len
-   *          length of the array elements to hash
-   * @return 32 bit hash of the given array
-   */
-  public static final int hash32(final byte[] data, int offset, int len) {
-    return MurmurHash2.hash(data, 0x9747b28c, offset, len);
-  }
-  
-
-  @Override
-  public final int hash(BytesRef br) {
-    return hash32(br.bytes, br.offset, br.length);
-  }
-  
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/hash/package.html b/lucene/core/src/java/org/apache/lucene/util/hash/package.html
deleted file mode 100644
index a9ef65a..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/hash/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Hashing functions load-able via SPI service
-</body>
-</html>
\ No newline at end of file
diff --git a/lucene/core/src/resources/META-INF/services/org.apache.lucene.util.hash.HashFunction b/lucene/core/src/resources/META-INF/services/org.apache.lucene.util.hash.HashFunction
deleted file mode 100644
index 4b2f1ed..0000000
--- a/lucene/core/src/resources/META-INF/services/org.apache.lucene.util.hash.HashFunction
+++ /dev/null
@@ -1,16 +0,0 @@
-#  Licensed to the Apache Software Foundation (ASF) under one or more
-#  contributor license agreements.  See the NOTICE file distributed with
-#  this work for additional information regarding copyright ownership.
-#  The ASF licenses this file to You under the Apache License, Version 2.0
-#  (the "License"); you may not use this file except in compliance with
-#  the License.  You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-
-org.apache.lucene.util.hash.MurmurHash2
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/bloom/TestBloomFilteredLucene40Postings.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/bloom/TestBloomFilteredLucene40Postings.java
index df83975..9c3a7e8 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/bloom/TestBloomFilteredLucene40Postings.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/bloom/TestBloomFilteredLucene40Postings.java
@@ -22,13 +22,10 @@ import java.io.IOException;
 import org.apache.lucene.codecs.FieldsConsumer;
 import org.apache.lucene.codecs.FieldsProducer;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.bloom.BloomFilteringPostingsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40PostingsFormat;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.util.FuzzySet;
-import org.apache.lucene.util.hash.MurmurHash2;
 
 /**
  * A class used for testing {@link BloomFilteringPostingsFormat} with a concrete
diff --git a/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java b/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
index 7ba722d..9595893 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrResourceLoader.java
@@ -36,7 +36,6 @@ import org.apache.lucene.analysis.util.TokenFilterFactory;
 import org.apache.lucene.analysis.util.TokenizerFactory;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.util.hash.HashFunction;
 import org.apache.lucene.analysis.util.WordlistLoader;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.handler.admin.CoreAdminHandler;
@@ -176,8 +175,6 @@ public class SolrResourceLoader implements ResourceLoader
    * this ResourceLoader.
    */
   void reloadLuceneSPI() {
-    // Hash functions:
-    HashFunction.reloadHashFunctions(this.classLoader);
     // Codecs:
     PostingsFormat.reloadPostingsFormats(this.classLoader);
     Codec.reloadCodecs(this.classLoader);

