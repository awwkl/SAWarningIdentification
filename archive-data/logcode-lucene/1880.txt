GitDiffStart: fc5b1ac279a02f51b634f0fd16ae3efdcdbc520b | Mon Feb 8 22:41:51 2016 +0200
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 754976c..ef6a108 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -280,6 +280,15 @@ Upgrading from Solr 5.4
 * bin/post now defaults application/json files to the /update/json/docs end-point.  Use `-format solr` to force
   files to the /update end-point.   See SOLR-7042 for more details.
 
+* <mergePolicy> is deprecated in favor of a new <mergePolicyFactory> element. See SOLR-8621 for details. To
+  migrate existing solrconfig.xml, you can replace the <mergePolicy> element with the following (assuming you
+  use TieredMergePolicy):
+  <mergePolicyFactory class="solr.TieredMergePolicyFactory">
+    <int name="maxMergeAtOnce">10</int>
+    <double name="maxMergedSegmentMB">5120</double>
+    ...
+  </mergePolicyFactory>
+
 Detailed Change List
 ----------------------
 
@@ -356,6 +365,10 @@ New Features
 * SOLR-8642: SOLR allows creation of collections with invalid names
   (Jason Gerlowski via Erick Erickson)
 
+* SOLR-8621: Deprecate <mergePolicy> in favor of <mergePolicyFactory>. It allows to configure
+  both the "simple" merge policies, but also more advanced ones, e.g. UpgradeIndexMergePolicy.
+  (Christine Poerschke, Shai Erera)
+
 Bug Fixes
 ----------------------
 
diff --git a/solr/core/src/java/org/apache/solr/index/DefaultMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/DefaultMergePolicyFactory.java
new file mode 100644
index 0000000..101204b
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/DefaultMergePolicyFactory.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.lucene.index.TieredMergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for the default {@link MergePolicy}.
+ */
+public class DefaultMergePolicyFactory extends MergePolicyFactory {
+
+  public DefaultMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+    if (!args.keys().isEmpty()) {
+      throw new IllegalArgumentException("Arguments were "+args+" but "+getClass().getSimpleName()+" takes no arguments.");
+    }
+  }
+
+  public DefaultMergePolicyFactory() {
+    super(null, null);
+  }
+
+  @Override
+  public final MergePolicy getMergePolicy() {
+    return new TieredMergePolicy();
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/LogByteSizeMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/LogByteSizeMergePolicyFactory.java
new file mode 100644
index 0000000..6f1c092
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/LogByteSizeMergePolicyFactory.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.LogByteSizeMergePolicy;
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for {@link LogByteSizeMergePolicy} objects.
+ */
+public class LogByteSizeMergePolicyFactory extends SimpleMergePolicyFactory {
+
+  public LogByteSizeMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+  }
+
+  @Override
+  protected MergePolicy getMergePolicyInstance() {
+    return new LogByteSizeMergePolicy();
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/LogDocMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/LogDocMergePolicyFactory.java
new file mode 100644
index 0000000..1ada776
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/LogDocMergePolicyFactory.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.LogDocMergePolicy;
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for {@link LogDocMergePolicy} objects.
+ */
+public class LogDocMergePolicyFactory extends SimpleMergePolicyFactory {
+
+  public LogDocMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+  }
+
+  @Override
+  protected MergePolicy getMergePolicyInstance() {
+    return new LogDocMergePolicy();
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/MergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/MergePolicyFactory.java
new file mode 100644
index 0000000..5dfba20
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/MergePolicyFactory.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A factory for creating a {@link MergePolicy}.
+ */
+public abstract class MergePolicyFactory {
+
+  protected final MergePolicyFactoryArgs args;
+  protected final SolrResourceLoader resourceLoader;
+
+  protected MergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    this.resourceLoader = resourceLoader;
+    this.args = args;
+  }
+
+  public abstract MergePolicy getMergePolicy();
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/MergePolicyFactoryArgs.java b/solr/core/src/java/org/apache/solr/index/MergePolicyFactoryArgs.java
new file mode 100644
index 0000000..e2e6672
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/MergePolicyFactoryArgs.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.util.SolrPluginUtils;
+
+public class MergePolicyFactoryArgs {
+
+  private final Map<String,Object> args;
+
+  public MergePolicyFactoryArgs() {
+    this.args = new HashMap<>();
+  }
+
+  public MergePolicyFactoryArgs(Iterable<Map.Entry<String,Object>> args) {
+    this.args = new HashMap<>();
+    for (final Map.Entry<String,Object> arg : args) {
+      this.args.put(arg.getKey(), arg.getValue());
+    }
+  }
+
+  public void add(String key, Object val) {
+    args.put(key, val);
+  }
+
+  public Object remove(String key) {
+    return args.remove(key);
+  }
+
+  public Object get(String key) {
+    return args.get(key);
+  }
+
+  public Set<String> keys() {
+    return args.keySet();
+  }
+
+  public void invokeSetters(MergePolicy policy) {
+    SolrPluginUtils.invokeSetters(policy, args.entrySet());
+  }
+
+  @Override
+  public String toString() {
+    return args.toString();
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/SimpleMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/SimpleMergePolicyFactory.java
new file mode 100644
index 0000000..6e975bc
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/SimpleMergePolicyFactory.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for simple {@link MergePolicy} objects. Implementations need only create the policy
+ * {@link #getMergePolicyInstance() instance} and this class will then configure it with all set properties.
+ */
+public abstract class SimpleMergePolicyFactory extends MergePolicyFactory {
+
+  protected SimpleMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+  }
+
+  protected abstract MergePolicy getMergePolicyInstance();
+
+  @Override
+  public final MergePolicy getMergePolicy() {
+    final MergePolicy mp = getMergePolicyInstance();
+    args.invokeSetters(mp);
+    return mp;
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/TieredMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/TieredMergePolicyFactory.java
new file mode 100644
index 0000000..6481f01
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/TieredMergePolicyFactory.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.lucene.index.TieredMergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for {@link TieredMergePolicy} objects.
+ */
+public class TieredMergePolicyFactory extends SimpleMergePolicyFactory {
+
+  public TieredMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+  }
+
+  @Override
+  protected MergePolicy getMergePolicyInstance() {
+    return new TieredMergePolicy();
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/UpgradeIndexMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/UpgradeIndexMergePolicyFactory.java
new file mode 100644
index 0000000..d9d4f4b
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/UpgradeIndexMergePolicyFactory.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.lucene.index.UpgradeIndexMergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for {@link UpgradeIndexMergePolicy} objects.
+ */
+public class UpgradeIndexMergePolicyFactory extends WrapperMergePolicyFactory {
+
+  public UpgradeIndexMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+  }
+
+  @Override
+  public MergePolicy getMergePolicy() {
+    final MergePolicy wrappedMP = getWrappedMergePolicy();
+    final MergePolicy mp = new UpgradeIndexMergePolicy(wrappedMP);
+    args.invokeSetters(mp);
+    return mp;
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/index/WrapperMergePolicyFactory.java b/solr/core/src/java/org/apache/solr/index/WrapperMergePolicyFactory.java
new file mode 100644
index 0000000..e407010
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/index/WrapperMergePolicyFactory.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import java.util.Iterator;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.core.SolrResourceLoader;
+
+/**
+ * A {@link MergePolicyFactory} for wrapping additional {@link MergePolicyFactory factories}.
+ */
+public abstract class WrapperMergePolicyFactory extends MergePolicyFactory {
+
+  private static final String CLASS = "class";
+
+  protected static final String[] NO_SUB_PACKAGES = new String[0];
+
+  static final String WRAPPED_PREFIX = "wrapped.prefix"; // not private so that test(s) can use it
+
+  private final MergePolicyFactoryArgs wrappedMergePolicyArgs;
+
+  protected WrapperMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs args) {
+    super(resourceLoader, args);
+    wrappedMergePolicyArgs = filterWrappedMergePolicyFactoryArgs();
+  }
+
+  /**
+   * Returns the default wrapped {@link MergePolicy}. This is called if the factory settings do not explicitly specify
+   * the wrapped policy.
+   */
+  protected MergePolicy getDefaultWrappedMergePolicy() {
+    final MergePolicyFactory mpf = new DefaultMergePolicyFactory();
+    return mpf.getMergePolicy();
+  }
+
+  /** Returns an instance of the wrapped {@link MergePolicy} after it has been configured with all set parameters. */
+  protected final MergePolicy getWrappedMergePolicy() {
+    if (wrappedMergePolicyArgs == null) {
+      return getDefaultWrappedMergePolicy();
+    }
+
+    final String className = (String) wrappedMergePolicyArgs.remove(CLASS);
+    if (className == null) {
+      throw new IllegalArgumentException("Class name not defined for wrapped MergePolicyFactory!");
+    }
+
+    final MergePolicyFactory mpf = resourceLoader.newInstance(
+        className,
+        MergePolicyFactory.class,
+        NO_SUB_PACKAGES,
+        new Class[] {SolrResourceLoader.class, MergePolicyFactoryArgs.class},
+        new Object[] {resourceLoader, wrappedMergePolicyArgs});
+    return mpf.getMergePolicy();
+  }
+
+  /**
+   * Returns a {@link MergePolicyFactoryArgs} for the wrapped {@link MergePolicyFactory}. This method also removes all
+   * args from this instance's args.
+   */
+  private MergePolicyFactoryArgs filterWrappedMergePolicyFactoryArgs() {
+    final String wrappedPolicyPrefix = (String) args.remove(WRAPPED_PREFIX);
+    if (wrappedPolicyPrefix == null) {
+      return null;
+    }
+
+    final String baseArgsPrefix = wrappedPolicyPrefix + '.';
+    final int baseArgsPrefixLength = baseArgsPrefix.length();
+    final MergePolicyFactoryArgs wrappedArgs = new MergePolicyFactoryArgs();
+    for (final Iterator<String> iter = args.keys().iterator(); iter.hasNext();) {
+      final String key = iter.next();
+      if (key.startsWith(baseArgsPrefix)) {
+        wrappedArgs.add(key.substring(baseArgsPrefixLength), args.get(key));
+        iter.remove();
+      }
+    }
+    return wrappedArgs;
+  }
+
+}
diff --git a/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java b/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
index a1ad771..cf30c56 100644
--- a/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
+++ b/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
@@ -16,14 +16,21 @@
  */
 package org.apache.solr.update;
 
+import static org.apache.solr.core.Config.assertWarnOrFail;
+
 import java.lang.invoke.MethodHandles;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.DelegatingAnalyzerWrapper;
-import org.apache.lucene.index.*;
+import org.apache.lucene.index.ConcurrentMergeScheduler;
 import org.apache.lucene.index.IndexWriter.IndexReaderWarmer;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.LogMergePolicy;
+import org.apache.lucene.index.MergePolicy;
+import org.apache.lucene.index.MergeScheduler;
+import org.apache.lucene.index.TieredMergePolicy;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.Version;
 import org.apache.solr.common.util.NamedList;
@@ -33,21 +40,25 @@ import org.apache.solr.core.MapSerializable;
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
+import org.apache.solr.core.SolrResourceLoader;
+import org.apache.solr.index.DefaultMergePolicyFactory;
+import org.apache.solr.index.MergePolicyFactory;
+import org.apache.solr.index.MergePolicyFactoryArgs;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.util.SolrPluginUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.solr.core.Config.assertWarnOrFail;
-
 /**
  * This config object encapsulates IndexWriter config params,
  * defined in the &lt;indexConfig&gt; section of solrconfig.xml
  */
 public class SolrIndexConfig implements MapSerializable {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
-  
-  final String defaultMergePolicyClassName;
+
+  private static final String NO_SUB_PACKAGES[] = new String[0];
+
+  private final DefaultMergePolicyFactory defaultMergePolicyFactory = new DefaultMergePolicyFactory();
   public static final String DEFAULT_MERGE_SCHEDULER_CLASSNAME = ConcurrentMergeScheduler.class.getName();
   public final Version luceneVersion;
 
@@ -62,6 +73,7 @@ public class SolrIndexConfig implements MapSerializable {
   public final int writeLockTimeout;
   public final String lockType;
   public final PluginInfo mergePolicyInfo;
+  public final PluginInfo mergePolicyFactoryInfo;
   public final PluginInfo mergeSchedulerInfo;
   
   public final PluginInfo mergedSegmentWarmerInfo;
@@ -71,7 +83,6 @@ public class SolrIndexConfig implements MapSerializable {
   /**
    * Internal constructor for setting defaults based on Lucene Version
    */
-  @SuppressWarnings("deprecation")
   private SolrIndexConfig(SolrConfig solrConfig) {
     luceneVersion = solrConfig.luceneMatchVersion;
     effectiveUseCompoundFileSetting = false;
@@ -82,8 +93,8 @@ public class SolrIndexConfig implements MapSerializable {
     writeLockTimeout = -1;
     lockType = DirectoryFactory.LOCK_TYPE_NATIVE;
     mergePolicyInfo = null;
+    mergePolicyFactoryInfo = null;
     mergeSchedulerInfo = null;
-    defaultMergePolicyClassName = TieredMergePolicy.class.getName();
     mergedSegmentWarmerInfo = null;
   }
   
@@ -93,7 +104,6 @@ public class SolrIndexConfig implements MapSerializable {
    * @param prefix the XPath prefix for which section to parse (mandatory)
    * @param def a SolrIndexConfig instance to pick default values from (optional)
    */
-  @SuppressWarnings("deprecation")
   public SolrIndexConfig(SolrConfig solrConfig, String prefix, SolrIndexConfig def)  {
     if (prefix == null) {
       prefix = "indexConfig";
@@ -122,7 +132,6 @@ public class SolrIndexConfig implements MapSerializable {
         solrConfig.get(prefix + "/luceneAutoCommit", null) == null,
         true);
 
-    defaultMergePolicyClassName = def.defaultMergePolicyClassName;
     effectiveUseCompoundFileSetting = solrConfig.getBool(prefix+"/useCompoundFile", def.getUseCompoundFile());
     maxBufferedDocs=solrConfig.getInt(prefix+"/maxBufferedDocs",def.maxBufferedDocs);
     maxMergeDocs=solrConfig.getInt(prefix+"/maxMergeDocs",def.maxMergeDocs);
@@ -134,7 +143,18 @@ public class SolrIndexConfig implements MapSerializable {
 
     mergeSchedulerInfo = getPluginInfo(prefix + "/mergeScheduler", solrConfig, def.mergeSchedulerInfo);
     mergePolicyInfo = getPluginInfo(prefix + "/mergePolicy", solrConfig, def.mergePolicyInfo);
-    
+    mergePolicyFactoryInfo = getPluginInfo(prefix + "/mergePolicyFactory", solrConfig, def.mergePolicyInfo);
+    if (mergePolicyInfo != null && mergePolicyFactoryInfo != null) {
+      throw new IllegalArgumentException("<mergePolicy> and <mergePolicyFactory> are mutually exclusive.");
+    }
+
+    assertWarnOrFail("Beginning with Solr 5.5, <mergePolicy> is deprecated, use <mergePolicyFactory> instead.",
+        (mergePolicyInfo == null), false);
+    assertWarnOrFail("Beginning with Solr 5.5, <maxMergeDocs> is deprecated, configure it on the relevant <mergePolicyFactory> instead.",
+        (mergePolicyFactoryInfo != null && maxMergeDocs == def.maxMergeDocs), false);
+    assertWarnOrFail("Beginning with Solr 5.5, <mergeFactor> is deprecated, configure it on the relevant <mergePolicyFactory> instead.",
+        (mergePolicyFactoryInfo != null && mergeFactor == def.mergeFactor), false);
+
     String val = solrConfig.get(prefix + "/termIndexInterval", null);
     if (val != null) {
       throw new IllegalArgumentException("Illegal parameter 'termIndexInterval'");
@@ -156,6 +176,7 @@ public class SolrIndexConfig implements MapSerializable {
         (null == solrConfig.getNode(prefix + "/checkIntegrityAtMerge", false)),
         true);
   }
+
   @Override
   public Map<String, Object> toMap() {
     Map<String, Object> m = Utils.makeMap("useCompoundFile", effectiveUseCompoundFileSetting,
@@ -222,6 +243,38 @@ public class SolrIndexConfig implements MapSerializable {
     return iwc;
   }
 
+  private boolean useMergePolicyInfo() {
+    return mergePolicyInfo != null || maxMergeDocs != -1 || mergeFactor != -1;
+  }
+
+  /**
+   * Builds a MergePolicy using the configured MergePolicyFactory
+   * or if no factory is configured uses the configured mergePolicy PluginInfo.
+   */
+  @SuppressWarnings("unchecked")
+  private MergePolicy buildMergePolicy(final IndexSchema schema) {
+    if (useMergePolicyInfo()) {
+      return buildMergePolicyFromInfo(schema);
+    }
+
+    final MergePolicyFactory mpf;
+    if (mergePolicyFactoryInfo == null) {
+      mpf = defaultMergePolicyFactory;
+    } else {
+      final String mpfClassName = mergePolicyFactoryInfo.className;
+      final MergePolicyFactoryArgs mpfArgs = new MergePolicyFactoryArgs(mergePolicyFactoryInfo.initArgs);
+      final SolrResourceLoader resourceLoader = schema.getResourceLoader();
+      mpf = resourceLoader.newInstance(
+          mpfClassName,
+          MergePolicyFactory.class,
+          NO_SUB_PACKAGES,
+          new Class[] { SolrResourceLoader.class, MergePolicyFactoryArgs.class },
+          new Object[] { resourceLoader, mpfArgs });
+    }
+
+    return mpf.getMergePolicy();
+  }
+
   /**
    * Builds a MergePolicy, may also modify the value returned by
    * getUseCompoundFile() for use by the IndexWriterConfig if 
@@ -231,10 +284,13 @@ public class SolrIndexConfig implements MapSerializable {
    * @see #fixUseCFMergePolicyInitArg
    * @see #getUseCompoundFile
    */
-  private MergePolicy buildMergePolicy(IndexSchema schema) {
-    String mpClassName = mergePolicyInfo == null ? defaultMergePolicyClassName : mergePolicyInfo.className;
-
-    MergePolicy policy = schema.getResourceLoader().newInstance(mpClassName, MergePolicy.class);
+  private MergePolicy buildMergePolicyFromInfo(IndexSchema schema) {
+    final MergePolicy policy;
+    if (mergePolicyInfo == null) {
+      policy = defaultMergePolicyFactory.getMergePolicy();
+    } else {
+      policy = schema.getResourceLoader().newInstance(mergePolicyInfo.className, MergePolicy.class);
+    }
 
     if (policy instanceof LogMergePolicy) {
       LogMergePolicy logMergePolicy = (LogMergePolicy) policy;
@@ -245,23 +301,21 @@ public class SolrIndexConfig implements MapSerializable {
 
       if (mergeFactor != -1)
         logMergePolicy.setMergeFactor(mergeFactor);
-
     } else if (policy instanceof TieredMergePolicy) {
       TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;
       fixUseCFMergePolicyInitArg(TieredMergePolicy.class);
-      
+
       if (mergeFactor != -1) {
         tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);
         tieredMergePolicy.setSegmentsPerTier(mergeFactor);
       }
-
-
     } else if (mergeFactor != -1) {
       log.warn("Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.");
     }
 
-    if (mergePolicyInfo != null)
+    if (mergePolicyInfo != null) {
       SolrPluginUtils.invokeSetters(policy, mergePolicyInfo.initArgs);
+    }
 
     return policy;
   }
diff --git a/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java b/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
index 9f9d115..debec54 100644
--- a/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
+++ b/solr/core/src/java/org/apache/solr/util/SolrPluginUtils.java
@@ -24,7 +24,6 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -33,8 +32,8 @@ import java.util.regex.Pattern;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
@@ -51,7 +50,6 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.core.RequestParams;
-import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.component.HighlightComponent;
 import org.apache.solr.handler.component.ResponseBuilder;
 import org.apache.solr.handler.component.ShardDoc;
@@ -1041,28 +1039,15 @@ public class SolrPluginUtils {
   }
 
 
-  public static void invokeSetters(Object bean, NamedList initArgs) {
+  public static void invokeSetters(Object bean, Iterable<Map.Entry<String,Object>> initArgs) {
     if (initArgs == null) return;
-    Class clazz = bean.getClass();
-    Method[] methods = clazz.getMethods();
-    Iterator<Map.Entry<String, Object>> iterator = initArgs.iterator();
-    while (iterator.hasNext()) {
-      Map.Entry<String, Object> entry = iterator.next();
+    final Class<?> clazz = bean.getClass();
+    for (Map.Entry<String,Object> entry : initArgs) {
       String key = entry.getKey();
       String setterName = "set" + String.valueOf(Character.toUpperCase(key.charAt(0))) + key.substring(1);
-      Method method = null;
       try {
-        for (Method m : methods) {
-          if (m.getName().equals(setterName) && m.getParameterTypes().length == 1) {
-            method = m;
-            break;
-          }
-        }
-        if (method == null) {
-          throw new RuntimeException("no setter corrresponding to '" + key + "' in " + clazz.getName());
-        }
-        Class pClazz = method.getParameterTypes()[0];
-        Object val = entry.getValue();
+        final Method method = findSetter(clazz, setterName, key);
+        final Object val = entry.getValue();
         method.invoke(bean, val);
       } catch (InvocationTargetException | IllegalAccessException e1) {
         throw new RuntimeException("Error invoking setter " + setterName + " on class : " + clazz.getName(), e1);
@@ -1070,7 +1055,14 @@ public class SolrPluginUtils {
     }
   }
 
-
+  private static Method findSetter(Class<?> clazz, String setterName, String key) {
+    for (Method m : clazz.getMethods()) {
+      if (m.getName().equals(setterName) && m.getParameterTypes().length == 1) {
+        return m;
+      }
+    }
+    throw new RuntimeException("No setter corrresponding to '" + key + "' in " + clazz.getName());
+  }
 
    /**
    * Given the integer purpose of a request generates a readable value corresponding 
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig-tieredmergepolicyfactory.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig-tieredmergepolicyfactory.xml
new file mode 100644
index 0000000..ebf360d
--- /dev/null
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig-tieredmergepolicyfactory.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" ?>
+
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<config>
+  <luceneMatchVersion>${tests.luceneMatchVersion:LATEST}</luceneMatchVersion>
+  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.RAMDirectoryFactory}"/>
+  <schemaFactory class="ClassicIndexSchemaFactory"/>
+
+  <indexConfig>
+    <mergePolicyFactory class="org.apache.solr.index.TieredMergePolicyFactory">
+      <int name="maxMergeAtOnceExplicit">19</int>
+      <int name="segmentsPerTier">9</int>
+      <double name="noCFSRatio">0.1</double>
+    </mergePolicyFactory>
+    <mergeScheduler class="org.apache.lucene.index.ConcurrentMergeScheduler">
+      <int name="maxMergeCount">987</int>
+      <int name="maxThreadCount">42</int>
+    </mergeScheduler>
+  </indexConfig>
+
+  <requestHandler name="standard" class="solr.StandardRequestHandler"></requestHandler>
+
+</config>
diff --git a/solr/core/src/test-files/solr/collection1/conf/solrconfig.snippet.randomindexconfig.xml b/solr/core/src/test-files/solr/collection1/conf/solrconfig.snippet.randomindexconfig.xml
index 069ccb8..a23bf0a 100644
--- a/solr/core/src/test-files/solr/collection1/conf/solrconfig.snippet.randomindexconfig.xml
+++ b/solr/core/src/test-files/solr/collection1/conf/solrconfig.snippet.randomindexconfig.xml
@@ -26,7 +26,7 @@ A solrconfig.xml snippet containing indexConfig settings for randomized testing.
        the RandomMergePolicy in all tests - but some tests expect very specific
        Merge behavior, so those tests can set it as needed.
   -->
-  <mergePolicy class="${solr.tests.mergePolicy:org.apache.solr.util.RandomMergePolicy}" />
+  <mergePolicyFactory class="org.apache.solr.util.RandomMergePolicyFactory" />
   
   <useCompoundFile>${useCompoundFile:false}</useCompoundFile>
 
diff --git a/solr/core/src/test/org/apache/solr/core/TestMergePolicyConfig.java b/solr/core/src/test/org/apache/solr/core/TestMergePolicyConfig.java
index 5b2c912..cea6996 100644
--- a/solr/core/src/test/org/apache/solr/core/TestMergePolicyConfig.java
+++ b/solr/core/src/test/org/apache/solr/core/TestMergePolicyConfig.java
@@ -72,16 +72,13 @@ public class TestMergePolicyConfig extends SolrTestCaseJ4 {
   }
 
   public void testLegacyMergePolicyConfig() throws Exception {
-    final boolean expectCFS 
-      = Boolean.parseBoolean(System.getProperty("useCompoundFile"));
+    final boolean expectCFS = Boolean.parseBoolean(System.getProperty("useCompoundFile"));
 
     initCore("solrconfig-mergepolicy-legacy.xml","schema-minimal.xml");
     IndexWriterConfig iwc = solrConfig.indexConfig.toIndexWriterConfig(h.getCore());
     assertEquals(expectCFS, iwc.getUseCompoundFile());
 
-
-    TieredMergePolicy tieredMP = assertAndCast(TieredMergePolicy.class,
-                                               iwc.getMergePolicy());
+    TieredMergePolicy tieredMP = assertAndCast(TieredMergePolicy.class, iwc.getMergePolicy());
 
     assertEquals(7, tieredMP.getMaxMergeAtOnce());
     assertEquals(7.0D, tieredMP.getSegmentsPerTier(), 0.0D);
diff --git a/solr/core/src/test/org/apache/solr/index/WrapperMergePolicyFactoryTest.java b/solr/core/src/test/org/apache/solr/index/WrapperMergePolicyFactoryTest.java
new file mode 100644
index 0000000..ee8eb71
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/index/WrapperMergePolicyFactoryTest.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.index;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.lucene.index.NoMergePolicy;
+import org.apache.lucene.index.TieredMergePolicy;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.core.SolrResourceLoader;
+
+/** Unit tests for {@link WrapperMergePolicyFactory}. */
+public class WrapperMergePolicyFactoryTest extends SolrTestCaseJ4 {
+
+  private final SolrResourceLoader resourceLoader = new SolrResourceLoader();
+
+  public void testReturnsDefaultMergePolicyIfNoneSpecified() {
+    final MergePolicyFactoryArgs args = new MergePolicyFactoryArgs();
+    MergePolicyFactory mpf = new DefaultingWrapperMergePolicyFactory(resourceLoader, args);
+    assertSame(mpf.getMergePolicy(), NoMergePolicy.INSTANCE);
+  }
+
+  public void testFailsIfNoClassSpecifiedForWrappedPolicy() {
+    final MergePolicyFactoryArgs args = new MergePolicyFactoryArgs();
+    args.add(WrapperMergePolicyFactory.WRAPPED_PREFIX, "foo");
+    try {
+      new DefaultingWrapperMergePolicyFactory(resourceLoader, args).getMergePolicy();
+      fail("Should have failed when no 'class' specified for wrapped merge policy");
+    } catch (final IllegalArgumentException e) {
+      // Good!
+    }
+  }
+
+  public void testProperlyInitializesWrappedMergePolicy() {
+    final TieredMergePolicy defaultTMP = new TieredMergePolicy();
+    final int testMaxMergeAtOnce = defaultTMP.getMaxMergeAtOnce() * 2;
+    final double testMaxMergedSegmentMB = defaultTMP.getMaxMergedSegmentMB() * 10;
+
+    final MergePolicyFactoryArgs args = new MergePolicyFactoryArgs();
+    args.add(WrapperMergePolicyFactory.WRAPPED_PREFIX, "test");
+    args.add("test.class", TieredMergePolicyFactory.class.getName());
+    args.add("test.maxMergeAtOnce", testMaxMergeAtOnce);
+    args.add("test.maxMergedSegmentMB", testMaxMergedSegmentMB);
+    MergePolicyFactory mpf = new DefaultingWrapperMergePolicyFactory(resourceLoader, args) {
+      @Override
+      protected MergePolicy getDefaultWrappedMergePolicy() {
+        throw new IllegalStateException("Should not have reached here!");
+      }
+    };
+    final MergePolicy mp = mpf.getMergePolicy();
+    assertSame(mp.getClass(), TieredMergePolicy.class);
+    final TieredMergePolicy tmp = (TieredMergePolicy)mp;
+    assertEquals("maxMergeAtOnce", testMaxMergeAtOnce, tmp.getMaxMergeAtOnce());
+    assertEquals("maxMergedSegmentMB", testMaxMergedSegmentMB, tmp.getMaxMergedSegmentMB(), 0.0d);
+  }
+
+  private static class DefaultingWrapperMergePolicyFactory extends WrapperMergePolicyFactory {
+
+    DefaultingWrapperMergePolicyFactory(SolrResourceLoader resourceLoader, MergePolicyFactoryArgs wrapperArgs) {
+      super(resourceLoader, wrapperArgs);
+      if (!args.keys().isEmpty()) {
+        throw new IllegalArgumentException("All arguments should have been claimed by the wrapped policy but some ("+args+") remain.");
+      }
+    }
+
+    @Override
+    protected MergePolicy getDefaultWrappedMergePolicy() {
+      return NoMergePolicy.INSTANCE;
+    }
+
+    @Override
+    public MergePolicy getMergePolicy() {
+      return getWrappedMergePolicy();
+    }
+
+  }
+
+}
diff --git a/solr/core/src/test/org/apache/solr/update/SolrIndexConfigTest.java b/solr/core/src/test/org/apache/solr/update/SolrIndexConfigTest.java
index 6a291dc..a51d5fb 100644
--- a/solr/core/src/test/org/apache/solr/update/SolrIndexConfigTest.java
+++ b/solr/core/src/test/org/apache/solr/update/SolrIndexConfigTest.java
@@ -42,7 +42,7 @@ public class SolrIndexConfigTest extends SolrTestCaseJ4 {
   private static final String solrConfigFileName = "solrconfig.xml";
   private static final String solrConfigFileNameWarmer = "solrconfig-warmer.xml";
   private static final String solrConfigFileNameTieredMergePolicy = "solrconfig-tieredmergepolicy.xml";
-
+  private static final String solrConfigFileNameTieredMergePolicyFactory = "solrconfig-tieredmergepolicyfactory.xml";
   private static final String schemaFileName = "schema.xml";
 
   @BeforeClass
@@ -68,10 +68,9 @@ public class SolrIndexConfigTest extends SolrTestCaseJ4 {
 
   @Test
   public void testTieredMPSolrIndexConfigCreation() throws Exception {
-    SolrConfig solrConfig = new SolrConfig(instanceDir, solrConfigFileNameTieredMergePolicy, null);
-    SolrIndexConfig solrIndexConfig = new SolrIndexConfig(solrConfig, null,
-        null);
-    assertNotNull(solrIndexConfig);
+    String solrConfigFileName = random().nextBoolean() ? solrConfigFileNameTieredMergePolicy : solrConfigFileNameTieredMergePolicyFactory;
+    SolrConfig solrConfig = new SolrConfig(instanceDir, solrConfigFileName, null);
+    SolrIndexConfig solrIndexConfig = new SolrIndexConfig(solrConfig, null, null);
     IndexSchema indexSchema = IndexSchemaFactory.buildIndexSchema(schemaFileName, solrConfig);
     
     h.getCore().setLatestSchema(indexSchema);
@@ -105,11 +104,16 @@ public class SolrIndexConfigTest extends SolrTestCaseJ4 {
   }
 
   public void testToMap() throws Exception {
-    final String solrConfigFileName = (random().nextBoolean() ? solrConfigFileNameWarmer : solrConfigFileNameTieredMergePolicy);
+    final String solrConfigFileNameTMP = random().nextBoolean() ? solrConfigFileNameTieredMergePolicy : solrConfigFileNameTieredMergePolicyFactory;
+    final String solrConfigFileName = (random().nextBoolean() ? solrConfigFileNameWarmer : solrConfigFileNameTMP);
     SolrConfig solrConfig = new SolrConfig(instanceDir, solrConfigFileName, null);
     SolrIndexConfig solrIndexConfig = new SolrIndexConfig(solrConfig, null, null);
     assertNotNull(solrIndexConfig);
-    assertNotNull(solrIndexConfig.mergePolicyInfo);
+    if (solrConfigFileName.equals(solrConfigFileNameTieredMergePolicyFactory)) {
+      assertNotNull(solrIndexConfig.mergePolicyFactoryInfo);
+    } else {
+      assertNotNull(solrIndexConfig.mergePolicyInfo);
+    }
     if (solrConfigFileName.equals(solrConfigFileNameWarmer)) {
       assertNotNull(solrIndexConfig.mergedSegmentWarmerInfo);
     } else {
diff --git a/solr/test-framework/src/java/org/apache/solr/util/RandomMergePolicyFactory.java b/solr/test-framework/src/java/org/apache/solr/util/RandomMergePolicyFactory.java
new file mode 100644
index 0000000..e6e28c8
--- /dev/null
+++ b/solr/test-framework/src/java/org/apache/solr/util/RandomMergePolicyFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.util;
+
+import org.apache.lucene.index.MergePolicy;
+import org.apache.solr.index.MergePolicyFactory;
+import org.apache.solr.index.MergePolicyFactoryArgs;
+
+/** A {@link MergePolicyFactory} for {@link RandomMergePolicy}. */
+public final class RandomMergePolicyFactory extends MergePolicyFactory {
+
+  public RandomMergePolicyFactory() {
+    super(null, new MergePolicyFactoryArgs());
+  }
+
+  @Override
+  public MergePolicy getMergePolicy() {
+    return new RandomMergePolicy();
+  }
+
+}

