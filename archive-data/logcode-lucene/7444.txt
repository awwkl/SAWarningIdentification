GitDiffStart: f8ae207e8065d4a7de3dacc766762b98ac037d28 | Sun Nov 24 22:15:28 2013 +0000
diff --git a/TODO b/TODO
index 5f146ac..5976523 100644
--- a/TODO
+++ b/TODO
@@ -2,15 +2,14 @@ nocommit this!
 
 TODO
   - allow path.length==0?
+  - need test coverage of utility search methods
   - move DocumentBuilder.build -> FacetsConfig.build
-  - add sugar apis to do sort-by-score, sort-by-field sort AND collect into SimpleFacetsCollector?
   - getSpecificValue for a dim isn't reliable
   - we could put more stuff into the "schema", e.g. this field is
     sorted-set-DV and that one is taxo?
   - standardize on facet or facets (e.g. FacetIndexWriter)
   - fewer args when constructing a range
   - how to do avg() agg?
-  - test needsScores=true / valuesource associations
   - consistently name things "dimension"? calling these fields is CONFUSING
   - later
     - SSDVValueSourceFacets?
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/Facets.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/Facets.java
index 7ec0127..f6f5fb7 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/Facets.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/Facets.java
@@ -20,6 +20,17 @@ package org.apache.lucene.facet.simple;
 import java.io.IOException;
 import java.util.List;
 
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.FilteredQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.TopFieldCollector;
+import org.apache.lucene.search.TopFieldDocs;
+import org.apache.lucene.search.TopScoreDocCollector;
+
 public abstract class Facets {
   /** Returns the topN child labels under the specified
    *  path.  Returns null if the specified path doesn't
@@ -36,4 +47,75 @@ public abstract class Facets {
    *  different dimensions were indexed depending on the
    *  type of document. */
   public abstract List<SimpleFacetResult> getAllDims(int topN) throws IOException;
+
+  // nocommit where to move?
+
+  /** Utility method, to search for top hits by score
+   *  ({@link IndexSearcher#search(Query,int)}), but
+   *  also collect results into a {@link
+   *  SimpleFacetsCollector} for faceting. */
+  public static TopDocs search(IndexSearcher searcher, Query q, int topN, SimpleFacetsCollector sfc) throws IOException {
+    // nocommit can we pass the "right" boolean for
+    // in-order...?  we'd need access to the protected
+    // IS.search methods taking Weight... could use
+    // reflection...
+    TopScoreDocCollector hitsCollector = TopScoreDocCollector.create(topN, false);
+    searcher.search(q, MultiCollector.wrap(hitsCollector, sfc));
+    return hitsCollector.topDocs();
+  }
+
+  // nocommit where to move?
+
+  /** Utility method, to search for top hits by score with a filter
+   *  ({@link IndexSearcher#search(Query,Filter,int)}), but
+   *  also collect results into a {@link
+   *  SimpleFacetsCollector} for faceting. */
+  public static TopDocs search(IndexSearcher searcher, Query q, Filter filter, int topN, SimpleFacetsCollector sfc) throws IOException {
+    if (filter != null) {
+      q = new FilteredQuery(q, filter);
+    }
+    return search(searcher, q, topN, sfc);
+  }
+
+  // nocommit where to move?
+
+  /** Utility method, to search for top hits by a custom
+   *  {@link Sort} with a filter
+   *  ({@link IndexSearcher#search(Query,Filter,int,Sort)}), but
+   *  also collect results into a {@link
+   *  SimpleFacetsCollector} for faceting. */
+  public static TopFieldDocs search(IndexSearcher searcher, Query q, Filter filter, int topN, Sort sort, SimpleFacetsCollector sfc) throws IOException {
+    return search(searcher, q, filter, topN, sort, false, false, sfc);
+  }
+
+  // nocommit where to move?
+
+  /** Utility method, to search for top hits by a custom
+   *  {@link Sort} with a filter
+   *  ({@link IndexSearcher#search(Query,Filter,int,Sort,boolean,boolean)}), but
+   *  also collect results into a {@link
+   *  SimpleFacetsCollector} for faceting. */
+  public static TopFieldDocs search(IndexSearcher searcher, Query q, Filter filter, int topN, Sort sort, boolean doDocScores, boolean doMaxScore, SimpleFacetsCollector sfc) throws IOException {
+    int limit = searcher.getIndexReader().maxDoc();
+    if (limit == 0) {
+      limit = 1;
+    }
+    topN = Math.min(topN, limit);
+
+    boolean fillFields = true;
+    TopFieldCollector hitsCollector = TopFieldCollector.create(sort, topN,
+                                                               null,
+                                                               fillFields,
+                                                               doDocScores,
+                                                               doMaxScore,
+                                                               false);
+    if (filter != null) {
+      q = new FilteredQuery(q, filter);
+    }
+    searcher.search(q, MultiCollector.wrap(hitsCollector, sfc));
+    return (TopFieldDocs) hitsCollector.topDocs();
+  }
+
+  // nocommit need searchAfter variants too
+
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/FastTaxonomyFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/FastTaxonomyFacetCounts.java
index 42697e6..1e59fec 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/FastTaxonomyFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/FastTaxonomyFacetCounts.java
@@ -185,6 +185,6 @@ public class FastTaxonomyFacetCounts extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[cp.length], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(cp, totCount, labelValues, childCount);
+    return new SimpleFacetResult(totCount, labelValues, childCount);
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
index b1e6492..65d3232 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
@@ -95,7 +95,7 @@ public class RangeFacetCounts extends Facets {
       labelValues[i] = new LabelAndValue(ranges[i].label, counts[i]);
     }
 
-    return new SimpleFacetResult(new FacetLabel(field), totCount, labelValues, labelValues.length);
+    return new SimpleFacetResult(totCount, labelValues, labelValues.length);
   }
 
   @Override
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
index cbbba15..58a1a22 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
@@ -20,11 +20,7 @@ package org.apache.lucene.facet.simple;
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-
 public final class SimpleFacetResult {
-  /** Path whose children we counted. */
-  public final FacetLabel path;
 
   /** Total value for this path (sum of all child counts, or
    *  sum of all child values), even those not included in
@@ -38,8 +34,7 @@ public final class SimpleFacetResult {
   /** Child counts. */
   public final LabelAndValue[] labelValues;
 
-  public SimpleFacetResult(FacetLabel path, Number value, LabelAndValue[] labelValues, int childCount) {
-    this.path = path;
+  public SimpleFacetResult(Number value, LabelAndValue[] labelValues, int childCount) {
     this.value = value;
     this.labelValues = labelValues;
     this.childCount = childCount;
@@ -48,12 +43,11 @@ public final class SimpleFacetResult {
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder();
-    if (path == null) {
-      sb.append("null");
-    } else {
-      sb.append(path.toString());
-    }
-    sb.append(" (" + value + ")\n");
+    sb.append("value=");
+    sb.append(value);
+    sb.append(" childCount=");
+    sb.append(childCount);
+    sb.append('\n');
     for(LabelAndValue labelValue : labelValues) {
       sb.append("  " + labelValue + "\n");
     }
@@ -66,8 +60,8 @@ public final class SimpleFacetResult {
       return false;
     }
     SimpleFacetResult other = (SimpleFacetResult) _other;
-    return path.equals(other.path) &&
-      value.equals(other.value) &&
+    return value.equals(other.value) &&
+      childCount == other.childCount &&
       Arrays.equals(labelValues, other.labelValues);
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
index 55f788e..112ac2a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
@@ -135,7 +135,7 @@ public class SortedSetDocValuesFacetCounts extends Facets {
       labelValues[i] = new LabelAndValue(parts[1], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(new FacetLabel(dim), dimCount, labelValues, childCount);
+    return new SimpleFacetResult(dimCount, labelValues, childCount);
   }
 
   /** Does all the "real work" of tallying up the counts. */
@@ -286,8 +286,7 @@ public class SortedSetDocValuesFacetCounts extends Facets {
                          } else if (b.value.intValue() > a.value.intValue()) {
                            return 1;
                          } else {
-                           // Tie break by dimension
-                           return a.path.components[0].compareTo(b.path.components[0]);
+                           return 0;
                          }
                        }
                      });
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
index 6a35428..84ee692 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
@@ -165,6 +165,6 @@ public class TaxonomyFacetCounts extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[cp.length], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(cp, totCount, labelValues, childCount);
+    return new SimpleFacetResult(totCount, labelValues, childCount);
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumFloatAssociations.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumFloatAssociations.java
index 4b261ed..28d0db8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumFloatAssociations.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumFloatAssociations.java
@@ -144,6 +144,6 @@ public class TaxonomyFacetSumFloatAssociations extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[path.length], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(cp, sumValue, labelValues, childCount);
+    return new SimpleFacetResult(sumValue, labelValues, childCount);
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumIntAssociations.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumIntAssociations.java
index c8e73c2..0e5552c 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumIntAssociations.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumIntAssociations.java
@@ -145,6 +145,6 @@ public class TaxonomyFacetSumIntAssociations extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[path.length], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(cp, sumValue, labelValues, childCount);
+    return new SimpleFacetResult(sumValue, labelValues, childCount);
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
index e4a8517..9732da8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
@@ -203,7 +203,7 @@ public class TaxonomyFacetSumValueSource extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[cp.length], ordAndValue.value);
     }
 
-    return new SimpleFacetResult(cp, sumValues, labelValues, childCount);
+    return new SimpleFacetResult(sumValues, labelValues, childCount);
   }
 
   /** {@link ValueSource} that returns the score for each
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacets.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacets.java
index 9a89f6f..fa58fae 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacets.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacets.java
@@ -82,8 +82,7 @@ abstract class TaxonomyFacets extends Facets {
                          } else if (b.value.doubleValue() > a.value.doubleValue()) {
                            return 1;
                          } else {
-                           // Tie break by dimension
-                           return a.path.components[0].compareTo(b.path.components[0]);
+                           return 0;
                          }
                        }
                      });
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/params/CategoryListParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/params/CategoryListParamsTest.java
deleted file mode 100644
index 6fe71c2..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/params/CategoryListParamsTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-package org.apache.lucene.facet.params;
-
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.encoding.DGapVInt8IntEncoder;
-import org.apache.lucene.facet.encoding.IntDecoder;
-import org.apache.lucene.facet.encoding.IntEncoder;
-import org.apache.lucene.facet.encoding.SortingIntEncoder;
-import org.apache.lucene.facet.encoding.UniqueValuesIntEncoder;
-import org.apache.lucene.facet.params.CategoryListParams;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class CategoryListParamsTest extends FacetTestCase {
-
-  @Test
-  public void testDefaultSettings() {
-    CategoryListParams clp = new CategoryListParams();
-    assertEquals("wrong default field", "$facets", clp.field);
-    IntEncoder encoder = new SortingIntEncoder(new UniqueValuesIntEncoder(new DGapVInt8IntEncoder()));
-    IntDecoder decoder = encoder.createMatchingDecoder();
-    assertEquals("unexpected default encoder", encoder.toString(), clp.createEncoder().toString());
-    assertEquals("unexpected default decoder", decoder.toString(), clp.createEncoder().createMatchingDecoder().toString());
-  }
-  
-  /**
-   * Test that the {@link CategoryListParams#hashCode()} and
-   * {@link CategoryListParams#equals(Object)} are consistent.
-   */
-  @Test
-  public void testIdentity() {
-    CategoryListParams clParams1 = new CategoryListParams();
-    // Assert identity is correct - a CategoryListParams equals itself.
-    assertEquals("A CategoryListParams object does not equal itself.",
-        clParams1, clParams1);
-    // For completeness, the object's hashcode equals itself
-    assertEquals("A CategoryListParams object's hashCode does not equal itself.",
-        clParams1.hashCode(), clParams1.hashCode());
-  }
-
-  /**
-   * Test that CategoryListParams behave correctly when compared against each
-   * other.
-   */
-  @Test
-  public void testIdentityConsistency() {
-    // Test 2 CategoryListParams with the default parameter
-    CategoryListParams clParams1 = new CategoryListParams();
-    CategoryListParams clParams2 = new CategoryListParams();
-    assertEquals(
-        "2 CategoryListParams with the same default term should equal each other.",
-        clParams1, clParams2);
-    assertEquals("2 CategoryListParams with the same default term should have the same hashcode",
-        clParams1.hashCode(), clParams2.hashCode());
-
-    // Test 2 CategoryListParams with the same specified Term
-    clParams1 = new CategoryListParams("test");
-    clParams2 = new CategoryListParams("test");
-    assertEquals(
-        "2 CategoryListParams with the same term should equal each other.",
-        clParams1, clParams2);
-    assertEquals("2 CategoryListParams with the same term should have the same hashcode",
-        clParams1.hashCode(), clParams2.hashCode());
-    
-    // Test 2 CategoryListParams with DIFFERENT terms
-    clParams1 = new CategoryListParams("test1");
-    clParams2 = new CategoryListParams("test2");
-    assertFalse(
-        "2 CategoryListParams with the different terms should NOT equal each other.",
-        clParams1.equals(clParams2));
-    assertFalse(
-        "2 CategoryListParams with the different terms should NOT have the same hashcode.",
-        clParams1.hashCode() == clParams2.hashCode());
-  }
-
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java
deleted file mode 100644
index 6dbc5da..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.apache.lucene.facet.params;
-
-import java.util.Collections;
-
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.params.CategoryListParams;
-import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.params.PerDimensionIndexingParams;
-import org.apache.lucene.facet.search.DrillDownQuery;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-import org.apache.lucene.facet.util.PartitionsUtils;
-import org.apache.lucene.index.Term;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class PerDimensionIndexingParamsTest extends FacetTestCase {
-
-  @Test
-  public void testTopLevelSettings() {
-    FacetIndexingParams ifip = new PerDimensionIndexingParams(Collections.<FacetLabel, CategoryListParams>emptyMap());
-    assertNotNull("Missing default category list", ifip.getAllCategoryListParams());
-    assertEquals("Expected default category list field is $facets", "$facets", ifip.getCategoryListParams(null).field);
-    String expectedDDText = "a" + ifip.getFacetDelimChar() + "b";
-    FacetLabel cp = new FacetLabel("a", "b");
-    assertEquals("wrong drill-down term", new Term("$facets", expectedDDText), DrillDownQuery.term(ifip,cp));
-    char[] buf = new char[20];
-    int numchars = ifip.drillDownTermText(cp, buf);
-    assertEquals("3 characters should be written", 3, numchars);
-    assertEquals("wrong drill-down term text", expectedDDText, new String(buf, 0, numchars));
-    
-    assertEquals("partition for all ordinals is the first", "", PartitionsUtils.partitionNameByOrdinal(ifip, 250));
-    assertEquals("for partition 0, the same name should be returned", "", PartitionsUtils.partitionName(0));
-    assertEquals("for any other, it's the concatenation of name + partition", PartitionsUtils.PART_NAME_PREFIX + "1", PartitionsUtils.partitionName(1));
-    assertEquals("default partition number is always 0", 0, PartitionsUtils.partitionNumber(ifip,100));
-    assertEquals("default partition size is unbounded", Integer.MAX_VALUE, ifip.getPartitionSize());
-  }
-
-  @Test
-  public void testCategoryListParamsAddition() {
-    CategoryListParams clp = new CategoryListParams("clp");
-    PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams(
-        Collections.<FacetLabel,CategoryListParams> singletonMap(new FacetLabel("a"), clp));
-    assertEquals("Expected category list field is " + clp.field, 
-        clp.field, tlfip.getCategoryListParams(new FacetLabel("a")).field);
-    assertNotSame("Unexpected default category list " + clp.field, clp, tlfip.getCategoryListParams(null));
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java
deleted file mode 100644
index 7b3a06d..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package org.apache.lucene.facet.search;
-
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.search.CountFacetRequest;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class FacetRequestTest extends FacetTestCase {
-  
-  @Test(expected=IllegalArgumentException.class)
-  public void testIllegalNumResults() throws Exception {
-    assertNotNull(new CountFacetRequest(new FacetLabel("a", "b"), 0));
-  }
-  
-  @Test(expected=IllegalArgumentException.class)
-  public void testIllegalCategoryPath() throws Exception {
-    assertNotNull(new CountFacetRequest(null, 1));
-  }
-  
-  @Test
-  public void testHashAndEquals() {
-    CountFacetRequest fr1 = new CountFacetRequest(new FacetLabel("a"), 8);
-    CountFacetRequest fr2 = new CountFacetRequest(new FacetLabel("a"), 8);
-    assertEquals("hashCode() should agree on both objects", fr1.hashCode(), fr2.hashCode());
-    assertTrue("equals() should return true", fr1.equals(fr2));
-    fr1.setDepth(10);
-    assertFalse("equals() should return false as fr1.depth != fr2.depth", fr1.equals(fr2));
-  }
-  
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetArrays.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetArrays.java
deleted file mode 100644
index 8aab807..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetArrays.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.apache.lucene.facet.search;
-
-import org.apache.lucene.facet.FacetTestCase;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class TestFacetArrays extends FacetTestCase {
-
-  @Test
-  public void testFacetArrays() {
-    for (boolean reusing : new boolean[] { false, true }) {
-      final FacetArrays arrays;
-      if (reusing) {
-        arrays = new ReusingFacetArrays(new ArraysPool(1, 1));
-      } else {
-        arrays = new FacetArrays(1);
-      }
-      
-      int[] intArray = arrays.getIntArray();
-      // Set the element, then free
-      intArray[0] = 1;
-      arrays.free();
-      
-      // We should expect a cleared array back
-      int[] newIntArray = arrays.getIntArray();
-      assertEquals("Expected a cleared array back, but the array is still filled", 0, newIntArray[0]);
-      
-      float[] floatArray = arrays.getFloatArray();
-      // Set the element, then free
-      floatArray[0] = 1.0f;
-      arrays.free();
-      
-      // We should expect a cleared array back
-      float[] newFloatArray = arrays.getFloatArray();
-      assertEquals("Expected a cleared array back, but the array is still filled", 0.0f, newFloatArray[0], 0.0);
-      
-      if (reusing) {
-        // same instance should be returned after free()
-        assertSame("ReusingFacetArrays did not reuse the array!", intArray, newIntArray);
-        assertSame("ReusingFacetArrays did not reuse the array!", floatArray, newFloatArray);
-      }
-    }
-  }
-  
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
deleted file mode 100644
index 90315a4..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
+++ /dev/null
@@ -1,354 +0,0 @@
-package org.apache.lucene.facet.search;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.index.FacetFields;
-import org.apache.lucene.facet.params.CategoryListParams;
-import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.params.PerDimensionIndexingParams;
-import org.apache.lucene.facet.search.FacetRequest.ResultMode;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
-import org.apache.lucene.index.AtomicReader;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.MultiCollector;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TopScoreDocCollector;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.IOUtils;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class TestMultipleCategoryLists extends FacetTestCase {
-
-  private static final FacetLabel[] CATEGORIES = new FacetLabel[] {
-    new FacetLabel("Author", "Mark Twain"),
-    new FacetLabel("Author", "Stephen King"),
-    new FacetLabel("Author", "Kurt Vonnegut"),
-    new FacetLabel("Band", "Rock & Pop", "The Beatles"),
-    new FacetLabel("Band", "Punk", "The Ramones"),
-    new FacetLabel("Band", "Rock & Pop", "U2"),
-    new FacetLabel("Band", "Rock & Pop", "REM"),
-    new FacetLabel("Band", "Rock & Pop", "Dave Matthews Band"),
-    new FacetLabel("Composer", "Bach"),
-  };
-  
-  @Test
-  public void testDefault() throws Exception {
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-    
-    // create and open an index writer
-    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
-        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
-    // create and open a taxonomy writer
-    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<FacetLabel, CategoryListParams>emptyMap());
-
-    seedIndex(iw, tw, iParams);
-
-    IndexReader ir = iw.getReader();
-    tw.commit();
-
-    // prepare index reader and taxonomy.
-    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
-
-    // prepare searcher to search against
-    IndexSearcher searcher = newSearcher(ir);
-
-    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);
-
-    // Obtain facets results and hand-test them
-    assertCorrectResults(facetsCollector);
-
-    assertOrdinalsExist("$facets", ir);
-
-    IOUtils.close(tr, ir, iw, tw);
-    IOUtils.close(indexDir, taxoDir);
-  }
-
-  @Test
-  public void testCustom() throws Exception {
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-    
-    // create and open an index writer
-    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
-        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
-    // create and open a taxonomy writer
-    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(
-        Collections.singletonMap(new FacetLabel("Author"), new CategoryListParams("$author")));
-    seedIndex(iw, tw, iParams);
-
-    IndexReader ir = iw.getReader();
-    tw.commit();
-
-    // prepare index reader and taxonomy.
-    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
-
-    // prepare searcher to search against
-    IndexSearcher searcher = newSearcher(ir);
-
-    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);
-
-    // Obtain facets results and hand-test them
-    assertCorrectResults(facetsCollector);
-
-    assertOrdinalsExist("$facets", ir);
-    assertOrdinalsExist("$author", ir);
-
-    IOUtils.close(tr, ir, iw, tw);
-    IOUtils.close(indexDir, taxoDir);
-  }
-
-  @Test
-  public void testTwoCustomsSameField() throws Exception {
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-    
-    // create and open an index writer
-    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
-        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
-    // create and open a taxonomy writer
-    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-
-    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
-    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$music"));
-    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$music"));
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
-    seedIndex(iw, tw, iParams);
-
-    IndexReader ir = iw.getReader();
-    tw.commit();
-
-    // prepare index reader and taxonomy.
-    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
-
-    // prepare searcher to search against
-    IndexSearcher searcher = newSearcher(ir);
-
-    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);
-
-    // Obtain facets results and hand-test them
-    assertCorrectResults(facetsCollector);
-
-    assertOrdinalsExist("$facets", ir);
-    assertOrdinalsExist("$music", ir);
-    assertOrdinalsExist("$music", ir);
-
-    IOUtils.close(tr, ir, iw, tw);
-    IOUtils.close(indexDir, taxoDir);
-  }
-
-  private void assertOrdinalsExist(String field, IndexReader ir) throws IOException {
-    for (AtomicReaderContext context : ir.leaves()) {
-      AtomicReader r = context.reader();
-      if (r.getBinaryDocValues(field) != null) {
-        return; // not all segments must have this DocValues
-      }
-    }
-    fail("no ordinals found for " + field);
-  }
-
-  @Test
-  public void testDifferentFieldsAndText() throws Exception {
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-
-    // create and open an index writer
-    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
-        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
-    // create and open a taxonomy writer
-    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-
-    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
-    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$bands"));
-    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$composers"));
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
-    seedIndex(iw, tw, iParams);
-
-    IndexReader ir = iw.getReader();
-    tw.commit();
-
-    // prepare index reader and taxonomy.
-    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
-
-    // prepare searcher to search against
-    IndexSearcher searcher = newSearcher(ir);
-
-    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);
-
-    // Obtain facets results and hand-test them
-    assertCorrectResults(facetsCollector);
-    assertOrdinalsExist("$facets", ir);
-    assertOrdinalsExist("$bands", ir);
-    assertOrdinalsExist("$composers", ir);
-
-    IOUtils.close(tr, ir, iw, tw);
-    IOUtils.close(indexDir, taxoDir);
-  }
-
-  @Test
-  public void testSomeSameSomeDifferent() throws Exception {
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-    
-    // create and open an index writer
-    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
-        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
-    // create and open a taxonomy writer
-    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
-
-    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
-    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$music"));
-    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$music"));
-    paramsMap.put(new FacetLabel("Author"), new CategoryListParams("$literature"));
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
-
-    seedIndex(iw, tw, iParams);
-
-    IndexReader ir = iw.getReader();
-    tw.commit();
-
-    // prepare index reader and taxonomy.
-    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
-
-    // prepare searcher to search against
-    IndexSearcher searcher = newSearcher(ir);
-
-    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);
-
-    // Obtain facets results and hand-test them
-    assertCorrectResults(facetsCollector);
-    assertOrdinalsExist("$music", ir);
-    assertOrdinalsExist("$literature", ir);
-
-    IOUtils.close(tr, ir, iw, tw);
-    IOUtils.close(indexDir, taxoDir);
-  }
-
-  private void assertCorrectResults(FacetsCollector facetsCollector) throws IOException {
-    List<FacetResult> res = facetsCollector.getFacetResults();
-
-    FacetResult results = res.get(0);
-    FacetResultNode resNode = results.getFacetResultNode();
-    Iterable<? extends FacetResultNode> subResults = resNode.subResults;
-    Iterator<? extends FacetResultNode> subIter = subResults.iterator();
-
-    checkResult(subIter.next(), "Band/Rock & Pop", 4.0);
-    checkResult(subIter.next(), "Band/Punk", 1.0);
-
-    results = res.get(1);
-    resNode = results.getFacetResultNode();
-    subResults = resNode.subResults;
-    subIter = subResults.iterator();
-
-    checkResult(subIter.next(), "Band/Rock & Pop", 4.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/Dave Matthews Band", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/REM", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/U2", 1.0);
-    checkResult(subIter.next(), "Band/Punk/The Ramones", 1.0);
-    checkResult(subIter.next(), "Band/Punk", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/The Beatles", 1.0);
-
-    results = res.get(2);
-    resNode = results.getFacetResultNode();
-    subResults = resNode.subResults;
-    subIter = subResults.iterator();
-
-    checkResult(subIter.next(), "Author/Kurt Vonnegut", 1.0);
-    checkResult(subIter.next(), "Author/Stephen King", 1.0);
-    checkResult(subIter.next(), "Author/Mark Twain", 1.0);
-
-    results = res.get(3);
-    resNode = results.getFacetResultNode();
-    subResults = resNode.subResults;
-    subIter = subResults.iterator();
-
-    checkResult(subIter.next(), "Band/Rock & Pop/Dave Matthews Band", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/REM", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/U2", 1.0);
-    checkResult(subIter.next(), "Band/Rock & Pop/The Beatles", 1.0);
-  }
-
-  private FacetsCollector performSearch(FacetIndexingParams iParams, TaxonomyReader tr, IndexReader ir, 
-      IndexSearcher searcher) throws IOException {
-    // step 1: collect matching documents into a collector
-    Query q = new MatchAllDocsQuery();
-    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
-
-    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
-    facetRequests.add(new CountFacetRequest(new FacetLabel("Band"), 10));
-    CountFacetRequest bandDepth = new CountFacetRequest(new FacetLabel("Band"), 10);
-    bandDepth.setDepth(2);
-    // makes it easier to check the results in the test.
-    bandDepth.setResultMode(ResultMode.GLOBAL_FLAT);
-    facetRequests.add(bandDepth);
-    facetRequests.add(new CountFacetRequest(new FacetLabel("Author"), 10));
-    facetRequests.add(new CountFacetRequest(new FacetLabel("Band", "Rock & Pop"), 10));
-
-    // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);
-
-    // perform documents search and facets accumulation
-    FacetsCollector facetsCollector = FacetsCollector.create(facetSearchParams, ir, tr);
-    searcher.search(q, MultiCollector.wrap(topDocsCollector, facetsCollector));
-    return facetsCollector;
-  }
-
-  private void seedIndex(RandomIndexWriter iw, TaxonomyWriter tw, FacetIndexingParams iParams) throws IOException {
-    FacetFields facetFields = new FacetFields(tw, iParams);
-    for (FacetLabel cp : CATEGORIES) {
-      Document doc = new Document();
-      facetFields.addFields(doc, Collections.singletonList(cp));
-      doc.add(new TextField("content", "alpha", Field.Store.YES));
-      iw.addDocument(doc);
-    }
-  }
-
-  private static void checkResult(FacetResultNode sub, String label, double value) {
-    assertEquals("Label of subresult " + sub.label + " was incorrect", label, sub.label.toString());
-    assertEquals("Value for " + sub.label + " subresult was incorrect", value, sub.value, 0.0);
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java
deleted file mode 100644
index 021314f..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.apache.lucene.facet.search;
-
-import java.util.List;
-
-import org.apache.lucene.facet.FacetTestBase;
-import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.junit.After;
-import org.junit.Before;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class TestSameRequestAccumulation extends FacetTestBase {
-  
-  private FacetIndexingParams fip;
-  
-  @Override
-  @Before
-  public void setUp() throws Exception {
-    super.setUp();
-    fip = getFacetIndexingParams(Integer.MAX_VALUE);
-    initIndex(fip);
-  }
-  
-  // Following LUCENE-4461 - ensure requesting the (exact) same request more
-  // than once does not alter the results
-  public void testTwoSameRequests() throws Exception {
-    final CountFacetRequest facetRequest = new CountFacetRequest(new FacetLabel("root"), 10);
-    FacetSearchParams fsp = new FacetSearchParams(fip, facetRequest);
-    
-    FacetsCollector fc = FacetsCollector.create(fsp, indexReader, taxoReader);
-    searcher.search(new MatchAllDocsQuery(), fc);
-    
-    final String expected = fc.getFacetResults().get(0).toString();
-
-    // now add the same facet request with duplicates (same instance and same one)
-    fsp = new FacetSearchParams(fip, facetRequest, facetRequest, new CountFacetRequest(new FacetLabel("root"), 10));
-
-    // make sure the search params holds 3 requests now
-    assertEquals(3, fsp.facetRequests.size());
-    
-    fc = FacetsCollector.create(fsp, indexReader, taxoReader);
-    searcher.search(new MatchAllDocsQuery(), fc);
-    List<FacetResult> actual = fc.getFacetResults();
-
-    // all 3 results should have the same toString()
-    assertEquals("same FacetRequest but different result?", expected, actual.get(0).toString());
-    assertEquals("same FacetRequest but different result?", expected, actual.get(1).toString());
-    assertEquals("same FacetRequest but different result?", expected, actual.get(2).toString());
-  }
-  
-  @Override
-  @After
-  public void tearDown() throws Exception {
-    closeAll();
-    super.tearDown();
-  }
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java
deleted file mode 100644
index 429ea4e..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.lucene.facet.search;
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.index.FacetFields;
-import org.apache.lucene.facet.params.CategoryListParams;
-import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
-import org.apache.lucene.facet.util.AssertingCategoryListIterator;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.NoMergePolicy;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.IOUtils;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class TestStandardFacetsAccumulator extends FacetTestCase {
-  
-  private void indexTwoDocs(IndexWriter indexWriter, FacetFields facetFields, boolean withContent) throws Exception {
-    for (int i = 0; i < 2; i++) {
-      Document doc = new Document();
-      if (withContent) {
-        doc.add(new StringField("f", "a", Store.NO));
-      }
-      if (facetFields != null) {
-        facetFields.addFields(doc, Collections.singletonList(new FacetLabel("A", Integer.toString(i))));
-      }
-      indexWriter.addDocument(doc);
-    }
-    
-    indexWriter.commit();
-  }
-  
-  @Test
-  public void testSegmentsWithoutCategoriesOrResults() throws Exception {
-    // tests the accumulator when there are segments with no results
-    Directory indexDir = newDirectory();
-    Directory taxoDir = newDirectory();
-    
-    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));
-    iwc.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges
-    IndexWriter indexWriter = new IndexWriter(indexDir, iwc);
-    FacetIndexingParams fip = new FacetIndexingParams(new CategoryListParams() {
-      @Override
-      public CategoryListIterator createCategoryListIterator(int partition) throws IOException {
-        return new AssertingCategoryListIterator(super.createCategoryListIterator(partition));
-      }
-    });
-    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
-    FacetFields facetFields = new FacetFields(taxoWriter, fip);
-    indexTwoDocs(indexWriter, facetFields, false); // 1st segment, no content, with categories
-    indexTwoDocs(indexWriter, null, true);         // 2nd segment, with content, no categories
-    indexTwoDocs(indexWriter, facetFields, true);  // 3rd segment ok
-    indexTwoDocs(indexWriter, null, false);        // 4th segment, no content, or categories
-    indexTwoDocs(indexWriter, null, true);         // 5th segment, with content, no categories
-    indexTwoDocs(indexWriter, facetFields, true);  // 6th segment, with content, with categories
-    indexTwoDocs(indexWriter, null, true);         // 7th segment, with content, no categories
-    IOUtils.close(indexWriter, taxoWriter);
-
-    DirectoryReader indexReader = DirectoryReader.open(indexDir);
-    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
-    IndexSearcher indexSearcher = newSearcher(indexReader);
-    
-    // search for "f:a", only segments 1 and 3 should match results
-    Query q = new TermQuery(new Term("f", "a"));
-    FacetRequest countNoComplements = new CountFacetRequest(new FacetLabel("A"), 10);
-    FacetSearchParams fsp = new FacetSearchParams(fip, countNoComplements);
-    FacetsCollector fc = FacetsCollector.create(fsp , indexReader, taxoReader);
-    indexSearcher.search(q, fc);
-    List<FacetResult> results = fc.getFacetResults();
-    assertEquals("received too many facet results", 1, results.size());
-    FacetResultNode frn = results.get(0).getFacetResultNode();
-    assertEquals("wrong number of children", 2, frn.subResults.size());
-    for (FacetResultNode node : frn.subResults) {
-      assertEquals("wrong weight for child " + node.label, 2, (int) node.value);
-    }
-    IOUtils.close(indexReader, taxoReader);
-    
-    IOUtils.close(indexDir, taxoDir);
-  }
-  
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestMultipleIndexFields.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestMultipleIndexFields.java
new file mode 100644
index 0000000..8d6d16e
--- /dev/null
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestMultipleIndexFields.java
@@ -0,0 +1,313 @@
+package org.apache.lucene.facet.simple;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.facet.FacetTestCase;
+import org.apache.lucene.facet.index.FacetFields;
+import org.apache.lucene.facet.params.CategoryListParams;
+import org.apache.lucene.facet.params.FacetIndexingParams;
+import org.apache.lucene.facet.params.FacetSearchParams;
+import org.apache.lucene.facet.params.PerDimensionIndexingParams;
+import org.apache.lucene.facet.search.FacetRequest.ResultMode;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
+import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.AtomicReader;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.IOUtils;
+import org.junit.Test;
+
+public class TestMultipleIndexFields extends FacetTestCase {
+
+  private static final FacetField[] CATEGORIES = new FacetField[] {
+    new FacetField("Author", "Mark Twain"),
+    new FacetField("Author", "Stephen King"),
+    new FacetField("Author", "Kurt Vonnegut"),
+    new FacetField("Band", "Rock & Pop", "The Beatles"),
+    new FacetField("Band", "Punk", "The Ramones"),
+    new FacetField("Band", "Rock & Pop", "U2"),
+    new FacetField("Band", "Rock & Pop", "REM"),
+    new FacetField("Band", "Rock & Pop", "Dave Matthews Band"),
+    new FacetField("Composer", "Bach"),
+  };
+
+  private FacetsConfig getConfig(TaxonomyWriter taxoWriter) {
+    FacetsConfig config = new FacetsConfig(taxoWriter);
+    //config.setMultiValued("Author", true);
+    //config.setMultiValued("Band", true);
+    config.setHierarchical("Band", true);
+    return config;
+  }
+  
+  @Test
+  public void testDefault() throws Exception {
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+    
+    // create and open an index writer
+    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
+        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
+    // create and open a taxonomy writer
+    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+    FacetsConfig config = getConfig(tw);
+
+    seedIndex(iw, config);
+
+    IndexReader ir = iw.getReader();
+    tw.commit();
+
+    // prepare index reader and taxonomy.
+    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
+
+    // prepare searcher to search against
+    IndexSearcher searcher = newSearcher(ir);
+
+    SimpleFacetsCollector sfc = performSearch(tr, ir, searcher);
+
+    // Obtain facets results and hand-test them
+    assertCorrectResults(getTaxonomyFacetCounts(tr, config, sfc));
+
+    assertOrdinalsExist("$facets", ir);
+
+    IOUtils.close(tr, ir, iw, tw, indexDir, taxoDir);
+  }
+
+  @Test
+  public void testCustom() throws Exception {
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+    
+    // create and open an index writer
+    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
+        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
+    // create and open a taxonomy writer
+    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+
+    FacetsConfig config = getConfig(tw);
+    config.setIndexFieldName("Author", "$author");
+    seedIndex(iw, config);
+
+    IndexReader ir = iw.getReader();
+    tw.commit();
+
+    // prepare index reader and taxonomy.
+    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
+
+    // prepare searcher to search against
+    IndexSearcher searcher = newSearcher(ir);
+
+    SimpleFacetsCollector sfc = performSearch(tr, ir, searcher);
+
+    Map<String,Facets> facetsMap = new HashMap<String,Facets>();
+    facetsMap.put("Author", getTaxonomyFacetCounts(tr, config, sfc, "$author"));
+    Facets facets = new MultiFacets(facetsMap, getTaxonomyFacetCounts(tr, config, sfc));
+
+    // Obtain facets results and hand-test them
+    assertCorrectResults(facets);
+
+    assertOrdinalsExist("$facets", ir);
+    assertOrdinalsExist("$author", ir);
+
+    IOUtils.close(tr, ir, iw, tw, indexDir, taxoDir);
+  }
+
+  @Test
+  public void testTwoCustomsSameField() throws Exception {
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+    
+    // create and open an index writer
+    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
+        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
+    // create and open a taxonomy writer
+    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+
+    FacetsConfig config = getConfig(tw);
+    config.setIndexFieldName("Band", "$music");
+    config.setIndexFieldName("Composer", "$music");
+    seedIndex(iw, config);
+
+    IndexReader ir = iw.getReader();
+    tw.commit();
+
+    // prepare index reader and taxonomy.
+    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
+
+    // prepare searcher to search against
+    IndexSearcher searcher = newSearcher(ir);
+
+    SimpleFacetsCollector sfc = performSearch(tr, ir, searcher);
+
+    Map<String,Facets> facetsMap = new HashMap<String,Facets>();
+    Facets facets2 = getTaxonomyFacetCounts(tr, config, sfc, "$music");
+    facetsMap.put("Band", facets2);
+    facetsMap.put("Composer", facets2);
+    Facets facets = new MultiFacets(facetsMap, getTaxonomyFacetCounts(tr, config, sfc));
+
+    // Obtain facets results and hand-test them
+    assertCorrectResults(facets);
+
+    assertOrdinalsExist("$facets", ir);
+    assertOrdinalsExist("$music", ir);
+    assertOrdinalsExist("$music", ir);
+
+    IOUtils.close(tr, ir, iw, tw, indexDir, taxoDir);
+  }
+
+  private void assertOrdinalsExist(String field, IndexReader ir) throws IOException {
+    for (AtomicReaderContext context : ir.leaves()) {
+      AtomicReader r = context.reader();
+      if (r.getBinaryDocValues(field) != null) {
+        return; // not all segments must have this DocValues
+      }
+    }
+    fail("no ordinals found for " + field);
+  }
+
+  @Test
+  public void testDifferentFieldsAndText() throws Exception {
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+
+    // create and open an index writer
+    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
+        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
+    // create and open a taxonomy writer
+    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+
+    FacetsConfig config = getConfig(tw);
+    config.setIndexFieldName("Band", "$bands");
+    config.setIndexFieldName("Composer", "$composers");
+    seedIndex(iw, config);
+
+    IndexReader ir = iw.getReader();
+    tw.commit();
+
+    // prepare index reader and taxonomy.
+    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
+
+    // prepare searcher to search against
+    IndexSearcher searcher = newSearcher(ir);
+
+    SimpleFacetsCollector sfc = performSearch(tr, ir, searcher);
+
+    Map<String,Facets> facetsMap = new HashMap<String,Facets>();
+    facetsMap.put("Band", getTaxonomyFacetCounts(tr, config, sfc, "$bands"));
+    facetsMap.put("Composer", getTaxonomyFacetCounts(tr, config, sfc, "$composers"));
+    Facets facets = new MultiFacets(facetsMap, getTaxonomyFacetCounts(tr, config, sfc));
+
+    // Obtain facets results and hand-test them
+    assertCorrectResults(facets);
+    assertOrdinalsExist("$facets", ir);
+    assertOrdinalsExist("$bands", ir);
+    assertOrdinalsExist("$composers", ir);
+
+    IOUtils.close(tr, ir, iw, tw, indexDir, taxoDir);
+  }
+
+  @Test
+  public void testSomeSameSomeDifferent() throws Exception {
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+    
+    // create and open an index writer
+    RandomIndexWriter iw = new RandomIndexWriter(random(), indexDir, newIndexWriterConfig(
+        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
+    // create and open a taxonomy writer
+    TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
+
+    FacetsConfig config = getConfig(tw);
+    config.setIndexFieldName("Band", "$music");
+    config.setIndexFieldName("Composer", "$music");
+    config.setIndexFieldName("Author", "$literature");
+    seedIndex(iw, config);
+
+    IndexReader ir = iw.getReader();
+    tw.commit();
+
+    // prepare index reader and taxonomy.
+    TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
+
+    // prepare searcher to search against
+    IndexSearcher searcher = newSearcher(ir);
+
+    SimpleFacetsCollector sfc = performSearch(tr, ir, searcher);
+
+    Map<String,Facets> facetsMap = new HashMap<String,Facets>();
+    Facets facets2 = getTaxonomyFacetCounts(tr, config, sfc, "$music");
+    facetsMap.put("Band", facets2);
+    facetsMap.put("Composer", facets2);
+    facetsMap.put("Author", getTaxonomyFacetCounts(tr, config, sfc, "$literature"));
+    Facets facets = new MultiFacets(facetsMap, getTaxonomyFacetCounts(tr, config, sfc));
+
+    // Obtain facets results and hand-test them
+    assertCorrectResults(facets);
+    assertOrdinalsExist("$music", ir);
+    assertOrdinalsExist("$literature", ir);
+
+    IOUtils.close(tr, ir, iw, tw);
+    IOUtils.close(indexDir, taxoDir);
+  }
+
+  private void assertCorrectResults(Facets facets) throws IOException {
+    assertEquals(5, facets.getSpecificValue("Band"));
+    assertEquals("value=5 childCount=2\n  Rock & Pop (4)\n  Punk (1)\n", facets.getTopChildren(10, "Band").toString());
+    assertEquals("value=4 childCount=4\n  The Beatles (1)\n  U2 (1)\n  REM (1)\n  Dave Matthews Band (1)\n", facets.getTopChildren(10, "Band", "Rock & Pop").toString());
+    assertEquals("value=3 childCount=3\n  Mark Twain (1)\n  Stephen King (1)\n  Kurt Vonnegut (1)\n", facets.getTopChildren(10, "Author").toString());
+  }
+
+  private SimpleFacetsCollector performSearch(TaxonomyReader tr, IndexReader ir, 
+      IndexSearcher searcher) throws IOException {
+    SimpleFacetsCollector sfc = new SimpleFacetsCollector();
+    Facets.search(searcher, new MatchAllDocsQuery(), 10, sfc);
+    return sfc;
+  }
+
+  private void seedIndex(RandomIndexWriter iw, FacetsConfig config) throws IOException {
+    for (FacetField ff : CATEGORIES) {
+      Document doc = new Document();
+      doc.add(ff);
+      doc.add(new TextField("content", "alpha", Field.Store.YES));
+      iw.addDocument(config.build(doc));
+    }
+  }
+}
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
index 37b38f0..6a1cc4f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
@@ -96,7 +96,7 @@ public class TestRangeFacets extends FacetTestCase {
         new LongRange("over 1000", 1000L, false, Long.MAX_VALUE, true));
     
     SimpleFacetResult result = facets.getTopChildren(10, "field");
-    assertEquals("field (101)\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (1)\n",
+    assertEquals("value=101 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (1)\n",
                  result.toString());
     
     r.close();
@@ -177,8 +177,8 @@ public class TestRangeFacets extends FacetTestCase {
     SimpleDrillSidewaysResult dsr = ds.search(null, ddq, 10);
 
     assertEquals(100, dsr.hits.totalHits);
-    assertEquals("dim (100)\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("field (100)\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
 
     // Second search, drill down on dim=b:
@@ -187,8 +187,8 @@ public class TestRangeFacets extends FacetTestCase {
     dsr = ds.search(null, ddq, 10);
 
     assertEquals(75, dsr.hits.totalHits);
-    assertEquals("dim (100)\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("field (75)\n  less than 10 (7)\n  less than or equal to 10 (8)\n  over 90 (7)\n  90 or above (8)\n  over 1000 (0)\n",
+    assertEquals("value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("value=75 childCount=5\n  less than 10 (7)\n  less than or equal to 10 (8)\n  over 90 (7)\n  90 or above (8)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
 
     // Third search, drill down on "less than or equal to 10":
@@ -197,8 +197,8 @@ public class TestRangeFacets extends FacetTestCase {
     dsr = ds.search(null, ddq, 10);
 
     assertEquals(11, dsr.hits.totalHits);
-    assertEquals("dim (11)\n  b (8)\n  a (3)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("field (100)\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("value=11 childCount=2\n  b (8)\n  a (3)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
     IOUtils.close(tw, tr, td, w, r, d);
   }
@@ -227,7 +227,7 @@ public class TestRangeFacets extends FacetTestCase {
         new DoubleRange("90 or above", 90.0, true, 100.0, false),
         new DoubleRange("over 1000", 1000.0, false, Double.POSITIVE_INFINITY, false));
                                          
-    assertEquals("field (100)\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
 
     IOUtils.close(w, r, d);
@@ -258,7 +258,7 @@ public class TestRangeFacets extends FacetTestCase {
         new FloatRange("90 or above", 90.0f, true, 100.0f, false),
         new FloatRange("over 1000", 1000.0f, false, Float.POSITIVE_INFINITY, false));
     
-    assertEquals("field (100)\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
     
     IOUtils.close(w, r, d);
@@ -547,7 +547,7 @@ public class TestRangeFacets extends FacetTestCase {
         new LongRange("90 or above", 90L, true, 100L, false),
         new LongRange("over 1000", 1000L, false, Long.MAX_VALUE, false));
     
-    assertEquals("field (100)\n  less than 10 (8)\n  less than or equal to 10 (8)\n  over 90 (8)\n  90 or above (8)\n  over 1000 (0)\n",
+    assertEquals("value=100 childCount=5\n  less than 10 (8)\n  less than or equal to 10 (8)\n  over 90 (8)\n  90 or above (8)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
 
     IOUtils.close(w, r, d);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways.java
index a400c30..133a6a3 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSimpleDrillSideways.java
@@ -123,12 +123,12 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("Publish Date (2)\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("Author (5)\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Same simple case, but no baseQuery (pure browse):
     // drill-down on a single field; in this case the
@@ -141,12 +141,12 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("Publish Date (2)\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("Author (5)\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Another simple case: drill-down on on single fields
     // but OR of two values
@@ -157,11 +157,11 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(3, r.hits.totalHits);
     // Publish Date is only drill-down: Lisa and Bob
     // (drill-down) published twice in 2010 and once in 2012:
-    assertEquals("Publish Date (3)\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("Author (5)\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // More interesting case: drill-down on two fields
     ddq = new SimpleDrillDownQuery(config);
@@ -171,10 +171,10 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(1, r.hits.totalHits);
     // Publish Date is drill-sideways + drill-down: Lisa
     // (drill-down) published once in 2010 and once in 2012:
-    assertEquals("Publish Date (2)\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down:
     // only Lisa & Bob published (once each) in 2010:
-    assertEquals("Author (2)\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Even more interesting case: drill down on two fields,
     // but one of them is OR
@@ -188,10 +188,10 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is both drill-sideways + drill-down:
     // Lisa or Bob published twice in 2010 and once in 2012:
-    assertEquals("Publish Date (3)\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down:
     // only Lisa & Bob published (once each) in 2010:
-    assertEquals("Author (2)\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Test drilling down on invalid field:
     ddq = new SimpleDrillDownQuery(config);
@@ -209,11 +209,11 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("Publish Date (2)\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("Author (5)\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // LUCENE-4915: test drilling down on a dimension but
     // NOT facet counting it:
@@ -224,7 +224,7 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("Publish Date (2)\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Test main query gets null scorer:
     ddq = new SimpleDrillDownQuery(config, new TermQuery(new Term("foobar", "baz")));
@@ -282,11 +282,11 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     assertEquals(1, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("Publish Date (1)\n  2010 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=1 childCount=1\n  2010 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published once, and Bob
     // published once:
-    assertEquals("Author (2)\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, writer, taxoWriter, dir, taxoDir);
   }
@@ -340,8 +340,8 @@ public class TestSimpleDrillSideways extends FacetTestCase {
     SimpleDrillSidewaysResult r = new SimpleDrillSideways(searcher, config, taxoReader).search(null, ddq, 10);
 
     assertEquals(3, r.hits.totalHits);
-    assertEquals("dim (6)\n  a (3)\n  b (1)\n  c (1)\n  d (1)\n", r.facets.getTopChildren(10, "dim").toString());
-    assertEquals("dim/a (3)\n  x (1)\n  y (1)\n  z (1)\n", r.facets.getTopChildren(10, "dim", "a").toString());
+    assertEquals("value=6 childCount=4\n  a (3)\n  b (1)\n  c (1)\n  d (1)\n", r.facets.getTopChildren(10, "dim").toString());
+    assertEquals("value=3 childCount=3\n  x (1)\n  y (1)\n  z (1)\n", r.facets.getTopChildren(10, "dim", "a").toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, writer, taxoWriter, dir, taxoDir);
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
index 11645c7..2b8bb76 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
@@ -69,8 +69,8 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
 
     SortedSetDocValuesFacetCounts facets = new SortedSetDocValuesFacetCounts(state, c);
 
-    assertEquals("a (4)\n  foo (2)\n  bar (1)\n  zoo (1)\n", facets.getTopChildren(10, "a").toString());
-    assertEquals("b (1)\n  baz (1)\n", facets.getTopChildren(10, "b").toString());
+    assertEquals("value=4 childCount=3\n  foo (2)\n  bar (1)\n  zoo (1)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("value=1 childCount=1\n  baz (1)\n", facets.getTopChildren(10, "b").toString());
 
     // DrillDown:
     SimpleDrillDownQuery q = new SimpleDrillDownQuery(config);
@@ -172,9 +172,9 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     List<SimpleFacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("a (3)\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
-    assertEquals("b (2)\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
-    assertEquals("c (1)\n  baz1 (1)\n", results.get(2).toString());
+    assertEquals("value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
+    assertEquals("value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
+    assertEquals("value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
 
     searcher.getIndexReader().close();
     dir.close();
@@ -215,7 +215,7 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     Facets facets = new SortedSetDocValuesFacetCounts(state, c);
 
     // Ask for top 10 labels for any dims that have counts:
-    assertEquals("a (2)\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("value=2 childCount=2\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
 
     IOUtils.close(writer, searcher.getIndexReader(), dir);
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetCounts.java
index 39fb0b7..9288a41 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetCounts.java
@@ -36,9 +36,13 @@ import org.apache.lucene.facet.util.PrintTaxonomyStats;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.NoMergePolicy;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
@@ -104,8 +108,8 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, c);
 
     // Retrieve & verify results:
-    assertEquals("Publish Date (5)\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", facets.getTopChildren(10, "Publish Date").toString());
-    assertEquals("Author (5)\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", facets.getTopChildren(10, "Author").toString());
 
     // Now user drills down on Publish Date/2010:
     SimpleDrillDownQuery q2 = new SimpleDrillDownQuery(config);
@@ -113,7 +117,7 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     c = new SimpleFacetsCollector();
     searcher.search(q2, c);
     facets = new FastTaxonomyFacetCounts(taxoReader, config, c);
-    assertEquals("Author (2)\n  Bob (1)\n  Lisa (1)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", facets.getTopChildren(10, "Author").toString());
 
     assertEquals(1, facets.getSpecificValue("Author", "Lisa"));
 
@@ -181,9 +185,9 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     List<SimpleFacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("a (3)\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
-    assertEquals("b (2)\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
-    assertEquals("c (1)\n  baz1 (1)\n", results.get(2).toString());
+    assertEquals("value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
+    assertEquals("value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
+    assertEquals("value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
 
     IOUtils.close(writer, taxoWriter, searcher.getIndexReader(), taxoReader, taxoDir, dir);
   }
@@ -340,7 +344,7 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     assertEquals(1, facets.getSpecificValue("dim", "test\u001Etwo"));
 
     SimpleFacetResult result = facets.getTopChildren(10, "dim");
-    assertEquals("dim (-1)\n  test\u001Fone (1)\n  test\u001Etwo (1)\n", result.toString());
+    assertEquals("value=-1 childCount=2\n  test\u001Fone (1)\n  test\u001Etwo (1)\n", result.toString());
     IOUtils.close(writer, taxoWriter, searcher.getIndexReader(), taxoReader, dir, taxoDir);
   }
 
@@ -586,4 +590,59 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
 
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
+
+  private void indexTwoDocs(IndexWriter indexWriter, FacetsConfig config, boolean withContent) throws Exception {
+    for (int i = 0; i < 2; i++) {
+      Document doc = new Document();
+      if (withContent) {
+        doc.add(new StringField("f", "a", Field.Store.NO));
+      }
+      if (config != null) {
+        doc.add(new FacetField("A", Integer.toString(i)));
+        indexWriter.addDocument(config.build(doc));
+      } else {
+        indexWriter.addDocument(doc);
+      }
+    }
+    
+    indexWriter.commit();
+  }
+  
+  public void testSegmentsWithoutCategoriesOrResults() throws Exception {
+    // tests the accumulator when there are segments with no results
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+    
+    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));
+    iwc.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges
+    IndexWriter indexWriter = new IndexWriter(indexDir, iwc);
+
+    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
+    FacetsConfig config = new FacetsConfig(taxoWriter);
+    indexTwoDocs(indexWriter, config, false); // 1st segment, no content, with categories
+    indexTwoDocs(indexWriter, null, true);         // 2nd segment, with content, no categories
+    indexTwoDocs(indexWriter, config, true);  // 3rd segment ok
+    indexTwoDocs(indexWriter, null, false);        // 4th segment, no content, or categories
+    indexTwoDocs(indexWriter, null, true);         // 5th segment, with content, no categories
+    indexTwoDocs(indexWriter, config, true);  // 6th segment, with content, with categories
+    indexTwoDocs(indexWriter, null, true);         // 7th segment, with content, no categories
+    IOUtils.close(indexWriter, taxoWriter);
+
+    DirectoryReader indexReader = DirectoryReader.open(indexDir);
+    TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
+    IndexSearcher indexSearcher = newSearcher(indexReader);
+    
+    // search for "f:a", only segments 1 and 3 should match results
+    Query q = new TermQuery(new Term("f", "a"));
+    SimpleFacetsCollector sfc = new SimpleFacetsCollector();
+    indexSearcher.search(q, sfc);
+    Facets facets = getTaxonomyFacetCounts(taxoReader, config, sfc);
+    SimpleFacetResult result = facets.getTopChildren(10, "A");
+    assertEquals("wrong number of children", 2, result.labelValues.length);
+    for (LabelAndValue labelValue : result.labelValues) {
+      assertEquals("wrong weight for child " + labelValue.label, 2, labelValue.value.intValue());
+    }
+
+    IOUtils.close(indexReader, taxoReader, indexDir, taxoDir);
+  }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetSumValueSource.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetSumValueSource.java
index 73e6590..446a4d5 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetSumValueSource.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetSumValueSource.java
@@ -129,7 +129,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     TaxonomyFacetSumValueSource facets = new TaxonomyFacetSumValueSource(taxoReader, new FacetsConfig(), c, new IntFieldSource("num"));
 
     // Retrieve & verify results:
-    assertEquals("Author (145.0)\n  Lisa (50.0)\n  Frank (45.0)\n  Susan (40.0)\n  Bob (10.0)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("value=145.0 childCount=4\n  Lisa (50.0)\n  Frank (45.0)\n  Susan (40.0)\n  Bob (10.0)\n", facets.getTopChildren(10, "Author").toString());
 
     taxoReader.close();
     searcher.getIndexReader().close();
@@ -192,9 +192,9 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     List<SimpleFacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("a (60.0)\n  foo3 (30.0)\n  foo2 (20.0)\n  foo1 (10.0)\n", results.get(0).toString());
-    assertEquals("b (50.0)\n  bar2 (30.0)\n  bar1 (20.0)\n", results.get(1).toString());
-    assertEquals("c (30.0)\n  baz1 (30.0)\n", results.get(2).toString());
+    assertEquals("value=60.0 childCount=3\n  foo3 (30.0)\n  foo2 (20.0)\n  foo1 (10.0)\n", results.get(0).toString());
+    assertEquals("value=50.0 childCount=2\n  bar2 (30.0)\n  bar1 (20.0)\n", results.get(1).toString());
+    assertEquals("value=30.0 childCount=1\n  baz1 (30.0)\n", results.get(2).toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, dir, taxoDir);
   }
@@ -309,7 +309,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     SimpleFacetsCollector sfc = new SimpleFacetsCollector();
     newSearcher(r).search(new MatchAllDocsQuery(), sfc);
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, sfc, new LongFieldSource("price"));
-    assertEquals("a (10.0)\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
@@ -361,7 +361,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     newSearcher(r).search(q, MultiCollector.wrap(tsdc, sfc));
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, sfc, valueSource);
     
-    assertEquals("a (10.0)\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
@@ -391,7 +391,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     newSearcher(r).search(new MatchAllDocsQuery(), sfc);
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, sfc, valueSource);
     
-    assertEquals("a (10.0)\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }

