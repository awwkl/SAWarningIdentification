GitDiffStart: 237478f09b7df946712cac29b03034b4a73f7032 | Thu Sep 18 05:43:04 2014 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index caf88e6..37e9c1e 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -128,6 +128,10 @@ Upgrading from Solr 4.10
   createAlias() and deleteAlias() have been deprecated. The new usage involves a
   builder style construction of the call.
 
+* The OVERSEERSTATUS API returns new key names for operations such as "create"
+  for "createcollection", "delete" for "removecollection" and "deleteshard" for
+  "removeshard".
+
 Detailed Change List
 ----------------------
 
@@ -241,6 +245,9 @@ Other Changes
   http://www.unidata.ucar.edu/software/thredds/current/netcdf-java/
   (Uwe Schindler)
 
+* SOLR-6115: Cleanup enum/string action types in Overseer, OverseerCollectionProcessor and
+  CollectionHandler. (Erick Erickson, shalin)
+
 
 ==================  4.10.0 =================
 
diff --git a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
index f5c242c..18c30cc 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
@@ -152,7 +152,7 @@ class ShardLeaderElectionContextBase extends ElectionContext {
     
     assert shardId != null;
     ZkNodeProps m = ZkNodeProps.fromKeyVals(Overseer.QUEUE_OPERATION,
-        ZkStateReader.LEADER_PROP, ZkStateReader.SHARD_ID_PROP, shardId,
+        Overseer.OverseerAction.LEADER.toLower(), ZkStateReader.SHARD_ID_PROP, shardId,
         ZkStateReader.COLLECTION_PROP, collection, ZkStateReader.BASE_URL_PROP,
         leaderProps.getProperties().get(ZkStateReader.BASE_URL_PROP),
         ZkStateReader.CORE_NAME_PROP,
@@ -205,7 +205,7 @@ final class ShardLeaderElectionContext extends ShardLeaderElectionContextBase {
     String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);
     
     // clear the leader in clusterstate
-    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, ZkStateReader.LEADER_PROP,
+    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.LEADER.toLower(),
         ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,
         collection);
     Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));
diff --git a/solr/core/src/java/org/apache/solr/cloud/Overseer.java b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
index 041b11f..b6257d8 100644
--- a/solr/core/src/java/org/apache/solr/cloud/Overseer.java
+++ b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
@@ -19,8 +19,6 @@ package org.apache.solr.cloud;
 
 import static java.util.Collections.singletonMap;
 import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
-import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDREPLICA;
-import static org.apache.solr.common.params.CollectionParams.CollectionAction.CLUSTERPROP;
 
 import java.io.Closeable;
 import java.io.IOException;
@@ -51,6 +49,7 @@ import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.core.ConfigSolr;
 import org.apache.solr.handler.component.ShardHandler;
 import org.apache.solr.update.UpdateShardHandler;
@@ -68,17 +67,55 @@ import org.slf4j.LoggerFactory;
  */
 public class Overseer implements Closeable {
   public static final String QUEUE_OPERATION = "operation";
-  public static final String DELETECORE = "deletecore";
+
+  /**
+   * @deprecated use {@link org.apache.solr.common.params.CollectionParams.CollectionAction#DELETE}
+   */
+  @Deprecated
   public static final String REMOVECOLLECTION = "removecollection";
+
+  /**
+   * @deprecated use {@link org.apache.solr.common.params.CollectionParams.CollectionAction#DELETESHARD}
+   */
+  @Deprecated
   public static final String REMOVESHARD = "removeshard";
-  public static final String ADD_ROUTING_RULE = "addroutingrule";
-  public static final String REMOVE_ROUTING_RULE = "removeroutingrule";
-  public static final String STATE = "state";
-  public static final String QUIT = "quit";
+
+  /**
+   * Enum of actions supported by the overseer only.
+   *
+   * There are other actions supported which are public and defined
+   * in {@link org.apache.solr.common.params.CollectionParams.CollectionAction}
+   */
+  public static enum OverseerAction {
+    LEADER,
+    DELETECORE,
+    ADDROUTINGRULE,
+    REMOVEROUTINGRULE,
+    UPDATESHARDSTATE,
+    STATE,
+    QUIT;
+
+    public static OverseerAction get(String p) {
+      if (p != null) {
+        try {
+          return OverseerAction.valueOf(p.toUpperCase(Locale.ROOT));
+        } catch (Exception ex) {
+        }
+      }
+      return null;
+    }
+
+    public boolean isEqual(String s) {
+      return s != null && toString().equals(s.toUpperCase(Locale.ROOT));
+    }
+
+    public String toLower() {
+      return toString().toLowerCase(Locale.ROOT);
+    }
+  }
+
 
   public static final int STATE_UPDATE_DELAY = 1500;  // delay between cloud state updates
-  public static final String CREATESHARD = "createshard";
-  public static final String UPDATESHARDSTATE = "updateshardstate";
 
   private static Logger log = LoggerFactory.getLogger(Overseer.class);
 
@@ -378,60 +415,109 @@ public class Overseer implements Closeable {
 
     private ClusterState processMessage(ClusterState clusterState,
         final ZkNodeProps message, final String operation) {
-      if (STATE.equals(operation)) {
-        if( isLegacy( clusterProps )) {
-          clusterState = updateState(clusterState, message);
-        } else {
-          clusterState = updateStateNew(clusterState, message);
+
+      CollectionParams.CollectionAction collectionAction = CollectionParams.CollectionAction.get(operation);
+      if (collectionAction != null) {
+        switch (collectionAction) {
+          case CREATE:
+            clusterState = buildCollection(clusterState, message);
+            break;
+          case DELETE:
+            clusterState = removeCollection(clusterState, message);
+            break;
+          case CREATESHARD:
+            clusterState = createShard(clusterState, message);
+            break;
+          case DELETESHARD:
+            clusterState = removeShard(clusterState, message);
+            break;
+          case ADDREPLICA:
+            clusterState = createReplica(clusterState, message);
+            break;
+          case CLUSTERPROP:
+            handleProp(message);
+            break;
+          default:
+            throw new RuntimeException("unknown operation:" + operation
+                + " contents:" + message.getProperties());
         }
-      } else if (DELETECORE.equals(operation)) {
-        clusterState = removeCore(clusterState, message);
-      } else if (REMOVECOLLECTION.equals(operation)) {
-        clusterState = removeCollection(clusterState, message);
-      } else if (REMOVESHARD.equals(operation)) {
-        clusterState = removeShard(clusterState, message);
-      } else if (ZkStateReader.LEADER_PROP.equals(operation)) {
-
-        StringBuilder sb = new StringBuilder();
-        String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);
-        String coreName = message.getStr(ZkStateReader.CORE_NAME_PROP);
-        sb.append(baseUrl);
-        if (baseUrl != null && !baseUrl.endsWith("/")) sb.append("/");
-        sb.append(coreName == null ? "" : coreName);
-        if (!(sb.substring(sb.length() - 1).equals("/"))) sb.append("/");
-        clusterState = setShardLeader(clusterState,
-            message.getStr(ZkStateReader.COLLECTION_PROP),
-            message.getStr(ZkStateReader.SHARD_ID_PROP),
-            sb.length() > 0 ? sb.toString() : null);
-
-      } else if (CREATESHARD.equals(operation)) {
-        clusterState = createShard(clusterState, message);
-      } else if (UPDATESHARDSTATE.equals(operation))  {
-        clusterState = updateShardState(clusterState, message);
-      } else if (OverseerCollectionProcessor.CREATECOLLECTION.equals(operation)) {
-         clusterState = buildCollection(clusterState, message);
-      } else if(ADDREPLICA.isEqual(operation)){
-        clusterState = createReplica(clusterState, message);
-      } else if (Overseer.ADD_ROUTING_RULE.equals(operation)) {
-        clusterState = addRoutingRule(clusterState, message);
-      } else if (Overseer.REMOVE_ROUTING_RULE.equals(operation))  {
-        clusterState = removeRoutingRule(clusterState, message);
-      } else if(CLUSTERPROP.isEqual(operation)){
-           handleProp(message);
-      } else if( QUIT.equals(operation)){
-        if(myId.equals( message.get("id"))){
-          log.info("Quit command received {}", LeaderElector.getNodeName(myId));
-          overseerCollectionProcessor.close();
-          close();
-        } else {
-          log.warn("Overseer received wrong QUIT message {}", message);
+      } else {
+        OverseerAction overseerAction = OverseerAction.get(operation);
+        if (overseerAction != null) {
+          switch (overseerAction) {
+            case STATE:
+              if (isLegacy(clusterProps)) {
+                clusterState = updateState(clusterState, message);
+              } else {
+                clusterState = updateStateNew(clusterState, message);
+              }
+              break;
+            case LEADER:
+              clusterState = setShardLeader(clusterState, message);
+              break;
+            case DELETECORE:
+              clusterState = removeCore(clusterState, message);
+              break;
+            case ADDROUTINGRULE:
+              clusterState = addRoutingRule(clusterState, message);
+              break;
+            case REMOVEROUTINGRULE:
+              clusterState = removeRoutingRule(clusterState, message);
+              break;
+            case UPDATESHARDSTATE:
+              clusterState = updateShardState(clusterState, message);
+              break;
+            case QUIT:
+              if (myId.equals(message.get("id"))) {
+                log.info("Quit command received {}", LeaderElector.getNodeName(myId));
+                overseerCollectionProcessor.close();
+                close();
+              } else {
+                log.warn("Overseer received wrong QUIT message {}", message);
+              }
+              break;
+            default:
+              throw new RuntimeException("unknown operation:" + operation
+                  + " contents:" + message.getProperties());
+          }
+        } else  {
+          // merely for back-compat where overseer action names were different from the ones
+          // specified in CollectionAction. See SOLR-6115. Remove this in 5.0
+          switch (operation) {
+            case OverseerCollectionProcessor.CREATECOLLECTION:
+              clusterState = buildCollection(clusterState, message);
+              break;
+            case REMOVECOLLECTION:
+              clusterState = removeCollection(clusterState, message);
+              break;
+            case REMOVESHARD:
+              clusterState = removeShard(clusterState, message);
+              break;
+            default:
+              throw new RuntimeException("unknown operation:" + operation
+                  + " contents:" + message.getProperties());
+          }
         }
-      } else{
-        throw new RuntimeException("unknown operation:" + operation
-            + " contents:" + message.getProperties());
       }
+
+      return clusterState;
+    }
+
+    private ClusterState setShardLeader(ClusterState clusterState, ZkNodeProps message) {
+      StringBuilder sb = new StringBuilder();
+      String baseUrl = message.getStr(ZkStateReader.BASE_URL_PROP);
+      String coreName = message.getStr(ZkStateReader.CORE_NAME_PROP);
+      sb.append(baseUrl);
+      if (baseUrl != null && !baseUrl.endsWith("/")) sb.append("/");
+      sb.append(coreName == null ? "" : coreName);
+      if (!(sb.substring(sb.length() - 1).equals("/"))) sb.append("/");
+      clusterState = setShardLeader(clusterState,
+          message.getStr(ZkStateReader.COLLECTION_PROP),
+          message.getStr(ZkStateReader.SHARD_ID_PROP),
+          sb.length() > 0 ? sb.toString() : null);
       return clusterState;
     }
+
     private void handleProp(ZkNodeProps message)  {
       String name = message.getStr("name");
       String val = message.getStr("val");
diff --git a/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java b/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
index d658604..9adc75e 100644
--- a/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
+++ b/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
@@ -26,8 +26,10 @@ import static org.apache.solr.common.cloud.ZkStateReader.ONLY_IF_DOWN;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDREPLICA;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDROLE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.CLUSTERSTATUS;
-import static org.apache.solr.common.params.CollectionParams.CollectionAction.LIST;
-import static org.apache.solr.common.params.CollectionParams.CollectionAction.OVERSEERSTATUS;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATE;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATESHARD;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETE;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETESHARD;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.REMOVEROLE;
 
 import java.io.Closeable;
@@ -74,7 +76,6 @@ import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
-import org.apache.solr.common.cloud.ZooKeeperException;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;
@@ -113,33 +114,31 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
   public static final String MAX_SHARDS_PER_NODE = "maxShardsPerNode";
   
   public static final String CREATE_NODE_SET = "createNodeSet";
-  
+
+  /**
+   * @deprecated use {@link org.apache.solr.common.params.CollectionParams.CollectionAction#DELETE}
+   */
+  @Deprecated
   public static final String DELETECOLLECTION = "deletecollection";
 
+  /**
+   * @deprecated use {@link org.apache.solr.common.params.CollectionParams.CollectionAction#CREATE}
+   */
+  @Deprecated
   public static final String CREATECOLLECTION = "createcollection";
 
+  /**
+   * @deprecated use {@link org.apache.solr.common.params.CollectionParams.CollectionAction#RELOAD}
+   */
+  @Deprecated
   public static final String RELOADCOLLECTION = "reloadcollection";
   
-  public static final String CREATEALIAS = "createalias";
-  
-  public static final String DELETEALIAS = "deletealias";
-  
-  public static final String SPLITSHARD = "splitshard";
-
-  public static final String DELETESHARD = "deleteshard";
-
   public static final String ROUTER = "router";
 
   public static final String SHARDS_PROP = "shards";
 
   public static final String ASYNC = "async";
 
-  public static final String CREATESHARD = "createshard";
-
-  public static final String DELETEREPLICA = "deletereplica";
-
-  public static final String MIGRATE = "migrate";
-
   public static final String REQUESTID = "requestid";
 
   public static final String COLL_CONF = "collection.configName";
@@ -442,7 +441,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     }
     //now ask the current leader to QUIT , so that the designate can takeover
     Overseer.getInQueue(zkStateReader.getZkClient()).offer(
-        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT,
+        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower(),
             "id",getLeaderId(zkStateReader.getZkClient()))));
 
   }
@@ -542,47 +541,87 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     return LeaderStatus.NO;
   }
 
-
+  @SuppressWarnings("unchecked")
   protected SolrResponse processMessage(ZkNodeProps message, String operation) {
     log.warn("OverseerCollectionProcessor.processMessage : "+ operation + " , "+ message.toString());
 
     NamedList results = new NamedList();
     try {
-      if (CREATECOLLECTION.equals(operation)) {
-        createCollection(zkStateReader.getClusterState(), message, results);
-      } else if (DELETECOLLECTION.equals(operation)) {
-        deleteCollection(message, results);
-      } else if (RELOADCOLLECTION.equals(operation)) {
-        ModifiableSolrParams params = new ModifiableSolrParams();
-        params.set(CoreAdminParams.ACTION, CoreAdminAction.RELOAD.toString());
-        collectionCmd(zkStateReader.getClusterState(), message, params, results, ZkStateReader.ACTIVE);
-      } else if (CREATEALIAS.equals(operation)) {
-        createAlias(zkStateReader.getAliases(), message);
-      } else if (DELETEALIAS.equals(operation)) {
-        deleteAlias(zkStateReader.getAliases(), message);
-      } else if (SPLITSHARD.equals(operation))  {
-        splitShard(zkStateReader.getClusterState(), message, results);
-      } else if (CREATESHARD.equals(operation))  {
-        createShard(zkStateReader.getClusterState(), message, results);
-      } else if (DELETESHARD.equals(operation)) {
-        deleteShard(zkStateReader.getClusterState(), message, results);
-      } else if (DELETEREPLICA.equals(operation)) {
-        deleteReplica(zkStateReader.getClusterState(), message, results);
-      } else if (MIGRATE.equals(operation)) {
-        migrate(zkStateReader.getClusterState(), message, results);
-      } else if(REMOVEROLE.isEqual(operation) || ADDROLE.isEqual(operation) ){
-        processRoleCommand(message, operation);
-      } else if (ADDREPLICA.isEqual(operation))  {
-        addReplica(zkStateReader.getClusterState(), message, results);
-      } else if (OVERSEERSTATUS.isEqual(operation)) {
-        getOverseerStatus(message, results);
-      } else if(LIST.isEqual(operation)) {
-        listCollections(zkStateReader.getClusterState(), results);
-      } else if (CLUSTERSTATUS.isEqual(operation)) {
-        getClusterStatus(zkStateReader.getClusterState(), message, results);
-      } else {
-        throw new SolrException(ErrorCode.BAD_REQUEST, "Unknown operation:"
-            + operation);
+      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(operation);
+      if (action == null) {
+        // back-compat because we used strings different than enum values before SOLR-6115
+        switch (operation) {
+          case CREATECOLLECTION:
+            createCollection(zkStateReader.getClusterState(), message, results);
+            break;
+          case DELETECOLLECTION:
+            deleteCollection(message, results);
+            break;
+          case RELOADCOLLECTION:
+            ModifiableSolrParams params = new ModifiableSolrParams();
+            params.set(CoreAdminParams.ACTION, CoreAdminAction.RELOAD.toString());
+            collectionCmd(zkStateReader.getClusterState(), message, params, results, ZkStateReader.ACTIVE);
+            break;
+          default:
+            throw new SolrException(ErrorCode.BAD_REQUEST, "Unknown operation:"
+                + operation);
+        }
+      } else  {
+        switch (action) {
+          case CREATE:
+            createCollection(zkStateReader.getClusterState(), message, results);
+            break;
+          case DELETE:
+            deleteCollection(message, results);
+            break;
+          case RELOAD:
+            ModifiableSolrParams params = new ModifiableSolrParams();
+            params.set(CoreAdminParams.ACTION, CoreAdminAction.RELOAD.toString());
+            collectionCmd(zkStateReader.getClusterState(), message, params, results, ZkStateReader.ACTIVE);
+            break;
+          case CREATEALIAS:
+            createAlias(zkStateReader.getAliases(), message);
+            break;
+          case DELETEALIAS:
+            deleteAlias(zkStateReader.getAliases(), message);
+            break;
+          case SPLITSHARD:
+            splitShard(zkStateReader.getClusterState(), message, results);
+            break;
+          case DELETESHARD:
+            deleteShard(zkStateReader.getClusterState(), message, results);
+            break;
+          case CREATESHARD:
+            createShard(zkStateReader.getClusterState(), message, results);
+            break;
+          case DELETEREPLICA:
+            deleteReplica(zkStateReader.getClusterState(), message, results);
+            break;
+          case MIGRATE:
+            migrate(zkStateReader.getClusterState(), message, results);
+            break;
+          case ADDROLE:
+            processRoleCommand(message, operation);
+            break;
+          case REMOVEROLE:
+            processRoleCommand(message, operation);
+            break;
+          case ADDREPLICA:
+            addReplica(zkStateReader.getClusterState(), message, results);
+            break;
+          case OVERSEERSTATUS:
+            getOverseerStatus(message, results);
+            break;
+          case LIST:
+            listCollections(zkStateReader.getClusterState(), results);
+            break;
+          case CLUSTERSTATUS:
+            getClusterStatus(zkStateReader.getClusterState(), message, results);
+            break;
+          default:
+            throw new SolrException(ErrorCode.BAD_REQUEST, "Unknown operation:"
+                + operation);
+        }
       }
     } catch (Exception e) {
       SolrException.log(log, "Collection " + operation + " of " + operation
@@ -596,6 +635,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     return new OverseerSolrResponse(results);
   }
 
+  @SuppressWarnings("unchecked")
   private void getOverseerStatus(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {
     String leaderNode = getLeaderNode(zkStateReader.getZkClient());
     results.add("leader", leaderNode);
@@ -669,6 +709,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
   }
 
+  @SuppressWarnings("unchecked")
   private void getClusterStatus(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {
     String collection = message.getStr(ZkStateReader.COLLECTION_PROP);
 
@@ -791,6 +832,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
    * @param shardStr comma separated shard names
    * @return map of collection properties
    */
+  @SuppressWarnings("unchecked")
   private Map<String, Object> getCollectionStatus(Map<String, Object> collection, String name, String shardStr) {
     if (collection == null)  {
       throw new SolrException(ErrorCode.BAD_REQUEST, "Collection: " + name + " not found");
@@ -812,6 +854,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     }
   }
 
+  @SuppressWarnings("unchecked")
   private void listCollections(ClusterState clusterState, NamedList results) {
     Set<String> collections = clusterState.getCollections();
     List<String> collectionList = new ArrayList<String>();
@@ -821,6 +864,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     results.add("collections", collectionList);
   }
 
+  @SuppressWarnings("unchecked")
   private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {
     SolrZkClient zkClient = zkStateReader.getZkClient();
     Map roles = null;
@@ -864,6 +908,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     }.start();
   }
 
+  @SuppressWarnings("unchecked")
   private void deleteReplica(ClusterState clusterState, ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {
     checkRequired(message, COLLECTION_PROP, SHARD_ID_PROP,REPLICA_PROP);
     String collectionName = message.getStr(COLLECTION_PROP);
@@ -942,7 +987,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
   private void deleteCoreNode(String collectionName, String replicaName, Replica replica, String core) throws KeeperException, InterruptedException {
     ZkNodeProps m = new ZkNodeProps(
-        Overseer.QUEUE_OPERATION, Overseer.DELETECORE,
+        Overseer.QUEUE_OPERATION, Overseer.OverseerAction.DELETECORE.toLower(),
         ZkStateReader.CORE_NAME_PROP, core,
         ZkStateReader.NODE_NAME_PROP, replica.getStr(ZkStateReader.NODE_NAME_PROP),
         ZkStateReader.COLLECTION_PROP, collectionName,
@@ -971,7 +1016,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
           null);
       
       ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-          Overseer.REMOVECOLLECTION, "name", collection);
+          DELETE.toLower(), "name", collection);
       Overseer.getInQueue(zkStateReader.getZkClient()).offer(
           ZkStateReader.toJSON(m));
       
@@ -1117,9 +1162,9 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
       throws KeeperException, InterruptedException {
     log.info("Create shard invoked: {}", message);
     String collectionName = message.getStr(COLLECTION_PROP);
-    String shard = message.getStr(SHARD_ID_PROP);
-    if(collectionName == null || shard ==null)
-      throw new SolrException(ErrorCode.BAD_REQUEST, "'collection' and 'shard' are required parameters" );
+    String sliceName = message.getStr(SHARD_ID_PROP);
+    if (collectionName == null || sliceName == null)
+      throw new SolrException(ErrorCode.BAD_REQUEST, "'collection' and 'shard' are required parameters");
     int numSlices = 1;
 
     ShardHandler shardHandler = shardHandlerFactory.getShardHandler();
@@ -1132,11 +1177,11 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
     Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));
     // wait for a while until we see the shard
-    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;
+    long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);
     boolean created = false;
     while (System.nanoTime() < waitUntil) {
       Thread.sleep(100);
-      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(shard) != null;
+      created = zkStateReader.getClusterState().getCollection(collectionName).getSlice(sliceName) != null;
       if (created) break;
     }
     if (!created)
@@ -1144,7 +1189,6 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
 
     String configName = message.getStr(COLL_CONF);
-    String sliceName = shard;
     for (int j = 1; j <= repFactor; j++) {
       String nodeName = sortedNodeList.get(((j - 1)) % sortedNodeList.size()).nodeName;
       String shardName = collectionName + "_" + sliceName + "_replica" + j;
@@ -1350,7 +1394,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
             + nodeName);
 
         Map<String, Object> propMap = new HashMap<>();
-        propMap.put(Overseer.QUEUE_OPERATION, "createshard");
+        propMap.put(Overseer.QUEUE_OPERATION, CREATESHARD.toLower());
         propMap.put(ZkStateReader.SHARD_ID_PROP, subSlice);
         propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);
         propMap.put(ZkStateReader.SHARD_RANGE_PROP, subRange.toString());
@@ -1555,7 +1599,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         log.info("Replication factor is 1 so switching shard states");
         DistributedQueue inQueue = Overseer.getInQueue(zkStateReader.getZkClient());
         Map<String, Object> propMap = new HashMap<>();
-        propMap.put(Overseer.QUEUE_OPERATION, "updateshardstate");
+        propMap.put(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.UPDATESHARDSTATE.toLower());
         propMap.put(slice, Slice.INACTIVE);
         for (String subSlice : subSlices) {
           propMap.put(subSlice, Slice.ACTIVE);
@@ -1567,7 +1611,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         log.info("Requesting shard state be set to 'recovery'");
         DistributedQueue inQueue = Overseer.getInQueue(zkStateReader.getZkClient());
         Map<String, Object> propMap = new HashMap<>();
-        propMap.put(Overseer.QUEUE_OPERATION, "updateshardstate");
+        propMap.put(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.UPDATESHARDSTATE.toLower());
         for (String subSlice : subSlices) {
           propMap.put(subSlice, Slice.RECOVERY);
         }
@@ -1727,13 +1771,13 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
       processResponses(results, shardHandler);
 
       ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-          Overseer.REMOVESHARD, ZkStateReader.COLLECTION_PROP, collection,
+          DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP, collection,
           ZkStateReader.SHARD_ID_PROP, sliceId);
       Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));
 
       // wait for a while until we don't see the shard
       long now = System.nanoTime();
-      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);;
+      long timeout = now + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);
       boolean removed = false;
       while (System.nanoTime() < timeout) {
         Thread.sleep(100);
@@ -1811,7 +1855,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     if (clusterState.hasCollection(tempSourceCollectionName)) {
       log.info("Deleting temporary collection: " + tempSourceCollectionName);
       Map<String, Object> props = ZkNodeProps.makeMap(
-          Overseer.QUEUE_OPERATION, DELETECOLLECTION,
+          Overseer.QUEUE_OPERATION, DELETE.toLower(),
           "name", tempSourceCollectionName);
 
       try {
@@ -1857,7 +1901,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     completeAsyncRequest(asyncId, requestMap, results);
 
     ZkNodeProps m = new ZkNodeProps(
-        Overseer.QUEUE_OPERATION, Overseer.ADD_ROUTING_RULE,
+        Overseer.QUEUE_OPERATION, Overseer.OverseerAction.ADDROUTINGRULE.toLower(),
         COLLECTION_PROP, sourceCollection.getName(),
         SHARD_ID_PROP, sourceSlice.getName(),
         "routeKey", SolrIndexSplitter.getRouteKey(splitKey) + "!",
@@ -1896,7 +1940,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     // create a temporary collection with just one node on the shard leader
     String configName = zkStateReader.readConfigName(sourceCollection.getName());
     Map<String, Object> props = ZkNodeProps.makeMap(
-        Overseer.QUEUE_OPERATION, CREATECOLLECTION,
+        Overseer.QUEUE_OPERATION, CREATE.toLower(),
         "name", tempSourceCollectionName,
         ZkStateReader.REPLICATION_FACTOR, 1,
         NUM_SLICES, 1,
@@ -2031,7 +2075,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     try {
       log.info("Deleting temporary collection: " + tempSourceCollectionName);
       props = ZkNodeProps.makeMap(
-          Overseer.QUEUE_OPERATION, DELETECOLLECTION,
+          Overseer.QUEUE_OPERATION, DELETE.toLower(),
           "name", tempSourceCollectionName);
       deleteCollection(new ZkNodeProps(props), results);
     } catch (Exception e) {
@@ -2189,7 +2233,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         if(created) break;
       }
       if (!created)
-        throw new SolrException(ErrorCode.SERVER_ERROR, "Could not fully createcollection: " + message.getStr("name"));
+        throw new SolrException(ErrorCode.SERVER_ERROR, "Could not fully create collection: " + message.getStr("name"));
 
       // For tracking async calls.
       HashMap<String, String> requestMap = new HashMap<String, String>();
@@ -2212,7 +2256,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
           // Otherwise the core creation fails
           if(!isLegacyCloud){
             ZkNodeProps props = new ZkNodeProps(
-                Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.ADDREPLICA.toString(),
+                Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),
                 ZkStateReader.COLLECTION_PROP, collectionName,
                 ZkStateReader.SHARD_ID_PROP, sliceName,
                 ZkStateReader.CORE_NAME_PROP, coreName,
@@ -2351,7 +2395,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
     if(!Overseer.isLegacy(zkStateReader.getClusterProps())){
       ZkNodeProps props = new ZkNodeProps(
-          Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),
+          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),
           ZkStateReader.COLLECTION_PROP, collection,
           ZkStateReader.SHARD_ID_PROP, shard,
           ZkStateReader.CORE_NAME_PROP, coreName,
@@ -2504,6 +2548,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     processResponse(results, e, nodeName, solrResponse, shard);
   }
 
+  @SuppressWarnings("unchecked")
   private void processResponse(NamedList results, Throwable e, String nodeName, SolrResponse solrResponse, String shard) {
     if (e != null) {
       log.error("Error from shard: " + shard, e);
@@ -2532,6 +2577,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     return isClosed;
   }
 
+  @SuppressWarnings("unchecked")
   private void waitForAsyncCallsToComplete(Map<String, String> requestMap, NamedList results) {
     for(String k:requestMap.keySet()) {
       log.debug("I am Waiting for :{}/{}", k, requestMap.get(k));
@@ -2599,6 +2645,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     } while(true);
   }
 
+  @SuppressWarnings("unchecked")
   private void markTaskAsRunning(QueueEvent head, String collectionName,
                                  String asyncId, ZkNodeProps message)
       throws KeeperException, InterruptedException {
diff --git a/solr/core/src/java/org/apache/solr/cloud/ZkController.java b/solr/core/src/java/org/apache/solr/cloud/ZkController.java
index 5ff3983..b442dc5 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ZkController.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ZkController.java
@@ -1179,7 +1179,7 @@ public final class ZkController {
     }
     if (removeWatch) zkStateReader.removeZKWatch(collection);
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        Overseer.DELETECORE, ZkStateReader.CORE_NAME_PROP, coreName,
+        Overseer.OverseerAction.DELETECORE.toLower(), ZkStateReader.CORE_NAME_PROP, coreName,
         ZkStateReader.NODE_NAME_PROP, getNodeName(),
         ZkStateReader.COLLECTION_PROP, cloudDescriptor.getCollectionName(),
         ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);
@@ -1189,7 +1189,7 @@ public final class ZkController {
   public void createCollection(String collection) throws KeeperException,
       InterruptedException {
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        "createcollection", ZkStateReader.NODE_NAME_PROP, getNodeName(),
+        CollectionParams.CollectionAction.CREATE.toLower(), ZkStateReader.NODE_NAME_PROP, getNodeName(),
         ZkStateReader.COLLECTION_PROP, collection);
     overseerJobQueue.offer(ZkStateReader.toJSON(m));
   }
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
index 667193c..e7d96bb 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
@@ -20,9 +20,7 @@ package org.apache.solr.handler.admin;
 import static org.apache.solr.cloud.Overseer.QUEUE_OPERATION;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.ASYNC;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.COLL_CONF;
-import static org.apache.solr.cloud.OverseerCollectionProcessor.CREATESHARD;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.CREATE_NODE_SET;
-import static org.apache.solr.cloud.OverseerCollectionProcessor.DELETEREPLICA;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.REPLICATION_FACTOR;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.REQUESTID;
@@ -34,10 +32,20 @@ import static org.apache.solr.common.cloud.ZkStateReader.ONLY_IF_DOWN;
 import static org.apache.solr.common.cloud.ZkStateReader.SHARD_ID_PROP;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.ADDROLE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.CLUSTERPROP;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATE;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATEALIAS;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.CREATESHARD;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETE;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEALIAS;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEREPLICA;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETESHARD;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.MIGRATE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.OVERSEERSTATUS;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.RELOAD;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.REMOVEROLE;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.common.cloud.ZkStateReader.AUTO_ADD_REPLICAS;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.SPLITSHARD;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -388,9 +396,9 @@ public class CollectionsHandler extends RequestHandlerBase {
     String name = req.getParams().required().get("name");
     
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        OverseerCollectionProcessor.RELOADCOLLECTION, "name", name);
+        RELOAD.toLower(), "name", name);
 
-    handleResponse(OverseerCollectionProcessor.RELOADCOLLECTION, m, rsp);
+    handleResponse(RELOAD.toLower(), m, rsp);
   }
   
   private void handleSyncShardAction(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException, SolrServerException, IOException {
@@ -424,10 +432,10 @@ public class CollectionsHandler extends RequestHandlerBase {
     String collections = req.getParams().required().get("collections");
     
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        OverseerCollectionProcessor.CREATEALIAS, "name", name, "collections",
+        CREATEALIAS.toLower(), "name", name, "collections",
         collections);
     
-    handleResponse(OverseerCollectionProcessor.CREATEALIAS, m, rsp);
+    handleResponse(CREATEALIAS.toLower(), m, rsp);
   }
   
   private void handleDeleteAliasAction(SolrQueryRequest req,
@@ -436,9 +444,9 @@ public class CollectionsHandler extends RequestHandlerBase {
     String name = req.getParams().required().get("name");
     
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        OverseerCollectionProcessor.DELETEALIAS, "name", name);
+        DELETEALIAS.toLower(), "name", name);
     
-    handleResponse(OverseerCollectionProcessor.DELETEALIAS, m, rsp);
+    handleResponse(DELETEALIAS.toLower(), m, rsp);
   }
 
   private void handleDeleteAction(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
@@ -447,9 +455,9 @@ public class CollectionsHandler extends RequestHandlerBase {
     String name = req.getParams().required().get("name");
     
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-        OverseerCollectionProcessor.DELETECOLLECTION, "name", name);
+        DELETE.toLower(), "name", name);
 
-    handleResponse(OverseerCollectionProcessor.DELETECOLLECTION, m, rsp);
+    handleResponse(DELETE.toLower(), m, rsp);
   }
 
   // very simple currently, you can pass a template collection, and the new collection is created on
@@ -469,7 +477,7 @@ public class CollectionsHandler extends RequestHandlerBase {
     
     Map<String,Object> props = ZkNodeProps.makeMap(
         Overseer.QUEUE_OPERATION,
-        OverseerCollectionProcessor.CREATECOLLECTION,
+        CREATE.toLower(),
         "fromApi","true");
     copyIfNotNull(req.getParams(),props,
         "name",
@@ -487,16 +495,16 @@ public class CollectionsHandler extends RequestHandlerBase {
     copyPropertiesIfNotNull(req.getParams(), props);
 
     ZkNodeProps m = new ZkNodeProps(props);
-    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);
+    handleResponse(CREATE.toLower(), m, rsp);
   }
 
   private void handleRemoveReplica(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
     log.info("Remove replica: " + req.getParamString());
     req.getParams().required().check(COLLECTION_PROP, SHARD_ID_PROP, "replica");
-    Map<String, Object> map = makeMap(QUEUE_OPERATION, DELETEREPLICA);
+    Map<String, Object> map = makeMap(QUEUE_OPERATION, DELETEREPLICA.toLower());
     copyIfNotNull(req.getParams(),map,COLLECTION_PROP,SHARD_ID_PROP,"replica", ASYNC, ONLY_IF_DOWN);
     ZkNodeProps m = new ZkNodeProps(map);
-    handleResponse(DELETEREPLICA, m, rsp);
+    handleResponse(DELETEREPLICA.toLower(), m, rsp);
   }
 
 
@@ -507,11 +515,11 @@ public class CollectionsHandler extends RequestHandlerBase {
     if(!ImplicitDocRouter.NAME.equals( ((Map) clusterState.getCollection(req.getParams().get(COLLECTION_PROP)).get(ROUTER)).get("name") )  )
       throw new SolrException(ErrorCode.BAD_REQUEST, "shards can be added only to 'implicit' collections" );
 
-    Map<String, Object> map = makeMap(QUEUE_OPERATION, CREATESHARD);
+    Map<String, Object> map = makeMap(QUEUE_OPERATION, CREATESHARD.toLower());
     copyIfNotNull(req.getParams(),map,COLLECTION_PROP, SHARD_ID_PROP, ZkStateReader.REPLICATION_FACTOR, CREATE_NODE_SET, ASYNC);
     copyPropertiesIfNotNull(req.getParams(), map);
     ZkNodeProps m = new ZkNodeProps(map);
-    handleResponse(CREATESHARD, m, rsp);
+    handleResponse(CREATESHARD.toLower(), m, rsp);
   }
 
   private static void copyIfNotNull(SolrParams params, Map<String, Object> props, String... keys) {
@@ -560,11 +568,11 @@ public class CollectionsHandler extends RequestHandlerBase {
     
     Map<String,Object> props = new HashMap<>();
     props.put(ZkStateReader.COLLECTION_PROP, name);
-    props.put(Overseer.QUEUE_OPERATION, OverseerCollectionProcessor.DELETESHARD);
+    props.put(Overseer.QUEUE_OPERATION, DELETESHARD.toLower());
     props.put(ZkStateReader.SHARD_ID_PROP, shard);
 
     ZkNodeProps m = new ZkNodeProps(props);
-    handleResponse(OverseerCollectionProcessor.DELETESHARD, m, rsp);
+    handleResponse(DELETESHARD.toLower(), m, rsp);
   }
 
   private void handleSplitShardAction(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
@@ -588,7 +596,7 @@ public class CollectionsHandler extends RequestHandlerBase {
     }
 
     Map<String,Object> props = new HashMap<>();
-    props.put(Overseer.QUEUE_OPERATION, OverseerCollectionProcessor.SPLITSHARD);
+    props.put(Overseer.QUEUE_OPERATION, SPLITSHARD.toLower());
     props.put("collection", name);
     if (shard != null)  {
       props.put(ZkStateReader.SHARD_ID_PROP, shard);
@@ -607,17 +615,17 @@ public class CollectionsHandler extends RequestHandlerBase {
 
     ZkNodeProps m = new ZkNodeProps(props);
 
-    handleResponse(OverseerCollectionProcessor.SPLITSHARD, m, rsp, DEFAULT_ZK_TIMEOUT * 5);
+    handleResponse(SPLITSHARD.toLower(), m, rsp, DEFAULT_ZK_TIMEOUT * 5);
   }
 
   private void handleMigrate(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
     log.info("Migrate action invoked: " + req.getParamString());
     req.getParams().required().check("collection", "split.key", "target.collection");
     Map<String,Object> props = new HashMap<>();
-    props.put(Overseer.QUEUE_OPERATION, OverseerCollectionProcessor.MIGRATE);
+    props.put(Overseer.QUEUE_OPERATION, MIGRATE.toLower());
     copyIfNotNull(req.getParams(), props, "collection", "split.key", "target.collection", "forward.timeout", ASYNC);
     ZkNodeProps m = new ZkNodeProps(props);
-    handleResponse(OverseerCollectionProcessor.MIGRATE, m, rsp, DEFAULT_ZK_TIMEOUT * 20);
+    handleResponse(MIGRATE.toLower(), m, rsp, DEFAULT_ZK_TIMEOUT * 20);
   }
 
   private void handleAddReplica(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException  {
diff --git a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
index 80aeb06..3630002 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
@@ -539,7 +539,7 @@ public class DistributedUpdateProcessor extends UpdateRequestProcessor {
                   if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {
                     log.info("Going to expire routing rule");
                     try {
-                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.REMOVE_ROUTING_RULE,
+                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.REMOVEROUTINGRULE.toLower(),
                           ZkStateReader.COLLECTION_PROP, collection,
                           ZkStateReader.SHARD_ID_PROP, myShardId,
                           "routeKey", routeKey + "!");
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
index a8e67b6..9c14e19 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
@@ -25,6 +25,7 @@ import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.ImplicitDocRouter;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.ZkNodeProps;
+import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.junit.After;
@@ -36,12 +37,12 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import static org.apache.solr.cloud.OverseerCollectionProcessor.DELETEREPLICA;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.REPLICATION_FACTOR;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.SHARDS_PROP;
 import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEREPLICA;
 
 public class DeleteLastCustomShardedReplicaTest extends AbstractFullDistribZkTestBase {
   private CloudSolrServer client;
@@ -108,7 +109,7 @@ public class DeleteLastCustomShardedReplicaTest extends AbstractFullDistribZkTes
 
   protected void removeAndWaitForLastReplicaGone(String COLL_NAME, Replica replica, String shard)
       throws SolrServerException, IOException, InterruptedException {
-    Map m = makeMap("collection", COLL_NAME, "action", DELETEREPLICA, "shard",
+    Map m = makeMap("collection", COLL_NAME, "action", DELETEREPLICA.toLower(), "shard",
         shard, "replica", replica.getName());
     SolrParams params = new MapSolrParams(m);
     SolrRequest request = new QueryRequest(params);
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
index a996f81..8417b35 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
@@ -17,10 +17,10 @@ package org.apache.solr.cloud;
  * limitations under the License.
  */
 
-import static org.apache.solr.cloud.OverseerCollectionProcessor.DELETEREPLICA;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEREPLICA;
 
 import java.io.File;
 import java.io.IOException;
@@ -157,7 +157,7 @@ public class DeleteReplicaTest extends AbstractFullDistribZkTestBase {
   protected void removeAndWaitForReplicaGone(String COLL_NAME,
       CloudSolrServer client, Replica replica, String shard)
       throws SolrServerException, IOException, InterruptedException {
-    Map m = makeMap("collection", COLL_NAME, "action", DELETEREPLICA, "shard",
+    Map m = makeMap("collection", COLL_NAME, "action", DELETEREPLICA.toLower(), "shard",
         shard, "replica", replica.getName());
     SolrParams params = new MapSolrParams(m);
     SolrRequest request = new QueryRequest(params);
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
index 4608912..cdd3972 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
@@ -157,7 +157,7 @@ public class DeleteShardTest extends AbstractFullDistribZkTestBase {
       KeeperException, InterruptedException {
     DistributedQueue inQueue = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());
     Map<String, Object> propMap = new HashMap<>();
-    propMap.put(Overseer.QUEUE_OPERATION, "updateshardstate");
+    propMap.put(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.UPDATESHARDSTATE.toLower());
     propMap.put(slice, state);
     propMap.put(ZkStateReader.COLLECTION_PROP, "collection1");
     ZkNodeProps m = new ZkNodeProps(propMap);
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
index c8a22ae..6b8b60c 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
@@ -26,6 +26,7 @@ import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;
 import org.apache.solr.common.params.ModifiableSolrParams;
@@ -313,7 +314,7 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
       public String answer() throws Throwable {
         String key = (String) getCurrentArguments()[0];
         zkMap.put(key, null);
-        handleCrateCollMessage((byte[]) getCurrentArguments()[1]);
+        handleCreateCollMessage((byte[]) getCurrentArguments()[1]);
         return key;
       }
     }).anyTimes();
@@ -339,10 +340,10 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
     return liveNodes;
   }
 
-  private void handleCrateCollMessage(byte[] bytes) {
+  private void handleCreateCollMessage(byte[] bytes) {
     try {
       ZkNodeProps props = ZkNodeProps.load(bytes);
-      if("createcollection".equals(props.getStr("operation"))){
+      if(CollectionParams.CollectionAction.CREATE.isEqual(props.getStr("operation"))){
         String collName = props.getStr("name") ;
         if(collName != null) collectionsSet.add(collName);
       }
@@ -390,7 +391,7 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
     ZkNodeProps props;
     if (sendCreateNodeList) {
       props = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-          OverseerCollectionProcessor.CREATECOLLECTION,
+          CollectionParams.CollectionAction.CREATE.toLower(),
           ZkStateReader.REPLICATION_FACTOR,
           replicationFactor.toString(), "name", COLLECTION_NAME,
           "collection.configName", CONFIG_NAME,
@@ -401,7 +402,7 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
           (createNodeList != null)?StrUtils.join(createNodeList, ','):null);
     } else {
       props = new ZkNodeProps(Overseer.QUEUE_OPERATION,
-          OverseerCollectionProcessor.CREATECOLLECTION,
+          CollectionParams.CollectionAction.CREATE.toLower(),
           ZkStateReader.REPLICATION_FACTOR,
           replicationFactor.toString(), "name", COLLECTION_NAME,
           "collection.configName", CONFIG_NAME,
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
index 4c48be8..b43aecc 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
@@ -106,7 +106,7 @@ public class OverseerRolesTest  extends AbstractFullDistribZkTestBase{
     Map m = (Map) ZkStateReader.fromJSON(data);
     String s = (String) m.get("id");
     String leader = LeaderElector.getNodeName(s);
-    Overseer.getInQueue(zk).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.QUIT)));
+    Overseer.getInQueue(zk).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.QUIT.toLower())));
     long timeout = System.currentTimeMillis()+10000;
     String newLeader=null;
     for(;System.currentTimeMillis() < timeout;){
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerStatusTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerStatusTest.java
index f9a3a76..f310866 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerStatusTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerStatusTest.java
@@ -75,13 +75,13 @@ public class OverseerStatusTest extends BasicDistributedZkTest {
     if (resp != null) {
       NamedList<Object> collection_operations = (NamedList<Object>) resp.get("collection_operations");
       if (collection_operations != null)  {
-        SimpleOrderedMap<Object> createcollection = (SimpleOrderedMap<Object>) collection_operations.get(OverseerCollectionProcessor.CREATECOLLECTION);
+        SimpleOrderedMap<Object> createcollection = (SimpleOrderedMap<Object>) collection_operations.get(CollectionParams.CollectionAction.CREATE.toLower());
         if (createcollection != null && createcollection.get("requests") != null) {
           numCollectionCreates = (Integer) createcollection.get("requests");
         }
         NamedList<Object> overseer_operations = (NamedList<Object>) resp.get("overseer_operations");
         if (overseer_operations != null)  {
-          createcollection = (SimpleOrderedMap<Object>) overseer_operations.get("createcollection");
+          createcollection = (SimpleOrderedMap<Object>) overseer_operations.get(CollectionParams.CollectionAction.CREATE.toLower());
           if (createcollection != null && createcollection.get("requests") != null) {
             numOverseerCreates = (Integer) createcollection.get("requests");
           }
@@ -95,16 +95,16 @@ public class OverseerStatusTest extends BasicDistributedZkTest {
         CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());
     NamedList<Object> collection_operations = (NamedList<Object>) resp.get("collection_operations");
     NamedList<Object> overseer_operations = (NamedList<Object>) resp.get("overseer_operations");
-    SimpleOrderedMap<Object> createcollection = (SimpleOrderedMap<Object>) collection_operations.get(OverseerCollectionProcessor.CREATECOLLECTION);
-    assertEquals("No stats for createcollection in OverseerCollectionProcessor", numCollectionCreates + 1, createcollection.get("requests"));
-    createcollection = (SimpleOrderedMap<Object>) overseer_operations.get("createcollection");
-    assertEquals("No stats for createcollection in Overseer", numOverseerCreates + 1, createcollection.get("requests"));
+    SimpleOrderedMap<Object> createcollection = (SimpleOrderedMap<Object>) collection_operations.get(CollectionParams.CollectionAction.CREATE.toLower());
+    assertEquals("No stats for create in OverseerCollectionProcessor", numCollectionCreates + 1, createcollection.get("requests"));
+    createcollection = (SimpleOrderedMap<Object>) overseer_operations.get(CollectionParams.CollectionAction.CREATE.toLower());
+    assertEquals("No stats for create in Overseer", numOverseerCreates + 1, createcollection.get("requests"));
 
     invokeCollectionApi("action", CollectionParams.CollectionAction.RELOAD.toLower(), "name", collectionName);
     resp = invokeCollectionApi("action",
         CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());
     collection_operations = (NamedList<Object>) resp.get("collection_operations");
-    SimpleOrderedMap<Object> reload = (SimpleOrderedMap<Object>) collection_operations.get(OverseerCollectionProcessor.RELOADCOLLECTION);
+    SimpleOrderedMap<Object> reload = (SimpleOrderedMap<Object>) collection_operations.get(CollectionParams.CollectionAction.RELOAD.toLower());
     assertEquals("No stats for reload in OverseerCollectionProcessor", 1, reload.get("requests"));
 
     try {
@@ -117,7 +117,7 @@ public class OverseerStatusTest extends BasicDistributedZkTest {
     resp = invokeCollectionApi("action",
         CollectionParams.CollectionAction.OVERSEERSTATUS.toLower());
     collection_operations = (NamedList<Object>) resp.get("collection_operations");
-    SimpleOrderedMap<Object> split = (SimpleOrderedMap<Object>) collection_operations.get(OverseerCollectionProcessor.SPLITSHARD);
+    SimpleOrderedMap<Object> split = (SimpleOrderedMap<Object>) collection_operations.get(CollectionParams.CollectionAction.SPLITSHARD.toLower());
     assertEquals("No stats for split in OverseerCollectionProcessor", 1, split.get("errors"));
     assertNotNull(split.get("recent_failures"));
 
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
index 50730a9..625e481 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
@@ -112,7 +112,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
         if (ec != null) {
           ec.cancelElection();
         }
-        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "deletecore",
+        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.DELETECORE.toLower(),
             ZkStateReader.NODE_NAME_PROP, nodeName,
             ZkStateReader.CORE_NAME_PROP, coreName,
             ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName,
@@ -121,7 +121,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
             q.offer(ZkStateReader.toJSON(m));
          return null;
       } else {
-        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state",
+        ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.STATE.toLower(),
         ZkStateReader.STATE_PROP, stateName,
         ZkStateReader.NODE_NAME_PROP, nodeName,
         ZkStateReader.CORE_NAME_PROP, coreName,
@@ -525,7 +525,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
 
       DistributedQueue q = Overseer.getInQueue(zkClient);
       
-      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state",
+      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.STATE.toLower(),
           ZkStateReader.BASE_URL_PROP, "http://127.0.0.1/solr",
           ZkStateReader.NODE_NAME_PROP, "node1",
           ZkStateReader.COLLECTION_PROP, "collection1",
@@ -928,7 +928,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
       
       //submit to proper queue
       queue = Overseer.getInQueue(zkClient);
-      m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state",
+      m = new ZkNodeProps(Overseer.QUEUE_OPERATION, Overseer.OverseerAction.STATE.toLower(),
           ZkStateReader.BASE_URL_PROP, "http://127.0.0.1/solr",
           ZkStateReader.NODE_NAME_PROP, "node1",
           ZkStateReader.SHARD_ID_PROP, "s1",
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
index fb5e59c..f5c0175 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
@@ -65,6 +65,7 @@ import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.CollectionParams.CollectionAction;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
@@ -374,7 +375,7 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
           AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT);
       Overseer.getInQueue(zkClient).offer(
           ZkStateReader.toJSON(ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION,
-              OverseerCollectionProcessor.CREATECOLLECTION, "name",
+              CollectionParams.CollectionAction.CREATE.toLower(), "name",
               DEFAULT_COLLECTION, "numShards", String.valueOf(sliceCount),
               DocCollection.STATE_FORMAT, getStateFormat())));
       zkClient.close();

