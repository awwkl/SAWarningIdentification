GitDiffStart: 737bb84db3cf37aa9939a875434140872d2b1e66 | Fri Jun 22 16:04:38 2012 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index aa6d58d..1f48609 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -283,6 +283,11 @@ Changes in backwards compatibility policy
   removed, as IndexReaderContext.leaves() is now the preferred way
   to access sub-readers.  (Uwe Schindler)
 
+* LUCENE-4155: oal.util.ReaderUtil, TwoPhaseCommit, TwoPhaseCommitTool
+  classes were moved to oal.index package. oal.util.CodecUtil class was moved
+  to oal.codecs package. oal.util.DummyConcurrentLock was removed
+  (no longer used in Lucene 4.0).  (Uwe Schindler)
+
 Changes in Runtime Behavior
 
 * LUCENE-2846: omitNorms now behaves like omitTermFrequencyAndPositions, if you
diff --git a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/BinaryDictionary.java b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/BinaryDictionary.java
index 2a70c64..edad0fa 100644
--- a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/BinaryDictionary.java
+++ b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/BinaryDictionary.java
@@ -26,9 +26,9 @@ import java.nio.ByteBuffer;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.InputStreamDataInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.IOUtils;
 
diff --git a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/CharacterDefinition.java b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/CharacterDefinition.java
index c5b6e01..fbd8611 100644
--- a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/CharacterDefinition.java
+++ b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/CharacterDefinition.java
@@ -21,9 +21,9 @@ import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.InputStreamDataInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java
index 9600e10..0ca72cb 100644
--- a/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java
+++ b/lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/dict/ConnectionCosts.java
@@ -21,9 +21,9 @@ import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.InputStreamDataInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsReader.java
index 8707048..4097d15 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsReader.java
@@ -41,7 +41,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.DoubleBarrelLRUCache;
 
 /** Handles a terms dict, but decouples all details of
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsWriter.java
index a168705..daf49d4 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/BlockTermsWriter.java
@@ -31,7 +31,6 @@ import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.RamUsageEstimator;
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java
index fc496e7..a4d9516 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java
@@ -41,7 +41,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.StringHelper;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java
index 70f7dec..80156f8 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java
@@ -31,7 +31,6 @@ import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.fst.Builder;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
new file mode 100644
index 0000000..c9c562e
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
@@ -0,0 +1,153 @@
+package org.apache.lucene.codecs;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexFormatTooNewException;
+import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.store.DataInput;
+import org.apache.lucene.store.DataOutput;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Utility class for reading and writing versioned headers.
+ * <p>
+ * Writing codec headers is useful to ensure that a file is in 
+ * the format you think it is.
+ * 
+ * @lucene.experimental
+ */
+
+public final class CodecUtil {
+  private CodecUtil() {} // no instance
+
+  /**
+   * Constant to identify the start of a codec header.
+   */
+  public final static int CODEC_MAGIC = 0x3fd76c17;
+
+  /**
+   * Writes a codec header, which records both a string to
+   * identify the file and a version number. This header can
+   * be parsed and validated with 
+   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.
+   * <p>
+   * CodecHeader --&gt; Magic,CodecName,Version
+   * <ul>
+   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This
+   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.
+   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This
+   *        is a string to identify this file.
+   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records
+   *        the version of the file.
+   * </ul>
+   * <p>
+   * Note that the length of a codec header depends only upon the
+   * name of the codec, so this length can be computed at any time
+   * with {@link #headerLength(String)}.
+   * 
+   * @param out Output stream
+   * @param codec String to identify this file. It should be simple ASCII, 
+   *              less than 128 characters in length.
+   * @param version Version number
+   * @throws IOException If there is an I/O error writing to the underlying medium.
+   */
+  public static void writeHeader(DataOutput out, String codec, int version)
+    throws IOException {
+    BytesRef bytes = new BytesRef(codec);
+    if (bytes.length != codec.length() || bytes.length >= 128) {
+      throw new IllegalArgumentException("codec must be simple ASCII, less than 128 characters in length [got " + codec + "]");
+    }
+    out.writeInt(CODEC_MAGIC);
+    out.writeString(codec);
+    out.writeInt(version);
+  }
+
+  /**
+   * Computes the length of a codec header.
+   * 
+   * @param codec Codec name.
+   * @return length of the entire codec header.
+   * @see #writeHeader(DataOutput, String, int)
+   */
+  public static int headerLength(String codec) {
+    return 9+codec.length();
+  }
+
+  /**
+   * Reads and validates a header previously written with 
+   * {@link #writeHeader(DataOutput, String, int)}.
+   * <p>
+   * When reading a file, supply the expected <code>codec</code> and
+   * an expected version range (<code>minVersion to maxVersion</code>).
+   * 
+   * @param in Input stream, positioned at the point where the
+   *        header was previously written. Typically this is located
+   *        at the beginning of the file.
+   * @param codec The expected codec name.
+   * @param minVersion The minimum supported expected version number.
+   * @param maxVersion The maximum supported expected version number.
+   * @return The actual version found, when a valid header is found 
+   *         that matches <code>codec</code>, with an actual version 
+   *         where <code>minVersion <= actual <= maxVersion</code>.
+   *         Otherwise an exception is thrown.
+   * @throws CorruptIndexException If the first four bytes are not
+   *         {@link #CODEC_MAGIC}, or if the actual codec found is
+   *         not <code>codec</code>.
+   * @throws IndexFormatTooOldException If the actual version is less 
+   *         than <code>minVersion</code>.
+   * @throws IndexFormatTooNewException If the actual version is greater 
+   *         than <code>maxVersion</code>.
+   * @throws IOException If there is an I/O error reading from the underlying medium.
+   * @see #writeHeader(DataOutput, String, int)
+   */
+  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)
+    throws IOException {
+
+    // Safety to guard against reading a bogus string:
+    final int actualHeader = in.readInt();
+    if (actualHeader != CODEC_MAGIC) {
+      throw new CorruptIndexException("codec header mismatch: actual header=" + actualHeader + " vs expected header=" + CODEC_MAGIC + " (resource: " + in + ")");
+    }
+    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);
+  }
+
+  /** Like {@link
+   *  #checkHeader(DataInput,String,int,int)} except this
+   *  version assumes the first int has already been read
+   *  and validated from the input. */
+  public static int checkHeaderNoMagic(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {
+    final String actualCodec = in.readString();
+    if (!actualCodec.equals(codec)) {
+      throw new CorruptIndexException("codec mismatch: actual codec=" + actualCodec + " vs expected codec=" + codec + " (resource: " + in + ")");
+    }
+
+    final int actualVersion = in.readInt();
+    if (actualVersion < minVersion) {
+      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);
+    }
+    if (actualVersion > maxVersion) {
+      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);
+    }
+
+    return actualVersion;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.java b/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.java
index be9c0a4..1e41eb7 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.java
@@ -23,7 +23,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.PagedBytes;
 import org.apache.lucene.util.packed.PackedInts;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexWriter.java
index 7800774..fa82964 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexWriter.java
@@ -23,7 +23,6 @@ import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.packed.PackedInts;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexReader.java b/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexReader.java
index 751d161..ceb76e1 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexReader.java
@@ -30,7 +30,6 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.fst.Builder;
 import org.apache.lucene.util.fst.BytesRefFSTEnum;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexWriter.java
index 87b7722..2156fbc 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/VariableGapTermsIndexWriter.java
@@ -27,7 +27,6 @@ import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.fst.Builder;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsReader.java
index 4aa6950..92198e9 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsReader.java
@@ -20,12 +20,12 @@ package org.apache.lucene.codecs.appending;
 import java.io.IOException;
 
 import org.apache.lucene.codecs.BlockTreeTermsReader;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 
 /**
  * Reads append-only terms from {@link AppendingTermsWriter}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsWriter.java
index 9e6d0ce..8025a21 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingTermsWriter.java
@@ -20,10 +20,10 @@ package org.apache.lucene.codecs.appending;
 import java.io.IOException;
 
 import org.apache.lucene.codecs.BlockTreeTermsWriter;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.CodecUtil;
 
 /**
  * Append-only version of {@link BlockTreeTermsWriter}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
index eafd893..f45df60 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
@@ -20,12 +20,12 @@ package org.apache.lucene.codecs.lucene40;
 import java.io.IOException;
 import java.util.Arrays;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.CompoundFileDirectory;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.MutableBits;
 
 /** Optimized implementation of a vector of bits.  This is more-or-less like
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesFormat.java
index caf8520..1a08c44 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40DocValuesFormat.java
@@ -19,6 +19,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.PerDocConsumer;
 import org.apache.lucene.codecs.PerDocProducer;
@@ -28,7 +29,6 @@ import org.apache.lucene.index.PerDocWriteState;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.store.CompoundFileDirectory; // javadocs
 import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.util.CodecUtil; // javadocs
 import org.apache.lucene.util.packed.PackedInts; // javadocs
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosFormat.java
index 5d238f2..e41baa0 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosFormat.java
@@ -19,13 +19,13 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.FieldInfosReader;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.index.DocValues; // javadoc
 import org.apache.lucene.index.DocValues.Type; // javadoc
 import org.apache.lucene.store.DataOutput; // javadoc
-import org.apache.lucene.util.CodecUtil; // javadoc
 
 /**
  * Lucene 4.0 Field Infos format.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
index 2e2db41..40b97ed 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
@@ -4,6 +4,7 @@ import java.io.IOException;
 import java.util.Collections;
 import java.util.Map;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.FieldInfosReader;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo;
@@ -14,7 +15,6 @@ import org.apache.lucene.index.DocValues;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java
index 7d3e2f5..e30fcee 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java
@@ -18,6 +18,7 @@ package org.apache.lucene.codecs.lucene40;
  */
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.index.DocValues.Type;
 import org.apache.lucene.index.FieldInfo;
@@ -27,7 +28,6 @@ import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.CodecUtil;
 
 /**
  * Lucene 4.0 FieldInfos writer.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
index d047e79..faaaf3f 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.lucene40;
 import java.io.IOException;
 import java.util.Collection;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfoPerCommit;
@@ -27,7 +28,6 @@ import org.apache.lucene.store.DataOutput; // javadocs
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.CodecUtil; // javadocs
 import org.apache.lucene.util.MutableBits;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsFormat.java
index a3c06bc..26f7f02 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsFormat.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.lucene.codecs.BlockTreeTermsReader;
 import org.apache.lucene.codecs.BlockTreeTermsWriter;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.FieldsConsumer;
 import org.apache.lucene.codecs.FieldsProducer;
 import org.apache.lucene.codecs.PostingsFormat;
@@ -32,7 +33,6 @@ import org.apache.lucene.index.FieldInfos; // javadocs
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.util.CodecUtil; // javadocs
 import org.apache.lucene.util.fst.FST; // javadocs
 
 /** 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsReader.java
index d7f1aea..5d0f9fa 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsReader.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.lucene40;
 import java.io.IOException;
 
 import org.apache.lucene.codecs.BlockTermState;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
@@ -36,7 +37,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /** 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsWriter.java
index 5cf6f3d..91c135c 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40PostingsWriter.java
@@ -24,6 +24,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
 import org.apache.lucene.index.CorruptIndexException;
@@ -35,7 +36,6 @@ import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
index dd2e272..d70b05d 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
@@ -17,13 +17,13 @@ package org.apache.lucene.codecs.lucene40;
  * limitations under the License.
  */
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.SegmentInfoReader;
 import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.index.IndexWriter; // javadocs
 import org.apache.lucene.index.SegmentInfos; // javadocs
 import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.util.CodecUtil; // javadocs
 
 /**
  * Lucene 4.0 Segment info format.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
index 74a56cd..0aeb8bf 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
@@ -22,13 +22,13 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.SegmentInfoReader;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
index 873767d..18def28 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
@@ -19,6 +19,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
@@ -26,7 +27,6 @@ import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsFormat.java
index 4811ef2..2ebc99f 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsFormat.java
@@ -19,6 +19,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.StoredFieldsWriter;
@@ -27,7 +28,6 @@ import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.DataOutput; // javadocs
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.CodecUtil;
 
 /** 
  * Lucene 4.0 Stored Fields Format.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsReader.java
index 7b7b0ca..e48aa63 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsReader.java
@@ -19,6 +19,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo;
@@ -30,7 +31,6 @@ import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 import java.io.Closeable;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsWriter.java
index 73be17e..2b6438a 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsWriter.java
@@ -18,6 +18,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.StoredFieldsWriter;
 import org.apache.lucene.document.Document;
@@ -35,7 +36,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /** 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsFormat.java
index bc3f0f5..89c46e4 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsFormat.java
@@ -19,6 +19,7 @@ package org.apache.lucene.codecs.lucene40;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.TermVectorsReader;
 import org.apache.lucene.codecs.TermVectorsWriter;
@@ -27,7 +28,6 @@ import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.DataOutput; // javadocs
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.CodecUtil;
 
 /**
  * Lucene 4.0 Term Vectors format.
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsReader.java
index c707b82..0eaebc4 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsReader.java
@@ -23,6 +23,7 @@ import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.TermVectorsReader;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.DocsAndPositionsEnum;
@@ -40,7 +41,6 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsWriter.java
index ec54cf5..b66970e 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40TermVectorsWriter.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.lucene40;
 import java.io.IOException;
 import java.util.Comparator;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.TermVectorsReader;
 import org.apache.lucene.codecs.TermVectorsWriter;
 import org.apache.lucene.index.FieldInfo;
@@ -36,7 +37,6 @@ import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.StringHelper;
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
index 9616e6e..fd092aa 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/Bytes.java
@@ -22,6 +22,7 @@ import java.io.IOException;
 import java.util.Comparator;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesConsumer;
 import org.apache.lucene.index.DocValues.SortedSource;
 import org.apache.lucene.index.DocValues.Source;
@@ -41,7 +42,6 @@ import org.apache.lucene.util.ByteBlockPool;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefHash.TrackingDirectBytesStartArray;
 import org.apache.lucene.util.BytesRefHash;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.Counter;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.PagedBytes;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
index f887297..8599c9b 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/values/PackedIntValues.java
@@ -18,6 +18,7 @@ package org.apache.lucene.codecs.lucene40.values;
  */
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesArraySource;
 import org.apache.lucene.codecs.lucene40.values.FixedStraightBytesImpl.FixedBytesWriterBase;
 import org.apache.lucene.index.DocValues.Source;
@@ -30,7 +31,6 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.Counter;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.packed.PackedInts;
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsReader.java
index 0b5a82e..79cfbb7 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsReader.java
@@ -22,6 +22,7 @@ import java.util.IdentityHashMap;
 import java.util.Map;
 
 import org.apache.lucene.codecs.BlockTermState;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
@@ -36,7 +37,6 @@ import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 
 /** Concrete class that reads the current doc/freq/skip
  *  postings format 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsWriter.java
index 8fa5587..c4c7b4f 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/pulsing/PulsingPostingsWriter.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.List;
 import java.util.ArrayList;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
 import org.apache.lucene.index.FieldInfo;
@@ -28,7 +29,6 @@ import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 
 // TODO: we now inline based on total TF of the term,
 // but it might be better to inline by "net bytes used"
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java
index c9f300f..73f5729 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsReader.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.sep;
 import java.io.IOException;
 
 import org.apache.lucene.codecs.BlockTermState;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
@@ -36,7 +37,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 
 /** Concrete class that reads the current doc/freq/skip
  *  postings format.    
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java
index 89061f7..ef96302 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/sep/SepPostingsWriter.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
 import org.apache.lucene.index.CorruptIndexException;
@@ -32,7 +33,6 @@ import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /** Writes frq to .frq, docs to .doc, pos to .pos, payloads
diff --git a/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java b/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java
index d77e3b4..445e6d2 100644
--- a/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java
@@ -22,7 +22,6 @@ import java.io.IOException;
 import org.apache.lucene.search.SearcherManager; // javadocs
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;         // for javadocs
 
 /** {@code AtomicReader} is an abstract class, providing an interface for accessing an
  index.  Search of an index is done entirely through this abstract interface,
diff --git a/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java b/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
index 0021e51..4b54c82 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
@@ -23,7 +23,6 @@ import java.util.Collections;
 import java.util.List;
 
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
 
 /** Base class for implementing {@link CompositeReader}s based on an array
  * of sub-readers. The implementing class has to add code for
diff --git a/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java b/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java
new file mode 100644
index 0000000..7870072
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java
@@ -0,0 +1,51 @@
+package org.apache.lucene.index;
+
+import org.apache.lucene.util.Bits;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Exposes a slice of an existing Bits as a new Bits.
+ *
+ * @lucene.internal
+ */
+final class BitsSlice implements Bits {
+  private final Bits parent;
+  private final int start;
+  private final int length;
+
+  // start is inclusive; end is exclusive (length = end-start)
+  public BitsSlice(Bits parent, ReaderSlice slice) {
+    this.parent = parent;
+    this.start = slice.start;
+    this.length = slice.length;
+    assert length >= 0: "length=" + length;
+  }
+    
+  public boolean get(int doc) {
+    if (doc >= length) {
+      throw new RuntimeException("doc " + doc + " is out of bounds 0 .. " + (length-1));
+    }
+    assert doc < length: "doc=" + doc + " length=" + length;
+    return parent.get(doc+start);
+  }
+
+  public int length() {
+    return length;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexReader.java b/lucene/core/src/java/org/apache/lucene/index/IndexReader.java
index ffe4d56..13b5f4c 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexReader.java
@@ -31,7 +31,6 @@ import org.apache.lucene.search.SearcherManager; // javadocs
 import org.apache.lucene.store.*;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;         // for javadocs
 
 /** IndexReader is an abstract class, providing an interface for accessing an
  index.  Search of an index is done entirely through this abstract interface,
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 5bb2799..1729d92 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -53,7 +53,6 @@ import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.MutableBits;
 import org.apache.lucene.util.ThreadInterruptedException;
-import org.apache.lucene.util.TwoPhaseCommit;
 
 /**
   An <code>IndexWriter</code> creates and maintains an index.
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiBits.java b/lucene/core/src/java/org/apache/lucene/index/MultiBits.java
new file mode 100644
index 0000000..cb45220
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiBits.java
@@ -0,0 +1,115 @@
+package org.apache.lucene.index;
+
+import org.apache.lucene.util.Bits;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Concatenates multiple Bits together, on every lookup.
+ *
+ * <p><b>NOTE</b>: This is very costly, as every lookup must
+ * do a binary search to locate the right sub-reader.
+ *
+ * @lucene.experimental
+ */
+final class MultiBits implements Bits {
+  private final Bits[] subs;
+
+  // length is 1+subs.length (the last entry has the maxDoc):
+  private final int[] starts;
+
+  private final boolean defaultValue;
+
+  public MultiBits(Bits[] subs, int[] starts, boolean defaultValue) {
+    assert starts.length == 1+subs.length;
+    this.subs = subs;
+    this.starts = starts;
+    this.defaultValue = defaultValue;
+  }
+
+  private boolean checkLength(int reader, int doc) {
+    final int length = starts[1+reader]-starts[reader];
+    assert doc - starts[reader] < length: "doc=" + doc + " reader=" + reader + " starts[reader]=" + starts[reader] + " length=" + length;
+    return true;
+  }
+
+  public boolean get(int doc) {
+    final int reader = ReaderUtil.subIndex(doc, starts);
+    assert reader != -1;
+    final Bits bits = subs[reader];
+    if (bits == null) {
+      return defaultValue;
+    } else {
+      assert checkLength(reader, doc);
+      return bits.get(doc-starts[reader]);
+    }
+  }
+  
+  @Override
+  public String toString() {
+    StringBuilder b = new StringBuilder();
+    b.append(subs.length + " subs: ");
+    for(int i=0;i<subs.length;i++) {
+      if (i != 0) {
+        b.append("; ");
+      }
+      if (subs[i] == null) {
+        b.append("s=" + starts[i] + " l=null");
+      } else {
+        b.append("s=" + starts[i] + " l=" + subs[i].length() + " b=" + subs[i]);
+      }
+    }
+    b.append(" end=" + starts[subs.length]);
+    return b.toString();
+  }
+
+  /**
+   * Represents a sub-Bits from 
+   * {@link MultiBits#getMatchingSub(org.apache.lucene.index.ReaderSlice) getMatchingSub()}.
+   */
+  public final static class SubResult {
+    public boolean matches;
+    public Bits result;
+  }
+
+  /**
+   * Returns a sub-Bits matching the provided <code>slice</code>
+   * <p>
+   * Because <code>null</code> usually has a special meaning for
+   * Bits (e.g. no deleted documents), you must check
+   * {@link SubResult#matches} instead to ensure the sub was 
+   * actually found.
+   */
+  public SubResult getMatchingSub(ReaderSlice slice) {
+    int reader = ReaderUtil.subIndex(slice.start, starts);
+    assert reader != -1;
+    assert reader < subs.length: "slice=" + slice + " starts[-1]=" + starts[starts.length-1];
+    final SubResult subResult = new SubResult();
+    if (starts[reader] == slice.start && starts[1+reader] == slice.start+slice.length) {
+      subResult.matches = true;
+      subResult.result = subs[reader];
+    } else {
+      subResult.matches = false;
+    }
+    return subResult;
+  }
+
+  public int length() {
+    return starts[starts.length-1];
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java b/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
index 27cb8e9..62074f5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
@@ -28,7 +28,6 @@ import org.apache.lucene.index.SortedBytesMergeUtils.SortedSourceSlice;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.PagedBytes;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.packed.PackedInts.Reader;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiDocsAndPositionsEnum.java b/lucene/core/src/java/org/apache/lucene/index/MultiDocsAndPositionsEnum.java
index 04a383c..47f4d37 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiDocsAndPositionsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiDocsAndPositionsEnum.java
@@ -18,7 +18,6 @@ package org.apache.lucene.index;
  */
 
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderSlice;
 
 import java.io.IOException;
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiDocsEnum.java b/lucene/core/src/java/org/apache/lucene/index/MultiDocsEnum.java
index c9bbd71..d112afa 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiDocsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiDocsEnum.java
@@ -17,7 +17,6 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
-import org.apache.lucene.util.ReaderSlice;
 
 import java.io.IOException;
 import java.util.Arrays;
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiFields.java b/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
index 240e4f5..cdaeeba 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
@@ -27,8 +27,6 @@ import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.MultiBits;
-import org.apache.lucene.util.ReaderSlice;
 
 /**
  * Exposes flex API, merged from flex API of sub-segments.
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiFieldsEnum.java b/lucene/core/src/java/org/apache/lucene/index/MultiFieldsEnum.java
index dba1b48..7009c95 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiFieldsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiFieldsEnum.java
@@ -18,7 +18,6 @@ package org.apache.lucene.index;
  */
 
 import org.apache.lucene.util.PriorityQueue;
-import org.apache.lucene.util.ReaderSlice;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiTerms.java b/lucene/core/src/java/org/apache/lucene/index/MultiTerms.java
index d42d69a..5edf803 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiTerms.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiTerms.java
@@ -23,7 +23,6 @@ import java.util.Comparator;
 import java.util.List;
 
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderSlice;
 
 import org.apache.lucene.util.automaton.CompiledAutomaton;
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum.java b/lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum.java
index ab42935..c368601 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiTermsEnum.java
@@ -20,9 +20,6 @@ package org.apache.lucene.index;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BitsSlice;
-import org.apache.lucene.util.MultiBits;
-import org.apache.lucene.util.ReaderSlice;
 
 import java.io.IOException;
 import java.util.Arrays;
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReaderSlice.java b/lucene/core/src/java/org/apache/lucene/index/ReaderSlice.java
new file mode 100644
index 0000000..62eabc2
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/ReaderSlice.java
@@ -0,0 +1,41 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Subreader slice from a parent composite reader.
+ *
+ * @lucene.internal
+ */
+public final class ReaderSlice {
+  public static final ReaderSlice[] EMPTY_ARRAY = new ReaderSlice[0];
+  public final int start;
+  public final int length;
+  public final int readerIndex;
+
+  public ReaderSlice(int start, int length, int readerIndex) {
+    this.start = start;
+    this.length = length;
+    this.readerIndex = readerIndex;
+  }
+
+  @Override
+  public String toString() {
+    return "slice start=" + start + " length=" + length + " readerIndex=" + readerIndex;
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReaderUtil.java b/lucene/core/src/java/org/apache/lucene/index/ReaderUtil.java
new file mode 100644
index 0000000..ae97143
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/ReaderUtil.java
@@ -0,0 +1,94 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+
+/**
+ * Common util methods for dealing with {@link IndexReader}s and {@link IndexReaderContext}s.
+ *
+ * @lucene.internal
+ */
+public final class ReaderUtil {
+
+  private ReaderUtil() {} // no instance
+
+  /**
+   * Walks up the reader tree and return the given context's top level reader
+   * context, or in other words the reader tree's root context.
+   */
+  public static IndexReaderContext getTopLevelContext(IndexReaderContext context) {
+    while (context.parent != null) {
+      context = context.parent;
+    }
+    return context;
+  }
+
+  /**
+   * Returns index of the searcher/reader for document <code>n</code> in the
+   * array used to construct this searcher/reader.
+   */
+  public static int subIndex(int n, int[] docStarts) { // find
+    // searcher/reader for doc n:
+    int size = docStarts.length;
+    int lo = 0; // search starts array
+    int hi = size - 1; // for first element less than n, return its index
+    while (hi >= lo) {
+      int mid = (lo + hi) >>> 1;
+      int midValue = docStarts[mid];
+      if (n < midValue)
+        hi = mid - 1;
+      else if (n > midValue)
+        lo = mid + 1;
+      else { // found a match
+        while (mid + 1 < size && docStarts[mid + 1] == midValue) {
+          mid++; // scan to last match
+        }
+        return mid;
+      }
+    }
+    return hi;
+  }
+  
+  /**
+   * Returns index of the searcher/reader for document <code>n</code> in the
+   * array used to construct this searcher/reader.
+   */
+  public static int subIndex(int n, List<AtomicReaderContext> leaves) { // find
+    // searcher/reader for doc n:
+    int size = leaves.size();
+    int lo = 0; // search starts array
+    int hi = size - 1; // for first element less than n, return its index
+    while (hi >= lo) {
+      int mid = (lo + hi) >>> 1;
+      int midValue = leaves.get(mid).docBase;
+      if (n < midValue)
+        hi = mid - 1;
+      else if (n > midValue)
+        lo = mid + 1;
+      else { // found a match
+        while (mid + 1 < size && leaves.get(mid + 1).docBase == midValue) {
+          mid++; // scan to last match
+        }
+        return mid;
+      }
+    }
+    return hi;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
index 1bf7197..8242bdd 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
@@ -32,6 +32,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.ChecksumIndexOutput;
@@ -41,7 +42,6 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.NoSuchDirectoryException;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.ThreadInterruptedException;
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java b/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
index 96ec622..fdc7d18 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
@@ -34,8 +34,6 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.lucene.util.ReaderSlice;
 
 /**
  * The SegmentMerger class combines two or more Segments, represented by an IndexReader ({@link #add},
diff --git a/lucene/core/src/java/org/apache/lucene/index/TermContext.java b/lucene/core/src/java/org/apache/lucene/index/TermContext.java
new file mode 100644
index 0000000..1cd67d3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/TermContext.java
@@ -0,0 +1,165 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Maintains a {@link IndexReader} {@link TermState} view over
+ * {@link IndexReader} instances containing a single term. The
+ * {@link TermContext} doesn't track if the given {@link TermState}
+ * objects are valid, neither if the {@link TermState} instances refer to the
+ * same terms in the associated readers.
+ * 
+ * @lucene.experimental
+ */
+public final class TermContext {
+  public final IndexReaderContext topReaderContext; // for asserting!
+  private final TermState[] states;
+  private int docFreq;
+  private long totalTermFreq;
+
+  //public static boolean DEBUG = BlockTreeTermsWriter.DEBUG;
+
+  /**
+   * Creates an empty {@link TermContext} from a {@link IndexReaderContext}
+   */
+  public TermContext(IndexReaderContext context) {
+    assert context != null && context.isTopLevel;
+    topReaderContext = context;
+    docFreq = 0;
+    final int len;
+    if (context.leaves() == null) {
+      len = 1;
+    } else {
+      len = context.leaves().size();
+    }
+    states = new TermState[len];
+  }
+  
+  /**
+   * Creates a {@link TermContext} with an initial {@link TermState},
+   * {@link IndexReader} pair.
+   */
+  public TermContext(IndexReaderContext context, TermState state, int ord, int docFreq, long totalTermFreq) {
+    this(context);
+    register(state, ord, docFreq, totalTermFreq);
+  }
+
+  /**
+   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the
+   * given {@link Term}. This method will lookup the given term in all context's leaf readers 
+   * and register each of the readers containing the term in the returned {@link TermContext}
+   * using the leaf reader's ordinal.
+   * <p>
+   * Note: the given context must be a top-level context.
+   */
+  public static TermContext build(IndexReaderContext context, Term term, boolean cache)
+      throws IOException {
+    assert context != null && context.isTopLevel;
+    final String field = term.field();
+    final BytesRef bytes = term.bytes();
+    final TermContext perReaderTermState = new TermContext(context);
+    //if (DEBUG) System.out.println("prts.build term=" + term);
+    for (final AtomicReaderContext ctx : context.leaves()) {
+      //if (DEBUG) System.out.println("  r=" + leaves[i].reader);
+      final Fields fields = ctx.reader().fields();
+      if (fields != null) {
+        final Terms terms = fields.terms(field);
+        if (terms != null) {
+          final TermsEnum termsEnum = terms.iterator(null);
+          if (termsEnum.seekExact(bytes, cache)) { 
+            final TermState termState = termsEnum.termState();
+            //if (DEBUG) System.out.println("    found");
+            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());
+          }
+        }
+      }
+    }
+    return perReaderTermState;
+  }
+
+  /**
+   * Clears the {@link TermContext} internal state and removes all
+   * registered {@link TermState}s
+   */
+  public void clear() {
+    docFreq = 0;
+    Arrays.fill(states, null);
+  }
+
+  /**
+   * Registers and associates a {@link TermState} with an leaf ordinal. The leaf ordinal
+   * should be derived from a {@link IndexReaderContext}'s leaf ord.
+   */
+  public void register(TermState state, final int ord, final int docFreq, final long totalTermFreq) {
+    assert state != null : "state must not be null";
+    assert ord >= 0 && ord < states.length;
+    assert states[ord] == null : "state for ord: " + ord
+        + " already registered";
+    this.docFreq += docFreq;
+    if (this.totalTermFreq >= 0 && totalTermFreq >= 0)
+      this.totalTermFreq += totalTermFreq;
+    else
+      this.totalTermFreq = -1;
+    states[ord] = state;
+  }
+
+  /**
+   * Returns the {@link TermState} for an leaf ordinal or <code>null</code> if no
+   * {@link TermState} for the ordinal was registered.
+   * 
+   * @param ord
+   *          the readers leaf ordinal to get the {@link TermState} for.
+   * @return the {@link TermState} for the given readers ord or <code>null</code> if no
+   *         {@link TermState} for the reader was registered
+   */
+  public TermState get(int ord) {
+    assert ord >= 0 && ord < states.length;
+    return states[ord];
+  }
+
+  /**
+   *  Returns the accumulated document frequency of all {@link TermState}
+   *         instances passed to {@link #register(TermState, int, int, long)}.
+   * @return the accumulated document frequency of all {@link TermState}
+   *         instances passed to {@link #register(TermState, int, int, long)}.
+   */
+  public int docFreq() {
+    return docFreq;
+  }
+  
+  /**
+   *  Returns the accumulated term frequency of all {@link TermState}
+   *         instances passed to {@link #register(TermState, int, int, long)}.
+   * @return the accumulated term frequency of all {@link TermState}
+   *         instances passed to {@link #register(TermState, int, int, long)}.
+   */
+  public long totalTermFreq() {
+    return totalTermFreq;
+  }
+  
+  /** expert: only available for queries that want to lie about docfreq
+   * @lucene.internal */
+  public void setDocFreq(int docFreq) {
+    this.docFreq = docFreq;
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommit.java b/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommit.java
new file mode 100644
index 0000000..165f093
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommit.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.index;
+
+import java.io.IOException;
+import java.util.Map;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * An interface for implementations that support 2-phase commit. You can use
+ * {@link TwoPhaseCommitTool} to execute a 2-phase commit algorithm over several
+ * {@link TwoPhaseCommit}s.
+ * 
+ * @lucene.experimental
+ */
+public interface TwoPhaseCommit {
+
+  /**
+   * The first stage of a 2-phase commit. Implementations should do as much work
+   * as possible in this method, but avoid actual committing changes. If the
+   * 2-phase commit fails, {@link #rollback()} is called to discard all changes
+   * since last successful commit.
+   */
+  public void prepareCommit() throws IOException;
+
+  /**
+   * Like {@link #commit()}, but takes an additional commit data to be included
+   * w/ the commit.
+   * <p>
+   * <b>NOTE:</b> some implementations may not support any custom data to be
+   * included w/ the commit and may discard it altogether. Consult the actual
+   * implementation documentation for verifying if this is supported.
+   * 
+   * @see #prepareCommit()
+   */
+  public void prepareCommit(Map<String, String> commitData) throws IOException;
+
+  /**
+   * The second phase of a 2-phase commit. Implementations should ideally do
+   * very little work in this method (following {@link #prepareCommit()}, and
+   * after it returns, the caller can assume that the changes were successfully
+   * committed to the underlying storage.
+   */
+  public void commit() throws IOException;
+
+  /**
+   * Like {@link #commit()}, but takes an additional commit data to be included
+   * w/ the commit.
+   * 
+   * @see #commit()
+   * @see #prepareCommit(Map)
+   */
+  public void commit(Map<String, String> commitData) throws IOException;
+
+  /**
+   * Discards any changes that have occurred since the last commit. In a 2-phase
+   * commit algorithm, where one of the objects failed to {@link #commit()} or
+   * {@link #prepareCommit()}, this method is used to roll all other objects
+   * back to their previous state.
+   */
+  public void rollback() throws IOException;
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommitTool.java b/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommitTool.java
new file mode 100644
index 0000000..10f7817
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/TwoPhaseCommitTool.java
@@ -0,0 +1,162 @@
+package org.apache.lucene.index;
+
+import java.io.IOException;
+import java.util.Map;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A utility for executing 2-phase commit on several objects.
+ * 
+ * @see TwoPhaseCommit
+ * @lucene.experimental
+ */
+public final class TwoPhaseCommitTool {
+
+  /**
+   * A wrapper of a {@link TwoPhaseCommit}, which delegates all calls to the
+   * wrapped object, passing the specified commitData. This object is useful for
+   * use with {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} if one would
+   * like to store commitData as part of the commit.
+   */
+  public static final class TwoPhaseCommitWrapper implements TwoPhaseCommit {
+
+    private final TwoPhaseCommit tpc;
+    private  final Map<String, String> commitData;
+
+    public TwoPhaseCommitWrapper(TwoPhaseCommit tpc, Map<String, String> commitData) {
+      this.tpc = tpc;
+      this.commitData = commitData;
+    }
+
+    public void prepareCommit() throws IOException {
+      prepareCommit(commitData);
+    }
+
+    public void prepareCommit(Map<String, String> commitData) throws IOException {
+      tpc.prepareCommit(this.commitData);
+    }
+
+    public void commit() throws IOException {
+      commit(commitData);
+    }
+
+    public void commit(Map<String, String> commitData) throws IOException {
+      tpc.commit(this.commitData);
+    }
+
+    public void rollback() throws IOException {
+      tpc.rollback();
+    }
+  }
+  
+  /**
+   * Thrown by {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} when an
+   * object fails to prepareCommit().
+   */
+  public static class PrepareCommitFailException extends IOException {
+    
+    public PrepareCommitFailException(Throwable cause, TwoPhaseCommit obj) {
+      super("prepareCommit() failed on " + obj);
+      initCause(cause);
+    }
+    
+  }
+
+  /**
+   * Thrown by {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} when an
+   * object fails to commit().
+   */
+  public static class CommitFailException extends IOException {
+    
+    public CommitFailException(Throwable cause, TwoPhaseCommit obj) {
+      super("commit() failed on " + obj);
+      initCause(cause);
+    }
+    
+  }
+
+  /** rollback all objects, discarding any exceptions that occur. */
+  private static void rollback(TwoPhaseCommit... objects) {
+    for (TwoPhaseCommit tpc : objects) {
+      // ignore any exception that occurs during rollback - we want to ensure
+      // all objects are rolled-back.
+      if (tpc != null) {
+        try {
+          tpc.rollback();
+        } catch (Throwable t) {}
+      }
+    }
+  }
+
+  /**
+   * Executes a 2-phase commit algorithm by first
+   * {@link TwoPhaseCommit#prepareCommit()} all objects and only if all succeed,
+   * it proceeds with {@link TwoPhaseCommit#commit()}. If any of the objects
+   * fail on either the preparation or actual commit, it terminates and
+   * {@link TwoPhaseCommit#rollback()} all of them.
+   * <p>
+   * <b>NOTE:</b> it may happen that an object fails to commit, after few have
+   * already successfully committed. This tool will still issue a rollback
+   * instruction on them as well, but depending on the implementation, it may
+   * not have any effect.
+   * <p>
+   * <b>NOTE:</b> if any of the objects are {@code null}, this method simply
+   * skips over them.
+   * 
+   * @throws PrepareCommitFailException
+   *           if any of the objects fail to
+   *           {@link TwoPhaseCommit#prepareCommit()}
+   * @throws CommitFailException
+   *           if any of the objects fail to {@link TwoPhaseCommit#commit()}
+   */
+  public static void execute(TwoPhaseCommit... objects)
+      throws PrepareCommitFailException, CommitFailException {
+    TwoPhaseCommit tpc = null;
+    try {
+      // first, all should successfully prepareCommit()
+      for (int i = 0; i < objects.length; i++) {
+        tpc = objects[i];
+        if (tpc != null) {
+          tpc.prepareCommit();
+        }
+      }
+    } catch (Throwable t) {
+      // first object that fails results in rollback all of them and
+      // throwing an exception.
+      rollback(objects);
+      throw new PrepareCommitFailException(t, tpc);
+    }
+    
+    // If all successfully prepareCommit(), attempt the actual commit()
+    try {
+      for (int i = 0; i < objects.length; i++) {
+        tpc = objects[i];
+        if (tpc != null) {
+          tpc.commit();
+        }
+      }
+    } catch (Throwable t) {
+      // first object that fails results in rollback all of them and
+      // throwing an exception.
+      rollback(objects);
+      throw new CommitFailException(t, tpc);
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreAutoRewrite.java b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreAutoRewrite.java
index 0c6fb99..ce3acc1 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreAutoRewrite.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreAutoRewrite.java
@@ -21,13 +21,13 @@ import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.ByteBlockPool;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefHash;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.BytesRefHash.DirectBytesStartArray;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
index c64c69e..ccca4ec 100644
--- a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -39,14 +39,14 @@ import org.apache.lucene.index.DirectoryReader; // javadocs
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.StoredFieldVisitor;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.NIOFSDirectory;    // javadoc
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ThreadInterruptedException;
 import org.apache.lucene.index.IndexWriter; // javadocs
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index 8364407..017c4f9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
@@ -35,7 +36,6 @@ import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.PriorityQueue;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
index f58bca4..e8c24bd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
@@ -23,10 +23,10 @@ import org.apache.lucene.index.FilteredTermsEnum; // javadocs
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.SingleTermsEnum;   // javadocs
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.TermContext;
 
 /**
  * An abstract {@link Query} that matches documents
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 148b430..68b5d69 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -28,6 +28,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
@@ -36,7 +37,6 @@ import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 /** A Query that matches documents containing a particular sequence of terms.
diff --git a/lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java b/lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java
index ec36777..dba6be2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ScoringRewrite.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search;
 import java.io.IOException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
@@ -28,7 +29,6 @@ import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.ByteBlockPool;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefHash;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.BytesRefHash.DirectBytesStartArray;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java b/lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java
index 3f5a6a3..a237d07 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermCollectingRewrite.java
@@ -25,11 +25,11 @@ import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.TermContext;
 
 abstract class TermCollectingRewrite<Q extends Query> extends MultiTermQuery.RewriteMethod {
   
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
index aed755d..7d781f2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
@@ -24,15 +24,15 @@ import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.similarities.Similarity.ExactSimScorer;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 /** A Query that matches documents containing a term.
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java b/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
index 6f93d12..38ae617 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopTermsRewrite.java
@@ -25,11 +25,11 @@ import java.util.Comparator;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.TermContext;
 
 /**
  * Base rewrite method for collecting only the top terms
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
index 0748836..6bae19b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
@@ -30,6 +30,7 @@ import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
@@ -43,7 +44,6 @@ import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.util.TermContext;
 
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
index b3e47a9..5f99458 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
@@ -24,11 +24,11 @@ import java.util.Set;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index 7f57f4f..a27c0cc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -19,9 +19,9 @@ package org.apache.lucene.search.spans;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index 4092e2a..d19663e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -19,9 +19,9 @@ package org.apache.lucene.search.spans;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.PriorityQueue;
-import org.apache.lucene.util.TermContext;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
index 500557f..22bf5a2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
@@ -23,13 +23,13 @@ import java.util.Map;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TopTermsRewrite;
 import org.apache.lucene.search.ScoringRewrite;
 import org.apache.lucene.search.BooleanClause.Occur; // javadocs only
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 /**
  * Wraps any {@link MultiTermQuery} as a {@link SpanQuery}, 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
index 9154a68..68aff02 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
@@ -30,9 +30,9 @@ import java.util.Set;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans which are near one another.  One can specify <i>slop</i>, the
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
index 1f84883..0258d13 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
@@ -20,9 +20,9 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 4e52a70..3f00fc5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -29,9 +29,9 @@ import java.util.Set;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.PriorityQueue;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.search.Query;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
index 67c9261..052f5a6 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
@@ -20,9 +20,9 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 import java.io.IOException;
 import java.util.ArrayList;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
index 3571daf..3767279 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
@@ -22,11 +22,11 @@ import java.util.Map;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 /** Base class for span-based queries. */
 public abstract class SpanQuery extends Query {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
index a113d16..86e0d35 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
@@ -21,11 +21,11 @@ import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.DocsAndPositionsEnum;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
index 5e98aee..7292e90 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
@@ -20,11 +20,11 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SloppySimScorer;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 import java.io.IOException;
 import java.util.HashMap;
diff --git a/lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory.java b/lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory.java
index 6e22475..5aa6b2e 100644
--- a/lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory.java
+++ b/lucene/core/src/java/org/apache/lucene/store/CompoundFileDirectory.java
@@ -18,11 +18,11 @@ package org.apache.lucene.store;
  */
 
 import org.apache.lucene.codecs.Codec; // javadocs
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.LiveDocsFormat; // javadocs
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.IndexFormatTooOldException;
 import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.util.CodecUtil; // javadocs
 import org.apache.lucene.util.IOUtils;
 
 import java.util.Collection;
diff --git a/lucene/core/src/java/org/apache/lucene/store/CompoundFileWriter.java b/lucene/core/src/java/org/apache/lucene/store/CompoundFileWriter.java
index 7b04d65..72623a2 100644
--- a/lucene/core/src/java/org/apache/lucene/store/CompoundFileWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/store/CompoundFileWriter.java
@@ -29,9 +29,9 @@ import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.MergePolicy.MergeAbortedException;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /**
diff --git a/lucene/core/src/java/org/apache/lucene/util/BitsSlice.java b/lucene/core/src/java/org/apache/lucene/util/BitsSlice.java
deleted file mode 100644
index b294ede..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/BitsSlice.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Exposes a slice of an existing Bits as a new Bits. */
-
-public final class BitsSlice implements Bits {
-  private final Bits parent;
-  private final int start;
-  private final int length;
-
-  // start is inclusive; end is exclusive (length = end-start)
-  public BitsSlice(Bits parent, ReaderSlice slice) {
-    this.parent = parent;
-    this.start = slice.start;
-    this.length = slice.length;
-    assert length >= 0: "length=" + length;
-  }
-    
-  public boolean get(int doc) {
-    if (doc >= length) {
-      throw new RuntimeException("doc " + doc + " is out of bounds 0 .. " + (length-1));
-    }
-    assert doc < length: "doc=" + doc + " length=" + length;
-    return parent.get(doc+start);
-  }
-
-  public int length() {
-    return length;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java b/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java
deleted file mode 100644
index 9bfc7eb..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java
+++ /dev/null
@@ -1,152 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.io.IOException;
-
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexFormatTooNewException;
-import org.apache.lucene.index.IndexFormatTooOldException;
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.store.DataOutput;
-
-/**
- * Utility class for reading and writing versioned headers.
- * <p>
- * Writing codec headers is useful to ensure that a file is in 
- * the format you think it is.
- * 
- * @lucene.experimental
- */
-
-public final class CodecUtil {
-  private CodecUtil() {} // no instance
-
-  /**
-   * Constant to identify the start of a codec header.
-   */
-  public final static int CODEC_MAGIC = 0x3fd76c17;
-
-  /**
-   * Writes a codec header, which records both a string to
-   * identify the file and a version number. This header can
-   * be parsed and validated with 
-   * {@link #checkHeader(DataInput, String, int, int) checkHeader()}.
-   * <p>
-   * CodecHeader --&gt; Magic,CodecName,Version
-   * <ul>
-   *    <li>Magic --&gt; {@link DataOutput#writeInt Uint32}. This
-   *        identifies the start of the header. It is always {@value #CODEC_MAGIC}.
-   *    <li>CodecName --&gt; {@link DataOutput#writeString String}. This
-   *        is a string to identify this file.
-   *    <li>Version --&gt; {@link DataOutput#writeInt Uint32}. Records
-   *        the version of the file.
-   * </ul>
-   * <p>
-   * Note that the length of a codec header depends only upon the
-   * name of the codec, so this length can be computed at any time
-   * with {@link #headerLength(String)}.
-   * 
-   * @param out Output stream
-   * @param codec String to identify this file. It should be simple ASCII, 
-   *              less than 128 characters in length.
-   * @param version Version number
-   * @throws IOException If there is an I/O error writing to the underlying medium.
-   */
-  public static void writeHeader(DataOutput out, String codec, int version)
-    throws IOException {
-    BytesRef bytes = new BytesRef(codec);
-    if (bytes.length != codec.length() || bytes.length >= 128) {
-      throw new IllegalArgumentException("codec must be simple ASCII, less than 128 characters in length [got " + codec + "]");
-    }
-    out.writeInt(CODEC_MAGIC);
-    out.writeString(codec);
-    out.writeInt(version);
-  }
-
-  /**
-   * Computes the length of a codec header.
-   * 
-   * @param codec Codec name.
-   * @return length of the entire codec header.
-   * @see #writeHeader(DataOutput, String, int)
-   */
-  public static int headerLength(String codec) {
-    return 9+codec.length();
-  }
-
-  /**
-   * Reads and validates a header previously written with 
-   * {@link #writeHeader(DataOutput, String, int)}.
-   * <p>
-   * When reading a file, supply the expected <code>codec</code> and
-   * an expected version range (<code>minVersion to maxVersion</code>).
-   * 
-   * @param in Input stream, positioned at the point where the
-   *        header was previously written. Typically this is located
-   *        at the beginning of the file.
-   * @param codec The expected codec name.
-   * @param minVersion The minimum supported expected version number.
-   * @param maxVersion The maximum supported expected version number.
-   * @return The actual version found, when a valid header is found 
-   *         that matches <code>codec</code>, with an actual version 
-   *         where <code>minVersion <= actual <= maxVersion</code>.
-   *         Otherwise an exception is thrown.
-   * @throws CorruptIndexException If the first four bytes are not
-   *         {@link #CODEC_MAGIC}, or if the actual codec found is
-   *         not <code>codec</code>.
-   * @throws IndexFormatTooOldException If the actual version is less 
-   *         than <code>minVersion</code>.
-   * @throws IndexFormatTooNewException If the actual version is greater 
-   *         than <code>maxVersion</code>.
-   * @throws IOException If there is an I/O error reading from the underlying medium.
-   * @see #writeHeader(DataOutput, String, int)
-   */
-  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)
-    throws IOException {
-
-    // Safety to guard against reading a bogus string:
-    final int actualHeader = in.readInt();
-    if (actualHeader != CODEC_MAGIC) {
-      throw new CorruptIndexException("codec header mismatch: actual header=" + actualHeader + " vs expected header=" + CODEC_MAGIC + " (resource: " + in + ")");
-    }
-    return checkHeaderNoMagic(in, codec, minVersion, maxVersion);
-  }
-
-  /** Like {@link
-   *  #checkHeader(DataInput,String,int,int)} except this
-   *  version assumes the first int has already been read
-   *  and validated from the input. */
-  public static int checkHeaderNoMagic(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {
-    final String actualCodec = in.readString();
-    if (!actualCodec.equals(codec)) {
-      throw new CorruptIndexException("codec mismatch: actual codec=" + actualCodec + " vs expected codec=" + codec + " (resource: " + in + ")");
-    }
-
-    final int actualVersion = in.readInt();
-    if (actualVersion < minVersion) {
-      throw new IndexFormatTooOldException(in, actualVersion, minVersion, maxVersion);
-    }
-    if (actualVersion > maxVersion) {
-      throw new IndexFormatTooNewException(in, actualVersion, minVersion, maxVersion);
-    }
-
-    return actualVersion;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/DummyConcurrentLock.java b/lucene/core/src/java/org/apache/lucene/util/DummyConcurrentLock.java
deleted file mode 100644
index 29a67b8..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/DummyConcurrentLock.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.Condition;
-import java.util.concurrent.locks.ReentrantLock;
-
-/**
- * A dummy lock as a replacement for {@link ReentrantLock} to disable locking
- * @lucene.internal
- */
-public final class DummyConcurrentLock implements Lock {
-
-  /** a default instance, can be always used, as this {@link Lock} is stateless. */
-  public static final DummyConcurrentLock INSTANCE = new DummyConcurrentLock();
-
-  public void lock() {}
-  
-  public void lockInterruptibly() {}
-  
-  public boolean tryLock() {
-    return true;
-  }
-  
-  public boolean tryLock(long time, TimeUnit unit) {
-    return true;
-  }
-  
-  public void unlock() {}
-  
-  public Condition newCondition() {
-    throw new UnsupportedOperationException();
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/MultiBits.java b/lucene/core/src/java/org/apache/lucene/util/MultiBits.java
deleted file mode 100644
index 4fa6efa..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/MultiBits.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Concatenates multiple Bits together, on every lookup.
- *
- * <p><b>NOTE</b>: This is very costly, as every lookup must
- * do a binary search to locate the right sub-reader.
- *
- * @lucene.experimental
- */
-
-public final class MultiBits implements Bits {
-  private final Bits[] subs;
-
-  // length is 1+subs.length (the last entry has the maxDoc):
-  private final int[] starts;
-
-  private final boolean defaultValue;
-
-  public MultiBits(Bits[] subs, int[] starts, boolean defaultValue) {
-    assert starts.length == 1+subs.length;
-    this.subs = subs;
-    this.starts = starts;
-    this.defaultValue = defaultValue;
-  }
-
-  private boolean checkLength(int reader, int doc) {
-    final int length = starts[1+reader]-starts[reader];
-    assert doc - starts[reader] < length: "doc=" + doc + " reader=" + reader + " starts[reader]=" + starts[reader] + " length=" + length;
-    return true;
-  }
-
-  public boolean get(int doc) {
-    final int reader = ReaderUtil.subIndex(doc, starts);
-    assert reader != -1;
-    final Bits bits = subs[reader];
-    if (bits == null) {
-      return defaultValue;
-    } else {
-      assert checkLength(reader, doc);
-      return bits.get(doc-starts[reader]);
-    }
-  }
-  
-  @Override
-  public String toString() {
-    StringBuilder b = new StringBuilder();
-    b.append(subs.length + " subs: ");
-    for(int i=0;i<subs.length;i++) {
-      if (i != 0) {
-        b.append("; ");
-      }
-      if (subs[i] == null) {
-        b.append("s=" + starts[i] + " l=null");
-      } else {
-        b.append("s=" + starts[i] + " l=" + subs[i].length() + " b=" + subs[i]);
-      }
-    }
-    b.append(" end=" + starts[subs.length]);
-    return b.toString();
-  }
-
-  /**
-   * Represents a sub-Bits from 
-   * {@link MultiBits#getMatchingSub(org.apache.lucene.util.ReaderSlice) getMatchingSub()}.
-   */
-  public final static class SubResult {
-    public boolean matches;
-    public Bits result;
-  }
-
-  /**
-   * Returns a sub-Bits matching the provided <code>slice</code>
-   * <p>
-   * Because <code>null</code> usually has a special meaning for
-   * Bits (e.g. no deleted documents), you must check
-   * {@link SubResult#matches} instead to ensure the sub was 
-   * actually found.
-   */
-  public SubResult getMatchingSub(ReaderSlice slice) {
-    int reader = ReaderUtil.subIndex(slice.start, starts);
-    assert reader != -1;
-    assert reader < subs.length: "slice=" + slice + " starts[-1]=" + starts[starts.length-1];
-    final SubResult subResult = new SubResult();
-    if (starts[reader] == slice.start && starts[1+reader] == slice.start+slice.length) {
-      subResult.matches = true;
-      subResult.result = subs[reader];
-    } else {
-      subResult.matches = false;
-    }
-    return subResult;
-  }
-
-  public int length() {
-    return starts[starts.length-1];
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/ReaderSlice.java b/lucene/core/src/java/org/apache/lucene/util/ReaderSlice.java
deleted file mode 100644
index b0e5cf4..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/ReaderSlice.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Subreader slice from a parent composite reader.
- */
-public final class ReaderSlice {
-  public static final ReaderSlice[] EMPTY_ARRAY = new ReaderSlice[0];
-  public final int start;
-  public final int length;
-  public final int readerIndex;
-
-  public ReaderSlice(int start, int length, int readerIndex) {
-    this.start = start;
-    this.length = length;
-    this.readerIndex = readerIndex;
-  }
-
-  @Override
-  public String toString() {
-    return "slice start=" + start + " length=" + length + " readerIndex=" + readerIndex;
-  }
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/util/ReaderUtil.java b/lucene/core/src/java/org/apache/lucene/util/ReaderUtil.java
deleted file mode 100644
index d154627..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/ReaderUtil.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
-
-/**
- * Common util methods for dealing with {@link IndexReader}s.
- *
- * @lucene.internal
- */
-public final class ReaderUtil {
-
-  private ReaderUtil() {} // no instance
-
-  /**
-   * Walks up the reader tree and return the given context's top level reader
-   * context, or in other words the reader tree's root context.
-   */
-  public static IndexReaderContext getTopLevelContext(IndexReaderContext context) {
-    while (context.parent != null) {
-      context = context.parent;
-    }
-    return context;
-  }
-
-  /**
-   * Returns index of the searcher/reader for document <code>n</code> in the
-   * array used to construct this searcher/reader.
-   */
-  public static int subIndex(int n, int[] docStarts) { // find
-    // searcher/reader for doc n:
-    int size = docStarts.length;
-    int lo = 0; // search starts array
-    int hi = size - 1; // for first element less than n, return its index
-    while (hi >= lo) {
-      int mid = (lo + hi) >>> 1;
-      int midValue = docStarts[mid];
-      if (n < midValue)
-        hi = mid - 1;
-      else if (n > midValue)
-        lo = mid + 1;
-      else { // found a match
-        while (mid + 1 < size && docStarts[mid + 1] == midValue) {
-          mid++; // scan to last match
-        }
-        return mid;
-      }
-    }
-    return hi;
-  }
-  
-  /**
-   * Returns index of the searcher/reader for document <code>n</code> in the
-   * array used to construct this searcher/reader.
-   */
-  public static int subIndex(int n, List<AtomicReaderContext> leaves) { // find
-    // searcher/reader for doc n:
-    int size = leaves.size();
-    int lo = 0; // search starts array
-    int hi = size - 1; // for first element less than n, return its index
-    while (hi >= lo) {
-      int mid = (lo + hi) >>> 1;
-      int midValue = leaves.get(mid).docBase;
-      if (n < midValue)
-        hi = mid - 1;
-      else if (n > midValue)
-        lo = mid + 1;
-      else { // found a match
-        while (mid + 1 < size && leaves.get(mid + 1).docBase == midValue) {
-          mid++; // scan to last match
-        }
-        return mid;
-      }
-    }
-    return hi;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/TermContext.java b/lucene/core/src/java/org/apache/lucene/util/TermContext.java
deleted file mode 100644
index d4d570f..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/TermContext.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.Fields;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermState;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-
-/**
- * Maintains a {@link IndexReader} {@link TermState} view over
- * {@link IndexReader} instances containing a single term. The
- * {@link TermContext} doesn't track if the given {@link TermState}
- * objects are valid, neither if the {@link TermState} instances refer to the
- * same terms in the associated readers.
- * 
- * @lucene.experimental
- */
-public final class TermContext {
-  public final IndexReaderContext topReaderContext; // for asserting!
-  private final TermState[] states;
-  private int docFreq;
-  private long totalTermFreq;
-
-  //public static boolean DEBUG = BlockTreeTermsWriter.DEBUG;
-
-  /**
-   * Creates an empty {@link TermContext} from a {@link IndexReaderContext}
-   */
-  public TermContext(IndexReaderContext context) {
-    assert context != null && context.isTopLevel;
-    topReaderContext = context;
-    docFreq = 0;
-    final int len;
-    if (context.leaves() == null) {
-      len = 1;
-    } else {
-      len = context.leaves().size();
-    }
-    states = new TermState[len];
-  }
-  
-  /**
-   * Creates a {@link TermContext} with an initial {@link TermState},
-   * {@link IndexReader} pair.
-   */
-  public TermContext(IndexReaderContext context, TermState state, int ord, int docFreq, long totalTermFreq) {
-    this(context);
-    register(state, ord, docFreq, totalTermFreq);
-  }
-
-  /**
-   * Creates a {@link TermContext} from a top-level {@link IndexReaderContext} and the
-   * given {@link Term}. This method will lookup the given term in all context's leaf readers 
-   * and register each of the readers containing the term in the returned {@link TermContext}
-   * using the leaf reader's ordinal.
-   * <p>
-   * Note: the given context must be a top-level context.
-   */
-  public static TermContext build(IndexReaderContext context, Term term, boolean cache)
-      throws IOException {
-    assert context != null && context.isTopLevel;
-    final String field = term.field();
-    final BytesRef bytes = term.bytes();
-    final TermContext perReaderTermState = new TermContext(context);
-    //if (DEBUG) System.out.println("prts.build term=" + term);
-    for (final AtomicReaderContext ctx : context.leaves()) {
-      //if (DEBUG) System.out.println("  r=" + leaves[i].reader);
-      final Fields fields = ctx.reader().fields();
-      if (fields != null) {
-        final Terms terms = fields.terms(field);
-        if (terms != null) {
-          final TermsEnum termsEnum = terms.iterator(null);
-          if (termsEnum.seekExact(bytes, cache)) { 
-            final TermState termState = termsEnum.termState();
-            //if (DEBUG) System.out.println("    found");
-            perReaderTermState.register(termState, ctx.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());
-          }
-        }
-      }
-    }
-    return perReaderTermState;
-  }
-
-  /**
-   * Clears the {@link TermContext} internal state and removes all
-   * registered {@link TermState}s
-   */
-  public void clear() {
-    docFreq = 0;
-    Arrays.fill(states, null);
-  }
-
-  /**
-   * Registers and associates a {@link TermState} with an leaf ordinal. The leaf ordinal
-   * should be derived from a {@link IndexReaderContext}'s leaf ord.
-   */
-  public void register(TermState state, final int ord, final int docFreq, final long totalTermFreq) {
-    assert state != null : "state must not be null";
-    assert ord >= 0 && ord < states.length;
-    assert states[ord] == null : "state for ord: " + ord
-        + " already registered";
-    this.docFreq += docFreq;
-    if (this.totalTermFreq >= 0 && totalTermFreq >= 0)
-      this.totalTermFreq += totalTermFreq;
-    else
-      this.totalTermFreq = -1;
-    states[ord] = state;
-  }
-
-  /**
-   * Returns the {@link TermState} for an leaf ordinal or <code>null</code> if no
-   * {@link TermState} for the ordinal was registered.
-   * 
-   * @param ord
-   *          the readers leaf ordinal to get the {@link TermState} for.
-   * @return the {@link TermState} for the given readers ord or <code>null</code> if no
-   *         {@link TermState} for the reader was registered
-   */
-  public TermState get(int ord) {
-    assert ord >= 0 && ord < states.length;
-    return states[ord];
-  }
-
-  /**
-   *  Returns the accumulated document frequency of all {@link TermState}
-   *         instances passed to {@link #register(TermState, int, int, long)}.
-   * @return the accumulated document frequency of all {@link TermState}
-   *         instances passed to {@link #register(TermState, int, int, long)}.
-   */
-  public int docFreq() {
-    return docFreq;
-  }
-  
-  /**
-   *  Returns the accumulated term frequency of all {@link TermState}
-   *         instances passed to {@link #register(TermState, int, int, long)}.
-   * @return the accumulated term frequency of all {@link TermState}
-   *         instances passed to {@link #register(TermState, int, int, long)}.
-   */
-  public long totalTermFreq() {
-    return totalTermFreq;
-  }
-  
-  /** expert: only available for queries that want to lie about docfreq
-   * @lucene.internal */
-  public void setDocFreq(int docFreq) {
-    this.docFreq = docFreq;
-  }
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommit.java b/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommit.java
deleted file mode 100644
index 688d1d8..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommit.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.apache.lucene.util;
-
-import java.io.IOException;
-import java.util.Map;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * An interface for implementations that support 2-phase commit. You can use
- * {@link TwoPhaseCommitTool} to execute a 2-phase commit algorithm over several
- * {@link TwoPhaseCommit}s.
- * 
- * @lucene.experimental
- */
-public interface TwoPhaseCommit {
-
-  /**
-   * The first stage of a 2-phase commit. Implementations should do as much work
-   * as possible in this method, but avoid actual committing changes. If the
-   * 2-phase commit fails, {@link #rollback()} is called to discard all changes
-   * since last successful commit.
-   */
-  public void prepareCommit() throws IOException;
-
-  /**
-   * Like {@link #commit()}, but takes an additional commit data to be included
-   * w/ the commit.
-   * <p>
-   * <b>NOTE:</b> some implementations may not support any custom data to be
-   * included w/ the commit and may discard it altogether. Consult the actual
-   * implementation documentation for verifying if this is supported.
-   * 
-   * @see #prepareCommit()
-   */
-  public void prepareCommit(Map<String, String> commitData) throws IOException;
-
-  /**
-   * The second phase of a 2-phase commit. Implementations should ideally do
-   * very little work in this method (following {@link #prepareCommit()}, and
-   * after it returns, the caller can assume that the changes were successfully
-   * committed to the underlying storage.
-   */
-  public void commit() throws IOException;
-
-  /**
-   * Like {@link #commit()}, but takes an additional commit data to be included
-   * w/ the commit.
-   * 
-   * @see #commit()
-   * @see #prepareCommit(Map)
-   */
-  public void commit(Map<String, String> commitData) throws IOException;
-
-  /**
-   * Discards any changes that have occurred since the last commit. In a 2-phase
-   * commit algorithm, where one of the objects failed to {@link #commit()} or
-   * {@link #prepareCommit()}, this method is used to roll all other objects
-   * back to their previous state.
-   */
-  public void rollback() throws IOException;
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommitTool.java b/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommitTool.java
deleted file mode 100644
index 7cc48ba..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/TwoPhaseCommitTool.java
+++ /dev/null
@@ -1,162 +0,0 @@
-package org.apache.lucene.util;
-
-import java.io.IOException;
-import java.util.Map;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * A utility for executing 2-phase commit on several objects.
- * 
- * @see TwoPhaseCommit
- * @lucene.experimental
- */
-public final class TwoPhaseCommitTool {
-
-  /**
-   * A wrapper of a {@link TwoPhaseCommit}, which delegates all calls to the
-   * wrapped object, passing the specified commitData. This object is useful for
-   * use with {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} if one would
-   * like to store commitData as part of the commit.
-   */
-  public static final class TwoPhaseCommitWrapper implements TwoPhaseCommit {
-
-    private final TwoPhaseCommit tpc;
-    private  final Map<String, String> commitData;
-
-    public TwoPhaseCommitWrapper(TwoPhaseCommit tpc, Map<String, String> commitData) {
-      this.tpc = tpc;
-      this.commitData = commitData;
-    }
-
-    public void prepareCommit() throws IOException {
-      prepareCommit(commitData);
-    }
-
-    public void prepareCommit(Map<String, String> commitData) throws IOException {
-      tpc.prepareCommit(this.commitData);
-    }
-
-    public void commit() throws IOException {
-      commit(commitData);
-    }
-
-    public void commit(Map<String, String> commitData) throws IOException {
-      tpc.commit(this.commitData);
-    }
-
-    public void rollback() throws IOException {
-      tpc.rollback();
-    }
-  }
-  
-  /**
-   * Thrown by {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} when an
-   * object fails to prepareCommit().
-   */
-  public static class PrepareCommitFailException extends IOException {
-    
-    public PrepareCommitFailException(Throwable cause, TwoPhaseCommit obj) {
-      super("prepareCommit() failed on " + obj);
-      initCause(cause);
-    }
-    
-  }
-
-  /**
-   * Thrown by {@link TwoPhaseCommitTool#execute(TwoPhaseCommit...)} when an
-   * object fails to commit().
-   */
-  public static class CommitFailException extends IOException {
-    
-    public CommitFailException(Throwable cause, TwoPhaseCommit obj) {
-      super("commit() failed on " + obj);
-      initCause(cause);
-    }
-    
-  }
-
-  /** rollback all objects, discarding any exceptions that occur. */
-  private static void rollback(TwoPhaseCommit... objects) {
-    for (TwoPhaseCommit tpc : objects) {
-      // ignore any exception that occurs during rollback - we want to ensure
-      // all objects are rolled-back.
-      if (tpc != null) {
-        try {
-          tpc.rollback();
-        } catch (Throwable t) {}
-      }
-    }
-  }
-
-  /**
-   * Executes a 2-phase commit algorithm by first
-   * {@link TwoPhaseCommit#prepareCommit()} all objects and only if all succeed,
-   * it proceeds with {@link TwoPhaseCommit#commit()}. If any of the objects
-   * fail on either the preparation or actual commit, it terminates and
-   * {@link TwoPhaseCommit#rollback()} all of them.
-   * <p>
-   * <b>NOTE:</b> it may happen that an object fails to commit, after few have
-   * already successfully committed. This tool will still issue a rollback
-   * instruction on them as well, but depending on the implementation, it may
-   * not have any effect.
-   * <p>
-   * <b>NOTE:</b> if any of the objects are {@code null}, this method simply
-   * skips over them.
-   * 
-   * @throws PrepareCommitFailException
-   *           if any of the objects fail to
-   *           {@link TwoPhaseCommit#prepareCommit()}
-   * @throws CommitFailException
-   *           if any of the objects fail to {@link TwoPhaseCommit#commit()}
-   */
-  public static void execute(TwoPhaseCommit... objects)
-      throws PrepareCommitFailException, CommitFailException {
-    TwoPhaseCommit tpc = null;
-    try {
-      // first, all should successfully prepareCommit()
-      for (int i = 0; i < objects.length; i++) {
-        tpc = objects[i];
-        if (tpc != null) {
-          tpc.prepareCommit();
-        }
-      }
-    } catch (Throwable t) {
-      // first object that fails results in rollback all of them and
-      // throwing an exception.
-      rollback(objects);
-      throw new PrepareCommitFailException(t, tpc);
-    }
-    
-    // If all successfully prepareCommit(), attempt the actual commit()
-    try {
-      for (int i = 0; i < objects.length; i++) {
-        tpc = objects[i];
-        if (tpc != null) {
-          tpc.commit();
-        }
-      }
-    } catch (Throwable t) {
-      // first object that fails results in rollback all of them and
-      // throwing an exception.
-      rollback(objects);
-      throw new CommitFailException(t, tpc);
-    }
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/fst/FST.java b/lucene/core/src/java/org/apache/lucene/util/fst/FST.java
index e43b795..259eb4f 100644
--- a/lucene/core/src/java/org/apache/lucene/util/fst/FST.java
+++ b/lucene/core/src/java/org/apache/lucene/util/fst/FST.java
@@ -28,12 +28,12 @@ import java.io.OutputStream;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
 import org.apache.lucene.store.InputStreamDataInput;
 import org.apache.lucene.store.OutputStreamDataOutput;
 import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.PriorityQueue;
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
index f993a9b..dcd39ea 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
@@ -19,10 +19,10 @@ package org.apache.lucene.util.packed;
 
 import java.io.Closeable;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 
 import java.io.IOException;
 
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestAllFilesHaveCodecHeader.java b/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestAllFilesHaveCodecHeader.java
index b87bdde..d6535df 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestAllFilesHaveCodecHeader.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestAllFilesHaveCodecHeader.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexFileNames;
@@ -29,7 +30,6 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.CompoundFileDirectory;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
index d706254..4c49c3d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
@@ -31,10 +31,10 @@ import org.apache.lucene.index.CompositeReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util._TestUtil;
 
 public class TestTopDocsMerge extends LuceneTestCase {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
index 7b66808..88448f9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
@@ -23,10 +23,10 @@ import java.util.Map;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 /**
  * Holds all implementations of classes in the o.a.l.s.spans package as a
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java b/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
index 23c8701..1db7b02 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
@@ -27,10 +27,10 @@ import java.util.TreeSet;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.ReaderUtil;
-import org.apache.lucene.util.TermContext;
 
 /**
  * 
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 0c1e892..61495de 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -30,6 +30,7 @@ import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -41,7 +42,6 @@ import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.ReaderUtil;
 
 public class TestSpans extends LuceneTestCase {
   private IndexSearcher searcher;
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestTwoPhaseCommitTool.java b/lucene/core/src/test/org/apache/lucene/util/TestTwoPhaseCommitTool.java
index 0784489..b0df628 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestTwoPhaseCommitTool.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestTwoPhaseCommitTool.java
@@ -21,7 +21,9 @@ import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.lucene.util.TwoPhaseCommitTool.TwoPhaseCommitWrapper;
+import org.apache.lucene.index.TwoPhaseCommit;
+import org.apache.lucene.index.TwoPhaseCommitTool;
+import org.apache.lucene.index.TwoPhaseCommitTool.TwoPhaseCommitWrapper;
 
 public class TestTwoPhaseCommitTool extends LuceneTestCase {
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
index 5a922a2..5964a77 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.taxonomy;
 import java.io.Closeable;
 import java.io.IOException;
 
-import org.apache.lucene.util.TwoPhaseCommit;
+import org.apache.lucene.index.TwoPhaseCommit;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index 808022c..9a41ff3 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -23,6 +23,7 @@ import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.CompositeReaderContext;
 import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.IndexReaderContext;
@@ -44,7 +45,6 @@ import org.apache.lucene.search.grouping.term.TermSecondPassGroupingCollector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util._TestUtil;
 import org.apache.lucene.util.mutable.MutableValue;
 import org.apache.lucene.util.mutable.MutableValueStr;
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
index a2a1864..161225b 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
@@ -32,6 +32,7 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.memory.MemoryIndex;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.spans.FieldMaskingSpanQuery;
@@ -43,7 +44,6 @@ import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.TermContext;
 
 /**
  * Class used to extract {@link WeightedSpanTerm}s from a {@link Query} based on whether 
diff --git a/lucene/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java b/lucene/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java
index 52e2bb9..7073fee 100644
--- a/lucene/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java
+++ b/lucene/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java
@@ -23,6 +23,7 @@ import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.Fields;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.FieldsEnum;
 import org.apache.lucene.index.Terms;
@@ -32,7 +33,6 @@ import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.ReaderUtil;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java
index d1fe939..1d8a8b1 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/JoinDocFreqValueSource.java
@@ -22,11 +22,11 @@ import java.util.Map;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.docvalues.IntDocValues;
 import org.apache.lucene.search.FieldCache.DocTerms;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.packed.PackedInts;
 
 /**
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java
index 274de29..5c60b5e 100755
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/NumDocsValueSource.java
@@ -17,9 +17,9 @@
 package org.apache.lucene.queries.function.valuesource;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.ReaderUtil;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
index 2f46eeb..04d5d0a 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
@@ -21,12 +21,12 @@ import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.CompositeReader;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.IntDocValues;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.mutable.MutableValue;
 import org.apache.lucene.util.mutable.MutableValueInt;
 
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java
index df47056..3e22e8e 100755
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/QueryValueSource.java
@@ -18,12 +18,12 @@
 package org.apache.lucene.queries.function.valuesource;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.FloatDocValues;
 import org.apache.lucene.search.*;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.mutable.MutableValue;
 import org.apache.lucene.util.mutable.MutableValueFloat;
 
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
index 5accef9..708c2b7 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
@@ -21,12 +21,12 @@ import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.CompositeReader;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.IntDocValues;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.util.ReaderUtil;
 
 import java.io.IOException;
 import java.util.Map;
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java
index c09814e..3b247a3 100755
--- a/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/ScaleFloatFunction.java
@@ -18,11 +18,11 @@
 package org.apache.lucene.queries.function.valuesource;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.FloatDocValues;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.ReaderUtil;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java b/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
index 5d6b0f6..52139b1 100755
--- a/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
@@ -33,6 +33,7 @@ import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.Terms;
@@ -47,7 +48,6 @@ import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefIterator;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.Version;
 
 /**
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java
index 91585bf..924ba17 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexInput.java
@@ -19,12 +19,12 @@ package org.apache.lucene.codecs.mocksep;
 
 import java.io.IOException;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.sep.IntIndexInput;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.CodecUtil;
 
 /** Reads IndexInputs written with {@link
  *  MockSingleIntIndexOutput}.  NOTE: this class is just for
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java
index 1024c6c..a7fad99 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/mocksep/MockSingleIntIndexOutput.java
@@ -20,8 +20,8 @@ package org.apache.lucene.codecs.mocksep;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.sep.IntIndexOutput;
 
 import java.io.IOException;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java
index 7ff4565..cbe9c65 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/ramonly/RAMOnlyPostingsFormat.java
@@ -28,6 +28,7 @@ import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.FieldsConsumer;
 import org.apache.lucene.codecs.FieldsProducer;
 import org.apache.lucene.codecs.PostingsConsumer;
@@ -48,7 +49,6 @@ import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.CodecUtil;
 import org.apache.lucene.util.IOUtils;
 
 /** Stores all postings data in RAM, but writes a small
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java b/lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java
index ee0f240..004b379 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/ShardSearchingTestBase.java
@@ -31,11 +31,11 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LineFileDocs;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TermContext;
 
 // TODO
 //   - doc blocks?  so we can test joins/grouping...
diff --git a/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java b/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
index dc3452b..c8cd3cc 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
@@ -21,6 +21,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.ParseException;
 import org.apache.lucene.search.*;
@@ -29,7 +30,6 @@ import org.apache.lucene.search.grouping.SearchGroup;
 import org.apache.lucene.search.grouping.TopGroups;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.common.SolrDocument;
diff --git a/solr/core/src/java/org/apache/solr/response/transform/ValueSourceAugmenter.java b/solr/core/src/java/org/apache/solr/response/transform/ValueSourceAugmenter.java
index 2920b67..15b099b 100644
--- a/solr/core/src/java/org/apache/solr/response/transform/ValueSourceAugmenter.java
+++ b/solr/core/src/java/org/apache/solr/response/transform/ValueSourceAugmenter.java
@@ -22,9 +22,9 @@ import java.util.Map;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.search.QParser;
diff --git a/solr/core/src/java/org/apache/solr/schema/RandomSortField.java b/solr/core/src/java/org/apache/solr/schema/RandomSortField.java
index 757a8d1..8234729 100644
--- a/solr/core/src/java/org/apache/solr/schema/RandomSortField.java
+++ b/solr/core/src/java/org/apache/solr/schema/RandomSortField.java
@@ -23,11 +23,11 @@ import java.util.Map;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.IntDocValues;
 import org.apache.lucene.search.*;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
diff --git a/solr/core/src/java/org/apache/solr/search/function/FileFloatSource.java b/solr/core/src/java/org/apache/solr/search/function/FileFloatSource.java
index 6640d1b..b5801a3 100755
--- a/solr/core/src/java/org/apache/solr/search/function/FileFloatSource.java
+++ b/solr/core/src/java/org/apache/solr/search/function/FileFloatSource.java
@@ -31,6 +31,7 @@ import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
@@ -38,7 +39,6 @@ import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.FloatDocValues;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
diff --git a/solr/core/src/test/org/apache/solr/search/TestIndexSearcher.java b/solr/core/src/test/org/apache/solr/search/TestIndexSearcher.java
index 6bbcc08..229fc28 100755
--- a/solr/core/src/test/org/apache/solr/search/TestIndexSearcher.java
+++ b/solr/core/src/test/org/apache/solr/search/TestIndexSearcher.java
@@ -18,9 +18,9 @@ package org.apache.solr.search;
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.SchemaField;

