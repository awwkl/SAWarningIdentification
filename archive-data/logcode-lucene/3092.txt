GitDiffStart: 422694f9c06393964bc6f26447c6b74e9f22de92 | Tue Jul 14 13:55:46 2015 +0000
diff --git a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
index 62f9913..471045b 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ElectionContext.java
@@ -19,6 +19,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.RetryUtil;
 import org.apache.solr.common.util.RetryUtil.RetryCmd;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.logging.MDCLoggingContext;
@@ -137,7 +138,7 @@ class ShardLeaderElectionContextBase extends ElectionContext {
           new RetryCmd() {
             @Override
             public void execute() throws Throwable {
-              zkClient.makePath(leaderPath, ZkStateReader.toJSON(leaderProps), CreateMode.EPHEMERAL, true);
+              zkClient.makePath(leaderPath, Utils.toJSON(leaderProps), CreateMode.EPHEMERAL, true);
             }
           }
       );
@@ -156,7 +157,7 @@ class ShardLeaderElectionContextBase extends ElectionContext {
         ZkStateReader.CORE_NAME_PROP,
         leaderProps.getProperties().get(ZkStateReader.CORE_NAME_PROP),
         ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());
-    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));    
+    Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));
   }  
 }
 
@@ -217,7 +218,7 @@ final class ShardLeaderElectionContext extends ShardLeaderElectionContextBase {
       // clear the leader in clusterstate
       ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.LEADER.toLower(),
           ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP, collection);
-      Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));
+      Overseer.getInQueue(zkClient).offer(Utils.toJSON(m));
       
       int leaderVoteWait = cc.getZkController().getLeaderVoteWait();
       if (!weAreReplacement) {
@@ -548,7 +549,7 @@ final class OverseerElectionContext extends ElectionContext {
         .substring(leaderSeqPath.lastIndexOf("/") + 1);
     ZkNodeProps myProps = new ZkNodeProps("id", id);
 
-    zkClient.makePath(leaderPath, ZkStateReader.toJSON(myProps),
+    zkClient.makePath(leaderPath, Utils.toJSON(myProps),
         CreateMode.EPHEMERAL, true);
     if(pauseBeforeStartMs >0){
       try {
diff --git a/solr/core/src/java/org/apache/solr/cloud/Overseer.java b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
index 315b91e..f4d146c 100644
--- a/solr/core/src/java/org/apache/solr/cloud/Overseer.java
+++ b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
@@ -52,6 +52,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.util.IOUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CloudConfig;
 import org.apache.solr.handler.admin.CollectionsHandler;
 import org.apache.solr.handler.component.ShardHandler;
@@ -67,7 +68,6 @@ import org.slf4j.LoggerFactory;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.ONLY_ACTIVE_NODES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.SHARD_UNIQUE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.BALANCESHARDUNIQUE;
-import static org.apache.solr.common.params.CommonParams.NAME;
 
 /**
  * Cluster leader. Responsible for processing state updates, node assignments, creating/deleting
@@ -303,7 +303,7 @@ public class Overseer implements Closeable {
         return;
       }
       try {
-        Map m = (Map) ZkStateReader.fromJSON(data);
+        Map m = (Map) Utils.fromJSON(data);
         String id = (String) m.get("id");
         if(overseerCollectionProcessor.getId().equals(id)){
           try {
diff --git a/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java b/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
index 8df05cb..a436bf8 100644
--- a/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
+++ b/solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.java
@@ -79,6 +79,7 @@ import org.apache.solr.common.util.ExecutorUtil;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.handler.admin.ClusterStatus;
 import org.apache.solr.handler.component.ShardHandler;
 import org.apache.solr.handler.component.ShardHandlerFactory;
@@ -97,7 +98,7 @@ import org.slf4j.LoggerFactory;
 
 import static org.apache.solr.cloud.Assign.getNodesForNewReplicas;
 import static org.apache.solr.common.cloud.DocCollection.SNITCH;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.cloud.ZkStateReader.BASE_URL_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.COLLECTION_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.CORE_NAME_PROP;
@@ -432,7 +433,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
   private synchronized void prioritizeOverseerNodes() throws KeeperException, InterruptedException {
     SolrZkClient zk = zkStateReader.getZkClient();
     if(!zk.exists(ZkStateReader.ROLES,true))return;
-    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));
+    Map m = (Map) Utils.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));
 
     List overseerDesignates = (List) m.get("overseer");
     if(overseerDesignates==null || overseerDesignates.isEmpty()) return;
@@ -463,8 +464,8 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     }
     //now ask the current leader to QUIT , so that the designate can takeover
     Overseer.getInQueue(zkStateReader.getZkClient()).offer(
-        ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),
-            "id",getLeaderId(zkStateReader.getZkClient()))));
+        Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower(),
+            "id", getLeaderId(zkStateReader.getZkClient()))));
 
   }
 
@@ -508,7 +509,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     } catch (KeeperException.NoNodeException e) {
       return null;
     }
-    Map m = (Map) ZkStateReader.fromJSON(data);
+    Map m = (Map) Utils.fromJSON(data);
     return  (String) m.get("id");
   }
 
@@ -636,7 +637,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
           processRebalanceLeaders(message);
           break;
         case MODIFYCOLLECTION:
-          overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));
+          overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));
           break;
         default:
           throw new SolrException(ErrorCode.BAD_REQUEST, "Unknown operation:"
@@ -699,7 +700,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     propMap.put(Overseer.QUEUE_OPERATION, ADDREPLICAPROP.toLower());
     propMap.putAll(message.getProperties());
     ZkNodeProps m = new ZkNodeProps(propMap);
-    inQueue.offer(ZkStateReader.toJSON(m));
+    inQueue.offer(Utils.toJSON(m));
   }
 
   private void processReplicaDeletePropertyCommand(ZkNodeProps message) throws KeeperException, InterruptedException {
@@ -710,7 +711,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     propMap.put(Overseer.QUEUE_OPERATION, DELETEREPLICAPROP.toLower());
     propMap.putAll(message.getProperties());
     ZkNodeProps m = new ZkNodeProps(propMap);
-    inQueue.offer(ZkStateReader.toJSON(m));
+    inQueue.offer(Utils.toJSON(m));
   }
 
   private void balanceProperty(ZkNodeProps message) throws KeeperException, InterruptedException {
@@ -724,7 +725,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     Map<String, Object> propMap = new HashMap<>();
     propMap.put(Overseer.QUEUE_OPERATION, BALANCESHARDUNIQUE.toLower());
     propMap.putAll(message.getProperties());
-    inQueue.offer(ZkStateReader.toJSON(new ZkNodeProps(propMap)));
+    inQueue.offer(Utils.toJSON(new ZkNodeProps(propMap)));
   }
 
 
@@ -829,12 +830,12 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
     Map roles = null;
     if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {
-      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));
+      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));
     }
 
     // convert cluster state into a map of writable types
-    byte[] bytes = ZkStateReader.toJSON(clusterState);
-    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);
+    byte[] bytes = Utils.toJSON(clusterState);
+    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);
 
     Set<String> collections = new HashSet<>();
     String routeKey = message.getStr(ShardParams._ROUTE_);
@@ -864,8 +865,8 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
       }
 
       if (clusterStateCollection.getStateFormat() > 1) {
-        bytes = ZkStateReader.toJSON(clusterStateCollection);
-        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);
+        bytes = Utils.toJSON(clusterStateCollection);
+        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);
         collectionStatus = getCollectionStatus(docCollection, name, requestedShards);
       } else {
         collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);
@@ -984,7 +985,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     String roleName = message.getStr("role");
     boolean nodeExists = false;
     if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){
-      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));
+      roles = (Map) Utils.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));
     } else {
       roles = new LinkedHashMap(1);
     }
@@ -1000,9 +1001,9 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     }
 
     if(nodeExists){
-      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);
+      zkClient.setData(ZkStateReader.ROLES, Utils.toJSON(roles),true);
     } else {
-      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);
+      zkClient.create(ZkStateReader.ROLES, Utils.toJSON(roles), CreateMode.PERSISTENT,true);
     }
     //if there are too many nodes this command may time out. And most likely dedicated
     // overseers are created when there are too many nodes  . So , do this operation in a separate thread
@@ -1107,7 +1108,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         ZkStateReader.NODE_NAME_PROP, replica.getStr(ZkStateReader.NODE_NAME_PROP),
         ZkStateReader.COLLECTION_PROP, collectionName,
         ZkStateReader.CORE_NODE_NAME_PROP, replicaName);
-    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));
+    Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));
   }
 
   private void checkRequired(ZkNodeProps message, String... props) {
@@ -1133,7 +1134,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
       ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
           DELETE.toLower(), NAME, collection);
       Overseer.getInQueue(zkStateReader.getZkClient()).offer(
-          ZkStateReader.toJSON(m));
+          Utils.toJSON(m));
 
       // wait for a while until we don't see the collection
       long now = System.nanoTime();
@@ -1187,7 +1188,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     Aliases newAliases = new Aliases(newAliasesMap);
     byte[] jsonBytes = null;
     if (newAliases.collectionAliasSize() > 0) { // only sub map right now
-      jsonBytes = ZkStateReader.toJSON(newAliases.getAliasMap());
+      jsonBytes = Utils.toJSON(newAliases.getAliasMap());
     }
     try {
       zkStateReader.getZkClient().setData(ZkStateReader.ALIASES, jsonBytes, true);
@@ -1253,7 +1254,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     Aliases newAliases = new Aliases(newAliasesMap);
     byte[] jsonBytes = null;
     if (newAliases.collectionAliasSize() > 0) { // only sub map right now
-      jsonBytes  = ZkStateReader.toJSON(newAliases.getAliasMap());
+      jsonBytes  = Utils.toJSON(newAliases.getAliasMap());
     }
     try {
       zkStateReader.getZkClient().setData(ZkStateReader.ALIASES,
@@ -1288,7 +1289,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     List<ReplicaCount> sortedNodeList = getNodesForNewReplicas(clusterState, collectionName, sliceName, repFactor,
         createNodeSetStr, overseer.getZkController().getCoreContainer());
         
-    Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));
+    Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));
     // wait for a while until we see the shard
     long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);
     boolean created = false;
@@ -1513,7 +1514,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         propMap.put(ZkStateReader.SHARD_STATE_PROP, Slice.State.CONSTRUCTION.toString());
         propMap.put(ZkStateReader.SHARD_PARENT_PROP, parentSlice.getName());
         DistributedQueue inQueue = Overseer.getInQueue(zkStateReader.getZkClient());
-        inQueue.offer(ZkStateReader.toJSON(new ZkNodeProps(propMap)));
+        inQueue.offer(Utils.toJSON(new ZkNodeProps(propMap)));
         
         // wait until we are able to see the new shard in cluster state
         waitForNewShard(collectionName, subSlice);
@@ -1654,7 +1655,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
               ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),
               ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(subShardNodeName),
               ZkStateReader.NODE_NAME_PROP, subShardNodeName);
-          Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(props));
+          Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));
 
           HashMap<String,Object> propMap = new HashMap<>();
           propMap.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());
@@ -1695,7 +1696,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         }
         propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);
         ZkNodeProps m = new ZkNodeProps(propMap);
-        inQueue.offer(ZkStateReader.toJSON(m));
+        inQueue.offer(Utils.toJSON(m));
       } else {
         log.info("Requesting shard state be set to 'recovery'");
         DistributedQueue inQueue = Overseer.getInQueue(zkStateReader.getZkClient());
@@ -1706,7 +1707,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         }
         propMap.put(ZkStateReader.COLLECTION_PROP, collectionName);
         ZkNodeProps m = new ZkNodeProps(propMap);
-        inQueue.offer(ZkStateReader.toJSON(m));
+        inQueue.offer(Utils.toJSON(m));
       }
 
       // now actually create replica cores on sub shard nodes
@@ -1869,7 +1870,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
       
       ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETESHARD.toLower(), ZkStateReader.COLLECTION_PROP,
           collection, ZkStateReader.SHARD_ID_PROP, sliceId);
-      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(m));
+      Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));
       
       // wait for a while until we don't see the shard
       long now = System.nanoTime();
@@ -2007,7 +2008,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
         "expireAt", String.valueOf(System.currentTimeMillis() + timeout));
     log.info("Adding routing rule: " + m);
     Overseer.getInQueue(zkStateReader.getZkClient()).offer(
-        ZkStateReader.toJSON(m));
+        Utils.toJSON(m));
 
     // wait for a while until we see the new rule
     log.info("Waiting to see routing rule updated in clusterstate");
@@ -2327,7 +2328,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
 
       createConfNode(configName, collectionName, isLegacyCloud);
 
-      Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(message));
+      Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(message));
 
       // wait for a while until we don't see the collection
       long waitUntil = System.nanoTime() + TimeUnit.NANOSECONDS.convert(30, TimeUnit.SECONDS);
@@ -2366,7 +2367,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
               ZkStateReader.CORE_NAME_PROP, coreName,
               ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),
               ZkStateReader.BASE_URL_PROP, baseUrl);
-          Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(props));
+          Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));
         }
 
         // Need to create new params for each request
@@ -2539,7 +2540,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
             collection, ZkStateReader.SHARD_ID_PROP, shard, ZkStateReader.CORE_NAME_PROP, coreName,
             ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(), ZkStateReader.BASE_URL_PROP,
             zkStateReader.getBaseUrlForNodeName(node), ZkStateReader.NODE_NAME_PROP, node);
-        Overseer.getInQueue(zkStateReader.getZkClient()).offer(ZkStateReader.toJSON(props));
+        Overseer.getInQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));
       }
       params.set(CoreAdminParams.CORE_NODE_NAME,
           waitToSeeReplicasInState(collection, Collections.singletonList(coreName)).get(coreName).getName());
@@ -2628,7 +2629,7 @@ public class OverseerCollectionProcessor implements Runnable, Closeable {
     if (configName != null) {
       String collDir = ZkStateReader.COLLECTIONS_ZKNODE + "/" + coll;
       log.info("creating collections conf node {} ", collDir);
-      byte[] data = ZkStateReader.toJSON(makeMap(ZkController.CONFIGNAME_PROP, configName));
+      byte[] data = Utils.toJSON(makeMap(ZkController.CONFIGNAME_PROP, configName));
       if (zkStateReader.getZkClient().exists(collDir, true)) {
         zkStateReader.getZkClient().setData(collDir, data, true);
       } else {
diff --git a/solr/core/src/java/org/apache/solr/cloud/ZkController.java b/solr/core/src/java/org/apache/solr/cloud/ZkController.java
index 79796ae..cb6f415 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ZkController.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ZkController.java
@@ -76,6 +76,7 @@ import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.common.util.URLUtil;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CloseHook;
 import org.apache.solr.core.CloudConfig;
 import org.apache.solr.core.CoreContainer;
@@ -709,7 +710,7 @@ public final class ZkController {
                 ZkStateReader.COLLECTION_PROP, collectionName,
                 ZkStateReader.CORE_NODE_NAME_PROP, replica.getName());
             updatedCoreNodeNames.add(replica.getName());
-            overseerJobQueue.offer(ZkStateReader.toJSON(m));
+            overseerJobQueue.offer(Utils.toJSON(m));
           }
         }
       }
@@ -1209,7 +1210,7 @@ public final class ZkController {
       if (updateLastState) {
         cd.getCloudDescriptor().lastPublished = state;
       }
-      overseerJobQueue.offer(ZkStateReader.toJSON(m));
+      overseerJobQueue.offer(Utils.toJSON(m));
     } finally {
       MDCLoggingContext.clear();
     }
@@ -1266,7 +1267,7 @@ public final class ZkController {
         ZkStateReader.NODE_NAME_PROP, getNodeName(),
         ZkStateReader.COLLECTION_PROP, cloudDescriptor.getCollectionName(),
         ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName);
-    overseerJobQueue.offer(ZkStateReader.toJSON(m));
+    overseerJobQueue.offer(Utils.toJSON(m));
   }
 
   public void createCollection(String collection) throws KeeperException,
@@ -1274,7 +1275,7 @@ public final class ZkController {
     ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
         CollectionParams.CollectionAction.CREATE.toLower(), ZkStateReader.NODE_NAME_PROP, getNodeName(),
         ZkStateReader.COLLECTION_PROP, collection);
-    overseerJobQueue.offer(ZkStateReader.toJSON(m));
+    overseerJobQueue.offer(Utils.toJSON(m));
   }
 
   // convenience for testing
@@ -1341,7 +1342,7 @@ public final class ZkController {
           collectionProps.remove(ZkStateReader.NUM_SHARDS_PROP);  // we don't put numShards in the collections properties
 
           ZkNodeProps zkProps = new ZkNodeProps(collectionProps);
-          zkClient.makePath(collectionPath, ZkStateReader.toJSON(zkProps), CreateMode.PERSISTENT, null, true);
+          zkClient.makePath(collectionPath, Utils.toJSON(zkProps), CreateMode.PERSISTENT, null, true);
 
         } catch (KeeperException e) {
           // it's okay if the node already exists
@@ -1702,7 +1703,7 @@ public final class ZkController {
       ZkNodeProps props = new ZkNodeProps(CONFIGNAME_PROP, confSetName);
       try {
 
-        zkClient.makePath(path, ZkStateReader.toJSON(props),
+        zkClient.makePath(path, Utils.toJSON(props),
             CreateMode.PERSISTENT, null, true);
       } catch (KeeperException e2) {
         // it's okay if the node already exists
@@ -1711,7 +1712,7 @@ public final class ZkController {
         }
         // if we fail creating, setdata
         // TODO: we should consider using version
-        zkClient.setData(path, ZkStateReader.toJSON(props), true);
+        zkClient.setData(path, Utils.toJSON(props), true);
       }
       return;
     }
@@ -1728,7 +1729,7 @@ public final class ZkController {
     }
 
     // TODO: we should consider using version
-    zkClient.setData(path, ZkStateReader.toJSON(props), true);
+    zkClient.setData(path, Utils.toJSON(props), true);
 
   }
 
@@ -1888,7 +1889,7 @@ public final class ZkController {
     try {
       byte[] data = zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true);
       if (data == null) return;
-      Map roles = (Map) ZkStateReader.fromJSON(data);
+      Map roles = (Map) Utils.fromJSON(data);
       if (roles == null) return;
       List nodeList = (List) roles.get("overseer");
       if (nodeList == null) return;
@@ -1897,7 +1898,7 @@ public final class ZkController {
             "node", getNodeName(),
             "role", "overseer");
         log.info("Going to add role {} ", props);
-        getOverseerCollectionQueue().offer(ZkStateReader.toJSON(props));
+        getOverseerCollectionQueue().offer(Utils.toJSON(props));
       }
     } catch (NoNodeException nne) {
       return;
@@ -1981,7 +1982,7 @@ public final class ZkController {
           ZkStateReader.COLLECTION_PROP, collection);
       log.warn("Leader is publishing core={} coreNodeName ={} state={} on behalf of un-reachable replica {}; forcePublishState? " + forcePublishState,
           replicaCoreName, replicaCoreNodeName, Replica.State.DOWN.toString(), replicaUrl);
-      overseerJobQueue.offer(ZkStateReader.toJSON(m));
+      overseerJobQueue.offer(Utils.toJSON(m));
     }
 
     return nodeIsLive;
@@ -2039,7 +2040,7 @@ public final class ZkController {
     if (stateData != null && stateData.length > 0) {
       // TODO: Remove later ... this is for upgrading from 4.8.x to 4.10.3 (see: SOLR-6732)
       if (stateData[0] == (byte) '{') {
-        Object parsedJson = ZkStateReader.fromJSON(stateData);
+        Object parsedJson = Utils.fromJSON(stateData);
         if (parsedJson instanceof Map) {
           stateObj = (Map<String, Object>) parsedJson;
         } else {
@@ -2047,7 +2048,7 @@ public final class ZkController {
         }
       } else {
         // old format still in ZK
-        stateObj = ZkNodeProps.makeMap("state", new String(stateData, StandardCharsets.UTF_8));
+        stateObj = Utils.makeMap("state", new String(stateData, StandardCharsets.UTF_8));
       }
     }
 
@@ -2082,14 +2083,14 @@ public final class ZkController {
       log.warn(exc.getMessage(), exc);
     }
     if (stateObj == null)
-      stateObj = ZkNodeProps.makeMap();
+      stateObj = Utils.makeMap();
 
     stateObj.put(ZkStateReader.STATE_PROP, state.toString());
     // only update the createdBy value if it's not set
     if (stateObj.get("createdByNodeName") == null)
       stateObj.put("createdByNodeName", String.valueOf(this.nodeName));
 
-    byte[] znodeData = ZkStateReader.toJSON(stateObj);
+    byte[] znodeData = Utils.toJSON(stateObj);
 
     try {
       if (state == Replica.State.DOWN) {
diff --git a/solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java b/solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java
index 7620c81..93a9965 100644
--- a/solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java
+++ b/solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java
@@ -29,6 +29,7 @@ import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.handler.admin.CollectionsHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -107,7 +108,7 @@ public class CollectionMutator {
       slices = new LinkedHashMap<>(1);
       slices.put(slice.getName(), slice);
       Map<String, Object> props = new HashMap<>(1);
-      props.put(DocCollection.DOC_ROUTER, ZkNodeProps.makeMap(NAME, ImplicitDocRouter.NAME));
+      props.put(DocCollection.DOC_ROUTER, Utils.makeMap(NAME, ImplicitDocRouter.NAME));
       newCollection = new DocCollection(collectionName, slices, props, new ImplicitDocRouter());
     } else {
       slices = new LinkedHashMap<>(collection.getSlicesMap()); // make a shallow copy
diff --git a/solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator.java b/solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator.java
index ea5b0b7..70e532c 100644
--- a/solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator.java
+++ b/solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator.java
@@ -36,6 +36,7 @@ import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -216,7 +217,7 @@ public class ReplicaMutator {
     boolean collectionExists = prevState.hasCollection(cName);
     if (!collectionExists && numShards != null) {
       ClusterStateMutator.getShardNames(numShards, shardNames);
-      Map<String, Object> createMsg = ZkNodeProps.makeMap(NAME, cName);
+      Map<String, Object> createMsg = Utils.makeMap(NAME, cName);
       createMsg.putAll(message.getProperties());
       writeCommand = new ClusterStateMutator(zkStateReader).createCollection(prevState, new ZkNodeProps(createMsg));
       DocCollection collection = writeCommand.collection;
diff --git a/solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator.java b/solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator.java
index 4798fe5..445e5d1 100644
--- a/solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator.java
+++ b/solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator.java
@@ -33,12 +33,13 @@ import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.COLL_PROP_PREFIX;
 import static org.apache.solr.cloud.overseer.CollectionMutator.checkCollectionKeyExistence;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CommonParams.NAME;
 
 public class SliceMutator {
@@ -124,7 +125,7 @@ public class SliceMutator {
     // if there are no slices left in the collection, remove it?
     if (newSlices.size() == 0) {
       return new ClusterStateMutator(zkStateReader).deleteCollection(clusterState,
-          new ZkNodeProps(ZkNodeProps.makeMap(NAME, collection)));
+          new ZkNodeProps(Utils.makeMap(NAME, collection)));
     } else {
       return new ZkWriteCommand(collection, coll.copyWithSlices(newSlices));
     }
diff --git a/solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java b/solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java
index e760ca9..768c958 100644
--- a/solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java
+++ b/solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java
@@ -26,6 +26,7 @@ import org.apache.solr.cloud.Overseer;
 import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.util.stats.TimerContext;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
@@ -150,7 +151,7 @@ public class ZkStateWriter {
             // let's clean up the collections path for this collection
             reader.getZkClient().clean("/collections/" + name);
           } else if (c.getStateFormat() > 1) {
-            byte[] data = ZkStateReader.toJSON(singletonMap(c.getName(),c));
+            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));
             if (reader.getZkClient().exists(path, true)) {
               assert c.getZNodeVersion() >= 0;
               log.info("going to update_collection {} version: {}", path, c.getZNodeVersion());
@@ -175,7 +176,7 @@ public class ZkStateWriter {
       if (isClusterStateModified) {
         assert clusterState.getZkClusterStateVersion() >= 0;
         lastUpdatedTime = System.nanoTime();
-        byte[] data = ZkStateReader.toJSON(clusterState);
+        byte[] data = Utils.toJSON(clusterState);
         Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);
         Set<String> collectionNames = clusterState.getCollections();
         Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());
diff --git a/solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner.java b/solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner.java
index c678127..755c451 100644
--- a/solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner.java
+++ b/solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner.java
@@ -36,8 +36,8 @@ import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -49,7 +49,7 @@ import static org.apache.solr.cloud.rule.Rule.Phase.FUZZY_ASSIGN;
 import static org.apache.solr.cloud.rule.Rule.Phase.FUZZY_VERIFY;
 import static org.apache.solr.cloud.rule.Rule.Phase.VERIFY;
 import static org.apache.solr.common.util.StrUtils.formatString;
-import static org.apache.solr.core.RequestParams.getDeepCopy;
+import static org.apache.solr.common.util.Utils.getDeepCopy;
 
 public class ReplicaAssigner {
   public static final Logger log = LoggerFactory.getLogger(ReplicaAssigner.class);
@@ -140,9 +140,9 @@ public class ReplicaAssigner {
         }
         msg += " Some nodes where excluded from assigning replicas because tags could not be obtained from them " + failedNodes;
       }
-      msg += "\n tag values" + ZkStateReader.toJSONString(getNodeVsTags());
+      msg += "\n tag values" + Utils.toJSONString(getNodeVsTags());
       if (!shardVsNodes.isEmpty()) {
-        msg += "\nInitial state for the coll : " + ZkStateReader.toJSONString(shardVsNodes);
+        msg += "\nInitial state for the coll : " + Utils.toJSONString(shardVsNodes);
       }
       throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, msg);
     }
diff --git a/solr/core/src/java/org/apache/solr/cloud/rule/Rule.java b/solr/core/src/java/org/apache/solr/cloud/rule/Rule.java
index f6e7ecb..51ef002 100644
--- a/solr/core/src/java/org/apache/solr/cloud/rule/Rule.java
+++ b/solr/core/src/java/org/apache/solr/cloud/rule/Rule.java
@@ -22,11 +22,10 @@ import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
-import java.util.Set;
 
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 
 import static org.apache.solr.cloud.rule.ImplicitSnitch.CORES;
 import static org.apache.solr.cloud.rule.Rule.MatchStatus.CANNOT_ASSIGN_FAIL;
@@ -105,7 +104,7 @@ public class Rule {
     if (shard != SHARD_DEFAULT) map.put(shard.name, shard.operand.toStr(shard.val));
     if (replica != REPLICA_DEFAULT) map.put(replica.name, replica.operand.toStr(replica.val));
     map.put(tag.name, tag.operand.toStr(tag.val));
-    return ZkStateReader.toJSONString(map);
+    return Utils.toJSONString(map);
   }
 
   /**
diff --git a/solr/core/src/java/org/apache/solr/core/ConfigOverlay.java b/solr/core/src/java/org/apache/solr/core/ConfigOverlay.java
index 2219ed6..518695c 100644
--- a/solr/core/src/java/org/apache/solr/core/ConfigOverlay.java
+++ b/solr/core/src/java/org/apache/solr/core/ConfigOverlay.java
@@ -26,9 +26,9 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.noggit.CharArr;
 import org.noggit.JSONParser;
 import org.noggit.JSONWriter;
@@ -62,27 +62,7 @@ public class ConfigOverlay implements MapSerializable {
   public Object getXPathProperty(String xpath, boolean onlyPrimitive) {
     List<String> hierarchy = checkEditable(xpath, true, false);
     if (hierarchy == null) return null;
-    return getObjectByPath(props, onlyPrimitive, hierarchy);
-  }
-
-  public static Object getObjectByPath(Map root, boolean onlyPrimitive, List<String> hierarchy) {
-    Map obj = root;
-    for (int i = 0; i < hierarchy.size(); i++) {
-      String s = hierarchy.get(i);
-      if (i < hierarchy.size() - 1) {
-        if (!(obj.get(s) instanceof Map)) return null;
-        obj = (Map) obj.get(s);
-        if (obj == null) return null;
-      } else {
-        Object val = obj.get(s);
-        if (onlyPrimitive && val instanceof Map) {
-          return null;
-        }
-        return val;
-      }
-    }
-
-    return false;
+    return Utils.getObjectByPath(props, onlyPrimitive, hierarchy);
   }
 
   public ConfigOverlay setUserProperty(String key, Object val) {
@@ -104,7 +84,7 @@ public class ConfigOverlay implements MapSerializable {
 
   public ConfigOverlay setProperty(String name, Object val) {
     List<String> hierarchy = checkEditable(name, false, true);
-    Map deepCopy = getDeepCopy(props);
+    Map deepCopy = (Map) Utils.fromJSON(Utils.toJSON(props));
     Map obj = deepCopy;
     for (int i = 0; i < hierarchy.size(); i++) {
       String s = hierarchy.get(i);
@@ -125,10 +105,6 @@ public class ConfigOverlay implements MapSerializable {
   }
 
 
-  private Map getDeepCopy(Map map) {
-    return (Map) ZkStateReader.fromJSON(ZkStateReader.toJSON(map));
-  }
-
   public static final String NOT_EDITABLE = "''{0}'' is not an editable property";
 
   private List<String> checkEditable(String propName, boolean isXPath, boolean failOnError) {
@@ -144,7 +120,7 @@ public class ConfigOverlay implements MapSerializable {
 
   public ConfigOverlay unsetProperty(String name) {
     List<String> hierarchy = checkEditable(name, false, true);
-    Map deepCopy = getDeepCopy(props);
+    Map deepCopy = (Map) Utils.fromJSON(Utils.toJSON(props));
     Map obj = deepCopy;
     for (int i = 0; i < hierarchy.size(); i++) {
       String s = hierarchy.get(i);
@@ -165,7 +141,7 @@ public class ConfigOverlay implements MapSerializable {
   }
 
   public byte[] toByteArray() {
-    return ZkStateReader.toJSON(data);
+    return Utils.toJSON(data);
   }
 
 
@@ -308,7 +284,7 @@ public class ConfigOverlay implements MapSerializable {
   }
 
   public Map<String, String> getEditableSubProperties(String xpath) {
-    Object o = getObjectByPath(props, false, StrUtils.splitSmart(xpath, '/'));
+    Object o = Utils.getObjectByPath(props, false, StrUtils.splitSmart(xpath, '/'));
     if (o instanceof Map) {
       return (Map) o;
     } else {
@@ -336,7 +312,7 @@ public class ConfigOverlay implements MapSerializable {
 
 
   public ConfigOverlay addNamedPlugin(Map<String, Object> info, String typ) {
-    Map dataCopy = RequestParams.getDeepCopy(data, 4);
+    Map dataCopy = Utils.getDeepCopy(data, 4);
     Map reqHandler = (Map) dataCopy.get(typ);
     if (reqHandler == null) dataCopy.put(typ, reqHandler = new LinkedHashMap());
     reqHandler.put(info.get(CoreAdminParams.NAME), info);
@@ -344,7 +320,7 @@ public class ConfigOverlay implements MapSerializable {
   }
 
   public ConfigOverlay deleteNamedPlugin(String name, String typ) {
-    Map dataCopy = RequestParams.getDeepCopy(data, 4);
+    Map dataCopy = Utils.getDeepCopy(data, 4);
     Map reqHandler = (Map) dataCopy.get(typ);
     if (reqHandler == null) return this;
     reqHandler.remove(name);
diff --git a/solr/core/src/java/org/apache/solr/core/ImplicitPlugins.java b/solr/core/src/java/org/apache/solr/core/ImplicitPlugins.java
index cde1e4f..10415c2 100644
--- a/solr/core/src/java/org/apache/solr/core/ImplicitPlugins.java
+++ b/solr/core/src/java/org/apache/solr/core/ImplicitPlugins.java
@@ -23,7 +23,6 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.handler.PingRequestHandler;
 import org.apache.solr.handler.RealTimeGetHandler;
@@ -43,7 +42,7 @@ import org.apache.solr.handler.admin.ThreadDumpHandler;
 import org.apache.solr.request.SolrRequestHandler;
 
 import static java.util.Collections.singletonMap;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CommonParams.JSON;
 import static org.apache.solr.common.params.CommonParams.NAME;
 import static org.apache.solr.common.params.CommonParams.WT;
diff --git a/solr/core/src/java/org/apache/solr/core/RequestParams.java b/solr/core/src/java/org/apache/solr/core/RequestParams.java
index 8390883..1c12b49 100644
--- a/solr/core/src/java/org/apache/solr/core/RequestParams.java
+++ b/solr/core/src/java/org/apache/solr/core/RequestParams.java
@@ -21,20 +21,15 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import org.apache.solr.cloud.ZkSolrResourceLoader;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.MapSolrParams;
-import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.data.Stat;
 import org.noggit.JSONParser;
@@ -118,7 +113,7 @@ public class RequestParams implements MapSerializable {
   }
 
   public RequestParams setParams(String name, Map values) {
-    Map deepCopy = getDeepCopy(data, 3);
+    Map deepCopy = Utils.getDeepCopy(data, 3);
     Map p = (Map) deepCopy.get(NAME);
     if (p == null) deepCopy.put(NAME, p = new LinkedHashMap());
     if (values == null) {
@@ -197,25 +192,8 @@ public class RequestParams implements MapSerializable {
   }
 
 
-  public static Map getDeepCopy(Map map, int maxDepth) {
-    Map copy = new LinkedHashMap<>();
-    for (Object o : map.entrySet()) {
-      Map.Entry e = (Map.Entry) o;
-      Object v = e.getValue();
-      if (v instanceof Map && maxDepth > 0) {
-        v = getDeepCopy((Map) v, maxDepth - 1);
-      } else if (v instanceof Set) {
-        v = new HashSet((Set) v);
-      } else if (v instanceof List) {
-        v = new ArrayList((List) v);
-      }
-      copy.put(e.getKey(), v);
-    }
-    return copy;
-  }
-
   public byte[] toByteArray() {
-    return ZkStateReader.toJSON(data);
+    return Utils.toJSON(data);
   }
 
   public static final String USEPARAM = "useParams";
diff --git a/solr/core/src/java/org/apache/solr/core/SolrConfig.java b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
index 21d60ad..c15469d 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrConfig.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrConfig.java
@@ -49,7 +49,6 @@ import org.apache.lucene.util.Version;
 import org.apache.solr.cloud.ZkSolrResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.util.IOUtils;
 import org.apache.solr.handler.component.SearchComponent;
 import org.apache.solr.request.SolrRequestHandler;
@@ -80,7 +79,7 @@ import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CommonParams.NAME;
 import static org.apache.solr.common.params.CommonParams.PATH;
 import static org.apache.solr.core.ConfigOverlay.ZNODEVER;
diff --git a/solr/core/src/java/org/apache/solr/handler/BlobHandler.java b/solr/core/src/java/org/apache/solr/handler/BlobHandler.java
index eb0f760..11fc31f 100644
--- a/solr/core/src/java/org/apache/solr/handler/BlobHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/BlobHandler.java
@@ -60,7 +60,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static java.util.Collections.singletonMap;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CommonParams.JSON;
 
 public class BlobHandler extends RequestHandlerBase implements PluginInfoInitialized {
diff --git a/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java b/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
index c6fc6b1..b75e777 100644
--- a/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/SolrConfigHandler.java
@@ -33,7 +33,6 @@ import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
@@ -51,7 +50,6 @@ import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
@@ -60,6 +58,7 @@ import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.ExecutorUtil;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.ConfigOverlay;
 import org.apache.solr.core.ImplicitPlugins;
 import org.apache.solr.core.PluginInfo;
@@ -77,7 +76,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import static java.util.Collections.singletonList;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CoreAdminParams.NAME;
 import static org.apache.solr.common.util.StrUtils.formatString;
 import static org.apache.solr.core.ConfigOverlay.NOT_EDITABLE;
@@ -179,7 +178,7 @@ public class SolrConfigHandler extends RequestHandlerBase {
 
         } else {
           if (ZNODEVER.equals(parts.get(1))) {
-            resp.add(ZNODEVER, ZkNodeProps.makeMap(
+            resp.add(ZNODEVER, Utils.makeMap(
                 ConfigOverlay.NAME, req.getCore().getSolrConfig().getOverlay().getZnodeVersion(),
                 RequestParams.NAME, req.getCore().getSolrConfig().getRequestParams().getZnodeVersion()));
             boolean checkStale = false;
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus.java b/solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus.java
index fd9df8a..02d9787 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/ClusterStatus.java
@@ -41,6 +41,7 @@ import org.apache.solr.common.params.ShardParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 
 public class ClusterStatus {
@@ -84,14 +85,14 @@ public class ClusterStatus {
 
     Map roles = null;
     if (zkStateReader.getZkClient().exists(ZkStateReader.ROLES, true)) {
-      roles = (Map) ZkStateReader.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));
+      roles = (Map) Utils.fromJSON(zkStateReader.getZkClient().getData(ZkStateReader.ROLES, null, null, true));
     }
 
     ClusterState clusterState = zkStateReader.getClusterState();
 
     // convert cluster state into a map of writable types
-    byte[] bytes = ZkStateReader.toJSON(clusterState);
-    Map<String, Object> stateMap = (Map<String,Object>) ZkStateReader.fromJSON(bytes);
+    byte[] bytes = Utils.toJSON(clusterState);
+    Map<String, Object> stateMap = (Map<String,Object>) Utils.fromJSON(bytes);
 
     Set<String> collections = new HashSet<>();
     String routeKey = message.getStr(ShardParams._ROUTE_);
@@ -121,8 +122,8 @@ public class ClusterStatus {
       }
 
       if (clusterStateCollection.getStateFormat() > 1) {
-        bytes = ZkStateReader.toJSON(clusterStateCollection);
-        Map<String, Object> docCollection = (Map<String, Object>) ZkStateReader.fromJSON(bytes);
+        bytes = Utils.toJSON(clusterStateCollection);
+        Map<String, Object> docCollection = (Map<String, Object>) Utils.fromJSON(bytes);
         collectionStatus = getCollectionStatus(docCollection, name, requestedShards);
       } else {
         collectionStatus = getCollectionStatus((Map<String, Object>) stateMap.get(name), name, requestedShards);
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
index b9ca25f..cab5a15 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java
@@ -59,6 +59,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.handler.BlobHandler;
 import org.apache.solr.handler.RequestHandlerBase;
@@ -167,7 +168,7 @@ public class CollectionsHandler extends RequestHandlerBase {
         result.put(QUEUE_OPERATION, operation.action.toLower());
         ZkNodeProps props = new ZkNodeProps(result);
         if (operation.sendToOCPQueue) handleResponse(operation.action.toLower(), props, rsp, operation.timeOut);
-        else Overseer.getInQueue(coreContainer.getZkController().getZkClient()).offer(ZkStateReader.toJSON(props));
+        else Overseer.getInQueue(coreContainer.getZkController().getZkClient()).offer(Utils.toJSON(props));
 
       }
     } else {
@@ -212,7 +213,7 @@ public class CollectionsHandler extends RequestHandlerBase {
 
        } else {
          coreContainer.getZkController().getOverseerCollectionQueue()
-             .offer(ZkStateReader.toJSON(m));
+             .offer(Utils.toJSON(m));
        }
        r.add(CoreAdminParams.REQUESTID, (String) m.get(ASYNC));
        SolrResponse response = new OverseerSolrResponse(r);
@@ -224,7 +225,7 @@ public class CollectionsHandler extends RequestHandlerBase {
 
     QueueEvent event = coreContainer.getZkController()
         .getOverseerCollectionQueue()
-        .offer(ZkStateReader.toJSON(m), timeout);
+        .offer(Utils.toJSON(m), timeout);
     if (event.getBytes() != null) {
       SolrResponse response = SolrResponse.deserialize(event.getBytes());
       rsp.getValues().addAll(response.getResponse());
diff --git a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
index dacb93c..8f2b015 100644
--- a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
+++ b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
@@ -87,6 +87,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
@@ -377,7 +378,7 @@ public class HttpSolrCall {
         path = path.substring(idx);
         if (invalidStates != null) {
           //it does not make sense to send the request to a remote node
-          throw new SolrException(SolrException.ErrorCode.INVALID_STATE, new String(ZkStateReader.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));
+          throw new SolrException(SolrException.ErrorCode.INVALID_STATE, new String(Utils.toJSON(invalidStates), org.apache.lucene.util.IOUtils.UTF_8));
         }
         action = REMOTEQUERY;
       } else {
diff --git a/solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.java b/solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.java
index 3031026..346f075 100644
--- a/solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.java
+++ b/solr/core/src/java/org/apache/solr/servlet/ZookeeperInfoServlet.java
@@ -45,9 +45,9 @@ import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.common.cloud.OnReconnect;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.SolrZkClient;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.util.FastWriter;
 import org.apache.zookeeper.KeeperException;
@@ -706,7 +706,7 @@ public final class ZookeeperInfoServlet extends BaseSolrServlet {
                   "Failed to parse /clusterstate.json from ZooKeeper due to: " + e, e);
             }
           } else {
-            clusterstateJsonMap = ZkNodeProps.makeMap();
+            clusterstateJsonMap = Utils.makeMap();
           }
           
           // fetch the requested page of collections and then retrieve the state for each 
diff --git a/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java b/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
index 2ce62a2..23b868c 100644
--- a/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
+++ b/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java
@@ -17,9 +17,6 @@
 
 package org.apache.solr.update;
 
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.PrintStream;
 import java.util.List;
 import java.util.Map;
 
@@ -29,8 +26,8 @@ import org.apache.lucene.index.*;
 import org.apache.lucene.index.IndexWriter.IndexReaderWarmer;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.Version;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.MapSerializable;
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrConfig;
@@ -166,7 +163,7 @@ public class SolrIndexConfig implements MapSerializable {
   }
   @Override
   public Map<String, Object> toMap() {
-    Map<String, Object> m = ZkNodeProps.makeMap("useCompoundFile", effectiveUseCompoundFileSetting,
+    Map<String, Object> m = Utils.makeMap("useCompoundFile", effectiveUseCompoundFileSetting,
         "maxBufferedDocs", maxBufferedDocs,
         "maxMergeDocs", maxMergeDocs,
         "mergeFactor", mergeFactor,
diff --git a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
index b408a5f..92db6c6 100644
--- a/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
+++ b/solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor.java
@@ -40,7 +40,6 @@ import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.Slice.State;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.cloud.ZooKeeperException;
 import org.apache.solr.common.params.ModifiableSolrParams;
@@ -49,6 +48,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.Hash;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.handler.component.RealTimeGetComponent;
@@ -551,13 +551,13 @@ public class DistributedUpdateProcessor extends UpdateRequestProcessor {
                   if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {
                     log.info("Going to expire routing rule");
                     try {
-                      Map<String, Object> map = ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),
+                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),
                           ZkStateReader.COLLECTION_PROP, collection,
                           ZkStateReader.SHARD_ID_PROP, myShardId,
                           "routeKey", routeKey + "!");
                       SolrZkClient zkClient = req.getCore().getCoreDescriptor().getCoreContainer().getZkController().getZkClient();
                       DistributedQueue queue = Overseer.getInQueue(zkClient);
-                      queue.offer(ZkStateReader.toJSON(map));
+                      queue.offer(Utils.toJSON(map));
                     } catch (KeeperException e) {
                       log.warn("Exception while removing routing rule for route key: " + routeKey, e);
                     } catch (Exception e) {
diff --git a/solr/core/src/java/org/apache/solr/util/CommandOperation.java b/solr/core/src/java/org/apache/solr/util/CommandOperation.java
index 5a28683..acd1cab 100644
--- a/solr/core/src/java/org/apache/solr/util/CommandOperation.java
+++ b/solr/core/src/java/org/apache/solr/util/CommandOperation.java
@@ -20,7 +20,6 @@ package org.apache.solr.util;
 import java.io.IOException;
 import java.io.Reader;
 import java.io.UnsupportedEncodingException;
-import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -28,15 +27,15 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.util.IOUtils;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.noggit.JSONParser;
 import org.noggit.ObjectBuilder;
 
 import static java.util.Collections.emptyMap;
 import static java.util.Collections.singletonList;
 import static java.util.Collections.singletonMap;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 
 public class CommandOperation {
   public final String name;
@@ -244,7 +243,7 @@ public class CommandOperation {
   @Override
   public String toString() {
     try {
-      return new String(ZkStateReader.toJSON(singletonMap(name, commandData)), IOUtils.UTF_8);
+      return new String(Utils.toJSON(singletonMap(name, commandData)), IOUtils.UTF_8);
     } catch (UnsupportedEncodingException e) {
       //should not happen
       return "";
diff --git a/solr/core/src/test/org/apache/solr/cloud/BaseCdcrDistributedZkTest.java b/solr/core/src/test/org/apache/solr/cloud/BaseCdcrDistributedZkTest.java
index 8341bba..2f26d46 100644
--- a/solr/core/src/test/org/apache/solr/cloud/BaseCdcrDistributedZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/BaseCdcrDistributedZkTest.java
@@ -34,6 +34,7 @@ import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.CdcrParams;
 import org.apache.solr.servlet.SolrDispatchFilter;
@@ -112,7 +113,7 @@ public class BaseCdcrDistributedZkTest extends AbstractDistribZkTestBase {
           AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT);
       try {
         zkStateReader.getZkClient().create(ZkStateReader.CLUSTER_PROPS,
-            ZkStateReader.toJSON(Collections.singletonMap("urlScheme", "https")),
+            Utils.toJSON(Collections.singletonMap("urlScheme", "https")),
             CreateMode.PERSISTENT, true);
       } finally {
         zkStateReader.close();
@@ -339,7 +340,7 @@ public class BaseCdcrDistributedZkTest extends AbstractDistribZkTestBase {
                                                    int maxShardsPerNode, SolrClient client, String createNodeSetStr)
       throws SolrServerException, IOException {
     return createCollection(collectionInfos, collectionName,
-        ZkNodeProps.makeMap(
+        Utils.makeMap(
             NUM_SLICES, numShards,
             REPLICATION_FACTOR, replicationFactor,
             CREATE_NODE_SET, createNodeSetStr,
diff --git a/solr/core/src/test/org/apache/solr/cloud/ClusterStateTest.java b/solr/core/src/test/org/apache/solr/cloud/ClusterStateTest.java
index 8959140..81b2cbe 100644
--- a/solr/core/src/test/org/apache/solr/cloud/ClusterStateTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/ClusterStateTest.java
@@ -17,7 +17,6 @@ package org.apache.solr.cloud;
  * the License.
  */
 
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -30,13 +29,12 @@ import org.apache.solr.common.cloud.DocRouter;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.easymock.EasyMock;
-import org.easymock.IAnswer;
 import org.junit.Test;
 
 import static org.easymock.EasyMock.createMock;
 import static org.easymock.EasyMock.createStrictMock;
-import static org.easymock.EasyMock.expectLastCall;
 
 public class ClusterStateTest extends SolrTestCaseJ4 {
   @Test
@@ -63,7 +61,7 @@ public class ClusterStateTest extends SolrTestCaseJ4 {
     ZkStateReader zkStateReaderMock = getMockZkStateReader(collectionStates.keySet());
     
     ClusterState clusterState = new ClusterState(-1,liveNodes, collectionStates);
-    byte[] bytes = ZkStateReader.toJSON(clusterState);
+    byte[] bytes = Utils.toJSON(clusterState);
     // System.out.println("#################### " + new String(bytes));
     ClusterState loadedClusterState = ClusterState.load(-1, bytes, liveNodes);
     
diff --git a/solr/core/src/test/org/apache/solr/cloud/ClusterStateUpdateTest.java b/solr/core/src/test/org/apache/solr/cloud/ClusterStateUpdateTest.java
index c51ba68..997fe8e 100644
--- a/solr/core/src/test/org/apache/solr/cloud/ClusterStateUpdateTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/ClusterStateUpdateTest.java
@@ -25,6 +25,7 @@ import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.core.SolrCore;
@@ -151,7 +152,7 @@ public class ClusterStateUpdateTest extends SolrTestCaseJ4  {
     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(),
         AbstractZkTestCase.TIMEOUT);
     zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + "/testcore",
-        ZkStateReader.toJSON(zkProps2), CreateMode.PERSISTENT, true);
+        Utils.toJSON(zkProps2), CreateMode.PERSISTENT, true);
     zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + "/testcore/shards",
         CreateMode.PERSISTENT, true);
     zkClient.close();
diff --git a/solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java b/solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java
index 0af4323..029d382 100644
--- a/solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/CollectionsAPIDistributedZkTest.java
@@ -83,7 +83,7 @@ import org.apache.solr.servlet.SolrDispatchFilter;
 import org.junit.Test;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.cloud.ZkStateReader.CORE_NAME_PROP;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
diff --git a/solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest.java b/solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest.java
index dba975a..943c78a 100644
--- a/solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/CustomCollectionTest.java
@@ -33,30 +33,19 @@ import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.ImplicitDocRouter;
 import org.apache.solr.common.cloud.Replica;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams.CollectionAction;
 import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.util.ExecutorUtil;
-import org.apache.solr.update.DirectUpdateHandler2;
-import org.apache.solr.util.DefaultSolrThreadFactory;
-import org.junit.BeforeClass;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import java.util.concurrent.CompletionService;
-import java.util.concurrent.ExecutorCompletionService;
-import java.util.concurrent.Future;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.SHARDS_PROP;
@@ -154,11 +143,11 @@ public class CustomCollectionTest extends AbstractFullDistribZkTestBase {
           client = createCloudClient(COLL_PREFIX + i);
         }
 
-        Map<String, Object> props = ZkNodeProps.makeMap(
+        Map<String, Object> props = Utils.makeMap(
             "router.name", ImplicitDocRouter.NAME,
             REPLICATION_FACTOR, replicationFactor,
             MAX_SHARDS_PER_NODE, maxShardsPerNode,
-            SHARDS_PROP,"a,b,c");
+            SHARDS_PROP, "a,b,c");
 
         createCollection(collectionInfos, COLL_PREFIX + i,props,client);
       } finally {
@@ -281,11 +270,11 @@ public class CustomCollectionTest extends AbstractFullDistribZkTestBase {
           .getZkStateReader().getClusterState().getLiveNodes().size())) + 1;
 
       try (CloudSolrClient client = createCloudClient(null)) {
-        Map<String, Object> props = ZkNodeProps.makeMap(
+        Map<String, Object> props = Utils.makeMap(
             "router.name", ImplicitDocRouter.NAME,
             REPLICATION_FACTOR, replicationFactor,
             MAX_SHARDS_PER_NODE, maxShardsPerNode,
-            SHARDS_PROP,"a,b,c,d",
+            SHARDS_PROP, "a,b,c,d",
             "router.field", shard_fld);
   
         collectionName = COLL_PREFIX + "withShardField";
@@ -335,10 +324,10 @@ public class CustomCollectionTest extends AbstractFullDistribZkTestBase {
     HashMap<String, List<Integer>> collectionInfos = new HashMap<>();
     String shard_fld = "shard_s";
     try (CloudSolrClient client = createCloudClient(null)) {
-      Map<String, Object> props = ZkNodeProps.makeMap(
+      Map<String, Object> props = Utils.makeMap(
           REPLICATION_FACTOR, replicationFactor,
           MAX_SHARDS_PER_NODE, maxShardsPerNode,
-          NUM_SLICES,numShards,
+          NUM_SLICES, numShards,
           "router.field", shard_fld);
 
       createCollection(collectionInfos, collectionName,props,client);
@@ -387,7 +376,7 @@ public class CustomCollectionTest extends AbstractFullDistribZkTestBase {
     String collectionName = "testCreateShardRepFactor";
     HashMap<String, List<Integer>> collectionInfos = new HashMap<>();
     try (CloudSolrClient client = createCloudClient(null)) {
-      Map<String, Object> props = ZkNodeProps.makeMap(
+      Map<String, Object> props = Utils.makeMap(
           REPLICATION_FACTOR, 1,
           MAX_SHARDS_PER_NODE, 5,
           NUM_SLICES, 2,
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteInactiveReplicaTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteInactiveReplicaTest.java
index b292b3b..b0ad50b 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteInactiveReplicaTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteInactiveReplicaTest.java
@@ -18,7 +18,6 @@ package org.apache.solr.cloud;
  */
 
 import static org.apache.solr.cloud.CollectionsAPIDistributedZkTest.*;
-import static org.apache.solr.common.cloud.ZkNodeProps.*;
 
 import java.net.URL;
 import java.util.HashMap;
@@ -37,6 +36,7 @@ import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 public class DeleteInactiveReplicaTest extends AbstractFullDistribZkTestBase{
@@ -120,7 +120,7 @@ public class DeleteInactiveReplicaTest extends AbstractFullDistribZkTestBase{
       ChaosMonkey.start(stoppedJetty);
       log.info("restarted jetty");
 
-      Map m = makeMap("qt", "/admin/cores", "action", "status");
+      Map m = Utils.makeMap("qt", "/admin/cores", "action", "status");
 
       try (SolrClient queryClient = new HttpSolrClient(replica1.getStr(ZkStateReader.BASE_URL_PROP))) {
         NamedList<Object> resp = queryClient.request(new QueryRequest(new MapSolrParams(m)));
@@ -132,7 +132,7 @@ public class DeleteInactiveReplicaTest extends AbstractFullDistribZkTestBase{
 
       try {
 
-        m = makeMap(
+        m = Utils.makeMap(
             "action", CoreAdminParams.CoreAdminAction.CREATE.toString(),
             ZkStateReader.COLLECTION_PROP, collectionName,
             ZkStateReader.SHARD_ID_PROP, "shard2",
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
index a63c174..d85dc17 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteLastCustomShardedReplicaTest.java
@@ -28,8 +28,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -39,7 +38,7 @@ import java.util.Map;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.SHARDS_PROP;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEREPLICA;
 
 public class DeleteLastCustomShardedReplicaTest extends AbstractFullDistribZkTestBase {
@@ -59,12 +58,12 @@ public class DeleteLastCustomShardedReplicaTest extends AbstractFullDistribZkTes
       int replicationFactor = 1;
       int maxShardsPerNode = 5;
 
-      Map<String, Object> props = ZkNodeProps.makeMap(
-              "router.name", ImplicitDocRouter.NAME,
-              ZkStateReader.REPLICATION_FACTOR, replicationFactor,
-              ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode,
-              NUM_SLICES, 1,
-              SHARDS_PROP,"a,b");
+      Map<String, Object> props = Utils.makeMap(
+          "router.name", ImplicitDocRouter.NAME,
+          ZkStateReader.REPLICATION_FACTOR, replicationFactor,
+          ZkStateReader.MAX_SHARDS_PER_NODE, maxShardsPerNode,
+          NUM_SLICES, 1,
+          SHARDS_PROP, "a,b");
 
       Map<String,List<Integer>> collectionInfos = new HashMap<>();
 
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
index dcf86de..f14873b 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteReplicaTest.java
@@ -32,7 +32,6 @@ import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
-import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
@@ -43,7 +42,7 @@ import java.util.Map;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.ONLY_IF_DOWN;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.common.params.CollectionParams.CollectionAction.DELETEREPLICA;
 
diff --git a/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java b/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
index e3e0682..6ab8a26 100644
--- a/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/DeleteShardTest.java
@@ -30,6 +30,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 import org.junit.Test;
 
@@ -131,7 +132,7 @@ public class DeleteShardTest extends AbstractFullDistribZkTestBase {
     propMap.put(ZkStateReader.COLLECTION_PROP, "collection1");
     ZkNodeProps m = new ZkNodeProps(propMap);
     ZkStateReader zkStateReader = cloudClient.getZkStateReader();
-    inQueue.offer(ZkStateReader.toJSON(m));
+    inQueue.offer(Utils.toJSON(m));
     boolean transition = false;
 
     for (int counter = 10; counter > 0; counter--) {
diff --git a/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest.java b/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest.java
index 171cf8a..3313de7 100644
--- a/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudDistribCmdsTest.java
@@ -38,6 +38,7 @@ import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams.CollectionAction;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.update.VersionInfo;
 import org.apache.solr.update.processor.DistributedUpdateProcessor;
 import org.apache.zookeeper.CreateMode;
@@ -421,7 +422,7 @@ public class FullSolrCloudDistribCmdsTest extends AbstractFullDistribZkTestBase
     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), 10000);
     int fails = 0;
     try {
-      zkClient.makePath(leaderPath, ZkStateReader.toJSON(props),
+      zkClient.makePath(leaderPath, Utils.toJSON(props),
           CreateMode.EPHEMERAL, true);
       for (int i = 0; i < 200; i++) {
         try {
diff --git a/solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest.java b/solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest.java
index 95315d2..2469c3f 100644
--- a/solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/MigrateRouteKeyTest.java
@@ -29,9 +29,8 @@ import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.RoutingRule;
 import org.apache.solr.common.cloud.Slice;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.update.DirectUpdateHandler2;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 import org.junit.Test;
 
@@ -111,7 +110,7 @@ public class MigrateRouteKeyTest extends BasicDistributedZkTest {
     HashMap<String, List<Integer>> collectionInfos = new HashMap<>();
 
     try (CloudSolrClient client = createCloudClient(null)) {
-      Map<String, Object> props = ZkNodeProps.makeMap(
+      Map<String, Object> props = Utils.makeMap(
           REPLICATION_FACTOR, 1,
           MAX_SHARDS_PER_NODE, 5,
           NUM_SLICES, 1);
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
index 023d179..1f9965b 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerCollectionProcessorTest.java
@@ -31,6 +31,7 @@ import org.apache.solr.common.params.CoreAdminParams;
 import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.handler.component.ShardHandler;
 import org.apache.solr.handler.component.ShardHandlerFactory;
 import org.apache.solr.handler.component.ShardRequest;
@@ -401,7 +402,7 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
   
   protected void issueCreateJob(Integer numberOfSlices,
       Integer replicationFactor, Integer maxShardsPerNode, List<String> createNodeList, boolean sendCreateNodeList, boolean createNodeSetShuffle) {
-    Map<String,Object> propMap = ZkNodeProps.makeMap(
+    Map<String,Object> propMap = Utils.makeMap(
         Overseer.QUEUE_OPERATION, CollectionParams.CollectionAction.CREATE.toLower(),
         ZkStateReader.REPLICATION_FACTOR, replicationFactor.toString(),
         "name", COLLECTION_NAME,
@@ -418,7 +419,7 @@ public class OverseerCollectionProcessorTest extends SolrTestCaseJ4 {
     }
 
     ZkNodeProps props = new ZkNodeProps(propMap);
-    QueueEvent qe = new QueueEvent("id", ZkStateReader.toJSON(props), null){
+    QueueEvent qe = new QueueEvent("id", Utils.toJSON(props), null){
       @Override
       public void setBytes(byte[] bytes) {
         lastProcessMessageResult = SolrResponse.deserialize( bytes);
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
index e8a6d30..c339007 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerRolesTest.java
@@ -27,12 +27,11 @@ import org.apache.solr.client.solrj.request.QueryRequest;
 import org.apache.solr.cloud.overseer.OverseerAction;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams.CollectionAction;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.data.Stat;
-import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -45,7 +44,7 @@ import java.util.Map;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.getLeaderNode;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.getSortedOverseerNodeNames;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
 
@@ -80,10 +79,10 @@ public class OverseerRolesTest  extends AbstractFullDistribZkTestBase{
     SolrZkClient zk = client.getZkStateReader().getZkClient();
     byte[] data = new byte[0];
     data = zk.getData("/overseer_elect/leader", null, new Stat(), true);
-    Map m = (Map) ZkStateReader.fromJSON(data);
+    Map m = (Map) Utils.fromJSON(data);
     String s = (String) m.get("id");
     String leader = LeaderElector.getNodeName(s);
-    Overseer.getInQueue(zk).offer(ZkStateReader.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower())));
+    Overseer.getInQueue(zk).offer(Utils.toJSON(new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.QUIT.toLower())));
     long timeout = System.currentTimeMillis()+10000;
     String newLeader=null;
     for(;System.currentTimeMillis() < timeout;){
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
index c14ffb7..730f7e4 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
@@ -27,7 +27,6 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -46,6 +45,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.util.ExecutorUtil;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CloudConfig;
 import org.apache.solr.handler.component.HttpShardHandlerFactory;
 import org.apache.solr.update.UpdateShardHandler;
@@ -131,7 +131,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
             ZkStateReader.CORE_NODE_NAME_PROP, coreNodeName,
             ZkStateReader.COLLECTION_PROP, collection);
             DistributedQueue q = Overseer.getInQueue(zkClient);
-            q.offer(ZkStateReader.toJSON(m));
+            q.offer(Utils.toJSON(m));
          return null;
       } else {
         ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),
@@ -143,7 +143,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
         ZkStateReader.NUM_SHARDS_PROP, Integer.toString(numShards),
         ZkStateReader.BASE_URL_PROP, "http://" + nodeName + "/solr/");
         DistributedQueue q = Overseer.getInQueue(zkClient);
-        q.offer(ZkStateReader.toJSON(m));
+        q.offer(Utils.toJSON(m));
       }
       
       if (collection.length() > 0) {
@@ -555,7 +555,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.ROLES_PROP, "",
           ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());
       
-      q.offer(ZkStateReader.toJSON(m));
+      q.offer(Utils.toJSON(m));
       
       waitForCollections(reader, "collection1");
 
@@ -571,7 +571,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.ROLES_PROP, "",
           ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());
 
-      q.offer(ZkStateReader.toJSON(m));
+      q.offer(Utils.toJSON(m));
 
       verifyStatus(reader, Replica.State.ACTIVE);
 
@@ -995,7 +995,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
             ZkStateReader.MAX_SHARDS_PER_NODE, "1"
             );
         DistributedQueue q = Overseer.getInQueue(controllerClient);
-        q.offer(ZkStateReader.toJSON(m));
+        q.offer(Utils.toJSON(m));
         controllerClient.makePath("/collections/perf" + i, true);
       }
 
@@ -1010,7 +1010,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
             ZkStateReader.BASE_URL_PROP, "http://" +  "node1"
             + "/solr/");
         DistributedQueue q = Overseer.getInQueue(controllerClient);
-        q.offer(ZkStateReader.toJSON(m));
+        q.offer(Utils.toJSON(m));
         if (j >= MAX_COLLECTIONS - 1) j = 0;
         if (k >= MAX_CORES - 1) k = 0;
         if (i > 0 && i % 100 == 0) log.info("Published {} items", i);
@@ -1027,7 +1027,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.BASE_URL_PROP, "http://" + "node1"
           + "/solr/");
       DistributedQueue q = Overseer.getInQueue(controllerClient);
-      q.offer(ZkStateReader.toJSON(m));
+      q.offer(Utils.toJSON(m));
 
       Timer t = new Timer();
       TimerContext context = t.time();
@@ -1123,7 +1123,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.CORE_NAME_PROP, "core1",
           ZkStateReader.ROLES_PROP, "",
           ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());
-      queue.offer(ZkStateReader.toJSON(m));
+      queue.offer(Utils.toJSON(m));
       m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state",
           ZkStateReader.BASE_URL_PROP, "http://127.0.0.1/solr",
           ZkStateReader.NODE_NAME_PROP, "node1",
@@ -1132,7 +1132,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.CORE_NAME_PROP, "core2",
           ZkStateReader.ROLES_PROP, "",
           ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());
-      queue.offer(ZkStateReader.toJSON(m));
+      queue.offer(Utils.toJSON(m));
       
       overseerClient = electNewOverseer(server.getZkAddress());
       
@@ -1146,7 +1146,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
           ZkStateReader.CORE_NAME_PROP, "core3",
           ZkStateReader.ROLES_PROP, "",
           ZkStateReader.STATE_PROP, Replica.State.RECOVERING.toString());
-      queue.offer(ZkStateReader.toJSON(m));
+      queue.offer(Utils.toJSON(m));
       
       for(int i=0;i<100;i++) {
         Slice s = reader.getClusterState().getSlice("collection1", "s1");
diff --git a/solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java b/solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java
index 33ef68f..e11e884 100644
--- a/solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java
@@ -43,7 +43,7 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 
 /**
  * We want to make sure that when migrating between http and https modes the
diff --git a/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java b/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java
index 1d8c6cf..e7d5ed1 100644
--- a/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java
@@ -35,10 +35,10 @@ import org.apache.solr.common.cloud.HashBasedRouter;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -227,7 +227,7 @@ public class ShardSplitTest extends BasicDistributedZkTest {
     HashMap<String, List<Integer>> collectionInfos = new HashMap<>();
     String shard_fld = "shard_s";
     try (CloudSolrClient client = createCloudClient(null)) {
-      Map<String, Object> props = ZkNodeProps.makeMap(
+      Map<String, Object> props = Utils.makeMap(
           REPLICATION_FACTOR, replicationFactor,
           MAX_SHARDS_PER_NODE, maxShardsPerNode,
           NUM_SLICES, numShards,
@@ -302,7 +302,7 @@ public class ShardSplitTest extends BasicDistributedZkTest {
     HashMap<String, List<Integer>> collectionInfos = new HashMap<>();
 
     try (CloudSolrClient client = createCloudClient(null)) {
-      Map<String, Object> props = ZkNodeProps.makeMap(
+      Map<String, Object> props = Utils.makeMap(
           REPLICATION_FACTOR, replicationFactor,
           MAX_SHARDS_PER_NODE, maxShardsPerNode,
           NUM_SLICES, numShards);
diff --git a/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest.java b/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest.java
index 80b8f13..026bc81 100644
--- a/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverTest.java
@@ -17,7 +17,7 @@ package org.apache.solr.cloud;
  * limitations under the License.
  */
 
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 
 import java.util.Collection;
 import java.util.HashSet;
diff --git a/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest.java b/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest.java
index aaeecfc..e22f13c 100644
--- a/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest.java
@@ -36,6 +36,7 @@ import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -356,7 +357,7 @@ public class SharedFSAutoReplicaFailoverUtilsTest extends SolrTestCaseJ4 {
     
     String json;
     try {
-      json = new String(ZkStateReader.toJSON(clusterState), "UTF-8");
+      json = new String(Utils.toJSON(clusterState), "UTF-8");
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException("Unexpected");
     }
diff --git a/solr/core/src/test/org/apache/solr/cloud/SliceStateTest.java b/solr/core/src/test/org/apache/solr/cloud/SliceStateTest.java
index 8ce5834..49ddfdd 100644
--- a/solr/core/src/test/org/apache/solr/cloud/SliceStateTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/SliceStateTest.java
@@ -23,7 +23,7 @@ import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.DocRouter;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
-import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 import java.util.HashMap;
@@ -51,7 +51,7 @@ public class SliceStateTest extends SolrTestCaseJ4 {
     collectionStates.put("collection1", new DocCollection("collection1", slices, null, DocRouter.DEFAULT));
 
     ClusterState clusterState = new ClusterState(-1,liveNodes, collectionStates);
-    byte[] bytes = ZkStateReader.toJSON(clusterState);
+    byte[] bytes = Utils.toJSON(clusterState);
     ClusterState loadedClusterState = ClusterState.load(-1, bytes, liveNodes);
 
     assertSame("Default state not set to active", Slice.State.ACTIVE, loadedClusterState.getSlice("collection1", "shard1").getState());
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestCryptoKeys.java b/solr/core/src/test/org/apache/solr/cloud/TestCryptoKeys.java
index 49a7817..db99d13 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestCryptoKeys.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestCryptoKeys.java
@@ -28,7 +28,7 @@ import java.util.Map;
 import org.apache.solr.client.solrj.SolrClient;
 import org.apache.solr.client.solrj.impl.HttpSolrClient;
 import org.apache.solr.common.cloud.SolrZkClient;
-import org.apache.solr.core.ConfigOverlay;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.MemClassLoader;
 import org.apache.solr.core.TestDynamicLoading;
 import org.apache.solr.core.TestSolrConfigHandler;
@@ -37,7 +37,6 @@ import org.apache.solr.util.CryptoKeys;
 import org.apache.solr.util.RESTfulServerProvider;
 import org.apache.solr.util.RestTestHarness;
 import org.apache.zookeeper.CreateMode;
-import org.junit.BeforeClass;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -158,7 +157,7 @@ public class TestCryptoKeys extends AbstractFullDistribZkTestBase {
         1l, 10);
 
     Map map = TestSolrConfigHandler.getRespMap("/runtime?wt=json", client);
-    String s = (String) ConfigOverlay.getObjectByPath(map, false, Arrays.asList("error", "msg"));
+    String s = (String) Utils.getObjectByPath(map, false, Arrays.asList("error", "msg"));
     assertNotNull(TestBlobHandler.getAsString(map), s);
     assertTrue(TestBlobHandler.getAsString(map), s.contains("should be signed with one of the keys in ZK /keys/exe"));
 
@@ -177,7 +176,7 @@ public class TestCryptoKeys extends AbstractFullDistribZkTestBase {
         wrongSig, 10);
 
     map = TestSolrConfigHandler.getRespMap("/runtime?wt=json", client);
-    s = (String) ConfigOverlay.getObjectByPath(map, false, Arrays.asList("error", "msg"));
+    s = (String) Utils.getObjectByPath(map, false, Arrays.asList("error", "msg"));
     assertNotNull(TestBlobHandler.getAsString(map), s);//No key matched signature for jar
     assertTrue(TestBlobHandler.getAsString(map), s.contains("No key matched signature for jar"));
 
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestRebalanceLeaders.java b/solr/core/src/test/org/apache/solr/cloud/TestRebalanceLeaders.java
index 9e23a6b..c8c4164 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestRebalanceLeaders.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestRebalanceLeaders.java
@@ -22,10 +22,10 @@ import org.apache.solr.client.solrj.impl.CloudSolrClient;
 import org.apache.solr.client.solrj.request.QueryRequest;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CollectionParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.KeeperException;
 import org.junit.Test;
 
@@ -221,7 +221,7 @@ public class TestRebalanceLeaders extends AbstractFullDistribZkTestBase {
       if (data == null) {
         return false;
       } else {
-        Map m = (Map) ZkStateReader.fromJSON(data);
+        Map m = (Map) Utils.fromJSON(data);
         zkCore = (String) m.get("core");
         repCore = ent.getValue().getStr("core");
         if (zkCore.equals(repCore) == false) {
diff --git a/solr/core/src/test/org/apache/solr/cloud/ZkControllerTest.java b/solr/core/src/test/org/apache/solr/cloud/ZkControllerTest.java
index 7180916..9eb8aee 100644
--- a/solr/core/src/test/org/apache/solr/cloud/ZkControllerTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/ZkControllerTest.java
@@ -29,6 +29,7 @@ import org.apache.solr.common.cloud.ZkConfigManager;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CloudConfig;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.CoreDescriptor;
@@ -141,7 +142,7 @@ public class ZkControllerTest extends SolrTestCaseJ4 {
         
         //Verify the URL Scheme is taken into account
         zkStateReader.getZkClient().create(ZkStateReader.CLUSTER_PROPS,
-            ZkStateReader.toJSON(Collections.singletonMap("urlScheme", "https")), CreateMode.PERSISTENT, true);
+            Utils.toJSON(Collections.singletonMap("urlScheme", "https")), CreateMode.PERSISTENT, true);
         
         assertEquals("https://zzz.xxx:1234/solr",
             zkStateReader.getBaseUrlForNodeName("zzz.xxx:1234_solr"));
@@ -178,7 +179,7 @@ public class ZkControllerTest extends SolrTestCaseJ4 {
       props.put("configName", actualConfigName);
       ZkNodeProps zkProps = new ZkNodeProps(props);
       zkClient.makePath(ZkStateReader.COLLECTIONS_ZKNODE + "/"
-              + COLLECTION_NAME, ZkStateReader.toJSON(zkProps),
+              + COLLECTION_NAME, Utils.toJSON(zkProps),
           CreateMode.PERSISTENT, true);
 
       if (DEBUG) {
@@ -351,7 +352,7 @@ public class ZkControllerTest extends SolrTestCaseJ4 {
         Slice slice = new Slice("shard1", replicas, sliceProps);
         DocCollection c = new DocCollection("testPublishAndWaitForDownStates", map("shard1", slice), Collections.emptyMap(), DocRouter.DEFAULT);
         ClusterState state = new ClusterState(0, Collections.emptySet(), map("testPublishAndWaitForDownStates", c));
-        byte[] bytes = ZkStateReader.toJSON(state);
+        byte[] bytes = Utils.toJSON(state);
         zkController.getZkClient().makePath(ZkStateReader.getCollectionPath("testPublishAndWaitForDownStates"), bytes, CreateMode.PERSISTENT, true);
 
         zkController.getZkStateReader().updateClusterState(true);
diff --git a/solr/core/src/test/org/apache/solr/cloud/ZkNodePropsTest.java b/solr/core/src/test/org/apache/solr/cloud/ZkNodePropsTest.java
index 5f68019..b80ff06 100644
--- a/solr/core/src/test/org/apache/solr/cloud/ZkNodePropsTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/ZkNodePropsTest.java
@@ -23,7 +23,7 @@ import java.util.Map;
 
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 public class ZkNodePropsTest extends SolrTestCaseJ4 {
@@ -39,7 +39,7 @@ public class ZkNodePropsTest extends SolrTestCaseJ4 {
     props.put("prop6", "value6");
     
     ZkNodeProps zkProps = new ZkNodeProps(props);
-    byte[] bytes = ZkStateReader.toJSON(zkProps);
+    byte[] bytes = Utils.toJSON(zkProps);
     
     ZkNodeProps props2 = ZkNodeProps.load(bytes);
     assertEquals("value1", props2.getStr("prop1"));
diff --git a/solr/core/src/test/org/apache/solr/cloud/overseer/TestClusterStateMutator.java b/solr/core/src/test/org/apache/solr/cloud/overseer/TestClusterStateMutator.java
index ef15b48..5e1cb9a 100644
--- a/solr/core/src/test/org/apache/solr/cloud/overseer/TestClusterStateMutator.java
+++ b/solr/core/src/test/org/apache/solr/cloud/overseer/TestClusterStateMutator.java
@@ -26,6 +26,7 @@ import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.ImplicitDocRouter;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkNodeProps;
+import org.apache.solr.common.util.Utils;
 
 public class TestClusterStateMutator extends SolrTestCaseJ4 {
   public void testCreateCollection() throws Exception {
@@ -34,7 +35,7 @@ public class TestClusterStateMutator extends SolrTestCaseJ4 {
 
     ClusterState clusterState = zkStateReader.getClusterState();
     ClusterStateMutator mutator = new ClusterStateMutator(zkStateReader);
-    ZkNodeProps message = new ZkNodeProps(ZkNodeProps.makeMap(
+    ZkNodeProps message = new ZkNodeProps(Utils.makeMap(
         "name", "xyz",
         "numShards", "1"
     ));
@@ -45,7 +46,7 @@ public class TestClusterStateMutator extends SolrTestCaseJ4 {
     assertEquals(1, collection.getMaxShardsPerNode());
 
     state = new ClusterState(-1, Collections.<String>emptySet(), Collections.singletonMap("xyz", collection));
-    message = new ZkNodeProps(ZkNodeProps.makeMap(
+    message = new ZkNodeProps(Utils.makeMap(
         "name", "abc",
         "numShards", "2",
         "router.name", "implicit",
diff --git a/solr/core/src/test/org/apache/solr/cloud/overseer/ZkStateWriterTest.java b/solr/core/src/test/org/apache/solr/cloud/overseer/ZkStateWriterTest.java
index 043bf39..19dd282 100644
--- a/solr/core/src/test/org/apache/solr/cloud/overseer/ZkStateWriterTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/overseer/ZkStateWriterTest.java
@@ -30,6 +30,7 @@ import org.apache.solr.common.cloud.DocRouter;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -148,9 +149,9 @@ public class ZkStateWriterTest extends SolrTestCaseJ4 {
       ClusterState clusterState = writer.enqueueUpdate(reader.getClusterState(), c1, null);
       writer.writePendingUpdates();
 
-      Map map = (Map) ZkStateReader.fromJSON(zkClient.getData("/clusterstate.json", null, null, true));
+      Map map = (Map) Utils.fromJSON(zkClient.getData("/clusterstate.json", null, null, true));
       assertNull(map.get("c1"));
-      map = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.COLLECTIONS_ZKNODE + "/c1/state.json", null, null, true));
+      map = (Map) Utils.fromJSON(zkClient.getData(ZkStateReader.COLLECTIONS_ZKNODE + "/c1/state.json", null, null, true));
       assertNotNull(map.get("c1"));
 
     } finally {
diff --git a/solr/core/src/test/org/apache/solr/cloud/rule/RuleEngineTest.java b/solr/core/src/test/org/apache/solr/cloud/rule/RuleEngineTest.java
index f147a60..bc1b1c3 100644
--- a/solr/core/src/test/org/apache/solr/cloud/rule/RuleEngineTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/rule/RuleEngineTest.java
@@ -29,12 +29,11 @@ import java.util.Set;
 
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.cloud.rule.ReplicaAssigner.Position;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.junit.Test;
 
 import static org.apache.solr.cloud.rule.Rule.parseRule;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 
 public class RuleEngineTest extends SolrTestCaseJ4{
   @Test
@@ -62,7 +61,7 @@ public class RuleEngineTest extends SolrTestCaseJ4{
         "    'node':'127.0.0.1:49958_'," +
         "    'freedisk':992," +
         "    'cores':1}}";
-    MockSnitch.nodeVsTags = (Map) ZkStateReader.fromJSON(s.getBytes(StandardCharsets.UTF_8));
+    MockSnitch.nodeVsTags = (Map) Utils.fromJSON(s.getBytes(StandardCharsets.UTF_8));
     Map shardVsReplicaCount = makeMap("shard1", 2, "shard2", 2);
 
     List<Rule> rules = parseRules("[{'cores':'<4'}, {" +
@@ -107,7 +106,7 @@ public class RuleEngineTest extends SolrTestCaseJ4{
         "    'node':'127.0.0.1:49958_'," +
         "    'freedisk':970," +
         "    'cores':1}}";
-    MockSnitch.nodeVsTags = (Map) ZkStateReader.fromJSON(s.getBytes(StandardCharsets.UTF_8));
+    MockSnitch.nodeVsTags = (Map) Utils.fromJSON(s.getBytes(StandardCharsets.UTF_8));
     //test not
     List<Rule> rules = parseRules(
          "[{cores:'<4'}, " +
@@ -184,7 +183,7 @@ public class RuleEngineTest extends SolrTestCaseJ4{
 
   private List<Rule> parseRules(String s) {
 
-    List maps = (List) ZkStateReader.fromJSON(s.getBytes(StandardCharsets.UTF_8));
+    List maps = (List) Utils.fromJSON(s.getBytes(StandardCharsets.UTF_8));
 
     List<Rule> rules = new ArrayList<>();
     for (Object map : maps) rules.add(new Rule((Map) map));
diff --git a/solr/core/src/test/org/apache/solr/core/TestInitParams.java b/solr/core/src/test/org/apache/solr/core/TestInitParams.java
index 5d0af66f..ba7a8cc 100644
--- a/solr/core/src/test/org/apache/solr/core/TestInitParams.java
+++ b/solr/core/src/test/org/apache/solr/core/TestInitParams.java
@@ -18,8 +18,8 @@ package org.apache.solr.core;
  */
 
 import org.apache.solr.SolrTestCaseJ4;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.SolrQueryResponse;
 import org.junit.BeforeClass;
@@ -55,7 +55,7 @@ public class TestInitParams extends SolrTestCaseJ4 {
 
     PluginInfo pluginInfo = new PluginInfo("requestHandler",
         new HashMap<String, String>(),
-        new NamedList<>(singletonMap("defaults", new NamedList(ZkNodeProps.makeMap("a", "A1")))), null);
+        new NamedList<>(singletonMap("defaults", new NamedList(Utils.makeMap("a", "A1")))), null);
     initParams.apply(pluginInfo);
     assertEquals( "A",initParams.defaults.get("a"));
   }
@@ -117,14 +117,14 @@ public class TestInitParams extends SolrTestCaseJ4 {
   }
 
   public void testMatchPath(){
-    InitParams initParams = new InitParams(new PluginInfo(InitParams.TYPE, ZkNodeProps.makeMap("path","/update/json/docs")));
+    InitParams initParams = new InitParams(new PluginInfo(InitParams.TYPE, Utils.makeMap("path", "/update/json/docs")));
     assertFalse(initParams.matchPath("/update"));
     assertTrue(initParams.matchPath("/update/json/docs"));
-    initParams = new InitParams(new PluginInfo(InitParams.TYPE, ZkNodeProps.makeMap("path","/update/**")));
+    initParams = new InitParams(new PluginInfo(InitParams.TYPE, Utils.makeMap("path", "/update/**")));
     assertTrue(initParams.matchPath("/update/json/docs"));
     assertTrue(initParams.matchPath("/update/json"));
     assertTrue(initParams.matchPath("/update"));
-    initParams = new InitParams(new PluginInfo(InitParams.TYPE, ZkNodeProps.makeMap("path","/update/*")));
+    initParams = new InitParams(new PluginInfo(InitParams.TYPE, Utils.makeMap("path", "/update/*")));
     assertFalse(initParams.matchPath("/update/json/docs"));
     assertTrue(initParams.matchPath("/update/json"));
     assertTrue(initParams.matchPath("/update"));
diff --git a/solr/core/src/test/org/apache/solr/core/TestSolrConfigHandler.java b/solr/core/src/test/org/apache/solr/core/TestSolrConfigHandler.java
index 0b0feeb..1ea9592 100644
--- a/solr/core/src/test/org/apache/solr/core/TestSolrConfigHandler.java
+++ b/solr/core/src/test/org/apache/solr/core/TestSolrConfigHandler.java
@@ -35,6 +35,7 @@ import org.apache.commons.io.FileUtils;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.impl.CloudSolrClient;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.handler.TestBlobHandler;
 import org.apache.solr.handler.TestSolrConfigHandlerConcurrent;
 import org.apache.solr.util.RestTestBase;
@@ -48,7 +49,7 @@ import org.restlet.ext.servlet.ServerServlet;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static org.apache.solr.core.ConfigOverlay.getObjectByPath;
+import static org.apache.solr.common.util.Utils.getObjectByPath;
 import static org.apache.solr.handler.TestBlobHandler.getAsString;
 
 public class TestSolrConfigHandler extends RestTestBase {
@@ -218,7 +219,7 @@ public class TestSolrConfigHandler extends RestTestBase {
     while (TimeUnit.SECONDS.convert(System.nanoTime() - startTime, TimeUnit.NANOSECONDS) < maxTimeoutSeconds) {
       String uri = "/config/overlay?wt=json";
       Map m = testServerBaseUrl == null ? getRespMap(uri, writeHarness) : TestSolrConfigHandlerConcurrent.getAsMap(testServerBaseUrl + uri, cloudSolrClient);
-      if (null == ConfigOverlay.getObjectByPath(m, true, Arrays.asList("overlay", "requestHandler", "/x", "a"))) {
+      if (null == Utils.getObjectByPath(m, true, Arrays.asList("overlay", "requestHandler", "/x", "a"))) {
         success = true;
         break;
       }
@@ -374,7 +375,7 @@ public class TestSolrConfigHandler extends RestTestBase {
         null,
         10);
 
-    List l = (List) ConfigOverlay.getObjectByPath(map,false, Arrays.asList("config", "initParams"));
+    List l = (List) Utils.getObjectByPath(map, false, Arrays.asList("config", "initParams"));
     assertNotNull("no object /config/initParams : "+ TestBlobHandler.getAsString(map) , l);
     assertEquals( 1, l.size());
     assertEquals( "val", ((Map)l.get(0)).get("key") );
@@ -399,7 +400,7 @@ public class TestSolrConfigHandler extends RestTestBase {
         continue;
 
       }
-      if (Objects.equals(expected, ConfigOverlay.getObjectByPath(m, false, jsonPath))) {
+      if (Objects.equals(expected, Utils.getObjectByPath(m, false, jsonPath))) {
         success = true;
         break;
       }
diff --git a/solr/core/src/test/org/apache/solr/handler/TestBlobHandler.java b/solr/core/src/test/org/apache/solr/handler/TestBlobHandler.java
index ed913a6..d9cd5d0 100644
--- a/solr/core/src/test/org/apache/solr/handler/TestBlobHandler.java
+++ b/solr/core/src/test/org/apache/solr/handler/TestBlobHandler.java
@@ -35,8 +35,8 @@ import org.apache.solr.common.cloud.DocCollection;
 import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.ConfigOverlay;
-import org.apache.solr.update.DirectUpdateHandler2;
 import org.apache.solr.util.SimplePostTool;
 import org.junit.Test;
 import org.noggit.JSONParser;
@@ -52,7 +52,7 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 
-import static org.apache.solr.core.ConfigOverlay.getObjectByPath;
+import static org.apache.solr.common.util.Utils.getObjectByPath;
 
 public class TestBlobHandler extends AbstractFullDistribZkTestBase {
   static final Logger log = LoggerFactory.getLogger(TestBlobHandler.class);
@@ -92,7 +92,7 @@ public class TestBlobHandler extends AbstractFullDistribZkTestBase {
 
       url = baseUrl + "/.system/blob/test/1";
       map = TestSolrConfigHandlerConcurrent.getAsMap(url, cloudClient);
-      List l = (List) ConfigOverlay.getObjectByPath(map, false, Arrays.asList("response", "docs"));
+      List l = (List) Utils.getObjectByPath(map, false, Arrays.asList("response", "docs"));
       assertNotNull("" + map, l);
       assertTrue("" + map, l.size() > 0);
       map = (Map) l.get(0);
@@ -125,12 +125,12 @@ public class TestBlobHandler extends AbstractFullDistribZkTestBase {
     for (; i < 150; i++) {//15 secs
       url = baseUrl + "/.system/blob/" + blobName;
       map = TestSolrConfigHandlerConcurrent.getAsMap(url, cloudClient);
-      String numFound = String.valueOf(ConfigOverlay.getObjectByPath(map, false, Arrays.asList("response", "numFound")));
+      String numFound = String.valueOf(Utils.getObjectByPath(map, false, Arrays.asList("response", "numFound")));
       if (!("" + count).equals(numFound)) {
         Thread.sleep(100);
         continue;
       }
-      l = (List) ConfigOverlay.getObjectByPath(map, false, Arrays.asList("response", "docs"));
+      l = (List) Utils.getObjectByPath(map, false, Arrays.asList("response", "docs"));
       assertNotNull(l);
       map = (Map) l.get(0);
       assertEquals("" + bytes.limit(), String.valueOf(map.get("size")));
@@ -141,7 +141,7 @@ public class TestBlobHandler extends AbstractFullDistribZkTestBase {
   }
 
   public static String getAsString(Map map) {
-    return new String(ZkStateReader.toJSON(map), StandardCharsets.UTF_8);
+    return new String(Utils.toJSON(map), StandardCharsets.UTF_8);
   }
 
   private void compareInputAndOutput(String url, byte[] bytarr) throws IOException {
diff --git a/solr/core/src/test/org/apache/solr/handler/TestConfigReload.java b/solr/core/src/test/org/apache/solr/handler/TestConfigReload.java
index 01287f07..dcd9a01 100644
--- a/solr/core/src/test/org/apache/solr/handler/TestConfigReload.java
+++ b/solr/core/src/test/org/apache/solr/handler/TestConfigReload.java
@@ -18,11 +18,10 @@ package org.apache.solr.handler;
  */
 
 import static java.util.Arrays.asList;
-import static org.apache.solr.core.ConfigOverlay.getObjectByPath;
+import static org.apache.solr.common.util.Utils.getObjectByPath;
 
 import java.io.StringReader;
 import java.nio.charset.StandardCharsets;
-import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
diff --git a/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerCloud.java b/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerCloud.java
index 71b5a34..a029f55 100644
--- a/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerCloud.java
+++ b/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerCloud.java
@@ -18,15 +18,12 @@ package org.apache.solr.handler;
  */
 
 
-import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
-import org.apache.lucene.util.LuceneTestCase.BadApple;
-
 import org.apache.solr.client.solrj.SolrClient;
 import org.apache.solr.client.solrj.impl.HttpSolrClient;
 import org.apache.solr.cloud.AbstractFullDistribZkTestBase;
@@ -35,7 +32,7 @@ import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
-import org.apache.solr.core.ConfigOverlay;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.RequestParams;
 import org.apache.solr.core.TestSolrConfigHandler;
 import org.apache.solr.util.RESTfulServerProvider;
@@ -268,7 +265,7 @@ public class TestSolrConfigHandlerCloud extends AbstractFullDistribZkTestBase {
 
   public static void compareValues(Map result, Object expected, List<String> jsonPath) {
     assertTrue(StrUtils.formatString("Could not get expected value  {0} for path {1} full output {2}", expected, jsonPath, getAsString(result)),
-        Objects.equals(expected, ConfigOverlay.getObjectByPath(result, false, jsonPath)));
+        Objects.equals(expected, Utils.getObjectByPath(result, false, jsonPath)));
   }
 
 }
diff --git a/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerConcurrent.java b/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerConcurrent.java
index 9458c67..c4db878 100644
--- a/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerConcurrent.java
+++ b/solr/core/src/test/org/apache/solr/handler/TestSolrConfigHandlerConcurrent.java
@@ -18,12 +18,11 @@ package org.apache.solr.handler;
  */
 
 import static java.util.Arrays.asList;
-import static org.apache.solr.core.ConfigOverlay.getObjectByPath;
+import static org.apache.solr.common.util.Utils.getObjectByPath;
 import static org.noggit.ObjectBuilder.getVal;
 
 import java.io.StringReader;
 import java.nio.charset.StandardCharsets;
-import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -44,6 +43,7 @@ import org.apache.solr.common.cloud.Replica;
 import org.apache.solr.common.cloud.Slice;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.ConfigOverlay;
 import org.apache.solr.util.RESTfulServerProvider;
 import org.apache.solr.util.RestTestHarness;
@@ -160,7 +160,7 @@ public class TestSolrConfigHandlerConcurrent extends AbstractFullDistribZkTestBa
       Map map = (Map) getVal(new JSONParser(new StringReader(response)));
       Object errors = map.get("errors");
       if(errors!= null){
-        errs.add(new String(ZkStateReader.toJSON(errors), StandardCharsets.UTF_8));
+        errs.add(new String(Utils.toJSON(errors), StandardCharsets.UTF_8));
         return;
       }
 
diff --git a/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java b/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java
index 8be90f2..3ebe8b6 100644
--- a/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java
+++ b/solr/core/src/test/org/apache/solr/request/SmileWriterTest.java
@@ -42,10 +42,10 @@ import com.fasterxml.jackson.dataformat.smile.SmileFactory;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.response.SmileResponseWriter;
 import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.ReturnFields;
@@ -78,7 +78,7 @@ public class SmileWriterTest extends SolrTestCaseJ4 {
     JSONWriter jsonWriter = new JSONWriter(out, 2);
     jsonWriter.setIndentSize(-1); // indentation by default
     jsonWriter.write(m);
-    String s = new String(ZkStateReader.toUTF8(out), StandardCharsets.UTF_8);
+    String s = new String(Utils.toUTF8(out), StandardCharsets.UTF_8);
     assertEquals(s , "{\"data1\":NaN,\"data2\":-Infinity,\"data3\":Infinity}");
 
     req.close();
@@ -102,7 +102,7 @@ public class SmileWriterTest extends SolrTestCaseJ4 {
     w.write(buf, req, rsp);
     Map m = (Map) decodeSmile(new ByteArrayInputStream(buf.toByteArray()));
     Map o2 = (Map) new ObjectBuilder(new JSONParser(new StringReader(expected))).getObject();
-    assertEquals(ZkStateReader.toJSONString(m),ZkStateReader.toJSONString(o2));
+    assertEquals(Utils.toJSONString(m), Utils.toJSONString(o2));
     req.close();
   }
 
diff --git a/solr/core/src/test/org/apache/solr/schema/TestBulkSchemaConcurrent.java b/solr/core/src/test/org/apache/solr/schema/TestBulkSchemaConcurrent.java
index b099035..bd0419a 100644
--- a/solr/core/src/test/org/apache/solr/schema/TestBulkSchemaConcurrent.java
+++ b/solr/core/src/test/org/apache/solr/schema/TestBulkSchemaConcurrent.java
@@ -34,8 +34,8 @@ import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.SolrClient;
 import org.apache.solr.client.solrj.impl.HttpSolrClient;
 import org.apache.solr.cloud.AbstractFullDistribZkTestBase;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.util.RESTfulServerProvider;
 import org.apache.solr.util.RestTestHarness;
 import org.junit.BeforeClass;
@@ -160,7 +160,7 @@ public class TestBulkSchemaConcurrent  extends AbstractFullDistribZkTestBase {
     Map map = (Map) ObjectBuilder.getVal(new JSONParser(new StringReader(response)));
     Object errors = map.get("errors");
     if (errors != null) {
-      errs.add(new String(ZkStateReader.toJSON(errors), StandardCharsets.UTF_8));
+      errs.add(new String(Utils.toJSON(errors), StandardCharsets.UTF_8));
       return;
     }
 
@@ -230,7 +230,7 @@ public class TestBulkSchemaConcurrent  extends AbstractFullDistribZkTestBase {
     Map map = (Map) ObjectBuilder.getVal(new JSONParser(new StringReader(response)));
     Object errors = map.get("errors");
     if (errors != null) {
-      errs.add(new String(ZkStateReader.toJSON(errors), StandardCharsets.UTF_8));
+      errs.add(new String(Utils.toJSON(errors), StandardCharsets.UTF_8));
       return;
     }
 
@@ -292,7 +292,7 @@ public class TestBulkSchemaConcurrent  extends AbstractFullDistribZkTestBase {
     Map map = (Map) ObjectBuilder.getVal(new JSONParser(new StringReader(response)));
     Object errors = map.get("errors");
     if (errors != null) {
-      errs.add(new String(ZkStateReader.toJSON(errors), StandardCharsets.UTF_8));
+      errs.add(new String(Utils.toJSON(errors), StandardCharsets.UTF_8));
       return;
     }
 
diff --git a/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java b/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java
index 63faec0..433d225 100644
--- a/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java
+++ b/solr/core/src/test/org/apache/solr/search/TestSmileRequest.java
@@ -29,9 +29,9 @@ import org.apache.solr.client.solrj.SolrClient;
 import org.apache.solr.client.solrj.impl.BinaryResponseParser;
 import org.apache.solr.client.solrj.impl.HttpSolrClient;
 import org.apache.solr.client.solrj.request.QueryRequest;
-import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.request.SmileWriterTest;
 import org.apache.solr.search.json.TestJsonRequest;
 import org.junit.AfterClass;
@@ -78,7 +78,7 @@ public class TestSmileRequest extends SolrTestCaseJ4 {
         }
         NamedList<Object> rsp = client.request(query);
         Map m = rsp.asMap(5);
-        String jsonStr = ZkStateReader.toJSONString(m);
+        String jsonStr = Utils.toJSONString(m);
         SolrTestCaseHS.matchJSON(jsonStr, tests);
       }
     };
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java b/solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java
index 9bd590d..42f84ed 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java
@@ -19,6 +19,7 @@ package org.apache.solr.common.cloud;
 
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.common.util.Utils;
 import org.noggit.JSONWriter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -248,7 +249,7 @@ public class ClusterState implements JSONWriter.Writable {
     if (bytes == null || bytes.length == 0) {
       return new ClusterState(version, liveNodes, Collections.<String, DocCollection>emptyMap());
     }
-    Map<String, Object> stateMap = (Map<String, Object>) ZkStateReader.fromJSON(bytes);
+    Map<String, Object> stateMap = (Map<String, Object>) Utils.fromJSON(bytes);
     Map<String,CollectionRef> collections = new LinkedHashMap<>(stateMap.size());
     for (Entry<String, Object> entry : stateMap.entrySet()) {
       String collectionName = entry.getKey();
@@ -264,7 +265,7 @@ public class ClusterState implements JSONWriter.Writable {
     if (bytes == null || bytes.length == 0) {
       return new Aliases();
     }
-    Map<String,Map<String,String>> aliasMap = (Map<String,Map<String,String>>) ZkStateReader.fromJSON(bytes);
+    Map<String,Map<String,String>> aliasMap = (Map<String,Map<String,String>>) Utils.fromJSON(bytes);
 
     return new Aliases(aliasMap);
   }
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java b/solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java
index 5ddfa24..08a7056 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java
@@ -17,10 +17,10 @@ package org.apache.solr.common.cloud;
  * limitations under the License.
  */
 
+import org.apache.solr.common.util.Utils;
 import org.noggit.JSONUtil;
 import org.noggit.JSONWriter;
 
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -47,22 +47,11 @@ public class ZkNodeProps implements JSONWriter.Writable {
    * key2, value2, ..., keyN, valueN
    */
   public ZkNodeProps(String... keyVals) {
-    this( makeMap((Object[])keyVals) );
+    this( Utils.makeMap((Object[]) keyVals) );
   }
 
   public static ZkNodeProps fromKeyVals(Object... keyVals)  {
-    return new ZkNodeProps( makeMap(keyVals) );
-  }
-
-  public static Map<String,Object> makeMap(Object... keyVals) {
-    if ((keyVals.length & 0x01) != 0) {
-      throw new IllegalArgumentException("arguments should be key,value");
-    }
-    Map<String,Object> propMap = new LinkedHashMap<>(keyVals.length>>1);
-    for (int i = 0; i < keyVals.length; i+=2) {
-      propMap.put(keyVals[i].toString(), keyVals[i+1]);
-    }
-    return propMap;
+    return new ZkNodeProps( Utils.makeMap(keyVals) );
   }
 
 
@@ -89,7 +78,7 @@ public class ZkNodeProps implements JSONWriter.Writable {
    * Create Replica from json string that is typically stored in zookeeper.
    */
   public static ZkNodeProps load(byte[] bytes) {
-    Map<String, Object> props = (Map<String, Object>) ZkStateReader.fromJSON(bytes);
+    Map<String, Object> props = (Map<String, Object>) Utils.fromJSON(bytes);
     return new ZkNodeProps(props);
   }
 
diff --git a/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java b/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java
index 323a2f7..a8a89c2 100644
--- a/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java
+++ b/solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java
@@ -18,12 +18,9 @@ package org.apache.solr.common.cloud;
  */
 
 import java.io.Closeable;
-import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.URLDecoder;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -39,17 +36,13 @@ import java.util.concurrent.TimeUnit;
 
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
-import org.apache.solr.common.util.ByteUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.WatchedEvent;
 import org.apache.zookeeper.Watcher;
 import org.apache.zookeeper.Watcher.Event.EventType;
 import org.apache.zookeeper.data.Stat;
-import org.noggit.CharArr;
-import org.noggit.JSONParser;
-import org.noggit.JSONWriter;
-import org.noggit.ObjectBuilder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -124,39 +117,6 @@ public class ZkStateReader implements Closeable {
       URL_SCHEME,
       AUTO_ADD_REPLICAS)));
 
-  //
-  // convenience methods... should these go somewhere else?
-  //
-  public static byte[] toJSON(Object o) {
-    CharArr out = new CharArr();
-    new JSONWriter(out, 2).write(o); // indentation by default
-    return toUTF8(out);
-  }
-
-  public static String toJSONString(Object o) {
-    return new String(toJSON(o), StandardCharsets.UTF_8);
-  }
-
-  public static byte[] toUTF8(CharArr out) {
-    byte[] arr = new byte[out.size() << 2]; // is 4x the real worst-case upper-bound?
-    int nBytes = ByteUtils.UTF16toUTF8(out, 0, out.size(), arr, 0);
-    return Arrays.copyOf(arr, nBytes);
-  }
-
-  public static Object fromJSON(byte[] utf8) {
-    // convert directly from bytes to chars
-    // and parse directly from that instead of going through
-    // intermediate strings or readers
-    CharArr chars = new CharArr();
-    ByteUtils.UTF8toUTF16(utf8, 0, utf8.length, chars);
-    JSONParser parser = new JSONParser(chars.getArray(), chars.getStart(), chars.length());
-    try {
-      return ObjectBuilder.getVal(parser);
-    } catch (IOException e) {
-      throw new RuntimeException(e); // should never happen w/o using real IO
-    }
-  }
-  
   /**
    * Returns config set name for collection.
    *
@@ -771,7 +731,7 @@ public class ZkStateReader implements Closeable {
     Map result = null;
     try {
       if(getZkClient().exists(ZkStateReader.CLUSTER_PROPS, true)){
-        result = (Map) ZkStateReader.fromJSON(getZkClient().getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true)) ;
+        result = (Map) Utils.fromJSON(getZkClient().getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true)) ;
       } else {
         result= new LinkedHashMap();
       }
@@ -797,24 +757,24 @@ public class ZkStateReader implements Closeable {
       try {
         if (getZkClient().exists(CLUSTER_PROPS, true)) {
           int v = 0;
-          Map properties = (Map) fromJSON(getZkClient().getData(CLUSTER_PROPS, null, s, true));
+          Map properties = (Map) Utils.fromJSON(getZkClient().getData(CLUSTER_PROPS, null, s, true));
           if (propertyValue == null) {
             //Don't update ZK unless absolutely necessary.
             if (properties.get(propertyName) != null) {
               properties.remove(propertyName);
-              getZkClient().setData(CLUSTER_PROPS, toJSON(properties), s.getVersion(), true);
+              getZkClient().setData(CLUSTER_PROPS, Utils.toJSON(properties), s.getVersion(), true);
             }
           } else {
             //Don't update ZK unless absolutely necessary.
             if (!propertyValue.equals(properties.get(propertyName))) {
               properties.put(propertyName, propertyValue);
-              getZkClient().setData(CLUSTER_PROPS, toJSON(properties), s.getVersion(), true);
+              getZkClient().setData(CLUSTER_PROPS, Utils.toJSON(properties), s.getVersion(), true);
             }
           }
         } else {
           Map properties = new LinkedHashMap();
           properties.put(propertyName, propertyValue);
-          getZkClient().create(CLUSTER_PROPS, toJSON(properties), CreateMode.PERSISTENT, true);
+          getZkClient().create(CLUSTER_PROPS, Utils.toJSON(properties), CreateMode.PERSISTENT, true);
         }
       } catch (KeeperException.BadVersionException bve) {
         log.warn("Race condition while trying to set a new cluster prop on current version " + s.getVersion());
@@ -841,7 +801,7 @@ public class ZkStateReader implements Closeable {
   public Map getSecurityProps() {
     try {
       if(getZkClient().exists(SOLR_SECURITY_CONF_PATH, true)) {
-        return (Map) ZkStateReader.fromJSON(getZkClient()
+        return (Map) Utils.fromJSON(getZkClient()
             .getData(ZkStateReader.SOLR_SECURITY_CONF_PATH, null, new Stat(), true)) ;
       }
     } catch (KeeperException | InterruptedException e) {
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/Utils.java b/solr/solrj/src/java/org/apache/solr/common/util/Utils.java
new file mode 100644
index 0000000..d001c70
--- /dev/null
+++ b/solr/solrj/src/java/org/apache/solr/common/util/Utils.java
@@ -0,0 +1,117 @@
+package org.apache.solr.common.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.noggit.CharArr;
+import org.noggit.JSONParser;
+import org.noggit.JSONWriter;
+import org.noggit.ObjectBuilder;
+
+public class Utils {
+  public static Map getDeepCopy(Map map, int maxDepth) {
+    Map copy = new LinkedHashMap<>();
+    for (Object o : map.entrySet()) {
+      Map.Entry e = (Map.Entry) o;
+      Object v = e.getValue();
+      if (v instanceof Map && maxDepth > 0) {
+        v = getDeepCopy((Map) v, maxDepth - 1);
+      } else if (v instanceof Set) {
+        v = new HashSet((Set) v);
+      } else if (v instanceof List) {
+        v = new ArrayList((List) v);
+      }
+      copy.put(e.getKey(), v);
+    }
+    return copy;
+  }
+
+  //
+  // convenience methods... should these go somewhere else?
+  //
+  public static byte[] toJSON(Object o) {
+    CharArr out = new CharArr();
+    new JSONWriter(out, 2).write(o); // indentation by default
+    return toUTF8(out);
+  }
+
+  public static String toJSONString(Object o) {
+    return new String(toJSON(o), StandardCharsets.UTF_8);
+  }
+
+  public static byte[] toUTF8(CharArr out) {
+    byte[] arr = new byte[out.size() << 2]; // is 4x the real worst-case upper-bound?
+    int nBytes = ByteUtils.UTF16toUTF8(out, 0, out.size(), arr, 0);
+    return Arrays.copyOf(arr, nBytes);
+  }
+
+  public static Object fromJSON(byte[] utf8) {
+    // convert directly from bytes to chars
+    // and parse directly from that instead of going through
+    // intermediate strings or readers
+    CharArr chars = new CharArr();
+    ByteUtils.UTF8toUTF16(utf8, 0, utf8.length, chars);
+    JSONParser parser = new JSONParser(chars.getArray(), chars.getStart(), chars.length());
+    try {
+      return ObjectBuilder.getVal(parser);
+    } catch (IOException e) {
+      throw new RuntimeException(e); // should never happen w/o using real IO
+    }
+  }
+
+  public static Map<String,Object> makeMap(Object... keyVals) {
+    if ((keyVals.length & 0x01) != 0) {
+      throw new IllegalArgumentException("arguments should be key,value");
+    }
+    Map<String,Object> propMap = new LinkedHashMap<>(keyVals.length>>1);
+    for (int i = 0; i < keyVals.length; i+=2) {
+      propMap.put(keyVals[i].toString(), keyVals[i+1]);
+    }
+    return propMap;
+  }
+
+  public static Object getObjectByPath(Map root, boolean onlyPrimitive, List<String> hierarchy) {
+    Map obj = root;
+    for (int i = 0; i < hierarchy.size(); i++) {
+      String s = hierarchy.get(i);
+      if (i < hierarchy.size() - 1) {
+        if (!(obj.get(s) instanceof Map)) return null;
+        obj = (Map) obj.get(s);
+        if (obj == null) return null;
+      } else {
+        Object val = obj.get(s);
+        if (onlyPrimitive && val instanceof Map) {
+          return null;
+        }
+        return val;
+      }
+    }
+
+    return false;
+  }
+}
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java b/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
index 6476c76..a39bd66 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest.java
@@ -45,7 +45,6 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.ShardParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
-import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
@@ -68,7 +67,7 @@ import java.util.Set;
 import java.util.concurrent.TimeoutException;
 
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 import static org.apache.solr.common.cloud.ZkStateReader.MAX_SHARDS_PER_NODE;
 import static org.apache.solr.common.cloud.ZkStateReader.REPLICATION_FACTOR;
 
diff --git a/solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec.java b/solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec.java
index 061b053..f9dad16 100644
--- a/solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec.java
+++ b/solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec.java
@@ -40,7 +40,6 @@ import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.util.ConcurrentLRUCache;
 import org.junit.Test;
 import org.noggit.CharArr;
@@ -306,7 +305,7 @@ public class TestJavaBinCodec extends SolrTestCaseJ4 {
   }
   @Test
   public void testStringCaching() throws Exception {
-    Map<String, Object> m = ZkNodeProps.makeMap("key1", "val1", "key2", "val2");
+    Map<String, Object> m = Utils.makeMap("key1", "val1", "key2", "val2");
 
     ByteArrayOutputStream os1 = new ByteArrayOutputStream();
     new JavaBinCodec().marshal(m, os1);
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
index dcd103d..a274c39 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
@@ -36,7 +36,6 @@ import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.http.params.CoreConnectionPNames;
 import org.apache.lucene.util.LuceneTestCase.Slow;
 import org.apache.solr.client.solrj.SolrClient;
 import org.apache.solr.client.solrj.SolrQuery;
@@ -69,6 +68,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
+import org.apache.solr.common.util.Utils;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.servlet.SolrDispatchFilter;
@@ -84,7 +84,7 @@ import org.slf4j.LoggerFactory;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.CREATE_NODE_SET;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.NUM_SLICES;
 import static org.apache.solr.cloud.OverseerCollectionProcessor.SHARDS_PROP;
-import static org.apache.solr.common.cloud.ZkNodeProps.makeMap;
+import static org.apache.solr.common.util.Utils.makeMap;
 
 /**
  * TODO: we should still test this works as a custom update chain as well as
@@ -205,7 +205,7 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
       try (ZkStateReader zkStateReader = new ZkStateReader(zkServer.getZkAddress(),
           AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT)) {
         zkStateReader.getZkClient().create(ZkStateReader.CLUSTER_PROPS,
-            ZkStateReader.toJSON(Collections.singletonMap("urlScheme", "https")),
+            Utils.toJSON(Collections.singletonMap("urlScheme", "https")),
             CreateMode.PERSISTENT, true);
       }
     }
@@ -356,7 +356,7 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
       SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(),
           AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT);
       Overseer.getInQueue(zkClient).offer(
-          ZkStateReader.toJSON(ZkNodeProps.makeMap(Overseer.QUEUE_OPERATION,
+          Utils.toJSON(Utils.makeMap(Overseer.QUEUE_OPERATION,
               CollectionParams.CollectionAction.CREATE.toLower(), "name",
               DEFAULT_COLLECTION, "numShards", String.valueOf(sliceCount),
               DocCollection.STATE_FORMAT, getStateFormat())));
@@ -1579,7 +1579,7 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
       String collectionName, int numShards, int replicationFactor, int maxShardsPerNode, SolrClient client, String createNodeSetStr) throws SolrServerException, IOException {
 
     return createCollection(collectionInfos, collectionName,
-        ZkNodeProps.makeMap(
+        Utils.makeMap(
         NUM_SLICES, numShards,
         ZkStateReader.REPLICATION_FACTOR, replicationFactor,
         CREATE_NODE_SET, createNodeSetStr,
@@ -1591,7 +1591,7 @@ public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTes
                                                      String collectionName, int numShards, int replicationFactor, int maxShardsPerNode, SolrClient client, String createNodeSetStr, String configName) throws SolrServerException, IOException {
 
     return createCollection(collectionInfos, collectionName,
-        ZkNodeProps.makeMap(
+        Utils.makeMap(
         NUM_SLICES, numShards,
         ZkStateReader.REPLICATION_FACTOR, replicationFactor,
         CREATE_NODE_SET, createNodeSetStr,
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractZkTestCase.java b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractZkTestCase.java
index c317c9b..cb3ad4b 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractZkTestCase.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractZkTestCase.java
@@ -20,7 +20,7 @@ package org.apache.solr.cloud;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkNodeProps;
-import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.common.util.Utils;
 import org.apache.zookeeper.CreateMode;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -96,9 +96,9 @@ public abstract class AbstractZkTestCase extends SolrTestCaseJ4 {
     props.put("configName", "conf1");
     final ZkNodeProps zkProps = new ZkNodeProps(props);
     
-    zkClient.makePath("/collections/collection1", ZkStateReader.toJSON(zkProps), CreateMode.PERSISTENT, true);
+    zkClient.makePath("/collections/collection1", Utils.toJSON(zkProps), CreateMode.PERSISTENT, true);
     zkClient.makePath("/collections/collection1/shards", CreateMode.PERSISTENT, true);
-    zkClient.makePath("/collections/control_collection", ZkStateReader.toJSON(zkProps), CreateMode.PERSISTENT, true);
+    zkClient.makePath("/collections/control_collection", Utils.toJSON(zkProps), CreateMode.PERSISTENT, true);
     zkClient.makePath("/collections/control_collection/shards", CreateMode.PERSISTENT, true);
 
     // for now, always upload the config and schema to the canonical names

