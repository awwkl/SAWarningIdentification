GitDiffStart: 21a07ee41e204935797d2cfeaad1b3a6c488ff19 | Tue Oct 9 21:45:27 2007 +0000
diff --git a/contrib/xml-query-parser/LuceneContribQuery.dtd b/contrib/xml-query-parser/LuceneContribQuery.dtd
new file mode 100644
index 0000000..159d6df
--- /dev/null
+++ b/contrib/xml-query-parser/LuceneContribQuery.dtd
@@ -0,0 +1,229 @@
+<!--	
+	This DTD builds on the <a href="LuceneCoreQuery.dtd.html">core Lucene XML syntax</a> and adds support for features found in the "contrib" section of the Lucene project.
+	
+	CorePlusExtensionsParser.java is the Java class that encapsulates this parser behaviour.
+
+	
+	The features added are:
+	<ul>
+	<li><a href="#LikeThisQuery">LikeThisQuery</a></li>
+	   Support for querying using large amounts of example text indicative of the users' general area of interest
+	<li><a href="#FuzzyLikeThisQuery">FuzzyLikeThisQuery</a></li>
+	   A style of fuzzy query which automatically looks for fuzzy variations on only the "interesting" terms 
+	<li><a href="#BooleanFilter">BooleanFilter</a></li>
+	   Is to Filters what core Lucene's BooleanQuery is to Queries - allows mixing of clauses using Boolean logic
+	<li><a href="#TermsFilter">TermsFilter</a></li>
+	   Constructs a filter from an arbitrary set of terms (unlike <a href="#RangeFilter">RangeFilter</a> which requires a contiguous range of terms)
+	<li><a href="#DuplicateFilter">DuplicateFilter</a></li>
+	   Removes duplicated documents from results where "duplicate" means documents share a value for a particular field (e.g. a primary key)
+	<li><a href="#BoostingQuery">BoostingQuery</a></li>
+	   Influence score of a query's matches in a subtle way which can't be achieved using BooleanQuery
+	</ul>
+	@title Contrib Lucene
+-->
+<!-- @hidden include the core DTD -->
+<!ENTITY % coreParserDTD SYSTEM "LuceneCoreQuery.dtd" >
+
+
+<!-- @hidden Allow for extensions -->
+<!ENTITY % extendedSpanQueries2 " " >
+<!ENTITY % extendedQueries2 " " >
+<!ENTITY % extendedFilters2 " " >
+
+
+<!ENTITY % extendedQueries1 "|LikeThisQuery|BoostingQuery|FuzzyLikeThisQuery%extendedQueries2;%extendedSpanQueries2;" >
+<!ENTITY % extendedFilters1 "|TermsFilter|BooleanFilter|DuplicateFilter%extendedFilters2;" >
+
+
+%coreParserDTD;
+
+<!--
+Performs fuzzy matching on "significant" terms in fields. Improves on "LikeThisQuery" by allowing for fuzzy variations of supplied fields.
+Improves on FuzzyQuery by rewarding all fuzzy variants of a term with the same IDF rather than default fuzzy behaviour which ranks rarer
+	variants (typically misspellings) more highly. This can be a useful default search mode for processing user input where the end user
+	is not expected to know about the standard query operators for fuzzy, boolean or phrase logic found in UserQuery
+	@example 
+	        <em>Search for information about the Sumitomo bank, where the end user has mis-spelt the name</em>
+	        %	          
+            <FuzzyLikeThisQuery>
+                <Field fieldName="contents">
+		             Sumitimo bank
+	            </Field>
+            </FuzzyLikeThisQuery>
+	         %	
+-->
+<!ELEMENT FuzzyLikeThisQuery (Field)*>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST FuzzyLikeThisQuery boost CDATA "1.0">
+<!-- Limits the total number of terms selected from the provided text plus the selected "fuzzy" variants -->
+<!ATTLIST FuzzyLikeThisQuery maxNumTerms CDATA "50">
+<!-- Ignore "Term Frequency" - a boost factor which rewards multiple occurences of the same term in a document -->
+<!ATTLIST FuzzyLikeThisQuery ignoreTF (true|false) "false">
+<!-- A field used in a FuzzyLikeThisQuery -->
+<!ELEMENT Field (#PCDATA)>
+<!-- Controls the level of similarity required for fuzzy variants where 1 is identical and 0.5 is that the variant contains 
+	half of the original's characters in the same order. Lower values produce more results but may take longer to execute due to
+	additional IO required to read matching document ids-->
+<!ATTLIST Field minSimilarity CDATA "0.5">
+<!-- Controls the minimum number of characters at the start of fuzzy variant words that must exactly match the original.
+	A value of zero will require no minimum and the search software will effectively scan ALL terms from a to z looking for variations.
+	This can incur high CPU overhead and a prefix length of just "1" will reduce this overhead to 1/26th of the original cost (assuming
+	an even distribution of letters used from the alphabet).
+ -->
+<!ATTLIST Field prefixLength CDATA "1">
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST Field fieldName CDATA #IMPLIED>
+
+
+
+<!--
+	Cherry-picks "significant" terms from the example child text and queries using these words. By only using significant (read: rare) terms the
+	performance cost of the query is substantially reduced and large bodies of text can be used as example content.
+	@example 
+	        <em>Use a block of text as an example of the type of content to be found, ignoring the "Reuters" word which
+	       appears commonly in the index.</em>
+	        %
+            <LikeThisQuery percentTermsToMatch="5" stopWords="Reuters">
+                IRAQI TROOPS REPORTED PUSHING BACK IRANIANS Iraq said today its troops were pushing Iranian forces out of 
+                positions they had initially occupied when they launched a new offensive near the southern port of 
+                Basra early yesterday.     A High Command communique said Iraqi troops had won a significant victory 
+                and were continuing to advance.     Iraq said it had foiled a three-pronged thrust some 10 km 
+                (six miles) from Basra, but admitted the Iranians had occupied ground held by the Mohammed al-Qassem 
+                unit, one of three divisions attacked.     The communique said Iranian Revolutionary Guards were under 
+                assault from warplanes, helicopter gunships, heavy artillery and tanks.     "Our forces are continuing 
+                their advance until they purge the last foothold" occupied by the Iranians, it said.     
+                (Iran said its troops had killed or wounded more than 4,000 Iraqis and were stabilising their new positions.)     
+                The Baghdad communique said Iraqi planes also destroyed oil installations at Iran's southwestern Ahvaz field 
+                during a raid today. It denied an Iranian report that an Iraqi jet was shot down.     
+                Iraq also reported a naval battle at the northern tip of the Gulf. Iraqi naval units and forces defending an 
+                offshore terminal sank six Iranian out of 28 Iranian boats attempting to attack an offshore terminal, 
+                the communique said.      Reuters 3;
+            </LikeThisQuery>	         
+	        %	
+	-->
+<!ELEMENT LikeThisQuery (#PCDATA)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST LikeThisQuery boost CDATA "1.0">
+<!-- Comma delimited list of field names -->
+<!ATTLIST LikeThisQuery fieldNames CDATA #IMPLIED>
+<!-- a list of stop words - analyzed to produce stop terms -->
+<!ATTLIST LikeThisQuery stopWords CDATA #IMPLIED>
+<!-- controls the maximum number of words shortlisted for the query. The higher the number the slower the response due to more disk reads required -->
+<!ATTLIST LikeThisQuery maxQueryTerms CDATA "20">
+<!-- Controls how many times a term must appear in the example text before it is shortlisted for use in the query -->
+<!ATTLIST LikeThisQuery minTermFrequency CDATA "1">
+<!-- A quality control that can be used to limit the number of results to those documents matching a certain percentage of the shortlisted query terms.
+	Values must be between 1 and 100-->
+<!ATTLIST LikeThisQuery percentTermsToMatch CDATA "30">
+
+<!--
+	Requires matches on the "Query" element and optionally boosts by any matches on the "BoostQuery".
+	Unlike a regular BooleanQuery the boost can be less than 1 to produce a subtractive rather than additive result
+	on the match score. 
+	@example <em>Find documents about banks, preferably related to mergers, and preferably not about "World bank"</em>
+    %
+	<BoostingQuery>
+      <Query>
+         <BooleanQuery fieldName="contents">
+           <Clause occurs="should">
+              <TermQuery>merger</TermQuery>
+           </Clause>
+           <Clause occurs="must">
+              <TermQuery>bank</TermQuery>
+           </Clause>
+         </BooleanQuery>	
+      </Query>
+      <BoostQuery boost="0.01">
+         <UserQuery>"world bank"</UserQuery>
+      </BoostQuery>
+    </BoostingQuery>
+	%
+	
+-->	
+<!ELEMENT BoostingQuery (Query,BoostQuery)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST BoostingQuery boost CDATA "1.0">
+
+<!--
+	Child element of BoostingQuery used to contain the choice of Query which is used for boosting purposes
+-->	
+<!ELEMENT BoostQuery (%queries;)>
+<!-- Optional boost for matches on this query. A boost of >0 but <1 
+	effectively demotes results from Query that match this BoostQuery.  	
+	-->
+<!ATTLIST BoostQuery boost CDATA "1.0">
+
+
+
+<!-- Removes duplicated documents from results where "duplicate" means documents share a value for a particular field such as a primary key
+	@example <em>Find the latest version of each web page that mentions "Lucene"</em>
+	%
+    <FilteredQuery>
+      <Query>
+         <TermQuery fieldName="text">lucene</TermQuery>
+      </Query>
+	  <Filter>
+		<DuplicateFilter fieldName="url" keepMode="last"/>
+	  </Filter>	
+    </FilteredQuery>	
+	%	
+	-->
+<!ELEMENT DuplicateFilter EMPTY>
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST DuplicateFilter fieldName CDATA #IMPLIED>
+<!-- Determines if the first or last document occurence is the one to return when presented with duplicated field values -->	
+<!ATTLIST DuplicateFilter keepMode (first | last) "first">
+<!-- Controls the choice of process used to produce the filter - "full" mode identifies only non-duplicate documents with the chosen field 
+	while "fast" mode may perform faster but will also mark documents <em>without</em> the field as valid. The former approach starts by 
+	assuming every document is a duplicate then finds the "master" documents to keep while the latter approach assumes all documents are 
+	unique and 	unmarks those documents that are a copy. 
+	-->	
+<!ATTLIST DuplicateFilter processingMode (full | fast) "full">
+
+
+
+
+<!-- Processes child text using a field-specific choice of Analyzer to produce a set of terms that are then used as a filter.
+	@example <em>Find documents talking about Lucene written on a Monday or a Friday</em>
+	%
+    <FilteredQuery>
+      <Query>
+         <TermQuery fieldName="text">lucene</TermQuery>
+      </Query>
+	<Filter>
+		<TermsFilter fieldName="dayOfWeek">monday friday</TermsFilter> 
+	</Filter>	
+    </FilteredQuery>	
+	%
+	
+	-->
+<!ELEMENT TermsFilter (#PCDATA)>
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST TermsFilter fieldName CDATA #IMPLIED>
+<!--
+	A Filter equivalent to BooleanQuery that applies Boolean logic to Clauses containing Filters.
+	Unlike BooleanQuery a BooleanFilter can contain a single "mustNot" clause.
+	@example <em>Find documents from the first quarter of this year or last year that are not in "draft" status</em>
+	%
+     <FilteredQuery>
+       <Query>
+           <MatchAllDocsQuery/>
+       </Query>
+       <Filter>
+        <BooleanFilter>
+          <Clause occurs="should">
+             <RangeFilter fieldName="date" lowerTerm="20070101" upperTerm="20070401"/>
+          </Clause>
+          <Clause occurs="should">
+             <RangeFilter fieldName="date" lowerTerm="20060101" upperTerm="20060401"/>
+          </Clause>
+          <Clause occurs="mustNot">
+             <TermsFilter fieldName="status">draft</TermsFilter> 
+          </Clause>
+        </BooleanFilter>
+       </Filter>
+    </FilteredQuery>
+	%
+	-->
+<!ELEMENT BooleanFilter (Clause)+>
+
diff --git a/contrib/xml-query-parser/LuceneCoreQuery.dtd b/contrib/xml-query-parser/LuceneCoreQuery.dtd
new file mode 100644
index 0000000..09f10bf
--- /dev/null
+++ b/contrib/xml-query-parser/LuceneCoreQuery.dtd
@@ -0,0 +1,397 @@
+<!--
+	<h3>Background</h3>
+	This DTD describes the XML syntax used to perform advanced searches using the core Lucene search engine. The motivation behind the XML query syntax is:
+	<ol>
+	<li>To open up Lucene functionality to clients other than Java</li>
+	<li>To offer a form of expressing queries that can easily be
+	    <ul>
+	        <li>Persisted for logging/auditing purposes</li>
+	        <li>Changed by editing text query templates (XSLT) without requiring a recompile/redeploy of applications</li>
+	        <li>Serialized across networks (without requiring Java bytecode for Query logic deployed on clients)</li>
+	    </ul>
+	</li>
+	<li>To provide a shorthand way of expressing query logic which echos the logical tree structure of query objects more closely than reading procedural Java query construction code</li>
+	<li>To bridge the growing gap between Lucene query/filtering functionality and the set of functionality accessible throught the standard Lucene QueryParser syntax</li>
+	<li>To provide a simply extensible syntax that does not require complex parser skills such as knowledge of JavaCC syntax</li>
+	</ol>
+	
+	
+	<h3>Syntax overview</h3>
+	Search syntax consists of two types of elements:
+	<ul>
+	<li><i>Queries</i></li>
+	<li><i>Filters</i></li>
+	</ul>
+
+	<h4>Queries</h4>
+	The root of any XML search must be a <i>Query</i> type element used to select content.
+	Queries typically score matches on documents using a number of different factors in order to provide relevant results first. 
+	One common example of a query tag is the <a href="#UserQuery">UserQuery</a> element which uses the standard 
+	Lucene QueryParser to parse Google-style search syntax provided by end users.
+	
+	<h4>Filters</h4>
+	Unlike Queries, <i>Filters</i> are not used to select or score content - they are simply used to filter <i>Query</i> output (see <a href="#FilteredQuery">FilteredQuery</a> for an example use of query filtering).
+	Because Filters simply offer a yes/no decision for each document in the index their output can be efficiently cached in memory as a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html">Bitset</a> for
+	subsequent reuse (see <a href="#CachedFilter">CachedFilter</a> tag).
+
+	<h4>Nesting elements</h4>
+	Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. 
+	The <a href="#BooleanQuery">BooleanQuery</a> element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean 
+	logic to determine mandatory or optional elements. 
+
+	
+	<h3>Advanced topics</h3>	
+	<h4>Advanced positional testing - span queries</h4>
+	The <i>SpanQuery</i> class of queries allow for complex positional tests which not only look for certain combinations of words but in particular 
+	positions in relation to each other and the documents containing them.
+	
+	
+	CoreParser.java is the Java class that encapsulates this parser behaviour.
+	
+	
+	@title Core Lucene	
+-->
+
+<!-- @hidden Define core types of XML elements -->
+<!ENTITY % coreSpanQueries "SpanOr|SpanNear|SpanOrTerms|SpanFirst|SpanNot|SpanTerm" >
+<!ENTITY % coreQueries "BooleanQuery|UserQuery|FilteredQuery|TermQuery|TermsQuery|MatchAllDocsQuery|ConstantScoreQuery" >
+<!ENTITY % coreFilters "RangeFilter|CachedFilter" >
+
+<!-- @hidden Allow for extensions -->
+<!ENTITY % extendedSpanQueries1 " " >
+<!ENTITY % extendedQueries1 " " >
+<!ENTITY % extendedFilters1 " " >
+
+<!ENTITY % spanQueries "%coreSpanQueries;%extendedSpanQueries1;" >
+<!ENTITY % queries "%coreQueries;|%spanQueries;%extendedQueries1;" >
+
+
+<!ENTITY % filters "%coreFilters;%extendedFilters1;" >
+
+<!--
+	BooleanQuerys implement Boolean logic which controls how multiple Clauses should be interpreted.
+	Some clauses may represent optional Query criteria while others represent mandatory criteria.	
+	@example 
+	        <em>Find articles about banks, preferably talking about mergers but nothing to do with "sumitomo"</em>
+	        %	          
+            <BooleanQuery fieldName="contents">
+	             <Clause occurs="should">
+		              <TermQuery>merger</TermQuery>
+	             </Clause>
+	             <Clause occurs="mustnot">
+		              <TermQuery>sumitomo</TermQuery>
+	             </Clause>
+	             <Clause occurs="must">
+		              <TermQuery>bank</TermQuery>
+	             </Clause>
+            </BooleanQuery>
+
+	         %
+-->	
+<!ELEMENT BooleanQuery (Clause)+>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST BooleanQuery boost CDATA "1.0">
+<!-- fieldName can optionally be defined here as a default attribute used by all child elements -->	
+<!ATTLIST BooleanQuery fieldName CDATA #IMPLIED>
+<!-- The "Coordination factor" rewards documents that contain more of the optional clauses in this list. This flag can be used to turn off this factor. -->
+<!ATTLIST BooleanQuery disableCoord (true | false) "false">
+<!-- The minimum number of optional clauses that should be present in any one document before it is considered to be a match. -->
+<!ATTLIST BooleanQuery minimumNumberShouldMatch CDATA "0">
+
+<!-- NOTE: "Clause" tag has 2 modes of use - inside <BooleanQuery> in which case only "query" types can be
+	child elements - while in a <BooleanFilter> clause only "filter" types can be contained.
+	@hidden TODO: Change BooleanFilterBuilder and BooleanQueryBuilder to auto-wrap choice of query or filters. This type of
+	      code already exists in CachedFilter so could be reused.
+-->	
+<!ELEMENT Clause (%queries;|%filters;)>
+<!-- Controls if the clause is optional (should), mandatory (must) or unacceptable (mustNot) -->
+<!ATTLIST Clause occurs (should | must | mustnot) "should">
+
+
+<!-- Caches any nested query or filter in an LRU (Least recently used) Cache. Cached queries, like filters, are turned into
+	Bitsets at a cost of 1 bit per document in the index. The memory cost of a cached query/filter is therefore numberOfDocsinIndex/8 bytes.
+	Queries that are cached as filters obviously retain none of the scoring information associated with results - they retain just
+	a Boolean yes/no record of which documents matched. 
+	@example 
+	        <em>Search for documents about banks from the last 10 years - caching the commonly-used "last 10 year" filter as a BitSet in 
+	RAM to eliminate the cost of building this filter from disk for every query</em>
+	        %	          
+            <FilteredQuery>
+               <Query>
+                  <UserQuery>bank</UserQuery>
+               </Query>	
+               <Filter>
+                  <CachedFilter>
+                     <RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/>
+                  </CachedFilter>
+               </Filter>	
+            </FilteredQuery>
+	         %
+	
+	-->
+<!ELEMENT CachedFilter (%queries;|%filters;)>
+
+
+
+<!--
+Passes content directly through to the standard LuceneQuery parser see "Lucene Query Syntax"
+	@example 
+	        <em>Search for documents about John Smith or John Doe using standard LuceneQuerySyntax</em>
+	        %	          
+               <UserQuery>"John Smith" OR "John Doe"</UserQuery>
+	         %
+		
+-->
+<!ELEMENT UserQuery (#PCDATA)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST UserQuery boost CDATA "1.0">
+
+<!-- A query which is used to match all documents. This has a couple of uses: 
+	<ol>
+	<li> as a Clause in a BooleanQuery who's only other clause
+	is a "mustNot" match (Lucene requires at least one positive clause) and..</li>
+	<li> in a FilteredQuery where a Filter tag is effectively being 
+	used to select content rather than it's usual role of filtering the results of a query.</li>
+	</ol>
+	
+	@example 
+	        <em>Effectively use a Filter as a query </em>
+	        %	          
+               <FilteredQuery>
+                 <Query>
+                    <MatchAllDocsQuery/>
+                 </Query>
+                 <Filter>
+                     <RangeFilter fieldName="date" lowerTerm="19870409" upperTerm="19870412"/>
+                 </Filter>	
+               </FilteredQuery>	         
+	       %
+	
+-->
+<!ELEMENT MatchAllDocsQuery EMPTY>
+
+<!-- a single term query - no analysis is done of the child text
+	@example 
+	        <em>Match on a primary key</em>
+	        %	          
+               <TermQuery fieldName="primaryKey">13424</TermQuery>
+	       %	
+-->	
+<!ELEMENT TermQuery (#PCDATA)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST TermQuery boost CDATA "1.0">
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST TermQuery fieldName CDATA #IMPLIED>
+
+
+
+<!-- 
+	The equivalent of a BooleanQuery with multiple optional TermQuery clauses.
+	Child text is analyzed using a field-specific choice of Analyzer to produce a set of terms that are ORed together in Boolean logic.
+	Unlike UserQuery element, this does not parse any special characters to control fuzzy/phrase/boolean logic and as such is incapable
+	of producing a Query parse error given any user input
+	@example 
+	        <em>Match on text from a database description (which may contain characters that 
+	are illegal characters in the standard Lucene Query syntax used in the UserQuery tag</em>
+	        %	          
+               <TermsQuery fieldName="description">Smith & Sons (Ltd) : incorporated 1982</TermsQuery>
+	       %	
+-->	
+<!ELEMENT TermsQuery (#PCDATA)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST TermsQuery boost CDATA "1.0">
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST TermsQuery fieldName CDATA #IMPLIED>
+<!-- The "Coordination factor" rewards documents that contain more of the terms in this list. This flag can be used to turn off this factor. -->
+<!ATTLIST TermsQuery disableCoord (true | false) "false">
+<!-- The minimum number of terms that should be present in any one document before it is considered to be a match. -->
+<!ATTLIST TermsQuery minimumNumberShouldMatch CDATA "0">
+
+
+<!-- 
+	Runs a Query and filters results to only those query matches that also match the Filter element.	
+	@example 
+	        <em>Find all documents about Lucene that have a status of "published"</em>
+	        %	          
+               <FilteredQuery>
+                 <Query>
+                    <UserQuery>Lucene</UserQuery>
+                 </Query>
+                 <Filter>
+                     <TermsFilter fieldName="status">published</TermsFilter>
+                 </Filter>	
+               </FilteredQuery>	         
+	       %	
+-->	
+<!ELEMENT FilteredQuery (Query,Filter)>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST FilteredQuery boost CDATA "1.0">
+<!-- Used to identify a nested Query element inside another container element. NOT a top-level query tag  -->
+<!ELEMENT Query (%queries;)>
+<!-- The choice of Filter that MUST also be matched  -->
+<!ELEMENT Filter (%filters;)>
+
+<!--
+	Filter used to limit query results to documents matching a range of field values
+	@example 
+	        <em>Search for documents about banks from the last 10 years</em>
+	        %	          
+            <FilteredQuery>
+               <Query>
+                  <UserQuery>bank</UserQuery>
+               </Query>	
+               <Filter>
+                     <RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/>
+               </Filter>	
+            </FilteredQuery>
+	         %
+	-->
+<!ELEMENT RangeFilter EMPTY>
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST RangeFilter fieldName CDATA #IMPLIED>
+<!-- The lower-most term value for this field (must be <= upperTerm) -->
+<!ATTLIST RangeFilter lowerTerm CDATA #REQUIRED>
+<!-- The upper-most term value for this field (must be >= lowerTerm) -->
+<!ATTLIST RangeFilter upperTerm CDATA #REQUIRED>
+<!-- Controls if the lowerTerm in the range is part of the allowed set of values -->
+<!ATTLIST RangeFilter includeLower (true | false) "true">
+<!-- Controls if the upperTerm in the range is part of the allowed set of values -->
+<!ATTLIST RangeFilter includeUpper (true | false) "true">
+
+
+
+<!-- A single term used in a SpanQuery. These clauses are the building blocks for more complex "span" queries which test word proximity
+	@example <em>Find documents using terms close to each other about mining and accidents</em>
+	      %
+	      <SpanNear slop="8" inOrder="false" fieldName="text">		
+			<SpanOr>
+				<SpanTerm>killed</SpanTerm>
+				<SpanTerm>died</SpanTerm>
+				<SpanTerm>dead</SpanTerm>
+			</SpanOr>
+			<SpanOr>
+				<SpanTerm>miner</SpanTerm>
+				<SpanTerm>mining</SpanTerm>
+				<SpanTerm>miners</SpanTerm>
+			</SpanOr>
+	      </SpanNear>
+	      % 	
+	-->
+<!ELEMENT SpanTerm (#PCDATA)>
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST SpanTerm fieldName CDATA #REQUIRED>
+
+<!-- A field-specific analyzer is used here to parse the child text provided in this tag. The SpanTerms produced are ORed in terms of Boolean logic 
+	@example <em>Use SpanOrTerms as a more convenient/succinct way of expressing multiple choices of SpanTerms. This example looks for reports 
+	using words describing a fatality near to references to miners</em>
+	      %
+	      <SpanNear slop="8" inOrder="false" fieldName="text">		
+			<SpanOrTerms>killed died death dead deaths</SpanOrTerms>
+			<SpanOrTerms>miner mining miners</SpanOrTerms>
+	      </SpanNear>
+	      % 	
+	-->
+<!ELEMENT SpanOrTerms (#PCDATA)>
+<!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute -->	
+<!ATTLIST SpanOrTerms fieldName CDATA #REQUIRED>
+
+<!-- Takes any number of child queries from the Span family 
+	@example <em>Find documents using terms close to each other about mining and accidents</em>
+	      %
+	      <SpanNear slop="8" inOrder="false" fieldName="text">		
+			<SpanOr>
+				<SpanTerm>killed</SpanTerm>
+				<SpanTerm>died</SpanTerm>
+				<SpanTerm>dead</SpanTerm>
+			</SpanOr>
+			<SpanOr>
+				<SpanTerm>miner</SpanTerm>
+				<SpanTerm>mining</SpanTerm>
+				<SpanTerm>miners</SpanTerm>
+			</SpanOr>
+	      </SpanNear>
+	      %	
+	
+	-->
+<!ELEMENT SpanOr (%spanQueries;)* >
+
+<!-- Takes any number of child queries from the Span family and tests for proximity
+	@hidden TODO SpanNear missing "boost attr (could add to SpanBuilderBase)
+	-->
+<!ELEMENT SpanNear (%spanQueries;)* >
+<!-- defines the maximum distance between Span elements where distance is expressed as word number, not byte offset 
+	@example <em>Find documents using terms within 8 words of each other talking about mining and accidents</em>
+	      %
+	      <SpanNear slop="8" inOrder="false" fieldName="text">		
+			<SpanOr>
+				<SpanTerm>killed</SpanTerm>
+				<SpanTerm>died</SpanTerm>
+				<SpanTerm>dead</SpanTerm>
+			</SpanOr>
+			<SpanOr>
+				<SpanTerm>miner</SpanTerm>
+				<SpanTerm>mining</SpanTerm>
+				<SpanTerm>miners</SpanTerm>
+			</SpanOr>
+	      </SpanNear>
+	      %	
+	-->
+<!ATTLIST SpanNear slop CDATA #REQUIRED>
+<!-- Controls if matching terms  have to appear in the order listed or can be reversed -->
+<!ATTLIST SpanNear inOrder (true | false) "true">
+
+<!-- Looks for a SpanQuery match occuring near the beginning of a document
+	
+	@example 
+	        <em>Find letters where the first 50 words talk about a resignation:</em>
+	        %	          
+	         <SpanFirst end="50">
+	               <SpanOrTerms fieldName="text">resigning resign leave</SpanOrTerms>
+	         </SpanFirst>
+	         %
+	
+	 --> 
+<!ELEMENT SpanFirst (%spanQueries;) >
+<!-- Controls the end of the region considered in a document's field (expressed in word number, not byte offset) --> 
+<!ATTLIST SpanFirst end CDATA #REQUIRED>
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST SpanFirst boost CDATA "1.0">
+
+<!-- Finds documents matching a SpanQuery but not if matching another SpanQuery 
+	@example <em>Find documents talking about social services but not containing the word "public"</em>
+	      %
+          <SpanNot fieldName="text">
+             <Include>
+                <SpanNear slop="2" inOrder="true">		
+                     <SpanTerm>social</SpanTerm>
+                     <SpanTerm>services</SpanTerm>
+                </SpanNear>				
+             </Include>
+             <Exclude>
+                <SpanTerm>public</SpanTerm>
+             </Exclude>
+          </SpanNot>
+	      %	
+	
+	-->
+<!ELEMENT SpanNot (Include,Exclude) >
+<!-- The SpanQuery to find -->
+<!ELEMENT Include (%spanQueries;) >
+<!-- The SpanQuery to be avoided -->
+<!ELEMENT Exclude (%spanQueries;) >
+
+
+<!-- a utility tag to wrap any filter as a query 
+	@example <em> Find all documents from the last 10 years </em>
+	%
+     <ConstantScoreQuery>
+           <RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/>
+     </ConstantScoreQuery>	
+	%
+	-->
+<!ELEMENT ConstantScoreQuery (%filters;)* >
+<!-- Optional boost for matches on this query. Values > 1 -->
+<!ATTLIST ConstantScoreQuery boost CDATA "1.0">
+
+
+
diff --git a/contrib/xml-query-parser/docs/DTDDocStyle.css b/contrib/xml-query-parser/docs/DTDDocStyle.css
new file mode 100644
index 0000000..163b973
--- /dev/null
+++ b/contrib/xml-query-parser/docs/DTDDocStyle.css
@@ -0,0 +1,57 @@
+body { background-color:white; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: small; }
+table { border: none}
+th.title { font-weight:bold; text-align:center; padding-left:1em; padding-right:1em}
+th.subtitle { font-weight:normal; text-align:left; padding-left:1em; padding-right:1em}
+td { text-align:left; vertical-align:baseline; padding-left:1em; padding-right:1em}
+td.construct { vertical-align:top; padding-left:1em; padding-right:1em}
+th.ruler { background-color:black; color:black}
+table.elementTitle { width:100%; background-color:#E0F0FF}
+td.leftElementTitle { font-weight:bold; font-size: medium;}
+td.rightElementTitle { text-align:right}
+table.attributeTitle { width:100%; background-color:#DDDDDD}
+td.leftAttributeTitle { font-weight:bold; font-size: medium;}
+td.rightAttributeTitle { text-align:right}
+p { text-align:justify;}
+p.model { padding-left:3em; text-align:left; font-style:italic}
+p.DTDSource { text-align:right; width:100%; background-color:#DDDDDD}
+p.emptyTagNote { font-style:italic}
+h1 { font-family:Arial; font-size: x-large;}
+h2 { font-size: medium;}
+h2.TOCTitle { font-family:Arial; font-size: medium;}
+.inTextTitle { font-weight:bold }
+pre, code { font-family: "Courier New", Courier, monospace; font-size: small; }
+
+pre#dtd_source { border: dotted 1px Gray; padding: 6pt 6pt 6pt 6pt;}
+.xml_plain {
+color: #000;
+}
+.dtd_tag_symbols {
+color: #003bff;
+}
+.dtd_comment {
+color: #555; background-color: #f8f8f8;
+}
+.dtd_attribute_name {
+color: #000;
+}
+.dtd_tag_name {
+color: #3f3fbf;
+}
+.dtd_char_data {
+color: #000;
+}
+.dtd_processing_instruction {
+color: #000; font-weight: bold; font-style: italic;
+}
+.dtd_attribute_value {
+color: #c10000;
+}
+.dtd_dtddoc_tag {
+color: #939393;
+background-color: #f7f7f7;
+font-style: italic;
+font-weight: bold;
+}
+.dtd_keyword {
+color: #800000;
+}
diff --git a/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.entities.html b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.entities.html
new file mode 100644
index 0000000..ba2703c
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.entities.html
@@ -0,0 +1,91 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head><title>LuceneContribQuery.dtd's entities</title>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+</head><body>
+<p class='DTDSource'><b><code>LuceneContribQuery.dtd</code></b>: <a href='LuceneContribQuery.dtd.html'>Elements</a> - <a href='LuceneContribQuery.dtd.entities.html'>Entities</a> - <a href='LuceneContribQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneContribQuery.dtd.entities.html' target='_top'>NO FRAMES</a></p><h1>Entities for Contrib Lucene</h1>
+<table summary='Entities'>
+<thead><tr><th>Name</th><th>Value</th></tr></thead>
+<tbody>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr>
+<td>coreParserDTD</td>
+<td>
+LuceneCoreQuery.dtd <i>(system)</i>
+</td>
+</tr>
+<tr>
+<td>filters</td>
+<td>
+%coreFilters;%extendedFilters1;
+</td>
+</tr>
+<tr>
+<td>spanQueries</td>
+<td>
+%coreSpanQueries;%extendedSpanQueries1;
+</td>
+</tr>
+<tr>
+<td>extendedSpanQueries2</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>extendedSpanQueries1</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>queries</td>
+<td>
+%coreQueries;|%spanQueries;%extendedQueries1;
+</td>
+</tr>
+<tr>
+<td>extendedQueries2</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>extendedQueries1</td>
+<td>
+|LikeThisQuery|BoostingQuery|FuzzyLikeThisQuery%extendedQueries2;%extendedSpanQueries2;
+</td>
+</tr>
+<tr>
+<td>coreSpanQueries</td>
+<td>
+SpanOr|SpanNear|SpanOrTerms|SpanFirst|SpanNot|SpanTerm
+</td>
+</tr>
+<tr>
+<td>coreFilters</td>
+<td>
+RangeFilter|CachedFilter
+</td>
+</tr>
+<tr>
+<td>extendedFilters2</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>extendedFilters1</td>
+<td>
+|TermsFilter|BooleanFilter|DuplicateFilter%extendedFilters2;
+</td>
+</tr>
+<tr>
+<td>coreQueries</td>
+<td>
+BooleanQuery|UserQuery|FilteredQuery|TermQuery|TermsQuery|MatchAllDocsQuery|ConstantScoreQuery
+</td>
+</tr>
+</tbody>
+</table>
+</body></html>
diff --git a/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.html b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.html
new file mode 100644
index 0000000..327052e
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.html
@@ -0,0 +1,1060 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+<title>Contrib Lucene</title>
+</head><body>
+<p class='DTDSource'><b><code>LuceneContribQuery.dtd</code></b>: <a href='LuceneContribQuery.dtd.html'>Elements</a> - <a href='LuceneContribQuery.dtd.entities.html'>Entities</a> - <a href='LuceneContribQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneContribQuery.dtd.html' target='_top'>NO FRAMES</a></p><h1>Contrib Lucene</h1>
+<p>This DTD builds on the <a href="LuceneCoreQuery.dtd.html">core Lucene XML syntax</a> and adds support for features found in the "contrib" section of the Lucene project.</p><p>CorePlusExtensionsParser.java is the Java class that encapsulates this parser behaviour.</p><p>The features added are:
+<ul>
+<li><a href="#LikeThisQuery">LikeThisQuery</a></li>
+Support for querying using large amounts of example text indicative of the users' general area of interest
+<li><a href="#FuzzyLikeThisQuery">FuzzyLikeThisQuery</a></li>
+A style of fuzzy query which automatically looks for fuzzy variations on only the "interesting" terms
+<li><a href="#BooleanFilter">BooleanFilter</a></li>
+Is to Filters what core Lucene's BooleanQuery is to Queries - allows mixing of clauses using Boolean logic
+<li><a href="#TermsFilter">TermsFilter</a></li>
+Constructs a filter from an arbitrary set of terms (unlike <a href="#RangeFilter">RangeFilter</a> which requires a contiguous range of terms)
+<li><a href="#DuplicateFilter">DuplicateFilter</a></li>
+Removes duplicated documents from results where "duplicate" means documents share a value for a particular field (e.g. a primary key)
+<li><a href="#BoostingQuery">BoostingQuery</a></li>
+Influence score of a query's matches in a subtle way which can't be achieved using BooleanQuery
+</ul></p><br />
+<a name='BooleanQuery'></a>
+<br /><table class='elementTitle' summary="BooleanQuery"><tr><td class='leftElementTitle'>
+&lt;BooleanQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>BooleanQuerys implement Boolean logic which controls how multiple Clauses should be interpreted.
+Some clauses may represent optional Query criteria while others represent mandatory criteria.</p><p><span class='inTextTitle'>Example:</span> <em>Find articles about banks, preferably talking about mergers but nothing to do with "sumitomo"</em>
+</p><pre>	          
+            &lt;BooleanQuery fieldName="contents"&gt;
+	             &lt;Clause occurs="should"&gt;
+		              &lt;TermQuery&gt;merger&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+	             &lt;Clause occurs="mustnot"&gt;
+		              &lt;TermQuery&gt;sumitomo&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+	             &lt;Clause occurs="must"&gt;
+		              &lt;TermQuery&gt;bank&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+            &lt;/BooleanQuery&gt;
+
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;BooleanQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;BooleanQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Clause'>Clause</a></td><td>At least one</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;BooleanQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;BooleanQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#BooleanQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#BooleanQuery_disableCoord'>disableCoord</a></td><td>true, false</td><td>false</td></tr><tr><td><a href='#BooleanQuery_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#BooleanQuery_minimumNumberShouldMatch'>minimumNumberShouldMatch</a></td><td></td><td>0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Clause'>Clause</a>)+</p><a name='BooleanQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='BooleanQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>fieldName can optionally be defined here as a default attribute used by all child elements</p><a name='BooleanQuery_disableCoord'></a>
+<br /><table class='attributeTitle' summary="disableCoord"><tr><td class='leftAttributeTitle'>
+@disableCoord</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>The "Coordination factor" rewards documents that contain more of the optional clauses in this list. This flag can be used to turn off this factor.</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: false</p><a name='BooleanQuery_minimumNumberShouldMatch'></a>
+<br /><table class='attributeTitle' summary="minimumNumberShouldMatch"><tr><td class='leftAttributeTitle'>
+@minimumNumberShouldMatch</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>The minimum number of optional clauses that should be present in any one document before it is considered to be a match.</p><p><span class='inTextTitle'>Default value</span>: 0</p><a name='Clause'></a>
+<br /><table class='elementTitle' summary="Clause"><tr><td class='leftElementTitle'>
+&lt;Clause&gt;</td><td class='rightElementTitle'>
+Child of <a href='#BooleanFilter'>BooleanFilter</a>, <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>NOTE: "Clause" tag has 2 modes of use - inside &lt;BooleanQuery> in which case only "query" types can be
+child elements - while in a &lt;BooleanFilter> clause only "filter" types can be contained.</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Clause&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Clause&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanFilter'>BooleanFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#BoostingQuery'>BoostingQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#DuplicateFilter'>DuplicateFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#LikeThisQuery'>LikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsFilter'>TermsFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;Clause&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;Clause&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#Clause_occurs'>occurs</a></td><td>should, must, mustnot</td><td>should</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#LikeThisQuery'>LikeThisQuery</a> | <a href='#BoostingQuery'>BoostingQuery</a> | <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a> | <a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a> | <a href='#TermsFilter'>TermsFilter</a> | <a href='#BooleanFilter'>BooleanFilter</a> | <a href='#DuplicateFilter'>DuplicateFilter</a>)</p><a name='Clause_occurs'></a>
+<br /><table class='attributeTitle' summary="occurs"><tr><td class='leftAttributeTitle'>
+@occurs</td><td class='rightAttributeTitle'>
+Attribute of <a href='#Clause'>Clause</a>
+</td></tr></table>
+<p>Controls if the clause is optional (should), mandatory (must) or unacceptable (mustNot)</p><p><span class='inTextTitle'>Possible values</span>: should, must, mustnot - <span class='inTextTitle'>Default value</span>: should</p><a name='CachedFilter'></a>
+<br /><table class='elementTitle' summary="CachedFilter"><tr><td class='leftElementTitle'>
+&lt;CachedFilter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Filter'>Filter</a>, <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>
+</td></tr></table>
+<p>Caches any nested query or filter in an LRU (Least recently used) Cache. Cached queries, like filters, are turned into
+Bitsets at a cost of 1 bit per document in the index. The memory cost of a cached query/filter is therefore numberOfDocsinIndex/8 bytes.
+Queries that are cached as filters obviously retain none of the scoring information associated with results - they retain just
+a Boolean yes/no record of which documents matched.</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about banks from the last 10 years - caching the commonly-used "last 10 year" filter as a BitSet in
+RAM to eliminate the cost of building this filter from disk for every query</em>
+</p><pre>	          
+            &lt;FilteredQuery&gt;
+               &lt;Query&gt;
+                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;
+               &lt;/Query&gt;	
+               &lt;Filter&gt;
+                  &lt;CachedFilter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+                  &lt;/CachedFilter&gt;
+               &lt;/Filter&gt;	
+            &lt;/FilteredQuery&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;CachedFilter&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;CachedFilter&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanFilter'>BooleanFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#BoostingQuery'>BoostingQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#DuplicateFilter'>DuplicateFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#LikeThisQuery'>LikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsFilter'>TermsFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#LikeThisQuery'>LikeThisQuery</a> | <a href='#BoostingQuery'>BoostingQuery</a> | <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a> | <a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a> | <a href='#TermsFilter'>TermsFilter</a> | <a href='#BooleanFilter'>BooleanFilter</a> | <a href='#DuplicateFilter'>DuplicateFilter</a>)</p><a name='UserQuery'></a>
+<br /><table class='elementTitle' summary="UserQuery"><tr><td class='leftElementTitle'>
+&lt;UserQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Passes content directly through to the standard LuceneQuery parser see "Lucene Query Syntax"</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about John Smith or John Doe using standard LuceneQuerySyntax</em>
+</p><pre>	          
+               &lt;UserQuery&gt;"John Smith" OR "John Doe"&lt;/UserQuery&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;UserQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;UserQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#UserQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<a name='UserQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#UserQuery'>UserQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='MatchAllDocsQuery'></a>
+<br /><table class='elementTitle' summary="MatchAllDocsQuery"><tr><td class='leftElementTitle'>
+&lt;MatchAllDocsQuery/&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>A query which is used to match all documents. This has a couple of uses:
+<ol>
+<li> as a Clause in a BooleanQuery who's only other clause
+is a "mustNot" match (Lucene requires at least one positive clause) and..</li>
+<li> in a FilteredQuery where a Filter tag is effectively being
+used to select content rather than it's usual role of filtering the results of a query.</li>
+</ol></p><p><span class='inTextTitle'>Example:</span> <em>Effectively use a Filter as a query </em>
+</p><pre>	          
+               &lt;FilteredQuery&gt;
+                 &lt;Query&gt;
+                    &lt;MatchAllDocsQuery/&gt;
+                 &lt;/Query&gt;
+                 &lt;Filter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19870409" upperTerm="19870412"/&gt;
+                 &lt;/Filter&gt;	
+               &lt;/FilteredQuery&gt;	         
+	       </pre><p></p><p class='emptyTagNote'>This element is always empty.</p><a name='TermQuery'></a>
+<br /><table class='elementTitle' summary="TermQuery"><tr><td class='leftElementTitle'>
+&lt;TermQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>a single term query - no analysis is done of the child text</p><p><span class='inTextTitle'>Example:</span> <em>Match on a primary key</em>
+</p><pre>	          
+               &lt;TermQuery fieldName="primaryKey"&gt;13424&lt;/TermQuery&gt;
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;TermQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;TermQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#TermQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#TermQuery_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='TermQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermQuery'>TermQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='TermQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermQuery'>TermQuery</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='TermsQuery'></a>
+<br /><table class='elementTitle' summary="TermsQuery"><tr><td class='leftElementTitle'>
+&lt;TermsQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>The equivalent of a BooleanQuery with multiple optional TermQuery clauses.
+Child text is analyzed using a field-specific choice of Analyzer to produce a set of terms that are ORed together in Boolean logic.
+Unlike UserQuery element, this does not parse any special characters to control fuzzy/phrase/boolean logic and as such is incapable
+of producing a Query parse error given any user input</p><p><span class='inTextTitle'>Example:</span> <em>Match on text from a database description (which may contain characters that
+are illegal characters in the standard Lucene Query syntax used in the UserQuery tag</em>
+</p><pre>	          
+               &lt;TermsQuery fieldName="description"&gt;Smith & Sons (Ltd) : incorporated 1982&lt;/TermsQuery&gt;
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;TermsQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;TermsQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#TermsQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#TermsQuery_disableCoord'>disableCoord</a></td><td>true, false</td><td>false</td></tr><tr><td><a href='#TermsQuery_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#TermsQuery_minimumNumberShouldMatch'>minimumNumberShouldMatch</a></td><td></td><td>0</td></tr></table></td></tr></table></blockquote>
+<a name='TermsQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='TermsQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='TermsQuery_disableCoord'></a>
+<br /><table class='attributeTitle' summary="disableCoord"><tr><td class='leftAttributeTitle'>
+@disableCoord</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>The "Coordination factor" rewards documents that contain more of the terms in this list. This flag can be used to turn off this factor.</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: false</p><a name='TermsQuery_minimumNumberShouldMatch'></a>
+<br /><table class='attributeTitle' summary="minimumNumberShouldMatch"><tr><td class='leftAttributeTitle'>
+@minimumNumberShouldMatch</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>The minimum number of terms that should be present in any one document before it is considered to be a match.</p><p><span class='inTextTitle'>Default value</span>: 0</p><a name='FilteredQuery'></a>
+<br /><table class='elementTitle' summary="FilteredQuery"><tr><td class='leftElementTitle'>
+&lt;FilteredQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Runs a Query and filters results to only those query matches that also match the Filter element.</p><p><span class='inTextTitle'>Example:</span> <em>Find all documents about Lucene that have a status of "published"</em>
+</p><pre>	          
+               &lt;FilteredQuery&gt;
+                 &lt;Query&gt;
+                    &lt;UserQuery&gt;Lucene&lt;/UserQuery&gt;
+                 &lt;/Query&gt;
+                 &lt;Filter&gt;
+                     &lt;TermsFilter fieldName="status"&gt;published&lt;/TermsFilter&gt;
+                 &lt;/Filter&gt;	
+               &lt;/FilteredQuery&gt;	         
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;FilteredQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;FilteredQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Filter'>Filter</a></td><td>Only one</td></tr>
+<tr><td><a href='#Query'>Query</a></td><td>Only one</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;FilteredQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;FilteredQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#FilteredQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Query'>Query</a>, <a href='#Filter'>Filter</a>)</p><a name='FilteredQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#FilteredQuery'>FilteredQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='Query'></a>
+<br /><table class='elementTitle' summary="Query"><tr><td class='leftElementTitle'>
+&lt;Query&gt;</td><td class='rightElementTitle'>
+Child of <a href='#FilteredQuery'>FilteredQuery</a>, <a href='#BoostingQuery'>BoostingQuery</a>
+</td></tr></table>
+<p>Used to identify a nested Query element inside another container element. NOT a top-level query tag</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Query&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Query&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#BoostingQuery'>BoostingQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#LikeThisQuery'>LikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#LikeThisQuery'>LikeThisQuery</a> | <a href='#BoostingQuery'>BoostingQuery</a> | <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>)</p><a name='Filter'></a>
+<br /><table class='elementTitle' summary="Filter"><tr><td class='leftElementTitle'>
+&lt;Filter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#FilteredQuery'>FilteredQuery</a>
+</td></tr></table>
+<p>The choice of Filter that MUST also be matched</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Filter&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Filter&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanFilter'>BooleanFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#DuplicateFilter'>DuplicateFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsFilter'>TermsFilter</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a> | <a href='#TermsFilter'>TermsFilter</a> | <a href='#BooleanFilter'>BooleanFilter</a> | <a href='#DuplicateFilter'>DuplicateFilter</a>)</p><a name='RangeFilter'></a>
+<br /><table class='elementTitle' summary="RangeFilter"><tr><td class='leftElementTitle'>
+&lt;RangeFilter/&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Filter'>Filter</a>, <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Filter used to limit query results to documents matching a range of field values</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about banks from the last 10 years</em>
+</p><pre>	          
+            &lt;FilteredQuery&gt;
+               &lt;Query&gt;
+                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;
+               &lt;/Query&gt;	
+               &lt;Filter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+               &lt;/Filter&gt;	
+            &lt;/FilteredQuery&gt;
+	         </pre><p></p><blockquote>
+<table  summary="&lt;RangeFilter&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;RangeFilter&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#RangeFilter_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#RangeFilter_includeLower'>includeLower</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#RangeFilter_includeUpper'>includeUpper</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#RangeFilter_lowerTerm'>lowerTerm</a></td><td></td><td></td></tr><tr><td><a href='#RangeFilter_upperTerm'>upperTerm</a></td><td></td><td></td></tr></table></blockquote>
+<p class='emptyTagNote'>This element is always empty.</p><a name='RangeFilter_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='RangeFilter_lowerTerm'></a>
+<br /><table class='attributeTitle' summary="lowerTerm"><tr><td class='leftAttributeTitle'>
+@lowerTerm</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>The lower-most term value for this field (must be &lt;= upperTerm)</p><p><span class='inTextTitle'>Required</span></p><a name='RangeFilter_upperTerm'></a>
+<br /><table class='attributeTitle' summary="upperTerm"><tr><td class='leftAttributeTitle'>
+@upperTerm</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>The upper-most term value for this field (must be >= lowerTerm)</p><p><span class='inTextTitle'>Required</span></p><a name='RangeFilter_includeLower'></a>
+<br /><table class='attributeTitle' summary="includeLower"><tr><td class='leftAttributeTitle'>
+@includeLower</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>Controls if the lowerTerm in the range is part of the allowed set of values</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='RangeFilter_includeUpper'></a>
+<br /><table class='attributeTitle' summary="includeUpper"><tr><td class='leftAttributeTitle'>
+@includeUpper</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>Controls if the upperTerm in the range is part of the allowed set of values</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='SpanTerm'></a>
+<br /><table class='elementTitle' summary="SpanTerm"><tr><td class='leftElementTitle'>
+&lt;SpanTerm&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>A single term used in a SpanQuery. These clauses are the building blocks for more complex "span" queries which test word proximity</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms close to each other about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;SpanTerm&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanTerm&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanTerm_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='SpanTerm_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanTerm'>SpanTerm</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><p><span class='inTextTitle'>Required</span></p><a name='SpanOrTerms'></a>
+<br /><table class='elementTitle' summary="SpanOrTerms"><tr><td class='leftElementTitle'>
+&lt;SpanOrTerms&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>A field-specific analyzer is used here to parse the child text provided in this tag. The SpanTerms produced are ORed in terms of Boolean logic</p><p><span class='inTextTitle'>Example:</span> <em>Use SpanOrTerms as a more convenient/succinct way of expressing multiple choices of SpanTerms. This example looks for reports
+using words describing a fatality near to references to miners</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOrTerms&gt;killed died death dead deaths&lt;/SpanOrTerms&gt;
+			&lt;SpanOrTerms&gt;miner mining miners&lt;/SpanOrTerms&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;SpanOrTerms&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanOrTerms&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanOrTerms_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='SpanOrTerms_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanOrTerms'>SpanOrTerms</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><p><span class='inTextTitle'>Required</span></p><a name='SpanOr'></a>
+<br /><table class='elementTitle' summary="SpanOr"><tr><td class='leftElementTitle'>
+&lt;SpanOr&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>Takes any number of child queries from the Span family</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms close to each other about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanOr&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanOr&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>Any number</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)*</p><a name='SpanNear'></a>
+<br /><table class='elementTitle' summary="SpanNear"><tr><td class='leftElementTitle'>
+&lt;SpanNear&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Takes any number of child queries from the Span family and tests for proximity</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanNear&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanNear&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>Any number</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;SpanNear&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanNear&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanNear_inOrder'>inOrder</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#SpanNear_slop'>slop</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)*</p><a name='SpanNear_slop'></a>
+<br /><table class='attributeTitle' summary="slop"><tr><td class='leftAttributeTitle'>
+@slop</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>defines the maximum distance between Span elements where distance is expressed as word number, not byte offset</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms within 8 words of each other talking about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><p><span class='inTextTitle'>Required</span></p><a name='SpanNear_inOrder'></a>
+<br /><table class='attributeTitle' summary="inOrder"><tr><td class='leftAttributeTitle'>
+@inOrder</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>Controls if matching terms have to appear in the order listed or can be reversed</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='SpanFirst'></a>
+<br /><table class='elementTitle' summary="SpanFirst"><tr><td class='leftElementTitle'>
+&lt;SpanFirst&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>Looks for a SpanQuery match occuring near the beginning of a document</p><p><span class='inTextTitle'>Example:</span> <em>Find letters where the first 50 words talk about a resignation:</em>
+</p><pre>	          
+	         &lt;SpanFirst end="50"&gt;
+	               &lt;SpanOrTerms fieldName="text"&gt;resigning resign leave&lt;/SpanOrTerms&gt;
+	         &lt;/SpanFirst&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanFirst&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanFirst&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;SpanFirst&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanFirst&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanFirst_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#SpanFirst_end'>end</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='SpanFirst_end'></a>
+<br /><table class='attributeTitle' summary="end"><tr><td class='leftAttributeTitle'>
+@end</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanFirst'>SpanFirst</a>
+</td></tr></table>
+<p>Controls the end of the region considered in a document's field (expressed in word number, not byte offset)</p><p><span class='inTextTitle'>Required</span></p><a name='SpanFirst_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanFirst'>SpanFirst</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='SpanNot'></a>
+<br /><table class='elementTitle' summary="SpanNot"><tr><td class='leftElementTitle'>
+&lt;SpanNot&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>Finds documents matching a SpanQuery but not if matching another SpanQuery</p><p><span class='inTextTitle'>Example:</span> <em>Find documents talking about social services but not containing the word "public"</em>
+</p><pre>
+          &lt;SpanNot fieldName="text"&gt;
+             &lt;Include&gt;
+                &lt;SpanNear slop="2" inOrder="true"&gt;		
+                     &lt;SpanTerm&gt;social&lt;/SpanTerm&gt;
+                     &lt;SpanTerm&gt;services&lt;/SpanTerm&gt;
+                &lt;/SpanNear&gt;				
+             &lt;/Include&gt;
+             &lt;Exclude&gt;
+                &lt;SpanTerm&gt;public&lt;/SpanTerm&gt;
+             &lt;/Exclude&gt;
+          &lt;/SpanNot&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanNot&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanNot&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Exclude'>Exclude</a></td><td>Only one</td></tr>
+<tr><td><a href='#Include'>Include</a></td><td>Only one</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>)</p><a name='Include'></a>
+<br /><table class='elementTitle' summary="Include"><tr><td class='leftElementTitle'>
+&lt;Include&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNot'>SpanNot</a>
+</td></tr></table>
+<p>The SpanQuery to find</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Include&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Include&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='Exclude'></a>
+<br /><table class='elementTitle' summary="Exclude"><tr><td class='leftElementTitle'>
+&lt;Exclude&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNot'>SpanNot</a>
+</td></tr></table>
+<p>The SpanQuery to be avoided</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Exclude&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Exclude&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='ConstantScoreQuery'></a>
+<br /><table class='elementTitle' summary="ConstantScoreQuery"><tr><td class='leftElementTitle'>
+&lt;ConstantScoreQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>a utility tag to wrap any filter as a query</p><p><span class='inTextTitle'>Example:</span> <em> Find all documents from the last 10 years </em>
+</p><pre>
+     &lt;ConstantScoreQuery&gt;
+           &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+     &lt;/ConstantScoreQuery&gt;	
+	</pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;ConstantScoreQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;ConstantScoreQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanFilter'>BooleanFilter</a></td><td>Any number</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>Any number</td></tr>
+<tr><td><a href='#DuplicateFilter'>DuplicateFilter</a></td><td>Any number</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>Any number</td></tr>
+<tr><td><a href='#TermsFilter'>TermsFilter</a></td><td>Any number</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;ConstantScoreQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;ConstantScoreQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#ConstantScoreQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a> | <a href='#TermsFilter'>TermsFilter</a> | <a href='#BooleanFilter'>BooleanFilter</a> | <a href='#DuplicateFilter'>DuplicateFilter</a>)*</p><a name='ConstantScoreQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='FuzzyLikeThisQuery'></a>
+<br /><table class='elementTitle' summary="FuzzyLikeThisQuery"><tr><td class='leftElementTitle'>
+&lt;FuzzyLikeThisQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Performs fuzzy matching on "significant" terms in fields. Improves on "LikeThisQuery" by allowing for fuzzy variations of supplied fields.
+Improves on FuzzyQuery by rewarding all fuzzy variants of a term with the same IDF rather than default fuzzy behaviour which ranks rarer
+variants (typically misspellings) more highly. This can be a useful default search mode for processing user input where the end user
+is not expected to know about the standard query operators for fuzzy, boolean or phrase logic found in UserQuery</p><p><span class='inTextTitle'>Example:</span> <em>Search for information about the Sumitomo bank, where the end user has mis-spelt the name</em>
+</p><pre>	          
+            &lt;FuzzyLikeThisQuery&gt;
+                &lt;Field fieldName="contents"&gt;
+		             Sumitimo bank
+	            &lt;/Field&gt;
+            &lt;/FuzzyLikeThisQuery&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;FuzzyLikeThisQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;FuzzyLikeThisQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Field'>Field</a></td><td>Any number</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;FuzzyLikeThisQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;FuzzyLikeThisQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#FuzzyLikeThisQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#FuzzyLikeThisQuery_ignoreTF'>ignoreTF</a></td><td>true, false</td><td>false</td></tr><tr><td><a href='#FuzzyLikeThisQuery_maxNumTerms'>maxNumTerms</a></td><td></td><td>50</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Field'>Field</a>)*</p><a name='FuzzyLikeThisQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='FuzzyLikeThisQuery_maxNumTerms'></a>
+<br /><table class='attributeTitle' summary="maxNumTerms"><tr><td class='leftAttributeTitle'>
+@maxNumTerms</td><td class='rightAttributeTitle'>
+Attribute of <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>
+</td></tr></table>
+<p>Limits the total number of terms selected from the provided text plus the selected "fuzzy" variants</p><p><span class='inTextTitle'>Default value</span>: 50</p><a name='FuzzyLikeThisQuery_ignoreTF'></a>
+<br /><table class='attributeTitle' summary="ignoreTF"><tr><td class='leftAttributeTitle'>
+@ignoreTF</td><td class='rightAttributeTitle'>
+Attribute of <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>
+</td></tr></table>
+<p>Ignore "Term Frequency" - a boost factor which rewards multiple occurences of the same term in a document</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: false</p><a name='Field'></a>
+<br /><table class='elementTitle' summary="Field"><tr><td class='leftElementTitle'>
+&lt;Field&gt;</td><td class='rightElementTitle'>
+Child of <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>
+</td></tr></table>
+<p>A field used in a FuzzyLikeThisQuery</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;Field&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;Field&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#Field_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#Field_minSimilarity'>minSimilarity</a></td><td></td><td>0.5</td></tr><tr><td><a href='#Field_prefixLength'>prefixLength</a></td><td></td><td>1</td></tr></table></td></tr></table></blockquote>
+<a name='Field_minSimilarity'></a>
+<br /><table class='attributeTitle' summary="minSimilarity"><tr><td class='leftAttributeTitle'>
+@minSimilarity</td><td class='rightAttributeTitle'>
+Attribute of <a href='#Field'>Field</a>
+</td></tr></table>
+<p>Controls the level of similarity required for fuzzy variants where 1 is identical and 0.5 is that the variant contains
+half of the original's characters in the same order. Lower values produce more results but may take longer to execute due to
+additional IO required to read matching document ids</p><p><span class='inTextTitle'>Default value</span>: 0.5</p><a name='Field_prefixLength'></a>
+<br /><table class='attributeTitle' summary="prefixLength"><tr><td class='leftAttributeTitle'>
+@prefixLength</td><td class='rightAttributeTitle'>
+Attribute of <a href='#Field'>Field</a>
+</td></tr></table>
+<p>Controls the minimum number of characters at the start of fuzzy variant words that must exactly match the original.
+A value of zero will require no minimum and the search software will effectively scan ALL terms from a to z looking for variations.
+This can incur high CPU overhead and a prefix length of just "1" will reduce this overhead to 1/26th of the original cost (assuming
+an even distribution of letters used from the alphabet).</p><p><span class='inTextTitle'>Default value</span>: 1</p><a name='Field_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#Field'>Field</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='LikeThisQuery'></a>
+<br /><table class='elementTitle' summary="LikeThisQuery"><tr><td class='leftElementTitle'>
+&lt;LikeThisQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Cherry-picks "significant" terms from the example child text and queries using these words. By only using significant (read: rare) terms the
+performance cost of the query is substantially reduced and large bodies of text can be used as example content.</p><p><span class='inTextTitle'>Example:</span> <em>Use a block of text as an example of the type of content to be found, ignoring the "Reuters" word which
+appears commonly in the index.</em>
+</p><pre>
+            &lt;LikeThisQuery percentTermsToMatch="5" stopWords="Reuters"&gt;
+                IRAQI TROOPS REPORTED PUSHING BACK IRANIANS Iraq said today its troops were pushing Iranian forces out of 
+                positions they had initially occupied when they launched a new offensive near the southern port of 
+                Basra early yesterday.     A High Command communique said Iraqi troops had won a significant victory 
+                and were continuing to advance.     Iraq said it had foiled a three-pronged thrust some 10 km 
+                (six miles) from Basra, but admitted the Iranians had occupied ground held by the Mohammed al-Qassem 
+                unit, one of three divisions attacked.     The communique said Iranian Revolutionary Guards were under 
+                assault from warplanes, helicopter gunships, heavy artillery and tanks.     "Our forces are continuing 
+                their advance until they purge the last foothold" occupied by the Iranians, it said.     
+                (Iran said its troops had killed or wounded more than 4,000 Iraqis and were stabilising their new positions.)     
+                The Baghdad communique said Iraqi planes also destroyed oil installations at Iran's southwestern Ahvaz field 
+                during a raid today. It denied an Iranian report that an Iraqi jet was shot down.     
+                Iraq also reported a naval battle at the northern tip of the Gulf. Iraqi naval units and forces defending an 
+                offshore terminal sank six Iranian out of 28 Iranian boats attempting to attack an offshore terminal, 
+                the communique said.      Reuters 3;
+            &lt;/LikeThisQuery&gt;	         
+	        </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;LikeThisQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;LikeThisQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#LikeThisQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#LikeThisQuery_fieldNames'>fieldNames</a></td><td></td><td></td></tr><tr><td><a href='#LikeThisQuery_maxQueryTerms'>maxQueryTerms</a></td><td></td><td>20</td></tr><tr><td><a href='#LikeThisQuery_minTermFrequency'>minTermFrequency</a></td><td></td><td>1</td></tr><tr><td><a href='#LikeThisQuery_percentTermsToMatch'>percentTermsToMatch</a></td><td></td><td>30</td></tr><tr><td><a href='#LikeThisQuery_stopWords'>stopWords</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='LikeThisQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='LikeThisQuery_fieldNames'></a>
+<br /><table class='attributeTitle' summary="fieldNames"><tr><td class='leftAttributeTitle'>
+@fieldNames</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>Comma delimited list of field names</p><a name='LikeThisQuery_stopWords'></a>
+<br /><table class='attributeTitle' summary="stopWords"><tr><td class='leftAttributeTitle'>
+@stopWords</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>a list of stop words - analyzed to produce stop terms</p><a name='LikeThisQuery_maxQueryTerms'></a>
+<br /><table class='attributeTitle' summary="maxQueryTerms"><tr><td class='leftAttributeTitle'>
+@maxQueryTerms</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>controls the maximum number of words shortlisted for the query. The higher the number the slower the response due to more disk reads required</p><p><span class='inTextTitle'>Default value</span>: 20</p><a name='LikeThisQuery_minTermFrequency'></a>
+<br /><table class='attributeTitle' summary="minTermFrequency"><tr><td class='leftAttributeTitle'>
+@minTermFrequency</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>Controls how many times a term must appear in the example text before it is shortlisted for use in the query</p><p><span class='inTextTitle'>Default value</span>: 1</p><a name='LikeThisQuery_percentTermsToMatch'></a>
+<br /><table class='attributeTitle' summary="percentTermsToMatch"><tr><td class='leftAttributeTitle'>
+@percentTermsToMatch</td><td class='rightAttributeTitle'>
+Attribute of <a href='#LikeThisQuery'>LikeThisQuery</a>
+</td></tr></table>
+<p>A quality control that can be used to limit the number of results to those documents matching a certain percentage of the shortlisted query terms.
+Values must be between 1 and 100</p><p><span class='inTextTitle'>Default value</span>: 30</p><a name='BoostingQuery'></a>
+<br /><table class='elementTitle' summary="BoostingQuery"><tr><td class='leftElementTitle'>
+&lt;BoostingQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Clause'>Clause</a>, <a href='#BoostQuery'>BoostQuery</a>, <a href='#Query'>Query</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Requires matches on the "Query" element and optionally boosts by any matches on the "BoostQuery".
+Unlike a regular BooleanQuery the boost can be less than 1 to produce a subtractive rather than additive result
+on the match score.</p><p><span class='inTextTitle'>Example:</span> <em>Find documents about banks, preferably related to mergers, and preferably not about "World bank"</em>
+</p><pre>
+	&lt;BoostingQuery&gt;
+      &lt;Query&gt;
+         &lt;BooleanQuery fieldName="contents"&gt;
+           &lt;Clause occurs="should"&gt;
+              &lt;TermQuery&gt;merger&lt;/TermQuery&gt;
+           &lt;/Clause&gt;
+           &lt;Clause occurs="must"&gt;
+              &lt;TermQuery&gt;bank&lt;/TermQuery&gt;
+           &lt;/Clause&gt;
+         &lt;/BooleanQuery&gt;	
+      &lt;/Query&gt;
+      &lt;BoostQuery boost="0.01"&gt;
+         &lt;UserQuery&gt;"world bank"&lt;/UserQuery&gt;
+      &lt;/BoostQuery&gt;
+    &lt;/BoostingQuery&gt;
+	</pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;BoostingQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;BoostingQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BoostQuery'>BoostQuery</a></td><td>Only one</td></tr>
+<tr><td><a href='#Query'>Query</a></td><td>Only one</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;BoostingQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;BoostingQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#BoostingQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Query'>Query</a>, <a href='#BoostQuery'>BoostQuery</a>)</p><a name='BoostingQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BoostingQuery'>BoostingQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='BoostQuery'></a>
+<br /><table class='elementTitle' summary="BoostQuery"><tr><td class='leftElementTitle'>
+&lt;BoostQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#BoostingQuery'>BoostingQuery</a>
+</td></tr></table>
+<p>Child element of BoostingQuery used to contain the choice of Query which is used for boosting purposes</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;BoostQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;BoostQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#BoostingQuery'>BoostingQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#LikeThisQuery'>LikeThisQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;BoostQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;BoostQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#BoostQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#LikeThisQuery'>LikeThisQuery</a> | <a href='#BoostingQuery'>BoostingQuery</a> | <a href='#FuzzyLikeThisQuery'>FuzzyLikeThisQuery</a>)</p><a name='BoostQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BoostQuery'>BoostQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. A boost of >0 but &lt;1
+effectively demotes results from Query that match this BoostQuery.</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='DuplicateFilter'></a>
+<br /><table class='elementTitle' summary="DuplicateFilter"><tr><td class='leftElementTitle'>
+&lt;DuplicateFilter/&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Filter'>Filter</a>, <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Removes duplicated documents from results where "duplicate" means documents share a value for a particular field such as a primary key</p><p><span class='inTextTitle'>Example:</span> <em>Find the latest version of each web page that mentions "Lucene"</em>
+</p><pre>
+    &lt;FilteredQuery&gt;
+      &lt;Query&gt;
+         &lt;TermQuery fieldName="text"&gt;lucene&lt;/TermQuery&gt;
+      &lt;/Query&gt;
+	  &lt;Filter&gt;
+		&lt;DuplicateFilter fieldName="url" keepMode="last"/&gt;
+	  &lt;/Filter&gt;	
+    &lt;/FilteredQuery&gt;	
+	</pre><p></p><blockquote>
+<table  summary="&lt;DuplicateFilter&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;DuplicateFilter&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#DuplicateFilter_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#DuplicateFilter_keepMode'>keepMode</a></td><td>first, last</td><td>first</td></tr><tr><td><a href='#DuplicateFilter_processingMode'>processingMode</a></td><td>full, fast</td><td>full</td></tr></table></blockquote>
+<p class='emptyTagNote'>This element is always empty.</p><a name='DuplicateFilter_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#DuplicateFilter'>DuplicateFilter</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='DuplicateFilter_keepMode'></a>
+<br /><table class='attributeTitle' summary="keepMode"><tr><td class='leftAttributeTitle'>
+@keepMode</td><td class='rightAttributeTitle'>
+Attribute of <a href='#DuplicateFilter'>DuplicateFilter</a>
+</td></tr></table>
+<p>Determines if the first or last document occurence is the one to return when presented with duplicated field values</p><p><span class='inTextTitle'>Possible values</span>: first, last - <span class='inTextTitle'>Default value</span>: first</p><a name='DuplicateFilter_processingMode'></a>
+<br /><table class='attributeTitle' summary="processingMode"><tr><td class='leftAttributeTitle'>
+@processingMode</td><td class='rightAttributeTitle'>
+Attribute of <a href='#DuplicateFilter'>DuplicateFilter</a>
+</td></tr></table>
+<p>Controls the choice of process used to produce the filter - "full" mode identifies only non-duplicate documents with the chosen field
+while "fast" mode may perform faster but will also mark documents <em>without</em> the field as valid. The former approach starts by
+assuming every document is a duplicate then finds the "master" documents to keep while the latter approach assumes all documents are
+unique and unmarks those documents that are a copy.</p><p><span class='inTextTitle'>Possible values</span>: full, fast - <span class='inTextTitle'>Default value</span>: full</p><a name='TermsFilter'></a>
+<br /><table class='elementTitle' summary="TermsFilter"><tr><td class='leftElementTitle'>
+&lt;TermsFilter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Filter'>Filter</a>, <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Processes child text using a field-specific choice of Analyzer to produce a set of terms that are then used as a filter.</p><p><span class='inTextTitle'>Example:</span> <em>Find documents talking about Lucene written on a Monday or a Friday</em>
+</p><pre>
+    &lt;FilteredQuery&gt;
+      &lt;Query&gt;
+         &lt;TermQuery fieldName="text"&gt;lucene&lt;/TermQuery&gt;
+      &lt;/Query&gt;
+	&lt;Filter&gt;
+		&lt;TermsFilter fieldName="dayOfWeek"&gt;monday friday&lt;/TermsFilter&gt; 
+	&lt;/Filter&gt;	
+    &lt;/FilteredQuery&gt;	
+	</pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;TermsFilter&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;TermsFilter&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#TermsFilter_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='TermsFilter_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsFilter'>TermsFilter</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='BooleanFilter'></a>
+<br /><table class='elementTitle' summary="BooleanFilter"><tr><td class='leftElementTitle'>
+&lt;BooleanFilter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Filter'>Filter</a>, <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>A Filter equivalent to BooleanQuery that applies Boolean logic to Clauses containing Filters.
+Unlike BooleanQuery a BooleanFilter can contain a single "mustNot" clause.</p><p><span class='inTextTitle'>Example:</span> <em>Find documents from the first quarter of this year or last year that are not in "draft" status</em>
+</p><pre>
+     &lt;FilteredQuery&gt;
+       &lt;Query&gt;
+           &lt;MatchAllDocsQuery/&gt;
+       &lt;/Query&gt;
+       &lt;Filter&gt;
+        &lt;BooleanFilter&gt;
+          &lt;Clause occurs="should"&gt;
+             &lt;RangeFilter fieldName="date" lowerTerm="20070101" upperTerm="20070401"/&gt;
+          &lt;/Clause&gt;
+          &lt;Clause occurs="should"&gt;
+             &lt;RangeFilter fieldName="date" lowerTerm="20060101" upperTerm="20060401"/&gt;
+          &lt;/Clause&gt;
+          &lt;Clause occurs="mustNot"&gt;
+             &lt;TermsFilter fieldName="status"&gt;draft&lt;/TermsFilter&gt; 
+          &lt;/Clause&gt;
+        &lt;/BooleanFilter&gt;
+       &lt;/Filter&gt;
+    &lt;/FilteredQuery&gt;
+	</pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;BooleanFilter&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;BooleanFilter&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Clause'>Clause</a></td><td>At least one</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Clause'>Clause</a>)+</p></body></html>
diff --git a/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.org.html b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.org.html
new file mode 100644
index 0000000..a4e2e0f
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneContribQuery.dtd.org.html
@@ -0,0 +1,237 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html> <head>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+<title>Contrib Lucene</title>
+</head><body>
+<p class='DTDSource'><b><code>LuceneContribQuery.dtd</code></b>: <a href='LuceneContribQuery.dtd.html'>Elements</a> - <a href='LuceneContribQuery.dtd.entities.html'>Entities</a> - <a href='LuceneContribQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneContribQuery.dtd.org.html' target='_top'>NO FRAMES</a></p><pre id='dtd_source'><span class="dtd_comment">&lt;!--    </span>
+<span class="dtd_comment">    This DTD builds on the &lt;a href=&quot;LuceneCoreQuery.dtd.html&quot;&gt;core Lucene XML syntax&lt;/a&gt; and adds support for features found in the &quot;contrib&quot; section of the Lucene project.</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    CorePlusExtensionsParser.java is the Java class that encapsulates this parser behaviour.</span>
+
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    The features added are:</span>
+<span class="dtd_comment">    &lt;ul&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#LikeThisQuery&quot;&gt;LikeThisQuery&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       Support for querying using large amounts of example text indicative of the users' general area of interest</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#FuzzyLikeThisQuery&quot;&gt;FuzzyLikeThisQuery&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       A style of fuzzy query which automatically looks for fuzzy variations on only the &quot;interesting&quot; terms </span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#BooleanFilter&quot;&gt;BooleanFilter&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       Is to Filters what core Lucene's BooleanQuery is to Queries - allows mixing of clauses using Boolean logic</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#TermsFilter&quot;&gt;TermsFilter&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       Constructs a filter from an arbitrary set of terms (unlike &lt;a href=&quot;#RangeFilter&quot;&gt;RangeFilter&lt;/a&gt; which requires a contiguous range of terms)</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#DuplicateFilter&quot;&gt;DuplicateFilter&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       Removes duplicated documents from results where &quot;duplicate&quot; means documents share a value for a particular field (e.g. a primary key)</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;a href=&quot;#BoostingQuery&quot;&gt;BoostingQuery&lt;/a&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">       Influence score of a query's matches in a subtle way which can't be achieved using BooleanQuery</span>
+<span class="dtd_comment">    &lt;/ul&gt;</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@title</span><span class="dtd_comment"> Contrib Lucene</span>
+<span class="dtd_comment">--&gt;</span>
+<span class="dtd_comment">&lt;!-- </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> include the core DTD --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">coreParserDTD</span><span class="dtd_plain"> </span><span class="dtd_keyword">SYSTEM</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;LuceneCoreQuery.dtd&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_comment">&lt;!-- </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> Allow for extensions --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedSpanQueries2</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedQueries2</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedFilters2</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedQueries1</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;|LikeThisQuery|BoostingQuery|FuzzyLikeThisQuery%extendedQueries2;%extendedSpanQueries2;&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedFilters1</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;|TermsFilter|BooleanFilter|DuplicateFilter%extendedFilters2;&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_plain">%coreParserDTD;</span>
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">Performs fuzzy matching on &quot;significant&quot; terms in fields. Improves on &quot;LikeThisQuery&quot; by allowing for fuzzy variations of supplied fields.</span>
+<span class="dtd_comment">Improves on FuzzyQuery by rewarding all fuzzy variants of a term with the same IDF rather than default fuzzy behaviour which ranks rarer</span>
+<span class="dtd_comment">    variants (typically misspellings) more highly. This can be a useful default search mode for processing user input where the end user</span>
+<span class="dtd_comment">    is not expected to know about the standard query operators for fuzzy, boolean or phrase logic found in UserQuery</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Search for information about the Sumitomo bank, where the end user has mis-spelt the name&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">            &lt;FuzzyLikeThisQuery&gt;</span>
+<span class="dtd_comment">                &lt;Field fieldName=&quot;contents&quot;&gt;</span>
+<span class="dtd_comment">                     Sumitimo bank</span>
+<span class="dtd_comment">                &lt;/Field&gt;</span>
+<span class="dtd_comment">            &lt;/FuzzyLikeThisQuery&gt;</span>
+<span class="dtd_comment">             %  </span>
+<span class="dtd_comment">--&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FuzzyLikeThisQuery</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Field</span><span class="dtd_plain">)*</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FuzzyLikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Limits the total number of terms selected from the provided text plus the selected &quot;fuzzy&quot; variants --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FuzzyLikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">maxNumTerms</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;50&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Ignore &quot;Term Frequency&quot; - a boost factor which rewards multiple occurences of the same term in a document --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FuzzyLikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">ignoreTF</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain">|</span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;false&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- A field used in a FuzzyLikeThisQuery --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Field</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls the level of similarity required for fuzzy variants where 1 is identical and 0.5 is that the variant contains </span>
+<span class="dtd_comment">    half of the original's characters in the same order. Lower values produce more results but may take longer to execute due to</span>
+<span class="dtd_comment">    additional IO required to read matching document ids--&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Field</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">minSimilarity</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;0.5&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls the minimum number of characters at the start of fuzzy variant words that must exactly match the original.</span>
+<span class="dtd_comment">    A value of zero will require no minimum and the search software will effectively scan ALL terms from a to z looking for variations.</span>
+<span class="dtd_comment">    This can incur high CPU overhead and a prefix length of just &quot;1&quot; will reduce this overhead to 1/26th of the original cost (assuming</span>
+<span class="dtd_comment">    an even distribution of letters used from the alphabet).</span>
+<span class="dtd_comment"> --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Field</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">prefixLength</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Field</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    Cherry-picks &quot;significant&quot; terms from the example child text and queries using these words. By only using significant (read: rare) terms the</span>
+<span class="dtd_comment">    performance cost of the query is substantially reduced and large bodies of text can be used as example content.</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Use a block of text as an example of the type of content to be found, ignoring the &quot;Reuters&quot; word which</span>
+<span class="dtd_comment">           appears commonly in the index.&lt;/em&gt;</span>
+<span class="dtd_comment">            %</span>
+<span class="dtd_comment">            &lt;LikeThisQuery percentTermsToMatch=&quot;5&quot; stopWords=&quot;Reuters&quot;&gt;</span>
+<span class="dtd_comment">                IRAQI TROOPS REPORTED PUSHING BACK IRANIANS Iraq said today its troops were pushing Iranian forces out of </span>
+<span class="dtd_comment">                positions they had initially occupied when they launched a new offensive near the southern port of </span>
+<span class="dtd_comment">                Basra early yesterday.     A High Command communique said Iraqi troops had won a significant victory </span>
+<span class="dtd_comment">                and were continuing to advance.     Iraq said it had foiled a three-pronged thrust some 10 km </span>
+<span class="dtd_comment">                (six miles) from Basra, but admitted the Iranians had occupied ground held by the Mohammed al-Qassem </span>
+<span class="dtd_comment">                unit, one of three divisions attacked.     The communique said Iranian Revolutionary Guards were under </span>
+<span class="dtd_comment">                assault from warplanes, helicopter gunships, heavy artillery and tanks.     &quot;Our forces are continuing </span>
+<span class="dtd_comment">                their advance until they purge the last foothold&quot; occupied by the Iranians, it said.     </span>
+<span class="dtd_comment">                (Iran said its troops had killed or wounded more than 4,000 Iraqis and were stabilising their new positions.)     </span>
+<span class="dtd_comment">                The Baghdad communique said Iraqi planes also destroyed oil installations at Iran's southwestern Ahvaz field </span>
+<span class="dtd_comment">                during a raid today. It denied an Iranian report that an Iraqi jet was shot down.     </span>
+<span class="dtd_comment">                Iraq also reported a naval battle at the northern tip of the Gulf. Iraqi naval units and forces defending an </span>
+<span class="dtd_comment">                offshore terminal sank six Iranian out of 28 Iranian boats attempting to attack an offshore terminal, </span>
+<span class="dtd_comment">                the communique said.      Reuters 3;</span>
+<span class="dtd_comment">            &lt;/LikeThisQuery&gt;             </span>
+<span class="dtd_comment">            %   </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Comma delimited list of field names --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldNames</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- a list of stop words - analyzed to produce stop terms --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">stopWords</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- controls the maximum number of words shortlisted for the query. The higher the number the slower the response due to more disk reads required --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">maxQueryTerms</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;20&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls how many times a term must appear in the example text before it is shortlisted for use in the query --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">minTermFrequency</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- A quality control that can be used to limit the number of results to those documents matching a certain percentage of the shortlisted query terms.</span>
+<span class="dtd_comment">    Values must be between 1 and 100--&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">LikeThisQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">percentTermsToMatch</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;30&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    Requires matches on the &quot;Query&quot; element and optionally boosts by any matches on the &quot;BoostQuery&quot;.</span>
+<span class="dtd_comment">    Unlike a regular BooleanQuery the boost can be less than 1 to produce a subtractive rather than additive result</span>
+<span class="dtd_comment">    on the match score. </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents about banks, preferably related to mergers, and preferably not about &quot;World bank&quot;&lt;/em&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    &lt;BoostingQuery&gt;</span>
+<span class="dtd_comment">      &lt;Query&gt;</span>
+<span class="dtd_comment">         &lt;BooleanQuery fieldName=&quot;contents&quot;&gt;</span>
+<span class="dtd_comment">           &lt;Clause occurs=&quot;should&quot;&gt;</span>
+<span class="dtd_comment">              &lt;TermQuery&gt;merger&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">           &lt;/Clause&gt;</span>
+<span class="dtd_comment">           &lt;Clause occurs=&quot;must&quot;&gt;</span>
+<span class="dtd_comment">              &lt;TermQuery&gt;bank&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">           &lt;/Clause&gt;</span>
+<span class="dtd_comment">         &lt;/BooleanQuery&gt;    </span>
+<span class="dtd_comment">      &lt;/Query&gt;</span>
+<span class="dtd_comment">      &lt;BoostQuery boost=&quot;0.01&quot;&gt;</span>
+<span class="dtd_comment">         &lt;UserQuery&gt;&quot;world bank&quot;&lt;/UserQuery&gt;</span>
+<span class="dtd_comment">      &lt;/BoostQuery&gt;</span>
+<span class="dtd_comment">    &lt;/BoostingQuery&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BoostingQuery</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Query</span><span class="dtd_plain">,</span><span class="dtd_attribute_name">BoostQuery</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BoostingQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    Child element of BoostingQuery used to contain the choice of Query which is used for boosting purposes</span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BoostQuery</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">queries</span><span class="dtd_plain">;)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. A boost of &gt;0 but &lt;1 </span>
+<span class="dtd_comment">    effectively demotes results from Query that match this BoostQuery.      </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BoostQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+<span class="dtd_comment">&lt;!-- Removes duplicated documents from results where &quot;duplicate&quot; means documents share a value for a particular field such as a primary key</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find the latest version of each web page that mentions &quot;Lucene&quot;&lt;/em&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">      &lt;Query&gt;</span>
+<span class="dtd_comment">         &lt;TermQuery fieldName=&quot;text&quot;&gt;lucene&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">      &lt;/Query&gt;</span>
+<span class="dtd_comment">      &lt;Filter&gt;</span>
+<span class="dtd_comment">        &lt;DuplicateFilter fieldName=&quot;url&quot; keepMode=&quot;last&quot;/&gt;</span>
+<span class="dtd_comment">      &lt;/Filter&gt; </span>
+<span class="dtd_comment">    &lt;/FilteredQuery&gt;    </span>
+<span class="dtd_comment">    %   </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">DuplicateFilter</span><span class="dtd_plain"> </span><span class="dtd_keyword">EMPTY</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">DuplicateFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Determines if the first or last document occurence is the one to return when presented with duplicated field values --&gt;</span><span class="dtd_plain">    </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">DuplicateFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">keepMode</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">first</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">last</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;first&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls the choice of process used to produce the filter - &quot;full&quot; mode identifies only non-duplicate documents with the chosen field </span>
+<span class="dtd_comment">    while &quot;fast&quot; mode may perform faster but will also mark documents &lt;em&gt;without&lt;/em&gt; the field as valid. The former approach starts by </span>
+<span class="dtd_comment">    assuming every document is a duplicate then finds the &quot;master&quot; documents to keep while the latter approach assumes all documents are </span>
+<span class="dtd_comment">    unique and  unmarks those documents that are a copy. </span>
+<span class="dtd_comment">    --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">DuplicateFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">processingMode</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">full</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">fast</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;full&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+
+<span class="dtd_comment">&lt;!-- Processes child text using a field-specific choice of Analyzer to produce a set of terms that are then used as a filter.</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents talking about Lucene written on a Monday or a Friday&lt;/em&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">      &lt;Query&gt;</span>
+<span class="dtd_comment">         &lt;TermQuery fieldName=&quot;text&quot;&gt;lucene&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">      &lt;/Query&gt;</span>
+<span class="dtd_comment">    &lt;Filter&gt;</span>
+<span class="dtd_comment">        &lt;TermsFilter fieldName=&quot;dayOfWeek&quot;&gt;monday friday&lt;/TermsFilter&gt; </span>
+<span class="dtd_comment">    &lt;/Filter&gt;   </span>
+<span class="dtd_comment">    &lt;/FilteredQuery&gt;    </span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsFilter</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    A Filter equivalent to BooleanQuery that applies Boolean logic to Clauses containing Filters.</span>
+<span class="dtd_comment">    Unlike BooleanQuery a BooleanFilter can contain a single &quot;mustNot&quot; clause.</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents from the first quarter of this year or last year that are not in &quot;draft&quot; status&lt;/em&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">     &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">       &lt;Query&gt;</span>
+<span class="dtd_comment">           &lt;MatchAllDocsQuery/&gt;</span>
+<span class="dtd_comment">       &lt;/Query&gt;</span>
+<span class="dtd_comment">       &lt;Filter&gt;</span>
+<span class="dtd_comment">        &lt;BooleanFilter&gt;</span>
+<span class="dtd_comment">          &lt;Clause occurs=&quot;should&quot;&gt;</span>
+<span class="dtd_comment">             &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;20070101&quot; upperTerm=&quot;20070401&quot;/&gt;</span>
+<span class="dtd_comment">          &lt;/Clause&gt;</span>
+<span class="dtd_comment">          &lt;Clause occurs=&quot;should&quot;&gt;</span>
+<span class="dtd_comment">             &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;20060101&quot; upperTerm=&quot;20060401&quot;/&gt;</span>
+<span class="dtd_comment">          &lt;/Clause&gt;</span>
+<span class="dtd_comment">          &lt;Clause occurs=&quot;mustNot&quot;&gt;</span>
+<span class="dtd_comment">             &lt;TermsFilter fieldName=&quot;status&quot;&gt;draft&lt;/TermsFilter&gt; </span>
+<span class="dtd_comment">          &lt;/Clause&gt;</span>
+<span class="dtd_comment">        &lt;/BooleanFilter&gt;</span>
+<span class="dtd_comment">       &lt;/Filter&gt;</span>
+<span class="dtd_comment">    &lt;/FilteredQuery&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanFilter</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Clause</span><span class="dtd_plain">)+</span><span class="dtd_tag_symbols">&gt;</span>
+
+</pre>
+</body></html>
diff --git a/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.entities.html b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.entities.html
new file mode 100644
index 0000000..7eb8e7b
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.entities.html
@@ -0,0 +1,67 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head><title>LuceneCoreQuery.dtd's entities</title>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+</head><body>
+<p class='DTDSource'><b><code>LuceneCoreQuery.dtd</code></b>: <a href='LuceneCoreQuery.dtd.html'>Elements</a> - <a href='LuceneCoreQuery.dtd.entities.html'>Entities</a> - <a href='LuceneCoreQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneCoreQuery.dtd.entities.html' target='_top'>NO FRAMES</a></p><h1>Entities for Core Lucene</h1>
+<table summary='Entities'>
+<thead><tr><th>Name</th><th>Value</th></tr></thead>
+<tbody>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr>
+<td>filters</td>
+<td>
+%coreFilters;%extendedFilters1;
+</td>
+</tr>
+<tr>
+<td>spanQueries</td>
+<td>
+%coreSpanQueries;%extendedSpanQueries1;
+</td>
+</tr>
+<tr>
+<td>extendedSpanQueries1</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>queries</td>
+<td>
+%coreQueries;|%spanQueries;%extendedQueries1;
+</td>
+</tr>
+<tr>
+<td>extendedQueries1</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>coreSpanQueries</td>
+<td>
+SpanOr|SpanNear|SpanOrTerms|SpanFirst|SpanNot|SpanTerm
+</td>
+</tr>
+<tr>
+<td>coreFilters</td>
+<td>
+RangeFilter|CachedFilter
+</td>
+</tr>
+<tr>
+<td>extendedFilters1</td>
+<td>
+ 
+</td>
+</tr>
+<tr>
+<td>coreQueries</td>
+<td>
+BooleanQuery|UserQuery|FilteredQuery|TermQuery|TermsQuery|MatchAllDocsQuery|ConstantScoreQuery
+</td>
+</tr>
+</tbody>
+</table>
+</body></html>
diff --git a/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.html b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.html
new file mode 100644
index 0000000..8d41330
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.html
@@ -0,0 +1,714 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+<title>Core Lucene</title>
+</head><body>
+<p class='DTDSource'><b><code>LuceneCoreQuery.dtd</code></b>: <a href='LuceneCoreQuery.dtd.html'>Elements</a> - <a href='LuceneCoreQuery.dtd.entities.html'>Entities</a> - <a href='LuceneCoreQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneCoreQuery.dtd.html' target='_top'>NO FRAMES</a></p><h1>Core Lucene</h1>
+<p><h3>Background</h3>
+This DTD describes the XML syntax used to perform advanced searches using the core Lucene search engine. The motivation behind the XML query syntax is:
+<ol>
+<li>To open up Lucene functionality to clients other than Java</li>
+<li>To offer a form of expressing queries that can easily be
+<ul>
+<li>Persisted for logging/auditing purposes</li>
+<li>Changed by editing text query templates (XSLT) without requiring a recompile/redeploy of applications</li>
+<li>Serialized across networks (without requiring Java bytecode for Query logic deployed on clients)</li>
+</ul>
+</li>
+<li>To provide a shorthand way of expressing query logic which echos the logical tree structure of query objects more closely than reading procedural Java query construction code</li>
+<li>To bridge the growing gap between Lucene query/filtering functionality and the set of functionality accessible throught the standard Lucene QueryParser syntax</li>
+<li>To provide a simply extensible syntax that does not require complex parser skills such as knowledge of JavaCC syntax</li>
+</ol></p><p><h3>Syntax overview</h3>
+Search syntax consists of two types of elements:
+<ul>
+<li><i>Queries</i></li>
+<li><i>Filters</i></li>
+</ul></p><p><h4>Queries</h4>
+The root of any XML search must be a <i>Query</i> type element used to select content.
+Queries typically score matches on documents using a number of different factors in order to provide relevant results first.
+One common example of a query tag is the <a href="#UserQuery">UserQuery</a> element which uses the standard
+Lucene QueryParser to parse Google-style search syntax provided by end users.</p><p><h4>Filters</h4>
+Unlike Queries, <i>Filters</i> are not used to select or score content - they are simply used to filter <i>Query</i> output (see <a href="#FilteredQuery">FilteredQuery</a> for an example use of query filtering).
+Because Filters simply offer a yes/no decision for each document in the index their output can be efficiently cached in memory as a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html">Bitset</a> for
+subsequent reuse (see <a href="#CachedFilter">CachedFilter</a> tag).</p><p><h4>Nesting elements</h4>
+Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity.
+The <a href="#BooleanQuery">BooleanQuery</a> element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean
+logic to determine mandatory or optional elements.</p><p><h3>Advanced topics</h3>
+<h4>Advanced positional testing - span queries</h4>
+The <i>SpanQuery</i> class of queries allow for complex positional tests which not only look for certain combinations of words but in particular
+positions in relation to each other and the documents containing them.</p><p>CoreParser.java is the Java class that encapsulates this parser behaviour.</p><br />
+<a name='BooleanQuery'></a>
+<br /><table class='elementTitle' summary="BooleanQuery"><tr><td class='leftElementTitle'>
+&lt;BooleanQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>BooleanQuerys implement Boolean logic which controls how multiple Clauses should be interpreted.
+Some clauses may represent optional Query criteria while others represent mandatory criteria.</p><p><span class='inTextTitle'>Example:</span> <em>Find articles about banks, preferably talking about mergers but nothing to do with "sumitomo"</em>
+</p><pre>	          
+            &lt;BooleanQuery fieldName="contents"&gt;
+	             &lt;Clause occurs="should"&gt;
+		              &lt;TermQuery&gt;merger&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+	             &lt;Clause occurs="mustnot"&gt;
+		              &lt;TermQuery&gt;sumitomo&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+	             &lt;Clause occurs="must"&gt;
+		              &lt;TermQuery&gt;bank&lt;/TermQuery&gt;
+	             &lt;/Clause&gt;
+            &lt;/BooleanQuery&gt;
+
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;BooleanQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;BooleanQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Clause'>Clause</a></td><td>At least one</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;BooleanQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;BooleanQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#BooleanQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#BooleanQuery_disableCoord'>disableCoord</a></td><td>true, false</td><td>false</td></tr><tr><td><a href='#BooleanQuery_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#BooleanQuery_minimumNumberShouldMatch'>minimumNumberShouldMatch</a></td><td></td><td>0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Clause'>Clause</a>)+</p><a name='BooleanQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='BooleanQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>fieldName can optionally be defined here as a default attribute used by all child elements</p><a name='BooleanQuery_disableCoord'></a>
+<br /><table class='attributeTitle' summary="disableCoord"><tr><td class='leftAttributeTitle'>
+@disableCoord</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>The "Coordination factor" rewards documents that contain more of the optional clauses in this list. This flag can be used to turn off this factor.</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: false</p><a name='BooleanQuery_minimumNumberShouldMatch'></a>
+<br /><table class='attributeTitle' summary="minimumNumberShouldMatch"><tr><td class='leftAttributeTitle'>
+@minimumNumberShouldMatch</td><td class='rightAttributeTitle'>
+Attribute of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>The minimum number of optional clauses that should be present in any one document before it is considered to be a match.</p><p><span class='inTextTitle'>Default value</span>: 0</p><a name='Clause'></a>
+<br /><table class='elementTitle' summary="Clause"><tr><td class='leftElementTitle'>
+&lt;Clause&gt;</td><td class='rightElementTitle'>
+Child of <a href='#BooleanQuery'>BooleanQuery</a>
+</td></tr></table>
+<p>NOTE: "Clause" tag has 2 modes of use - inside &lt;BooleanQuery> in which case only "query" types can be
+child elements - while in a &lt;BooleanFilter> clause only "filter" types can be contained.</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Clause&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Clause&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;Clause&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;Clause&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#Clause_occurs'>occurs</a></td><td>should, must, mustnot</td><td>should</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a>)</p><a name='Clause_occurs'></a>
+<br /><table class='attributeTitle' summary="occurs"><tr><td class='leftAttributeTitle'>
+@occurs</td><td class='rightAttributeTitle'>
+Attribute of <a href='#Clause'>Clause</a>
+</td></tr></table>
+<p>Controls if the clause is optional (should), mandatory (must) or unacceptable (mustNot)</p><p><span class='inTextTitle'>Possible values</span>: should, must, mustnot - <span class='inTextTitle'>Default value</span>: should</p><a name='CachedFilter'></a>
+<br /><table class='elementTitle' summary="CachedFilter"><tr><td class='leftElementTitle'>
+&lt;CachedFilter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#Filter'>Filter</a>
+</td></tr></table>
+<p>Caches any nested query or filter in an LRU (Least recently used) Cache. Cached queries, like filters, are turned into
+Bitsets at a cost of 1 bit per document in the index. The memory cost of a cached query/filter is therefore numberOfDocsinIndex/8 bytes.
+Queries that are cached as filters obviously retain none of the scoring information associated with results - they retain just
+a Boolean yes/no record of which documents matched.</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about banks from the last 10 years - caching the commonly-used "last 10 year" filter as a BitSet in
+RAM to eliminate the cost of building this filter from disk for every query</em>
+</p><pre>	          
+            &lt;FilteredQuery&gt;
+               &lt;Query&gt;
+                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;
+               &lt;/Query&gt;	
+               &lt;Filter&gt;
+                  &lt;CachedFilter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+                  &lt;/CachedFilter&gt;
+               &lt;/Filter&gt;	
+            &lt;/FilteredQuery&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;CachedFilter&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;CachedFilter&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a> | <a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a>)</p><a name='UserQuery'></a>
+<br /><table class='elementTitle' summary="UserQuery"><tr><td class='leftElementTitle'>
+&lt;UserQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Passes content directly through to the standard LuceneQuery parser see "Lucene Query Syntax"</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about John Smith or John Doe using standard LuceneQuerySyntax</em>
+</p><pre>	          
+               &lt;UserQuery&gt;"John Smith" OR "John Doe"&lt;/UserQuery&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;UserQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;UserQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#UserQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<a name='UserQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#UserQuery'>UserQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='MatchAllDocsQuery'></a>
+<br /><table class='elementTitle' summary="MatchAllDocsQuery"><tr><td class='leftElementTitle'>
+&lt;MatchAllDocsQuery/&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>A query which is used to match all documents. This has a couple of uses:
+<ol>
+<li> as a Clause in a BooleanQuery who's only other clause
+is a "mustNot" match (Lucene requires at least one positive clause) and..</li>
+<li> in a FilteredQuery where a Filter tag is effectively being
+used to select content rather than it's usual role of filtering the results of a query.</li>
+</ol></p><p><span class='inTextTitle'>Example:</span> <em>Effectively use a Filter as a query </em>
+</p><pre>	          
+               &lt;FilteredQuery&gt;
+                 &lt;Query&gt;
+                    &lt;MatchAllDocsQuery/&gt;
+                 &lt;/Query&gt;
+                 &lt;Filter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19870409" upperTerm="19870412"/&gt;
+                 &lt;/Filter&gt;	
+               &lt;/FilteredQuery&gt;	         
+	       </pre><p></p><p class='emptyTagNote'>This element is always empty.</p><a name='TermQuery'></a>
+<br /><table class='elementTitle' summary="TermQuery"><tr><td class='leftElementTitle'>
+&lt;TermQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>a single term query - no analysis is done of the child text</p><p><span class='inTextTitle'>Example:</span> <em>Match on a primary key</em>
+</p><pre>	          
+               &lt;TermQuery fieldName="primaryKey"&gt;13424&lt;/TermQuery&gt;
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;TermQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;TermQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#TermQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#TermQuery_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='TermQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermQuery'>TermQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='TermQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermQuery'>TermQuery</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='TermsQuery'></a>
+<br /><table class='elementTitle' summary="TermsQuery"><tr><td class='leftElementTitle'>
+&lt;TermsQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>The equivalent of a BooleanQuery with multiple optional TermQuery clauses.
+Child text is analyzed using a field-specific choice of Analyzer to produce a set of terms that are ORed together in Boolean logic.
+Unlike UserQuery element, this does not parse any special characters to control fuzzy/phrase/boolean logic and as such is incapable
+of producing a Query parse error given any user input</p><p><span class='inTextTitle'>Example:</span> <em>Match on text from a database description (which may contain characters that
+are illegal characters in the standard Lucene Query syntax used in the UserQuery tag</em>
+</p><pre>	          
+               &lt;TermsQuery fieldName="description"&gt;Smith & Sons (Ltd) : incorporated 1982&lt;/TermsQuery&gt;
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;TermsQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;TermsQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#TermsQuery_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#TermsQuery_disableCoord'>disableCoord</a></td><td>true, false</td><td>false</td></tr><tr><td><a href='#TermsQuery_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#TermsQuery_minimumNumberShouldMatch'>minimumNumberShouldMatch</a></td><td></td><td>0</td></tr></table></td></tr></table></blockquote>
+<a name='TermsQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='TermsQuery_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='TermsQuery_disableCoord'></a>
+<br /><table class='attributeTitle' summary="disableCoord"><tr><td class='leftAttributeTitle'>
+@disableCoord</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>The "Coordination factor" rewards documents that contain more of the terms in this list. This flag can be used to turn off this factor.</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: false</p><a name='TermsQuery_minimumNumberShouldMatch'></a>
+<br /><table class='attributeTitle' summary="minimumNumberShouldMatch"><tr><td class='leftAttributeTitle'>
+@minimumNumberShouldMatch</td><td class='rightAttributeTitle'>
+Attribute of <a href='#TermsQuery'>TermsQuery</a>
+</td></tr></table>
+<p>The minimum number of terms that should be present in any one document before it is considered to be a match.</p><p><span class='inTextTitle'>Default value</span>: 0</p><a name='FilteredQuery'></a>
+<br /><table class='elementTitle' summary="FilteredQuery"><tr><td class='leftElementTitle'>
+&lt;FilteredQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Runs a Query and filters results to only those query matches that also match the Filter element.</p><p><span class='inTextTitle'>Example:</span> <em>Find all documents about Lucene that have a status of "published"</em>
+</p><pre>	          
+               &lt;FilteredQuery&gt;
+                 &lt;Query&gt;
+                    &lt;UserQuery&gt;Lucene&lt;/UserQuery&gt;
+                 &lt;/Query&gt;
+                 &lt;Filter&gt;
+                     &lt;TermsFilter fieldName="status"&gt;published&lt;/TermsFilter&gt;
+                 &lt;/Filter&gt;	
+               &lt;/FilteredQuery&gt;	         
+	       </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;FilteredQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;FilteredQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Filter'>Filter</a></td><td>Only one</td></tr>
+<tr><td><a href='#Query'>Query</a></td><td>Only one</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;FilteredQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;FilteredQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#FilteredQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Query'>Query</a>, <a href='#Filter'>Filter</a>)</p><a name='FilteredQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#FilteredQuery'>FilteredQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='Query'></a>
+<br /><table class='elementTitle' summary="Query"><tr><td class='leftElementTitle'>
+&lt;Query&gt;</td><td class='rightElementTitle'>
+Child of <a href='#FilteredQuery'>FilteredQuery</a>
+</td></tr></table>
+<p>Used to identify a nested Query element inside another container element. NOT a top-level query tag</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Query&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Query&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#BooleanQuery'>BooleanQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#ConstantScoreQuery'>ConstantScoreQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#FilteredQuery'>FilteredQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermQuery'>TermQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#TermsQuery'>TermsQuery</a></td><td>One or none</td></tr>
+<tr><td><a href='#UserQuery'>UserQuery</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#BooleanQuery'>BooleanQuery</a> | <a href='#UserQuery'>UserQuery</a> | <a href='#FilteredQuery'>FilteredQuery</a> | <a href='#TermQuery'>TermQuery</a> | <a href='#TermsQuery'>TermsQuery</a> | <a href='#MatchAllDocsQuery'>MatchAllDocsQuery</a> | <a href='#ConstantScoreQuery'>ConstantScoreQuery</a> | <a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='Filter'></a>
+<br /><table class='elementTitle' summary="Filter"><tr><td class='leftElementTitle'>
+&lt;Filter&gt;</td><td class='rightElementTitle'>
+Child of <a href='#FilteredQuery'>FilteredQuery</a>
+</td></tr></table>
+<p>The choice of Filter that MUST also be matched</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Filter&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Filter&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>One or none</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a>)</p><a name='RangeFilter'></a>
+<br /><table class='elementTitle' summary="RangeFilter"><tr><td class='leftElementTitle'>
+&lt;RangeFilter/&gt;</td><td class='rightElementTitle'>
+Child of <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>, <a href='#Filter'>Filter</a>
+</td></tr></table>
+<p>Filter used to limit query results to documents matching a range of field values</p><p><span class='inTextTitle'>Example:</span> <em>Search for documents about banks from the last 10 years</em>
+</p><pre>	          
+            &lt;FilteredQuery&gt;
+               &lt;Query&gt;
+                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;
+               &lt;/Query&gt;	
+               &lt;Filter&gt;
+                     &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+               &lt;/Filter&gt;	
+            &lt;/FilteredQuery&gt;
+	         </pre><p></p><blockquote>
+<table  summary="&lt;RangeFilter&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;RangeFilter&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#RangeFilter_fieldName'>fieldName</a></td><td></td><td></td></tr><tr><td><a href='#RangeFilter_includeLower'>includeLower</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#RangeFilter_includeUpper'>includeUpper</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#RangeFilter_lowerTerm'>lowerTerm</a></td><td></td><td></td></tr><tr><td><a href='#RangeFilter_upperTerm'>upperTerm</a></td><td></td><td></td></tr></table></blockquote>
+<p class='emptyTagNote'>This element is always empty.</p><a name='RangeFilter_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><a name='RangeFilter_lowerTerm'></a>
+<br /><table class='attributeTitle' summary="lowerTerm"><tr><td class='leftAttributeTitle'>
+@lowerTerm</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>The lower-most term value for this field (must be &lt;= upperTerm)</p><p><span class='inTextTitle'>Required</span></p><a name='RangeFilter_upperTerm'></a>
+<br /><table class='attributeTitle' summary="upperTerm"><tr><td class='leftAttributeTitle'>
+@upperTerm</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>The upper-most term value for this field (must be >= lowerTerm)</p><p><span class='inTextTitle'>Required</span></p><a name='RangeFilter_includeLower'></a>
+<br /><table class='attributeTitle' summary="includeLower"><tr><td class='leftAttributeTitle'>
+@includeLower</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>Controls if the lowerTerm in the range is part of the allowed set of values</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='RangeFilter_includeUpper'></a>
+<br /><table class='attributeTitle' summary="includeUpper"><tr><td class='leftAttributeTitle'>
+@includeUpper</td><td class='rightAttributeTitle'>
+Attribute of <a href='#RangeFilter'>RangeFilter</a>
+</td></tr></table>
+<p>Controls if the upperTerm in the range is part of the allowed set of values</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='SpanTerm'></a>
+<br /><table class='elementTitle' summary="SpanTerm"><tr><td class='leftElementTitle'>
+&lt;SpanTerm&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNear'>SpanNear</a>, <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>A single term used in a SpanQuery. These clauses are the building blocks for more complex "span" queries which test word proximity</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms close to each other about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;SpanTerm&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanTerm&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanTerm_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='SpanTerm_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanTerm'>SpanTerm</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><p><span class='inTextTitle'>Required</span></p><a name='SpanOrTerms'></a>
+<br /><table class='elementTitle' summary="SpanOrTerms"><tr><td class='leftElementTitle'>
+&lt;SpanOrTerms&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNear'>SpanNear</a>, <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>A field-specific analyzer is used here to parse the child text provided in this tag. The SpanTerms produced are ORed in terms of Boolean logic</p><p><span class='inTextTitle'>Example:</span> <em>Use SpanOrTerms as a more convenient/succinct way of expressing multiple choices of SpanTerms. This example looks for reports
+using words describing a fatality near to references to miners</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOrTerms&gt;killed died death dead deaths&lt;/SpanOrTerms&gt;
+			&lt;SpanOrTerms&gt;miner mining miners&lt;/SpanOrTerms&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table  summary="&lt;SpanOrTerms&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanOrTerms&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanOrTerms_fieldName'>fieldName</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<a name='SpanOrTerms_fieldName'></a>
+<br /><table class='attributeTitle' summary="fieldName"><tr><td class='leftAttributeTitle'>
+@fieldName</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanOrTerms'>SpanOrTerms</a>
+</td></tr></table>
+<p>fieldName must be defined here or is taken from the most immediate parent XML element that defines a "fieldName" attribute</p><p><span class='inTextTitle'>Required</span></p><a name='SpanOr'></a>
+<br /><table class='elementTitle' summary="SpanOr"><tr><td class='leftElementTitle'>
+&lt;SpanOr&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNear'>SpanNear</a>, <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Takes any number of child queries from the Span family</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms close to each other about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanOr&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanOr&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>Any number</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)*</p><a name='SpanNear'></a>
+<br /><table class='elementTitle' summary="SpanNear"><tr><td class='leftElementTitle'>
+&lt;SpanNear&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Takes any number of child queries from the Span family and tests for proximity</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanNear&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanNear&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>Any number</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>Any number</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;SpanNear&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanNear&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanNear_inOrder'>inOrder</a></td><td>true, false</td><td>true</td></tr><tr><td><a href='#SpanNear_slop'>slop</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)*</p><a name='SpanNear_slop'></a>
+<br /><table class='attributeTitle' summary="slop"><tr><td class='leftAttributeTitle'>
+@slop</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>defines the maximum distance between Span elements where distance is expressed as word number, not byte offset</p><p><span class='inTextTitle'>Example:</span> <em>Find documents using terms within 8 words of each other talking about mining and accidents</em>
+</p><pre>
+	      &lt;SpanNear slop="8" inOrder="false" fieldName="text"&gt;		
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;died&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+			&lt;SpanOr&gt;
+				&lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;
+				&lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;
+			&lt;/SpanOr&gt;
+	      &lt;/SpanNear&gt;
+	      </pre><p></p><p><span class='inTextTitle'>Required</span></p><a name='SpanNear_inOrder'></a>
+<br /><table class='attributeTitle' summary="inOrder"><tr><td class='leftAttributeTitle'>
+@inOrder</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanNear'>SpanNear</a>
+</td></tr></table>
+<p>Controls if matching terms have to appear in the order listed or can be reversed</p><p><span class='inTextTitle'>Possible values</span>: true, false - <span class='inTextTitle'>Default value</span>: true</p><a name='SpanFirst'></a>
+<br /><table class='elementTitle' summary="SpanFirst"><tr><td class='leftElementTitle'>
+&lt;SpanFirst&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNear'>SpanNear</a>, <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Looks for a SpanQuery match occuring near the beginning of a document</p><p><span class='inTextTitle'>Example:</span> <em>Find letters where the first 50 words talk about a resignation:</em>
+</p><pre>	          
+	         &lt;SpanFirst end="50"&gt;
+	               &lt;SpanOrTerms fieldName="text"&gt;resigning resign leave&lt;/SpanOrTerms&gt;
+	         &lt;/SpanFirst&gt;
+	         </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanFirst&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanFirst&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;SpanFirst&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;SpanFirst&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#SpanFirst_boost'>boost</a></td><td></td><td>1.0</td></tr><tr><td><a href='#SpanFirst_end'>end</a></td><td></td><td></td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='SpanFirst_end'></a>
+<br /><table class='attributeTitle' summary="end"><tr><td class='leftAttributeTitle'>
+@end</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanFirst'>SpanFirst</a>
+</td></tr></table>
+<p>Controls the end of the region considered in a document's field (expressed in word number, not byte offset)</p><p><span class='inTextTitle'>Required</span></p><a name='SpanFirst_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#SpanFirst'>SpanFirst</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p><a name='SpanNot'></a>
+<br /><table class='elementTitle' summary="SpanNot"><tr><td class='leftElementTitle'>
+&lt;SpanNot&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNear'>SpanNear</a>, <a href='#Include'>Include</a>, <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#SpanOr'>SpanOr</a>, <a href='#SpanFirst'>SpanFirst</a>, <a href='#Exclude'>Exclude</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>Finds documents matching a SpanQuery but not if matching another SpanQuery</p><p><span class='inTextTitle'>Example:</span> <em>Find documents talking about social services but not containing the word "public"</em>
+</p><pre>
+          &lt;SpanNot fieldName="text"&gt;
+             &lt;Include&gt;
+                &lt;SpanNear slop="2" inOrder="true"&gt;		
+                     &lt;SpanTerm&gt;social&lt;/SpanTerm&gt;
+                     &lt;SpanTerm&gt;services&lt;/SpanTerm&gt;
+                &lt;/SpanNear&gt;				
+             &lt;/Include&gt;
+             &lt;Exclude&gt;
+                &lt;SpanTerm&gt;public&lt;/SpanTerm&gt;
+             &lt;/Exclude&gt;
+          &lt;/SpanNot&gt;
+	      </pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;SpanNot&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;SpanNot&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#Exclude'>Exclude</a></td><td>Only one</td></tr>
+<tr><td><a href='#Include'>Include</a></td><td>Only one</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#Include'>Include</a>, <a href='#Exclude'>Exclude</a>)</p><a name='Include'></a>
+<br /><table class='elementTitle' summary="Include"><tr><td class='leftElementTitle'>
+&lt;Include&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNot'>SpanNot</a>
+</td></tr></table>
+<p>The SpanQuery to find</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Include&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Include&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='Exclude'></a>
+<br /><table class='elementTitle' summary="Exclude"><tr><td class='leftElementTitle'>
+&lt;Exclude&gt;</td><td class='rightElementTitle'>
+Child of <a href='#SpanNot'>SpanNot</a>
+</td></tr></table>
+<p>The SpanQuery to be avoided</p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;Exclude&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;Exclude&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#SpanFirst'>SpanFirst</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNear'>SpanNear</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanNot'>SpanNot</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOr'>SpanOr</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanOrTerms'>SpanOrTerms</a></td><td>One or none</td></tr>
+<tr><td><a href='#SpanTerm'>SpanTerm</a></td><td>One or none</td></tr>
+</tbody></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#SpanOr'>SpanOr</a> | <a href='#SpanNear'>SpanNear</a> | <a href='#SpanOrTerms'>SpanOrTerms</a> | <a href='#SpanFirst'>SpanFirst</a> | <a href='#SpanNot'>SpanNot</a> | <a href='#SpanTerm'>SpanTerm</a>)</p><a name='ConstantScoreQuery'></a>
+<br /><table class='elementTitle' summary="ConstantScoreQuery"><tr><td class='leftElementTitle'>
+&lt;ConstantScoreQuery&gt;</td><td class='rightElementTitle'>
+Child of <a href='#Query'>Query</a>, <a href='#Clause'>Clause</a>, <a href='#CachedFilter'>CachedFilter</a>
+</td></tr></table>
+<p>a utility tag to wrap any filter as a query</p><p><span class='inTextTitle'>Example:</span> <em> Find all documents from the last 10 years </em>
+</p><pre>
+     &lt;ConstantScoreQuery&gt;
+           &lt;RangeFilter fieldName="date" lowerTerm="19970101" upperTerm="20070101"/&gt;
+     &lt;/ConstantScoreQuery&gt;	
+	</pre><p></p><blockquote><table summary='element info'><tr>
+<td class='construct'><table summary="&lt;ConstantScoreQuery&gt;'s children">
+<thead>
+<tr><th class='title' colspan='2'>&lt;ConstantScoreQuery&gt;'s children</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+<tr><th class='subtitle'>Name</th><th class='subtitle'>Cardinality</th></tr>
+<tr><th colspan='2' height='1' class='ruler'></th></tr>
+</thead>
+<tbody><tr><td><a href='#CachedFilter'>CachedFilter</a></td><td>Any number</td></tr>
+<tr><td><a href='#RangeFilter'>RangeFilter</a></td><td>Any number</td></tr>
+</tbody></table></td><td class='construct'><table  summary="&lt;ConstantScoreQuery&gt;'s attributes"><tr>
+<th class='title' colspan='3'>&lt;ConstantScoreQuery&gt;'s attributes</th>
+</tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr>
+<th class='subtitle'>Name</th><th class='subtitle'>Values</th><th class='subtitle'>Default</th></tr>
+<tr><th colspan='3' height='1' class='ruler'></th></tr>
+<tr><td><a href='#ConstantScoreQuery_boost'>boost</a></td><td></td><td>1.0</td></tr></table></td></tr></table></blockquote>
+<span class='inTextTitle'>Element's model:</span><p class='model'>(<a href='#RangeFilter'>RangeFilter</a> | <a href='#CachedFilter'>CachedFilter</a>)*</p><a name='ConstantScoreQuery_boost'></a>
+<br /><table class='attributeTitle' summary="boost"><tr><td class='leftAttributeTitle'>
+@boost</td><td class='rightAttributeTitle'>
+Attribute of <a href='#ConstantScoreQuery'>ConstantScoreQuery</a>
+</td></tr></table>
+<p>Optional boost for matches on this query. Values > 1</p><p><span class='inTextTitle'>Default value</span>: 1.0</p></body></html>
diff --git a/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.org.html b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.org.html
new file mode 100644
index 0000000..afd5537
--- /dev/null
+++ b/contrib/xml-query-parser/docs/LuceneCoreQuery.dtd.org.html
@@ -0,0 +1,405 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html> <head>
+<meta http-equiv='CONTENT-TYPE' content='text/html; charset=UTF-8' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+<title>Core Lucene</title>
+</head><body>
+<p class='DTDSource'><b><code>LuceneCoreQuery.dtd</code></b>: <a href='LuceneCoreQuery.dtd.html'>Elements</a> - <a href='LuceneCoreQuery.dtd.entities.html'>Entities</a> - <a href='LuceneCoreQuery.dtd.org.html'>Source</a> | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='LuceneCoreQuery.dtd.org.html' target='_top'>NO FRAMES</a></p><pre id='dtd_source'><span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    &lt;h3&gt;Background&lt;/h3&gt;</span>
+<span class="dtd_comment">    This DTD describes the XML syntax used to perform advanced searches using the core Lucene search engine. The motivation behind the XML query syntax is:</span>
+<span class="dtd_comment">    &lt;ol&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;To open up Lucene functionality to clients other than Java&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;To offer a form of expressing queries that can easily be</span>
+<span class="dtd_comment">        &lt;ul&gt;</span>
+<span class="dtd_comment">            &lt;li&gt;Persisted for logging/auditing purposes&lt;/li&gt;</span>
+<span class="dtd_comment">            &lt;li&gt;Changed by editing text query templates (XSLT) without requiring a recompile/redeploy of applications&lt;/li&gt;</span>
+<span class="dtd_comment">            &lt;li&gt;Serialized across networks (without requiring Java bytecode for Query logic deployed on clients)&lt;/li&gt;</span>
+<span class="dtd_comment">        &lt;/ul&gt;</span>
+<span class="dtd_comment">    &lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;To provide a shorthand way of expressing query logic which echos the logical tree structure of query objects more closely than reading procedural Java query construction code&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;To bridge the growing gap between Lucene query/filtering functionality and the set of functionality accessible throught the standard Lucene QueryParser syntax&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;To provide a simply extensible syntax that does not require complex parser skills such as knowledge of JavaCC syntax&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;/ol&gt;</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    &lt;h3&gt;Syntax overview&lt;/h3&gt;</span>
+<span class="dtd_comment">    Search syntax consists of two types of elements:</span>
+<span class="dtd_comment">    &lt;ul&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;i&gt;Queries&lt;/i&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt;&lt;i&gt;Filters&lt;/i&gt;&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;/ul&gt;</span>
+
+<span class="dtd_comment">    &lt;h4&gt;Queries&lt;/h4&gt;</span>
+<span class="dtd_comment">    The root of any XML search must be a &lt;i&gt;Query&lt;/i&gt; type element used to select content.</span>
+<span class="dtd_comment">    Queries typically score matches on documents using a number of different factors in order to provide relevant results first. </span>
+<span class="dtd_comment">    One common example of a query tag is the &lt;a href=&quot;#UserQuery&quot;&gt;UserQuery&lt;/a&gt; element which uses the standard </span>
+<span class="dtd_comment">    Lucene QueryParser to parse Google-style search syntax provided by end users.</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    &lt;h4&gt;Filters&lt;/h4&gt;</span>
+<span class="dtd_comment">    Unlike Queries, &lt;i&gt;Filters&lt;/i&gt; are not used to select or score content - they are simply used to filter &lt;i&gt;Query&lt;/i&gt; output (see &lt;a href=&quot;#FilteredQuery&quot;&gt;FilteredQuery&lt;/a&gt; for an example use of query filtering).</span>
+<span class="dtd_comment">    Because Filters simply offer a yes/no decision for each document in the index their output can be efficiently cached in memory as a &lt;a href=&quot;http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html&quot;&gt;Bitset&lt;/a&gt; for</span>
+<span class="dtd_comment">    subsequent reuse (see &lt;a href=&quot;#CachedFilter&quot;&gt;CachedFilter&lt;/a&gt; tag).</span>
+
+<span class="dtd_comment">    &lt;h4&gt;Nesting elements&lt;/h4&gt;</span>
+<span class="dtd_comment">    Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. </span>
+<span class="dtd_comment">    The &lt;a href=&quot;#BooleanQuery&quot;&gt;BooleanQuery&lt;/a&gt; element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean </span>
+<span class="dtd_comment">    logic to determine mandatory or optional elements. </span>
+
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    &lt;h3&gt;Advanced topics&lt;/h3&gt;    </span>
+<span class="dtd_comment">    &lt;h4&gt;Advanced positional testing - span queries&lt;/h4&gt;</span>
+<span class="dtd_comment">    The &lt;i&gt;SpanQuery&lt;/i&gt; class of queries allow for complex positional tests which not only look for certain combinations of words but in particular </span>
+<span class="dtd_comment">    positions in relation to each other and the documents containing them.</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    CoreParser.java is the Java class that encapsulates this parser behaviour.</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@title</span><span class="dtd_comment"> Core Lucene  </span>
+<span class="dtd_comment">--&gt;</span>
+
+<span class="dtd_comment">&lt;!-- </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> Define core types of XML elements --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">coreSpanQueries</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;SpanOr|SpanNear|SpanOrTerms|SpanFirst|SpanNot|SpanTerm&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">coreQueries</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;BooleanQuery|UserQuery|FilteredQuery|TermQuery|TermsQuery|MatchAllDocsQuery|ConstantScoreQuery&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">coreFilters</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;RangeFilter|CachedFilter&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> Allow for extensions --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedSpanQueries1</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedQueries1</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">extendedFilters1</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot; &quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;%coreSpanQueries;%extendedSpanQueries1;&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">queries</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;%coreQueries;|%spanQueries;%extendedQueries1;&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ENTITY</span><span class="dtd_plain"> % </span><span class="dtd_attribute_name">filters</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;%coreFilters;%extendedFilters1;&quot;</span><span class="dtd_plain"> </span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    BooleanQuerys implement Boolean logic which controls how multiple Clauses should be interpreted.</span>
+<span class="dtd_comment">    Some clauses may represent optional Query criteria while others represent mandatory criteria.   </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Find articles about banks, preferably talking about mergers but nothing to do with &quot;sumitomo&quot;&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">            &lt;BooleanQuery fieldName=&quot;contents&quot;&gt;</span>
+<span class="dtd_comment">                 &lt;Clause occurs=&quot;should&quot;&gt;</span>
+<span class="dtd_comment">                      &lt;TermQuery&gt;merger&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">                 &lt;/Clause&gt;</span>
+<span class="dtd_comment">                 &lt;Clause occurs=&quot;mustnot&quot;&gt;</span>
+<span class="dtd_comment">                      &lt;TermQuery&gt;sumitomo&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">                 &lt;/Clause&gt;</span>
+<span class="dtd_comment">                 &lt;Clause occurs=&quot;must&quot;&gt;</span>
+<span class="dtd_comment">                      &lt;TermQuery&gt;bank&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">                 &lt;/Clause&gt;</span>
+<span class="dtd_comment">            &lt;/BooleanQuery&gt;</span>
+
+<span class="dtd_comment">             %</span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanQuery</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Clause</span><span class="dtd_plain">)+</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName can optionally be defined here as a default attribute used by all child elements --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The &quot;Coordination factor&quot; rewards documents that contain more of the optional clauses in this list. This flag can be used to turn off this factor. --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">disableCoord</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;false&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The minimum number of optional clauses that should be present in any one document before it is considered to be a match. --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">BooleanQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">minimumNumberShouldMatch</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- NOTE: &quot;Clause&quot; tag has 2 modes of use - inside &lt;BooleanQuery&gt; in which case only &quot;query&quot; types can be</span>
+<span class="dtd_comment">    child elements - while in a &lt;BooleanFilter&gt; clause only &quot;filter&quot; types can be contained.</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> TODO: Change BooleanFilterBuilder and BooleanQueryBuilder to auto-wrap choice of query or filters. This type of</span>
+<span class="dtd_comment">          code already exists in CachedFilter so could be reused.</span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Clause</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">queries</span><span class="dtd_plain">;|%</span><span class="dtd_attribute_name">filters</span><span class="dtd_plain">;)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls if the clause is optional (should), mandatory (must) or unacceptable (mustNot) --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Clause</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">occurs</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">should</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">must</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">mustnot</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;should&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_comment">&lt;!-- Caches any nested query or filter in an LRU (Least recently used) Cache. Cached queries, like filters, are turned into</span>
+<span class="dtd_comment">    Bitsets at a cost of 1 bit per document in the index. The memory cost of a cached query/filter is therefore numberOfDocsinIndex/8 bytes.</span>
+<span class="dtd_comment">    Queries that are cached as filters obviously retain none of the scoring information associated with results - they retain just</span>
+<span class="dtd_comment">    a Boolean yes/no record of which documents matched. </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Search for documents about banks from the last 10 years - caching the commonly-used &quot;last 10 year&quot; filter as a BitSet in </span>
+<span class="dtd_comment">    RAM to eliminate the cost of building this filter from disk for every query&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">            &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">               &lt;Query&gt;</span>
+<span class="dtd_comment">                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;</span>
+<span class="dtd_comment">               &lt;/Query&gt; </span>
+<span class="dtd_comment">               &lt;Filter&gt;</span>
+<span class="dtd_comment">                  &lt;CachedFilter&gt;</span>
+<span class="dtd_comment">                     &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;19970101&quot; upperTerm=&quot;20070101&quot;/&gt;</span>
+<span class="dtd_comment">                  &lt;/CachedFilter&gt;</span>
+<span class="dtd_comment">               &lt;/Filter&gt;    </span>
+<span class="dtd_comment">            &lt;/FilteredQuery&gt;</span>
+<span class="dtd_comment">             %</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">CachedFilter</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">queries</span><span class="dtd_plain">;|%</span><span class="dtd_attribute_name">filters</span><span class="dtd_plain">;)</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">Passes content directly through to the standard LuceneQuery parser see &quot;Lucene Query Syntax&quot;</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Search for documents about John Smith or John Doe using standard LuceneQuerySyntax&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">               &lt;UserQuery&gt;&quot;John Smith&quot; OR &quot;John Doe&quot;&lt;/UserQuery&gt;</span>
+<span class="dtd_comment">             %</span>
+<span class="dtd_comment">        </span>
+<span class="dtd_comment">--&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">UserQuery</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">UserQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- A query which is used to match all documents. This has a couple of uses: </span>
+<span class="dtd_comment">    &lt;ol&gt;</span>
+<span class="dtd_comment">    &lt;li&gt; as a Clause in a BooleanQuery who's only other clause</span>
+<span class="dtd_comment">    is a &quot;mustNot&quot; match (Lucene requires at least one positive clause) and..&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;li&gt; in a FilteredQuery where a Filter tag is effectively being </span>
+<span class="dtd_comment">    used to select content rather than it's usual role of filtering the results of a query.&lt;/li&gt;</span>
+<span class="dtd_comment">    &lt;/ol&gt;</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Effectively use a Filter as a query &lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">               &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">                 &lt;Query&gt;</span>
+<span class="dtd_comment">                    &lt;MatchAllDocsQuery/&gt;</span>
+<span class="dtd_comment">                 &lt;/Query&gt;</span>
+<span class="dtd_comment">                 &lt;Filter&gt;</span>
+<span class="dtd_comment">                     &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;19870409&quot; upperTerm=&quot;19870412&quot;/&gt;</span>
+<span class="dtd_comment">                 &lt;/Filter&gt;  </span>
+<span class="dtd_comment">               &lt;/FilteredQuery&gt;          </span>
+<span class="dtd_comment">           %</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">--&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">MatchAllDocsQuery</span><span class="dtd_plain"> </span><span class="dtd_keyword">EMPTY</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- a single term query - no analysis is done of the child text</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Match on a primary key&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">               &lt;TermQuery fieldName=&quot;primaryKey&quot;&gt;13424&lt;/TermQuery&gt;</span>
+<span class="dtd_comment">           %    </span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermQuery</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+<span class="dtd_comment">&lt;!-- </span>
+<span class="dtd_comment">    The equivalent of a BooleanQuery with multiple optional TermQuery clauses.</span>
+<span class="dtd_comment">    Child text is analyzed using a field-specific choice of Analyzer to produce a set of terms that are ORed together in Boolean logic.</span>
+<span class="dtd_comment">    Unlike UserQuery element, this does not parse any special characters to control fuzzy/phrase/boolean logic and as such is incapable</span>
+<span class="dtd_comment">    of producing a Query parse error given any user input</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Match on text from a database description (which may contain characters that </span>
+<span class="dtd_comment">    are illegal characters in the standard Lucene Query syntax used in the UserQuery tag&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">               &lt;TermsQuery fieldName=&quot;description&quot;&gt;Smith &amp; Sons (Ltd) : incorporated 1982&lt;/TermsQuery&gt;</span>
+<span class="dtd_comment">           %    </span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsQuery</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The &quot;Coordination factor&quot; rewards documents that contain more of the terms in this list. This flag can be used to turn off this factor. --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">disableCoord</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;false&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The minimum number of terms that should be present in any one document before it is considered to be a match. --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">TermsQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">minimumNumberShouldMatch</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_comment">&lt;!-- </span>
+<span class="dtd_comment">    Runs a Query and filters results to only those query matches that also match the Filter element.    </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Find all documents about Lucene that have a status of &quot;published&quot;&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">               &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">                 &lt;Query&gt;</span>
+<span class="dtd_comment">                    &lt;UserQuery&gt;Lucene&lt;/UserQuery&gt;</span>
+<span class="dtd_comment">                 &lt;/Query&gt;</span>
+<span class="dtd_comment">                 &lt;Filter&gt;</span>
+<span class="dtd_comment">                     &lt;TermsFilter fieldName=&quot;status&quot;&gt;published&lt;/TermsFilter&gt;</span>
+<span class="dtd_comment">                 &lt;/Filter&gt;  </span>
+<span class="dtd_comment">               &lt;/FilteredQuery&gt;          </span>
+<span class="dtd_comment">           %    </span>
+<span class="dtd_comment">--&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FilteredQuery</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Query</span><span class="dtd_plain">,</span><span class="dtd_attribute_name">Filter</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">FilteredQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Used to identify a nested Query element inside another container element. NOT a top-level query tag  --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Query</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">queries</span><span class="dtd_plain">;)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The choice of Filter that MUST also be matched  --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Filter</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">filters</span><span class="dtd_plain">;)</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!--</span>
+<span class="dtd_comment">    Filter used to limit query results to documents matching a range of field values</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Search for documents about banks from the last 10 years&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">            &lt;FilteredQuery&gt;</span>
+<span class="dtd_comment">               &lt;Query&gt;</span>
+<span class="dtd_comment">                  &lt;UserQuery&gt;bank&lt;/UserQuery&gt;</span>
+<span class="dtd_comment">               &lt;/Query&gt; </span>
+<span class="dtd_comment">               &lt;Filter&gt;</span>
+<span class="dtd_comment">                     &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;19970101&quot; upperTerm=&quot;20070101&quot;/&gt;</span>
+<span class="dtd_comment">               &lt;/Filter&gt;    </span>
+<span class="dtd_comment">            &lt;/FilteredQuery&gt;</span>
+<span class="dtd_comment">             %</span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_keyword">EMPTY</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#IMPLIED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The lower-most term value for this field (must be &lt;= upperTerm) --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">lowerTerm</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The upper-most term value for this field (must be &gt;= lowerTerm) --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">upperTerm</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls if the lowerTerm in the range is part of the allowed set of values --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">includeLower</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;true&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls if the upperTerm in the range is part of the allowed set of values --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">RangeFilter</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">includeUpper</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;true&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+<span class="dtd_comment">&lt;!-- A single term used in a SpanQuery. These clauses are the building blocks for more complex &quot;span&quot; queries which test word proximity</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents using terms close to each other about mining and accidents&lt;/em&gt;</span>
+<span class="dtd_comment">          %</span>
+<span class="dtd_comment">          &lt;SpanNear slop=&quot;8&quot; inOrder=&quot;false&quot; fieldName=&quot;text&quot;&gt;      </span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;died&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">          &lt;/SpanNear&gt;</span>
+<span class="dtd_comment">          %     </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanTerm</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanTerm</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- A field-specific analyzer is used here to parse the child text provided in this tag. The SpanTerms produced are ORed in terms of Boolean logic </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Use SpanOrTerms as a more convenient/succinct way of expressing multiple choices of SpanTerms. This example looks for reports </span>
+<span class="dtd_comment">    using words describing a fatality near to references to miners&lt;/em&gt;</span>
+<span class="dtd_comment">          %</span>
+<span class="dtd_comment">          &lt;SpanNear slop=&quot;8&quot; inOrder=&quot;false&quot; fieldName=&quot;text&quot;&gt;      </span>
+<span class="dtd_comment">            &lt;SpanOrTerms&gt;killed died death dead deaths&lt;/SpanOrTerms&gt;</span>
+<span class="dtd_comment">            &lt;SpanOrTerms&gt;miner mining miners&lt;/SpanOrTerms&gt;</span>
+<span class="dtd_comment">          &lt;/SpanNear&gt;</span>
+<span class="dtd_comment">          %     </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanOrTerms</span><span class="dtd_plain"> (</span><span class="dtd_keyword">#PCDATA</span><span class="dtd_plain">)</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- fieldName must be defined here or is taken from the most immediate parent XML element that defines a &quot;fieldName&quot; attribute --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanOrTerms</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">fieldName</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- Takes any number of child queries from the Span family </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents using terms close to each other about mining and accidents&lt;/em&gt;</span>
+<span class="dtd_comment">          %</span>
+<span class="dtd_comment">          &lt;SpanNear slop=&quot;8&quot; inOrder=&quot;false&quot; fieldName=&quot;text&quot;&gt;      </span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;died&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">          &lt;/SpanNear&gt;</span>
+<span class="dtd_comment">          % </span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanOr</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain">;)* </span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- Takes any number of child queries from the Span family and tests for proximity</span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@hidden</span><span class="dtd_comment"> TODO SpanNear missing &quot;boost attr (could add to SpanBuilderBase)</span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanNear</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain">;)* </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- defines the maximum distance between Span elements where distance is expressed as word number, not byte offset </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents using terms within 8 words of each other talking about mining and accidents&lt;/em&gt;</span>
+<span class="dtd_comment">          %</span>
+<span class="dtd_comment">          &lt;SpanNear slop=&quot;8&quot; inOrder=&quot;false&quot; fieldName=&quot;text&quot;&gt;      </span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;killed&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;died&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;dead&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">            &lt;SpanOr&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miner&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;mining&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;miners&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">            &lt;/SpanOr&gt;</span>
+<span class="dtd_comment">          &lt;/SpanNear&gt;</span>
+<span class="dtd_comment">          % </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanNear</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">slop</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls if matching terms  have to appear in the order listed or can be reversed --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanNear</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">inOrder</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">true</span><span class="dtd_plain"> | </span><span class="dtd_attribute_name">false</span><span class="dtd_plain">) </span><span class="dtd_attribute_value">&quot;true&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- Looks for a SpanQuery match occuring near the beginning of a document</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> </span>
+<span class="dtd_comment">            &lt;em&gt;Find letters where the first 50 words talk about a resignation:&lt;/em&gt;</span>
+<span class="dtd_comment">            %             </span>
+<span class="dtd_comment">             &lt;SpanFirst end=&quot;50&quot;&gt;</span>
+<span class="dtd_comment">                   &lt;SpanOrTerms fieldName=&quot;text&quot;&gt;resigning resign leave&lt;/SpanOrTerms&gt;</span>
+<span class="dtd_comment">             &lt;/SpanFirst&gt;</span>
+<span class="dtd_comment">             %</span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">     --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanFirst</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain">;) </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Controls the end of the region considered in a document's field (expressed in word number, not byte offset) --&gt;</span><span class="dtd_plain"> </span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanFirst</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">end</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_keyword">#REQUIRED</span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanFirst</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+<span class="dtd_comment">&lt;!-- Finds documents matching a SpanQuery but not if matching another SpanQuery </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt;Find documents talking about social services but not containing the word &quot;public&quot;&lt;/em&gt;</span>
+<span class="dtd_comment">          %</span>
+<span class="dtd_comment">          &lt;SpanNot fieldName=&quot;text&quot;&gt;</span>
+<span class="dtd_comment">             &lt;Include&gt;</span>
+<span class="dtd_comment">                &lt;SpanNear slop=&quot;2&quot; inOrder=&quot;true&quot;&gt;      </span>
+<span class="dtd_comment">                     &lt;SpanTerm&gt;social&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                     &lt;SpanTerm&gt;services&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">                &lt;/SpanNear&gt;             </span>
+<span class="dtd_comment">             &lt;/Include&gt;</span>
+<span class="dtd_comment">             &lt;Exclude&gt;</span>
+<span class="dtd_comment">                &lt;SpanTerm&gt;public&lt;/SpanTerm&gt;</span>
+<span class="dtd_comment">             &lt;/Exclude&gt;</span>
+<span class="dtd_comment">          &lt;/SpanNot&gt;</span>
+<span class="dtd_comment">          % </span>
+<span class="dtd_comment">    </span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">SpanNot</span><span class="dtd_plain"> (</span><span class="dtd_attribute_name">Include</span><span class="dtd_plain">,</span><span class="dtd_attribute_name">Exclude</span><span class="dtd_plain">) </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The SpanQuery to find --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Include</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain">;) </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- The SpanQuery to be avoided --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">Exclude</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">spanQueries</span><span class="dtd_plain">;) </span><span class="dtd_tag_symbols">&gt;</span>
+
+
+<span class="dtd_comment">&lt;!-- a utility tag to wrap any filter as a query </span>
+<span class="dtd_comment">    </span><span class="dtd_dtddoc_tag">@example</span><span class="dtd_comment"> &lt;em&gt; Find all documents from the last 10 years &lt;/em&gt;</span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">     &lt;ConstantScoreQuery&gt;</span>
+<span class="dtd_comment">           &lt;RangeFilter fieldName=&quot;date&quot; lowerTerm=&quot;19970101&quot; upperTerm=&quot;20070101&quot;/&gt;</span>
+<span class="dtd_comment">     &lt;/ConstantScoreQuery&gt;  </span>
+<span class="dtd_comment">    %</span>
+<span class="dtd_comment">    --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ELEMENT</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">ConstantScoreQuery</span><span class="dtd_plain"> (%</span><span class="dtd_attribute_name">filters</span><span class="dtd_plain">;)* </span><span class="dtd_tag_symbols">&gt;</span>
+<span class="dtd_comment">&lt;!-- Optional boost for matches on this query. Values &gt; 1 --&gt;</span>
+<span class="dtd_tag_symbols">&lt;!</span><span class="dtd_tag_name">ATTLIST</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">ConstantScoreQuery</span><span class="dtd_plain"> </span><span class="dtd_attribute_name">boost</span><span class="dtd_plain"> </span><span class="dtd_keyword">CDATA</span><span class="dtd_plain"> </span><span class="dtd_attribute_value">&quot;1.0&quot;</span><span class="dtd_tag_symbols">&gt;</span>
+
+
+
+</pre>
+</body></html>
diff --git a/contrib/xml-query-parser/docs/cctree.js b/contrib/xml-query-parser/docs/cctree.js
new file mode 100644
index 0000000..bc30014
--- /dev/null
+++ b/contrib/xml-query-parser/docs/cctree.js
@@ -0,0 +1,291 @@
+/* This code is based on the one originally provided by
+   Geir Landr? in his dTree 2.05 package. You can get it
+   at : www.destroydrop.com/javascript/tree/.
+   
+   Therefore, the DTDDoc team considers that this code is 
+   Copyright (c) 2002-2003 Geir Landr?. Since the original
+   author didn't clearly forbids copies of this part, we
+   assume we're not doing anything wrong in porviding it
+   to you, in a modified or non-modified form.
+*/
+
+/*   
+   Geir Landr? : Orignal version, for dTree.
+   
+   Michael Koehrsen (10/2004) : Original modification to
+      allow DTDDoc to use this.
+   
+   Stefan Champailler (10/2004) : Make sure that the first
+      level of the tree is not shown (aesthetic stuff).
+*/
+
+//----------------------------------------------------------------
+// CCTree
+// Implements a DHTML tree with the following features:
+// - Supports a general directed graph as the underlying model.
+// - Supports a concept of an "always open" node.
+//----------------------------------------------------------------
+
+// Private class _CCTreeModelNode
+function _CCTreeModelNode(id,label,link,alwaysOpen,initiallyOpen)
+{
+    this.id = id;
+    this.label = label;
+    this.link = link;
+    this.alwaysOpen = alwaysOpen;
+    this.initiallyOpen = initiallyOpen;
+
+    // children and childLabels are parallel arrays.
+    // By default, childLabels[i] == children[i].label,
+    // but the link operation may optionally specify
+    // a child label that is specific to that parent-child 
+    // relationship.  
+    this.children = new Array();
+    this.childLabels = new Array();
+}
+
+_CCTreeModelNode.prototype.addChild = function(child,childLabel)
+{
+    this.children.push(child);
+    if (childLabel) this.childLabels.push(childLabel);
+    else this.childLabels.push(child.label);
+}
+
+// Private class _CCDisplayNode
+function _CCDisplayNode(modelNode,parentNode,treeId,label)
+{
+    this.modelNode = modelNode;
+    this.parentNode = parentNode;
+    this.treeId = treeId;
+
+    if (label) this.label = label;
+    else this.label = modelNode.label;
+
+    this.isLastChild = false;
+
+    if (this.parentNode) {
+        this.id = this.parentNode.id + ":" + this.modelNode.id;
+
+        /* Stefan Champailler : This little fix is clever ! Let's check the
+           following tree:
+           
+           alpha (1) -+-> beta (69)
+                      \-> beta (69).
+                      
+           This describes a tree with three nodes. Two of them are links
+           (beta). In that case, both the "beta" node have an id of "1:69".
+           So if one calls openNode on any of them, what happens is that only
+           one actually gets opened. To prevent that, I change the id of the
+           node on the fly to make sure there are only unique id's. 
+           
+           Please note this code is not very efficient (and yes, the right
+           number of slash will be added :)) */
+           
+        for( var k=0; k<parentNode.children.length; k++) {
+            if( parentNode.children[k].id == this.id)
+                this.id = this.id + "/";
+        }
+        
+        /* end of fix */
+    }
+    else this.id = this.modelNode.id;
+
+    CCTree.trees[this.treeId].allDisplayNodes[this.id] = this;
+
+    this.isOpen = this.modelNode.alwaysOpen || this.modelNode.initiallyOpen;
+    if (this.isOpen)
+    {
+        this.constructChildren();
+    }
+}
+
+_CCDisplayNode.prototype.toInnerHTML = function()
+{
+    var indent = "";
+
+    if (this.isOpen && !this.children) this.constructChildren();
+
+    if (this.isLastChild)
+    {
+        if (this.modelNode.alwaysOpen)
+            indent = this.imageTag("joinbottom.gif");
+        else if (this.isOpen)
+            indent = this.imageTag("minusbottom.gif","close")
+        else if (this.modelNode.children.length)
+            indent = this.imageTag("plusbottom.gif","open");
+        else
+            indent = this.imageTag("joinbottom.gif");
+    }
+    else
+    {
+        if (this.modelNode.alwaysOpen)
+            indent = this.imageTag("join.gif");
+        else if (this.isOpen)
+            indent = this.imageTag("minus.gif","close");
+        else if (this.modelNode.children.length)
+            indent = this.imageTag("plus.gif","open");
+        else
+            indent = this.imageTag("join.gif");
+    }
+
+    /* Construct a horizontal line of the tree */
+
+    var currAnc = this.parentNode;
+    while (currAnc)
+    {
+        if (currAnc.isLastChild)
+            indent = this.imageTag("empty.gif") + indent;
+        else
+            indent = this.imageTag("line.gif") + indent;
+        currAnc = currAnc.parentNode;
+    }
+
+    var result = indent + this.nodeContent();
+
+    /* Recurse deeper in the tree */
+    
+    if (this.isOpen && this.children)
+    {
+        var ix;
+        for (ix in this.children)
+        {
+            result += this.children[ix];
+        }
+    }
+
+    return result;
+}
+
+_CCDisplayNode.prototype.toString = function()
+{
+    return "<div class='cctree-node' id='" + this.divId() + "'>" + this.toInnerHTML() + "</div>";
+}
+
+_CCDisplayNode.prototype.constructChildren = function()
+{
+    if (this.modelNode.children.length > 0)
+    {
+        this.children = new Array();
+        var ix;
+        for (ix in this.modelNode.children)
+        {
+            this.children.push(new _CCDisplayNode(this.modelNode.children[ix],
+                                                  this,
+                                                  this.treeId,
+                                                  this.modelNode.childLabels[ix]));
+        }
+        this.children[this.children.length-1].isLastChild = true;
+    }
+}
+
+_CCDisplayNode.prototype.imageTag = function(imgName,action)
+{
+    var href =  null;
+
+    if (action == "open") href="CCTree.trees[" + this.treeId + "].openNode('" + this.id + "')";
+    if (action == "close") href="CCTree.trees[" + this.treeId + "].closeNode('" + this.id +  "')";
+
+    if (href) return "<a href=\"javascript:" + href + "\"><img src='img/" + imgName + "' border='0'></a>";
+    else return "<img src='img/" + imgName + "'>";
+}
+
+_CCDisplayNode.prototype.divId = function()
+{
+    return "CCTree_" + this.treeId + "_" + this.id;
+}
+
+_CCDisplayNode.prototype.nodeContent = function()
+{
+    var target = "";
+
+    if (CCTree.trees[this.treeId].linkTarget) target = " target='" + CCTree.trees[this.treeId].linkTarget + "'";
+
+    if (this.modelNode.link)
+        return "<a href='" + this.modelNode.link + "'" + target + ">" + this.label + "</a>";
+    else return this.label;
+}
+
+_CCDisplayNode.prototype.open = function()
+{
+    this.isOpen = true;
+    // document.all is known to work on IE but not on Konqueror or Mozilla.
+    // So I've changed it to something more portable.
+    
+    //document.all[this.divId()].innerHTML = this.toInnerHTML();
+    document.getElementById(this.divId()).innerHTML = this.toInnerHTML();
+}
+
+_CCDisplayNode.prototype.close = function()
+{
+    this.isOpen = false;
+    //document.all[this.divId()].innerHTML = this.toInnerHTML();
+    document.getElementById(this.divId()).innerHTML = this.toInnerHTML();
+}
+
+// Public class CCTree
+CCTree = function(linkTarget)
+{
+    // may have multiple roots:
+    this.rootModelNodes = new Array();
+    this.allModelNodes = new Array();
+    this.treeId = CCTree.trees.length;
+    this.allDisplayNodes = new Array(); // indexed by id
+    this.linkTarget = linkTarget;
+    CCTree.trees.push(this);
+}
+
+// static variables
+CCTree.trees = new Array();
+
+CCTree.prototype.addRootNode = function (id,label,link,alwaysOpen,initiallyOpen)
+{
+    this.rootModelNodes[id] = this.addNode(id,label,link,alwaysOpen,initiallyOpen);
+}
+
+CCTree.prototype.addNode = function(id,label,link,alwaysOpen,initiallyOpen)
+{
+    var newNode = new _CCTreeModelNode(id,label,link,alwaysOpen,initiallyOpen);
+    this.allModelNodes[id] = newNode;
+    return newNode;
+}
+
+CCTree.prototype.linkNodes = function(parentId,childId,childLabel)
+{
+    this.allModelNodes[parentId].addChild(this.allModelNodes[childId],childLabel);
+}
+
+CCTree.prototype.constructDisplayNodes = function()
+{
+    this.rootDisplayNodes = new Array();
+    var ix;
+    for (ix in this.rootModelNodes)
+    {
+        this.rootDisplayNodes.push(new _CCDisplayNode(this.rootModelNodes[ix],null,this.treeId));
+    }
+    this.rootDisplayNodes[this.rootDisplayNodes.length-1].isLastChild = true;
+}
+
+CCTree.prototype.openNode = function(displayNodeId)
+{
+    this.allDisplayNodes[displayNodeId].open();
+}
+
+CCTree.prototype.closeNode = function(displayNodeId) 
+{
+    this.allDisplayNodes[displayNodeId].close();
+}
+
+CCTree.prototype.toString = function()
+{
+    this.constructDisplayNodes();
+
+    var ix;
+    var result = "";
+
+    for (ix in this.rootDisplayNodes)
+    {
+        result += this.rootDisplayNodes[ix].toString();
+    }
+
+    return result;
+}
diff --git a/contrib/xml-query-parser/docs/dtreeStyle.css b/contrib/xml-query-parser/docs/dtreeStyle.css
new file mode 100644
index 0000000..f21c66e
--- /dev/null
+++ b/contrib/xml-query-parser/docs/dtreeStyle.css
@@ -0,0 +1,30 @@
+/* This CSS is based on the one originally provided by
+   Geir Landr? in his dTree 2.05 package. You can get it
+   at : www.destroydrop.com/javascript/tree/.
+   
+   Therefore, the DTDDoc team considers that this code is 
+   Copyright (c) 2002-2003 Geir Landr?. Since the original
+   author didn't clearly forbids copies of this part, we
+   assume we're not doing anything wrong in porviding it
+   to you, in a modified or non-modified form.
+*/
+
+/*   
+   Geir Landr? : Orignal version, for dTree.
+   
+   Stefan Champailler (10/2004) : Style changes here and
+      there.
+*/
+
+
+.dtree {
+   font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;
+   font-size: 11 px;
+   white-space: nowrap;
+}
+.dtree img { vertical-align: middle; }
+.dtree a { }
+.dtree a.node, .dtree a.nodeSel { white-space: nowrap; padding: 1px 2px 1px 2px; }
+.dtree a.node:hover, .dtree a.nodeSel:hover {}
+.dtree a.nodeSel { }
+.dtree .clip { overflow: hidden; }
diff --git a/contrib/xml-query-parser/docs/elementsIndex.html b/contrib/xml-query-parser/docs/elementsIndex.html
new file mode 100644
index 0000000..264a1ce
--- /dev/null
+++ b/contrib/xml-query-parser/docs/elementsIndex.html
@@ -0,0 +1,60 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head><title>elements' index</title>
+<meta http-equiv='CONTENT-TYPE' content='text/html' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+</head><body>
+<p class='DTDSource'>Elements - Entities - Source | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='elementsIndex.html' target='_top'>NO FRAMES</a></p><a href='#B'>B</a> <a href='#C'>C</a> <a href='#D'>D</a> <a href='#E'>E</a> <a href='#F'>F</a> <a href='#I'>I</a> <a href='#L'>L</a> <a href='#M'>M</a> <a href='#Q'>Q</a> <a href='#R'>R</a> <a href='#S'>S</a> <a href='#T'>T</a> <a href='#U'>U</a> <br />
+<a name='B'></a>
+<h2>B</h2>
+BooleanFilter - <a href='LuceneContribQuery.dtd.html#BooleanFilter'>Contrib Lucene</a><br />
+BooleanQuery - <a href='LuceneContribQuery.dtd.html#BooleanQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#BooleanQuery'>Core Lucene</a><br />
+BoostingQuery - <a href='LuceneContribQuery.dtd.html#BoostingQuery'>Contrib Lucene</a><br />
+BoostQuery - <a href='LuceneContribQuery.dtd.html#BoostQuery'>Contrib Lucene</a><br />
+<a name='C'></a>
+<h2>C</h2>
+CachedFilter - <a href='LuceneContribQuery.dtd.html#CachedFilter'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#CachedFilter'>Core Lucene</a><br />
+Clause - <a href='LuceneContribQuery.dtd.html#Clause'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#Clause'>Core Lucene</a><br />
+ConstantScoreQuery - <a href='LuceneContribQuery.dtd.html#ConstantScoreQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#ConstantScoreQuery'>Core Lucene</a><br />
+<a name='D'></a>
+<h2>D</h2>
+DuplicateFilter - <a href='LuceneContribQuery.dtd.html#DuplicateFilter'>Contrib Lucene</a><br />
+<a name='E'></a>
+<h2>E</h2>
+Exclude - <a href='LuceneContribQuery.dtd.html#Exclude'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#Exclude'>Core Lucene</a><br />
+<a name='F'></a>
+<h2>F</h2>
+Field - <a href='LuceneContribQuery.dtd.html#Field'>Contrib Lucene</a><br />
+Filter - <a href='LuceneContribQuery.dtd.html#Filter'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#Filter'>Core Lucene</a><br />
+FilteredQuery - <a href='LuceneContribQuery.dtd.html#FilteredQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#FilteredQuery'>Core Lucene</a><br />
+FuzzyLikeThisQuery - <a href='LuceneContribQuery.dtd.html#FuzzyLikeThisQuery'>Contrib Lucene</a><br />
+<a name='I'></a>
+<h2>I</h2>
+Include - <a href='LuceneContribQuery.dtd.html#Include'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#Include'>Core Lucene</a><br />
+<a name='L'></a>
+<h2>L</h2>
+LikeThisQuery - <a href='LuceneContribQuery.dtd.html#LikeThisQuery'>Contrib Lucene</a><br />
+<a name='M'></a>
+<h2>M</h2>
+MatchAllDocsQuery - <a href='LuceneContribQuery.dtd.html#MatchAllDocsQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#MatchAllDocsQuery'>Core Lucene</a><br />
+<a name='Q'></a>
+<h2>Q</h2>
+Query - <a href='LuceneContribQuery.dtd.html#Query'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#Query'>Core Lucene</a><br />
+<a name='R'></a>
+<h2>R</h2>
+RangeFilter - <a href='LuceneContribQuery.dtd.html#RangeFilter'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#RangeFilter'>Core Lucene</a><br />
+<a name='S'></a>
+<h2>S</h2>
+SpanFirst - <a href='LuceneContribQuery.dtd.html#SpanFirst'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanFirst'>Core Lucene</a><br />
+SpanNear - <a href='LuceneContribQuery.dtd.html#SpanNear'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanNear'>Core Lucene</a><br />
+SpanNot - <a href='LuceneContribQuery.dtd.html#SpanNot'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanNot'>Core Lucene</a><br />
+SpanOr - <a href='LuceneContribQuery.dtd.html#SpanOr'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanOr'>Core Lucene</a><br />
+SpanOrTerms - <a href='LuceneContribQuery.dtd.html#SpanOrTerms'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanOrTerms'>Core Lucene</a><br />
+SpanTerm - <a href='LuceneContribQuery.dtd.html#SpanTerm'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#SpanTerm'>Core Lucene</a><br />
+<a name='T'></a>
+<h2>T</h2>
+TermQuery - <a href='LuceneContribQuery.dtd.html#TermQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#TermQuery'>Core Lucene</a><br />
+TermsFilter - <a href='LuceneContribQuery.dtd.html#TermsFilter'>Contrib Lucene</a><br />
+TermsQuery - <a href='LuceneContribQuery.dtd.html#TermsQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#TermsQuery'>Core Lucene</a><br />
+<a name='U'></a>
+<h2>U</h2>
+UserQuery - <a href='LuceneContribQuery.dtd.html#UserQuery'>Contrib Lucene</a>, <a href='LuceneCoreQuery.dtd.html#UserQuery'>Core Lucene</a></body></html>
diff --git a/contrib/xml-query-parser/docs/img/empty.gif b/contrib/xml-query-parser/docs/img/empty.gif
new file mode 100644
index 0000000..b5cf523
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/empty.gif differ
diff --git a/contrib/xml-query-parser/docs/img/join.gif b/contrib/xml-query-parser/docs/img/join.gif
new file mode 100644
index 0000000..34dd476
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/join.gif differ
diff --git a/contrib/xml-query-parser/docs/img/joinbottom.gif b/contrib/xml-query-parser/docs/img/joinbottom.gif
new file mode 100644
index 0000000..48b81c8
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/joinbottom.gif differ
diff --git a/contrib/xml-query-parser/docs/img/line.gif b/contrib/xml-query-parser/docs/img/line.gif
new file mode 100644
index 0000000..1a259ee
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/line.gif differ
diff --git a/contrib/xml-query-parser/docs/img/minus.gif b/contrib/xml-query-parser/docs/img/minus.gif
new file mode 100644
index 0000000..3d212a9
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/minus.gif differ
diff --git a/contrib/xml-query-parser/docs/img/minusbottom.gif b/contrib/xml-query-parser/docs/img/minusbottom.gif
new file mode 100644
index 0000000..dc3198b
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/minusbottom.gif differ
diff --git a/contrib/xml-query-parser/docs/img/plus.gif b/contrib/xml-query-parser/docs/img/plus.gif
new file mode 100644
index 0000000..b2c9972
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/plus.gif differ
diff --git a/contrib/xml-query-parser/docs/img/plusbottom.gif b/contrib/xml-query-parser/docs/img/plusbottom.gif
new file mode 100644
index 0000000..b5671d8
Binary files /dev/null and b/contrib/xml-query-parser/docs/img/plusbottom.gif differ
diff --git a/contrib/xml-query-parser/docs/index.html b/contrib/xml-query-parser/docs/index.html
new file mode 100644
index 0000000..8488ff5
--- /dev/null
+++ b/contrib/xml-query-parser/docs/index.html
@@ -0,0 +1,16 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
+<html><head>
+<title>DTDDoc for Lucene XML Query syntax</title>
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' /></head>
+<frameset cols='20%, 80%'>
+   <frame src='toc.html' />
+   <frame src='intro.html' name='detail' />
+   <noframes><body>
+<p class='DTDSource'>Elements - Entities - Source | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='intro.html' target='_top'>NO FRAMES</a></p><h1>Lucene XML Query syntax</h1>
+<table border='1' cellspacing='0'>
+<tr><td><code><a href='LuceneContribQuery.dtd.html'>LuceneContribQuery.dtd</a></code></td><td>Contrib Lucene</td></tr>
+<tr><td><code><a href='LuceneCoreQuery.dtd.html'>LuceneCoreQuery.dtd</a></code></td><td>Core Lucene</td></tr>
+</table>
+<p>This documentation was generated by <a href='http://dtddoc.sourceforge.net'>DTDDoc</a> 1.1.0 (2007-02-03) !</p>
+</body></noframes>
+</frameset></html>
diff --git a/contrib/xml-query-parser/docs/intro.html b/contrib/xml-query-parser/docs/intro.html
new file mode 100644
index 0000000..a2a0976
--- /dev/null
+++ b/contrib/xml-query-parser/docs/intro.html
@@ -0,0 +1,12 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head><title>DTDDoc for Lucene XML Query syntax</title>
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+</head><body>
+<p class='DTDSource'>Elements - Entities - Source | <a href='intro.html'>Intro</a> - <a href='elementsIndex.html'>Index</a><br /><a href='index.html' target='_top'>FRAMES</a>&nbsp;/&nbsp;<a href='intro.html' target='_top'>NO FRAMES</a></p><h1>Lucene XML Query syntax</h1>
+<table border='1' cellspacing='0'>
+<tr><td><code><a href='LuceneContribQuery.dtd.html'>LuceneContribQuery.dtd</a></code></td><td>Contrib Lucene</td></tr>
+<tr><td><code><a href='LuceneCoreQuery.dtd.html'>LuceneCoreQuery.dtd</a></code></td><td>Core Lucene</td></tr>
+</table>
+<p>This documentation was generated by <a href='http://dtddoc.sourceforge.net'>DTDDoc</a> 1.1.0 (2007-02-03) !</p>
+<p>Use the left menu to navigate through the DTDs !</p>
+</body></html>
diff --git a/contrib/xml-query-parser/docs/toc.html b/contrib/xml-query-parser/docs/toc.html
new file mode 100644
index 0000000..4198342
--- /dev/null
+++ b/contrib/xml-query-parser/docs/toc.html
@@ -0,0 +1,509 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html><head>
+<meta http-equiv='CONTENT-TYPE' content='text/html' />
+<link rel='StyleSheet' href='DTDDocStyle.css' type='text/css' media='screen' />
+<link rel='StyleSheet' href='dtreeStyle.css' type='text/css' media='screen' />
+<script type='text/javascript' src='cctree.js'></script>
+<title>Lucene XML Query syntax, 09-Oct-2007</title>
+</head><body>
+<h1 class='TOCTitle'>Lucene XML Query syntax</h1>
+<h2 class='TOCTitle'>09-Oct-2007</h2>
+<a href='elementsIndex.html' target='detail'>Elements' index</a><hr />
+<div class='dtree'>
+<script type='text/javascript'>
+//<!--
+eltTree = new CCTree('detail');
+eltTree.addRootNode('0','Contrib Lucene','LuceneContribQuery.dtd.html',false,false)
+eltTree.addNode('1','BooleanFilter','LuceneContribQuery.dtd.html#BooleanFilter',false,false)
+eltTree.linkNodes('0','1')
+eltTree.addNode('2','<b><i>&lt;sequence&gt;+</i></b>',null,true,false)
+eltTree.linkNodes('1','2')
+eltTree.addNode('3','<b>Clause</b>','LuceneContribQuery.dtd.html#Clause',false,false)
+eltTree.linkNodes('2','3')
+eltTree.addNode('4','@occurs','LuceneContribQuery.dtd.html#Clause_occurs',false,false)
+eltTree.linkNodes('3','4')
+eltTree.addNode('5','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('3','5')
+eltTree.addNode('6','<b>BooleanQuery</b>','LuceneContribQuery.dtd.html#BooleanQuery',false,false)
+eltTree.linkNodes('5','6')
+eltTree.addNode('7','@boost','LuceneContribQuery.dtd.html#BooleanQuery_boost',false,false)
+eltTree.linkNodes('6','7')
+eltTree.addNode('8','@disableCoord','LuceneContribQuery.dtd.html#BooleanQuery_disableCoord',false,false)
+eltTree.linkNodes('6','8')
+eltTree.addNode('9','@fieldName','LuceneContribQuery.dtd.html#BooleanQuery_fieldName',false,false)
+eltTree.linkNodes('6','9')
+eltTree.addNode('10','@minimumNumberShouldMatch','LuceneContribQuery.dtd.html#BooleanQuery_minimumNumberShouldMatch',false,false)
+eltTree.linkNodes('6','10')
+eltTree.addNode('11','<b><i>&lt;sequence&gt;+</i></b>',null,true,false)
+eltTree.linkNodes('6','11')
+eltTree.linkNodes('11','3','<b>Clause</b>')
+eltTree.addNode('12','<b>UserQuery</b>','LuceneContribQuery.dtd.html#UserQuery',false,false)
+eltTree.linkNodes('5','12')
+eltTree.addNode('13','@boost','LuceneContribQuery.dtd.html#UserQuery_boost',false,false)
+eltTree.linkNodes('12','13')
+eltTree.addNode('14','<b>FilteredQuery</b>','LuceneContribQuery.dtd.html#FilteredQuery',false,false)
+eltTree.linkNodes('5','14')
+eltTree.addNode('15','@boost','LuceneContribQuery.dtd.html#FilteredQuery_boost',false,false)
+eltTree.linkNodes('14','15')
+eltTree.addNode('16','<b>Query</b>','LuceneContribQuery.dtd.html#Query',false,false)
+eltTree.linkNodes('14','16')
+eltTree.addNode('17','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('16','17')
+eltTree.linkNodes('17','6','<b>BooleanQuery</b>')
+eltTree.linkNodes('17','12','<b>UserQuery</b>')
+eltTree.linkNodes('17','14','<b>FilteredQuery</b>')
+eltTree.addNode('18','<b>TermQuery</b>','LuceneContribQuery.dtd.html#TermQuery',false,false)
+eltTree.linkNodes('17','18')
+eltTree.addNode('19','@boost','LuceneContribQuery.dtd.html#TermQuery_boost',false,false)
+eltTree.linkNodes('18','19')
+eltTree.addNode('20','@fieldName','LuceneContribQuery.dtd.html#TermQuery_fieldName',false,false)
+eltTree.linkNodes('18','20')
+eltTree.addNode('21','<b>TermsQuery</b>','LuceneContribQuery.dtd.html#TermsQuery',false,false)
+eltTree.linkNodes('17','21')
+eltTree.addNode('22','@boost','LuceneContribQuery.dtd.html#TermsQuery_boost',false,false)
+eltTree.linkNodes('21','22')
+eltTree.addNode('23','@disableCoord','LuceneContribQuery.dtd.html#TermsQuery_disableCoord',false,false)
+eltTree.linkNodes('21','23')
+eltTree.addNode('24','@fieldName','LuceneContribQuery.dtd.html#TermsQuery_fieldName',false,false)
+eltTree.linkNodes('21','24')
+eltTree.addNode('25','@minimumNumberShouldMatch','LuceneContribQuery.dtd.html#TermsQuery_minimumNumberShouldMatch',false,false)
+eltTree.linkNodes('21','25')
+eltTree.addNode('26','<b>&lt;MatchAllDocsQuery/&gt;</b>','LuceneContribQuery.dtd.html#MatchAllDocsQuery',false,false)
+eltTree.linkNodes('17','26')
+eltTree.addNode('27','<b>ConstantScoreQuery</b>','LuceneContribQuery.dtd.html#ConstantScoreQuery',false,false)
+eltTree.linkNodes('17','27')
+eltTree.addNode('28','@boost','LuceneContribQuery.dtd.html#ConstantScoreQuery_boost',false,false)
+eltTree.linkNodes('27','28')
+eltTree.addNode('29','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('27','29')
+eltTree.addNode('30','<b>&lt;RangeFilter/&gt;</b>','LuceneContribQuery.dtd.html#RangeFilter',false,false)
+eltTree.linkNodes('29','30')
+eltTree.addNode('31','@fieldName','LuceneContribQuery.dtd.html#RangeFilter_fieldName',false,false)
+eltTree.linkNodes('30','31')
+eltTree.addNode('32','@includeLower','LuceneContribQuery.dtd.html#RangeFilter_includeLower',false,false)
+eltTree.linkNodes('30','32')
+eltTree.addNode('33','@includeUpper','LuceneContribQuery.dtd.html#RangeFilter_includeUpper',false,false)
+eltTree.linkNodes('30','33')
+eltTree.addNode('34','<b>@lowerTerm</b>','LuceneContribQuery.dtd.html#RangeFilter_lowerTerm',false,false)
+eltTree.linkNodes('30','34')
+eltTree.addNode('35','<b>@upperTerm</b>','LuceneContribQuery.dtd.html#RangeFilter_upperTerm',false,false)
+eltTree.linkNodes('30','35')
+eltTree.addNode('36','<b>CachedFilter</b>','LuceneContribQuery.dtd.html#CachedFilter',false,false)
+eltTree.linkNodes('29','36')
+eltTree.addNode('37','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('36','37')
+eltTree.linkNodes('37','6','<b>BooleanQuery</b>')
+eltTree.linkNodes('37','12','<b>UserQuery</b>')
+eltTree.linkNodes('37','14','<b>FilteredQuery</b>')
+eltTree.linkNodes('37','18','<b>TermQuery</b>')
+eltTree.linkNodes('37','21','<b>TermsQuery</b>')
+eltTree.linkNodes('37','26','<b>MatchAllDocsQuery</b>')
+eltTree.linkNodes('37','27','<b>ConstantScoreQuery</b>')
+eltTree.addNode('38','<b>SpanOr</b>','LuceneContribQuery.dtd.html#SpanOr',false,false)
+eltTree.linkNodes('37','38')
+eltTree.addNode('39','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('38','39')
+eltTree.linkNodes('39','38','<b>SpanOr</b>')
+eltTree.addNode('40','<b>SpanNear</b>','LuceneContribQuery.dtd.html#SpanNear',false,false)
+eltTree.linkNodes('39','40')
+eltTree.addNode('41','@inOrder','LuceneContribQuery.dtd.html#SpanNear_inOrder',false,false)
+eltTree.linkNodes('40','41')
+eltTree.addNode('42','<b>@slop</b>','LuceneContribQuery.dtd.html#SpanNear_slop',false,false)
+eltTree.linkNodes('40','42')
+eltTree.addNode('43','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('40','43')
+eltTree.linkNodes('43','38','<b>SpanOr</b>')
+eltTree.linkNodes('43','40','<b>SpanNear</b>')
+eltTree.addNode('44','<b>SpanOrTerms</b>','LuceneContribQuery.dtd.html#SpanOrTerms',false,false)
+eltTree.linkNodes('43','44')
+eltTree.addNode('45','<b>@fieldName</b>','LuceneContribQuery.dtd.html#SpanOrTerms_fieldName',false,false)
+eltTree.linkNodes('44','45')
+eltTree.addNode('46','<b>SpanFirst</b>','LuceneContribQuery.dtd.html#SpanFirst',false,false)
+eltTree.linkNodes('43','46')
+eltTree.addNode('47','@boost','LuceneContribQuery.dtd.html#SpanFirst_boost',false,false)
+eltTree.linkNodes('46','47')
+eltTree.addNode('48','<b>@end</b>','LuceneContribQuery.dtd.html#SpanFirst_end',false,false)
+eltTree.linkNodes('46','48')
+eltTree.addNode('49','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('46','49')
+eltTree.linkNodes('49','38','<b>SpanOr</b>')
+eltTree.linkNodes('49','40','<b>SpanNear</b>')
+eltTree.linkNodes('49','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('49','46','<b>SpanFirst</b>')
+eltTree.addNode('50','<b>SpanNot</b>','LuceneContribQuery.dtd.html#SpanNot',false,false)
+eltTree.linkNodes('49','50')
+eltTree.addNode('51','<b>Include</b>','LuceneContribQuery.dtd.html#Include',false,false)
+eltTree.linkNodes('50','51')
+eltTree.addNode('52','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('51','52')
+eltTree.linkNodes('52','38','<b>SpanOr</b>')
+eltTree.linkNodes('52','40','<b>SpanNear</b>')
+eltTree.linkNodes('52','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('52','46','<b>SpanFirst</b>')
+eltTree.linkNodes('52','50','<b>SpanNot</b>')
+eltTree.addNode('53','<b>SpanTerm</b>','LuceneContribQuery.dtd.html#SpanTerm',false,false)
+eltTree.linkNodes('52','53')
+eltTree.addNode('54','<b>@fieldName</b>','LuceneContribQuery.dtd.html#SpanTerm_fieldName',false,false)
+eltTree.linkNodes('53','54')
+eltTree.addNode('55','<b>Exclude</b>','LuceneContribQuery.dtd.html#Exclude',false,false)
+eltTree.linkNodes('50','55')
+eltTree.addNode('56','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('55','56')
+eltTree.linkNodes('56','38','<b>SpanOr</b>')
+eltTree.linkNodes('56','40','<b>SpanNear</b>')
+eltTree.linkNodes('56','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('56','46','<b>SpanFirst</b>')
+eltTree.linkNodes('56','50','<b>SpanNot</b>')
+eltTree.linkNodes('56','53','<b>SpanTerm</b>')
+eltTree.linkNodes('49','53','<b>SpanTerm</b>')
+eltTree.linkNodes('43','50','<b>SpanNot</b>')
+eltTree.linkNodes('43','53','<b>SpanTerm</b>')
+eltTree.linkNodes('39','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('39','46','<b>SpanFirst</b>')
+eltTree.linkNodes('39','50','<b>SpanNot</b>')
+eltTree.linkNodes('39','53','<b>SpanTerm</b>')
+eltTree.linkNodes('37','40','<b>SpanNear</b>')
+eltTree.linkNodes('37','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('37','46','<b>SpanFirst</b>')
+eltTree.linkNodes('37','50','<b>SpanNot</b>')
+eltTree.linkNodes('37','53','<b>SpanTerm</b>')
+eltTree.addNode('57','<b>LikeThisQuery</b>','LuceneContribQuery.dtd.html#LikeThisQuery',false,false)
+eltTree.linkNodes('37','57')
+eltTree.addNode('58','@boost','LuceneContribQuery.dtd.html#LikeThisQuery_boost',false,false)
+eltTree.linkNodes('57','58')
+eltTree.addNode('59','@fieldNames','LuceneContribQuery.dtd.html#LikeThisQuery_fieldNames',false,false)
+eltTree.linkNodes('57','59')
+eltTree.addNode('60','@maxQueryTerms','LuceneContribQuery.dtd.html#LikeThisQuery_maxQueryTerms',false,false)
+eltTree.linkNodes('57','60')
+eltTree.addNode('61','@minTermFrequency','LuceneContribQuery.dtd.html#LikeThisQuery_minTermFrequency',false,false)
+eltTree.linkNodes('57','61')
+eltTree.addNode('62','@percentTermsToMatch','LuceneContribQuery.dtd.html#LikeThisQuery_percentTermsToMatch',false,false)
+eltTree.linkNodes('57','62')
+eltTree.addNode('63','@stopWords','LuceneContribQuery.dtd.html#LikeThisQuery_stopWords',false,false)
+eltTree.linkNodes('57','63')
+eltTree.addNode('64','<b>BoostingQuery</b>','LuceneContribQuery.dtd.html#BoostingQuery',false,false)
+eltTree.linkNodes('37','64')
+eltTree.addNode('65','@boost','LuceneContribQuery.dtd.html#BoostingQuery_boost',false,false)
+eltTree.linkNodes('64','65')
+eltTree.linkNodes('64','16','<b>Query</b>')
+eltTree.addNode('66','<b>BoostQuery</b>','LuceneContribQuery.dtd.html#BoostQuery',false,false)
+eltTree.linkNodes('64','66')
+eltTree.addNode('67','@boost','LuceneContribQuery.dtd.html#BoostQuery_boost',false,false)
+eltTree.linkNodes('66','67')
+eltTree.addNode('68','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('66','68')
+eltTree.linkNodes('68','6','<b>BooleanQuery</b>')
+eltTree.linkNodes('68','12','<b>UserQuery</b>')
+eltTree.linkNodes('68','14','<b>FilteredQuery</b>')
+eltTree.linkNodes('68','18','<b>TermQuery</b>')
+eltTree.linkNodes('68','21','<b>TermsQuery</b>')
+eltTree.linkNodes('68','26','<b>MatchAllDocsQuery</b>')
+eltTree.linkNodes('68','27','<b>ConstantScoreQuery</b>')
+eltTree.linkNodes('68','38','<b>SpanOr</b>')
+eltTree.linkNodes('68','40','<b>SpanNear</b>')
+eltTree.linkNodes('68','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('68','46','<b>SpanFirst</b>')
+eltTree.linkNodes('68','50','<b>SpanNot</b>')
+eltTree.linkNodes('68','53','<b>SpanTerm</b>')
+eltTree.linkNodes('68','57','<b>LikeThisQuery</b>')
+eltTree.linkNodes('68','64','<b>BoostingQuery</b>')
+eltTree.addNode('69','<b>FuzzyLikeThisQuery</b>','LuceneContribQuery.dtd.html#FuzzyLikeThisQuery',false,false)
+eltTree.linkNodes('68','69')
+eltTree.addNode('70','@boost','LuceneContribQuery.dtd.html#FuzzyLikeThisQuery_boost',false,false)
+eltTree.linkNodes('69','70')
+eltTree.addNode('71','@ignoreTF','LuceneContribQuery.dtd.html#FuzzyLikeThisQuery_ignoreTF',false,false)
+eltTree.linkNodes('69','71')
+eltTree.addNode('72','@maxNumTerms','LuceneContribQuery.dtd.html#FuzzyLikeThisQuery_maxNumTerms',false,false)
+eltTree.linkNodes('69','72')
+eltTree.addNode('73','<i>&lt;sequence&gt;*</i>',null,true,false)
+eltTree.linkNodes('69','73')
+eltTree.addNode('74','<b>Field</b>','LuceneContribQuery.dtd.html#Field',false,false)
+eltTree.linkNodes('73','74')
+eltTree.addNode('75','@fieldName','LuceneContribQuery.dtd.html#Field_fieldName',false,false)
+eltTree.linkNodes('74','75')
+eltTree.addNode('76','@minSimilarity','LuceneContribQuery.dtd.html#Field_minSimilarity',false,false)
+eltTree.linkNodes('74','76')
+eltTree.addNode('77','@prefixLength','LuceneContribQuery.dtd.html#Field_prefixLength',false,false)
+eltTree.linkNodes('74','77')
+eltTree.linkNodes('37','69','<b>FuzzyLikeThisQuery</b>')
+eltTree.linkNodes('37','30','<b>RangeFilter</b>')
+eltTree.linkNodes('37','36','<b>CachedFilter</b>')
+eltTree.addNode('78','<b>TermsFilter</b>','LuceneContribQuery.dtd.html#TermsFilter',false,false)
+eltTree.linkNodes('37','78')
+eltTree.addNode('79','@fieldName','LuceneContribQuery.dtd.html#TermsFilter_fieldName',false,false)
+eltTree.linkNodes('78','79')
+eltTree.linkNodes('37','1','<b>BooleanFilter</b>')
+eltTree.addNode('80','<b>&lt;DuplicateFilter/&gt;</b>','LuceneContribQuery.dtd.html#DuplicateFilter',false,false)
+eltTree.linkNodes('37','80')
+eltTree.addNode('81','@fieldName','LuceneContribQuery.dtd.html#DuplicateFilter_fieldName',false,false)
+eltTree.linkNodes('80','81')
+eltTree.addNode('82','@keepMode','LuceneContribQuery.dtd.html#DuplicateFilter_keepMode',false,false)
+eltTree.linkNodes('80','82')
+eltTree.addNode('83','@processingMode','LuceneContribQuery.dtd.html#DuplicateFilter_processingMode',false,false)
+eltTree.linkNodes('80','83')
+eltTree.linkNodes('29','78','<b>TermsFilter</b>')
+eltTree.linkNodes('29','1','<b>BooleanFilter</b>')
+eltTree.linkNodes('29','80','<b>DuplicateFilter</b>')
+eltTree.linkNodes('17','38','<b>SpanOr</b>')
+eltTree.linkNodes('17','40','<b>SpanNear</b>')
+eltTree.linkNodes('17','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('17','46','<b>SpanFirst</b>')
+eltTree.linkNodes('17','50','<b>SpanNot</b>')
+eltTree.linkNodes('17','53','<b>SpanTerm</b>')
+eltTree.linkNodes('17','57','<b>LikeThisQuery</b>')
+eltTree.linkNodes('17','64','<b>BoostingQuery</b>')
+eltTree.linkNodes('17','69','<b>FuzzyLikeThisQuery</b>')
+eltTree.addNode('84','<b>Filter</b>','LuceneContribQuery.dtd.html#Filter',false,false)
+eltTree.linkNodes('14','84')
+eltTree.addNode('85','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('84','85')
+eltTree.linkNodes('85','30','<b>RangeFilter</b>')
+eltTree.linkNodes('85','36','<b>CachedFilter</b>')
+eltTree.linkNodes('85','78','<b>TermsFilter</b>')
+eltTree.linkNodes('85','1','<b>BooleanFilter</b>')
+eltTree.linkNodes('85','80','<b>DuplicateFilter</b>')
+eltTree.linkNodes('5','18','<b>TermQuery</b>')
+eltTree.linkNodes('5','21','<b>TermsQuery</b>')
+eltTree.linkNodes('5','26','<b>MatchAllDocsQuery</b>')
+eltTree.linkNodes('5','27','<b>ConstantScoreQuery</b>')
+eltTree.linkNodes('5','38','<b>SpanOr</b>')
+eltTree.linkNodes('5','40','<b>SpanNear</b>')
+eltTree.linkNodes('5','44','<b>SpanOrTerms</b>')
+eltTree.linkNodes('5','46','<b>SpanFirst</b>')
+eltTree.linkNodes('5','50','<b>SpanNot</b>')
+eltTree.linkNodes('5','53','<b>SpanTerm</b>')
+eltTree.linkNodes('5','57','<b>LikeThisQuery</b>')
+eltTree.linkNodes('5','64','<b>BoostingQuery</b>')
+eltTree.linkNodes('5','69','<b>FuzzyLikeThisQuery</b>')
+eltTree.linkNodes('5','30','<b>RangeFilter</b>')
+eltTree.linkNodes('5','36','<b>CachedFilter</b>')
+eltTree.linkNodes('5','78','<b>TermsFilter</b>')
+eltTree.linkNodes('5','1','<b>BooleanFilter</b>')
+eltTree.linkNodes('5','80','<b>DuplicateFilter</b>')
+eltTree.linkNodes('0','6','BooleanQuery')
+eltTree.linkNodes('0','64','BoostingQuery')
+eltTree.linkNodes('0','66','BoostQuery')
+eltTree.linkNodes('0','36','CachedFilter')
+eltTree.linkNodes('0','3','Clause')
+eltTree.linkNodes('0','27','ConstantScoreQuery')
+eltTree.linkNodes('0','80','DuplicateFilter')
+eltTree.linkNodes('0','55','Exclude')
+eltTree.linkNodes('0','74','Field')
+eltTree.linkNodes('0','84','Filter')
+eltTree.linkNodes('0','14','FilteredQuery')
+eltTree.linkNodes('0','69','FuzzyLikeThisQuery')
+eltTree.linkNodes('0','51','Include')
+eltTree.linkNodes('0','57','LikeThisQuery')
+eltTree.linkNodes('0','26','MatchAllDocsQuery')
+eltTree.linkNodes('0','16','Query')
+eltTree.linkNodes('0','30','RangeFilter')
+eltTree.linkNodes('0','46','SpanFirst')
+eltTree.linkNodes('0','40','SpanNear')
+eltTree.linkNodes('0','50','SpanNot')
+eltTree.linkNodes('0','38','SpanOr')
+eltTree.linkNodes('0','44','SpanOrTerms')
+eltTree.linkNodes('0','53','SpanTerm')
+eltTree.linkNodes('0','18','TermQuery')
+eltTree.linkNodes('0','78','TermsFilter')
+eltTree.linkNodes('0','21','TermsQuery')
+eltTree.linkNodes('0','12','UserQuery')
+eltTree.addRootNode('86','Core Lucene','LuceneCoreQuery.dtd.html',false,false)
+eltTree.addNode('87','BooleanQuery','LuceneCoreQuery.dtd.html#BooleanQuery',false,false)
+eltTree.linkNodes('86','87')
+eltTree.addNode('88','@boost','LuceneCoreQuery.dtd.html#BooleanQuery_boost',false,false)
+eltTree.linkNodes('87','88')
+eltTree.addNode('89','@disableCoord','LuceneCoreQuery.dtd.html#BooleanQuery_disableCoord',false,false)
+eltTree.linkNodes('87','89')
+eltTree.addNode('90','@fieldName','LuceneCoreQuery.dtd.html#BooleanQuery_fieldName',false,false)
+eltTree.linkNodes('87','90')
+eltTree.addNode('91','@minimumNumberShouldMatch','LuceneCoreQuery.dtd.html#BooleanQuery_minimumNumberShouldMatch',false,false)
+eltTree.linkNodes('87','91')
+eltTree.addNode('92','<b><i>&lt;sequence&gt;+</i></b>',null,true,false)
+eltTree.linkNodes('87','92')
+eltTree.addNode('93','<b>Clause</b>','LuceneCoreQuery.dtd.html#Clause',false,false)
+eltTree.linkNodes('92','93')
+eltTree.addNode('94','@occurs','LuceneCoreQuery.dtd.html#Clause_occurs',false,false)
+eltTree.linkNodes('93','94')
+eltTree.addNode('95','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('93','95')
+eltTree.linkNodes('95','87','<b>BooleanQuery</b>')
+eltTree.addNode('96','<b>UserQuery</b>','LuceneCoreQuery.dtd.html#UserQuery',false,false)
+eltTree.linkNodes('95','96')
+eltTree.addNode('97','@boost','LuceneCoreQuery.dtd.html#UserQuery_boost',false,false)
+eltTree.linkNodes('96','97')
+eltTree.addNode('98','<b>FilteredQuery</b>','LuceneCoreQuery.dtd.html#FilteredQuery',false,false)
+eltTree.linkNodes('95','98')
+eltTree.addNode('99','@boost','LuceneCoreQuery.dtd.html#FilteredQuery_boost',false,false)
+eltTree.linkNodes('98','99')
+eltTree.addNode('100','<b>Query</b>','LuceneCoreQuery.dtd.html#Query',false,false)
+eltTree.linkNodes('98','100')
+eltTree.addNode('101','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('100','101')
+eltTree.linkNodes('101','87','<b>BooleanQuery</b>')
+eltTree.linkNodes('101','96','<b>UserQuery</b>')
+eltTree.linkNodes('101','98','<b>FilteredQuery</b>')
+eltTree.addNode('102','<b>TermQuery</b>','LuceneCoreQuery.dtd.html#TermQuery',false,false)
+eltTree.linkNodes('101','102')
+eltTree.addNode('103','@boost','LuceneCoreQuery.dtd.html#TermQuery_boost',false,false)
+eltTree.linkNodes('102','103')
+eltTree.addNode('104','@fieldName','LuceneCoreQuery.dtd.html#TermQuery_fieldName',false,false)
+eltTree.linkNodes('102','104')
+eltTree.addNode('105','<b>TermsQuery</b>','LuceneCoreQuery.dtd.html#TermsQuery',false,false)
+eltTree.linkNodes('101','105')
+eltTree.addNode('106','@boost','LuceneCoreQuery.dtd.html#TermsQuery_boost',false,false)
+eltTree.linkNodes('105','106')
+eltTree.addNode('107','@disableCoord','LuceneCoreQuery.dtd.html#TermsQuery_disableCoord',false,false)
+eltTree.linkNodes('105','107')
+eltTree.addNode('108','@fieldName','LuceneCoreQuery.dtd.html#TermsQuery_fieldName',false,false)
+eltTree.linkNodes('105','108')
+eltTree.addNode('109','@minimumNumberShouldMatch','LuceneCoreQuery.dtd.html#TermsQuery_minimumNumberShouldMatch',false,false)
+eltTree.linkNodes('105','109')
+eltTree.addNode('110','<b>&lt;MatchAllDocsQuery/&gt;</b>','LuceneCoreQuery.dtd.html#MatchAllDocsQuery',false,false)
+eltTree.linkNodes('101','110')
+eltTree.addNode('111','<b>ConstantScoreQuery</b>','LuceneCoreQuery.dtd.html#ConstantScoreQuery',false,false)
+eltTree.linkNodes('101','111')
+eltTree.addNode('112','@boost','LuceneCoreQuery.dtd.html#ConstantScoreQuery_boost',false,false)
+eltTree.linkNodes('111','112')
+eltTree.addNode('113','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('111','113')
+eltTree.addNode('114','<b>&lt;RangeFilter/&gt;</b>','LuceneCoreQuery.dtd.html#RangeFilter',false,false)
+eltTree.linkNodes('113','114')
+eltTree.addNode('115','@fieldName','LuceneCoreQuery.dtd.html#RangeFilter_fieldName',false,false)
+eltTree.linkNodes('114','115')
+eltTree.addNode('116','@includeLower','LuceneCoreQuery.dtd.html#RangeFilter_includeLower',false,false)
+eltTree.linkNodes('114','116')
+eltTree.addNode('117','@includeUpper','LuceneCoreQuery.dtd.html#RangeFilter_includeUpper',false,false)
+eltTree.linkNodes('114','117')
+eltTree.addNode('118','<b>@lowerTerm</b>','LuceneCoreQuery.dtd.html#RangeFilter_lowerTerm',false,false)
+eltTree.linkNodes('114','118')
+eltTree.addNode('119','<b>@upperTerm</b>','LuceneCoreQuery.dtd.html#RangeFilter_upperTerm',false,false)
+eltTree.linkNodes('114','119')
+eltTree.addNode('120','<b>CachedFilter</b>','LuceneCoreQuery.dtd.html#CachedFilter',false,false)
+eltTree.linkNodes('113','120')
+eltTree.addNode('121','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('120','121')
+eltTree.linkNodes('121','87','<b>BooleanQuery</b>')
+eltTree.linkNodes('121','96','<b>UserQuery</b>')
+eltTree.linkNodes('121','98','<b>FilteredQuery</b>')
+eltTree.linkNodes('121','102','<b>TermQuery</b>')
+eltTree.linkNodes('121','105','<b>TermsQuery</b>')
+eltTree.linkNodes('121','110','<b>MatchAllDocsQuery</b>')
+eltTree.linkNodes('121','111','<b>ConstantScoreQuery</b>')
+eltTree.addNode('122','<b>SpanOr</b>','LuceneCoreQuery.dtd.html#SpanOr',false,false)
+eltTree.linkNodes('121','122')
+eltTree.addNode('123','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('122','123')
+eltTree.linkNodes('123','122','<b>SpanOr</b>')
+eltTree.addNode('124','<b>SpanNear</b>','LuceneCoreQuery.dtd.html#SpanNear',false,false)
+eltTree.linkNodes('123','124')
+eltTree.addNode('125','@inOrder','LuceneCoreQuery.dtd.html#SpanNear_inOrder',false,false)
+eltTree.linkNodes('124','125')
+eltTree.addNode('126','<b>@slop</b>','LuceneCoreQuery.dtd.html#SpanNear_slop',false,false)
+eltTree.linkNodes('124','126')
+eltTree.addNode('127','<i>&lt;choice&gt;*</i>',null,true,false)
+eltTree.linkNodes('124','127')
+eltTree.linkNodes('127','122','<b>SpanOr</b>')
+eltTree.linkNodes('127','124','<b>SpanNear</b>')
+eltTree.addNode('128','<b>SpanOrTerms</b>','LuceneCoreQuery.dtd.html#SpanOrTerms',false,false)
+eltTree.linkNodes('127','128')
+eltTree.addNode('129','<b>@fieldName</b>','LuceneCoreQuery.dtd.html#SpanOrTerms_fieldName',false,false)
+eltTree.linkNodes('128','129')
+eltTree.addNode('130','<b>SpanFirst</b>','LuceneCoreQuery.dtd.html#SpanFirst',false,false)
+eltTree.linkNodes('127','130')
+eltTree.addNode('131','@boost','LuceneCoreQuery.dtd.html#SpanFirst_boost',false,false)
+eltTree.linkNodes('130','131')
+eltTree.addNode('132','<b>@end</b>','LuceneCoreQuery.dtd.html#SpanFirst_end',false,false)
+eltTree.linkNodes('130','132')
+eltTree.addNode('133','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('130','133')
+eltTree.linkNodes('133','122','<b>SpanOr</b>')
+eltTree.linkNodes('133','124','<b>SpanNear</b>')
+eltTree.linkNodes('133','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('133','130','<b>SpanFirst</b>')
+eltTree.addNode('134','<b>SpanNot</b>','LuceneCoreQuery.dtd.html#SpanNot',false,false)
+eltTree.linkNodes('133','134')
+eltTree.addNode('135','<b>Include</b>','LuceneCoreQuery.dtd.html#Include',false,false)
+eltTree.linkNodes('134','135')
+eltTree.addNode('136','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('135','136')
+eltTree.linkNodes('136','122','<b>SpanOr</b>')
+eltTree.linkNodes('136','124','<b>SpanNear</b>')
+eltTree.linkNodes('136','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('136','130','<b>SpanFirst</b>')
+eltTree.linkNodes('136','134','<b>SpanNot</b>')
+eltTree.addNode('137','<b>SpanTerm</b>','LuceneCoreQuery.dtd.html#SpanTerm',false,false)
+eltTree.linkNodes('136','137')
+eltTree.addNode('138','<b>@fieldName</b>','LuceneCoreQuery.dtd.html#SpanTerm_fieldName',false,false)
+eltTree.linkNodes('137','138')
+eltTree.addNode('139','<b>Exclude</b>','LuceneCoreQuery.dtd.html#Exclude',false,false)
+eltTree.linkNodes('134','139')
+eltTree.addNode('140','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('139','140')
+eltTree.linkNodes('140','122','<b>SpanOr</b>')
+eltTree.linkNodes('140','124','<b>SpanNear</b>')
+eltTree.linkNodes('140','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('140','130','<b>SpanFirst</b>')
+eltTree.linkNodes('140','134','<b>SpanNot</b>')
+eltTree.linkNodes('140','137','<b>SpanTerm</b>')
+eltTree.linkNodes('133','137','<b>SpanTerm</b>')
+eltTree.linkNodes('127','134','<b>SpanNot</b>')
+eltTree.linkNodes('127','137','<b>SpanTerm</b>')
+eltTree.linkNodes('123','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('123','130','<b>SpanFirst</b>')
+eltTree.linkNodes('123','134','<b>SpanNot</b>')
+eltTree.linkNodes('123','137','<b>SpanTerm</b>')
+eltTree.linkNodes('121','124','<b>SpanNear</b>')
+eltTree.linkNodes('121','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('121','130','<b>SpanFirst</b>')
+eltTree.linkNodes('121','134','<b>SpanNot</b>')
+eltTree.linkNodes('121','137','<b>SpanTerm</b>')
+eltTree.linkNodes('121','114','<b>RangeFilter</b>')
+eltTree.linkNodes('121','120','<b>CachedFilter</b>')
+eltTree.linkNodes('101','122','<b>SpanOr</b>')
+eltTree.linkNodes('101','124','<b>SpanNear</b>')
+eltTree.linkNodes('101','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('101','130','<b>SpanFirst</b>')
+eltTree.linkNodes('101','134','<b>SpanNot</b>')
+eltTree.linkNodes('101','137','<b>SpanTerm</b>')
+eltTree.addNode('141','<b>Filter</b>','LuceneCoreQuery.dtd.html#Filter',false,false)
+eltTree.linkNodes('98','141')
+eltTree.addNode('142','<b><i>&lt;choice&gt;</i></b>',null,true,false)
+eltTree.linkNodes('141','142')
+eltTree.linkNodes('142','114','<b>RangeFilter</b>')
+eltTree.linkNodes('142','120','<b>CachedFilter</b>')
+eltTree.linkNodes('95','102','<b>TermQuery</b>')
+eltTree.linkNodes('95','105','<b>TermsQuery</b>')
+eltTree.linkNodes('95','110','<b>MatchAllDocsQuery</b>')
+eltTree.linkNodes('95','111','<b>ConstantScoreQuery</b>')
+eltTree.linkNodes('95','122','<b>SpanOr</b>')
+eltTree.linkNodes('95','124','<b>SpanNear</b>')
+eltTree.linkNodes('95','128','<b>SpanOrTerms</b>')
+eltTree.linkNodes('95','130','<b>SpanFirst</b>')
+eltTree.linkNodes('95','134','<b>SpanNot</b>')
+eltTree.linkNodes('95','137','<b>SpanTerm</b>')
+eltTree.linkNodes('95','114','<b>RangeFilter</b>')
+eltTree.linkNodes('95','120','<b>CachedFilter</b>')
+eltTree.linkNodes('86','120','CachedFilter')
+eltTree.linkNodes('86','93','Clause')
+eltTree.linkNodes('86','111','ConstantScoreQuery')
+eltTree.linkNodes('86','139','Exclude')
+eltTree.linkNodes('86','141','Filter')
+eltTree.linkNodes('86','98','FilteredQuery')
+eltTree.linkNodes('86','135','Include')
+eltTree.linkNodes('86','110','MatchAllDocsQuery')
+eltTree.linkNodes('86','100','Query')
+eltTree.linkNodes('86','114','RangeFilter')
+eltTree.linkNodes('86','130','SpanFirst')
+eltTree.linkNodes('86','124','SpanNear')
+eltTree.linkNodes('86','134','SpanNot')
+eltTree.linkNodes('86','122','SpanOr')
+eltTree.linkNodes('86','128','SpanOrTerms')
+eltTree.linkNodes('86','137','SpanTerm')
+eltTree.linkNodes('86','102','TermQuery')
+eltTree.linkNodes('86','105','TermsQuery')
+eltTree.linkNodes('86','96','UserQuery')
+document.write(eltTree);
+//-->
+</script>
+</div>
+</body></html>
diff --git a/contrib/xml-query-parser/dtddocbuild.xml b/contrib/xml-query-parser/dtddocbuild.xml
new file mode 100644
index 0000000..ba42842
--- /dev/null
+++ b/contrib/xml-query-parser/dtddocbuild.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0"?>
+
+<project name="DTDDocAnt" default="main">
+
+  <import file="../contrib-build.xml"/>
+
+    <description>
+    This file generates DTDdocumentation
+    </description>
+
+    <!-- Tell ant where to find the code of the DTDDoc task.
+         Set dtddoc.home property to the directory where DTDdoc is installed on your system
+         -->
+
+    <taskdef name="DTDDoc"
+             classname="DTDDoc.DTDDocTask"
+             classpath="${dtddoc.home}/DTDDoc.jar"/>
+
+    <!-- Execute DTDDoc -->
+
+    <target name="main">
+
+
+        <DTDDoc showHiddenTags="false"
+                showFixmeTags="false"
+                sourceDir="."
+                destDir="docs"
+                docTitle = "Lucene XML Query syntax">
+                <include name="*.dtd"/>
+        </DTDDoc>
+
+    </target>
+
+
+
+</project>
diff --git a/contrib/xml-query-parser/readme.htm b/contrib/xml-query-parser/readme.htm
index 015080c..7352ca2 100644
--- a/contrib/xml-query-parser/readme.htm
+++ b/contrib/xml-query-parser/readme.htm
@@ -7,6 +7,7 @@
 			<ul>
 				<li>a modular Lucene Query Parser where queries are expressed as XML</li>
 				<li>JUnit test</li>
+				<li>DTD schemas and <a href="docs/index.html">generated documentation</a> </li>
 				<li>Example XML queries</li>
 				<li>Test index (subset of Reuters 21578)</li>
 			</ul>
@@ -18,11 +19,12 @@
 			Parser support includes:
 			<ul>
 				<li>"Span" queries</li>
+				<li>Simple caching for filters</li>
 				<li>"Like this" queries</li>
 				<li>Boolean, Term, and UserInput (parsed with existing query parser)</li>
 				<li>BoostingQuery - a class that can downgrade scores for hits on
 				certain terms rather than the hard-line approach taken by BooleanClause.Occurs.MUST_NOT</li>
-				<li>FilteredQuery, RangeFilter, and "TermsFilter" for non-sequential terms</li>
+				<li>FilteredQuery, RangeFilter, DuplicateFilter and "TermsFilter" for non-sequential terms</li>
 				<li>"FuzzyLikeThis" a new query which is a cross between "LikeThis" and "fuzzy" but with
 					better scoring of fuzzy terms than standard fuzzy queries</li>
 				<li>A modular design with expandable support for new query/filter types</li>

