GitDiffStart: 6c5f475b4d1c4e063028b10160138ab4cec9ac31 | Thu Dec 13 12:37:14 2012 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index ab60dae..08aadf7 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -90,6 +90,12 @@ Changes in backwards compatibility policy
   FacetArrays no longer takes those allocators; if you need to reuse the arrays,
   you should use ReusingFacetArrays. (Shai Erera, Gilad Barkai)
 
+* LUCENE-4621: FacetIndexingParams is now a concrete class (instead of DefaultFIP).
+  Also, the entire IndexingParams chain is now immutable. If you need to override
+  a setting, you should extend the relevant class.
+  Additionally, FacetSearchParams is now immutable, and requires all FacetRequests
+  to speified at initialization time. (Shai Erera)
+  
 New Features
 
 * LUCENE-4226: New experimental StoredFieldsFormat that compresses chunks of
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java
index 6497eb8..c88ab52 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java
@@ -2,16 +2,6 @@ package org.apache.lucene.facet.example.adaptive;
 
 import java.util.List;
 
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-import org.apache.lucene.store.Directory;
-
-import org.apache.lucene.search.MultiCollector;
 import org.apache.lucene.facet.example.ExampleUtils;
 import org.apache.lucene.facet.example.simple.SimpleUtils;
 import org.apache.lucene.facet.search.AdaptiveFacetsAccumulator;
@@ -22,6 +12,15 @@ import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.store.Directory;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -78,8 +77,8 @@ public class AdaptiveSearcher {
     ScoredDocIdCollector docIdsCollecor = ScoredDocIdCollector.create(indexReader.maxDoc(), false);
     
     // Faceted search parameters indicate which facets are we interested in 
-    FacetSearchParams facetSearchParams = new FacetSearchParams();
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
+    FacetSearchParams facetSearchParams = new FacetSearchParams(
+        new CountFacetRequest(new CategoryPath("root", "a"), 10));
     
     // search, into both collectors. note: in case only facets accumulation 
     // is required, the topDocCollector part can be totally discarded
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java
index f13bf4d..0723700 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java
@@ -4,7 +4,7 @@ import org.apache.lucene.facet.enhancements.association.AssociationEnhancement;
 import org.apache.lucene.facet.enhancements.association.AssociationFloatProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationIntProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationProperty;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
+import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
@@ -73,7 +73,7 @@ public class AssociationUtils {
    * Indexing Params: the indexing params to use when dealing with
    * associations.
    */
-  public static final DefaultEnhancementsIndexingParams assocIndexingParams = 
-    new DefaultEnhancementsIndexingParams(new AssociationEnhancement());
+  public static final EnhancementsIndexingParams assocIndexingParams = new EnhancementsIndexingParams(
+      new AssociationEnhancement());
 
 }
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java
index 25bee49..55d1e67 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java
@@ -3,22 +3,20 @@ package org.apache.lucene.facet.example.merge;
 import java.io.IOException;
 import java.util.List;
 
-import org.apache.lucene.index.AtomicReader;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.MultiReader;
-import org.apache.lucene.store.Directory;
-
 import org.apache.lucene.facet.example.ExampleUtils;
 import org.apache.lucene.facet.index.OrdinalMappingAtomicReader;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.DiskOrdinalMap;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
+import org.apache.lucene.index.AtomicReader;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.MultiReader;
+import org.apache.lucene.store.Directory;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -88,7 +86,7 @@ public class TaxonomyMergeUtils {
     destTaxWriter.addTaxonomy(srcTaxDir, map);
 
     int ordinalMap[] = map.getMap();
-    FacetIndexingParams params = new DefaultFacetIndexingParams();
+    FacetIndexingParams params = FacetIndexingParams.ALL_PARENTS;
 
     DirectoryReader reader = DirectoryReader.open(srcIndexDir, -1);
     List<AtomicReaderContext> leaves = reader.leaves();
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java
index b16c596..1da777e 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java
@@ -1,7 +1,9 @@
 package org.apache.lucene.facet.example.multiCL;
 
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 
 import org.apache.lucene.document.Document;
@@ -74,22 +76,18 @@ public class MultiCLIndexer {
       + "reprehenderit qui in ea voluptate velit esse quam nihil molestiae "
       + "consequatur vel illum qui dolorem eum fugiat quo voluptas nulla pariatur";
   // PerDimensionIndexingParams for multiple category lists
-  public static PerDimensionIndexingParams MULTI_IPARAMS = new PerDimensionIndexingParams();
+  public static final PerDimensionIndexingParams MULTI_IPARAMS;
 
   // Initialize PerDimensionIndexingParams
   static {
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("0"),
-        new CategoryListParams(new Term("$Digits", "Zero")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("1"),
-        new CategoryListParams(new Term("$Digits", "One")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("2"),
-        new CategoryListParams(new Term("$Digits", "Two")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("3"),
-        new CategoryListParams(new Term("$Digits", "Three")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("4"),
-        new CategoryListParams(new Term("$Digits", "Four")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("5"),
-        new CategoryListParams(new Term("$Digits", "Five")));
+    Map<CategoryPath, CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("0"), new CategoryListParams(new Term("$Digits", "Zero")));
+    paramsMap.put(new CategoryPath("1"), new CategoryListParams(new Term("$Digits", "One")));
+    paramsMap.put(new CategoryPath("2"), new CategoryListParams(new Term("$Digits", "Two")));
+    paramsMap.put(new CategoryPath("3"), new CategoryListParams(new Term("$Digits", "Three")));
+    paramsMap.put(new CategoryPath("4"), new CategoryListParams(new Term("$Digits", "Four")));
+    paramsMap.put(new CategoryPath("5"), new CategoryListParams(new Term("$Digits", "Five")));
+    MULTI_IPARAMS = new PerDimensionIndexingParams(paramsMap);
   }
   
   /**
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java
index 933b426..e84c69b 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java
@@ -1,5 +1,6 @@
 package org.apache.lucene.facet.example.multiCL;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.index.DirectoryReader;
@@ -17,6 +18,7 @@ import org.apache.lucene.facet.example.simple.SimpleUtils;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -91,17 +93,14 @@ public class MultiCLSearcher {
     Query q = new TermQuery(new Term(SimpleUtils.TEXT, "Quis"));
     ExampleUtils.log("Query: " + q);
 
-    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10,
-        true);
+    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
     // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("5"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("5", "5"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("6", "2"), 10));
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("5"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("5", "5"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("6", "2"), 10));
+    FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
 
     // Facets collector is the simplest interface for faceted search.
     // It provides faceted search functions that are sufficient to many
diff --git a/lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java b/lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java
index 8e87baf..8cc5839 100644
--- a/lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java
+++ b/lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java
@@ -1,18 +1,10 @@
 package org.apache.lucene.facet.example.simple;
 
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-
-import org.apache.lucene.search.MultiCollector;
 import org.apache.lucene.facet.example.ExampleUtils;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.DrillDown;
 import org.apache.lucene.facet.search.FacetsCollector;
@@ -23,6 +15,13 @@ import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopScoreDocCollector;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -101,16 +100,11 @@ public class SimpleSearcher {
     TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
     if (indexingParams == null) {
-      indexingParams = new DefaultFacetIndexingParams();
+      indexingParams = FacetIndexingParams.ALL_PARENTS;
     }
     
     // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(indexingParams);
-    
-    // Add the facet requests of interest to the search params
-    for (FacetRequest frq : facetRequests) {
-      facetSearchParams.addFacetRequest(frq);
-    }
+    FacetSearchParams facetSearchParams = new FacetSearchParams(Arrays.asList(facetRequests), indexingParams);
 
     FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, indexReader, taxoReader);
 
@@ -138,7 +132,7 @@ public class SimpleSearcher {
   public static List<FacetResult> searchWithDrillDown(IndexReader indexReader,
       TaxonomyReader taxoReader) throws Exception {
 
-    final FacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    final FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     
     // base query the user is interested in
     Query baseQuery = new TermQuery(new Term(SimpleUtils.TEXT, "white"));
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html b/lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
index e6f309a..051aad0 100755
--- a/lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
+++ b/lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
@@ -538,7 +538,7 @@ parameters it defines, the following two are likely to interest many application
 forms: category-tokens (for drill-down) and category-list-tokens (for
 accumulation). This parameter allows to specify, for each category, the
 Lucene term used for maintaining the category-list-tokens for that category.
-The default implementation in <code>DefaultFacetIndexingParams</code> maintains
+The default implementation in <code>FacetIndexingParams</code> maintains
 this information for all categories under the same special dedicated term.
 One case where it is needed to maintain two categories in separate category
 lists, is when it is known that at search time it would be required to use
@@ -548,7 +548,7 @@ call.</li>
 for example, the partition size is set to 1000, a distinct sub-term is used for
 maintaining each 1000 categories, e.g. term1 for categories 0 to 999, term2
 for categories 1000 to 1999, etc. The default implementation in
-<code>DefaultFacetIndexingParams</code> maintains category lists in a single
+<code>FacetIndexingParams</code> maintains category lists in a single
 partition, hence it defines the partition size as <code>Integer.MAX_VALUE</code>. The
 importance of this parameter is on allowing to handle very large
 taxonomies without exhausting RAM resources. This is because at facet
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java
index 4493f45..a6500ed 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java
@@ -121,7 +121,7 @@ public interface CategoryEnhancement {
    *         {@link CategoryParentsStream}, or {@code null} if there is no such
    *         property.
    */
-  Class<? extends CategoryProperty> getRetainableProperty();
+  CategoryProperty getRetainableProperty();
   
   /**
    * Category enhancements must override {@link Object#equals(Object)}, as it is
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java
index 9e64e7f..99a3a57 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java
@@ -53,13 +53,12 @@ public class EnhancementsDocumentBuilder extends CategoryDocumentBuilder {
 
   @Override
   protected TokenStream getParentsStream(CategoryAttributesStream categoryAttributesStream) {
-    List<Class<? extends CategoryProperty>> toRetainList = ((EnhancementsIndexingParams) indexingParams)
-        .getRetainableProperties();
+    List<CategoryProperty> toRetainList = ((EnhancementsIndexingParams) indexingParams).getRetainableProperties();
     if (toRetainList != null) {
       CategoryParentsStream categoryParentsStream = new CategoryParentsStream(
           categoryAttributesStream, taxonomyWriter, indexingParams);
-      for (Class<? extends CategoryProperty> toRetain : toRetainList) {
-        categoryParentsStream.addRetainableProperty(toRetain);
+      for (CategoryProperty toRetain : toRetainList) {
+        categoryParentsStream.addRetainableProperty(toRetain.getClass());
       }
       return categoryParentsStream;
     }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java
index 63ecaab..3969d15 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java
@@ -152,7 +152,7 @@ public class AssociationEnhancement implements CategoryEnhancement {
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java
deleted file mode 100644
index 181cca9..0000000
--- a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package org.apache.lucene.facet.enhancements.params;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.facet.enhancements.CategoryEnhancement;
-import org.apache.lucene.facet.index.attributes.CategoryProperty;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Default implementation of {@link EnhancementsIndexingParams} 
- * 
- * @lucene.experimental
- */
-public class DefaultEnhancementsIndexingParams extends
-    PerDimensionIndexingParams implements EnhancementsIndexingParams {
-
-  private List<CategoryEnhancement> enhancedCategories;
-
-  /**
-   * Construct with a certain {@link CategoryEnhancement enhancement}
-   * @throws IllegalArgumentException if no enhancements are provided
-   */
-  public DefaultEnhancementsIndexingParams(CategoryEnhancement... enhancements) {
-    super();
-    validateparams(enhancements);
-    addCategoryEnhancements(enhancements);
-  }
-
-  private void validateparams(CategoryEnhancement... enhancements) {
-    if (enhancements==null || enhancements.length<1) {
-      throw new IllegalArgumentException("at least one enhancement is required");
-    }
-  }
-
-  /**
-   * Construct with certain {@link CategoryEnhancement enhancements}
-   * and {@link CategoryListParams}
-   * @throws IllegalArgumentException if no enhancements are provided
-   */
-  public DefaultEnhancementsIndexingParams(
-      CategoryListParams categoryListParams,
-      CategoryEnhancement... enhancements) {
-    super(categoryListParams);
-    validateparams(enhancements);
-    addCategoryEnhancements(enhancements);
-  }
-
-  @Override
-  public void addCategoryEnhancements(CategoryEnhancement... enhancements) {
-    if (enhancedCategories == null) {
-      enhancedCategories = new ArrayList<CategoryEnhancement>();
-    }
-    for (CategoryEnhancement categoryEnhancement : enhancements) {
-      enhancedCategories.add(categoryEnhancement);
-    }
-  }
-
-  @Override
-  public List<CategoryEnhancement> getCategoryEnhancements() {
-    if (enhancedCategories == null || enhancedCategories.isEmpty()) {
-      return null;
-    }
-    return enhancedCategories;
-  }
-
-  @Override
-  public List<Class<? extends CategoryProperty>> getRetainableProperties() {
-    if (enhancedCategories == null) {
-      return null;
-    }
-    List<Class<? extends CategoryProperty>> retainableProperties = new ArrayList<Class<? extends CategoryProperty>>();
-    for (CategoryEnhancement enhancement : enhancedCategories) {
-      if (enhancement.getRetainableProperty() != null) {
-        retainableProperties.add(enhancement.getRetainableProperty());
-      }
-    }
-    if (retainableProperties.isEmpty()) {
-      return null;
-    }
-    return retainableProperties;
-  }
-}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java
index 8e0fd93..a84104f 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java
@@ -1,12 +1,18 @@
 package org.apache.lucene.facet.enhancements.params;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.facet.enhancements.CategoryEnhancement;
 import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
 import org.apache.lucene.facet.index.attributes.CategoryProperty;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
+import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.index.streaming.CategoryParentsStream;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -26,41 +32,76 @@ import org.apache.lucene.facet.index.streaming.CategoryParentsStream;
  */
 
 /**
- * {@link FacetIndexingParams Facet indexing parameters} for defining
- * {@link CategoryEnhancement category enhancements}. It must contain at least
- * one enhancement, otherwise nothing is "enhanced" about it. When there are
- * more than one, the order matters - see {@link #getCategoryEnhancements()}.
+ * A {@link PerDimensionIndexingParams} for defining {@link CategoryEnhancement
+ * category enhancements}. Must contain at least one enhancement, and when there
+ * are more than one, their order matters.
  * 
+ * @see #getCategoryEnhancements()
  * @see EnhancementsDocumentBuilder
+
  * @lucene.experimental
  */
-public interface EnhancementsIndexingParams extends FacetIndexingParams {
+public class EnhancementsIndexingParams extends PerDimensionIndexingParams {
+
+  private final List<CategoryEnhancement> enhancements;
 
   /**
-   * Add {@link CategoryEnhancement}s to the indexing parameters
-   * @param enhancements enhancements to add
+   * Initializes with the given enhancements
+   * 
+   * @throws IllegalArgumentException
+   *           if no enhancements are provided
    */
-  public void addCategoryEnhancements(CategoryEnhancement... enhancements);
+  public EnhancementsIndexingParams(CategoryEnhancement... enhancements) {
+    this(DEFAULT_CATEGORY_LIST_PARAMS, Collections.<CategoryPath,CategoryListParams> emptyMap(), enhancements);
+  }
 
   /**
-   * Get a list of the active category enhancements. If no enhancements exist
-   * return {@code null}. The order of enhancements in the returned list
-   * dictates the order in which the enhancements data appear in the category
-   * tokens payload.
+   * Initializes with the given enhancements and category list params mappings.
    * 
-   * @return A list of the active category enhancements, or {@code null} if
-   *         there are no enhancements.
+   * @see PerDimensionIndexingParams#PerDimensionIndexingParams(Map, CategoryListParams)
+   * @throws IllegalArgumentException
+   *           if no enhancements are provided
+   */
+  public EnhancementsIndexingParams(CategoryListParams categoryListParams, 
+      Map<CategoryPath,CategoryListParams> paramsMap, CategoryEnhancement... enhancements) {
+    super(paramsMap, categoryListParams);
+    validateparams(enhancements);
+    this.enhancements = Arrays.asList(enhancements);
+  }
+
+  private void validateparams(CategoryEnhancement... enhancements) {
+    if (enhancements == null || enhancements.length < 1) {
+      throw new IllegalArgumentException("at least one enhancement is required");
+    }
+  }
+
+  /**
+   * Returns the list of {@link CategoryEnhancement} as were given at
+   * intialization time. You are not expected to modify the list. The order of
+   * the enhancements dictates the order in which they are written in the
+   * document.
    */
-  public List<CategoryEnhancement> getCategoryEnhancements();
+  public List<CategoryEnhancement> getCategoryEnhancements() {
+    return enhancements;
+  }
 
   /**
-   * Get a list of {@link CategoryProperty} classes to be retained when
-   * creating {@link CategoryParentsStream}.
-   * 
-   * @return the list of {@link CategoryProperty} classes to be retained when
-   *         creating {@link CategoryParentsStream}, or {@code null} if there
-   *         are no such properties.
+   * Returns a list of {@link CategoryProperty} which should be retained when
+   * creating {@link CategoryParentsStream}, or {@code null} if there are no
+   * such properties.
    */
-  public List<Class<? extends CategoryProperty>> getRetainableProperties();
+  public List<CategoryProperty> getRetainableProperties() {
+    List<CategoryProperty> props = new ArrayList<CategoryProperty>();
+    for (CategoryEnhancement enhancement : enhancements) {
+      CategoryProperty prop = enhancement.getRetainableProperty();
+      if (prop != null) {
+        props.add(prop);
+      }
+    }
+    if (props.isEmpty()) {
+      return null;
+    }
+    return props;
+  }
 
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java
index cedb4f9..4be7ce2 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java
@@ -12,12 +12,10 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
-
 import org.apache.lucene.facet.index.attributes.CategoryAttribute;
 import org.apache.lucene.facet.index.attributes.CategoryAttributesIterable;
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.streaming.CategoryAttributesStream;
 import org.apache.lucene.facet.index.streaming.CategoryListTokenizer;
@@ -48,7 +46,7 @@ import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
  * A utility class which allows attachment of {@link CategoryPath}s or
  * {@link CategoryAttribute}s to a given document using a taxonomy.<br>
  * Construction could be done with either a given {@link FacetIndexingParams} or
- * the default implementation {@link DefaultFacetIndexingParams}.<br>
+ * the default implementation {@link FacetIndexingParams}.<br>
  * A CategoryDocumentBuilder can be reused by repeatedly setting the categories
  * and building the document. Categories are provided either as
  * {@link CategoryAttribute} elements through {@link #setCategories(Iterable)},
@@ -85,18 +83,16 @@ public class CategoryDocumentBuilder {
   protected Map<String, List<CategoryAttribute>> categoriesMap;
 
   /**
-   * Creating a facets document builder with default facet indexing
-   * parameters.<br>
-   * See:
-   * {@link #CategoryDocumentBuilder(TaxonomyWriter, FacetIndexingParams)}
+   * Creating a facets document builder with default facet indexing parameters.
    * 
    * @param taxonomyWriter
-   *            to which new categories will be added, as well as translating
-   *            known categories to ordinals
-   *
+   *          to which new categories will be added, as well as translating
+   *          known categories to ordinals
+   * 
+   * @see #CategoryDocumentBuilder(TaxonomyWriter, FacetIndexingParams)
    */
   public CategoryDocumentBuilder(TaxonomyWriter taxonomyWriter) {
-    this(taxonomyWriter, new DefaultFacetIndexingParams());
+    this(taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
   }
 
   /**
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java b/lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java
index 0e0976f..e2f6a5a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java
@@ -25,7 +25,6 @@ import java.util.HashMap;
 import java.util.Map;
 
 import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
 import org.apache.lucene.index.AtomicReader;
@@ -71,6 +70,7 @@ import org.apache.lucene.util.encoding.IntEncoder;
  * @lucene.experimental
  */
 public class OrdinalMappingAtomicReader extends FilterAtomicReader {
+  
   private final int[] ordinalMap;
   // a little obtuse: but we dont need to create Term objects this way
   private final Map<String,Map<BytesRef,CategoryListParams>> termMap = 
@@ -82,7 +82,7 @@ public class OrdinalMappingAtomicReader extends FilterAtomicReader {
    * OrdinalMappingAtomicReader(in, ordinalMap, new DefaultFacetIndexingParams())}
    */
   public OrdinalMappingAtomicReader(AtomicReader in, int[] ordinalMap) {
-    this(in, ordinalMap, new DefaultFacetIndexingParams());
+    this(in, ordinalMap, FacetIndexingParams.ALL_PARENTS);
   }
   
   /**
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java b/lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java
index 1dcc7f4..5e10d36 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java
@@ -2,7 +2,6 @@ package org.apache.lucene.facet.index.categorypolicy;
 
 import java.io.Serializable;
 
-import org.apache.lucene.facet.index.streaming.CategoryParentsStream;
 import org.apache.lucene.facet.search.FacetsAccumulator;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -25,11 +24,9 @@ import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
  */
 
 /**
- * Filtering category ordinals in {@link CategoryParentsStream}, where a given
- * category ordinal is added to the stream, and than its parents are being added
- * one after the other using {@link TaxonomyWriter#getParent(int)}. <br>
- * That loop should have a stop point - the default approach (excluding the
- * ROOT) is implemented in {@link OrdinalPolicy#ALL_PARENTS}.
+ * A policy for adding category parent ordinals to the list of ordinals that are
+ * encoded for a given document. The default {@link #ALL_PARENTS} policy always
+ * adds all parents, where {@link #NO_PARENTS} never adds any parents.
  * 
  * @lucene.experimental
  */
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java
deleted file mode 100644
index d725c25..0000000
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.apache.lucene.facet.index.params;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
-import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Default implementation for {@link FacetIndexingParams}.
- * <p>
- * Getters for <em>partition-size</em>, {@link OrdinalPolicy} and
- * {@link PathPolicy} are all final, and so the proper way to modify them when
- * extending this class is through {@link #fixedPartitionSize()},
- * {@link #fixedOrdinalPolicy()} or {@link #fixedPathPolicy()} accordingly.
- * 
- * @lucene.experimental
- */
-public class DefaultFacetIndexingParams implements FacetIndexingParams {
-
-  /**
-   * delimiter between a categories in a path, e.g. Products FACET_DELIM
-   * Consumer FACET_DELIM Tv. This should be a character not found in any path
-   * component
-   */
-  public static final char DEFAULT_FACET_DELIM_CHAR = '\uF749';
-
-  private final CategoryListParams clpParams;
-  private final OrdinalPolicy ordinalPolicy;
-  private final PathPolicy pathPolicy;
-  private final int partitionSize;
-
-  public DefaultFacetIndexingParams() {
-    this(new CategoryListParams());
-  }
-
-  public DefaultFacetIndexingParams(CategoryListParams categoryListParams) {
-    clpParams = categoryListParams;
-    ordinalPolicy = fixedOrdinalPolicy();
-    pathPolicy = fixedPathPolicy();
-    partitionSize = fixedPartitionSize();
-  }
-
-  @Override
-  public CategoryListParams getCategoryListParams(CategoryPath category) {
-    return clpParams;
-  }
-
-  @Override
-  public int drillDownTermText(CategoryPath path, char[] buffer) {
-    return path.copyToCharArray(buffer, 0, -1, getFacetDelimChar());
-  }
-
-  /**
-   * "fixed" partition size. 
-   * @see #getPartitionSize()
-   */
-  protected int fixedPartitionSize() {
-    return Integer.MAX_VALUE;
-  }
-  
-  /**
-   * "fixed" ordinal policy. 
-   * @see #getOrdinalPolicy()
-   */
-  protected OrdinalPolicy fixedOrdinalPolicy() {
-    return OrdinalPolicy.ALL_PARENTS;
-  }
-  
-  /**
-   * "fixed" path policy. 
-   * @see #getPathPolicy()
-   */
-  protected PathPolicy fixedPathPolicy() {
-    return PathPolicy.ALL_CATEGORIES;
-  }
-  
-  @Override
-  public final int getPartitionSize() {
-    return partitionSize;
-  }
-
-  /*
-   * (non-Javadoc)
-   * 
-   * @see
-   * org.apache.lucene.facet.index.params.FacetIndexingParams#getAllCategoryListParams
-   * ()
-   */
-  @Override
-  public Iterable<CategoryListParams> getAllCategoryListParams() {
-    List<CategoryListParams> res = new ArrayList<CategoryListParams>();
-    res.add(clpParams);
-    return res;
-  }
-
-  @Override
-  public final OrdinalPolicy getOrdinalPolicy() {
-    return ordinalPolicy;
-  }
-
-  @Override
-  public final PathPolicy getPathPolicy() {
-    return pathPolicy;
-  }
-
-  /* (non-Javadoc)
-   * @see java.lang.Object#hashCode()
-   */
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result
-        + ((clpParams == null) ? 0 : clpParams.hashCode());
-    result = prime * result
-        + ((ordinalPolicy == null) ? 0 : ordinalPolicy.hashCode());
-    result = prime * result + partitionSize;
-    result = prime * result
-        + ((pathPolicy == null) ? 0 : pathPolicy.hashCode());
-    
-    for (CategoryListParams clp: getAllCategoryListParams()) {
-      result ^= clp.hashCode();
-    }
-    
-    return result;
-  }
-
-  /* (non-Javadoc)
-   * @see java.lang.Object#equals(java.lang.Object)
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj == null) {
-      return false;
-    }
-    if (!(obj instanceof DefaultFacetIndexingParams)) {
-      return false;
-    }
-    DefaultFacetIndexingParams other = (DefaultFacetIndexingParams) obj;
-    if (clpParams == null) {
-      if (other.clpParams != null) {
-        return false;
-      }
-    } else if (!clpParams.equals(other.clpParams)) {
-      return false;
-    }
-    if (ordinalPolicy == null) {
-      if (other.ordinalPolicy != null) {
-        return false;
-      }
-    } else if (!ordinalPolicy.equals(other.ordinalPolicy)) {
-      return false;
-    }
-    if (partitionSize != other.partitionSize) {
-      return false;
-    }
-    if (pathPolicy == null) {
-      if (other.pathPolicy != null) {
-        return false;
-      }
-    } else if (!pathPolicy.equals(other.pathPolicy)) {
-      return false;
-    }
-    
-    Iterable<CategoryListParams> cLs = getAllCategoryListParams();
-    Iterable<CategoryListParams> otherCLs = other.getAllCategoryListParams();
-    
-    return cLs.equals(otherCLs);
-  }
-
-  /**
-   * Use {@link #DEFAULT_FACET_DELIM_CHAR} as the delimiter.
-   */
-  @Override
-  public char getFacetDelimChar() {
-    return DEFAULT_FACET_DELIM_CHAR;
-  }
-
-}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java
index a5d1d42..90a4294 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java
@@ -1,9 +1,11 @@
 package org.apache.lucene.facet.index.params;
 
-import java.io.Serializable;
+import java.util.Collections;
+import java.util.List;
 
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
+import org.apache.lucene.facet.search.FacetArrays;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
@@ -24,75 +26,202 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  */
 
 /**
- * Parameters on how facets are to be written to the index. 
- * For example, which fields and terms are used to refer to the indexed posting list.
- * <P>
- * If non-default parameters were used during indexing, the same parameters
- * must also be passed during faceted search. This requirement is analogous
- * to the requirement during search to know which fields were indexed, and which
- * Analyzer was used on the text.
+ * Defines parameters that are needed for facets indexing. Note that this class
+ * does not have any setters. That's because overriding the default parameters
+ * is considered expert. If you wish to override them, simply extend this class
+ * and override the relevant getter.
+ * 
+ * <p>
+ * <b>NOTE:</b> This class is also used during faceted search in order to e.g.
+ * know which field holds the drill-down terms or the fulltree posting.
+ * Therefore this class should be initialized once and you should refrain from
+ * changing it. Also note that if you make any changes to it (e.g. suddenly
+ * deciding that drill-down terms should be read from a different field) and use
+ * it on an existing index, things may not work as expected.
  * 
  * @lucene.experimental
  */
-public interface FacetIndexingParams extends Serializable {
+public class FacetIndexingParams {
+  
+  // the default CLP, can be a singleton
+  protected static final CategoryListParams DEFAULT_CATEGORY_LIST_PARAMS = new CategoryListParams();
 
   /**
-   * The name of the category-list to put this category in, or null if this
-   * category should not be aggregatable.
-   * <P>
-   * By default, all categories are written to the same category list, but
-   * applications which know in advance that in some situations only parts
-   * of the category hierarchy needs to be counted can divide the categories
-   * into two or more different category lists.
-   * <P>
-   * If null is returned for a category, it means that this category should
-   * not appear in any category list, and thus counts for it cannot be
-   * aggregated. This category can still be used for drill-down, even though
-   * the count for it is not known.
+   * A {@link FacetIndexingParams} which fixes {@link OrdinalPolicy} to
+   * {@link OrdinalPolicy#NO_PARENTS}. This is a singleton equivalent to new
+   * {@link #FacetIndexingParams()}.
+   */
+  public static final FacetIndexingParams ALL_PARENTS = new FacetIndexingParams();
+  
+  /**
+   * The default delimiter with which {@link CategoryPath#getComponent(int)
+   * components} are concatenated when written to the index, e.g. as drill-down
+   * terms. If you choose to override it by overiding
+   * {@link #getFacetDelimChar()}, you should make sure that you return a
+   * character that's not found in any path component.
    */
-  public CategoryListParams getCategoryListParams(CategoryPath category);
+  public static final char DEFAULT_FACET_DELIM_CHAR = '\uF749';
+  
+  private final OrdinalPolicy ordinalPolicy = OrdinalPolicy.ALL_PARENTS;
+  private final PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
+  private final int partitionSize = Integer.MAX_VALUE;
+
+  protected final CategoryListParams clParams;
 
   /**
-   * Return info about all category lists in the index.
-   * 
-   * @see #getCategoryListParams(CategoryPath)
+   * Initializes new default params. You should use this constructor only if you
+   * intend to override any of the getters, otherwise you can use
+   * {@link #ALL_PARENTS} to save unnecessary object allocations.
    */
-  public Iterable<CategoryListParams> getAllCategoryListParams();
+  public FacetIndexingParams() {
+    this(DEFAULT_CATEGORY_LIST_PARAMS);
+  }
+
+  /** Initializes new params with the given {@link CategoryListParams}. */
+  public FacetIndexingParams(CategoryListParams categoryListParams) {
+    clParams = categoryListParams;
+  }
 
-  // TODO (Facet): Add special cases of exact/non-exact category term-text
+  /**
+   * The name of the category list to put this category in, or {@code null} if
+   * this category should not be aggregatable.
+   * <p>
+   * By default, all categories are written to the same category list, but
+   * applications which know in advance that in some situations only parts of
+   * the category hierarchy needs to be counted can divide the categories into
+   * two or more different category lists.
+   * <p>
+   * If {@code null} is returned for a category, it means that this category
+   * should not appear in any category list, and thus weights for it cannot be
+   * aggregated. This category can still be used for drill-down, even though the
+   * its weight is unknown.
+   * 
+   * @see PerDimensionIndexingParams
+   */
+  public CategoryListParams getCategoryListParams(CategoryPath category) {
+    return clParams;
+  }
 
   /**
-   * Return the drilldown Term-Text which does not need to do any allocations.
-   * The number of chars set is returned.
+   * Copies the text required to execute a drill-down query on the given
+   * category to the given {@code char[]}, and returns the number of characters
+   * that were written.
+   * <p>
+   * <b>NOTE:</b> You should make sure that the {@code char[]} is large enough,
+   * by e.g. calling {@link CategoryPath#charsNeededForFullPath()}.
+   */
+  public int drillDownTermText(CategoryPath path, char[] buffer) {
+    return path.copyToCharArray(buffer, 0, -1, getFacetDelimChar());
+  }
+  
+  /**
+   * Returns the size of a partition. <i>Partitions</i> allow you to divide
+   * (hence, partition) the categories space into small sets to e.g. improve RAM
+   * consumption during faceted search. For instance, {@code partitionSize=100K}
+   * would mean that if your taxonomy index contains 420K categories, they will
+   * be divided into 5 groups and at search time a {@link FacetArrays} will be
+   * allocated at the size of the partition.
+   * 
    * <p>
-   * Note: Make sure <code>buffer</code> is large enough.
-   * @see CategoryPath#charsNeededForFullPath()
+   * This is real advanced setting and should be changed with care. By default,
+   * all categories are put in one partition. You should modify this setting if
+   * you have really large taxonomies (e.g. 1M+ nodes).
    */
-  public int drillDownTermText(CategoryPath path, char[] buffer);
+  public int getPartitionSize() {
+    return partitionSize;
+  }
 
   /**
-   * Get the partition size.
-   * Same value should be used during the life time of an index.
-   * At search time this value is compared with actual taxonomy size and their minimum is used.
+   * Returns a list of all {@link CategoryListParams categoryListParams} that
+   * are used for facets indexing.
    */
-  public int getPartitionSize();
+  public List<CategoryListParams> getAllCategoryListParams() {
+    return Collections.singletonList(clParams);
+  }
 
-  /** 
-   * Get the policy for indexing category <b>paths</b>, 
-   * used for deciding how "high" to climb in taxonomy 
-   * from a category when ingesting its category paths. 
+  /**
+   * Returns the {@link OrdinalPolicy} that is used during indexing. By default
+   * returns {@link OrdinalPolicy#ALL_PARENTS} which means that the full
+   * hierarchy will be stored for every document.
    */
-  public PathPolicy getPathPolicy();
+  public OrdinalPolicy getOrdinalPolicy() {
+    return ordinalPolicy;
+  }
 
-  /** 
-   * Get the policy for indexing category <b>ordinals</b>, 
-   * used for deciding how "high" to climb in taxonomy 
-   * from a category when ingesting its ordinals 
+  /**
+   * Returns the {@link PathPolicy} that is used during indexing. By default
+   * returns {@link PathPolicy#ALL_CATEGORIES} which means that the full
+   * hierarchy is added as drill-down terms for every document.
    */
-  public OrdinalPolicy getOrdinalPolicy();
-  
-  /** 
-   * Get the delimiter character used internally for drill-down terms 
-   */ 
-  public char getFacetDelimChar();
+  public PathPolicy getPathPolicy() {
+    return pathPolicy;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((clParams == null) ? 0 : clParams.hashCode());
+    result = prime * result + ((ordinalPolicy == null) ? 0 : ordinalPolicy.hashCode());
+    result = prime * result + partitionSize;
+    result = prime * result + ((pathPolicy == null) ? 0 : pathPolicy.hashCode());
+    
+    for (CategoryListParams clp : getAllCategoryListParams()) {
+      result ^= clp.hashCode();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof FacetIndexingParams)) {
+      return false;
+    }
+    FacetIndexingParams other = (FacetIndexingParams) obj;
+    if (clParams == null) {
+      if (other.clParams != null) {
+        return false;
+      }
+    } else if (!clParams.equals(other.clParams)) {
+      return false;
+    }
+    if (ordinalPolicy == null) {
+      if (other.ordinalPolicy != null) {
+        return false;
+      }
+    } else if (!ordinalPolicy.equals(other.ordinalPolicy)) {
+      return false;
+    }
+    if (partitionSize != other.partitionSize) {
+      return false;
+    }
+    if (pathPolicy == null) {
+      if (other.pathPolicy != null) {
+        return false;
+      }
+    } else if (!pathPolicy.equals(other.pathPolicy)) {
+      return false;
+    }
+    
+    Iterable<CategoryListParams> cLs = getAllCategoryListParams();
+    Iterable<CategoryListParams> otherCLs = other.getAllCategoryListParams();
+    
+    return cLs.equals(otherCLs);
+  }
+
+  /**
+   * Returns the delimiter character used internally for concatenating category
+   * path components, e.g. for drill-down terms.
+   */
+  public char getFacetDelimChar() {
+    return DEFAULT_FACET_DELIM_CHAR;
+  }
+
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java
index 1f657d8..035b190 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java
@@ -2,7 +2,9 @@ package org.apache.lucene.facet.index.params;
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
@@ -24,62 +26,59 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  */
 
 /**
- * A FacetIndexingParams that utilizes different category lists, defined by the
- * dimension specified CategoryPaths (see
- * {@link PerDimensionIndexingParams#addCategoryListParams(CategoryPath, CategoryListParams)}
+ * A {@link FacetIndexingParams} that utilizes different category lists, defined
+ * by the dimension specified by a {@link CategoryPath category} (see
+ * {@link #PerDimensionIndexingParams(Map, CategoryListParams)}.
  * <p>
  * A 'dimension' is defined as the first or "zero-th" component in a
- * CategoryPath. For example, if a CategoryPath is defined as
- * "/Author/American/Mark Twain", then the dimension is "Author".
- * <p>
- * This class also uses the 'default' CategoryListParams (as specified by
- * {@link CategoryListParams#CategoryListParams()} when
- * {@link #getCategoryListParams(CategoryPath)} is called for a CategoryPath
- * whose dimension component has not been specifically defined.
+ * {@link CategoryPath}. For example, if a category is defined as
+ * "Author/American/Mark Twain", then the dimension would be "Author".
  * 
  * @lucene.experimental
  */
-public class PerDimensionIndexingParams extends DefaultFacetIndexingParams {
+public class PerDimensionIndexingParams extends FacetIndexingParams {
 
-  // "Root" or "first component" of a Category Path maps to a
-  // CategoryListParams
-  private final Map<String, CategoryListParams> clParamsMap = new HashMap<String, CategoryListParams>();
+  private final Map<String, CategoryListParams> clParamsMap;
 
   /**
-   * Construct with the default {@link CategoryListParams} as the default
-   * CategoryListParams for unspecified CategoryPaths.
+   * Initializes a new instance with the given dimension-to-params mapping. The
+   * dimension is considered as what's returned by
+   * {@link CategoryPath#getComponent(int) cp.getComponent(0)}.
+   * 
+   * <p>
+   * <b>NOTE:</b> for any dimension whose {@link CategoryListParams} is not
+   * defined in the mapping, a default {@link CategoryListParams} will be used.
+   * 
+   * @see #PerDimensionIndexingParams(Map, CategoryListParams)
    */
-  public PerDimensionIndexingParams() {
-    this(new CategoryListParams());
+  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap) {
+    this(paramsMap, DEFAULT_CATEGORY_LIST_PARAMS);
   }
 
   /**
-   * Construct with the included categoryListParams as the default
-   * CategoryListParams for unspecified CategoryPaths.
-   * 
-   * @param categoryListParams
-   *            the default categoryListParams to use
+   * Same as {@link #PerDimensionIndexingParams(Map)}, only the given
+   * {@link CategoryListParams} will be used for any dimension that is not
+   * specified in the given mapping.
    */
-  public PerDimensionIndexingParams(CategoryListParams categoryListParams) {
+  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap, 
+      CategoryListParams categoryListParams) {
     super(categoryListParams);
+    clParamsMap = new HashMap<String,CategoryListParams>();
+    for (Entry<CategoryPath, CategoryListParams> e : paramsMap.entrySet()) {
+      clParamsMap.put(e.getKey().getComponent(0), e.getValue());
+    }
   }
 
-  /**
-   * Get all the categoryListParams, including the default.
-   */
   @Override
-  public Iterable<CategoryListParams> getAllCategoryListParams() {
-    ArrayList<CategoryListParams> vals = 
-      new ArrayList<CategoryListParams>(clParamsMap.values());
-    for (CategoryListParams clp : super.getAllCategoryListParams()) {
-      vals.add(clp);
-    }
+  public List<CategoryListParams> getAllCategoryListParams() {
+    ArrayList<CategoryListParams> vals = new ArrayList<CategoryListParams>(clParamsMap.values());
+    vals.add(clParams); // add the default too
     return vals;
   }
 
   /**
-   * Get the CategoryListParams based on the dimension or "zero-th category"
-   * of the specified CategoryPath.
+   * Returns the {@link CategoryListParams} for the corresponding dimension
+   * which is returned by {@code category.getComponent(0)}.
    */
   @Override
   public CategoryListParams getCategoryListParams(CategoryPath category) {
@@ -89,14 +88,7 @@ public class PerDimensionIndexingParams extends DefaultFacetIndexingParams {
         return clParams;
       }
     }
-    return super.getCategoryListParams(category);
+    return clParams;
   }
 
-  /**
-   * Add a CategoryListParams for a given CategoryPath's dimension or
-   * "zero-th" category.
-   */
-  public void addCategoryListParams(CategoryPath category, CategoryListParams clParams) {
-    clParamsMap.put(category.getComponent(0), clParams);
-  }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java b/lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java
index 2ef1651..5da3902 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java
@@ -154,20 +154,17 @@ public class CategoryParentsStream extends TokenFilter {
    * using {@link #addRetainableProperty(Class)}.
    */
   protected void clearCategoryProperties() {
-    if (this.retainableProperties == null
-        || this.retainableProperties.isEmpty()) {
-      this.categoryAttribute.clearProperties();
+    if (retainableProperties == null || retainableProperties.isEmpty()) {
+      categoryAttribute.clearProperties();
     } else {
-      List<Class<? extends CategoryProperty>> propertyClassesToRemove = 
-                            new LinkedList<Class<? extends CategoryProperty>>();
-      for (Class<? extends CategoryProperty> propertyClass : this.categoryAttribute
-          .getPropertyClasses()) {
-        if (!this.retainableProperties.contains(propertyClass)) {
-          propertyClassesToRemove.add(propertyClass);
+      List<Class<? extends CategoryProperty>> propsToRemove = new LinkedList<Class<? extends CategoryProperty>>();
+      for (Class<? extends CategoryProperty> propertyClass : categoryAttribute.getPropertyClasses()) {
+        if (!retainableProperties.contains(propertyClass)) {
+          propsToRemove.add(propertyClass);
         }
       }
-      for (Class<? extends CategoryProperty> propertyClass : propertyClassesToRemove) {
-        this.categoryAttribute.remove(propertyClass);
+      for (Class<? extends CategoryProperty> propertyClass : propsToRemove) {
+        categoryAttribute.remove(propertyClass);
       }
     }
   }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java b/lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java
index 9d38942..af997fb 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java
@@ -83,7 +83,7 @@ public class StandardFacetsAccumulator extends FacetsAccumulator {
     this.facetArrays = facetArrays;
     // can only be computed later when docids size is known
     isUsingComplements = false;
-    partitionSize = PartitionsUtils.partitionSize(searchParams, taxonomyReader);
+    partitionSize = PartitionsUtils.partitionSize(searchParams.getFacetIndexingParams(), taxonomyReader);
     maxPartitions = (int) Math.ceil(this.taxonomyReader.getSize() / (double) partitionSize);
     accumulateGuard = new Object();
   }
@@ -91,7 +91,7 @@ public class StandardFacetsAccumulator extends FacetsAccumulator {
   public StandardFacetsAccumulator(FacetSearchParams searchParams,
       IndexReader indexReader, TaxonomyReader taxonomyReader) {
     this(searchParams, indexReader, taxonomyReader, new FacetArrays(
-        PartitionsUtils.partitionSize(searchParams, taxonomyReader)));
+        PartitionsUtils.partitionSize(searchParams.getFacetIndexingParams(), taxonomyReader)));
   }
 
   @Override
@@ -109,7 +109,7 @@ public class StandardFacetsAccumulator extends FacetsAccumulator {
         try {
           totalFacetCounts = TotalFacetCountsCache.getSingleton()
             .getTotalCounts(indexReader, taxonomyReader,
-                searchParams.getFacetIndexingParams(), searchParams.getClCache());
+                searchParams.getFacetIndexingParams(), searchParams.getCategoryListCache());
           if (totalFacetCounts != null) {
             docids = ScoredDocIdsUtils.getComplementSet(docids, indexReader);
           } else {
@@ -135,11 +135,7 @@ public class StandardFacetsAccumulator extends FacetsAccumulator {
           isUsingComplements = false;
         } catch (Exception e) {
           // give up: this should not happen!
-          IOException ioEx = new IOException(
-              "PANIC: Got unexpected exception while trying to get/calculate total counts: "
-              +e.getMessage());
-          ioEx.initCause(e);
-          throw ioEx;
+          throw new IOException("PANIC: Got unexpected exception while trying to get/calculate total counts", e);
         }
       }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java
index 3c29404..da46778 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java
@@ -8,21 +8,25 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.lucene.index.IndexReader;
-
 import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.aggregator.Aggregator;
 import org.apache.lucene.facet.search.aggregator.CountingAggregator;
 import org.apache.lucene.facet.search.cache.CategoryListCache;
 import org.apache.lucene.facet.search.cache.CategoryListData;
+import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.facet.util.ScoredDocIdsUtils;
+import org.apache.lucene.index.IndexReader;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -146,13 +150,17 @@ public class TotalFacetCounts {
       dos.close();
     }
   }
+  
+  // needed because FacetSearchParams do not allow empty FacetRequests
+  private static final List<FacetRequest> DUMMY_REQ = Arrays.asList(
+      new FacetRequest[] { new CountFacetRequest(new CategoryPath(), 1) });
 
   static TotalFacetCounts compute(final IndexReader indexReader,
       final TaxonomyReader taxonomy, final FacetIndexingParams facetIndexingParams,
       final CategoryListCache clCache) throws IOException {
     int partitionSize = PartitionsUtils.partitionSize(facetIndexingParams, taxonomy);
     final int[][] counts = new int[(int) Math.ceil(taxonomy.getSize()  /(float) partitionSize)][partitionSize];
-    FacetSearchParams newSearchParams = new FacetSearchParams(facetIndexingParams); 
+    FacetSearchParams newSearchParams = new FacetSearchParams(DUMMY_REQ, facetIndexingParams); 
       //createAllListsSearchParams(facetIndexingParams,  this.totalCounts);
     FacetsAccumulator fe = new StandardFacetsAccumulator(newSearchParams, indexReader, taxonomy) {
       @Override
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java
index dfd4d59..388d061 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java
@@ -332,7 +332,7 @@ public abstract class FacetRequest implements Cloneable {
   public CategoryListIterator createCategoryListIterator(IndexReader reader,
       TaxonomyReader taxo, FacetSearchParams sParams, int partition)
       throws IOException {
-    CategoryListCache clCache = sParams.getClCache();
+    CategoryListCache clCache = sParams.getCategoryListCache();
     CategoryListParams clParams = sParams.getFacetIndexingParams().getCategoryListParams(categoryPath);
     if (clCache!=null) {
       CategoryListData clData = clCache.get(clParams);
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java b/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java
index a7522a9..7866243 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java
@@ -1,12 +1,10 @@
 package org.apache.lucene.facet.search.params;
 
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.cache.CategoryListCache;
-import org.apache.lucene.facet.search.results.FacetResult;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -26,12 +24,13 @@ import org.apache.lucene.facet.search.results.FacetResult;
  */
 
 /**
- * Faceted search parameters indicate for which facets should info be gathered.
+ * Defines parameters that are needed for faceted search. The list of
+ * {@link FacetRequest facet requests} denotes the facets for which aggregated
+ * should be done.
  * <p>
- * The contained facet requests define for which facets should info be gathered.
- * <p>
- * Contained faceted indexing parameters provide required info on how
- * to read and interpret the underlying faceted information in the search index.   
+ * One can pass {@link FacetIndexingParams} in order to tell the search code how
+ * to read the facets information. Note that you must use the same
+ * {@link FacetIndexingParams} that were used for indexing.
  * 
  * @lucene.experimental
  */
@@ -39,64 +38,63 @@ public class FacetSearchParams {
 
   protected final FacetIndexingParams indexingParams;
   protected final List<FacetRequest> facetRequests;
-  private CategoryListCache clCache = null;
-
+  
   /**
-   * Construct with specific faceted indexing parameters.
-   * It is important to know the indexing parameters so as to e.g. 
-   * read facets data correctly from the index.
-   * {@link #addFacetRequest(FacetRequest)} must be called at least once 
-   * for this faceted search to find any faceted result.
-   * @param indexingParams Indexing faceted parameters which were used at indexing time.
-   * @see #addFacetRequest(FacetRequest)
+   * Initializes with the given {@link FacetRequest requests} and default
+   * {@link FacetIndexingParams#ALL_PARENTS}. If you used a different
+   * {@link FacetIndexingParams}, you should use
+   * {@link #FacetSearchParams(List, FacetIndexingParams)}.
    */
-  public FacetSearchParams(FacetIndexingParams indexingParams) {
-    this.indexingParams = indexingParams;
-    facetRequests = new ArrayList<FacetRequest>();
+  public FacetSearchParams(FacetRequest... facetRequests) {
+    this(Arrays.asList(facetRequests), FacetIndexingParams.ALL_PARENTS);
   }
-
+  
   /**
-   * Construct with default faceted indexing parameters.
-   * Usage of this constructor is valid only if also during indexing the 
-   * default faceted indexing parameters were used.   
-   * {@link #addFacetRequest(FacetRequest)} must be called at least once 
-   * for this faceted search to find any faceted result.
-   * @see #addFacetRequest(FacetRequest)
+   * Initializes with the given {@link FacetRequest requests} and default
+   * {@link FacetIndexingParams#ALL_PARENTS}. If you used a different
+   * {@link FacetIndexingParams}, you should use
+   * {@link #FacetSearchParams(List, FacetIndexingParams)}.
    */
-  public FacetSearchParams() {
-    this(new DefaultFacetIndexingParams());
+  public FacetSearchParams(List<FacetRequest> facetRequests) {
+    this(facetRequests, FacetIndexingParams.ALL_PARENTS);
   }
 
   /**
-   * A list of {@link FacetRequest} objects, determining what to count.
-   * If the returned collection is empty, the faceted search will return no facet results!
+   * Initilizes with the given {@link FacetRequest requests} and
+   * {@link FacetIndexingParams}.
    */
-  public final FacetIndexingParams getFacetIndexingParams() {
-    return indexingParams;
+  public FacetSearchParams(List<FacetRequest> facetRequests, FacetIndexingParams indexingParams) {
+    if (facetRequests == null || facetRequests.size() == 0) {
+      throw new IllegalArgumentException("at least one FacetRequest must be defined");
+    }
+    this.indexingParams = indexingParams;
+    this.facetRequests = facetRequests;
   }
 
   /**
-   * Parameters which controlled the indexing of facets, and which are also
-   * needed during search.
+   * Returns the {@link CategoryListCache}. By default returns {@code null}, you
+   * should override if you want to use a cache.
    */
-  public final List<FacetRequest> getFacetRequests() {
-    return facetRequests;
+  public CategoryListCache getCategoryListCache() {
+    return null;
   }
 
   /**
-   * Add a facet request to apply for this faceted search.
-   * This method must be called at least once for faceted search 
-   * to find any faceted result. <br>
-   * NOTE: The order of addition implies the order of the {@link FacetResult}s
-   * @param facetRequest facet request to be added.
+   * Returns the {@link FacetIndexingParams} that were passed to the
+   * constructor.
    */
-  public void addFacetRequest(FacetRequest facetRequest) {
-    if (facetRequest == null) {
-      throw new IllegalArgumentException("Provided facetRequest must not be null");
-    }
-    facetRequests.add(facetRequest);
+  public FacetIndexingParams getFacetIndexingParams() {
+    return indexingParams;
   }
   
+  /**
+   * Returns the list of {@link FacetRequest facet requests} that were passed to
+   * the constructor.
+   */
+  public List<FacetRequest> getFacetRequests() {
+    return facetRequests;
+  }
+
   @Override
   public String toString() {
     final char TAB = '\t';
@@ -112,19 +110,4 @@ public class FacetSearchParams {
     
     return sb.toString();
   }
-
-  /**
-   * @return the cldCache in effect
-   */
-  public CategoryListCache getClCache() {
-    return clCache;
-  }
-
-  /**
-   * Set Cached Category Lists data to be used in Faceted search.
-   * @param clCache the cldCache to set
-   */
-  public void setClCache(CategoryListCache clCache) {
-    this.clCache = clCache;
-  }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java b/lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java
index c3bdfdf..e6f7f7d3 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java
@@ -1,6 +1,8 @@
 package org.apache.lucene.facet.search.sampling;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.lucene.index.IndexReader;
 
@@ -183,11 +185,12 @@ public abstract class Sampler {
     // So now we can sample -> altering the searchParams to accommodate for the statistical error for the sampling
     double overSampleFactor = getSamplingParams().getOversampleFactor();
     if (overSampleFactor > 1) { // any factoring to do?
-      res = new FacetSearchParams(original.getFacetIndexingParams());
-      for (FacetRequest frq: original.getFacetRequests()) {
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      for (FacetRequest frq : original.getFacetRequests()) {
         int overSampledNumResults = (int) Math.ceil(frq.getNumResults() * overSampleFactor);
-        res.addFacetRequest(new OverSampledFacetRequest(frq, overSampledNumResults));
+        facetRequests.add(new OverSampledFacetRequest(frq, overSampledNumResults));
       }
+      res = new FacetSearchParams(facetRequests, original.getFacetIndexingParams());
     }
     return res;
   }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java b/lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java
index 4c6673c..7e583e1 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java
@@ -2,7 +2,6 @@ package org.apache.lucene.facet.util;
 
 import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 
 /*
@@ -33,22 +32,12 @@ public final class PartitionsUtils {
    * Get the offset for a given partition.  That is, what is the minimum number an
    * ordinal could be for a particular partition. 
    */
-  public final static int partitionOffset (  FacetIndexingParams iParams, 
-                        int partitionNumber, 
-                        final TaxonomyReader taxonomyReader) {
+  public final static int partitionOffset(FacetIndexingParams iParams,
+      int partitionNumber, final TaxonomyReader taxonomyReader) {
     return partitionNumber * partitionSize(iParams, taxonomyReader);
   }
 
   /**
-   * @see #partitionOffset(FacetIndexingParams, int, TaxonomyReader)
-   */
-  public final static int partitionOffset (  FacetSearchParams sParams, 
-                        int partitionNumber, 
-                        final TaxonomyReader taxonomyReader) {
-    return partitionOffset(sParams.getFacetIndexingParams(), partitionNumber, taxonomyReader);
-  }
-
-  /**
    * Get the partition size in this parameter, or return the size of the taxonomy, which
    * is smaller.  (Guarantees usage of as little memory as possible at search time).
    */
@@ -57,13 +46,6 @@ public final class PartitionsUtils {
   }
 
   /**
-   * @see #partitionSize(FacetIndexingParams, TaxonomyReader)
-   */
-  public final static int partitionSize(FacetSearchParams sParams, final TaxonomyReader taxonomyReader) {
-    return partitionSize(sParams.getFacetIndexingParams(), taxonomyReader);
-  }
-
-  /**
    * Partition number of an ordinal.
    * <p>
    * This allows to locate the partition containing a certain (facet) ordinal.
@@ -74,19 +56,11 @@ public final class PartitionsUtils {
   }
 
   /**
-   * @see #partitionNumber(FacetIndexingParams, int)
-   */
-  public final static int partitionNumber(FacetSearchParams sParams, int ordinal) {
-    return partitionNumber(sParams.getFacetIndexingParams(), ordinal);
-  }
-
-  /**
    * Partition name by category ordinal
    */
-  public final static String partitionNameByOrdinal(  FacetIndexingParams iParams, 
-                            CategoryListParams clParams, 
-                            int ordinal) {
-    int partition = partitionNumber(iParams, ordinal); 
+  public final static String partitionNameByOrdinal(
+      FacetIndexingParams iParams, CategoryListParams clParams, int ordinal) {
+    int partition = partitionNumber(iParams, ordinal);
     return partitionName(clParams, partition);
   }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
index 4c93613..ed2482a 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
@@ -15,6 +15,18 @@ import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.facet.index.CategoryDocumentBuilder;
+import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
+import org.apache.lucene.facet.search.params.FacetRequest;
+import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.search.results.FacetResult;
+import org.apache.lucene.facet.search.results.FacetResultNode;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.IndexReader;
@@ -28,24 +40,10 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.store.Directory;
-
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
-import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.search.params.FacetRequest;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
-import org.apache.lucene.facet.search.results.FacetResult;
-import org.apache.lucene.facet.search.results.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
@@ -184,29 +182,28 @@ public abstract class FacetTestBase extends LuceneTestCase {
 
   /** Returns a default facet indexing params */
   protected FacetIndexingParams getFacetIndexingParams(final int partSize) {
-    return new DefaultFacetIndexingParams() {
+    return new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return partSize;
       }
     };
   }
   
   /**
-   * Faceted Search Params for the test.
-   * Sub classes should override in order to test with different faceted search params.
+   * Faceted Search Params for the test. Sub classes should override in order to
+   * test with different faceted search params.
    */
-  protected FacetSearchParams getFacetedSearchParams() {
-    return getFacetedSearchParams(Integer.MAX_VALUE);
+  protected FacetSearchParams getFacetSearchParams(FacetIndexingParams iParams, FacetRequest... facetRequests) {
+    return new FacetSearchParams(Arrays.asList(facetRequests), iParams);
   }
 
   /**
-   * Faceted Search Params with specified partition size.
-   * @see #getFacetedSearchParams()
+   * Faceted Search Params for the test. Sub classes should override in order to
+   * test with different faceted search params.
    */
-  protected FacetSearchParams getFacetedSearchParams(int partitionSize) {
-    FacetSearchParams res = new FacetSearchParams(getFacetIndexingParams(partitionSize));
-    return res; 
+  protected FacetSearchParams getFacetSearchParams(List<FacetRequest> facetRequests, FacetIndexingParams iParams) {
+    return new FacetSearchParams(facetRequests, iParams);
   }
 
   /**
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java
index 5cc79a8..7c2b107 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java
@@ -2,26 +2,13 @@ package org.apache.lucene.facet;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.List;
 
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.Collector;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-import org.apache.lucene.store.Directory;
-
-import org.apache.lucene.search.MultiCollector;
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
@@ -32,6 +19,17 @@ import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.Collector;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -91,19 +89,18 @@ public class FacetTestUtils {
   }
 
   public static Collector[] search(IndexSearcher searcher,
-      TaxonomyReader taxonomyReader, DefaultFacetIndexingParams iParams,
-      int k, String... facetNames) throws IOException {
+      TaxonomyReader taxonomyReader, FacetIndexingParams iParams, int k,
+      String... facetNames) throws IOException {
     
     Collector[] collectors = new Collector[2];
     
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-    Collection<FacetRequest> fRequests = new ArrayList<FacetRequest>();
+    List<FacetRequest> fRequests = new ArrayList<FacetRequest>();
     for (String facetName : facetNames) {
       CategoryPath cp = new CategoryPath(facetName);
       FacetRequest fq = new CountFacetRequest(cp, k);
-      facetSearchParams.addFacetRequest(fq);
       fRequests.add(fq);
     }
+    FacetSearchParams facetSearchParams = new FacetSearchParams(fRequests, iParams);
 
     TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(
         searcher.getIndexReader().maxDoc(), true);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java
index fc15e46..1a9c795 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java
@@ -56,7 +56,7 @@ public class CategoryEnhancementDummy1 implements CategoryEnhancement {
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java
index 0bd454c..becb5d6 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java
@@ -65,8 +65,8 @@ public class CategoryEnhancementDummy2 implements CategoryEnhancement {
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
-    return DummyProperty.class;
+  public CategoryProperty getRetainableProperty() {
+    return DummyProperty.INSTANCE;
   }
 
   @Override
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java
index b525252..18c1f41 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java
@@ -64,7 +64,7 @@ public class CategoryEnhancementDummy3 implements CategoryEnhancement {
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java
index ddfb57d..4db1717 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java
@@ -7,21 +7,17 @@ import java.util.List;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
-import org.apache.lucene.facet.enhancements.EnhancementsPayloadIterator;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
 import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.search.DrillDown;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -47,10 +43,8 @@ public class TwoEnhancementsTest extends LuceneTestCase {
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
 
-    EnhancementsIndexingParams indexingParams = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy1(),
-          new CategoryEnhancementDummy3());
+    EnhancementsIndexingParams indexingParams = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy1(), new CategoryEnhancementDummy3());
 
     // add document with a category containing data for both enhancements
     List<CategoryPath> categoryPaths = new ArrayList<CategoryPath>();
@@ -93,10 +87,8 @@ public class TwoEnhancementsTest extends LuceneTestCase {
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
 
-    EnhancementsIndexingParams indexingParams = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy2(),
-          new CategoryEnhancementDummy3());
+    EnhancementsIndexingParams indexingParams = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy2(), new CategoryEnhancementDummy3());
 
     List<CategoryPath> categoryPaths = new ArrayList<CategoryPath>();
     categoryPaths.add(new CategoryPath("a", "b"));
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java
index 9a1f637..4c69e57 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java
@@ -3,14 +3,7 @@ package org.apache.lucene.facet.enhancements.association;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
 import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.index.CategoryContainer;
 import org.apache.lucene.facet.index.attributes.CategoryAttributeImpl;
@@ -18,6 +11,11 @@ import org.apache.lucene.facet.index.attributes.CategoryProperty;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -51,8 +49,7 @@ public class CustomAssociationPropertyTest extends LuceneTestCase {
     }
 
     final int NUM_CATEGORIES = 10;
-    EnhancementsIndexingParams iParams = new DefaultEnhancementsIndexingParams(
-        new AssociationEnhancement());
+    EnhancementsIndexingParams iParams = new EnhancementsIndexingParams(new AssociationEnhancement());
 
     Directory iDir = newDirectory();
     Directory tDir = newDirectory();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java
deleted file mode 100644
index 9bf0861..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.apache.lucene.facet.enhancements.params;
-
-import java.util.List;
-
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.enhancements.CategoryEnhancement;
-import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy1;
-import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy2;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
-import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
-import org.apache.lucene.facet.index.DummyProperty;
-import org.apache.lucene.facet.index.attributes.CategoryProperty;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class DefaultEnhancementsIndexingParamsTest extends LuceneTestCase {
-
-  @Test
-  public void testCategoryEnhancements() {
-    EnhancementsIndexingParams params = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy1());
-
-    // check retainable properties 
-    List<Class<? extends CategoryProperty>> retainableProps = params
-        .getRetainableProperties();
-    assertNull("Unexpected content in retainable list", retainableProps);
-
-    params.addCategoryEnhancements(new CategoryEnhancementDummy2());
-
-    List<CategoryEnhancement> enhancements = params
-        .getCategoryEnhancements();
-
-    assertEquals("Wrong number of enhancements", 2, enhancements.size());
-
-    assertTrue("Wrong first enhancement",
-        enhancements.get(0) instanceof CategoryEnhancementDummy1);
-    assertTrue("Wrong second enhancement",
-        enhancements.get(1) instanceof CategoryEnhancementDummy2);
-
-    // re-check retainable properties 
-    retainableProps = params.getRetainableProperties();
-    assertNotNull("Unexpected empty retainable list", retainableProps);
-    assertEquals("Unexpected size of retainable list", 1, retainableProps
-        .size());
-    assertEquals("Wrong property in retainable list", DummyProperty.class,
-        retainableProps.get(0));
-
-  }
-}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java
new file mode 100644
index 0000000..bb331fc
--- /dev/null
+++ b/lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java
@@ -0,0 +1,51 @@
+package org.apache.lucene.facet.enhancements.params;
+
+import java.util.List;
+
+import org.apache.lucene.facet.enhancements.CategoryEnhancement;
+import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy1;
+import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy2;
+import org.apache.lucene.facet.index.DummyProperty;
+import org.apache.lucene.facet.index.attributes.CategoryProperty;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class EnhancementsIndexingParamsTest extends LuceneTestCase {
+
+  @Test
+  public void testCategoryEnhancements() {
+    EnhancementsIndexingParams params = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy1(), new CategoryEnhancementDummy2());
+
+    List<CategoryEnhancement> enhancements = params.getCategoryEnhancements();
+    assertEquals("Wrong number of enhancements", 2, enhancements.size());
+
+    // check order
+    assertTrue("Wrong first enhancement", enhancements.get(0) instanceof CategoryEnhancementDummy1);
+    assertTrue("Wrong second enhancement", enhancements.get(1) instanceof CategoryEnhancementDummy2);
+
+    // check retainable properties 
+    List<CategoryProperty> retainableProps = params.getRetainableProperties();
+    assertNotNull("Unexpected empty retainable list", retainableProps);
+    assertEquals("Unexpected size of retainable list", 1, retainableProps.size());
+    assertSame("Wrong property in retainable list", DummyProperty.INSTANCE, retainableProps.get(0));
+  }
+  
+}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java
index ec8a5de..5ddb9a8 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java
@@ -62,7 +62,7 @@ public class CategoryContainerTest extends CategoryContainerTestBase {
   @Test
   public void testExistingNewCategoryWithProperty() throws FacetException {
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -83,12 +83,12 @@ public class CategoryContainerTest extends CategoryContainerTestBase {
     AssociationProperty associationProperty = new AssociationIntProperty(
         49);
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty(), associationProperty);
+        DummyProperty.INSTANCE, associationProperty);
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     associationProperty = new AssociationIntProperty(123);
     categoryContainer.addCategory(new CategoryPath("nine"),
-        associationProperty, new DummyProperty());
+        associationProperty, DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -114,7 +114,7 @@ public class CategoryContainerTest extends CategoryContainerTestBase {
   @Test
   public void testAddNewCategoryWithProperty() throws FacetException {
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -150,7 +150,7 @@ public class CategoryContainerTest extends CategoryContainerTestBase {
   public void testAddCategoryAttributeWithProperty() throws FacetException {
     CategoryAttribute newCA = new CategoryAttributeImpl(new CategoryPath(
         "seven", "eight"));
-    newCA.addProperty(new DummyProperty());
+    newCA.addProperty(DummyProperty.INSTANCE);
     categoryContainer.addCategory(newCA);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
@@ -215,12 +215,12 @@ public class CategoryContainerTest extends CategoryContainerTestBase {
     AssociationProperty associationProperty = new AssociationIntProperty(
         49);
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty(), associationProperty);
+        DummyProperty.INSTANCE, associationProperty);
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     associationProperty = new AssociationIntProperty(123);
     categoryContainer.addCategory(new CategoryPath("nine"),
-        associationProperty, new DummyProperty());
+        associationProperty, DummyProperty.INSTANCE);
     
     ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);
     ObjectOutputStream out = new ObjectOutputStream(baos);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java b/lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java
index b04ced2..08e8b16 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java
@@ -24,6 +24,10 @@ import org.apache.lucene.facet.index.attributes.CategoryProperty;
  */
 public class DummyProperty implements CategoryProperty {
 
+  public static final DummyProperty INSTANCE = new DummyProperty();
+  
+  private DummyProperty() {}
+  
   @Override
   public boolean equals(Object o) {
     if (o instanceof DummyProperty) {
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java
index 9f5e890..88f2dbf 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java
@@ -70,8 +70,7 @@ public class FacetsPayloadProcessorProviderTest extends LuceneTestCase {
     DirectoryReader reader1 = DirectoryReader.open(dir);
     DirectoryTaxonomyReader taxReader = new DirectoryTaxonomyReader(taxDir);
     IndexSearcher searcher = newSearcher(reader1);
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("tag"), NUM_DOCS));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("tag"), NUM_DOCS));
     FacetsCollector collector = new FacetsCollector(fsp, reader1, taxReader);
     searcher.search(new MatchAllDocsQuery(), collector);
     FacetResult result = collector.getFacetResults().get(0);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java
index 63c4816..bd66a13 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java
@@ -57,15 +57,15 @@ public class CategoryAttributeImplTest extends LuceneTestCase {
         .getProperty(DummyProperty.class));
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(DummyProperty.class));
+        DummyProperty.INSTANCE, ca.getProperty(DummyProperty.class));
     assertEquals("Attribute classes should contain 1 element", 1, ca
         .getPropertyClasses().size());
 
     boolean failed = false;
     try {
-      ca.addProperty(new DummyProperty());
+      ca.addProperty(DummyProperty.INSTANCE);
     } catch (UnsupportedOperationException e) {
       failed = true;
     }
@@ -77,24 +77,24 @@ public class CategoryAttributeImplTest extends LuceneTestCase {
     ca.clearProperties();
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(DummyProperty.class));
+        DummyProperty.INSTANCE, ca.getProperty(DummyProperty.class));
     ca.remove(DummyProperty.class);
     assertEquals("DummyProperty should not be in properties", null, ca
         .getProperty(DummyProperty.class));
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     List<Class<? extends CategoryProperty>> propertyClasses = new ArrayList<Class<? extends CategoryProperty>>();
     assertEquals("No property expected when no classes given", null, ca
         .getProperty(propertyClasses));
     propertyClasses.add(DummyProperty.class);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(propertyClasses));
+        DummyProperty.INSTANCE, ca.getProperty(propertyClasses));
     propertyClasses.add(OrdinalProperty.class);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(propertyClasses));
+        DummyProperty.INSTANCE, ca.getProperty(propertyClasses));
     propertyClasses.clear();
     propertyClasses.add(OrdinalProperty.class);
     assertEquals("No ordinal property expected", null, ca
@@ -107,7 +107,7 @@ public class CategoryAttributeImplTest extends LuceneTestCase {
 
     CategoryPath cp = new CategoryPath("a", "b");
     ca1.setCategoryPath(cp);
-    ca1.addProperty(new DummyProperty());
+    ca1.addProperty(DummyProperty.INSTANCE);
 
     CategoryAttribute ca2 = ca1.clone();
     assertEquals("Error in cloning", ca1, ca2);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java
deleted file mode 100644
index f71ecf2..0000000
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.lucene.facet.index.params;
-
-import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
-import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.search.DrillDown;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.util.PartitionsUtils;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class DefaultFacetIndexingParamsTest extends LuceneTestCase {
-
-  @Test
-  public void testDefaultSettings() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
-    assertNotNull("Missing default category list", dfip
-        .getAllCategoryListParams());
-    assertEquals(
-        "all categories have the same CategoryListParams by default",
-        dfip.getCategoryListParams(null), dfip
-            .getCategoryListParams(new CategoryPath("a")));
-    assertEquals(
-        "Expected default category list term is $facets:$fulltree$",
-        new Term("$facets", "$fulltree$"), dfip.getCategoryListParams(
-            null).getTerm());
-    String expectedDDText = "a"
-        + dfip.getFacetDelimChar() + "b";
-    CategoryPath cp = new CategoryPath("a", "b");
-    assertEquals("wrong drill-down term", new Term("$facets",
-        expectedDDText), DrillDown.term(dfip,cp));
-    char[] buf = new char[20];
-    int numchars = dfip.drillDownTermText(cp, buf);
-    assertEquals("3 characters should be written", 3, numchars);
-    assertEquals("wrong drill-down term text", expectedDDText, new String(
-        buf, 0, numchars));
-    CategoryListParams clParams = dfip.getCategoryListParams(null);
-    assertEquals("partition for all ordinals is the first", "$fulltree$", 
-        PartitionsUtils.partitionNameByOrdinal(dfip, clParams , 250));
-    assertEquals("for partition 0, the same name should be returned",
-        "$fulltree$", PartitionsUtils.partitionName(clParams, 0));
-    assertEquals(
-        "for any other, it's the concatenation of name + partition",
-        "$fulltree$1", PartitionsUtils.partitionName(clParams, 1));
-    assertEquals("default partition number is always 0", 0, 
-        PartitionsUtils.partitionNumber(dfip,100));
-    assertEquals("default partition size is unbounded", Integer.MAX_VALUE,
-        dfip.getPartitionSize());
-  }
-
-  @Test
-  public void testCategoryListParamsWithDefaultIndexingParams() {
-    CategoryListParams clp = new CategoryListParams(
-        new Term("clp", "value"));
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams(clp);
-    assertEquals("Expected default category list term is " + clp.getTerm(),
-        clp.getTerm(), dfip.getCategoryListParams(null).getTerm());
-  }
-
-  @Test
-  public void testCategoryPolicies() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
-    // check path policy
-    CategoryPath cp = new CategoryPath();
-    PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
-    assertEquals("path policy does not match default for root", pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
-    for (int i = 0; i < 30; i++) {
-      int nComponents = random().nextInt(10);
-      String[] components = new String[nComponents];
-      for (int j = 0; j < components.length; j++) {
-        components[j] = (Integer.valueOf(random().nextInt(30))).toString();
-      }
-      cp = new CategoryPath(components);
-      assertEquals("path policy does not match default for " + cp.toString('/'), 
-          pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
-    }
-
-    // check ordinal policy
-    OrdinalPolicy ordinalPolicy = OrdinalPolicy.ALL_PARENTS;
-    assertEquals("ordinal policy does not match default for root", 
-        ordinalPolicy.shouldAdd(TaxonomyReader.ROOT_ORDINAL), 
-        dfip.getOrdinalPolicy().shouldAdd(TaxonomyReader.ROOT_ORDINAL));
-    for (int i = 0; i < 30; i++) {
-      int ordinal = random().nextInt();
-      assertEquals("ordinal policy does not match default for " + ordinal, 
-          ordinalPolicy.shouldAdd(ordinal),
-          dfip.getOrdinalPolicy().shouldAdd(ordinal));
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java
new file mode 100644
index 0000000..151dca7
--- /dev/null
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java
@@ -0,0 +1,104 @@
+package org.apache.lucene.facet.index.params;
+
+import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
+import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
+import org.apache.lucene.facet.search.DrillDown;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class FacetIndexingParamsTest extends LuceneTestCase {
+
+  @Test
+  public void testDefaultSettings() {
+    FacetIndexingParams dfip = FacetIndexingParams.ALL_PARENTS;
+    assertNotNull("Missing default category list", dfip.getAllCategoryListParams());
+    assertEquals("all categories have the same CategoryListParams by default",
+        dfip.getCategoryListParams(null), dfip.getCategoryListParams(new CategoryPath("a")));
+    assertEquals("Expected default category list term is $facets:$fulltree$",
+        new Term("$facets", "$fulltree$"), dfip.getCategoryListParams(null).getTerm());
+    String expectedDDText = "a"
+        + dfip.getFacetDelimChar() + "b";
+    CategoryPath cp = new CategoryPath("a", "b");
+    assertEquals("wrong drill-down term", new Term("$facets",
+        expectedDDText), DrillDown.term(dfip,cp));
+    char[] buf = new char[20];
+    int numchars = dfip.drillDownTermText(cp, buf);
+    assertEquals("3 characters should be written", 3, numchars);
+    assertEquals("wrong drill-down term text", expectedDDText, new String(
+        buf, 0, numchars));
+    CategoryListParams clParams = dfip.getCategoryListParams(null);
+    assertEquals("partition for all ordinals is the first", "$fulltree$", 
+        PartitionsUtils.partitionNameByOrdinal(dfip, clParams , 250));
+    assertEquals("for partition 0, the same name should be returned",
+        "$fulltree$", PartitionsUtils.partitionName(clParams, 0));
+    assertEquals(
+        "for any other, it's the concatenation of name + partition",
+        "$fulltree$1", PartitionsUtils.partitionName(clParams, 1));
+    assertEquals("default partition number is always 0", 0, 
+        PartitionsUtils.partitionNumber(dfip,100));
+    assertEquals("default partition size is unbounded", Integer.MAX_VALUE,
+        dfip.getPartitionSize());
+  }
+
+  @Test
+  public void testCategoryListParamsWithDefaultIndexingParams() {
+    CategoryListParams clp = new CategoryListParams(
+        new Term("clp", "value"));
+    FacetIndexingParams dfip = new FacetIndexingParams(clp);
+    assertEquals("Expected default category list term is " + clp.getTerm(),
+        clp.getTerm(), dfip.getCategoryListParams(null).getTerm());
+  }
+
+  @Test
+  public void testCategoryPolicies() {
+    FacetIndexingParams dfip = FacetIndexingParams.ALL_PARENTS;
+    // check path policy
+    CategoryPath cp = new CategoryPath();
+    PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
+    assertEquals("path policy does not match default for root", pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
+    for (int i = 0; i < 30; i++) {
+      int nComponents = random().nextInt(10);
+      String[] components = new String[nComponents];
+      for (int j = 0; j < components.length; j++) {
+        components[j] = (Integer.valueOf(random().nextInt(30))).toString();
+      }
+      cp = new CategoryPath(components);
+      assertEquals("path policy does not match default for " + cp.toString('/'), 
+          pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
+    }
+
+    // check ordinal policy
+    OrdinalPolicy ordinalPolicy = OrdinalPolicy.ALL_PARENTS;
+    assertEquals("ordinal policy does not match default for root", 
+        ordinalPolicy.shouldAdd(TaxonomyReader.ROOT_ORDINAL), 
+        dfip.getOrdinalPolicy().shouldAdd(TaxonomyReader.ROOT_ORDINAL));
+    for (int i = 0; i < 30; i++) {
+      int ordinal = random().nextInt();
+      assertEquals("ordinal policy does not match default for " + ordinal, 
+          ordinalPolicy.shouldAdd(ordinal),
+          dfip.getOrdinalPolicy().shouldAdd(ordinal));
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java
index eb2759d..c73cf8d 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java
@@ -1,15 +1,13 @@
 package org.apache.lucene.facet.index.params;
 
-import org.apache.lucene.index.Term;
-import org.junit.Test;
+import java.util.Collections;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.DrillDown;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -32,9 +30,8 @@ public class PerDimensionIndexingParamsTest extends LuceneTestCase {
 
   @Test
   public void testTopLevelSettings() {
-    FacetIndexingParams ifip = new PerDimensionIndexingParams();
-    assertNotNull("Missing default category list", ifip
-        .getAllCategoryListParams());
+    FacetIndexingParams ifip = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
+    assertNotNull("Missing default category list", ifip.getAllCategoryListParams());
     assertEquals(
         "Expected default category list term is $facets:$fulltree$",
         new Term("$facets", "$fulltree$"), ifip.getCategoryListParams(
@@ -67,15 +64,12 @@ public class PerDimensionIndexingParamsTest extends LuceneTestCase {
 
   @Test
   public void testCategoryListParamsAddition() {
-    PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams();
-    CategoryListParams clp = new CategoryListParams(
-        new Term("clp", "value"));
-    tlfip.addCategoryListParams(new CategoryPath("a"), clp);
-    assertEquals("Expected category list term is " + clp.getTerm(), clp
-        .getTerm(), tlfip.getCategoryListParams(new CategoryPath("a"))
-        .getTerm());
-    assertNotSame("Unexpected default category list " + clp.getTerm(), clp,
-        tlfip.getCategoryListParams(null));
+    CategoryListParams clp = new CategoryListParams(new Term("clp", "value"));
+    PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams(
+        Collections.<CategoryPath,CategoryListParams> singletonMap(new CategoryPath("a"), clp));
+    assertEquals("Expected category list term is " + clp.getTerm(), 
+        clp.getTerm(), tlfip.getCategoryListParams(new CategoryPath("a")).getTerm());
+    assertNotSame("Unexpected default category list " + clp.getTerm(), clp, tlfip.getCategoryListParams(null));
   }
 
 }
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java
index acbfa5d..25a3b8c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java
@@ -3,20 +3,17 @@ package org.apache.lucene.facet.index.streaming;
 import java.io.IOException;
 
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.facet.FacetException;
 import org.apache.lucene.facet.index.CategoryContainerTestBase;
 import org.apache.lucene.facet.index.DummyProperty;
 import org.apache.lucene.facet.index.categorypolicy.NonTopLevelOrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.NonTopLevelPathPolicy;
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.store.Directory;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -49,7 +46,7 @@ public class CategoryParentsStreamTest extends CategoryContainerTestBase {
         directory);
     CategoryParentsStream stream = new CategoryParentsStream(
         new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
 
     // count the number of tokens
     int nTokens;
@@ -72,13 +69,13 @@ public class CategoryParentsStreamTest extends CategoryContainerTestBase {
     Directory directory = newDirectory();
     final TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
         directory);
-    FacetIndexingParams indexingParams = new DefaultFacetIndexingParams() {
+    FacetIndexingParams indexingParams = new FacetIndexingParams() {
       @Override
-      protected OrdinalPolicy fixedOrdinalPolicy() {
+      public OrdinalPolicy getOrdinalPolicy() {
         return new NonTopLevelOrdinalPolicy();
       }
       @Override
-      protected PathPolicy fixedPathPolicy() {
+      public PathPolicy getPathPolicy() {
         return new NonTopLevelPathPolicy();
       }
     };
@@ -110,15 +107,14 @@ public class CategoryParentsStreamTest extends CategoryContainerTestBase {
     Directory directory = newDirectory();
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(directory);
 
-    new CategoryParentsStream(new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+    assertNotNull(new CategoryParentsStream(new CategoryAttributesStream(categoryContainer),
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS));
 
     // add DummyAttribute, but do not retain, only one expected
-    categoryContainer.addCategory(initialCatgeories[0], new DummyProperty());
+    categoryContainer.addCategory(initialCatgeories[0], DummyProperty.INSTANCE);
 
     CategoryParentsStream stream = new CategoryParentsStream(new CategoryAttributesStream(
-        categoryContainer), taxonomyWriter,
-        new DefaultFacetIndexingParams());
+        categoryContainer), taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
 
     int nAttributes = 0;
     while (stream.incrementToken()) {
@@ -139,24 +135,21 @@ public class CategoryParentsStreamTest extends CategoryContainerTestBase {
   @Test
   public void testRetainableAttributes() throws IOException {
     Directory directory = newDirectory();
-    TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
-        directory);
+    TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(directory);
 
-    FacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
-    new CategoryParentsStream(new CategoryAttributesStream(
-        categoryContainer), taxonomyWriter, indexingParams);
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
+    assertNotNull(new CategoryParentsStream(new CategoryAttributesStream(
+        categoryContainer), taxonomyWriter, indexingParams));
 
     // add DummyAttribute and retain it, three expected
     categoryContainer.clear();
-    categoryContainer
-        .addCategory(initialCatgeories[0], new DummyProperty());
+    categoryContainer.addCategory(initialCatgeories[0], DummyProperty.INSTANCE);
     CategoryParentsStream stream = new CategoryParentsStream(
         new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
     stream.addRetainableProperty(DummyProperty.class);
 
-    MyCategoryListTokenizer tokenizer = new MyCategoryListTokenizer(stream,
-        indexingParams);
+    MyCategoryListTokenizer tokenizer = new MyCategoryListTokenizer(stream, indexingParams);
 
     int nAttributes = 0;
     try {
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java b/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java
index 977eeb0..ec9ad26 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java
@@ -7,17 +7,14 @@ import java.util.List;
 import java.util.Set;
 
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
 import org.apache.lucene.facet.index.CategoryContainerTestBase;
 import org.apache.lucene.facet.index.attributes.CategoryAttributesIterable;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-import org.apache.lucene.facet.index.streaming.CategoryAttributesStream;
-import org.apache.lucene.facet.index.streaming.CategoryTokenizer;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.store.Directory;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -47,7 +44,7 @@ public class CategoryTokenizerTest extends CategoryContainerTestBase {
     Directory directory = newDirectory();
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
         directory);
-    DefaultFacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     CategoryTokenizer tokenizer = new CategoryTokenizer(
         new CategoryAttributesStream(categoryContainer),
         indexingParams);
@@ -89,7 +86,7 @@ public class CategoryTokenizerTest extends CategoryContainerTestBase {
     longCategory.add(new CategoryPath("one", "two", "three", "four",
         "five", "six", "seven"));
 
-    DefaultFacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     CategoryTokenizer tokenizer = new CategoryTokenizer(
         new CategoryAttributesStream(new CategoryAttributesIterable(
             longCategory)), indexingParams);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java b/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
index 9dc320d..45e2322 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
@@ -1,6 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
@@ -12,6 +13,7 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.facet.FacetTestBase;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -97,12 +99,12 @@ public abstract class BaseTestTopK extends FacetTestBase {
   }
   
   protected FacetSearchParams searchParamsWithRequests(int numResults, int partitionSize) {
-    FacetSearchParams res = getFacetedSearchParams(partitionSize);
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "1"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "1", "10"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "2",  "26", "267"), numResults));
-    return res;
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1", "10"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "2",  "26", "267"), numResults));
+    return getFacetSearchParams(facetRequests, getFacetIndexingParams(partitionSize));
   }
 
   @Override
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java
index 3ab7905..97671af 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java
@@ -2,6 +2,8 @@ package org.apache.lucene.facet.search;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -10,8 +12,8 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
 import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -49,22 +51,18 @@ import org.junit.Test;
 
 public class DrillDownTest extends LuceneTestCase {
   
-  private FacetSearchParams defaultParams = new FacetSearchParams();
-  private FacetSearchParams nonDefaultParams;
+  private FacetIndexingParams defaultParams = FacetIndexingParams.ALL_PARENTS;
+  private PerDimensionIndexingParams nonDefaultParams;
   private static IndexReader reader;
   private static DirectoryTaxonomyReader taxo;
   private static Directory dir;
   private static Directory taxoDir;
   
   public DrillDownTest() {
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    CategoryListParams aClParams = new CategoryListParams(new Term("testing_facets_a", "a"));
-    CategoryListParams bClParams = new CategoryListParams(new Term("testing_facets_b", "b"));
-    
-    iParams.addCategoryListParams(new CategoryPath("a"), aClParams);
-    iParams.addCategoryListParams(new CategoryPath("b"), bClParams);
-    
-    nonDefaultParams = new FacetSearchParams(iParams);
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("a"), new CategoryListParams(new Term("testing_facets_a", "a")));
+    paramsMap.put(new CategoryPath("b"), new CategoryListParams(new Term("testing_facets_b", "b")));
+    nonDefaultParams = new PerDimensionIndexingParams(paramsMap);
   }
 
   @BeforeClass
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java
index ce28454..08b48aa 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java
@@ -1,6 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
@@ -16,6 +17,7 @@ import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.cache.CategoryListCache;
 import org.apache.lucene.facet.search.cache.CategoryListData;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -74,22 +76,29 @@ public class TestCategoryListCache extends FacetTestBase {
   
   private void doTest(boolean withCache, boolean plantWrongData) throws Exception {
     Map<CategoryPath,Integer> truth = facetCountsTruth();
-    CategoryPath cp = (CategoryPath) truth.keySet().toArray()[0]; // any category path will do for this test 
-    CountFacetRequest frq = new CountFacetRequest(cp, 10);
-    FacetSearchParams sParams = getFacetedSearchParams();
-    sParams.addFacetRequest(frq);
+    CategoryPath cp = (CategoryPath) truth.keySet().toArray()[0]; // any category path will do for this test
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
+    final CategoryListCache clCache;
     if (withCache) {
       //let's use a cached cl data
-      FacetIndexingParams iparams = sParams.getFacetIndexingParams();
       CategoryListParams clp = new CategoryListParams(); // default term ok as only single list
-      CategoryListCache clCache = new CategoryListCache();
-      clCache.loadAndRegister(clp, indexReader, taxoReader, iparams);
+      clCache = new CategoryListCache();
+      clCache.loadAndRegister(clp, indexReader, taxoReader, iParams);
       if (plantWrongData) {
         // let's mess up the cached data and then expect a wrong result...
         messCachedData(clCache, clp);
       }
-      sParams.setClCache(clCache);
+    } else {
+      clCache = null;
     }
+    List<FacetRequest> req = new ArrayList<FacetRequest>();
+    req.add(new CountFacetRequest(cp, 10));
+    final FacetSearchParams sParams = new FacetSearchParams(req, iParams) {
+      @Override
+      public CategoryListCache getCategoryListCache() {
+        return clCache;
+      }
+    };
     FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader);
     searcher.search(new MatchAllDocsQuery(), fc);
     List<FacetResult> res = fc.getFacetResults();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
index 9adfea0..5ec042c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
@@ -84,12 +84,10 @@ public class TestDemoFacets extends LuceneTestCase {
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);
     taxoWriter.close();
 
-    // Holds all configuration for a facet request:
-    FacetSearchParams fsp = new FacetSearchParams();
-
     // Count both "Publish Date" and "Author" dimensions:
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Publish Date"), 10));
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
+        new CountFacetRequest(new CategoryPath("Author"), 10));
 
     // Aggregatses the facet counts:
     FacetsCollector c = new FacetsCollector(fsp, searcher.getIndexReader(), taxoReader);
@@ -110,9 +108,8 @@ public class TestDemoFacets extends LuceneTestCase {
 
     
     // Now user drills down on Publish Date/2010:
-    fsp = new FacetSearchParams();
+    fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
     Query q2 = DrillDown.query(fsp, new MatchAllDocsQuery(), new CategoryPath("Publish Date/2010", '/'));
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
     c = new FacetsCollector(fsp, searcher.getIndexReader(), taxoReader);
     searcher.search(q2, c);
     results = c.getFacetResults();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java
index f3071bc..b300550 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java
@@ -123,18 +123,15 @@ public class TestFacetsAccumulatorWithComplement extends FacetTestBase {
     
   }
   
-  @Override
-  protected FacetSearchParams getFacetedSearchParams() {
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
-    return res;
+  private FacetSearchParams getFacetSearchParams() {
+    return new FacetSearchParams(new CountFacetRequest(new CategoryPath("root","a"), 10));
   }
   
   /** compute facets with certain facet requests and docs */
   private List<FacetResult> findFacets(ScoredDocIDs sDocids, boolean withComplement) throws IOException {
     
     FacetsAccumulator fAccumulator = 
-      new StandardFacetsAccumulator(getFacetedSearchParams(), indexReader, taxoReader);
+      new StandardFacetsAccumulator(getFacetSearchParams(), indexReader, taxoReader);
     
     fAccumulator.setComplementThreshold(
         withComplement ? 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
index 8004f3e..b1123b9 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
@@ -67,8 +67,7 @@ public class TestFacetsCollector extends LuceneTestCase {
     taxonomyWriter.close();
     iw.close();
     
-    FacetSearchParams sParams = new FacetSearchParams();
-    sParams.addFacetRequest(new ScoreFacetRequest(new CategoryPath("a"), 10));
+    FacetSearchParams sParams = new FacetSearchParams(new ScoreFacetRequest(new CategoryPath("a"), 10));
     
     DirectoryReader r = DirectoryReader.open(indexDir);
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
index cf7e54c..12a054c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
@@ -1,8 +1,12 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -11,6 +15,7 @@ import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.results.FacetResult;
@@ -70,7 +75,7 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
     /**
      * Configure with no custom counting lists
      */
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
 
     seedIndex(iw, tw, iParams);
 
@@ -109,9 +114,9 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Author"),
-        new CategoryListParams(new Term("$author", "Authors")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(
+        Collections.singletonMap(new CategoryPath("Author"),
+            new CategoryListParams(new Term("$author", "Authors"))));
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -148,11 +153,10 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$music", "Bands")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$music", "Composers")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "Bands")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "Composers")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -195,11 +199,10 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1], OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$bands", "Bands")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$composers", "Composers")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$bands", "Bands")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$composers", "Composers")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -236,13 +239,11 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$music", "music")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$music", "music")));
-    iParams.addCategoryListParams(new CategoryPath("Author"),
-        new CategoryListParams(new Term("$literature", "Authors")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "music")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "music")));
+    paramsMap.put(new CategoryPath("Author"), new CategoryListParams(new Term("$literature", "Authors")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
 
     seedIndex(iw, tw, iParams);
 
@@ -329,20 +330,21 @@ public class TestMultipleCategoryLists extends LuceneTestCase {
                                         IndexSearcher searcher) throws IOException {
     // step 1: collect matching documents into a collector
     Query q = new MatchAllDocsQuery();
-    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10,
-        true);
+    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
-    // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Band"), 10));
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Band"), 10));
     CountFacetRequest bandDepth = new CountFacetRequest(new CategoryPath("Band"), 10);
     bandDepth.setDepth(2);
     // makes it easier to check the results in the test.
     bandDepth.setResultMode(ResultMode.GLOBAL_FLAT);
-    facetSearchParams.addFacetRequest(bandDepth);
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Band", "Rock & Pop"), 10));
+    facetRequests.add(bandDepth);
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Author"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Band", "Rock & Pop"), 10));
+
+    // Faceted search parameters indicate which facets are we interested in
+    FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
+    
 
     // perform documents search and facets accumulation
     FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, ir, tr);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java
index 730ccc5..36066a8 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java
@@ -80,7 +80,7 @@ public class TestScoredDocIdCollector extends FacetTestBase {
     }
 
     // verify by facet values
-    List<FacetResult> countRes = findFacets(scoredDocIDs, getFacetedSearchParams());
+    List<FacetResult> countRes = findFacets(scoredDocIDs, getFacetSearchParams());
     List<FacetResult> scoreRes = findFacets(scoredDocIDs, sumScoreSearchParams());
 
     assertEquals("Wrong number of facet count results!", 1, countRes.size());
@@ -160,16 +160,11 @@ public class TestScoredDocIdCollector extends FacetTestBase {
   /* use a scoring aggregator */
   private FacetSearchParams sumScoreSearchParams() {
     // this will use default faceted indexing params, not altering anything about indexing
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new ScoreFacetRequest(new CategoryPath("root", "a"), 10));
-    return res;
+    return new FacetSearchParams(new ScoreFacetRequest(new CategoryPath("root", "a"), 10));
   }
 
-  @Override
-  protected FacetSearchParams getFacetedSearchParams() {
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
-    return res;
+  private FacetSearchParams getFacetSearchParams() {
+    return new FacetSearchParams(new CountFacetRequest(new CategoryPath("root","a"), 10));
   }
 
 }
\ No newline at end of file
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
index dd19c67..1209dd9 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
@@ -8,22 +8,12 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
+import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -31,6 +21,16 @@ import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -69,9 +69,9 @@ public class TestTopKInEachNodeResultHandler extends LuceneTestCase {
       }
       
       final int pSize = partitionSize;
-      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+      FacetIndexingParams iParams = new FacetIndexingParams() {
         @Override
-        protected int fixedPartitionSize() {
+        public int getPartitionSize() {
           return pSize;
         }
       };
@@ -153,17 +153,18 @@ public class TestTopKInEachNodeResultHandler extends LuceneTestCase {
       cfrb20.setDepth(0);
       cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-      facetSearchParams.addFacetRequest(cfra23);
-      facetSearchParams.addFacetRequest(cfra22);
-      facetSearchParams.addFacetRequest(cfra21);
-      facetSearchParams.addFacetRequest(cfrb23);
-      facetSearchParams.addFacetRequest(cfrb22);
-      facetSearchParams.addFacetRequest(cfrb21);
-      facetSearchParams.addFacetRequest(doctor);
-      facetSearchParams.addFacetRequest(cfrb20);
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      facetRequests.add(cfra23);
+      facetRequests.add(cfra22);
+      facetRequests.add(cfra21);
+      facetRequests.add(cfrb23);
+      facetRequests.add(cfrb22);
+      facetRequests.add(cfrb21);
+      facetRequests.add(doctor);
+      facetRequests.add(cfrb20);
+      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
       
-      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams,tr));
+      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));
       FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);
       fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);
       long start = System.currentTimeMillis();
@@ -318,8 +319,8 @@ public class TestTopKInEachNodeResultHandler extends LuceneTestCase {
 
   }
 
-  private void prvt_add(DefaultFacetIndexingParams iParams, RandomIndexWriter iw,
-                    TaxonomyWriter tw, String... strings) throws IOException {
+  private void prvt_add(FacetIndexingParams iParams, RandomIndexWriter iw,
+      TaxonomyWriter tw, String... strings) throws IOException {
     ArrayList<CategoryPath> cps = new ArrayList<CategoryPath>();
     CategoryPath cp = new CategoryPath(strings);
     cps.add(cp);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
index b84c245..96414b4 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
@@ -1,19 +1,20 @@
 package org.apache.lucene.facet.search;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.junit.Test;
-
 import org.apache.lucene.facet.search.params.CountFacetRequest;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
+import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -74,18 +75,19 @@ public class TestTopKResultsHandler extends BaseTestTopK {
     for (int partitionSize : partitionSizes) {
       initIndex(partitionSize);
 
-      // do different facet counts and compare to control
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a"), 100));
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a"), 100));
       CountFacetRequest cfra = new CountFacetRequest(new CategoryPath("a"), 100);
       cfra.setDepth(3);
       // makes it easier to check the results in the test.
       cfra.setResultMode(ResultMode.GLOBAL_FLAT);
-      sParams.addFacetRequest(cfra);
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b"), 100));
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b", "1"), 100));
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "c"), 100));
+      facetRequests.add(cfra);
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b"), 100));
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b", "1"), 100));
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "c"), 100));
+      
+      // do different facet counts and compare to control
+      FacetSearchParams sParams = getFacetSearchParams(facetRequests, getFacetIndexingParams(partitionSize));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader) {
         @Override
@@ -157,8 +159,8 @@ public class TestTopKResultsHandler extends BaseTestTopK {
 
       // do different facet counts and compare to control
       CategoryPath path = new CategoryPath("a", "b");
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      sParams.addFacetRequest(new CountFacetRequest(path, Integer.MAX_VALUE));
+      FacetSearchParams sParams = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize), new CountFacetRequest(path, Integer.MAX_VALUE));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader) {
         @Override
@@ -183,8 +185,8 @@ public class TestTopKResultsHandler extends BaseTestTopK {
       assertEquals(path + " should only have 4 desendants", 4, res.getNumValidDescendants());
 
       // As a control base results, ask for top-1000 results
-      FacetSearchParams sParams2 = getFacetedSearchParams(partitionSize);
-      sParams2.addFacetRequest(new CountFacetRequest(path, Integer.MAX_VALUE));
+      FacetSearchParams sParams2 = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize), new CountFacetRequest(path, Integer.MAX_VALUE));
 
       FacetsCollector fc2 = new FacetsCollector(sParams2, indexReader, taxoReader) {
         @Override
@@ -220,8 +222,9 @@ public class TestTopKResultsHandler extends BaseTestTopK {
       initIndex(partitionSize);
 
       CategoryPath path = new CategoryPath("Miau Hattulla");
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      sParams.addFacetRequest(new CountFacetRequest(path, 10));
+      FacetSearchParams sParams = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize),
+          new CountFacetRequest(path, 10));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader);
       
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java
index 5c2b77b..bc4922f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java
@@ -4,17 +4,16 @@ import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
 
+import org.apache.lucene.facet.FacetTestUtils;
+import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
+import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
 import org.junit.Test;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.FacetTestUtils;
-import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
-import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -56,9 +55,9 @@ public class TestTotalFacetCounts extends LuceneTestCase {
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils
     .createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+    FacetIndexingParams iParams = new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return partitionSize;
       }
     };
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java
index 35788bb..10037cf 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java
@@ -8,16 +8,6 @@ import java.util.List;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.FacetTestUtils;
 import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
 import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
@@ -26,7 +16,6 @@ import org.apache.lucene.facet.example.TestMultiCLExample;
 import org.apache.lucene.facet.example.multiCL.MultiCLIndexer;
 import org.apache.lucene.facet.example.multiCL.MultiCLSearcher;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.TotalFacetCounts.CreationType;
 import org.apache.lucene.facet.search.results.FacetResult;
@@ -36,9 +25,18 @@ import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.SlowRAMDirectory;
 import org.apache.lucene.util._TestUtil;
+import org.junit.Before;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -196,7 +194,7 @@ public class TestTotalFacetCountsCache extends LuceneTestCase {
     // it references a different TFC cache. This will still result
     // in valid results, but will only search one of the category lists
     // instead of all of them.
-    multis[numThreads - 1] = new Multi(slowIndexReader, slowTaxoReader, new DefaultFacetIndexingParams());
+    multis[numThreads - 1] = new Multi(slowIndexReader, slowTaxoReader, FacetIndexingParams.ALL_PARENTS);
 
     // Gentleman, start your engines
     for (Multi m : multis) {
@@ -252,7 +250,7 @@ public class TestTotalFacetCountsCache extends LuceneTestCase {
 
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
 
     // Add a facet to the index
     addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, "a", "b");
@@ -347,11 +345,10 @@ public class TestTotalFacetCountsCache extends LuceneTestCase {
     // Create temporary RAMDirectories
     Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);
     // Create our index/taxonomy writers
-    IndexTaxonomyWriterPair[] writers = FacetTestUtils
-    .createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
+    FacetIndexingParams iParams = new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return 2;
       }
     };
@@ -403,7 +400,7 @@ public class TestTotalFacetCountsCache extends LuceneTestCase {
     IndexWriter w = new IndexWriter(indexDir, new IndexWriterConfig(
         TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
     DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
     // Add documents and facets
     for (int i = 0; i < 1000; i++) {
       addFacets(iParams, w, tw, "facet", Integer.toString(i));
@@ -454,7 +451,7 @@ public class TestTotalFacetCountsCache extends LuceneTestCase {
     Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(2);
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
 
     // Add a facet to the index
     addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, "a", "b");
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java
index 0115e74..dbe5761 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java
@@ -2,17 +2,6 @@ package org.apache.lucene.facet.search.association;
 
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.store.Directory;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
@@ -20,7 +9,7 @@ import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
 import org.apache.lucene.facet.enhancements.association.AssociationEnhancement;
 import org.apache.lucene.facet.enhancements.association.AssociationFloatProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationIntProperty;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
+import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.index.CategoryContainer;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
@@ -31,6 +20,16 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -72,8 +71,7 @@ public class AssociationsFacetRequestTest extends LuceneTestCase {
     TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
     
     EnhancementsDocumentBuilder builder = new EnhancementsDocumentBuilder(
-        taxoWriter, new DefaultEnhancementsIndexingParams(
-            new AssociationEnhancement()));
+        taxoWriter, new EnhancementsIndexingParams(new AssociationEnhancement()));
     
     // index documents, 50% have only 'b' and all have 'a'
     for (int i = 0; i < 100; i++) {
@@ -109,9 +107,9 @@ public class AssociationsFacetRequestTest extends LuceneTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(aint, 10));
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(bint, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationIntSumFacetRequest(aint, 10),
+        new AssociationIntSumFacetRequest(bint, 10));
     
     Query q = new MatchAllDocsQuery();
 
@@ -134,9 +132,9 @@ public class AssociationsFacetRequestTest extends LuceneTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(afloat, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(bfloat, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationFloatSumFacetRequest(afloat, 10),
+        new AssociationFloatSumFacetRequest(bfloat, 10));
     
     Query q = new MatchAllDocsQuery();
 
@@ -162,11 +160,11 @@ public class AssociationsFacetRequestTest extends LuceneTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(aint, 10));
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(bint, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(afloat, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(bfloat, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationIntSumFacetRequest(aint, 10),
+        new AssociationIntSumFacetRequest(bint, 10),
+        new AssociationFloatSumFacetRequest(afloat, 10),
+        new AssociationFloatSumFacetRequest(bfloat, 10));
     
     Query q = new MatchAllDocsQuery();
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java
index c6e70e4..33bc116 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java
@@ -1,16 +1,15 @@
 package org.apache.lucene.facet.search.params;
 
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -32,47 +31,32 @@ import org.apache.lucene.facet.util.PartitionsUtils;
 public class FacetSearchParamsTest extends LuceneTestCase {
 
   @Test
-  public void testDefaultSettings() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
-    assertEquals("unexpected default facet indexing params class", DefaultFacetIndexingParams.class.getName(), fsp.getFacetIndexingParams().getClass().getName());
-    assertEquals("no facet requests should be added by default", 0, fsp.getFacetRequests().size());
-    Directory dir = newDirectory();
-    new DirectoryTaxonomyWriter(dir).close();
-    TaxonomyReader tr = new DirectoryTaxonomyReader(dir);
-    assertEquals("unexpected partition offset for 0 categories", 1, PartitionsUtils.partitionOffset(fsp, 1, tr));
-    assertEquals("unexpected partition size for 0 categories", 1, PartitionsUtils.partitionSize(fsp,tr));
-    tr.close();
-    dir.close();
-  }
-  
-  @Test
   public void testAddFacetRequest() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b"), 1));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("a", "b"), 1));
     assertEquals("expected 1 facet request", 1, fsp.getFacetRequests().size());
   }
   
   @Test
   public void testPartitionSizeWithCategories() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
     Directory dir = newDirectory();
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dir);
     tw.addCategory(new CategoryPath("a"));
     tw.commit();
     tw.close();
     TaxonomyReader tr = new DirectoryTaxonomyReader(dir);
-    assertEquals("unexpected partition offset for 1 categories", 2, PartitionsUtils.partitionOffset(fsp, 1, tr));
-    assertEquals("unexpected partition size for 1 categories", 2, PartitionsUtils.partitionSize(fsp,tr));
+    assertEquals("unexpected partition offset for 1 categories", 2,
+        PartitionsUtils.partitionOffset(FacetIndexingParams.ALL_PARENTS, 1, tr));
+    assertEquals("unexpected partition size for 1 categories", 2,
+        PartitionsUtils.partitionSize(FacetIndexingParams.ALL_PARENTS,tr));
     tr.close();
     dir.close();
   }
   
   @Test
   public void testSearchParamsWithNullRequest() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
     try {
-      fsp.addFacetRequest(null);
-      fail("FacetSearchParams should throw IllegalArgumentException when trying to add a null FacetRequest");
+      assertNull(new FacetSearchParams());
+      fail("FacetSearchParams should throw IllegalArgumentException when not adding requests");
     } catch (IllegalArgumentException e) {
     }
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java
index d278d2e..756f453 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java
@@ -1,22 +1,15 @@
 package org.apache.lucene.facet.search.params;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
 import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.CategoryListIterator;
 import org.apache.lucene.facet.search.FacetArrays;
@@ -35,6 +28,12 @@ import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.ScoredDocIdsUtils;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -87,7 +86,7 @@ public class MultiIteratorsPerCLParamsTest extends LuceneTestCase {
     // Create a CLP which generates different CLIs according to the
     // FacetRequest's dimension
     CategoryListParams clp = new CategoryListParams();
-    FacetIndexingParams iParams = new DefaultFacetIndexingParams(clp);
+    FacetIndexingParams iParams = new FacetIndexingParams(clp);
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
     populateIndex(iParams, indexDir, taxoDir);
@@ -135,16 +134,19 @@ public class MultiIteratorsPerCLParamsTest extends LuceneTestCase {
   }
 
   private void validateFacetedSearch(FacetIndexingParams iParams,
-      TaxonomyReader taxo, IndexReader reader,  CategoryListCache clCache, ScoredDocIDs allDocs,
-      String[] dimension, int[] expectedValue,
-      int[] expectedNumDescendants)
-      throws IOException {
-    FacetSearchParams sParams = new FacetSearchParams(iParams);
-    sParams.setClCache(clCache);
+      TaxonomyReader taxo, IndexReader reader, final CategoryListCache clCache,
+      ScoredDocIDs allDocs, String[] dimension, int[] expectedValue,
+      int[] expectedNumDescendants) throws IOException {
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
     for (String dim : dimension) {
-      sParams.addFacetRequest(new PerDimCountFacetRequest(
-          new CategoryPath(dim), 10));
+      facetRequests.add(new PerDimCountFacetRequest(new CategoryPath(dim), 10));
     }
+    FacetSearchParams sParams = new FacetSearchParams(facetRequests, iParams) {
+      @Override
+      public CategoryListCache getCategoryListCache() {
+        return clCache;
+      }
+    };
     FacetsAccumulator acc = new StandardFacetsAccumulator(sParams, reader, taxo);
     
     // no use to test this with complement since at that mode all facets are taken
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java
index e82e467..cb30e1c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java
@@ -63,14 +63,12 @@ public class OversampleWithDepthTest extends LuceneTestCase {
     DirectoryReader r = DirectoryReader.open(indexDir);
     TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
     
-    FacetSearchParams fsp = new FacetSearchParams();
-    
     CountFacetRequest facetRequest = new CountFacetRequest(new CategoryPath("root"), 10);
-    
     // Setting the depth to '2', should potentially get all categories
     facetRequest.setDepth(2);
     facetRequest.setResultMode(ResultMode.PER_NODE_IN_TREE);
-    fsp.addFacetRequest(facetRequest);
+
+    FacetSearchParams fsp = new FacetSearchParams(facetRequest);
     
     // Craft sampling params to enforce sampling
     final SamplingParams params = new SamplingParams();

