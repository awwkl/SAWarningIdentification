GitDiffStart: afee9af13f2627c1e9fb3498d826d7a227c60ea7 | Fri Sep 26 02:22:18 2014 +0000
diff --git a/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java b/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
new file mode 100644
index 0000000..a565e26
--- /dev/null
+++ b/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
@@ -0,0 +1,410 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.CompoundFileDirectory;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.BitUtil;
+import org.apache.lucene.util.MutableBits;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+ *  java.util.BitSet, but also includes the following:
+ *  <ul>
+ *  <li>a count() method, which efficiently computes the number of one bits;</li>
+ *  <li>optimized read from and write to disk;</li>
+ *  <li>inlinable get() method;</li>
+ *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+ *  </ul>
+ *
+ *  @lucene.internal
+ */
+// pkg-private: if this thing is generally useful then it can go back in .util,
+// but the serialization must be here underneath the codec.
+final class BitVector implements Cloneable, MutableBits {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+  private int version;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector(int n) {
+    size = n;
+    bits = new byte[getNumBytes(size)];
+    count = 0;
+  }
+
+  BitVector(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  private int getNumBytes(int size) {
+    int bytesLength = size >>> 3;
+    if ((size & 7) != 0) {
+      bytesLength++;
+    }
+    return bytesLength;
+  }
+  
+  @Override
+  public BitVector clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector clone = new BitVector(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1) {
+        count++;
+        assert count <= size;
+      }
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  @Override
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  public final boolean getAndClear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) == 0) {
+      return false;
+    } else {
+      bits[pos] &= ~flag;
+      if (count != -1) {
+        count--;
+        assert count >= 0;
+      }
+      return true;
+    }
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  @Override
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  @Override
+  public int length() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++) {
+        c += BitUtil.bitCount(bits[i]);  // sum bits per byte
+      }
+      count = c;
+    }
+    assert count <= size: "count=" + count + " size=" + size;
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++) {
+      c += BitUtil.bitCount(bits[i]);  // sum bits per byte
+    }
+    return c;
+  }
+
+
+
+  private static String CODEC = "BitVector";
+
+  // Version before version tracking was added:
+  public final static int VERSION_PRE = -1;
+
+  // First version:
+  public final static int VERSION_START = 0;
+
+  // Changed DGaps to encode gaps between cleared bits, not
+  // set:
+  public final static int VERSION_DGAPS_CLEARED = 1;
+  
+  // added checksum
+  public final static int VERSION_CHECKSUM = 2;
+
+  // Increment version to change it:
+  public final static int VERSION_CURRENT = VERSION_CHECKSUM;
+
+  public int getVersion() {
+    return version;
+  }
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector(Directory, String, IOContext)}.  */
+  public final void write(Directory d, String name, IOContext context) throws IOException {
+    assert !(d instanceof CompoundFileDirectory);
+    try (IndexOutput output = d.createOutput(name, context)) {
+      output.writeInt(-2);
+      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
+      if (isSparse()) { 
+        // sparse bit-set more efficiently saved as d-gaps.
+        writeClearedDgaps(output);
+      } else {
+        writeBits(output);
+      }
+      CodecUtil.writeFooter(output);
+      assert verifyCount();
+    }
+  }
+
+  /** Invert all bits */
+  public void invertAll() {
+    if (count != -1) {
+      count = size - count;
+    }
+    if (bits.length > 0) {
+      for(int idx=0;idx<bits.length;idx++) {
+        bits[idx] = (byte) (~bits[idx]);
+      }
+      clearUnusedBits();
+    }
+  }
+
+  private void clearUnusedBits() {
+    // Take care not to invert the "unused" bits in the
+    // last byte:
+    if (bits.length > 0) {
+      final int lastNBits = size & 7;
+      if (lastNBits != 0) {
+        final int mask = (1 << lastNBits)-1;
+        bits[bits.length-1] &= mask;
+      }
+    }
+  }
+
+  /** Set all bits */
+  public void setAll() {
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    count = size;
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeClearedDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int numCleared = size()-count();
+    for (int i=0; i<bits.length && numCleared>0; i++) {
+      if (bits[i] != (byte) 0xff) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        numCleared -= (8-BitUtil.bitCount(bits[i]));
+        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+
+    final int clearedCount = size() - count();
+    if (clearedCount == 0) {
+      return true;
+    }
+
+    final int avgGapLength = bits.length / clearedCount;
+
+    // expected number of bytes for vInt encoding of each gap
+    final int expectedDGapBytes;
+    if (avgGapLength <= (1<< 7)) {
+      expectedDGapBytes = 1;
+    } else if (avgGapLength <= (1<<14)) {
+      expectedDGapBytes = 2;
+    } else if (avgGapLength <= (1<<21)) {
+      expectedDGapBytes = 3;
+    } else if (avgGapLength <= (1<<28)) {
+      expectedDGapBytes = 4;
+    } else {
+      expectedDGapBytes = 5;
+    }
+
+    // +1 because we write the byte itself that contains the
+    // set bit
+    final int bytesPerSetBit = expectedDGapBytes + 1;
+    
+    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
+    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
+
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    final long factor = 10;  
+    return factor * expectedBits < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector(Directory d, String name, IOContext context) throws IOException {
+    try (ChecksumIndexInput input = d.openChecksumInput(name, context)) {
+      final int firstInt = input.readInt();
+
+      if (firstInt == -2) {
+        // New format, with full header & version:
+        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
+        size = input.readInt();
+      } else {
+        // we started writing full header well before 4.0
+        throw new IndexFormatTooOldException(input.toString(), Integer.toString(firstInt));
+      }
+      if (size == -1) {
+        if (version >= VERSION_DGAPS_CLEARED) {
+          readClearedDgaps(input);
+        } else {
+          readSetDgaps(input);
+        }
+      } else {
+        readBits(input);
+      }
+
+      if (version < VERSION_DGAPS_CLEARED) {
+        invertAll();
+      }
+
+      if (version >= VERSION_CHECKSUM) {
+        CodecUtil.checkFooter(input);
+      } else {
+        CodecUtil.checkEOF(input);
+      }
+      assert verifyCount();
+    }
+  }
+
+  // asserts only
+  private boolean verifyCount() {
+    assert count != -1;
+    final int countSav = count;
+    count = -1;
+    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
+    return true;
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readSetDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BitUtil.bitCount(bits[last]);
+      assert n >= 0;
+    }          
+  }
+
+  /** read as a d-gaps cleared bits list */ 
+  private void readClearedDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    int last=0;
+    int numCleared = size()-count();
+    while (numCleared>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      numCleared -= 8-BitUtil.bitCount(bits[last]);
+      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
+    }
+  }
+}
diff --git a/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java b/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
new file mode 100644
index 0000000..64dc854
--- /dev/null
+++ b/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
@@ -0,0 +1,120 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentCommitInfo;
+import org.apache.lucene.store.DataOutput; // javadocs
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.MutableBits;
+
+/**
+ * Lucene 4.0 Live Documents Format.
+ * <p>
+ * <p>The .del file is optional, and only exists when a segment contains
+ * deletions.</p>
+ * <p>Although per-segment, this file is maintained exterior to compound segment
+ * files.</p>
+ * <p>Deletions (.del) --&gt; Format,Header,ByteCount,BitCount, Bits | DGaps (depending
+ * on Format)</p>
+ * <ul>
+ *   <li>Format,ByteSize,BitCount --&gt; {@link DataOutput#writeInt Uint32}</li>
+ *   <li>Bits --&gt; &lt;{@link DataOutput#writeByte Byte}&gt; <sup>ByteCount</sup></li>
+ *   <li>DGaps --&gt; &lt;DGap,NonOnesByte&gt; <sup>NonzeroBytesCount</sup></li>
+ *   <li>DGap --&gt; {@link DataOutput#writeVInt VInt}</li>
+ *   <li>NonOnesByte --&gt; {@link DataOutput#writeByte Byte}</li>
+ *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
+ * </ul>
+ * <p>Format is 1: indicates cleared DGaps.</p>
+ * <p>ByteCount indicates the number of bytes in Bits. It is typically
+ * (SegSize/8)+1.</p>
+ * <p>BitCount indicates the number of bits that are currently set in Bits.</p>
+ * <p>Bits contains one bit for each document indexed. When the bit corresponding
+ * to a document number is cleared, that document is marked as deleted. Bit ordering
+ * is from least to most significant. Thus, if Bits contains two bytes, 0x00 and
+ * 0x02, then document 9 is marked as alive (not deleted).</p>
+ * <p>DGaps represents sparse bit-vectors more efficiently than Bits. It is made
+ * of DGaps on indexes of nonOnes bytes in Bits, and the nonOnes bytes themselves.
+ * The number of nonOnes bytes in Bits (NonOnesBytesCount) is not stored.</p>
+ * <p>For example, if there are 8000 bits and only bits 10,12,32 are cleared, DGaps
+ * would be used:</p>
+ * <p>(VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1</p>
+ */
+public class Lucene40LiveDocsFormat extends LiveDocsFormat {
+
+  /** Extension of deletes */
+  static final String DELETES_EXTENSION = "del";
+
+  /** Sole constructor. */
+  public Lucene40LiveDocsFormat() {
+  }
+  
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    BitVector bitVector = new BitVector(size);
+    bitVector.invertAll();
+    return bitVector;
+  }
+
+  @Override
+  public MutableBits newLiveDocs(Bits existing) throws IOException {
+    final BitVector liveDocs = (BitVector) existing;
+    return liveDocs.clone();
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
+    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen());
+    final BitVector liveDocs = new BitVector(dir, filename, context);
+    if (liveDocs.length() != info.info.getDocCount()) {
+      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
+    }
+    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount()) {
+      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount(), filename);
+    }
+    return liveDocs;
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
+    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getNextDelGen());
+    final BitVector liveDocs = (BitVector) bits;
+    if (liveDocs.length() != info.info.getDocCount()) {
+      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
+    }
+    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount() - newDelCount) {
+      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount() + " newDelCount=" + newDelCount, filename);
+    }
+    liveDocs.write(dir, filename, context);
+  }
+
+  @Override
+  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
+    if (info.hasDeletions()) {
+      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen()));
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java b/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
index 40e9214..d46beed 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
@@ -80,8 +80,7 @@ public final class CodecUtil {
    * @throws IOException If there is an I/O error writing to the underlying medium.
    * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length
    */
-  public static void writeHeader(DataOutput out, String codec, int version)
-    throws IOException {
+  public static void writeHeader(DataOutput out, String codec, int version) throws IOException {
     BytesRef bytes = new BytesRef(codec);
     if (bytes.length != codec.length() || bytes.length >= 128) {
       throw new IllegalArgumentException("codec must be simple ASCII, less than 128 characters in length [got " + codec + "]");
@@ -90,6 +89,38 @@ public final class CodecUtil {
     out.writeString(codec);
     out.writeInt(version);
   }
+  
+  /**
+   * Writes a codec header for a per-segment, which records both a string to
+   * identify the file, a version number, and the unique ID of the segment. 
+   * This header can be parsed and validated with 
+   * {@link #checkSegmentHeader(DataInput, String, int, int, String) checkSegmentHeader()}.
+   * <p>
+   * CodecSegmentHeader --&gt; CodecHeader,SegmentID
+   * <ul>
+   *    <li>CodecHeader --&gt; {@link #writeHeader}
+   *    <li>SegmentID   --&gt; {@link DataOutput#writeString String}.
+   *        Unique identifier for the segment.
+   * </ul>
+   * <p>
+   * Note that the length of a segment header depends only upon the
+   * name of the codec, so this length can be computed at any time
+   * with {@link #headerLength(String)}.
+   * 
+   * @param out Output stream
+   * @param codec String to identify this file. It should be simple ASCII, 
+   *              less than 128 characters in length.
+   * @param segmentID Unique identifier for the segment
+   * @param version Version number
+   * @throws IOException If there is an I/O error writing to the underlying medium.
+   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length
+   */
+  // nocommit: fix javadocs, add segmentLength()
+  public static void writeSegmentHeader(DataOutput out, String codec, int version, String segmentID) throws IOException {
+    writeHeader(out, codec, version);
+    // nocommit: improve encoding of this ID
+    out.writeString(segmentID);
+  }
 
   /**
    * Computes the length of a codec header.
@@ -129,9 +160,7 @@ public final class CodecUtil {
    * @throws IOException If there is an I/O error reading from the underlying medium.
    * @see #writeHeader(DataOutput, String, int)
    */
-  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)
-    throws IOException {
-
+  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {
     // Safety to guard against reading a bogus string:
     final int actualHeader = in.readInt();
     if (actualHeader != CODEC_MAGIC) {
@@ -162,6 +191,46 @@ public final class CodecUtil {
   }
   
   /**
+   * Reads and validates a header previously written with 
+   * {@link #writeSegmentHeader(DataOutput, String, int, String)}.
+   * <p>
+   * When reading a file, supply the expected <code>codec</code>,
+   * expected version range (<code>minVersion to maxVersion</code>),
+   * and segment ID.
+   * 
+   * @param in Input stream, positioned at the point where the
+   *        header was previously written. Typically this is located
+   *        at the beginning of the file.
+   * @param codec The expected codec name.
+   * @param minVersion The minimum supported expected version number.
+   * @param maxVersion The maximum supported expected version number.
+   * @param segmentID The expected segment this file belongs to.
+   * @return The actual version found, when a valid header is found 
+   *         that matches <code>codec</code>, with an actual version 
+   *         where <code>minVersion <= actual <= maxVersion</code>, 
+   *         and matching <code>segmentID</code>
+   *         Otherwise an exception is thrown.
+   * @throws CorruptIndexException If the first four bytes are not
+   *         {@link #CODEC_MAGIC}, or if the actual codec found is
+   *         not <code>codec</code>, or if the <code>segmentID</code>
+   *         does not match.
+   * @throws IndexFormatTooOldException If the actual version is less 
+   *         than <code>minVersion</code>.
+   * @throws IndexFormatTooNewException If the actual version is greater 
+   *         than <code>maxVersion</code>.
+   * @throws IOException If there is an I/O error reading from the underlying medium.
+   * @see #writeSegmentHeader(DataOutput, String, int, String)
+   */
+  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, String segmentID) throws IOException {
+    int version = checkHeader(in, codec, minVersion, maxVersion);
+    String id = in.readString();
+    if (!id.equals(segmentID)) {
+      throw new CorruptIndexException("file mismatch, expected segment id=" + segmentID + ", got=" + id, in);
+    }
+    return version;
+  }
+  
+  /**
    * Writes a codec footer, which records both a checksum
    * algorithm ID and a checksum. This footer can
    * be parsed and validated with 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
deleted file mode 100644
index a565e26..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
+++ /dev/null
@@ -1,410 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.index.IndexFormatTooOldException;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.CompoundFileDirectory;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BitUtil;
-import org.apache.lucene.util.MutableBits;
-
-/** Optimized implementation of a vector of bits.  This is more-or-less like
- *  java.util.BitSet, but also includes the following:
- *  <ul>
- *  <li>a count() method, which efficiently computes the number of one bits;</li>
- *  <li>optimized read from and write to disk;</li>
- *  <li>inlinable get() method;</li>
- *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
- *  </ul>
- *
- *  @lucene.internal
- */
-// pkg-private: if this thing is generally useful then it can go back in .util,
-// but the serialization must be here underneath the codec.
-final class BitVector implements Cloneable, MutableBits {
-
-  private byte[] bits;
-  private int size;
-  private int count;
-  private int version;
-
-  /** Constructs a vector capable of holding <code>n</code> bits. */
-  public BitVector(int n) {
-    size = n;
-    bits = new byte[getNumBytes(size)];
-    count = 0;
-  }
-
-  BitVector(byte[] bits, int size) {
-    this.bits = bits;
-    this.size = size;
-    count = -1;
-  }
-  
-  private int getNumBytes(int size) {
-    int bytesLength = size >>> 3;
-    if ((size & 7) != 0) {
-      bytesLength++;
-    }
-    return bytesLength;
-  }
-  
-  @Override
-  public BitVector clone() {
-    byte[] copyBits = new byte[bits.length];
-    System.arraycopy(bits, 0, copyBits, 0, bits.length);
-    BitVector clone = new BitVector(copyBits, size);
-    clone.count = count;
-    return clone;
-  }
-  
-  /** Sets the value of <code>bit</code> to one. */
-  public final void set(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    bits[bit >> 3] |= 1 << (bit & 7);
-    count = -1;
-  }
-
-  /** Sets the value of <code>bit</code> to true, and
-   *  returns true if bit was already set */
-  public final boolean getAndSet(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) != 0)
-      return true;
-    else {
-      bits[pos] = (byte) (v | flag);
-      if (count != -1) {
-        count++;
-        assert count <= size;
-      }
-      return false;
-    }
-  }
-
-  /** Sets the value of <code>bit</code> to zero. */
-  @Override
-  public final void clear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    bits[bit >> 3] &= ~(1 << (bit & 7));
-    count = -1;
-  }
-
-  public final boolean getAndClear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) == 0) {
-      return false;
-    } else {
-      bits[pos] &= ~flag;
-      if (count != -1) {
-        count--;
-        assert count >= 0;
-      }
-      return true;
-    }
-  }
-
-  /** Returns <code>true</code> if <code>bit</code> is one and
-    <code>false</code> if it is zero. */
-  @Override
-  public final boolean get(int bit) {
-    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
-    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
-  }
-
-  /** Returns the number of bits in this vector.  This is also one greater than
-    the number of the largest valid bit number. */
-  public final int size() {
-    return size;
-  }
-
-  @Override
-  public int length() {
-    return size;
-  }
-
-  /** Returns the total number of one bits in this vector.  This is efficiently
-    computed and cached, so that, if the vector is not changed, no
-    recomputation is done for repeated calls. */
-  public final int count() {
-    // if the vector has been modified
-    if (count == -1) {
-      int c = 0;
-      int end = bits.length;
-      for (int i = 0; i < end; i++) {
-        c += BitUtil.bitCount(bits[i]);  // sum bits per byte
-      }
-      count = c;
-    }
-    assert count <= size: "count=" + count + " size=" + size;
-    return count;
-  }
-
-  /** For testing */
-  public final int getRecomputedCount() {
-    int c = 0;
-    int end = bits.length;
-    for (int i = 0; i < end; i++) {
-      c += BitUtil.bitCount(bits[i]);  // sum bits per byte
-    }
-    return c;
-  }
-
-
-
-  private static String CODEC = "BitVector";
-
-  // Version before version tracking was added:
-  public final static int VERSION_PRE = -1;
-
-  // First version:
-  public final static int VERSION_START = 0;
-
-  // Changed DGaps to encode gaps between cleared bits, not
-  // set:
-  public final static int VERSION_DGAPS_CLEARED = 1;
-  
-  // added checksum
-  public final static int VERSION_CHECKSUM = 2;
-
-  // Increment version to change it:
-  public final static int VERSION_CURRENT = VERSION_CHECKSUM;
-
-  public int getVersion() {
-    return version;
-  }
-
-  /** Writes this vector to the file <code>name</code> in Directory
-    <code>d</code>, in a format that can be read by the constructor {@link
-    #BitVector(Directory, String, IOContext)}.  */
-  public final void write(Directory d, String name, IOContext context) throws IOException {
-    assert !(d instanceof CompoundFileDirectory);
-    try (IndexOutput output = d.createOutput(name, context)) {
-      output.writeInt(-2);
-      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
-      if (isSparse()) { 
-        // sparse bit-set more efficiently saved as d-gaps.
-        writeClearedDgaps(output);
-      } else {
-        writeBits(output);
-      }
-      CodecUtil.writeFooter(output);
-      assert verifyCount();
-    }
-  }
-
-  /** Invert all bits */
-  public void invertAll() {
-    if (count != -1) {
-      count = size - count;
-    }
-    if (bits.length > 0) {
-      for(int idx=0;idx<bits.length;idx++) {
-        bits[idx] = (byte) (~bits[idx]);
-      }
-      clearUnusedBits();
-    }
-  }
-
-  private void clearUnusedBits() {
-    // Take care not to invert the "unused" bits in the
-    // last byte:
-    if (bits.length > 0) {
-      final int lastNBits = size & 7;
-      if (lastNBits != 0) {
-        final int mask = (1 << lastNBits)-1;
-        bits[bits.length-1] &= mask;
-      }
-    }
-  }
-
-  /** Set all bits */
-  public void setAll() {
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    count = size;
-  }
-     
-  /** Write as a bit set */
-  private void writeBits(IndexOutput output) throws IOException {
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    output.writeBytes(bits, bits.length);
-  }
-  
-  /** Write as a d-gaps list */
-  private void writeClearedDgaps(IndexOutput output) throws IOException {
-    output.writeInt(-1);            // mark using d-gaps                         
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    int last=0;
-    int numCleared = size()-count();
-    for (int i=0; i<bits.length && numCleared>0; i++) {
-      if (bits[i] != (byte) 0xff) {
-        output.writeVInt(i-last);
-        output.writeByte(bits[i]);
-        last = i;
-        numCleared -= (8-BitUtil.bitCount(bits[i]));
-        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
-      }
-    }
-  }
-
-  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
-  private boolean isSparse() {
-
-    final int clearedCount = size() - count();
-    if (clearedCount == 0) {
-      return true;
-    }
-
-    final int avgGapLength = bits.length / clearedCount;
-
-    // expected number of bytes for vInt encoding of each gap
-    final int expectedDGapBytes;
-    if (avgGapLength <= (1<< 7)) {
-      expectedDGapBytes = 1;
-    } else if (avgGapLength <= (1<<14)) {
-      expectedDGapBytes = 2;
-    } else if (avgGapLength <= (1<<21)) {
-      expectedDGapBytes = 3;
-    } else if (avgGapLength <= (1<<28)) {
-      expectedDGapBytes = 4;
-    } else {
-      expectedDGapBytes = 5;
-    }
-
-    // +1 because we write the byte itself that contains the
-    // set bit
-    final int bytesPerSetBit = expectedDGapBytes + 1;
-    
-    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
-    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
-
-    // note: factor is for read/write of byte-arrays being faster than vints.  
-    final long factor = 10;  
-    return factor * expectedBits < size();
-  }
-
-  /** Constructs a bit vector from the file <code>name</code> in Directory
-    <code>d</code>, as written by the {@link #write} method.
-    */
-  public BitVector(Directory d, String name, IOContext context) throws IOException {
-    try (ChecksumIndexInput input = d.openChecksumInput(name, context)) {
-      final int firstInt = input.readInt();
-
-      if (firstInt == -2) {
-        // New format, with full header & version:
-        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
-        size = input.readInt();
-      } else {
-        // we started writing full header well before 4.0
-        throw new IndexFormatTooOldException(input.toString(), Integer.toString(firstInt));
-      }
-      if (size == -1) {
-        if (version >= VERSION_DGAPS_CLEARED) {
-          readClearedDgaps(input);
-        } else {
-          readSetDgaps(input);
-        }
-      } else {
-        readBits(input);
-      }
-
-      if (version < VERSION_DGAPS_CLEARED) {
-        invertAll();
-      }
-
-      if (version >= VERSION_CHECKSUM) {
-        CodecUtil.checkFooter(input);
-      } else {
-        CodecUtil.checkEOF(input);
-      }
-      assert verifyCount();
-    }
-  }
-
-  // asserts only
-  private boolean verifyCount() {
-    assert count != -1;
-    final int countSav = count;
-    count = -1;
-    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
-    return true;
-  }
-
-  /** Read as a bit set */
-  private void readBits(IndexInput input) throws IOException {
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    input.readBytes(bits, 0, bits.length);
-  }
-
-  /** read as a d-gaps list */ 
-  private void readSetDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    int last=0;
-    int n = count();
-    while (n>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      n -= BitUtil.bitCount(bits[last]);
-      assert n >= 0;
-    }          
-  }
-
-  /** read as a d-gaps cleared bits list */ 
-  private void readClearedDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    int last=0;
-    int numCleared = size()-count();
-    while (numCleared>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      numCleared -= 8-BitUtil.bitCount(bits[last]);
-      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
deleted file mode 100644
index 64dc854..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.LiveDocsFormat;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentCommitInfo;
-import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.MutableBits;
-
-/**
- * Lucene 4.0 Live Documents Format.
- * <p>
- * <p>The .del file is optional, and only exists when a segment contains
- * deletions.</p>
- * <p>Although per-segment, this file is maintained exterior to compound segment
- * files.</p>
- * <p>Deletions (.del) --&gt; Format,Header,ByteCount,BitCount, Bits | DGaps (depending
- * on Format)</p>
- * <ul>
- *   <li>Format,ByteSize,BitCount --&gt; {@link DataOutput#writeInt Uint32}</li>
- *   <li>Bits --&gt; &lt;{@link DataOutput#writeByte Byte}&gt; <sup>ByteCount</sup></li>
- *   <li>DGaps --&gt; &lt;DGap,NonOnesByte&gt; <sup>NonzeroBytesCount</sup></li>
- *   <li>DGap --&gt; {@link DataOutput#writeVInt VInt}</li>
- *   <li>NonOnesByte --&gt; {@link DataOutput#writeByte Byte}</li>
- *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
- * </ul>
- * <p>Format is 1: indicates cleared DGaps.</p>
- * <p>ByteCount indicates the number of bytes in Bits. It is typically
- * (SegSize/8)+1.</p>
- * <p>BitCount indicates the number of bits that are currently set in Bits.</p>
- * <p>Bits contains one bit for each document indexed. When the bit corresponding
- * to a document number is cleared, that document is marked as deleted. Bit ordering
- * is from least to most significant. Thus, if Bits contains two bytes, 0x00 and
- * 0x02, then document 9 is marked as alive (not deleted).</p>
- * <p>DGaps represents sparse bit-vectors more efficiently than Bits. It is made
- * of DGaps on indexes of nonOnes bytes in Bits, and the nonOnes bytes themselves.
- * The number of nonOnes bytes in Bits (NonOnesBytesCount) is not stored.</p>
- * <p>For example, if there are 8000 bits and only bits 10,12,32 are cleared, DGaps
- * would be used:</p>
- * <p>(VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1</p>
- */
-public class Lucene40LiveDocsFormat extends LiveDocsFormat {
-
-  /** Extension of deletes */
-  static final String DELETES_EXTENSION = "del";
-
-  /** Sole constructor. */
-  public Lucene40LiveDocsFormat() {
-  }
-  
-  @Override
-  public MutableBits newLiveDocs(int size) throws IOException {
-    BitVector bitVector = new BitVector(size);
-    bitVector.invertAll();
-    return bitVector;
-  }
-
-  @Override
-  public MutableBits newLiveDocs(Bits existing) throws IOException {
-    final BitVector liveDocs = (BitVector) existing;
-    return liveDocs.clone();
-  }
-
-  @Override
-  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
-    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen());
-    final BitVector liveDocs = new BitVector(dir, filename, context);
-    if (liveDocs.length() != info.info.getDocCount()) {
-      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
-    }
-    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount()) {
-      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount(), filename);
-    }
-    return liveDocs;
-  }
-
-  @Override
-  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
-    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getNextDelGen());
-    final BitVector liveDocs = (BitVector) bits;
-    if (liveDocs.length() != info.info.getDocCount()) {
-      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
-    }
-    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount() - newDelCount) {
-      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount() + " newDelCount=" + newDelCount, filename);
-    }
-    liveDocs.write(dir, filename, context);
-  }
-
-  @Override
-  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
-    if (info.hasDeletions()) {
-      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen()));
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
deleted file mode 100644
index 7959cc0..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Lucene 4.0 file format.
-</body>
-</html>
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java
index fdef7d6..f2c78a9 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java
@@ -27,7 +27,6 @@ import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
-import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene41.Lucene41StoredFieldsFormat;
 import org.apache.lucene.codecs.lucene42.Lucene42TermVectorsFormat;
 import org.apache.lucene.codecs.lucene49.Lucene49NormsFormat;
@@ -49,7 +48,7 @@ public class Lucene50Codec extends Codec {
   private final TermVectorsFormat vectorsFormat = new Lucene42TermVectorsFormat();
   private final FieldInfosFormat fieldInfosFormat = new Lucene50FieldInfosFormat();
   private final SegmentInfoFormat segmentInfosFormat = new Lucene50SegmentInfoFormat();
-  private final LiveDocsFormat liveDocsFormat = new Lucene40LiveDocsFormat();
+  private final LiveDocsFormat liveDocsFormat = new Lucene50LiveDocsFormat();
   
   private final PostingsFormat postingsFormat = new PerFieldPostingsFormat() {
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
index 2d9f5ec..18fb609 100755
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
@@ -36,8 +36,7 @@ import org.apache.lucene.store.DataOutput;
  * FieldBits,DocValuesBits,DocValuesGen,Attributes&gt; <sup>FieldsCount</sup>,Footer</p>
  * <p>Data types:
  * <ul>
- *   <li>Header --&gt; {@link CodecUtil#checkHeader CodecHeader}</li>
- *   <li>SegmentID --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>Header --&gt; {@link CodecUtil#checkSegmentHeader SegmentHeader}</li>
  *   <li>FieldsCount --&gt; {@link DataOutput#writeVInt VInt}</li>
  *   <li>FieldName --&gt; {@link DataOutput#writeString String}</li>
  *   <li>FieldBits, DocValuesBits --&gt; {@link DataOutput#writeByte Byte}</li>
@@ -49,7 +48,6 @@ import org.apache.lucene.store.DataOutput;
  * </p>
  * Field Descriptions:
  * <ul>
- *   <li>SegmentID: {@link SegmentInfo#getId()} this file belongs to</li>
  *   <li>FieldsCount: the number of fields in this file.</li>
  *   <li>FieldName: name of the field as a UTF-8 String.</li>
  *   <li>FieldNumber: the field's number. Note that unlike previous versions of
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java
index a842289..f759e27 100755
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java
@@ -54,13 +54,10 @@ final class Lucene50FieldInfosReader extends FieldInfosReader {
       Throwable priorE = null;
       FieldInfo infos[] = null;
       try {
-        CodecUtil.checkHeader(input, Lucene50FieldInfosFormat.CODEC_NAME, 
+        CodecUtil.checkSegmentHeader(input, Lucene50FieldInfosFormat.CODEC_NAME, 
                                      Lucene50FieldInfosFormat.FORMAT_START, 
-                                     Lucene50FieldInfosFormat.FORMAT_CURRENT);
-        String id = input.readString();
-        if (!id.equals(segmentInfo.getId())) {
-          throw new CorruptIndexException("file mismatch, expected segment id=" + segmentInfo.getId() + ", got=" + id, input);
-        }
+                                     Lucene50FieldInfosFormat.FORMAT_CURRENT,
+                                     segmentInfo.getId());
         
         final int size = input.readVInt(); //read in the size
         infos = new FieldInfo[size];
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java
index 4ff42f4..c3dcbaf 100755
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java
@@ -47,8 +47,7 @@ final class Lucene50FieldInfosWriter extends FieldInfosWriter {
   public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
     final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);
     try (IndexOutput output = directory.createOutput(fileName, context)) {
-      CodecUtil.writeHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT);
-      output.writeString(segmentInfo.getId());
+      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId());
       output.writeVInt(infos.size());
       for (FieldInfo fi : infos) {
         fi.checkConsistency();
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java
new file mode 100644
index 0000000..612bb9b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java
@@ -0,0 +1,115 @@
+package org.apache.lucene.codecs.lucene50;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentCommitInfo;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.DataOutput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.MutableBits;
+
+/** 
+ * Lucene 5.0 live docs format 
+ * <p>
+ * <p>The .liv file is optional, and only exists when a segment contains
+ * deletions.</p>
+ * <p>Although per-segment, this file is maintained exterior to compound segment
+ * files.</p>
+ * <p>Deletions (.liv) --&gt; SegmentHeader,Bits</p>
+ * <ul>
+ *   <li>SegmentHeader --&gt; {@link CodecUtil#writeSegmentHeader SegmentHeader}</li>
+ *   <li>Bits --&gt; &lt;{@link DataOutput#writeLong Int64}&gt; <sup>LongCount</sup></li>
+ * </ul>
+ */
+public class Lucene50LiveDocsFormat extends LiveDocsFormat {
+  
+  /** extension of live docs */
+  private static final String EXTENSION = "liv";
+  
+  /** codec of live docs */
+  private static final String CODEC_NAME = "Lucene50LiveDocs";
+  
+  /** supported version range */
+  private static final int VERSION_START = 0;
+  private static final int VERSION_CURRENT = VERSION_START;
+
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    FixedBitSet bits = new FixedBitSet(size);
+    bits.set(0, size);
+    return bits;
+  }
+
+  @Override
+  public MutableBits newLiveDocs(Bits existing) throws IOException {
+    FixedBitSet fbs = (FixedBitSet) existing;
+    return fbs.clone();
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
+    String name = IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, info.getDelGen());
+    final int length = info.info.getDocCount();
+    try (ChecksumIndexInput input = dir.openChecksumInput(name, context)) {
+      Throwable priorE = null;
+      try {
+        CodecUtil.checkSegmentHeader(input, CODEC_NAME, VERSION_START, VERSION_CURRENT, info.info.getId());
+        long data[] = new long[FixedBitSet.bits2words(length)];
+        for (int i = 0; i < data.length; i++) {
+          data[i] = input.readLong();
+        }
+        return new FixedBitSet(data, length);
+      } catch (Throwable exception) {
+        priorE = exception;
+      } finally {
+        CodecUtil.checkFooter(input, priorE);
+      }
+    }
+    throw new AssertionError();
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
+    String name = IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, info.getNextDelGen());
+    long data[] = ((FixedBitSet) bits).getBits();
+    try (IndexOutput output = dir.createOutput(name, context)) {
+      CodecUtil.writeSegmentHeader(output, CODEC_NAME, VERSION_CURRENT, info.info.getId());
+      for (int i = 0; i < data.length; i++) {
+        output.writeLong(data[i]);
+      }
+      CodecUtil.writeFooter(output);
+    }
+  }
+
+  @Override
+  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
+    if (info.hasDeletions()) {
+      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, info.getDelGen()));
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java b/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
index cf69d3e..b107223 100644
--- a/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
+++ b/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
@@ -31,7 +31,7 @@ import org.apache.lucene.search.DocIdSetIterator;
  * 
  * @lucene.internal
  */
-public final class FixedBitSet extends DocIdSet implements Bits {
+public final class FixedBitSet extends DocIdSet implements MutableBits {
 
   private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(FixedBitSet.class);
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java
index fe20dc1..e3efa9c 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java
@@ -96,7 +96,7 @@ public class TestIndexFileDeleter extends LuceneTestCase {
     */
 
     // TODO: fix this test better
-    String ext = Codec.getDefault().getName().equals("SimpleText") ? ".liv" : ".del";
+    String ext = ".liv";
     
     // Create a bogus separate del file for a
     // segment that already has a separate del file: 

