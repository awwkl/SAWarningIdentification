GitDiffStart: cebfa0b9b95117482c9ae8b4c18c17e49e8d9fe6 | Sun Aug 12 11:23:11 2012 +0000
diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index 66e7bbc..c24f5f0 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -174,6 +174,6 @@
   <classpathentry kind="lib" path="solr/contrib/velocity/lib/commons-beanutils-1.7.0.jar"/>
   <classpathentry kind="lib" path="solr/contrib/velocity/lib/commons-collections-3.2.1.jar"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="lucene/test-framework/lib/randomizedtesting-runner-1.6.0.jar"/>
+	<classpathentry kind="lib" path="lucene/test-framework/lib/randomizedtesting-runner-2.0.0.rc5.jar"/>
 	<classpathentry kind="output" path="bin/other"/>
 </classpath>
diff --git a/dev-tools/idea/.idea/libraries/JUnit.xml b/dev-tools/idea/.idea/libraries/JUnit.xml
index b3a42f8..c8db190 100644
--- a/dev-tools/idea/.idea/libraries/JUnit.xml
+++ b/dev-tools/idea/.idea/libraries/JUnit.xml
@@ -2,7 +2,7 @@
   <library name="JUnit">
     <CLASSES>
       <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/junit-4.10.jar!/" />
-      <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/randomizedtesting-runner-1.6.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/randomizedtesting-runner-2.0.0.rc5.jar!/" />
     </CLASSES>
     <JAVADOC />
     <SOURCES />
diff --git a/dev-tools/maven/pom.xml.template b/dev-tools/maven/pom.xml.template
index 0ed4cfc..8523fc1 100644
--- a/dev-tools/maven/pom.xml.template
+++ b/dev-tools/maven/pom.xml.template
@@ -385,7 +385,7 @@
       <dependency>
         <groupId>com.carrotsearch.randomizedtesting</groupId>
         <artifactId>randomizedtesting-runner</artifactId>
-        <version>1.6.0</version>
+        <version>2.0.0.rc5</version>
       </dependency>
     </dependencies>
   </dependencyManagement>
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index ceeea52..34bcd4f 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -43,6 +43,11 @@ Bug Fixes
   upgraded to 3.x, then to Lucene 4.0-ALPHA or -BETA, you should run 
   CheckIndex. If it fails, then you need to upgrade again to 4.0  (Robert Muir)
 
+Build
+
+* LUCENE-3985: Upgrade to randomizedtesting 2.0.0. Added support for 
+  thread leak detection. Added support for suite timeouts. (Dawid Weiss)
+
 ======================= Lucene 4.0.0-BETA =======================
 
 New features
diff --git a/lucene/build.xml b/lucene/build.xml
index f010f9a..82a6554 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -153,6 +153,7 @@
       <apiFileSet dir="${custom-tasks.dir}/forbiddenApis">
         <include name="jdk.txt" />
         <include name="jdk-deprecated.txt" />
+        <include name="executors.txt" />
       </apiFileSet>
       <fileset dir="${basedir}/build" includes="**/*.class" />
     </forbidden-apis>
diff --git a/lucene/common-build.xml b/lucene/common-build.xml
index 65e3d2b..c40be52 100644
--- a/lucene/common-build.xml
+++ b/lucene/common-build.xml
@@ -88,7 +88,7 @@
   <property name="tests.timezone" value="random" />
   <property name="tests.directory" value="random" />
   <property name="tests.linedocsfile" value="europarl.lines.txt.gz" />
-  <property name="tests.loggingfile" value="/dev/null"/>
+  <property name="tests.loggingfile" value="${common.dir}/tools/junit4/logging.properties"/>
   <property name="tests.nightly" value="false" />
   <property name="tests.weekly" value="false" />
   <property name="tests.slow" value="true" />
@@ -700,15 +700,22 @@
   <condition property="tests.method" value="${testmethod}*">
     <isset property="testmethod" />
   </condition>
+
   <condition property="tests.showSuccess" value="true">
     <or>
       <isset property="tests.class" />
       <isset property="tests.method" />
     </or>
   </condition>
-  <!-- default -->
   <property name="tests.showSuccess" value="false"/>
-  
+
+  <condition property="tests.showOutput" value="always">
+    <or>
+      <isset property="tests.class" />
+      <isset property="tests.method" />
+    </or>
+  </condition>
+  <property name="tests.showOutput" value="onerror"/>
 
   <!-- Test macro using junit4. -->
   <macrodef name="test-macro" description="Executes junit tests.">
@@ -854,6 +861,7 @@
             <syspropertyset>
                 <propertyref prefix="tests.maxfailures" />
                 <propertyref prefix="tests.failfast" />
+                <propertyref prefix="tests.badapples" />
             </syspropertyset>
 
             <!-- Pass randomized settings to the forked JVM. -->
@@ -875,8 +883,7 @@
                 <junit4:report-text
                     showThrowable="true" 
                     showStackTraces="true" 
-                    showOutputStream="true" 
-                    showErrorStream="true"
+                    showOutput="${tests.showOutput}" 
 
                     showStatusOk="${tests.showSuccess}"
                     showStatusError="${tests.showError}"
@@ -896,8 +903,7 @@
                     file="@{junit.output.dir}/tests-report.txt"
                     showThrowable="true" 
                     showStackTraces="true" 
-                    showOutputStream="true" 
-                    showErrorStream="true"
+                    showOutput="always"
 
                     showStatusOk="true"
                     showStatusError="true"
@@ -913,8 +919,7 @@
                     file="@{junit.output.dir}/tests-failures.txt"
                     showThrowable="true" 
                     showStackTraces="true" 
-                    showOutputStream="true" 
-                    showErrorStream="true"
+                    showOutput="onerror" 
 
                     showStatusOk="false"
                     showStatusError="true"
@@ -929,8 +934,13 @@
                      the slowest tests or for reuse in balancing). -->
                 <junit4:report-execution-times file="@{junit.output.dir}/tests-timehints.txt" historyLength="5" />
 
-                <junit4:report-ant-xml dir="@{junit.output.dir}" />
-                <junit4:report-json file="@{junit.output.dir}/tests-report-${ant.project.name}/index.html" />
+                <!-- ANT-compatible XMLs for jenkins records etc. -->
+                <junit4:report-ant-xml dir="@{junit.output.dir}" outputStreams="no" />
+
+                <!--
+                Enable if you wish to have a nice HTML5 report.
+                <junit4:report-json file="@{junit.output.dir}/tests-report-${ant.project.name}/index.html" outputStreams="no" />
+                -->
             </listeners>
 
             <!-- Input test classes. -->
diff --git a/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java b/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java
new file mode 100644
index 0000000..e9509ab
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java
@@ -0,0 +1,98 @@
+package org.apache.lucene;
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Ignore;
+
+import com.carrotsearch.randomizedtesting.RandomizedTest;
+import com.carrotsearch.randomizedtesting.annotations.Timeout;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestWorstCaseTestBehavior extends LuceneTestCase {
+  @Ignore
+  public void testThreadLeak() {
+    Thread t = new Thread() {
+      @Override
+      public void run() {
+        try {
+          Thread.sleep(10000);
+        } catch (InterruptedException e) {
+          // Ignore.
+        }
+      }
+    };
+    t.start();
+
+    while (!t.isAlive()) {
+      Thread.yield();
+    }
+
+    // once alive, leave it to run outside of the test scope.
+  }
+
+  @Ignore
+  public void testLaaaaaargeOutput() throws Exception {
+    String message = "I will not OOM on large output";
+    int howMuch = 250 * 1024 * 1024;
+    for (int i = 0; i < howMuch; i++) {
+      if (i > 0) System.out.print(",\n");
+      System.out.print(message);
+      howMuch -= message.length(); // approximately.
+    }
+    System.out.println(".");
+  }
+
+  @Ignore
+  public void testProgressiveOutput() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      System.out.println("Emitting sysout line: " + i);
+      System.err.println("Emitting syserr line: " + i);
+      System.out.flush();
+      System.err.flush();
+      RandomizedTest.sleep(1000);
+    }
+  }
+
+  @Ignore
+  public void testUncaughtException() throws Exception {
+    Thread t = new Thread() {
+      @Override
+      public void run() {
+        throw new RuntimeException("foobar");
+      }
+    };
+    t.start();
+    t.join();
+  }
+  
+  @Ignore
+  @Timeout(millis = 500)
+  public void testTimeout() throws Exception {
+    Thread.sleep(5000);
+  }
+  
+  @Ignore
+  @Timeout(millis = 1000)
+  public void testZombie() throws Exception {
+    while (true) {
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException e) {}
+    }
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java b/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
index e24ba4b..135fea4 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
@@ -27,12 +27,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.ThreadInterruptedException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
-
 /**
  * Tests for {@link DocumentsWriterStallControl}
  */
-@ThreadLeaks(failTestIfLeaking = true)
 public class TestDocumentsWriterStallControl extends LuceneTestCase {
   
   public void testSimpleStall() throws InterruptedException {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java b/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
index 25d1587..804e13c 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
@@ -67,13 +67,19 @@ public class TestReaderClosed extends LuceneTestCase {
       // expected
     }
   }
-  
+
   // LUCENE-3800
+  @BadApple
+  @AwaitsFix(bugUrl = "LUCENE-4280")
   public void testReaderChaining() throws Exception {
     assertTrue(reader.getRefCount() > 0);
     IndexReader wrappedReader = SlowCompositeReaderWrapper.wrap(reader);
     wrappedReader = new ParallelAtomicReader((AtomicReader) wrappedReader);
+
+    // TODO: LUCENE-4280; this fails:
     IndexSearcher searcher = newSearcher(wrappedReader);
+    // but with this it works: IndexSearcher searcher = new IndexSearcher(wrappedReader);
+
     TermRangeQuery query = TermRangeQuery.newStringRange("field", "a", "z", true, true);
     searcher.search(query, 5);
     reader.close(); // close original child reader
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSort.java b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
index 312d004..0d54e32 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
@@ -59,6 +59,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.DocIdBitSet;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util._TestUtil;
 import org.junit.BeforeClass;
 
@@ -810,7 +811,7 @@ public class TestSort extends LuceneTestCase {
     assertMatches (full, queryG, sort, "ZYXW");
 
     // Do the same for a ParallelMultiSearcher
-    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));
+    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory("testEmptyFieldSort"));
     IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);
 
     sort.setSort (new SortField ("int", SortField.Type.INT),
@@ -852,7 +853,7 @@ public class TestSort extends LuceneTestCase {
 
   // test a variety of sorts using a parallel multisearcher
   public void testParallelMultiSort() throws Exception {
-    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));
+    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory("testParallelMultiSort"));
     IndexSearcher searcher = new IndexSearcher(
                                   new MultiReader(searchX.getIndexReader(),
                                                   searchY.getIndexReader()), exec);
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java b/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
index 37cc86c..b5e36e9 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
@@ -159,7 +159,7 @@ public class TestWeakIdentityMap extends LuceneTestCase {
   public void testConcurrentHashMap() throws Exception {
     // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:
     final int threadCount = 8, keyCount = 1024;
-    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);
+    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory("testConcurrentHashMap"));
     final WeakIdentityMap<Object,Integer> map =
       WeakIdentityMap.newConcurrentHashMap();
     // we keep strong references to the keys,
diff --git a/lucene/ivy-settings.xml b/lucene/ivy-settings.xml
index 97376ff..c09a0f0 100644
--- a/lucene/ivy-settings.xml
+++ b/lucene/ivy-settings.xml
@@ -19,6 +19,8 @@
 <ivysettings>
   <settings defaultResolver="default"/>
 
+  <property name="local-maven2-dir" value="${user.home}/.m2/repository/" />
+  
   <include url="${ivy.default.settings.dir}/ivysettings-public.xml"/>
   <include url="${ivy.default.settings.dir}/ivysettings-shared.xml"/>
   <include url="${ivy.default.settings.dir}/ivysettings-local.xml"/>
@@ -26,11 +28,22 @@
 
   <resolvers>
     <ibiblio name="sonatype-releases" root="http://oss.sonatype.org/content/repositories/releases" m2compatible="true" />
+
     <!-- you might need to tweak this from china so it works -->
     <ibiblio name="working-chinese-mirror" root="http://mirror.netcologne.de/maven2" m2compatible="true" />
 
+    <!--
+    <filesystem name="local-maven-2" m2compatible="true" local="true">
+      <artifact
+          pattern="${local-maven2-dir}/[organisation]/[module]/[revision]/[module]-[revision].[ext]" />
+      <ivy
+          pattern="${local-maven2-dir}/[organisation]/[module]/[revision]/[module]-[revision].pom" />
+    </filesystem>
+    -->
+
     <chain name="default" returnFirst="true" checkmodified="true" changingPattern=".*SNAPSHOT">
       <resolver ref="local"/>
+      <!-- <resolver ref="local-maven-2" /> -->
       <resolver ref="main"/>
       <resolver ref="sonatype-releases" />
       <resolver ref="working-chinese-mirror" />
diff --git a/lucene/licenses/junit4-ant-1.6.0.jar.sha1 b/lucene/licenses/junit4-ant-1.6.0.jar.sha1
deleted file mode 100644
index 9a2ca80..0000000
--- a/lucene/licenses/junit4-ant-1.6.0.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-c7a65e96a2c62ba83ca404065305aec5dc7fc8f1
diff --git a/lucene/licenses/junit4-ant-2.0.0.rc5.jar.sha1 b/lucene/licenses/junit4-ant-2.0.0.rc5.jar.sha1
new file mode 100644
index 0000000..2f0a50f
--- /dev/null
+++ b/lucene/licenses/junit4-ant-2.0.0.rc5.jar.sha1
@@ -0,0 +1 @@
+2b08ce9fc1269cbbdbb647ec651d64d501d8c071
\ No newline at end of file
diff --git a/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1 b/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1
deleted file mode 100644
index be7ad32..0000000
--- a/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-709f9549a0b0c2e2ecdd5af012d9531325d6551b
diff --git a/lucene/licenses/randomizedtesting-runner-2.0.0.rc5.jar.sha1 b/lucene/licenses/randomizedtesting-runner-2.0.0.rc5.jar.sha1
new file mode 100644
index 0000000..4cc4de9
--- /dev/null
+++ b/lucene/licenses/randomizedtesting-runner-2.0.0.rc5.jar.sha1
@@ -0,0 +1 @@
+68dbb7c5d90e6b3606a4f207eefbd028d6a68c1a
\ No newline at end of file
diff --git a/lucene/module-build.xml b/lucene/module-build.xml
index 771016a..87baa3d 100644
--- a/lucene/module-build.xml
+++ b/lucene/module-build.xml
@@ -49,8 +49,8 @@
   <path id="test.classpath" refid="test.base.classpath"/>
 
   <path id="junit.classpath">
-    <path refid="test.classpath"/>
     <pathelement location="${build.dir}/classes/test"/>
+    <path refid="test.classpath"/>
     <pathelement path="${java.class.path}"/>
   </path>
 
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java b/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
index ab7e455..8504b99 100755
--- a/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
@@ -39,6 +39,7 @@ import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
 
 /**
  * Spell checker test case
@@ -413,7 +414,7 @@ public class TestSpellChecker extends LuceneTestCase {
     int num_field2 = this.numdoc();
     assertEquals(num_field2, num_field1 + 1);
     int numThreads = 5 + random().nextInt(5);
-    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads, new NamedThreadFactory("testConcurrentAccess"));
     SpellCheckWorker[] workers = new SpellCheckWorker[numThreads];
     for (int i = 0; i < numThreads; i++) {
       SpellCheckWorker spellCheckWorker = new SpellCheckWorker(r);
diff --git a/lucene/test-framework/ivy.xml b/lucene/test-framework/ivy.xml
index 4e39a2b..6d55434 100644
--- a/lucene/test-framework/ivy.xml
+++ b/lucene/test-framework/ivy.xml
@@ -33,8 +33,8 @@
       <dependency org="org.apache.ant" name="ant-junit" rev="1.8.2" transitive="false" />
 
       <dependency org="junit" name="junit" rev="4.10" transitive="false" conf="default->*;junit4-stdalone->*" />
-            <dependency org="com.carrotsearch.randomizedtesting" name="junit4-ant" rev="1.6.0" transitive="false" conf="default->*;junit4-stdalone->*" />
-      <dependency org="com.carrotsearch.randomizedtesting" name="randomizedtesting-runner" rev="1.6.0" transitive="false" conf="default->*;junit4-stdalone->*" />
+      <dependency org="com.carrotsearch.randomizedtesting" name="junit4-ant" rev="2.0.0.rc5" transitive="false" conf="default->*;junit4-stdalone->*" />
+      <dependency org="com.carrotsearch.randomizedtesting" name="randomizedtesting-runner" rev="2.0.0.rc5" transitive="false" conf="default->*;junit4-stdalone->*" />
 
       <exclude org="*" ext="*" matcher="regexp" type="${ivy.exclude.types}"/> 
     </dependencies>
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneJUnit3MethodProvider.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneJUnit3MethodProvider.java
index 15518fb..bbc9831 100755
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneJUnit3MethodProvider.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneJUnit3MethodProvider.java
@@ -17,13 +17,14 @@ package org.apache.lucene.util;
  * limitations under the License.
  */
 
-import static com.carrotsearch.randomizedtesting.MethodCollector.flatten;
-import static com.carrotsearch.randomizedtesting.MethodCollector.mutableCopy1;
-
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
 
+import com.carrotsearch.randomizedtesting.ClassModel;
+import com.carrotsearch.randomizedtesting.ClassModel.MethodModel;
 import com.carrotsearch.randomizedtesting.TestMethodProvider;
 
 /**
@@ -31,20 +32,21 @@ import com.carrotsearch.randomizedtesting.TestMethodProvider;
  */
 public final class LuceneJUnit3MethodProvider implements TestMethodProvider {
   @Override
-  public Collection<Method> getTestMethods(Class<?> suiteClass, List<List<Method>> methods) {
-    // We will return all methods starting with test* and rely on further validation to weed
-    // out static or otherwise invalid test methods.
-    List<Method> copy = mutableCopy1(flatten(methods));
-    Iterator<Method> i =copy.iterator();
-    while (i.hasNext()) {
-      Method m= i.next();
-      if (!m.getName().startsWith("test") ||
-          !Modifier.isPublic(m.getModifiers()) ||
-           Modifier.isStatic(m.getModifiers()) ||
-           m.getParameterTypes().length != 0) {
-        i.remove();
+  public Collection<Method> getTestMethods(Class<?> suiteClass, ClassModel classModel) {
+    Map<Method,MethodModel> methods = classModel.getMethods();
+    ArrayList<Method> result = new ArrayList<Method>();
+    for (MethodModel mm : methods.values()) {
+      // Skip any methods that have overrieds/ shadows.
+      if (mm.getDown() != null) continue;
+
+      Method m = mm.element;
+      if (m.getName().startsWith("test") &&
+          Modifier.isPublic(m.getModifiers()) &&
+          !Modifier.isStatic(m.getModifiers()) &&
+          m.getParameterTypes().length == 0) {
+        result.add(m);
       }
     }
-    return copy;
+    return result;
   }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index 1adfbca..9705c15 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -45,7 +45,13 @@ import org.junit.rules.TestRule;
 import org.junit.runner.RunWith;
 import com.carrotsearch.randomizedtesting.*;
 import com.carrotsearch.randomizedtesting.annotations.*;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakAction.Action;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakGroup.Group;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakScope.Scope;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakZombies.Consequence;
 import com.carrotsearch.randomizedtesting.generators.RandomPicks;
+import com.carrotsearch.randomizedtesting.rules.NoClassHooksShadowingRule;
+import com.carrotsearch.randomizedtesting.rules.NoInstanceHooksOverridesRule;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule;
 
 import static com.carrotsearch.randomizedtesting.RandomizedTest.systemPropertyAsBoolean;
@@ -113,7 +119,15 @@ import static com.carrotsearch.randomizedtesting.RandomizedTest.systemPropertyAs
   RunListenerPrintReproduceInfo.class
 })
 @SeedDecorators({MixWithSuiteName.class}) // See LUCENE-3995 for rationale.
-@ThreadLeaks(failTestIfLeaking = false)
+@ThreadLeakScope(Scope.SUITE)
+@ThreadLeakGroup(Group.MAIN)
+@ThreadLeakAction({Action.WARN, Action.INTERRUPT})
+@ThreadLeakLingering(linger = 20000) // Wait long for leaked threads to complete before failure. zk needs this.
+@ThreadLeakZombies(Consequence.IGNORE_REMAINING_TESTS)
+@TimeoutSuite(millis = 10 * (/* minutes */ 1000 * 60)) // max suite execution time.
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    QuickPatchThreadsFilter.class
+})
 public abstract class LuceneTestCase extends Assert {
 
   // --------------------------------------------------------------------
@@ -124,6 +138,7 @@ public abstract class LuceneTestCase extends Assert {
   public static final String SYSPROP_WEEKLY = "tests.weekly";
   public static final String SYSPROP_AWAITSFIX = "tests.awaitsfix";
   public static final String SYSPROP_SLOW = "tests.slow";
+  public static final String SYSPROP_BADAPPLES = "tests.badapples";
 
   /** @see #ignoreAfterMaxFailures*/
   private static final String SYSPROP_MAXFAILURES = "tests.maxfailures";
@@ -170,7 +185,21 @@ public abstract class LuceneTestCase extends Assert {
   @Retention(RetentionPolicy.RUNTIME)
   @TestGroup(enabled = true, sysProperty = SYSPROP_SLOW)
   public @interface Slow {}
-  
+
+  /**
+   * Annotation for tests that fail frequently. You can disable them
+   * if you want to run a long build and not stop on something that
+   * is a known problem.
+   * <pre>
+   * -Dtests.badapples=false
+   * </pre>
+   */
+  @Documented
+  @Inherited
+  @Retention(RetentionPolicy.RUNTIME)
+  @TestGroup(enabled = true, sysProperty = SYSPROP_BADAPPLES)
+  public @interface BadApple {}
+
   /**
    * Annotation for test classes that should avoid certain codec types
    * (because they are expensive, for example).
@@ -349,11 +378,16 @@ public abstract class LuceneTestCase extends Assert {
     .around(ignoreAfterMaxFailures)
     .around(suiteFailureMarker)
     .around(new TestRuleAssertionsRequired())
-    .around(new TestRuleNoStaticHooksShadowing())
-    .around(new TestRuleNoInstanceHooksOverrides())
+    .around(new NoClassHooksShadowingRule())
+    .around(new NoInstanceHooksOverridesRule() {
+      @Override
+      protected boolean verify(Method key) {
+        String name = key.getName();
+        return !(name.equals("setUp") || name.equals("tearDown"));
+      }
+    })
     .around(new SystemPropertiesInvariantRule(IGNORED_INVARIANT_PROPERTIES))
     .around(classNameRule = new TestRuleStoreClassName())
-    .around(new TestRuleReportUncaughtExceptions())
     .around(classEnvRule = new TestRuleSetupAndRestoreClassEnv());
 
 
@@ -380,7 +414,6 @@ public abstract class LuceneTestCase extends Assert {
     .outerRule(testFailureMarker)
     .around(ignoreAfterMaxFailures)
     .around(threadAndTestNameRule)
-    .around(new TestRuleReportUncaughtExceptions())
     .around(new SystemPropertiesInvariantRule(IGNORED_INVARIANT_PROPERTIES))
     .around(new TestRuleSetupAndRestoreInstanceEnv())
     .around(new TestRuleFieldCacheSanity())
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/QuickPatchThreadsFilter.java b/lucene/test-framework/src/java/org/apache/lucene/util/QuickPatchThreadsFilter.java
new file mode 100644
index 0000000..0feeec4
--- /dev/null
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/QuickPatchThreadsFilter.java
@@ -0,0 +1,35 @@
+package org.apache.lucene.util;
+
+import com.carrotsearch.randomizedtesting.ThreadFilter;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Last minute patches.
+ * TODO: remove when integrated in system filters in rr.
+ */
+public class QuickPatchThreadsFilter implements ThreadFilter {
+  @Override
+  public boolean reject(Thread t) {
+    // MacOS system thread.
+    if (t.getName().equals("AWT-AppKit")) {
+      return true;
+    }
+    return false;
+  }
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleAssertionsRequired.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleAssertionsRequired.java
index 9fc8b39..4822363 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleAssertionsRequired.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleAssertionsRequired.java
@@ -21,30 +21,24 @@ import org.junit.rules.TestRule;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
-import com.carrotsearch.randomizedtesting.ClassValidator;
-
 /**
  * Require assertions for Lucene/Solr packages.
  */
-public class TestRuleAssertionsRequired implements TestRule, ClassValidator {
+public class TestRuleAssertionsRequired implements TestRule {
   @Override
   public Statement apply(final Statement base, final Description description) {
     return new Statement() {
       @Override
       public void evaluate() throws Throwable {
-        validate(description.getTestClass());
+        try {
+          assert false;
+          throw new Exception("Test class requires assertions, enable assertions globally (-ea) or for Solr/Lucene subpackages only.");
+        } catch (AssertionError e) {
+          // Ok, enabled.
+        }
+
         base.evaluate();
       }
     };
   }
-
-  @Override
-  public void validate(Class<?> clazz) throws Throwable {
-    try {
-      assert false;
-      throw new Exception("Test class requires assertions, enable assertions globally (-ea) or for Solr/Lucene subpackages only.");
-    } catch (AssertionError e) {
-      // Ok, enabled.
-    }    
-  }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoInstanceHooksOverrides.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoInstanceHooksOverrides.java
deleted file mode 100644
index 81dda90..0000000
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoInstanceHooksOverrides.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import static com.carrotsearch.randomizedtesting.MethodCollector.allDeclaredMethods;
-import static com.carrotsearch.randomizedtesting.MethodCollector.annotatedWith;
-import static com.carrotsearch.randomizedtesting.MethodCollector.flatten;
-import static com.carrotsearch.randomizedtesting.MethodCollector.removeOverrides;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import com.carrotsearch.randomizedtesting.ClassValidator;
-
-/**
- * Don't allow {@link Before} and {@link After} hook overrides as it is most
- * likely a user error and will result in superclass methods not being called
- * (requires manual chaining). 
- */
-public class TestRuleNoInstanceHooksOverrides implements TestRule, ClassValidator {
-  @Override
-  public Statement apply(final Statement base, final Description description) {
-    return new Statement() {
-      @Override
-      public void evaluate() throws Throwable {
-        validate(description.getTestClass());
-        base.evaluate();
-      }
-    };
-  }
-
-  @Override
-  public void validate(Class<?> clazz) throws Throwable {
-    List<List<Method>> all = allDeclaredMethods(clazz);
-
-    checkNoShadows(clazz, all, Before.class);
-    checkNoShadows(clazz, all, After.class);
-  }
-
-  private void checkNoShadows(Class<?> clazz, List<List<Method>> all, Class<? extends Annotation> ann) {
-    List<List<Method>> methodHierarchy = filterIgnored(annotatedWith(all, ann));
-    List<List<Method>> noOverrides = removeOverrides(methodHierarchy);
-    if (!noOverrides.equals(methodHierarchy)) {
-      Set<Method> shadowed = new HashSet<Method>(flatten(methodHierarchy));
-      shadowed.removeAll(flatten(noOverrides));
-
-      StringBuilder b = new StringBuilder();
-      for (Method m : shadowed) {
-        String sig = signature(m);
-        for (Method other : flatten(methodHierarchy)) {
-          if (other != m && sig.equals(signature(other))) {
-            b.append("Method: " + m.toString()
-                + "#" + sig + " possibly overriden by " + 
-                other.toString() + "#" + signature(other) + "\n");
-          }
-        }
-      }
-
-      throw new RuntimeException("There are overridden methods annotated with "
-          + ann.getName() + ". These methods would not be executed by JUnit and need to manually chain themselves which can lead to" +
-              " maintenance problems. Consider using different method names or make hook methods private.\n" + b.toString().trim());
-    }
-  }
-
-  private List<List<Method>> filterIgnored(List<List<Method>> methods) {
-    Set<String> ignored = new HashSet<String>(Arrays.asList("setUp", "tearDown"));
-    List<List<Method>> copy = new ArrayList<List<Method>>();
-    for (List<Method> m : methods) {
-      if (!ignored.contains(m.get(0).getName())) {
-        copy.add(m);
-      }
-    }
-    return copy;
-  }
-
-  private String signature(Method m) {
-    return m.getName() + Arrays.toString(m.getParameterTypes());
-  }
-}
-
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoStaticHooksShadowing.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoStaticHooksShadowing.java
deleted file mode 100644
index af28b6a..0000000
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleNoStaticHooksShadowing.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import static com.carrotsearch.randomizedtesting.MethodCollector.allDeclaredMethods;
-import static com.carrotsearch.randomizedtesting.MethodCollector.annotatedWith;
-import static com.carrotsearch.randomizedtesting.MethodCollector.flatten;
-import static com.carrotsearch.randomizedtesting.MethodCollector.removeShadowed;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import com.carrotsearch.randomizedtesting.ClassValidator;
-
-/**
- * Don't allow shadowing of {@link BeforeClass} or {@link AfterClass} hooks
- * as it is very likely a user error and will prevent execution of shadowed hooks.
- */
-public class TestRuleNoStaticHooksShadowing implements TestRule, ClassValidator {
-  
-  @Override
-  public Statement apply(final Statement base, final Description description) {
-    return new Statement() {
-      @Override
-      public void evaluate() throws Throwable {
-        validate(description.getTestClass());
-        base.evaluate();
-      }
-    };
-  }
-
-  @Override
-  public void validate(Class<?> clazz) throws Throwable {
-    List<List<Method>> all = allDeclaredMethods(clazz);
-
-    checkNoShadows(clazz, all, BeforeClass.class);
-    checkNoShadows(clazz, all, AfterClass.class);
-  }
-
-  private void checkNoShadows(Class<?> clazz, List<List<Method>> all, Class<? extends Annotation> ann) {
-    List<List<Method>> methodHierarchy = annotatedWith(all, ann);
-    List<List<Method>> noShadows = removeShadowed(methodHierarchy);
-    if (!noShadows.equals(methodHierarchy)) {
-      Set<Method> shadowed = new HashSet<Method>(flatten(methodHierarchy));
-      shadowed.removeAll(flatten(noShadows));
-
-      StringBuilder b = new StringBuilder();
-      for (Method m : shadowed) {
-        String sig = signature(m);
-        for (Method other : flatten(methodHierarchy)) {
-          if (other != m && sig.equals(signature(other))) {
-            b.append("Method: " + m.toString()
-                + "#" + sig + " possibly shadowed by " + 
-                other.toString() + "#" + signature(other) + "\n");
-          }
-        }
-      }
-
-      throw new RuntimeException("There are shadowed methods annotated with "
-          + ann.getName() + ". These methods would not be executed by JUnit and need to manually chain themselves which can lead to" +
-              " maintenance problems.\n" + b.toString().trim());
-    }
-  }
-
-  private String signature(Method m) {
-    return m.getName() + Arrays.toString(m.getParameterTypes());
-  }
-}
-
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java
deleted file mode 100644
index fa75b7c..0000000
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.MultipleFailureException;
-import org.junit.runners.model.Statement;
-
-/**
- * Subscribes to
- * {@link Thread#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)}
- * and causes test/ suite failures if uncaught exceptions are detected.
- */
-public class TestRuleReportUncaughtExceptions implements TestRule {
-  // This was originally volatile, but I don't think it needs to be. It's the same
-  // thread accessing it, always.
-  private UncaughtExceptionHandler savedUncaughtExceptionHandler;
-  
-  public static class UncaughtExceptionEntry {
-    public final Thread thread;
-    public final Throwable exception;
-
-    public UncaughtExceptionEntry(Thread thread, Throwable exception) {
-      this.thread = thread;
-      this.exception = exception;
-    }
-  }
-
-  @SuppressWarnings("serial")
-  private static class UncaughtExceptionsInBackgroundThread extends RuntimeException {
-    public UncaughtExceptionsInBackgroundThread(UncaughtExceptionEntry e) {
-      super("Uncaught exception by thread: " + e.thread, e.exception);
-    }
-  }
-
-  // Lock on uncaughtExceptions to access.
-  private final List<UncaughtExceptionEntry> uncaughtExceptions = new ArrayList<UncaughtExceptionEntry>();
-
-  @Override
-  public Statement apply(final Statement s, final Description d) {
-    return new Statement() {
-      public void evaluate() throws Throwable {
-        final ArrayList<Throwable> errors = new ArrayList<Throwable>();
-        try {
-          setupHandler();
-          s.evaluate();
-        } catch (Throwable t) {
-          errors.add(t);
-        } finally {
-          restoreHandler();
-        }
-
-        synchronized (uncaughtExceptions) {
-          for (UncaughtExceptionEntry e : uncaughtExceptions) {
-            errors.add(new UncaughtExceptionsInBackgroundThread(e));
-          }
-          uncaughtExceptions.clear();
-        }
-
-        MultipleFailureException.assertEmpty(errors);
-      }
-    };
-  }
-
-  /**
-   * Just a check if anything's been caught.
-   */
-  public boolean hasUncaughtExceptions() {
-    synchronized (uncaughtExceptions) {
-      return !uncaughtExceptions.isEmpty();
-    }
-  }
-  
-  private void restoreHandler() {
-    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);    
-  }
-
-  private void setupHandler() {
-    savedUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-      public void uncaughtException(Thread t, Throwable e) {
-        // org.junit.internal.AssumptionViolatedException in older releases
-        // org.junit.Assume.AssumptionViolatedException in recent ones
-        if (e.getClass().getName().endsWith("AssumptionViolatedException")) {
-          String where = "<unknown>";
-          for (StackTraceElement elem : e.getStackTrace()) {
-            if (!elem.getClassName().startsWith("org.junit")) {
-              where = elem.toString();
-              break;
-            }
-          }
-          System.err.print("NOTE: Uncaught exception handler caught a failed assumption at " 
-              + where + " (ignored):");
-        } else {
-          synchronized (uncaughtExceptions) {
-            uncaughtExceptions.add(new UncaughtExceptionEntry(t, e));
-          }
-
-          StringWriter sw = new StringWriter();
-          sw.write("\n===>\nUncaught exception by thread: " + t + "\n");
-          PrintWriter pw = new PrintWriter(sw);
-          e.printStackTrace(pw);
-          pw.flush();
-          sw.write("<===\n");
-          System.err.println(sw.toString());
-        }
-      }
-    });
-  }  
-}
diff --git a/lucene/tools/custom-tasks.xml b/lucene/tools/custom-tasks.xml
index 959c952..1b409e8 100644
--- a/lucene/tools/custom-tasks.xml
+++ b/lucene/tools/custom-tasks.xml
@@ -51,8 +51,9 @@
             <additional-filters />
 
             <!-- Typical version patterns. -->
+            <replaceregex pattern="\.rc[0-9]+" replace="" flags="gi" />
             <replaceregex pattern="\-(r)?([0-9\-\_\.])+(b(eta)?([0-9\-\.])*)?$" replace="" flags="gi" />
-    
+
             <!-- git hashcode pattern: its always 40 chars right? -->
             <replaceregex pattern="\-[a-z0-9]{40,40}$" replace="" flags="gi" />
           </filtermapper>
diff --git a/lucene/tools/forbiddenApis/executors.txt b/lucene/tools/forbiddenApis/executors.txt
new file mode 100644
index 0000000..dfb9df5
--- /dev/null
+++ b/lucene/tools/forbiddenApis/executors.txt
@@ -0,0 +1,12 @@
+# These methods spawn threads with vague names. Use a custom thread factory and name
+# threads so that you can tell (by its name) which executor it is associated with.
+# see Solr's DefaultSolrThreadFactory
+# see Lucene's NamedThreadFactory
+
+java.util.concurrent.Executors#newFixedThreadPool(int)
+java.util.concurrent.Executors#newSingleThreadExecutor()
+java.util.concurrent.Executors#newCachedThreadPool()
+java.util.concurrent.Executors#newSingleThreadScheduledExecutor()
+java.util.concurrent.Executors#newScheduledThreadPool(int)
+java.util.concurrent.Executors#defaultThreadFactory()
+java.util.concurrent.Executors#privilegedThreadFactory()
diff --git a/lucene/tools/junit4/logging.properties b/lucene/tools/junit4/logging.properties
new file mode 100644
index 0000000..f54ee74
--- /dev/null
+++ b/lucene/tools/junit4/logging.properties
@@ -0,0 +1,10 @@
+
+# root handler
+handlers=java.util.logging.ConsoleHandler
+
+# root logger's cutoff threshold.
+.level=INFO
+
+# configure console handler to emit everything in the default format.
+java.util.logging.ConsoleHandler.level=FINEST
+java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter
diff --git a/solr/build.xml b/solr/build.xml
index 3194587..1bef760 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -200,6 +200,7 @@
         <include name="jdk.txt" />
         <include name="jdk-deprecated.txt" />
         <include name="commons-io.txt" />
+        <include name="executors.txt" />
       </apiFileSet>
       <fileset dir="${basedir}/build">
         <include name="**/*.class" />
diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java
index f7888ff..b58546f 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -70,6 +70,7 @@ import org.apache.solr.update.processor.LogUpdateProcessorFactory;
 import org.apache.solr.update.processor.RunUpdateProcessorFactory;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
 import org.apache.solr.update.processor.UpdateRequestProcessorFactory;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.RefCounted;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
 import org.apache.solr.util.plugin.PluginInfoInitialized;
@@ -1070,7 +1071,8 @@ public final class SolrCore implements SolrInfoMBean {
   private final LinkedList<RefCounted<SolrIndexSearcher>> _searchers = new LinkedList<RefCounted<SolrIndexSearcher>>();
   private final LinkedList<RefCounted<SolrIndexSearcher>> _realtimeSearchers = new LinkedList<RefCounted<SolrIndexSearcher>>();
 
-  final ExecutorService searcherExecutor = Executors.newSingleThreadExecutor();
+  final ExecutorService searcherExecutor = Executors.newSingleThreadExecutor(
+      new DefaultSolrThreadFactory("searcherExecutor"));
   private int onDeckSearchers;  // number of searchers preparing
   // Lock ordering: one can acquire the openSearcherLock and then the searcherLock, but not vice-versa.
   private Object searcherLock = new Object();  // the sync object for the searcher
diff --git a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
index ce3c0f4..f616096 100644
--- a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
+++ b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
@@ -31,6 +31,7 @@ import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.FastInputStream;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.FileUtils;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.CachingDirectoryFactory.CloseListener;
@@ -178,7 +179,8 @@ public class SnapPuller {
         }
       }
     };
-    executorService = Executors.newSingleThreadScheduledExecutor();
+    executorService = Executors.newSingleThreadScheduledExecutor(
+        new DefaultSolrThreadFactory("snapPuller"));
     long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);
     executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);
     LOG.info("Poll Scheduled at an interval of " + pollInterval + "ms");
@@ -311,7 +313,7 @@ public class SnapPuller {
       LOG.info("Number of files in latest index in master: " + filesToDownload.size());
 
       // Create the sync service
-      fsyncService = Executors.newSingleThreadExecutor();
+      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory("fsyncService"));
       // use a synchronized list because the list is read by other threads (to show details)
       filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());
       // if the generateion of master is older than that of the slave , it means they are not compatible to be copied
diff --git a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
index 800c720..c2b1307 100644
--- a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
+++ b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
@@ -397,7 +397,7 @@ public class SimpleFacets {
           Integer.MAX_VALUE,
           10, TimeUnit.SECONDS, // terminate idle threads after 10 sec
           new SynchronousQueue<Runnable>()  // directly hand off tasks
-          , new DefaultSolrThreadFactory("facetExectutor")
+          , new DefaultSolrThreadFactory("facetExecutor")
   );
   
   /**
diff --git a/solr/core/src/java/org/apache/solr/update/CommitTracker.java b/solr/core/src/java/org/apache/solr/update/CommitTracker.java
index 375d2e5..915636e 100644
--- a/solr/core/src/java/org/apache/solr/update/CommitTracker.java
+++ b/solr/core/src/java/org/apache/solr/update/CommitTracker.java
@@ -29,6 +29,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -52,8 +53,8 @@ public final class CommitTracker implements Runnable {
   private int docsUpperBound;
   private long timeUpperBound;
   
-  private final ScheduledExecutorService scheduler = Executors
-      .newScheduledThreadPool(1);
+  private final ScheduledExecutorService scheduler = 
+      Executors.newScheduledThreadPool(1, new DefaultSolrThreadFactory("commitScheduler"));
   private ScheduledFuture pending;
   
   // state
diff --git a/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java b/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
index 246a0f2..3858115 100644
--- a/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
@@ -35,10 +35,12 @@ import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 @Slow
@@ -315,7 +317,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
   @Test
   public void testStressElection() throws Exception {
     final ScheduledExecutorService scheduler = Executors
-        .newScheduledThreadPool(15);
+        .newScheduledThreadPool(15, new DefaultSolrThreadFactory("stressElection"));
     final List<ClientThread> threads = Collections
         .synchronizedList(new ArrayList<ClientThread>());
     
@@ -369,9 +371,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
             }
 
             Thread.sleep(10);
-            
           } catch (Exception e) {
-
           }
         }
       }
@@ -382,7 +382,6 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
       public void run() {
         
         while (!stopStress) {
-
           try {
             Thread.sleep(50);
             int j;
@@ -426,6 +425,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
     
     // cleanup any threads still running
     for (ClientThread thread : threads) {
+      thread.zkClient.getSolrZooKeeper().close();
       thread.close();
     }
     
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
index 8802f6b..3dfabee 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
@@ -43,6 +43,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.handler.component.HttpShardHandlerFactory;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.NodeExistsException;
@@ -298,7 +299,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
 
       
       for (int i = 0; i < nodeCount; i++) {
-        nodeExecutors[i] = Executors.newFixedThreadPool(1);
+        nodeExecutors[i] = Executors.newFixedThreadPool(1, new DefaultSolrThreadFactory("testShardAssignment"));
       }
       
       final String[] ids = new String[coreCount];
diff --git a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
index fd74ee7..a83e5ed 100644
--- a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
@@ -24,8 +24,6 @@ import org.apache.solr.client.solrj.SolrQuery;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.embedded.JettySolrRunner;
 import org.apache.solr.common.SolrInputDocument;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,16 +34,7 @@ public class RecoveryZkTest extends AbstractFullDistribZkTestBase {
   private static Logger log = LoggerFactory.getLogger(RecoveryZkTest.class);
   private StopableIndexingThread indexThread;
   private StopableIndexingThread indexThread2;
-  @BeforeClass
-  public static void beforeSuperClass() {
 
-  }
-  
-  @AfterClass
-  public static void afterSuperClass() {
-
-  }
-  
   public RecoveryZkTest() {
     super();
     sliceCount = 1;
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java b/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
index 56292ff..8effb26 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
@@ -37,7 +37,6 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
   protected CoreContainer cores = null;
   private String home;
 
-
   protected static ZkTestServer zkServer;
   protected static String zkDir;
   
@@ -101,7 +100,6 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
     super.tearDown();
   }
 
-
   @Test
   public void testMultiCoreConfBootstrap() throws Exception {
     System.setProperty("bootstrap_conf", "true");
@@ -113,6 +111,7 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
     assertTrue(zkclient.exists("/configs/core1/schema.xml", true));
     assertTrue(zkclient.exists("/configs/core0/solrconfig.xml", true));
     assertTrue(zkclient.exists("/configs/core1/schema.xml", true));
+    
+    zkclient.close();
   }
-
 }
diff --git a/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java b/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
index 43bc6ec..8930fd0 100755
--- a/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
+++ b/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
@@ -25,6 +25,7 @@ import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.plugin.SolrCoreAware;
 import org.junit.Test;
 
@@ -163,7 +164,7 @@ public class SolrCoreTest extends SolrTestCaseJ4 {
 
     final int LOOP = 100;
     final int MT = 16;
-    ExecutorService service = Executors.newFixedThreadPool(MT);
+    ExecutorService service = Executors.newFixedThreadPool(MT, new DefaultSolrThreadFactory("refCountMT"));
     List<Callable<Integer>> callees = new ArrayList<Callable<Integer>>(MT);
     final CoreContainer cores = h.getCoreContainer();
     for (int i = 0; i < MT; ++i) {
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
index 53f851f..33a729d 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
@@ -49,6 +49,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SolrjNamedThreadFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -71,7 +72,8 @@ public class ConcurrentUpdateSolrServer extends SolrServer {
       .getLogger(ConcurrentUpdateSolrServer.class);
   private HttpSolrServer server;
   final BlockingQueue<UpdateRequest> queue;
-  final ExecutorService scheduler = Executors.newCachedThreadPool();
+  final ExecutorService scheduler = Executors.newCachedThreadPool(
+      new SolrjNamedThreadFactory("concurrentUpdateScheduler"));
   final Queue<Runner> runners;
   volatile CountDownLatch lock = null; // used to block everything
   final int threadCount;
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
index c4c5467..bc124d9 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
@@ -21,6 +21,7 @@ import org.apache.solr.client.solrj.*;
 import org.apache.solr.client.solrj.response.QueryResponse;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SolrjNamedThreadFactory;
 import org.apache.solr.common.SolrException;
 
 import java.io.IOException;
@@ -397,7 +398,7 @@ public class LBHttpSolrServer extends SolrServer {
   public void setSoTimeout(int timeout) {
     HttpClientUtil.setSoTimeout(httpClient, timeout);
   }
-  
+
   @Override
   public void shutdown() {
     if (aliveCheckExecutor != null) {
@@ -555,7 +556,8 @@ public class LBHttpSolrServer extends SolrServer {
     if (aliveCheckExecutor == null) {
       synchronized (this) {
         if (aliveCheckExecutor == null) {
-          aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor();
+          aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor(
+              new SolrjNamedThreadFactory("aliveCheckExecutor"));
           aliveCheckExecutor.scheduleAtFixedRate(
                   getAliveCheckRunner(new WeakReference<LBHttpSolrServer>(this)),
                   this.interval, this.interval, TimeUnit.MILLISECONDS);
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java b/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java
new file mode 100644
index 0000000..de9042f
--- /dev/null
+++ b/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java
@@ -0,0 +1,49 @@
+package org.apache.solr.common.util;
+
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class SolrjNamedThreadFactory implements ThreadFactory {
+  private static final AtomicInteger poolNumber = new AtomicInteger(1);
+  private final ThreadGroup group;
+  private final AtomicInteger threadNumber = new AtomicInteger(1);
+  private final String prefix;
+
+  public SolrjNamedThreadFactory(String namePrefix) {
+      SecurityManager s = System.getSecurityManager();
+      group = (s != null)? s.getThreadGroup() :
+                           Thread.currentThread().getThreadGroup();
+      prefix = namePrefix + "-" +
+                    poolNumber.getAndIncrement() +
+                   "-thread-";
+  }
+
+  public Thread newThread(Runnable r) {
+      Thread t = new Thread(group, r,
+                            prefix + threadNumber.getAndIncrement(),
+                            0);
+
+      t.setDaemon(false);
+      
+      if (t.getPriority() != Thread.NORM_PRIORITY)
+          t.setPriority(Thread.NORM_PRIORITY);
+      return t;
+  }
+}
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java b/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
index 3025ae5..5e77cf5 100644
--- a/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
+++ b/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
@@ -19,9 +19,12 @@ package org.apache.zookeeper;
 
 import java.io.IOException;
 import java.nio.channels.SocketChannel;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // we use this class to expose nasty stuff for tests
 public class SolrZooKeeper extends ZooKeeper {
+  List<Thread> spawnedThreads = new CopyOnWriteArrayList<Thread>();
 
   public SolrZooKeeper(String connectString, int sessionTimeout,
       Watcher watcher) throws IOException {
@@ -38,21 +41,32 @@ public class SolrZooKeeper extends ZooKeeper {
    * @param ms the number of milliseconds to pause.
    */
   public void pauseCnxn(final long ms) {
-    new Thread() {
+    Thread t = new Thread() {
       public void run() {
-        synchronized (cnxn) {
-          try {
+        try {
+          synchronized (cnxn) {
             try {
               ((SocketChannel) cnxn.sendThread.sockKey.channel()).socket()
                   .close();
             } catch (Exception e) {
-
             }
             Thread.sleep(ms);
-          } catch (InterruptedException e) {}
-        }
+          }
+
+          // Wait a long while to make sure we properly clean up these threads.
+          Thread.sleep(500000);
+        } catch (InterruptedException e) {}
       }
-    }.start();
+    };
+    t.start();
+    spawnedThreads.add(t);
   }
 
+  @Override
+  public synchronized void close() throws InterruptedException {
+    for (Thread t : spawnedThreads) {
+      t.interrupt();
+    }
+    super.close();
+  }
 }
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java b/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
index 190b9c3..bfd5a72 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
@@ -21,7 +21,9 @@ import junit.framework.Assert;
 import org.apache.commons.io.FileUtils;
 import org.apache.http.client.HttpClient;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.QuickPatchThreadsFilter;
 import org.apache.lucene.util.LuceneTestCase.Slow;
+import org.apache.solr.SolrIgnoredThreadsFilter;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.embedded.JettySolrRunner;
 import org.apache.solr.client.solrj.impl.HttpClientUtil;
@@ -35,6 +37,8 @@ import org.apache.solr.util.AbstractSolrTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -48,6 +52,10 @@ import java.util.Set;
  * @since solr 1.4
  */
 @Slow
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class,
+    QuickPatchThreadsFilter.class
+})
 public class TestLBHttpSolrServer extends LuceneTestCase {
   SolrInstance[] solr = new SolrInstance[3];
   HttpClient httpClient;
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java b/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java
new file mode 100644
index 0000000..85b9e05
--- /dev/null
+++ b/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java
@@ -0,0 +1,60 @@
+package org.apache.solr;
+
+import org.apache.lucene.search.TimeLimitingCollector.TimerThread;
+
+import com.carrotsearch.randomizedtesting.ThreadFilter;
+
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This ignores those threads in Solr for which there is no way to
+ * clean up after a suite.
+ */
+public class SolrIgnoredThreadsFilter implements ThreadFilter {
+  @Override
+  public boolean reject(Thread t) {
+    /*
+     * IMPORTANT! IMPORTANT!
+     * 
+     * Any threads added here should have ABSOLUTELY NO SIDE EFFECTS
+     * (should be stateless). This includes no references to cores or other
+     * test-dependent information.
+     */
+
+    String threadName = t.getName();
+    if (threadName.equals(TimerThread.THREAD_NAME)) {
+      return true;
+    }
+
+    if (threadName.startsWith("facetExecutor-") || 
+        threadName.startsWith("cmdDistribExecutor-") ||
+        threadName.startsWith("httpShardExecutor-")) {
+      return true;
+    }
+
+    // THESE ARE LIKELY BUGS - these threads should be closed!
+    if (threadName.startsWith("Overseer-") ||
+        threadName.startsWith("aliveCheckExecutor-") ||
+        threadName.startsWith("concurrentUpdateScheduler-")) {
+      return true;
+    }
+
+    return false;
+  }
+}
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
index 60d3b6c..c50732e 100755
--- a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
+++ b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
@@ -24,6 +24,7 @@ import java.util.logging.*;
 import javax.xml.xpath.XPathExpressionException;
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.QuickPatchThreadsFilter;
 import org.apache.noggit.*;
 import org.apache.solr.common.*;
 import org.apache.solr.common.cloud.SolrZkClient;
@@ -38,6 +39,7 @@ import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.servlet.DirectSolrConnection;
 import org.apache.solr.util.AbstractSolrTestCase;
+import org.apache.solr.util.RevertDefaultThreadHandlerRule;
 import org.apache.solr.util.TestHarness;
 import org.junit.*;
 import org.junit.rules.RuleChain;
@@ -46,20 +48,25 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.SAXException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
 
 /**
  * A junit4 Solr test harness that extends LuceneTestCaseJ4.
  * Unlike {@link AbstractSolrTestCase}, a new core is not created for each test method.
  */
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class,
+    QuickPatchThreadsFilter.class
+})
 public abstract class SolrTestCaseJ4 extends LuceneTestCase {
   public static int DEFAULT_CONNECTION_TIMEOUT = 1000;  // default socket connection timeout in ms
 
 
   @ClassRule
   public static TestRule solrClassRules = 
-    RuleChain.outerRule(new SystemPropertiesRestoreRule());
+    RuleChain.outerRule(new SystemPropertiesRestoreRule())
+             .around(new RevertDefaultThreadHandlerRule());
 
   @Rule
   public TestRule solrTestRules = 
diff --git a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
index 5d46ba1..7e57630 100644
--- a/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
+++ b/solr/test-framework/src/java/org/apache/solr/cloud/AbstractFullDistribZkTestBase.java
@@ -31,7 +31,9 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.http.params.CoreConnectionPNames;
+import org.apache.lucene.util.LuceneTestCase.BadApple;
 import org.apache.lucene.util.LuceneTestCase.Slow;
+import org.apache.lucene.util.LuceneTestCase.AwaitsFix;
 import org.apache.solr.client.solrj.SolrQuery;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.SolrServerException;
@@ -59,12 +61,12 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * 
  * TODO: we should still test this works as a custom update chain as well as
  * what we test now - the default update chain
- * 
  */
 @Slow
+@BadApple
+@AwaitsFix(bugUrl = "thread leaks") 
 public abstract class AbstractFullDistribZkTestBase extends AbstractDistribZkTestBase {
   static Logger log = LoggerFactory.getLogger(AbstractFullDistribZkTestBase.class);
   
diff --git a/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java b/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
index 6d31774..206ffa0 100644
--- a/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
+++ b/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
@@ -25,6 +25,8 @@ import java.util.*;
 import javax.xml.xpath.XPathExpressionException;
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.QuickPatchThreadsFilter;
+import org.apache.solr.SolrIgnoredThreadsFilter;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.*;
 import org.apache.solr.common.params.CommonParams;
@@ -38,7 +40,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.SAXException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
 
 /**
@@ -54,6 +56,10 @@ import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
  * @see #setUp
  * @see #tearDown
  */
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class,
+    QuickPatchThreadsFilter.class
+})
 public abstract class AbstractSolrTestCase extends LuceneTestCase {
   protected SolrConfig solrConfig;
 
@@ -98,7 +104,8 @@ public abstract class AbstractSolrTestCase extends LuceneTestCase {
   
   @ClassRule
   public static TestRule solrClassRules = 
-    RuleChain.outerRule(new SystemPropertiesRestoreRule());
+    RuleChain.outerRule(new SystemPropertiesRestoreRule())
+             .around(new RevertDefaultThreadHandlerRule());
 
   @Rule
   public TestRule solrTestRules = 
diff --git a/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java b/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java
new file mode 100644
index 0000000..f805a1a
--- /dev/null
+++ b/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java
@@ -0,0 +1,54 @@
+package org.apache.solr.util;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import com.carrotsearch.randomizedtesting.rules.StatementAdapter;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public final class RevertDefaultThreadHandlerRule implements TestRule {
+  private final static AtomicBoolean applied = new AtomicBoolean();
+  
+  @Override
+  public Statement apply(Statement s, Description d) {
+    return new StatementAdapter(s) {
+      @Override
+      protected void before() throws Throwable {
+        if (!applied.getAndSet(true)) {
+          UncaughtExceptionHandler p = Thread.getDefaultUncaughtExceptionHandler();
+          try {
+            // Try to initialize a zookeeper class that reinitializes default exception handler.
+            Class<?> cl = org.apache.zookeeper.server.NIOServerCnxn.Factory.class;
+            // Make sure static initializers have been called.
+            Class.forName(cl.getName(), true, cl.getClassLoader());
+          } finally {
+            if (p == Thread.getDefaultUncaughtExceptionHandler()) {
+              throw new RuntimeException("Zookeeper no longer resets default thread handler.");
+            }
+            Thread.setDefaultUncaughtExceptionHandler(p);
+          }
+        }
+      }
+    };
+  }
+}

