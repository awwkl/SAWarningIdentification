GitDiffStart: 77f2a49896dc33d5e919eddeffd95f042f76a162 | Wed Aug 1 18:36:45 2007 +0000
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java
index f8092b5..e48664b 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java
@@ -17,9 +17,10 @@
 
 package org.apache.solr.client.solrj;
 
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.params.HighlightParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.SolrParams;
 
 
 /**
@@ -47,7 +48,7 @@ public class SolrQuery extends ModifiableSolrParams
    */
   public SolrQuery(String q) {
     this();
-    this.set(SolrParams.Q, q);
+    this.set(CommonParams.Q, q);
   }
 
 
@@ -56,8 +57,8 @@ public class SolrQuery extends ModifiableSolrParams
    * @param f the field name from the IndexSchema
    */
   public void addFacetField(String f) {
-    this.add(SolrParams.FACET_FIELD, f);
-    this.set(SolrParams.FACET, true);
+    this.add(FacetParams.FACET_FIELD, f);
+    this.set(FacetParams.FACET, true);
     this.setFacetMinCount(1);
   }
 
@@ -66,15 +67,15 @@ public class SolrQuery extends ModifiableSolrParams
    * @return string array of facet fields or null if not set/empty
    */
   public String[] getFacetFields() {
-    return this.getParams(SolrParams.FACET_FIELD);
+    return this.getParams(FacetParams.FACET_FIELD);
   }
 
   /** remove a facet field
    * 
    */
   public boolean removeFacetField(String name) {
-    boolean b = this.remove(SolrParams.FACET_FIELD, name);
-    if (this.get(SolrParams.FACET_FIELD) == null && this.get(SolrParams.FACET_QUERY) == null) {
+    boolean b = this.remove(FacetParams.FACET_FIELD, name);
+    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
       this.setFacet(false);
     }
     return b;
@@ -86,30 +87,30 @@ public class SolrQuery extends ModifiableSolrParams
    */
   public void setFacet(boolean b) {
     if (b) {
-      this.set(SolrParams.FACET, true);
+      this.set(FacetParams.FACET, true);
     } else {
-      this.remove(SolrParams.FACET);
-      this.remove(SolrParams.FACET_MINCOUNT);
-      this.remove(SolrParams.FACET_FIELD);
-      this.remove(SolrParams.FACET_LIMIT);
-      this.remove(SolrParams.FACET_MISSING);
-      this.remove(SolrParams.FACET_OFFSET);
-      this.remove(SolrParams.FACET_PREFIX);
-      this.remove(SolrParams.FACET_QUERY);
-      this.remove(SolrParams.FACET_SORT);
-      this.remove(SolrParams.FACET_ZEROS);
-      this.remove(SolrParams.FACET_PREFIX); // does not include the individual fields...
+      this.remove(FacetParams.FACET);
+      this.remove(FacetParams.FACET_MINCOUNT);
+      this.remove(FacetParams.FACET_FIELD);
+      this.remove(FacetParams.FACET_LIMIT);
+      this.remove(FacetParams.FACET_MISSING);
+      this.remove(FacetParams.FACET_OFFSET);
+      this.remove(FacetParams.FACET_PREFIX);
+      this.remove(FacetParams.FACET_QUERY);
+      this.remove(FacetParams.FACET_SORT);
+      this.remove(FacetParams.FACET_ZEROS);
+      this.remove(FacetParams.FACET_PREFIX); // does not include the individual fields...
     }
   }
   
   public void setFacetPrefix( String prefix )
   {
-    this.set( SolrParams.FACET_PREFIX, prefix );
+    this.set( FacetParams.FACET_PREFIX, prefix );
   }
 
   public void setFacetPrefix( String field, String prefix )
   {
-    this.set( "f."+field+"."+SolrParams.FACET_PREFIX, prefix );
+    this.set( "f."+field+"."+FacetParams.FACET_PREFIX, prefix );
   }
 
   /** add a faceting query
@@ -117,7 +118,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @param f facet query
    */
   public void addFacetQuery(String f) {
-    this.add(SolrParams.FACET_QUERY, f);
+    this.add(FacetParams.FACET_QUERY, f);
   }
 
   /** get facet queries
@@ -125,7 +126,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @return all facet queries or null if not set/empty
    */
   public String[] getFacetQuery() {
-    return this.getParams(SolrParams.FACET_QUERY);
+    return this.getParams(FacetParams.FACET_QUERY);
   }
 
   /** remove a facet query
@@ -134,8 +135,8 @@ public class SolrQuery extends ModifiableSolrParams
    * @return true if the facet query was removed false otherwise
    */
   public boolean removeFacetQuery(String q) {
-    boolean b = this.remove(SolrParams.FACET_QUERY, q);
-    if (this.get(SolrParams.FACET_FIELD) == null && this.get(SolrParams.FACET_QUERY) == null) {
+    boolean b = this.remove(FacetParams.FACET_QUERY, q);
+    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
       this.setFacet(false);
     }
     return b;
@@ -146,7 +147,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @param lim number facet items to return
    */
   public void setFacetLimit(int lim) {
-    this.set(SolrParams.FACET_LIMIT, lim);
+    this.set(FacetParams.FACET_LIMIT, lim);
   }
 
   /** get current facet limit
@@ -154,7 +155,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @return facet limit or default of 25
    */
   public int getFacetLimit() {
-    return this.getInt(SolrParams.FACET_LIMIT, 25);
+    return this.getInt(FacetParams.FACET_LIMIT, 25);
   }
 
   /** set facet minimum count
@@ -162,7 +163,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @param cnt facets having less that cnt hits will be excluded from teh facet list
    */
   public void setFacetMinCount(int cnt) {
-    this.set(SolrParams.FACET_MINCOUNT, cnt);
+    this.set(FacetParams.FACET_MINCOUNT, cnt);
   }
 
   /** get facet minimum count
@@ -170,11 +171,11 @@ public class SolrQuery extends ModifiableSolrParams
    * @return facet minimum count or default of 1
    */
   public int getFacetMinCount() {
-    return this.getInt(SolrParams.FACET_LIMIT, 1);
+    return this.getInt(FacetParams.FACET_LIMIT, 1);
   }
 
   public void setMissing(String fld) {
-    this.set(SolrParams.FACET_MISSING, fld);
+    this.set(FacetParams.FACET_MISSING, fld);
   }
 
   /** get facet sort
@@ -182,7 +183,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @return facet sort or default of true
    */
   public boolean getFacetSort() {
-    return this.getBool(SolrParams.FACET_SORT, false);
+    return this.getBool(FacetParams.FACET_SORT, false);
   }
 
   /** set facet sort
@@ -190,7 +191,7 @@ public class SolrQuery extends ModifiableSolrParams
    * @param sort sort facets
    */
   public void setFacetSort(Boolean sort) {
-    this.set(SolrParams.FACET_SORT, sort);
+    this.set(FacetParams.FACET_SORT, sort);
   }
 
   /** add highlight field
@@ -264,17 +265,17 @@ public class SolrQuery extends ModifiableSolrParams
   }
 
   public void addSortField(String field, ORDER order) {
-    addValueToParam(SolrParams.SORT, toSortString(field, order));
+    addValueToParam(CommonParams.SORT, toSortString(field, order));
   }
 
   public void removeSortField(String field, ORDER order) {
-    String s = this.get(SolrParams.SORT);
+    String s = this.get(CommonParams.SORT);
     String removeSort = toSortString(field, order);
     if (s != null) {
       String[] sorts = s.split(",");
       s = join(sorts, ", ", removeSort);
       if (s.length()==0) s=null;
-      this.set(SolrParams.SORT, s);
+      this.set(CommonParams.SORT, s);
     }
   }
   
@@ -285,23 +286,23 @@ public class SolrQuery extends ModifiableSolrParams
   }
 
   public String getSortField() {
-    return this.get(SolrParams.SORT);
+    return this.get(CommonParams.SORT);
   }
 
   public void setFilterQueries(String ... fq) {
-    this.set(SolrParams.FQ, fq);
+    this.set(CommonParams.FQ, fq);
   }
 
   public void addFilterQuery(String ... fq) {
-    this.add(SolrParams.FQ, fq);
+    this.add(CommonParams.FQ, fq);
   }
 
   public boolean removeFilterQuery(String fq) {
-    return this.remove(SolrParams.FQ, fq);
+    return this.remove(CommonParams.FQ, fq);
   }
 
   public String[] getFilterQueries() {
-    return this.getParams(SolrParams.FQ);
+    return this.getParams(CommonParams.FQ);
   }
   
   public boolean getHighlight() {
@@ -324,15 +325,15 @@ public class SolrQuery extends ModifiableSolrParams
   }
 
   public void setFields(String ... fields) {
-    this.set(SolrParams.FL, fields);
+    this.set(CommonParams.FL, fields);
   }
     
   public void addField(String field) {
-    addValueToParam(SolrParams.FL, field);
+    addValueToParam(CommonParams.FL, field);
   }
 
   public String getFields() {
-    String fields = this.get(SolrParams.FL);
+    String fields = this.get(CommonParams.FL);
     if (fields!=null && fields.equals("score")) {
       fields = "*, score";
     }
@@ -341,39 +342,39 @@ public class SolrQuery extends ModifiableSolrParams
 
   public void setIncludeScore(boolean includeScore) {
     if (includeScore) {
-      this.add(SolrParams.FL, "score");
+      this.add(CommonParams.FL, "score");
     } else {
-      this.remove(SolrParams.FL, "score");
+      this.remove(CommonParams.FL, "score");
     }
   }
 
   public void setQuery(String query) {
-    this.set(SolrParams.Q, query);
+    this.set(CommonParams.Q, query);
   }
 
   public void setRows(Integer rows) {
-    this.set(SolrParams.ROWS, rows);
+    this.set(CommonParams.ROWS, rows);
   }
 
   public void setShowDebugInfo(boolean showDebugInfo) {
-    this.set(SolrParams.DEBUG_QUERY, String.valueOf(showDebugInfo));
+    this.set(CommonParams.DEBUG_QUERY, String.valueOf(showDebugInfo));
   }
 
 // use addSortField( sort, order 
 //  public void setSort(String ... sort) {
-//    this.set(SolrParams.SORT, sort);
+//    this.set(CommonParams.SORT, sort);
 //  }
 
   public void setStart(Integer start) {
-    this.set(SolrParams.START, start);
+    this.set(CommonParams.START, start);
   }
 
   public void setQueryType(String qt) {
-    this.set(SolrParams.QT, qt);
+    this.set(CommonParams.QT, qt);
   }
 
   public String getQueryType() {
-    return this.get(SolrParams.QT);
+    return this.get(CommonParams.QT);
   }
 
   public void setParam(String name, String ... values) {
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
index 096e3a8..e24286b 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
@@ -27,6 +27,7 @@ import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.impl.BaseSolrServer;
 import org.apache.solr.client.solrj.impl.XMLResponseParser;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.DefaultSolrParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
@@ -65,8 +66,8 @@ public class EmbeddedSolrServer extends BaseSolrServer
     _processor = new XMLResponseParser();
 
     _invariantParams = new ModifiableSolrParams();
-    _invariantParams.set( SolrParams.WT, _processor.getWriterType() );
-    _invariantParams.set( SolrParams.VERSION, "2.2" );
+    _invariantParams.set( CommonParams.WT, _processor.getWriterType() );
+    _invariantParams.set( CommonParams.VERSION, "2.2" );
   }
 
   public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException 
@@ -88,7 +89,7 @@ public class EmbeddedSolrServer extends BaseSolrServer
     SolrRequestHandler handler = core.getRequestHandler( path );
     if( handler == null ) {
       if( "/select".equals( path ) || "/select/".equalsIgnoreCase( path) ) {
-        String qt = params.get( SolrParams.QT );
+        String qt = params.get( CommonParams.QT );
         handler = core.getRequestHandler( qt );
         if( handler == null ) {
           throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
index e10a36e..48fcebb 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
@@ -44,6 +44,7 @@ import org.apache.solr.client.solrj.SolrRequest;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.util.ClientUtils;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.DefaultSolrParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
@@ -95,8 +96,8 @@ public class CommonsHttpSolrServer extends BaseSolrServer
 
     // TODO -- expose these so that people can add things like 'u' & 'p'
     _invariantParams = new ModifiableSolrParams();
-    _invariantParams.set( SolrParams.WT, _processor.getWriterType() );
-    _invariantParams.set( SolrParams.VERSION, "2.2" );
+    _invariantParams.set( CommonParams.WT, _processor.getWriterType() );
+    _invariantParams.set( CommonParams.VERSION, "2.2" );
   }
 
   //------------------------------------------------------------------------
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java
index cd58746..4146c99 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java
@@ -25,6 +25,7 @@ import java.util.List;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.response.LukeResponse;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
@@ -79,7 +80,7 @@ public class LukeRequest extends RequestBase
   public SolrParams getParams() {
     ModifiableSolrParams params = new ModifiableSolrParams();
     if( fields != null && fields.size() > 0 ) {
-      params.add( SolrParams.FL, fields.toArray( new String[fields.size()] ) );
+      params.add( CommonParams.FL, fields.toArray( new String[fields.size()] ) );
     }
     if( count >= 0 ) {
       params.add( "count", count+"" );
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java
index 04bda6c..8876c2d 100644
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java
+++ b/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java
@@ -22,6 +22,7 @@ import java.util.Collection;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
 
@@ -50,7 +51,7 @@ public class QueryRequest extends RequestBase
    */
   @Override
   public String getPath() {
-    String qt = query.get( SolrParams.QT );
+    String qt = query.get( CommonParams.QT );
     if( qt == null ) {
       qt = super.getPath();
     }
diff --git a/src/java/org/apache/solr/common/params/CommonParams.java b/src/java/org/apache/solr/common/params/CommonParams.java
index 794bf63..4bb754b 100755
--- a/src/java/org/apache/solr/common/params/CommonParams.java
+++ b/src/java/org/apache/solr/common/params/CommonParams.java
@@ -17,116 +17,96 @@
 
 package org.apache.solr.common.params;
 
-import org.apache.solr.common.util.NamedList;
-
-import java.util.logging.Logger;
 
 /**
- * A collection on common params, both for Plugin initialization and
- * for Requests.
+ * Parameters used across many handlers
  */
-@Deprecated
-public class CommonParams {
+public interface CommonParams {
 
-  public static Logger log = Logger.getLogger(CommonParams.class.getName());
+  /** the query type - which query handler should handle the request */
+  public static final String QT ="qt";
+  
+  /** the response writer type - the format of the response */
+  public static final String WT ="wt";
+  
+  /** query string */
+  public static final String Q ="q";
+  
+  /** sort order */
+  public static final String SORT ="sort";
+  
+  /** Lucene query string(s) for filtering the results without affecting scoring */
+  public static final String FQ ="fq";
+  
+  /** zero based offset of matching documents to retrieve */
+  public static final String START ="start";
+  
+  /** number of documents to return starting at "start" */
+  public static final String ROWS ="rows";
+  
+  /** stylesheet to apply to XML results */
+  public static final String XSL ="xsl";
+  
+  /** stylesheet to apply to XML results */
+  public static final String VERSION ="version";
+  
+  /** query and init param for field list */
+  public static final String FL = "fl";
   
-  @Deprecated
-  public static String FL = "fl";
   /** default query field */
-  @Deprecated
-  public static String DF = "df";
+  public static final String DF = "df";
+  
   /** whether to include debug data */
-  @Deprecated
-  public static String DEBUG_QUERY = "debugQuery";
+  public static final String DEBUG_QUERY = "debugQuery";
+  
   /** another query to explain against */
-  @Deprecated
-  public static String EXPLAIN_OTHER = "explainOther";
-
-
-  /** the default field list to be used */
-  public String fl = null;
-  /** the default field to query */
-  public String df = null;
-  /** do not debug by default **/
-  public String debugQuery = null;
-  /** no default other explanation query **/
-  public String explainOther = null;
-  /** whether to highlight */
-  public boolean highlight = false;
-  /** fields to highlight */
-  public String highlightFields = null;
-  /** maximum highlight fragments to return */
-  public int maxSnippets = 1;
-  /** override default highlight Formatter class */
-  public String highlightFormatterClass = null;
-
-
-  public CommonParams() {
-    /* :NOOP: */
-  }
+  public static final String EXPLAIN_OTHER = "explainOther";
+  
 
-  /** @see #setValues */
-  public CommonParams(NamedList args) {
-    this();
-    setValues(args);
-  }
+  /** If the content stream should come from a URL (using URLConnection) */
+  public static final String STREAM_URL = "stream.url";
 
-  /**
-   * Sets the params using values from a NamedList, usefull in the
-   * init method for your handler.
-   *
-   * <p>
-   * If any param is not of the expected type, a severe error is
-   * logged,and the param is skipped.
-   * </p>
-   *
-   * <p>
-   * If any param is not of in the NamedList, it is skipped and the
-   * old value is left alone.
-   * </p>
-   *
+  /** If the content stream should come from a File (using FileReader) */
+  public static final String STREAM_FILE = "stream.file";
+  
+  /** If the content stream should come directly from a field */
+  public static final String STREAM_BODY = "stream.body";
+  
+  /** 
+   * Explicitly set the content type for the input stream
+   * If multiple streams are specified, the explicit contentType
+   * will be used for all of them.  
    */
-  public void setValues(NamedList args) {
-
-    Object tmp;
-
-    tmp = args.get(SolrParams.FL);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        fl = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + SolrParams.FL);
-      }
-    }
-
-    tmp = args.get(SolrParams.DF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        df = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + SolrParams.DF);
-      }
-    }
-
-    tmp = args.get(SolrParams.DEBUG_QUERY);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        debugQuery = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + SolrParams.DEBUG_QUERY);
-      }
-    }
-
-    tmp = args.get(SolrParams.EXPLAIN_OTHER);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        explainOther = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + SolrParams.EXPLAIN_OTHER);
+  public static final String STREAM_CONTENTTYPE = "stream.contentType";
+    
+  
+  /** 'true' if the header should include the handler name */
+  public static final String HEADER_ECHO_HANDLER = "echoHandler";
+  
+  /** include the parameters in the header **/
+  public static final String HEADER_ECHO_PARAMS = "echoParams";
+  
+  /** valid values for: <code>echoParams</code> */
+  public enum EchoParamStyle {
+    EXPLICIT,
+    ALL,
+    NONE;
+    
+    public static EchoParamStyle get( String v ) {
+      if( v != null ) {
+        v = v.toUpperCase();
+        if( v.equals( "EXPLICIT" ) ) {
+          return EXPLICIT;
+        }
+        if( v.equals( "ALL") ) {
+          return ALL;
+        }
+        if( v.equals( "NONE") ) {  // the same as nothing...
+          return NONE;
+        }
       }
+      return null;
     }
-
-  }
-
+  };
 }
 
diff --git a/src/java/org/apache/solr/common/params/DisMaxParams.java b/src/java/org/apache/solr/common/params/DisMaxParams.java
index 0382842..6354225 100755
--- a/src/java/org/apache/solr/common/params/DisMaxParams.java
+++ b/src/java/org/apache/solr/common/params/DisMaxParams.java
@@ -17,189 +17,50 @@
 
 package org.apache.solr.common.params;
 
-import org.apache.solr.common.util.NamedList;
-
-import java.util.logging.Logger;
     
 
 /**
  * A collection of params used in DisMaxRequestHandler,
  * both for Plugin initialization and for Requests.
  */
-public class DisMaxParams extends CommonParams {
+public interface DisMaxParams {
   
-  public static Logger log = Logger.getLogger(CommonParams.class.getName());
-
   /** query and init param for tiebreaker value */
   public static String TIE = "tie";
+  
   /** query and init param for query fields */
   public static String QF = "qf";
+  
   /** query and init param for phrase boost fields */
   public static String PF = "pf";
+  
   /** query and init param for MinShouldMatch specification */
   public static String MM = "mm";
+  
   /**
    * query and init param for Phrase Slop value in phrase
    * boost query (in pf fields)
    */
   public static String PS = "ps";
+  
   /**
    * query and init param for phrase Slop value in phrases
    * explicitly included in the user's query string ( in qf fields)
    */
   public static String QS = "qs";
+  
   /** query and init param for boosting query */
   public static String BQ = "bq";
+  
   /** query and init param for boosting functions */
   public static String BF = "bf";
+  
   /**
    * Alternate query (expressed in Solr QuerySyntax)
    * to use if main query (q) is empty
    */
   public static String ALTQ = "q.alt";
-  /** query and init param for filtering query
-   * @deprecated use SolrParams.FQ or SolrPluginUtils.parseFilterQueries
-   */
-  public static String FQ = "fq";
+  
   /** query and init param for field list */
   public static String GEN = "gen";
-        
-  /**
-   * the default tie breaker to use in DisjunctionMaxQueries
-   * @deprecated - use explicit default with SolrParams.getFloat
-   */
-  public float tiebreaker = 0.0f;
-  /**
-   * the default query fields to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String qf = null;
-  /**
-   * the default phrase boosting fields to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String pf = null;
-  /**
-   * the default min should match to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String mm = "100%";
-  /**
-   * the default phrase slop to be used 
-   * @deprecated - use explicit default with SolrParams.getInt
-   */
-  public int pslop = 0;
-  /**
-   * the default boosting query to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String bq = null;
-  /**
-   * the default boosting functions to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String bf = null;
-  /**
-   * the default filtering query to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String fq = null;
-
-
-  /**
-   * Sets the params using values from a NamedList, usefull in the
-   * init method for your handler.
-   *
-   * <p>
-   * If any param is not of the expected type, a severe error is
-   * logged,and the param is skipped.
-   * </p>
-   *
-   * <p>
-   * If any param is not of in the NamedList, it is skipped and the
-   * old value is left alone.
-   * </p>
-   * @deprecated use SolrParams.toSolrParams
-   */
-  public void setValues(NamedList args) {
-
-    super.setValues(args);
-
-    Object tmp;
-
-    tmp = args.get(TIE);
-    if (null != tmp) {
-      if (tmp instanceof Float) {
-        tiebreaker = ((Float)tmp).floatValue();
-      } else {
-        log.severe("init param is not a float: " + TIE);
-      }
-    }
-
-    tmp = args.get(QF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        qf = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + QF);
-      }
-    }
-
-    tmp = args.get(PF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        pf = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + PF);
-      }
-    }
-
-        
-    tmp = args.get(MM);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        mm = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + MM);
-      }
-    }
-        
-    tmp = args.get(PS);
-    if (null != tmp) {
-      if (tmp instanceof Integer) {
-        pslop = ((Integer)tmp).intValue();
-      } else {
-        log.severe("init param is not an int: " + PS);
-      }
-    }
-
-    tmp = args.get(BQ);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        bq = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + BQ);
-      }
-    }
- 
-    tmp = args.get(BF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        bf = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + BF);
-      }
-    }
- 
-    tmp = args.get(FQ);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        fq = tmp.toString();
-      } else {
-        log.severe("init param is not a str: " + FQ);
-      }
-    }
-                
-  }
-
 }
diff --git a/src/java/org/apache/solr/common/params/FacetParams.java b/src/java/org/apache/solr/common/params/FacetParams.java
new file mode 100644
index 0000000..691a0f6
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/FacetParams.java
@@ -0,0 +1,162 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.SolrException;
+
+
+/**
+ * Facet parameters
+ */
+public interface FacetParams {
+
+  /**
+   * Should facet counts be calculated?
+   */
+  public static final String FACET = "facet";
+  
+  /**
+   * Any lucene formated queries the user would like to use for
+   * Facet Constraint Counts (multi-value)
+   */
+  public static final String FACET_QUERY = "facet.query";
+  /**
+   * Any field whose terms the user wants to enumerate over for
+   * Facet Constraint Counts (multi-value)
+   */
+  public static final String FACET_FIELD = "facet.field";
+
+  /**
+   * The offset into the list of facets.
+   * Can be overridden on a per field basis.
+   */
+  public static final String FACET_OFFSET = "facet.offset";
+
+  /**
+   * Numeric option indicating the maximum number of facet field counts
+   * be included in the response for each field - in descending order of count.
+   * Can be overridden on a per field basis.
+   */
+  public static final String FACET_LIMIT = "facet.limit";
+
+  /**
+   * Numeric option indicating the minimum number of hits before a facet should
+   * be included in the response.  Can be overridden on a per field basis.
+   */
+  public static final String FACET_MINCOUNT = "facet.mincount";
+
+  /**
+   * Boolean option indicating whether facet field counts of "0" should 
+   * be included in the response.  Can be overridden on a per field basis.
+   */
+  public static final String FACET_ZEROS = "facet.zeros";
+
+  /**
+   * Boolean option indicating whether the response should include a 
+   * facet field count for all records which have no value for the 
+   * facet field. Can be overridden on a per field basis.
+   */
+  public static final String FACET_MISSING = "facet.missing";
+
+  /**
+   * Boolean option: true causes facets to be sorted
+   * by the count, false results in natural index order.
+   */
+  public static final String FACET_SORT = "facet.sort";
+
+  /**
+   * Only return constraints of a facet field with the given prefix.
+   */
+  public static final String FACET_PREFIX = "facet.prefix";
+
+ /**
+   * When faceting by enumerating the terms in a field,
+   * only use the filterCache for terms with a df >= to this parameter.
+   */
+  public static final String FACET_ENUM_CACHE_MINDF = "facet.enum.cache.minDf";
+  /**
+   * Any field whose terms the user wants to enumerate over for
+   * Facet Contraint Counts (multi-value)
+   */
+  public static final String FACET_DATE = "facet.date";
+  /**
+   * Date string indicating the starting point for a date facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_START = "facet.date.start";
+  /**
+   * Date string indicating the endinging point for a date facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_END = "facet.date.end";
+  /**
+   * Date Math string indicating the interval of sub-ranges for a date
+   * facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_GAP = "facet.date.gap";
+  /**
+   * Boolean indicating how counts should be computed if the range
+   * between 'start' and 'end' is not evenly divisible by 'gap'.  If
+   * this value is true, then all counts of ranges involving the 'end'
+   * point will use the exact endpoint specified -- this includes the
+   * 'between' and 'after' counts as well as the last range computed
+   * using the 'gap'.  If the value is false, then 'gap' is used to
+   * compute the effective endpoint closest to the 'end' param which
+   * results in the range between 'start' and 'end' being evenly
+   * divisible by 'gap'.
+   * The default is false.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_HARD_END = "facet.date.hardend";
+  /**
+   * String indicating what "other" ranges should be computed for a
+   * date facet range (multi-value).
+   * Can be overriden on a per field basis.
+   * @see FacetDateOther
+   */
+  public static final String FACET_DATE_OTHER = "facet.date.other";
+
+  /**
+   * An enumeration of the legal values for FACET_DATE_OTHER...
+   * <ul>
+   * <li>before = the count of matches before the start date</li>
+   * <li>after = the count of matches after the end date</li>
+   * <li>between = the count of all matches between start and end</li>
+   * <li>all = all of the above (default value)</li>
+   * <li>none = no additional info requested</li>
+   * </ul>
+   * @see #FACET_DATE_OTHER
+   */
+  public enum FacetDateOther {
+    BEFORE, AFTER, BETWEEN, ALL, NONE;
+    public String toString() { return super.toString().toLowerCase(); }
+    public static FacetDateOther get(String label) {
+      try {
+        return valueOf(label.toUpperCase());
+      } catch (IllegalArgumentException e) {
+        throw new SolrException
+          (SolrException.ErrorCode.BAD_REQUEST,
+           label+" is not a valid type of 'other' date facet information",e);
+      }
+    }
+  }
+  
+
+}
+
diff --git a/src/java/org/apache/solr/common/params/SolrParams.java b/src/java/org/apache/solr/common/params/SolrParams.java
index 8c101b1..7029b7a 100644
--- a/src/java/org/apache/solr/common/params/SolrParams.java
+++ b/src/java/org/apache/solr/common/params/SolrParams.java
@@ -30,209 +30,6 @@ import org.apache.solr.common.util.SimpleOrderedMap;
  * @version $Id$
  */
 public abstract class SolrParams {
-  /** the query type - which query handler should handle the request */
-  public static final String QT ="qt";
-  /** the response writer type - the format of the response */
-  public static final String WT ="wt";
-  /** query string */
-  public static final String Q ="q";
-  /** sort order */
-  public static final String SORT ="sort";
-  /** Lucene query string(s) for filtering the results without affecting scoring */
-  public static final String FQ ="fq";
-  /** zero based offset of matching documents to retrieve */
-  public static final String START ="start";
-  /** number of documents to return starting at "start" */
-  public static final String ROWS ="rows";
-  /** stylesheet to apply to XML results */
-  public static final String XSL ="xsl";
-  /** stylesheet to apply to XML results */
-  public static final String VERSION ="version";
-  /** query and init param for field list */
-  public static final String FL = "fl";
-  /** default query field */
-  public static final String DF = "df";
-  /** whether to include debug data */
-  public static final String DEBUG_QUERY = "debugQuery";
-  /** another query to explain against */
-  public static final String EXPLAIN_OTHER = "explainOther";
-
-  /**
-   * Should facet counts be calculated?
-   */
-  public static final String FACET = "facet";
-  
-  /**
-   * Any lucene formated queries the user would like to use for
-   * Facet Constraint Counts (multi-value)
-   */
-  public static final String FACET_QUERY = "facet.query";
-  /**
-   * Any field whose terms the user wants to enumerate over for
-   * Facet Constraint Counts (multi-value)
-   */
-  public static final String FACET_FIELD = "facet.field";
-
-  /**
-   * The offset into the list of facets.
-   * Can be overridden on a per field basis.
-   */
-  public static final String FACET_OFFSET = "facet.offset";
-
-  /**
-   * Numeric option indicating the maximum number of facet field counts
-   * be included in the response for each field - in descending order of count.
-   * Can be overridden on a per field basis.
-   */
-  public static final String FACET_LIMIT = "facet.limit";
-
-  /**
-   * Numeric option indicating the minimum number of hits before a facet should
-   * be included in the response.  Can be overridden on a per field basis.
-   */
-  public static final String FACET_MINCOUNT = "facet.mincount";
-
-  /**
-   * Boolean option indicating whether facet field counts of "0" should 
-   * be included in the response.  Can be overridden on a per field basis.
-   */
-  public static final String FACET_ZEROS = "facet.zeros";
-
-  /**
-   * Boolean option indicating whether the response should include a 
-   * facet field count for all records which have no value for the 
-   * facet field. Can be overridden on a per field basis.
-   */
-  public static final String FACET_MISSING = "facet.missing";
-
-  /**
-   * Boolean option: true causes facets to be sorted
-   * by the count, false results in natural index order.
-   */
-  public static final String FACET_SORT = "facet.sort";
-
-  /**
-   * Only return constraints of a facet field with the given prefix.
-   */
-  public static final String FACET_PREFIX = "facet.prefix";
-
- /**
-   * When faceting by enumerating the terms in a field,
-   * only use the filterCache for terms with a df >= to this parameter.
-   */
-  public static final String FACET_ENUM_CACHE_MINDF = "facet.enum.cache.minDf";
-  /**
-   * Any field whose terms the user wants to enumerate over for
-   * Facet Contraint Counts (multi-value)
-   */
-  public static final String FACET_DATE = "facet.date";
-  /**
-   * Date string indicating the starting point for a date facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_START = "facet.date.start";
-  /**
-   * Date string indicating the endinging point for a date facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_END = "facet.date.end";
-  /**
-   * Date Math string indicating the interval of sub-ranges for a date
-   * facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_GAP = "facet.date.gap";
-  /**
-   * Boolean indicating how counts should be computed if the range
-   * between 'start' and 'end' is not evenly divisible by 'gap'.  If
-   * this value is true, then all counts of ranges involving the 'end'
-   * point will use the exact endpoint specified -- this includes the
-   * 'between' and 'after' counts as well as the last range computed
-   * using the 'gap'.  If the value is false, then 'gap' is used to
-   * compute the effective endpoint closest to the 'end' param which
-   * results in the range between 'start' and 'end' being evenly
-   * divisible by 'gap'.
-   * The default is false.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_HARD_END = "facet.date.hardend";
-  /**
-   * String indicating what "other" ranges should be computed for a
-   * date facet range (multi-value).
-   * Can be overriden on a per field basis.
-   * @see FacetDateOther
-   */
-  public static final String FACET_DATE_OTHER = "facet.date.other";
-
-  /**
-   * An enumeration of the legal values for FACET_DATE_OTHER...
-   * <ul>
-   * <li>before = the count of matches before the start date</li>
-   * <li>after = the count of matches after the end date</li>
-   * <li>between = the count of all matches between start and end</li>
-   * <li>all = all of the above (default value)</li>
-   * <li>none = no additional info requested</li>
-   * </ul>
-   * @see #FACET_DATE_OTHER
-   */
-  public enum FacetDateOther {
-    BEFORE, AFTER, BETWEEN, ALL, NONE;
-    public String toString() { return super.toString().toLowerCase(); }
-    public static FacetDateOther get(String label) {
-      try {
-        return valueOf(label.toUpperCase());
-      } catch (IllegalArgumentException e) {
-        throw new SolrException
-          (SolrException.ErrorCode.BAD_REQUEST,
-           label+" is not a valid type of 'other' date facet information",e);
-      }
-    }
-  }
-  
-  /** If the content stream should come from a URL (using URLConnection) */
-  public static final String STREAM_URL = "stream.url";
-
-  /** If the content stream should come from a File (using FileReader) */
-  public static final String STREAM_FILE = "stream.file";
-  
-  /** If the content stream should come directly from a field */
-  public static final String STREAM_BODY = "stream.body";
-  
-  /** 
-   * Explicitly set the content type for the input stream
-   * If multiple streams are specified, the explicit contentType
-   * will be used for all of them.  
-   */
-  public static final String STREAM_CONTENTTYPE = "stream.contentType";
-    
-  /** 'true' if the header should include the handler name */
-  public static final String HEADER_ECHO_HANDLER = "echoHandler";
-  
-  /** include the parameters in the header **/
-  public static final String HEADER_ECHO_PARAMS = "echoParams";
-  
-  /** valid values for: <code>echoParams</code> */
-  public enum EchoParamStyle {
-    EXPLICIT,
-    ALL,
-    NONE;
-    
-    public static EchoParamStyle get( String v ) {
-      if( v != null ) {
-        v = v.toUpperCase();
-        if( v.equals( "EXPLICIT" ) ) {
-          return EXPLICIT;
-        }
-        if( v.equals( "ALL") ) {
-          return ALL;
-        }
-        if( v.equals( "NONE") ) {  // the same as nothing...
-          return NONE;
-        }
-      }
-      return null;
-    }
-  };
   
   /** returns the String value of a param, or null if not set */
   public abstract String get(String param);
diff --git a/src/java/org/apache/solr/core/SolrCore.java b/src/java/org/apache/solr/core/SolrCore.java
index 255d94d..e3e3fa8 100644
--- a/src/java/org/apache/solr/core/SolrCore.java
+++ b/src/java/org/apache/solr/core/SolrCore.java
@@ -37,8 +37,9 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.params.SolrParams.EchoParamStyle;
+import org.apache.solr.common.params.CommonParams.EchoParamStyle;
 import org.apache.solr.common.util.DOMUtil;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
@@ -745,16 +746,16 @@ public final class SolrCore {
     responseHeader.add("QTime",qtime);
         
     SolrParams params = req.getParams();
-    if( params.getBool(SolrParams.HEADER_ECHO_HANDLER, false) ) {
+    if( params.getBool(CommonParams.HEADER_ECHO_HANDLER, false) ) {
       responseHeader.add("handler", handler.getName() );
     }
     
     // Values for echoParams... false/true/all or false/explicit/all ???
-    String ep = params.get( SolrParams.HEADER_ECHO_PARAMS, null );
+    String ep = params.get( CommonParams.HEADER_ECHO_PARAMS, null );
     if( ep != null ) {
       EchoParamStyle echoParams = EchoParamStyle.get( ep );
       if( echoParams == null ) {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,"Invalid value '" + ep + "' for " + SolrParams.HEADER_ECHO_PARAMS 
+        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,"Invalid value '" + ep + "' for " + CommonParams.HEADER_ECHO_PARAMS 
             + " parameter, use '" + EchoParamStyle.EXPLICIT + "' or '" + EchoParamStyle.ALL + "'" );
       }
       if( echoParams == EchoParamStyle.EXPLICIT ) {
diff --git a/src/java/org/apache/solr/handler/DisMaxRequestHandler.java b/src/java/org/apache/solr/handler/DisMaxRequestHandler.java
index e9e3cd5..68ff492 100644
--- a/src/java/org/apache/solr/handler/DisMaxRequestHandler.java
+++ b/src/java/org/apache/solr/handler/DisMaxRequestHandler.java
@@ -17,10 +17,6 @@
 
 package org.apache.solr.handler;
 
-import static org.apache.solr.common.params.SolrParams.FACET;
-import static org.apache.solr.common.params.SolrParams.FQ;
-import static org.apache.solr.common.params.SolrParams.Q;
-
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
@@ -34,7 +30,9 @@ import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.DisMaxParams;
+import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
@@ -154,7 +152,7 @@ public class DisMaxRequestHandler extends RequestHandlerBase  {
     /* :NOOP */
   }
   /** shorten the class references for utilities */
-  private static class DMP extends DisMaxParams {
+  private static interface DMP extends DisMaxParams {
     /* :NOOP */
   }
 
@@ -222,7 +220,7 @@ public class DisMaxRequestHandler extends RequestHandlerBase  {
 
       /* * * Main User Query * * */
       Query parsedUserQuery = null;
-      String userQuery = params.get( Q );
+      String userQuery = params.get( CommonParams.Q );
       Query altUserQuery = null;
       if( userQuery == null || userQuery.trim().length() < 1 ) {
         // If no query is specified, we may have an alternate
@@ -315,7 +313,7 @@ public class DisMaxRequestHandler extends RequestHandlerBase  {
       
       DocListAndSet results = new DocListAndSet();
       NamedList facetInfo = null;
-      if (params.getBool(FACET,false)) {
+      if (params.getBool(FacetParams.FACET,false)) {
         results = s.getDocListAndSet(query, restrictions,
                                      SolrPluginUtils.getSort(req),
                                      req.getStart(), req.getLimit(),
@@ -349,7 +347,7 @@ public class DisMaxRequestHandler extends RequestHandlerBase  {
           }
           debug.add("boostfuncs", params.getParams(DMP.BF));
           if (null != restrictions) {
-            debug.add("filter_queries", params.getParams(FQ));
+            debug.add("filter_queries", params.getParams(CommonParams.FQ));
             debug.add("parsed_filter_queries", 
                       QueryParsing.toString(restrictions, req.getSchema()));
           }
diff --git a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
index f529ad2..e055184 100644
--- a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
+++ b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
@@ -17,10 +17,6 @@
 
 package org.apache.solr.handler;
 
-import static org.apache.solr.common.params.SolrParams.DF;
-import static org.apache.solr.common.params.SolrParams.FACET;
-import static org.apache.solr.common.params.SolrParams.FQ;
-
 import java.io.IOException;
 import java.io.Reader;
 import java.net.MalformedURLException;
@@ -40,6 +36,8 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similar.MoreLikeThis;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.MoreLikeThisParams;
@@ -87,7 +85,7 @@ public class MoreLikeThisHandler extends RequestHandlerBase
     // Parse Required Params
     // This will either have a single Reader or valid query
     Reader reader = null;
-    String q = params.get( SolrParams.Q );
+    String q = params.get( CommonParams.Q );
     if( q == null || q.trim().length() <1 ) {
       Iterable<ContentStream> streams = req.getContentStreams();
       if( streams != null ) {
@@ -111,14 +109,14 @@ public class MoreLikeThisHandler extends RequestHandlerBase
       ? null : new ArrayList<InterestingTerm>( mlt.mlt.getMaxQueryTerms() );
     
     // What fields do we need to return
-    String fl = params.get(SolrParams.FL);
+    String fl = params.get(CommonParams.FL);
     int flags = 0; 
     if (fl != null) {
       flags |= SolrPluginUtils.setReturnFields(fl, rsp);
     }
 
-    int start = params.getInt( SolrParams.START, 0 );
-    int rows  = params.getInt( SolrParams.ROWS, 10 );
+    int start = params.getInt( CommonParams.START, 0 );
+    int rows  = params.getInt( CommonParams.ROWS, 10 );
     
     DocListAndSet mltDocs = null;
     
@@ -133,7 +131,7 @@ public class MoreLikeThisHandler extends RequestHandlerBase
       int matchOffset = params.getInt( MoreLikeThisParams.MATCH_OFFSET, 0 );
       
       // Find the base match  
-      Query query = QueryParsing.parseQuery(q, params.get(DF), params, req.getSchema());
+      Query query = QueryParsing.parseQuery(q, params.get(CommonParams.DF), params, req.getSchema());
       DocList match = searcher.getDocList(query, null, null, matchOffset, 1, flags ); // only get the first one...
       if( includeMatch ) {
         rsp.add( "match", match );
@@ -175,7 +173,7 @@ public class MoreLikeThisHandler extends RequestHandlerBase
     }
     
     // maybe facet the results
-    if (params.getBool(FACET,false)) {
+    if (params.getBool(FacetParams.FACET,false)) {
       if( mltDocs.docSet == null ) {
         rsp.add( "facet_counts", null );
       }
@@ -190,7 +188,7 @@ public class MoreLikeThisHandler extends RequestHandlerBase
       NamedList<Object> dbg = SolrPluginUtils.doStandardDebug(req, q, mlt.mltquery, mltDocs.docList );
       if (null != dbg) {
         if (null != filters) {
-          dbg.add("filter_queries",req.getParams().getParams(FQ));
+          dbg.add("filter_queries",req.getParams().getParams(CommonParams.FQ));
           List<String> fqs = new ArrayList<String>(filters.size());
           for (Query fq : filters) {
             fqs.add(QueryParsing.toString(fq, req.getSchema()));
@@ -239,7 +237,7 @@ public class MoreLikeThisHandler extends RequestHandlerBase
       this.searcher = searcher;
       this.reader = searcher.getReader();
       this.uniqueKeyField = searcher.getSchema().getUniqueKeyField();
-      this.needDocSet = params.getBool(FACET,false);
+      this.needDocSet = params.getBool(FacetParams.FACET,false);
       
       SolrParams required = params.required();
       String[] fields = splitList.split( required.get(MoreLikeThisParams.SIMILARITY_FIELDS) );
diff --git a/src/java/org/apache/solr/handler/StandardRequestHandler.java b/src/java/org/apache/solr/handler/StandardRequestHandler.java
index 32853f4..27a34e5 100644
--- a/src/java/org/apache/solr/handler/StandardRequestHandler.java
+++ b/src/java/org/apache/solr/handler/StandardRequestHandler.java
@@ -31,6 +31,8 @@ import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.search.*;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.MoreLikeThisParams;
 import org.apache.solr.common.util.NamedList;
@@ -71,18 +73,18 @@ public class StandardRequestHandler extends RequestHandlerBase {
   {
     
       SolrParams p = req.getParams();
-      String qstr = p.required().get(Q);
+      String qstr = p.required().get(CommonParams.Q);
 
-      String defaultField = p.get(DF);
+      String defaultField = p.get(CommonParams.DF);
 
       // find fieldnames to return (fieldlist)
-      String fl = p.get(SolrParams.FL);
+      String fl = p.get(CommonParams.FL);
       int flags = 0; 
       if (fl != null) {
         flags |= U.setReturnFields(fl, rsp);
       }
       
-      String sortStr = p.get(SORT);
+      String sortStr = p.get(CommonParams.SORT);
       if( sortStr == null ) {  
         // TODO? should we disable the ';' syntax with config?
         // legacy mode, where sreq is query;sort
@@ -117,14 +119,14 @@ public class StandardRequestHandler extends RequestHandlerBase {
       List<Query> filters = U.parseFilterQueries(req);
       SolrIndexSearcher s = req.getSearcher();
 
-      if (p.getBool(FACET,false)) {
+      if (p.getBool(FacetParams.FACET,false)) {
         results = s.getDocListAndSet(query, filters, sort,
-                                     p.getInt(START,0), p.getInt(ROWS,10),
+                                     p.getInt(CommonParams.START,0), p.getInt(CommonParams.ROWS,10),
                                      flags);
         facetInfo = getFacetInfo(req, rsp, results.docSet);
       } else {
         results.docList = s.getDocList(query, filters, sort,
-                                       p.getInt(START,0), p.getInt(ROWS,10),
+                                       p.getInt(CommonParams.START,0), p.getInt(CommonParams.ROWS,10),
                                        flags);
       }
 
@@ -147,7 +149,7 @@ public class StandardRequestHandler extends RequestHandlerBase {
         NamedList dbg = U.doStandardDebug(req, qstr, query, results.docList);
         if (null != dbg) {
           if (null != filters) {
-            dbg.add("filter_queries",req.getParams().getParams(FQ));
+            dbg.add("filter_queries",req.getParams().getParams(CommonParams.FQ));
             List<String> fqs = new ArrayList<String>(filters.size());
             for (Query fq : filters) {
               fqs.add(QueryParsing.toString(fq, req.getSchema()));
diff --git a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
index 583d5d4..fb38136 100644
--- a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
@@ -44,6 +44,7 @@ import org.apache.lucene.search.Sort;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
@@ -134,9 +135,9 @@ public class LukeRequestHandler extends RequestHandlerBase
     else {
       // If no doc is given, show all fields and top terms
       Set<String> fields = null;
-      if( params.get( SolrParams.FL ) != null ) {
+      if( params.get( CommonParams.FL ) != null ) {
         fields = new HashSet<String>();
-        for( String f : params.getParams( SolrParams.FL ) ) {
+        for( String f : params.getParams( CommonParams.FL ) ) {
           fields.add( f );
         }
       }
diff --git a/src/java/org/apache/solr/request/LocalSolrQueryRequest.java b/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
index 113751e..427cf0d 100644
--- a/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
+++ b/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
@@ -17,6 +17,7 @@
 
 package org.apache.solr.request;
 
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MultiMapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
@@ -44,10 +45,10 @@ public class LocalSolrQueryRequest extends SolrQueryRequestBase {
       if (v instanceof String[]) map.put(k,(String[])v);
       else map.put(k,new String[]{v.toString()});
     }
-    if (query!=null) map.put(SolrParams.Q, new String[]{query});
-    if (qtype!=null) map.put(SolrParams.QT, new String[]{qtype});
-    map.put(SolrParams.START, new String[]{Integer.toString(start)});
-    map.put(SolrParams.ROWS, new String[]{Integer.toString(limit)});
+    if (query!=null) map.put(CommonParams.Q, new String[]{query});
+    if (qtype!=null) map.put(CommonParams.QT, new String[]{qtype});
+    map.put(CommonParams.START, new String[]{Integer.toString(start)});
+    map.put(CommonParams.ROWS, new String[]{Integer.toString(limit)});
     return new MultiMapSolrParams(map);
   }
 
diff --git a/src/java/org/apache/solr/request/SimpleFacets.java b/src/java/org/apache/solr/request/SimpleFacets.java
index 767e9db..1528297 100644
--- a/src/java/org/apache/solr/request/SimpleFacets.java
+++ b/src/java/org/apache/solr/request/SimpleFacets.java
@@ -24,12 +24,12 @@ import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.*;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.FacetParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.params.SolrParams.FacetDateOther;
+import org.apache.solr.common.params.FacetParams.FacetDateOther;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrConfig;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.SchemaField;
@@ -84,7 +84,7 @@ public class SimpleFacets {
   public NamedList getFacetCounts() {
 
     // if someone called this method, benefit of the doubt: assume true
-    if (!params.getBool(params.FACET,true))
+    if (!params.getBool(FacetParams.FACET,true))
       return null;
 
     NamedList res = new SimpleOrderedMap();
@@ -118,7 +118,7 @@ public class SimpleFacets {
      */
     SolrQueryParser qp = searcher.getSchema().getSolrQueryParser(null);
 
-    String[] facetQs = params.getParams(SolrParams.FACET_QUERY);
+    String[] facetQs = params.getParams(FacetParams.FACET_QUERY);
     if (null != facetQs && 0 != facetQs.length) {
       for (String q : facetQs) {
         res.add(q, searcher.numDocs(qp.parse(q), docs));
@@ -130,19 +130,19 @@ public class SimpleFacets {
 
 
   public NamedList getTermCounts(String field) throws IOException {
-    int offset = params.getFieldInt(field, params.FACET_OFFSET, 0);
-    int limit = params.getFieldInt(field, params.FACET_LIMIT, 100);
-    Integer mincount = params.getFieldInt(field, params.FACET_MINCOUNT);
+    int offset = params.getFieldInt(field, FacetParams.FACET_OFFSET, 0);
+    int limit = params.getFieldInt(field, FacetParams.FACET_LIMIT, 100);
+    Integer mincount = params.getFieldInt(field, FacetParams.FACET_MINCOUNT);
     if (mincount==null) {
-      Boolean zeros = params.getFieldBool(field, params.FACET_ZEROS);
+      Boolean zeros = params.getFieldBool(field, FacetParams.FACET_ZEROS);
       // mincount = (zeros!=null && zeros) ? 0 : 1;
       mincount = (zeros!=null && !zeros) ? 1 : 0;
       // current default is to include zeros.
     }
-    boolean missing = params.getFieldBool(field, params.FACET_MISSING, false);
+    boolean missing = params.getFieldBool(field, FacetParams.FACET_MISSING, false);
     // default to sorting if there is a limit.
-    boolean sort = params.getFieldBool(field, params.FACET_SORT, limit>0);
-    String prefix = params.getFieldParam(field,params.FACET_PREFIX);
+    boolean sort = params.getFieldBool(field, FacetParams.FACET_SORT, limit>0);
+    String prefix = params.getFieldParam(field,FacetParams.FACET_PREFIX);
 
     NamedList counts;
     SchemaField sf = searcher.getSchema().getField(field);
@@ -172,7 +172,7 @@ public class SimpleFacets {
           throws IOException {
 
     NamedList res = new SimpleOrderedMap();
-    String[] facetFs = params.getParams(SolrParams.FACET_FIELD);
+    String[] facetFs = params.getParams(FacetParams.FACET_FIELD);
     if (null != facetFs) {
       for (String f : facetFs) {
         res.add(f, getTermCounts(f));
@@ -333,7 +333,7 @@ public class SimpleFacets {
     */
 
     // Minimum term docFreq in order to use the filterCache for that term.
-    int minDfFilterCache = params.getFieldInt(field, SolrParams.FACET_ENUM_CACHE_MINDF, 0);
+    int minDfFilterCache = params.getFieldInt(field, FacetParams.FACET_ENUM_CACHE_MINDF, 0);
 
     IndexSchema schema = searcher.getSchema();
     IndexReader r = searcher.getReader();
@@ -422,7 +422,7 @@ public class SimpleFacets {
 
     final SolrParams required = new RequiredSolrParams(params);
     final NamedList resOuter = new SimpleOrderedMap();
-    final String[] fields = params.getParams(SolrParams.FACET_DATE);
+    final String[] fields = params.getParams(FacetParams.FACET_DATE);
     final Date NOW = new Date();
     
     if (null == fields || 0 == fields.length) return resOuter;
@@ -439,7 +439,7 @@ public class SimpleFacets {
       }
       final DateField ft = (DateField) trash;
       final String startS
-        = required.getFieldParam(f,SolrParams.FACET_DATE_START);
+        = required.getFieldParam(f,FacetParams.FACET_DATE_START);
       final Date start;
       try {
         start = ft.parseMath(NOW, startS);
@@ -449,7 +449,7 @@ public class SimpleFacets {
            "date facet 'start' is not a valid Date string: " + startS, e);
       }
       final String endS
-        = required.getFieldParam(f,SolrParams.FACET_DATE_END);
+        = required.getFieldParam(f,FacetParams.FACET_DATE_END);
       Date end; // not final, hardend may change this
       try {
         end = ft.parseMath(NOW, endS);
@@ -465,7 +465,7 @@ public class SimpleFacets {
            "date facet 'end' comes before 'start': "+endS+" < "+startS);
       }
 
-      final String gap = required.getFieldParam(f,SolrParams.FACET_DATE_GAP);
+      final String gap = required.getFieldParam(f,FacetParams.FACET_DATE_GAP);
       final DateMathParser dmp = new DateMathParser(ft.UTC, Locale.US);
       dmp.setNow(NOW);
       
@@ -478,7 +478,7 @@ public class SimpleFacets {
           final String label = ft.indexedToReadable(lowI);
           Date high = dmp.parseMath(gap);
           if (end.before(high)) {
-            if (params.getFieldBool(f,SolrParams.FACET_DATE_HARD_END,false)) {
+            if (params.getFieldBool(f,FacetParams.FACET_DATE_HARD_END,false)) {
               high = end;
             } else {
               end = high;
@@ -504,7 +504,7 @@ public class SimpleFacets {
       resInner.add("end", end);
 
       final String[] othersP =
-        params.getFieldParams(f,SolrParams.FACET_DATE_OTHER);
+        params.getFieldParams(f,FacetParams.FACET_DATE_OTHER);
       if (null != othersP && 0 < othersP.length ) {
         Set<FacetDateOther> others = EnumSet.noneOf(FacetDateOther.class);
 
diff --git a/src/java/org/apache/solr/request/SolrParams.java b/src/java/org/apache/solr/request/SolrParams.java
index 20dc184..909f5c5 100644
--- a/src/java/org/apache/solr/request/SolrParams.java
+++ b/src/java/org/apache/solr/request/SolrParams.java
@@ -17,12 +17,17 @@
 
 package org.apache.solr.request;
 
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.FacetParams;
+
 
 /**
  * This class is scheduled for deletion.  Please update your code to the moved package.
  */
 @Deprecated
-public abstract class SolrParams extends org.apache.solr.common.params.SolrParams {
+public abstract class SolrParams extends org.apache.solr.common.params.SolrParams
+ implements FacetParams, CommonParams // keep the same constants it used to have
+{
   
 }
 
diff --git a/src/java/org/apache/solr/request/SolrQueryRequestBase.java b/src/java/org/apache/solr/request/SolrQueryRequestBase.java
index ed245d8..df30f58 100644
--- a/src/java/org/apache/solr/request/SolrQueryRequestBase.java
+++ b/src/java/org/apache/solr/request/SolrQueryRequestBase.java
@@ -21,6 +21,7 @@ import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.util.RefCounted;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrCore;
@@ -135,24 +136,24 @@ public abstract class SolrQueryRequestBase implements SolrQueryRequest {
 
   @Deprecated
   public String getQueryString() {
-    return params.get(SolrParams.Q);
+    return params.get(CommonParams.Q);
   }
 
   @Deprecated
   public String getQueryType() {
-    return params.get(SolrParams.QT);
+    return params.get(CommonParams.QT);
   }
 
   // starting position in matches to return to client
   @Deprecated
   public int getStart() {
-    return params.getInt(SolrParams.START, 0);
+    return params.getInt(CommonParams.START, 0);
   }
 
   // number of matching documents to return
   @Deprecated
   public int getLimit() {
-    return params.getInt(SolrParams.ROWS, 10);
+    return params.getInt(CommonParams.ROWS, 10);
   }
 
 
diff --git a/src/java/org/apache/solr/util/CommonParams.java b/src/java/org/apache/solr/util/CommonParams.java
index e0bc926..617cef0 100644
--- a/src/java/org/apache/solr/util/CommonParams.java
+++ b/src/java/org/apache/solr/util/CommonParams.java
@@ -17,11 +17,105 @@
 
 package org.apache.solr.util;
 
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+
+import java.util.logging.Logger;
+
 /**
- * This class is scheduled for deletion.  Please update your code to the moved package.
+ * A collection on common params, both for Plugin initialization and
+ * for Requests.
  */
 @Deprecated
-public class CommonParams extends org.apache.solr.common.params.CommonParams {
+public class CommonParams implements org.apache.solr.common.params.CommonParams {
+
+  public static Logger log = Logger.getLogger(CommonParams.class.getName());
+  
+
+  /** the default field list to be used */
+  public String fl = null;
+  /** the default field to query */
+  public String df = null;
+  /** do not debug by default **/
+  public String debugQuery = null;
+  /** no default other explanation query **/
+  public String explainOther = null;
+  /** whether to highlight */
+  public boolean highlight = false;
+  /** fields to highlight */
+  public String highlightFields = null;
+  /** maximum highlight fragments to return */
+  public int maxSnippets = 1;
+  /** override default highlight Formatter class */
+  public String highlightFormatterClass = null;
+
+
+  public CommonParams() {
+    /* :NOOP: */
+  }
+
+  /** @see #setValues */
+  public CommonParams(NamedList args) {
+    this();
+    setValues(args);
+  }
+
+  /**
+   * Sets the params using values from a NamedList, usefull in the
+   * init method for your handler.
+   *
+   * <p>
+   * If any param is not of the expected type, a severe error is
+   * logged,and the param is skipped.
+   * </p>
+   *
+   * <p>
+   * If any param is not of in the NamedList, it is skipped and the
+   * old value is left alone.
+   * </p>
+   *
+   */
+  public void setValues(NamedList args) {
+
+    Object tmp;
+
+    tmp = args.get(FL);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        fl = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + FL);
+      }
+    }
+
+    tmp = args.get(DF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        df = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + DF);
+      }
+    }
+
+    tmp = args.get(DEBUG_QUERY);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        debugQuery = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + DEBUG_QUERY);
+      }
+    }
+
+    tmp = args.get(EXPLAIN_OTHER);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        explainOther = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + EXPLAIN_OTHER);
+      }
+    }
+
+  }
 
 }
 
diff --git a/src/java/org/apache/solr/util/DisMaxParams.java b/src/java/org/apache/solr/util/DisMaxParams.java
index 05a3a9d..549c9bf 100644
--- a/src/java/org/apache/solr/util/DisMaxParams.java
+++ b/src/java/org/apache/solr/util/DisMaxParams.java
@@ -17,10 +17,160 @@
 
 package org.apache.solr.util;
 
+import java.util.logging.Logger;
+
+import org.apache.solr.common.util.NamedList;
+
 /**
  * This class is scheduled for deletion.  Please update your code to the moved package.
  */
 @Deprecated
-public class DisMaxParams extends org.apache.solr.common.params.DisMaxParams {
+public class DisMaxParams extends CommonParams implements org.apache.solr.common.params.DisMaxParams {
+
+  public static Logger log = Logger.getLogger(DisMaxParams.class.getName());
+
+
+  /** query and init param for filtering query
+   * @deprecated use SolrParams.FQ or SolrPluginUtils.parseFilterQueries
+   */
+  public static String FQ = "fq";
   
+  /**
+   * the default tie breaker to use in DisjunctionMaxQueries
+   * @deprecated - use explicit default with SolrParams.getFloat
+   */
+  public float tiebreaker = 0.0f;
+  /**
+   * the default query fields to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String qf = null;
+  /**
+   * the default phrase boosting fields to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String pf = null;
+  /**
+   * the default min should match to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String mm = "100%";
+  /**
+   * the default phrase slop to be used 
+   * @deprecated - use explicit default with SolrParams.getInt
+   */
+  public int pslop = 0;
+  /**
+   * the default boosting query to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String bq = null;
+  /**
+   * the default boosting functions to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String bf = null;
+  /**
+   * the default filtering query to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String fq = null;
+
+
+  /**
+   * Sets the params using values from a NamedList, usefull in the
+   * init method for your handler.
+   *
+   * <p>
+   * If any param is not of the expected type, a severe error is
+   * logged,and the param is skipped.
+   * </p>
+   *
+   * <p>
+   * If any param is not of in the NamedList, it is skipped and the
+   * old value is left alone.
+   * </p>
+   * @deprecated use SolrParams.toSolrParams
+   */
+  public void setValues(NamedList args) {
+
+    super.setValues(args);
+
+    Object tmp;
+
+    tmp = args.get(TIE);
+    if (null != tmp) {
+      if (tmp instanceof Float) {
+        tiebreaker = ((Float)tmp).floatValue();
+      } else {
+        log.severe("init param is not a float: " + TIE);
+      }
+    }
+
+    tmp = args.get(QF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        qf = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + QF);
+      }
+    }
+
+    tmp = args.get(PF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        pf = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + PF);
+      }
+    }
+
+        
+    tmp = args.get(MM);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        mm = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + MM);
+      }
+    }
+        
+    tmp = args.get(PS);
+    if (null != tmp) {
+      if (tmp instanceof Integer) {
+        pslop = ((Integer)tmp).intValue();
+      } else {
+        log.severe("init param is not an int: " + PS);
+      }
+    }
+
+    tmp = args.get(BQ);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        bq = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + BQ);
+      }
+    }
+ 
+    tmp = args.get(BF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        bf = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + BF);
+      }
+    }
+ 
+    tmp = args.get(FQ);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        fq = tmp.toString();
+      } else {
+        log.severe("init param is not a str: " + FQ);
+      }
+    }
+                
+  }
+
 }
diff --git a/src/java/org/apache/solr/util/SolrPluginUtils.java b/src/java/org/apache/solr/util/SolrPluginUtils.java
index d25a3f1..885311e 100644
--- a/src/java/org/apache/solr/util/SolrPluginUtils.java
+++ b/src/java/org/apache/solr/util/SolrPluginUtils.java
@@ -97,7 +97,7 @@ public class SolrPluginUtils {
 
   /** standard param for field list */
   @Deprecated
-  public static String FL = SolrParams.FL;
+  public static String FL = org.apache.solr.common.params.CommonParams.FL;
 
   /**
    * SolrIndexSearch.numDocs(Query,Query) freaks out if the filtering
@@ -300,7 +300,7 @@ public class SolrPluginUtils {
                                           CommonParams params)
     throws IOException {
         
-    String debug = getParam(req, SolrParams.DEBUG_QUERY, params.debugQuery);
+    String debug = getParam(req, org.apache.solr.common.params.CommonParams.DEBUG_QUERY, params.debugQuery);
 
     NamedList dbg = null;
     if (debug!=null) {
@@ -377,7 +377,7 @@ public class SolrPluginUtils {
                                           DocList results)
     throws IOException {
 
-    String debug = req.getParam(SolrParams.DEBUG_QUERY);
+    String debug = req.getParam(org.apache.solr.common.params.CommonParams.DEBUG_QUERY);
 
     NamedList dbg = null;
     if (debug!=null) {
@@ -787,7 +787,7 @@ public class SolrPluginUtils {
    */
   public static Sort getSort(SolrQueryRequest req) {
 
-    String sort = req.getParam(SolrParams.SORT);
+    String sort = req.getParam(org.apache.solr.common.params.CommonParams.SORT);
     if (null == sort || sort.equals("")) {
       return null;
     }
@@ -817,7 +817,7 @@ public class SolrPluginUtils {
    * @return null if no filter queries
    */
   public static List<Query> parseFilterQueries(SolrQueryRequest req) throws ParseException {
-    return parseQueryStrings(req, req.getParams().getParams(SolrParams.FQ));
+    return parseQueryStrings(req, req.getParams().getParams(org.apache.solr.common.params.CommonParams.FQ));
   }
 
   /** Turns an array of query strings into a List of Query objects.
diff --git a/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java b/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
index e713262..18a226b 100644
--- a/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
+++ b/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
@@ -20,8 +20,8 @@ package org.apache.solr.handler;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
-import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
@@ -47,7 +47,7 @@ public class StandardRequestHandlerTest extends AbstractSolrTestCase {
     assertU(commit());
     
     Map<String,String> args = new HashMap<String, String>();
-    args.put( SolrParams.Q, "title:test" );
+    args.put( CommonParams.Q, "title:test" );
     args.put( "indent", "true" );
     SolrQueryRequest req = new LocalSolrQueryRequest( SolrCore.getSolrCore(), new MapSolrParams( args) );
     
@@ -56,7 +56,7 @@ public class StandardRequestHandlerTest extends AbstractSolrTestCase {
             ,"//*[@numFound='3']"
             );
     
-    args.put( SolrParams.SORT, "val_s asc" );
+    args.put( CommonParams.SORT, "val_s asc" );
     assertQ("with sort param [asc]", req
             ,"//*[@numFound='3']"
             ,"//result/doc[1]/int[@name='id'][.='10']"
@@ -64,7 +64,7 @@ public class StandardRequestHandlerTest extends AbstractSolrTestCase {
             ,"//result/doc[3]/int[@name='id'][.='12']"
             );
 
-    args.put( SolrParams.SORT, "val_s desc" );
+    args.put( CommonParams.SORT, "val_s desc" );
     assertQ("with sort param [desc]", req
             ,"//*[@numFound='3']"
             ,"//result/doc[1]/int[@name='id'][.='12']"
@@ -73,8 +73,8 @@ public class StandardRequestHandlerTest extends AbstractSolrTestCase {
             );
     
     // Using legacy ';' param
-    args.remove( SolrParams.SORT );
-    args.put( SolrParams.Q, "title:test; val_s desc" );
+    args.remove( CommonParams.SORT );
+    args.put( CommonParams.Q, "title:test; val_s desc" );
     assertQ("with sort param [desc]", req
             ,"//*[@numFound='3']"
             ,"//result/doc[1]/int[@name='id'][.='12']"
@@ -82,7 +82,7 @@ public class StandardRequestHandlerTest extends AbstractSolrTestCase {
             ,"//result/doc[3]/int[@name='id'][.='10']"
             );
 
-    args.put( SolrParams.Q, "title:test; val_s asc" );
+    args.put( CommonParams.Q, "title:test; val_s asc" );
     assertQ("with sort param [desc]", req
             ,"//*[@numFound='3']"
             ,"//result/doc[1]/int[@name='id'][.='10']"
diff --git a/src/test/org/apache/solr/schema/IndexSchemaTest.java b/src/test/org/apache/solr/schema/IndexSchemaTest.java
index 8b9fd25..f14cf66 100644
--- a/src/test/org/apache/solr/schema/IndexSchemaTest.java
+++ b/src/test/org/apache/solr/schema/IndexSchemaTest.java
@@ -20,6 +20,7 @@ package org.apache.solr.schema;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
@@ -54,7 +55,7 @@ public class IndexSchemaTest extends AbstractSolrTestCase {
     assertU(commit());
     
     Map<String,String> args = new HashMap<String, String>();
-    args.put( SolrParams.Q, "title:test" );
+    args.put( CommonParams.Q, "title:test" );
     args.put( "indent", "true" );
     SolrQueryRequest req = new LocalSolrQueryRequest( SolrCore.getSolrCore(), new MapSolrParams( args) );
     
@@ -64,7 +65,7 @@ public class IndexSchemaTest extends AbstractSolrTestCase {
             );
     
     args = new HashMap<String, String>();
-    args.put( SolrParams.Q, "aaa_dynamic:aaa" );
+    args.put( CommonParams.Q, "aaa_dynamic:aaa" );
     args.put( "indent", "true" );
     req = new LocalSolrQueryRequest( SolrCore.getSolrCore(), new MapSolrParams( args) );
     assertQ("dynamic source", req
@@ -73,7 +74,7 @@ public class IndexSchemaTest extends AbstractSolrTestCase {
             );
 
     args = new HashMap<String, String>();
-    args.put( SolrParams.Q, "dynamic_aaa:aaa" );
+    args.put( CommonParams.Q, "dynamic_aaa:aaa" );
     args.put( "indent", "true" );
     req = new LocalSolrQueryRequest( SolrCore.getSolrCore(), new MapSolrParams( args) );
     assertQ("dynamic destination", req
diff --git a/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java b/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
index 3a12036..8f4148c 100644
--- a/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
+++ b/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.servlet;
 
-import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 
@@ -68,7 +68,7 @@ public class DirectSolrConnectionTest extends AbstractSolrTestCase
     
     // Test using the Stream body parameter
     for( String cmd : cmds ) {
-      direct.request( "/update?"+SolrParams.STREAM_BODY+"="+cmd, null );
+      direct.request( "/update?"+CommonParams.STREAM_BODY+"="+cmd, null );
     }
     String got = direct.request( getIt, null );
     assertTrue( got.indexOf( value ) > 0 );
diff --git a/src/test/org/apache/solr/servlet/SolrRequestParserTest.java b/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
index c22af0b..782d0f7 100644
--- a/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
+++ b/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
@@ -31,6 +31,7 @@ import java.util.Map;
 import javax.servlet.http.HttpServletRequest;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MultiMapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
@@ -57,7 +58,7 @@ public class SolrRequestParserTest extends AbstractSolrTestCase {
     String body3 = "1234567890";
     
     Map<String,String[]> args = new HashMap<String, String[]>();
-    args.put( SolrParams.STREAM_BODY, new String[] {body1} );
+    args.put( CommonParams.STREAM_BODY, new String[] {body1} );
     
     // Make sure it got a single stream in and out ok
     List<ContentStream> streams = new ArrayList<ContentStream>();
@@ -67,7 +68,7 @@ public class SolrRequestParserTest extends AbstractSolrTestCase {
     
     // Now add three and make sure they come out ok
     streams = new ArrayList<ContentStream>();
-    args.put( SolrParams.STREAM_BODY, new String[] {body1,body2,body3} );
+    args.put( CommonParams.STREAM_BODY, new String[] {body1,body2,body3} );
     parser.buildRequestFrom( new MultiMapSolrParams( args ), streams );
     assertEquals( 3, streams.size() );
     ArrayList<String> input  = new ArrayList<String>();
@@ -86,7 +87,7 @@ public class SolrRequestParserTest extends AbstractSolrTestCase {
     // set the contentType and make sure tat gets set
     String ctype = "text/xxx";
     streams = new ArrayList<ContentStream>();
-    args.put( SolrParams.STREAM_CONTENTTYPE, new String[] {ctype} );
+    args.put( CommonParams.STREAM_CONTENTTYPE, new String[] {ctype} );
     parser.buildRequestFrom( new MultiMapSolrParams( args ), streams );
     for( ContentStream s : streams ) {
       assertEquals( ctype, s.getContentType() );
@@ -109,7 +110,7 @@ public class SolrRequestParserTest extends AbstractSolrTestCase {
     }
     
     Map<String,String[]> args = new HashMap<String, String[]>();
-    args.put( SolrParams.STREAM_URL, new String[] {url} );
+    args.put( CommonParams.STREAM_URL, new String[] {url} );
     
     // Make sure it got a single stream in and out ok
     List<ContentStream> streams = new ArrayList<ContentStream>();
diff --git a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
index 1e18eae..3236a72 100644
--- a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
+++ b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
@@ -24,6 +24,7 @@ import java.util.HashMap;
 import java.util.List;
 
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
@@ -146,7 +147,7 @@ public class DirectSolrConnection
     SolrRequestHandler handler = core.getRequestHandler( path );
     if( handler == null ) {
       if( "/select".equals( path ) || "/select/".equalsIgnoreCase( path) ) {
-        String qt = params.get( SolrParams.QT );
+        String qt = params.get( CommonParams.QT );
         handler = core.getRequestHandler( qt );
         if( handler == null ) {
           throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
index e1dcd8c..ad74e6b 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
@@ -33,6 +33,7 @@ import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
@@ -143,7 +144,7 @@ public class SolrDispatchFilter implements Filter
         if( handler == null && handleSelect ) {
           if( "/select".equals( path ) || "/select/".equals( path ) ) {
             solrReq = parsers.parse( path, req );
-            String qt = solrReq.getParams().get( SolrParams.QT );
+            String qt = solrReq.getParams().get( CommonParams.QT );
             if( qt != null && qt.startsWith( "/" ) ) {
               throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Invalid query type.  Do not use /select to access: "+qt);
             }
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java b/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
index ccdeeab..19297c8 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
@@ -37,6 +37,7 @@ import org.apache.commons.fileupload.FileItem;
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
 import org.apache.commons.fileupload.servlet.ServletFileUpload;
 import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.MultiMapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.ContentStream;
@@ -109,10 +110,10 @@ public class SolrRequestParsers
   public SolrQueryRequest buildRequestFrom( SolrParams params, Collection<ContentStream> streams ) throws Exception
   {
     // The content type will be applied to all streaming content
-    String contentType = params.get( SolrParams.STREAM_CONTENTTYPE );
+    String contentType = params.get( CommonParams.STREAM_CONTENTTYPE );
       
     // Handle anything with a remoteURL
-    String[] strs = params.getParams( SolrParams.STREAM_URL );
+    String[] strs = params.getParams( CommonParams.STREAM_URL );
     if( strs != null ) {
       if( !enableRemoteStreams ) {
         throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Remote Streaming is disabled." );
@@ -127,7 +128,7 @@ public class SolrRequestParsers
     }
     
     // Handle streaming files
-    strs = params.getParams( SolrParams.STREAM_FILE );
+    strs = params.getParams( CommonParams.STREAM_FILE );
     if( strs != null ) {
       if( !enableRemoteStreams ) {
         throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Remote Streaming is disabled." );
@@ -142,7 +143,7 @@ public class SolrRequestParsers
     }
     
     // Check for streams in the request parameters
-    strs = params.getParams( SolrParams.STREAM_BODY );
+    strs = params.getParams( CommonParams.STREAM_BODY );
     if( strs != null ) {
       for( final String body : strs ) {
         ContentStreamBase stream = new ContentStreamBase.StringStream( body );

