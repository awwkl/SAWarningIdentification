GitDiffStart: b5d3afa239029fe4e9e00d0456eceb8fc698bbfc | Thu Nov 14 20:38:42 2013 +0000
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FacetSource.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FacetSource.java
index 34b2361..81b65d5 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FacetSource.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FacetSource.java
@@ -20,7 +20,7 @@ package org.apache.lucene.benchmark.byTask.feeds;
 import java.io.IOException;
 import java.util.List;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /**
  * Source items for facets.
@@ -34,7 +34,7 @@ public abstract class FacetSource extends ContentItemsSource {
    * account for multi-threading, as multiple threads can call this method
    * simultaneously.
    */
-  public abstract void getNextFacets(List<CategoryPath> facets) throws NoMoreDataException, IOException;
+  public abstract void getNextFacets(List<FacetLabel> facets) throws NoMoreDataException, IOException;
 
   @Override
   public void resetInputs() throws IOException {
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java
index 99d5f21..c492fef 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/RandomFacetSource.java
@@ -22,7 +22,7 @@ import java.util.List;
 import java.util.Random;
 
 import org.apache.lucene.benchmark.byTask.utils.Config;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /**
  * Simple implementation of a random facet source
@@ -47,7 +47,7 @@ public class RandomFacetSource extends FacetSource {
   private int maxValue = maxDocFacets * maxFacetDepth;
   
   @Override
-  public void getNextFacets(List<CategoryPath> facets) throws NoMoreDataException, IOException {
+  public void getNextFacets(List<FacetLabel> facets) throws NoMoreDataException, IOException {
     facets.clear();
     int numFacets = 1 + random.nextInt(maxDocFacets); // at least one facet to each doc
     for (int i = 0; i < numFacets; i++) {
@@ -57,7 +57,7 @@ public class RandomFacetSource extends FacetSource {
         components[k] = Integer.toString(random.nextInt(maxValue));
         addItem();
       }
-      CategoryPath cp = new CategoryPath(components);
+      FacetLabel cp = new FacetLabel(components);
       facets.add(cp);
       addBytes(cp.toString().length()); // very rough approximation
     }
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddFacetedDocTask.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddFacetedDocTask.java
index 9fa660a..f73b731 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddFacetedDocTask.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddFacetedDocTask.java
@@ -23,7 +23,7 @@ import java.util.List;
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.feeds.FacetSource;
 import org.apache.lucene.facet.index.FacetFields;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /**
  * Add a faceted document.
@@ -44,7 +44,7 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  */
 public class AddFacetedDocTask extends AddDocTask {
 
-  private final List<CategoryPath> facets = new ArrayList<CategoryPath>();
+  private final List<FacetLabel> facets = new ArrayList<FacetLabel>();
   private FacetFields facetFields;
   
   public AddFacetedDocTask(PerfRunData runData) {
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/AssociationsFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/AssociationsFacetsExample.java
index fdfd5fd..1b55c42 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/AssociationsFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/AssociationsFacetsExample.java
@@ -16,7 +16,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -52,17 +52,17 @@ public class AssociationsFacetsExample {
    * Categories per document, {@link #ASSOCIATIONS} hold the association value
    * for each category.
    */
-  public static CategoryPath[][] CATEGORIES = {
+  public static FacetLabel[][] CATEGORIES = {
     // Doc #1
-    { new CategoryPath("tags", "lucene") , 
-      new CategoryPath("genre", "computing")
+    { new FacetLabel("tags", "lucene") , 
+      new FacetLabel("genre", "computing")
     },
         
     // Doc #2
-    { new CategoryPath("tags", "lucene"),  
-      new CategoryPath("tags", "solr"),
-      new CategoryPath("genre", "computing"),
-      new CategoryPath("genre", "software")
+    { new FacetLabel("tags", "lucene"),  
+      new FacetLabel("tags", "solr"),
+      new FacetLabel("genre", "computing"),
+      new FacetLabel("genre", "software")
     }
   };
 
@@ -126,8 +126,8 @@ public class AssociationsFacetsExample {
     IndexSearcher searcher = new IndexSearcher(indexReader);
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
     
-    CategoryPath tags = new CategoryPath("tags");
-    CategoryPath genre = new CategoryPath("genre");
+    FacetLabel tags = new FacetLabel("tags");
+    FacetLabel genre = new FacetLabel("genre");
     FacetSearchParams fsp = new FacetSearchParams(new SumIntAssociationFacetRequest(tags, 10), 
         new SumFloatAssociationFacetRequest(genre, 10));
     FacetsCollector fc = FacetsCollector.create(fsp, indexReader, taxoReader);
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/ExpressionAggregationFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/ExpressionAggregationFacetsExample.java
index 7588561..434b9a9 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/ExpressionAggregationFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/ExpressionAggregationFacetsExample.java
@@ -18,7 +18,7 @@ import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.SumValueSourceFacetRequest;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -61,7 +61,7 @@ public class ExpressionAggregationFacetsExample {
     Document doc = new Document();
     doc.add(new TextField("c", text, Store.NO));
     doc.add(new NumericDocValuesField("popularity", popularity));
-    facetFields.addFields(doc, Collections.singletonList(new CategoryPath(category, '/')));
+    facetFields.addFields(doc, Collections.singletonList(new FacetLabel(category, '/')));
     indexWriter.addDocument(doc);
   }
 
@@ -97,7 +97,7 @@ public class ExpressionAggregationFacetsExample {
     bindings.add(new SortField("popularity", SortField.Type.LONG)); // the value of the 'popularity' field
 
     FacetSearchParams fsp = new FacetSearchParams(
-        new SumValueSourceFacetRequest(new CategoryPath("A"), 10, expr.getValueSource(bindings), true));
+        new SumValueSourceFacetRequest(new FacetLabel("A"), 10, expr.getValueSource(bindings), true));
 
     // Aggregates the facet values
     FacetsCollector fc = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/MultiCategoryListsFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/MultiCategoryListsFacetsExample.java
index e02fff4..0e2dfc0 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/MultiCategoryListsFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/MultiCategoryListsFacetsExample.java
@@ -16,7 +16,7 @@ import org.apache.lucene.facet.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -55,18 +55,18 @@ public class MultiCategoryListsFacetsExample {
   /** Creates a new instance and populates the catetory list params mapping. */
   public MultiCategoryListsFacetsExample() {
     // index all Author facets in one category list and all Publish Date in another.
-    Map<CategoryPath,CategoryListParams> categoryListParams = new HashMap<CategoryPath,CategoryListParams>();
-    categoryListParams.put(new CategoryPath("Author"), new CategoryListParams("author"));
-    categoryListParams.put(new CategoryPath("Publish Date"), new CategoryListParams("pubdate"));
+    Map<FacetLabel,CategoryListParams> categoryListParams = new HashMap<FacetLabel,CategoryListParams>();
+    categoryListParams.put(new FacetLabel("Author"), new CategoryListParams("author"));
+    categoryListParams.put(new FacetLabel("Publish Date"), new CategoryListParams("pubdate"));
     indexingParams = new PerDimensionIndexingParams(categoryListParams);
   }
   
   private void add(IndexWriter indexWriter, FacetFields facetFields, String ... categoryPaths) throws IOException {
     Document doc = new Document();
     
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for (String categoryPath : categoryPaths) {
-      paths.add(new CategoryPath(categoryPath, '/'));
+      paths.add(new FacetLabel(categoryPath, '/'));
     }
     facetFields.addFields(doc, paths);
     indexWriter.addDocument(doc);
@@ -101,8 +101,8 @@ public class MultiCategoryListsFacetsExample {
 
     // Count both "Publish Date" and "Author" dimensions
     FacetSearchParams fsp = new FacetSearchParams(indexingParams,
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     // Aggregatses the facet counts
     FacetsCollector fc = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleFacetsExample.java
index 4379c50..e65feb8 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleFacetsExample.java
@@ -12,7 +12,7 @@ import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.DrillDownQuery;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -53,9 +53,9 @@ public class SimpleFacetsExample {
   private void add(IndexWriter indexWriter, FacetFields facetFields, String ... categoryPaths) throws IOException {
     Document doc = new Document();
     
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for (String categoryPath : categoryPaths) {
-      paths.add(new CategoryPath(categoryPath, '/'));
+      paths.add(new FacetLabel(categoryPath, '/'));
     }
     facetFields.addFields(doc, paths);
     indexWriter.addDocument(doc);
@@ -90,8 +90,8 @@ public class SimpleFacetsExample {
 
     // Count both "Publish Date" and "Author" dimensions
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     // Aggregates the facet counts
     FacetsCollector fc = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
@@ -118,12 +118,12 @@ public class SimpleFacetsExample {
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
 
     // Now user drills down on Publish Date/2010:
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("Author"), 10));
 
     // Passing no baseQuery means we drill down on all
     // documents ("browse only"):
     DrillDownQuery q = new DrillDownQuery(fsp.indexingParams);
-    q.add(new CategoryPath("Publish Date/2010", '/'));
+    q.add(new FacetLabel("Publish Date/2010", '/'));
     FacetsCollector fc = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
     searcher.search(q, fc);
 
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleSortedSetFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleSortedSetFacetsExample.java
index 3cd7c15..52dec49 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleSortedSetFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/SimpleSortedSetFacetsExample.java
@@ -31,7 +31,7 @@ import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesAccumulator;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetFields;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
@@ -54,9 +54,9 @@ public class SimpleSortedSetFacetsExample {
   private void add(IndexWriter indexWriter, SortedSetDocValuesFacetFields facetFields, String ... categoryPaths) throws IOException {
     Document doc = new Document();
     
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for (String categoryPath : categoryPaths) {
-      paths.add(new CategoryPath(categoryPath, '/'));
+      paths.add(new FacetLabel(categoryPath, '/'));
     }
     facetFields.addFields(doc, paths);
     indexWriter.addDocument(doc);
@@ -87,8 +87,8 @@ public class SimpleSortedSetFacetsExample {
 
     // Count both "Publish Year" and "Author" dimensions
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Year"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Year"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     // Aggregatses the facet counts
     FacetsCollector fc = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));
@@ -114,9 +114,9 @@ public class SimpleSortedSetFacetsExample {
     SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(indexReader);
 
     // Now user drills down on Publish Year/2010:
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("Author"), 10));
     DrillDownQuery q = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    q.add(new CategoryPath("Publish Year/2010", '/'));
+    q.add(new FacetLabel("Publish Year/2010", '/'));
     FacetsCollector fc = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));
     searcher.search(q, fc);
 
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
index e3354da..76baf06 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
@@ -5,7 +5,7 @@ import java.util.List;
 import org.apache.lucene.facet.collections.ObjectToIntMap;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Test;
 
@@ -28,18 +28,18 @@ import org.junit.Test;
 
 public class TestMultiCategoryListsFacetsExample extends LuceneTestCase {
 
-  private static final ObjectToIntMap<CategoryPath> expectedCounts = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCounts = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCounts.put(new CategoryPath("Publish Date", "2012"), 2);
-    expectedCounts.put(new CategoryPath("Publish Date", "2010"), 2);
-    expectedCounts.put(new CategoryPath("Publish Date", "1999"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Lisa"), 2);
-    expectedCounts.put(new CategoryPath("Author", "Frank"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Susan"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Bob"), 1);
+    expectedCounts.put(new FacetLabel("Publish Date", "2012"), 2);
+    expectedCounts.put(new FacetLabel("Publish Date", "2010"), 2);
+    expectedCounts.put(new FacetLabel("Publish Date", "1999"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Lisa"), 2);
+    expectedCounts.put(new FacetLabel("Author", "Frank"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Susan"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Bob"), 1);
   }
   
-  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<CategoryPath> expCounts) {
+  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<FacetLabel> expCounts) {
     for (FacetResult res : facetResults) {
       FacetResultNode root = res.getFacetResultNode();
       for (FacetResultNode node : root.subResults) {
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
index c8213fc..aeaab50 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
@@ -24,7 +24,7 @@ import org.apache.lucene.facet.range.LongRange;
 import org.apache.lucene.facet.range.RangeFacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
@@ -33,14 +33,14 @@ import org.junit.Test;
 @SuppressCodecs("Lucene3x")
 public class TestRangeFacetsExample extends LuceneTestCase {
 
-  private static final ObjectToIntMap<CategoryPath> expectedCounts = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCounts = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCounts.put(new CategoryPath("timestamp", "Past hour"), 4);
-    expectedCounts.put(new CategoryPath("timestamp", "Past six hours"), 22);
-    expectedCounts.put(new CategoryPath("timestamp", "Past day"), 87);
+    expectedCounts.put(new FacetLabel("timestamp", "Past hour"), 4);
+    expectedCounts.put(new FacetLabel("timestamp", "Past six hours"), 22);
+    expectedCounts.put(new FacetLabel("timestamp", "Past day"), 87);
   }
   
-  private void assertExpectedCounts(FacetResult res, ObjectToIntMap<CategoryPath> expCounts) {
+  private void assertExpectedCounts(FacetResult res, ObjectToIntMap<FacetLabel> expCounts) {
     FacetResultNode root = res.getFacetResultNode();
     for (FacetResultNode node : root.subResults) {
       assertEquals("incorrect count for " + node.label, expCounts.get(node.label), (int) node.value);
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
index 2710a61..ba9952b 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
@@ -5,7 +5,7 @@ import java.util.List;
 import org.apache.lucene.facet.collections.ObjectToIntMap;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Test;
 
@@ -28,24 +28,24 @@ import org.junit.Test;
 
 public class TestSimpleFacetsExample extends LuceneTestCase {
 
-  private static final ObjectToIntMap<CategoryPath> expectedCounts = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCounts = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCounts.put(new CategoryPath("Publish Date", "2012"), 2);
-    expectedCounts.put(new CategoryPath("Publish Date", "2010"), 2);
-    expectedCounts.put(new CategoryPath("Publish Date", "1999"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Lisa"), 2);
-    expectedCounts.put(new CategoryPath("Author", "Frank"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Susan"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Bob"), 1);
+    expectedCounts.put(new FacetLabel("Publish Date", "2012"), 2);
+    expectedCounts.put(new FacetLabel("Publish Date", "2010"), 2);
+    expectedCounts.put(new FacetLabel("Publish Date", "1999"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Lisa"), 2);
+    expectedCounts.put(new FacetLabel("Author", "Frank"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Susan"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Bob"), 1);
   }
   
-  private static final ObjectToIntMap<CategoryPath> expectedCountsDrillDown = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCountsDrillDown = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCountsDrillDown.put(new CategoryPath("Author", "Lisa"), 1);
-    expectedCountsDrillDown.put(new CategoryPath("Author", "Bob"), 1);
+    expectedCountsDrillDown.put(new FacetLabel("Author", "Lisa"), 1);
+    expectedCountsDrillDown.put(new FacetLabel("Author", "Bob"), 1);
   }
   
-  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<CategoryPath> expCounts) {
+  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<FacetLabel> expCounts) {
     for (FacetResult res : facetResults) {
       FacetResultNode root = res.getFacetResultNode();
       for (FacetResultNode node : root.subResults) {
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
index 765e377..7299fd7 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
@@ -5,7 +5,7 @@ import java.util.List;
 import org.apache.lucene.facet.collections.ObjectToIntMap;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Test;
@@ -31,24 +31,24 @@ import org.junit.Test;
 @SuppressCodecs({"Lucene40", "Lucene41"})
 public class TestSimpleSortedSetFacetsExample extends LuceneTestCase {
 
-  private static final ObjectToIntMap<CategoryPath> expectedCounts = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCounts = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCounts.put(new CategoryPath("Publish Year", "2012"), 2);
-    expectedCounts.put(new CategoryPath("Publish Year", "2010"), 2);
-    expectedCounts.put(new CategoryPath("Publish Year", "1999"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Lisa"), 2);
-    expectedCounts.put(new CategoryPath("Author", "Frank"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Susan"), 1);
-    expectedCounts.put(new CategoryPath("Author", "Bob"), 1);
+    expectedCounts.put(new FacetLabel("Publish Year", "2012"), 2);
+    expectedCounts.put(new FacetLabel("Publish Year", "2010"), 2);
+    expectedCounts.put(new FacetLabel("Publish Year", "1999"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Lisa"), 2);
+    expectedCounts.put(new FacetLabel("Author", "Frank"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Susan"), 1);
+    expectedCounts.put(new FacetLabel("Author", "Bob"), 1);
   }
   
-  private static final ObjectToIntMap<CategoryPath> expectedCountsDrillDown = new ObjectToIntMap<CategoryPath>();
+  private static final ObjectToIntMap<FacetLabel> expectedCountsDrillDown = new ObjectToIntMap<FacetLabel>();
   static {
-    expectedCountsDrillDown.put(new CategoryPath("Author", "Lisa"), 1);
-    expectedCountsDrillDown.put(new CategoryPath("Author", "Bob"), 1);
+    expectedCountsDrillDown.put(new FacetLabel("Author", "Lisa"), 1);
+    expectedCountsDrillDown.put(new FacetLabel("Author", "Bob"), 1);
   }
   
-  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<CategoryPath> expCounts) {
+  private void assertExpectedCounts(List<FacetResult> facetResults, ObjectToIntMap<FacetLabel> expCounts) {
     for (FacetResult res : facetResults) {
       FacetResultNode root = res.getFacetResultNode();
       for (FacetResultNode node : root.subResults) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsDrillDownStream.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsDrillDownStream.java
index c607fd7..839bcbb 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsDrillDownStream.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsDrillDownStream.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.associations;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.facet.index.DrillDownStream;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.util.BytesRef;
 
@@ -52,7 +52,7 @@ public class AssociationsDrillDownStream extends DrillDownStream {
   }
   
   @Override
-  protected void addAdditionalAttributes(CategoryPath cp, boolean isParent) {
+  protected void addAdditionalAttributes(FacetLabel cp, boolean isParent) {
     if (isParent) {
       return; // associations are not added to parent categories
     }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsFacetFields.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsFacetFields.java
index 87bfac5..b596416 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsFacetFields.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsFacetFields.java
@@ -11,7 +11,7 @@ import org.apache.lucene.facet.index.DrillDownStream;
 import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.util.BytesRef;
@@ -37,7 +37,7 @@ import org.apache.lucene.util.IntsRef;
 /**
  * A utility class for adding facet fields to a document. Usually one field will
  * be added for all facets, however per the
- * {@link FacetIndexingParams#getCategoryListParams(CategoryPath)}, one field
+ * {@link FacetIndexingParams#getCategoryListParams(FacetLabel)}, one field
  * may be added for every group of facets.
  * 
  * @lucene.experimental
@@ -77,12 +77,12 @@ public class AssociationsFacetFields extends FacetFields {
   }
 
   @Override
-  protected Map<CategoryListParams,Iterable<CategoryPath>> createCategoryListMapping(
-      Iterable<CategoryPath> categories) {
+  protected Map<CategoryListParams,Iterable<FacetLabel>> createCategoryListMapping(
+      Iterable<FacetLabel> categories) {
     CategoryAssociationsContainer categoryAssociations = (CategoryAssociationsContainer) categories;
-    HashMap<CategoryListParams,Iterable<CategoryPath>> categoryLists = 
-        new HashMap<CategoryListParams,Iterable<CategoryPath>>();
-    for (CategoryPath cp : categories) {
+    HashMap<CategoryListParams,Iterable<FacetLabel>> categoryLists = 
+        new HashMap<CategoryListParams,Iterable<FacetLabel>>();
+    for (FacetLabel cp : categories) {
       // each category may be indexed under a different field, so add it to the right list.
       CategoryListParams clp = indexingParams.getCategoryListParams(cp);
       CategoryAssociationsContainer clpContainer = (CategoryAssociationsContainer) categoryLists.get(clp);
@@ -97,13 +97,13 @@ public class AssociationsFacetFields extends FacetFields {
   
   @Override
   protected Map<String,BytesRef> getCategoryListData(CategoryListParams categoryListParams, IntsRef ordinals,
-      Iterable<CategoryPath> categories) throws IOException {
+      Iterable<FacetLabel> categories) throws IOException {
     AssociationsListBuilder associations = new AssociationsListBuilder((CategoryAssociationsContainer) categories);
     return associations.build(ordinals, categories);
   }
   
   @Override
-  protected DrillDownStream getDrillDownStream(Iterable<CategoryPath> categories) {
+  protected DrillDownStream getDrillDownStream(Iterable<FacetLabel> categories) {
     return new AssociationsDrillDownStream((CategoryAssociationsContainer) categories, indexingParams);
   }
   
@@ -113,7 +113,7 @@ public class AssociationsFacetFields extends FacetFields {
   }
 
   @Override
-  public void addFields(Document doc, Iterable<CategoryPath> categories) throws IOException {
+  public void addFields(Document doc, Iterable<FacetLabel> categories) throws IOException {
     if (!(categories instanceof CategoryAssociationsContainer)) {
       throw new IllegalArgumentException("categories must be of type " + 
           CategoryAssociationsContainer.class.getSimpleName());
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder.java
index 3c9db45..c5adf49 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/AssociationsListBuilder.java
@@ -6,7 +6,7 @@ import java.util.Map;
 
 import org.apache.lucene.facet.index.CategoryListBuilder;
 import org.apache.lucene.facet.index.CountingListBuilder;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
@@ -47,10 +47,10 @@ public class AssociationsListBuilder implements CategoryListBuilder {
   }
   
   @Override
-  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {
+  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<FacetLabel> categories) throws IOException {
     final HashMap<String,BytesRef> res = new HashMap<String,BytesRef>();
     int idx = 0;
-    for (CategoryPath cp : categories) {
+    for (FacetLabel cp : categories) {
       // build per-association key BytesRef
       CategoryAssociation association = associations.getAssociation(cp);
       
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociation.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociation.java
index 2aa433a..ba34fcb 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociation.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociation.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.associations;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.store.DataInput;
@@ -24,7 +24,7 @@ import org.apache.lucene.store.DataOutput;
  */
 
 /**
- * Allows associating an arbitrary value with a {@link CategoryPath}.
+ * Allows associating an arbitrary value with a {@link FacetLabel}.
  * 
  * @lucene.experimental
  */
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociationsContainer.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociationsContainer.java
index d40a0c1..11bde97 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociationsContainer.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/CategoryAssociationsContainer.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.associations;
 import java.util.HashMap;
 import java.util.Iterator;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -22,17 +22,17 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  * limitations under the License.
  */
 
-/** Holds {@link CategoryAssociation} per {@link CategoryPath}. */
-public class CategoryAssociationsContainer implements Iterable<CategoryPath> {
+/** Holds {@link CategoryAssociation} per {@link FacetLabel}. */
+public class CategoryAssociationsContainer implements Iterable<FacetLabel> {
 
-  private final HashMap<CategoryPath,CategoryAssociation> categoryAssociations = 
-      new HashMap<CategoryPath,CategoryAssociation>();
+  private final HashMap<FacetLabel,CategoryAssociation> categoryAssociations = 
+      new HashMap<FacetLabel,CategoryAssociation>();
   
   /**
-   * Adds the {@link CategoryAssociation} for the given {@link CategoryPath
+   * Adds the {@link CategoryAssociation} for the given {@link FacetLabel
    * category}. Overrides any assocation that was previously set.
    */
-  public void setAssociation(CategoryPath category, CategoryAssociation association) {
+  public void setAssociation(FacetLabel category, CategoryAssociation association) {
     if (association == null) {
       throw new IllegalArgumentException("cannot set a null association to a category");
     }
@@ -41,14 +41,14 @@ public class CategoryAssociationsContainer implements Iterable<CategoryPath> {
   
   /**
    * Returns the {@link CategoryAssociation} that was set for the
-   * {@link CategoryPath category}, or {@code null} if none was defined.
+   * {@link FacetLabel category}, or {@code null} if none was defined.
    */
-  public CategoryAssociation getAssociation(CategoryPath category) {
+  public CategoryAssociation getAssociation(FacetLabel category) {
     return categoryAssociations.get(category);
   }
 
   @Override
-  public Iterator<CategoryPath> iterator() {
+  public Iterator<FacetLabel> iterator() {
     return categoryAssociations.keySet().iterator();
   }
   
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/SumFloatAssociationFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/SumFloatAssociationFacetRequest.java
index 2a03659..8736389 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/SumFloatAssociationFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/SumFloatAssociationFacetRequest.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.associations;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetsAggregator;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -34,7 +34,7 @@ public class SumFloatAssociationFacetRequest extends FacetRequest {
    * Create a float association facet request for a given node in the
    * taxonomy.
    */
-  public SumFloatAssociationFacetRequest(CategoryPath path, int num) {
+  public SumFloatAssociationFacetRequest(FacetLabel path, int num) {
     super(path, num);
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/associations/SumIntAssociationFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/associations/SumIntAssociationFacetRequest.java
index 6ec06c9..da54eee 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/associations/SumIntAssociationFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/associations/SumIntAssociationFacetRequest.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.associations;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetsAggregator;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -34,7 +34,7 @@ public class SumIntAssociationFacetRequest extends FacetRequest {
    * Create an integer association facet request for a given node in the
    * taxonomy.
    */
-  public SumIntAssociationFacetRequest(CategoryPath path, int num) {
+  public SumIntAssociationFacetRequest(FacetLabel path, int num) {
     super(path, num);
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/complements/TotalFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/complements/TotalFacetCounts.java
index c83e1d0..44d81be 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/complements/TotalFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/complements/TotalFacetCounts.java
@@ -22,7 +22,7 @@ import org.apache.lucene.facet.search.CategoryListIterator;
 import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetArrays;
 import org.apache.lucene.facet.search.FacetRequest;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.index.IndexReader;
@@ -151,7 +151,7 @@ public class TotalFacetCounts {
   }
   
   // needed because FacetSearchParams do not allow empty FacetRequests
-  private static final FacetRequest DUMMY_REQ = new CountFacetRequest(CategoryPath.EMPTY, 1);
+  private static final FacetRequest DUMMY_REQ = new CountFacetRequest(FacetLabel.EMPTY, 1);
 
   static TotalFacetCounts compute(final IndexReader indexReader, final TaxonomyReader taxonomy, 
       final FacetIndexingParams facetIndexingParams) throws IOException {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryListBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryListBuilder.java
index 0bea432..6e204d5 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryListBuilder.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/CategoryListBuilder.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.index;
 import java.io.IOException;
 import java.util.Map;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
 
@@ -33,6 +33,6 @@ import org.apache.lucene.util.IntsRef;
 public interface CategoryListBuilder {
   
   /** Returns the encoded ordinals data. */
-  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException;
+  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<FacetLabel> categories) throws IOException;
   
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/CountingListBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/index/CountingListBuilder.java
index cf05a22..1b4b6d3 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/CountingListBuilder.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/CountingListBuilder.java
@@ -11,7 +11,7 @@ import org.apache.lucene.facet.encoding.IntEncoder;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.CategoryListParams.OrdinalPolicy;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.util.BytesRef;
@@ -141,13 +141,13 @@ public class CountingListBuilder implements CategoryListBuilder {
    * processing the array for other purposes.
    */
   @Override
-  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<CategoryPath> categories) throws IOException {
+  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<FacetLabel> categories) throws IOException {
     int upto = ordinals.length; // since we may add ordinals to IntsRef, iterate upto original length
 
-    Iterator<CategoryPath> iter = categories.iterator();
+    Iterator<FacetLabel> iter = categories.iterator();
     for (int i = 0; i < upto; i++) {
       int ordinal = ordinals.ints[i];
-      CategoryPath cp = iter.next();
+      FacetLabel cp = iter.next();
       OrdinalPolicy op = clp.getOrdinalPolicy(cp.components[0]);
       if (op != OrdinalPolicy.NO_PARENTS) {
         // need to add parents too
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/DrillDownStream.java b/lucene/facet/src/java/org/apache/lucene/facet/index/DrillDownStream.java
index 0851f69..a40832a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/DrillDownStream.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/DrillDownStream.java
@@ -6,7 +6,7 @@ import java.util.Iterator;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -33,19 +33,19 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
 public class DrillDownStream extends TokenStream {
 
   private final FacetIndexingParams indexingParams;
-  private final Iterator<CategoryPath> categories;
+  private final Iterator<FacetLabel> categories;
   private final CharTermAttribute termAttribute;
   
-  private CategoryPath current;
+  private FacetLabel current;
   private boolean isParent;
   
-  public DrillDownStream(Iterable<CategoryPath> categories, FacetIndexingParams indexingParams) {
+  public DrillDownStream(Iterable<FacetLabel> categories, FacetIndexingParams indexingParams) {
     termAttribute = addAttribute(CharTermAttribute.class);
     this.categories = categories.iterator();
     this.indexingParams = indexingParams;
   }
 
-  protected void addAdditionalAttributes(CategoryPath category, boolean isParent) {
+  protected void addAdditionalAttributes(FacetLabel category, boolean isParent) {
     // a hook for AssociationsDrillDownStream to add the associations payload to
     // the drill-down terms
   }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java b/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
index aa2ed5e..52ad945 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
@@ -15,7 +15,7 @@ import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.util.BytesRef;
@@ -41,7 +41,7 @@ import org.apache.lucene.util.IntsRef;
 /**
  * A utility class for adding facet fields to a document. Usually one field will
  * be added for all facets, however per the
- * {@link FacetIndexingParams#getCategoryListParams(CategoryPath)}, one field
+ * {@link FacetIndexingParams#getCategoryListParams(FacetLabel)}, one field
  * may be added for every group of facets.
  * 
  * @lucene.experimental
@@ -88,21 +88,21 @@ public class FacetFields {
 
   /**
    * Creates a mapping between a {@link CategoryListParams} and all
-   * {@link CategoryPath categories} that are associated with it.
+   * {@link FacetLabel categories} that are associated with it.
    */
-  protected Map<CategoryListParams,Iterable<CategoryPath>> createCategoryListMapping(
-      Iterable<CategoryPath> categories) {
+  protected Map<CategoryListParams,Iterable<FacetLabel>> createCategoryListMapping(
+      Iterable<FacetLabel> categories) {
     if (indexingParams.getAllCategoryListParams().size() == 1) {
       return Collections.singletonMap(indexingParams.getCategoryListParams(null), categories);
     }
-    HashMap<CategoryListParams,Iterable<CategoryPath>> categoryLists = 
-        new HashMap<CategoryListParams,Iterable<CategoryPath>>();
-    for (CategoryPath cp : categories) {
+    HashMap<CategoryListParams,Iterable<FacetLabel>> categoryLists = 
+        new HashMap<CategoryListParams,Iterable<FacetLabel>>();
+    for (FacetLabel cp : categories) {
       // each category may be indexed under a different field, so add it to the right list.
       CategoryListParams clp = indexingParams.getCategoryListParams(cp);
-      List<CategoryPath> list = (List<CategoryPath>) categoryLists.get(clp);
+      List<FacetLabel> list = (List<FacetLabel>) categoryLists.get(clp);
       if (list == null) {
-        list = new ArrayList<CategoryPath>();
+        list = new ArrayList<FacetLabel>();
         categoryLists.put(clp, list);
       }
       list.add(cp);
@@ -113,10 +113,10 @@ public class FacetFields {
   /**
    * Returns the category list data, as a mapping from key to {@link BytesRef}
    * which includes the encoded data. Every ordinal in {@code ordinals}
-   * corrspond to a {@link CategoryPath} returned from {@code categories}.
+   * corrspond to a {@link FacetLabel} returned from {@code categories}.
    */
   protected Map<String,BytesRef> getCategoryListData(CategoryListParams categoryListParams, 
-      IntsRef ordinals, Iterable<CategoryPath> categories /* needed for AssociationsFacetFields */) 
+      IntsRef ordinals, Iterable<FacetLabel> categories /* needed for AssociationsFacetFields */) 
       throws IOException {
     return new CountingListBuilder(categoryListParams, indexingParams, taxonomyWriter).build(ordinals, categories);
   }
@@ -125,7 +125,7 @@ public class FacetFields {
    * Returns a {@link DrillDownStream} for writing the categories drill-down
    * terms.
    */
-  protected DrillDownStream getDrillDownStream(Iterable<CategoryPath> categories) {
+  protected DrillDownStream getDrillDownStream(Iterable<FacetLabel> categories) {
     return new DrillDownStream(categories, indexingParams);
   }
   
@@ -148,7 +148,7 @@ public class FacetFields {
   }
   
   /** Adds the needed facet fields to the document. */
-  public void addFields(Document doc, Iterable<CategoryPath> categories) throws IOException {
+  public void addFields(Document doc, Iterable<FacetLabel> categories) throws IOException {
     if (categories == null) {
       throw new IllegalArgumentException("categories should not be null");
     }
@@ -159,19 +159,19 @@ public class FacetFields {
     // - DrillDownStream
     // - CountingListStream
 
-    final Map<CategoryListParams,Iterable<CategoryPath>> categoryLists = createCategoryListMapping(categories);
+    final Map<CategoryListParams,Iterable<FacetLabel>> categoryLists = createCategoryListMapping(categories);
 
     // for each CLP we add a different field for drill-down terms as well as for
     // counting list data.
     IntsRef ordinals = new IntsRef(32); // should be enough for most common applications
-    for (Entry<CategoryListParams, Iterable<CategoryPath>> e : categoryLists.entrySet()) {
+    for (Entry<CategoryListParams, Iterable<FacetLabel>> e : categoryLists.entrySet()) {
       final CategoryListParams clp = e.getKey();
       final String field = clp.field;
 
       // build category list data
       ordinals.length = 0; // reset
       int maxNumOrds = 0;
-      for (CategoryPath cp : e.getValue()) {
+      for (FacetLabel cp : e.getValue()) {
         int ordinal = taxonomyWriter.addCategory(cp);
         maxNumOrds += cp.length; // ordinal and potentially all parents
         if (ordinals.ints.length < maxNumOrds) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/params/CategoryListParams.java b/lucene/facet/src/java/org/apache/lucene/facet/params/CategoryListParams.java
index a457bcd..3034f6a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/params/CategoryListParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/params/CategoryListParams.java
@@ -9,7 +9,7 @@ import org.apache.lucene.facet.encoding.SortingIntEncoder;
 import org.apache.lucene.facet.encoding.UniqueValuesIntEncoder;
 import org.apache.lucene.facet.search.CategoryListIterator;
 import org.apache.lucene.facet.search.DocValuesCategoryListIterator;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.util.PartitionsUtils;
 
 /*
@@ -77,7 +77,7 @@ public class CategoryListParams {
     /**
      * Encodes the ordinals of all path components except the dimension. The
      * dimension of a category is defined to be the first components in
-     * {@link CategoryPath#components}. For the category A/B/C, the ordinal of
+     * {@link FacetLabel#components}. For the category A/B/C, the ordinal of
      * A/B will be encoded as well, however not the ordinal of A.
      * 
      * <p>
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/params/FacetIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/params/FacetIndexingParams.java
index 344f4af..1eaf936 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/params/FacetIndexingParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/params/FacetIndexingParams.java
@@ -4,7 +4,7 @@ import java.util.Collections;
 import java.util.List;
 
 import org.apache.lucene.facet.search.FacetArrays;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -52,7 +52,7 @@ public class FacetIndexingParams {
   public static final FacetIndexingParams DEFAULT = new FacetIndexingParams();
   
   /**
-   * The default delimiter with which {@link CategoryPath#components} are
+   * The default delimiter with which {@link FacetLabel#components} are
    * concatenated when written to the index, e.g. as drill-down terms. If you
    * choose to override it by overiding {@link #getFacetDelimChar()}, you should
    * make sure that you return a character that's not found in any path
@@ -79,13 +79,13 @@ public class FacetIndexingParams {
   }
 
   /**
-   * Returns the {@link CategoryListParams} for this {@link CategoryPath}. The
+   * Returns the {@link CategoryListParams} for this {@link FacetLabel}. The
    * default implementation returns the same {@link CategoryListParams} for all
    * categories (even if {@code category} is {@code null}).
    * 
    * @see PerDimensionIndexingParams
    */
-  public CategoryListParams getCategoryListParams(CategoryPath category) {
+  public CategoryListParams getCategoryListParams(FacetLabel category) {
     return clParams;
   }
 
@@ -95,9 +95,9 @@ public class FacetIndexingParams {
    * that were written.
    * <p>
    * <b>NOTE:</b> You should make sure that the {@code char[]} is large enough,
-   * by e.g. calling {@link CategoryPath#fullPathLength()}.
+   * by e.g. calling {@link FacetLabel#fullPathLength()}.
    */
-  public int drillDownTermText(CategoryPath path, char[] buffer) {
+  public int drillDownTermText(FacetLabel path, char[] buffer) {
     return path.copyFullPath(buffer, 0, getFacetDelimChar());
   }
   
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionIndexingParams.java b/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionIndexingParams.java
index 18251e7..9fb2b0a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionIndexingParams.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionIndexingParams.java
@@ -6,7 +6,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -27,11 +27,11 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /**
  * A {@link FacetIndexingParams} that utilizes different category lists, defined
- * by the dimension specified by a {@link CategoryPath category} (see
+ * by the dimension specified by a {@link FacetLabel category} (see
  * {@link #PerDimensionIndexingParams(Map, CategoryListParams)}.
  * <p>
  * A 'dimension' is defined as the first or "zero-th" component in a
- * {@link CategoryPath}. For example, if a category is defined as
+ * {@link FacetLabel}. For example, if a category is defined as
  * "Author/American/Mark Twain", then the dimension would be "Author".
  * 
  * @lucene.experimental
@@ -43,7 +43,7 @@ public class PerDimensionIndexingParams extends FacetIndexingParams {
   /**
    * Initializes a new instance with the given dimension-to-params mapping. The
    * dimension is considered as what's returned by
-   * {@link CategoryPath#components cp.components[0]}.
+   * {@link FacetLabel#components cp.components[0]}.
    * 
    * <p>
    * <b>NOTE:</b> for any dimension whose {@link CategoryListParams} is not
@@ -51,7 +51,7 @@ public class PerDimensionIndexingParams extends FacetIndexingParams {
    * 
    * @see #PerDimensionIndexingParams(Map, CategoryListParams)
    */
-  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap) {
+  public PerDimensionIndexingParams(Map<FacetLabel, CategoryListParams> paramsMap) {
     this(paramsMap, DEFAULT_CATEGORY_LIST_PARAMS);
   }
 
@@ -60,11 +60,11 @@ public class PerDimensionIndexingParams extends FacetIndexingParams {
    * {@link CategoryListParams} will be used for any dimension that is not
    * specified in the given mapping.
    */
-  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap, 
+  public PerDimensionIndexingParams(Map<FacetLabel, CategoryListParams> paramsMap, 
       CategoryListParams categoryListParams) {
     super(categoryListParams);
     clParamsMap = new HashMap<String,CategoryListParams>();
-    for (Entry<CategoryPath, CategoryListParams> e : paramsMap.entrySet()) {
+    for (Entry<FacetLabel, CategoryListParams> e : paramsMap.entrySet()) {
       clParamsMap.put(e.getKey().components[0], e.getValue());
     }
   }
@@ -83,7 +83,7 @@ public class PerDimensionIndexingParams extends FacetIndexingParams {
    * returns the default {@link CategoryListParams}.
    */
   @Override
-  public CategoryListParams getCategoryListParams(CategoryPath category) {
+  public CategoryListParams getCategoryListParams(FacetLabel category) {
     if (category != null) {
       CategoryListParams clParams = clParamsMap.get(category.components[0]);
       if (clParams != null) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionOrdinalPolicy.java b/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionOrdinalPolicy.java
index 9446508..98568fb 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionOrdinalPolicy.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/params/PerDimensionOrdinalPolicy.java
@@ -2,7 +2,7 @@ package org.apache.lucene.facet.params;
 
 import java.util.Map;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -25,7 +25,7 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  * A {@link CategoryListParams} which allow controlling the
  * {@link CategoryListParams.OrdinalPolicy} used for each dimension. The
  * dimension is specified as the first component in
- * {@link CategoryPath#components}.
+ * {@link FacetLabel#components}.
  */
 public class PerDimensionOrdinalPolicy extends CategoryListParams {
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetRequest.java
index 8786fe9..86fe74a 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetRequest.java
@@ -25,7 +25,7 @@ import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsAggregator;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.queries.function.FunctionValues;
@@ -73,7 +73,7 @@ public class RangeFacetRequest<T extends Range> extends FacetRequest {
    */
   @SuppressWarnings("unchecked")
   public RangeFacetRequest(String label, ValueSource valueSource, T...ranges) {
-    super(new CategoryPath(label), 1);
+    super(new FacetLabel(label), 1);
     this.ranges = ranges;
     this.valueSource = valueSource;
     this.label = label;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetResultNode.java b/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetResultNode.java
index fcfc1b6..7a380aa 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetResultNode.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/RangeFacetResultNode.java
@@ -18,7 +18,7 @@ package org.apache.lucene.facet.range;
  */
 
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /** Holds the facet results for a {@link
  *  RangeFacetRequest}. */
@@ -28,6 +28,6 @@ public class RangeFacetResultNode extends FacetResultNode {
   RangeFacetResultNode(String field, Range range, int count) {
     super(-1, count);
     this.range = range;
-    this.label = new CategoryPath(field, range.label);
+    this.label = new FacetLabel(field, range.label);
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/sampling/TakmiSampleFixer.java b/lucene/facet/src/java/org/apache/lucene/facet/sampling/TakmiSampleFixer.java
index 2ec3613..b0b3a26 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/sampling/TakmiSampleFixer.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/sampling/TakmiSampleFixer.java
@@ -7,7 +7,7 @@ import org.apache.lucene.facet.old.ScoredDocIDsIterator;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.DrillDownQuery;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.IndexReader;
@@ -88,7 +88,7 @@ public class TakmiSampleFixer extends SampleFixer {
     if (fresNode.label == null) {
       fresNode.label = taxonomyReader.getPath(fresNode.ordinal);
     }
-    CategoryPath catPath = fresNode.label;
+    FacetLabel catPath = fresNode.label;
 
     Term drillDownTerm = DrillDownQuery.term(searchParams.indexingParams, catPath);
     // TODO (Facet): avoid Multi*?
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/CountFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/search/CountFacetRequest.java
index 24bb95e..6daf533 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/CountFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/CountFacetRequest.java
@@ -1,7 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -27,7 +27,7 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  */
 public class CountFacetRequest extends FacetRequest {
 
-  public CountFacetRequest(CategoryPath path, int num) {
+  public CountFacetRequest(FacetLabel path, int num) {
     super(path, num);
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/DrillDownQuery.java b/lucene/facet/src/java/org/apache/lucene/facet/search/DrillDownQuery.java
index f612ba1..6c4576f 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/DrillDownQuery.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/DrillDownQuery.java
@@ -24,7 +24,7 @@ import java.util.Map;
 
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
@@ -38,8 +38,8 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 
 /**
- * A {@link Query} for drill-down over {@link CategoryPath categories}. You
- * should call {@link #add(CategoryPath...)} for every group of categories you
+ * A {@link Query} for drill-down over {@link FacetLabel categories}. You
+ * should call {@link #add(FacetLabel...)} for every group of categories you
  * want to drill-down over. Each category in the group is {@code OR'ed} with
  * the others, and groups are {@code AND'ed}.
  * <p>
@@ -53,7 +53,7 @@ import org.apache.lucene.search.TermQuery;
 public final class DrillDownQuery extends Query {
 
   /** Return a drill-down {@link Term} for a category. */
-  public static Term term(FacetIndexingParams iParams, CategoryPath path) {
+  public static Term term(FacetIndexingParams iParams, FacetLabel path) {
     CategoryListParams clp = iParams.getCategoryListParams(path);
     char[] buffer = new char[path.fullPathLength()];
     iParams.drillDownTermText(path, buffer);
@@ -128,7 +128,7 @@ public final class DrillDownQuery extends Query {
    * Adds one dimension of drill downs; if you pass multiple values they are
    * OR'd, and then the entire dimension is AND'd against the base query.
    */
-  public void add(CategoryPath... paths) {
+  public void add(FacetLabel... paths) {
     Query q;
     if (paths[0].length == 0) {
       throw new IllegalArgumentException("all CategoryPaths must have length > 0");
@@ -141,7 +141,7 @@ public final class DrillDownQuery extends Query {
       q = new TermQuery(term(fip, paths[0]));
     } else {
       BooleanQuery bq = new BooleanQuery(true); // disable coord
-      for (CategoryPath cp : paths) {
+      for (FacetLabel cp : paths) {
         if (cp.length == 0) {
           throw new IllegalArgumentException("all CategoryPaths must have length > 0");
         }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetRequest.java
index 3bfa56e..5b4af6b 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetRequest.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.search;
 import org.apache.lucene.facet.params.CategoryListParams.OrdinalPolicy;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.range.RangeFacetRequest;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -64,7 +64,7 @@ public abstract class FacetRequest {
   public enum SortOrder { ASCENDING, DESCENDING }
 
   /** The category being aggregated in this facet request. */
-  public final CategoryPath categoryPath;
+  public final FacetLabel categoryPath;
   
   /** The number of child categories to return for {@link #categoryPath}. */
   public final int numResults;
@@ -88,7 +88,7 @@ public abstract class FacetRequest {
    *          {@code Integer.MAX_VALUE}, all immediate child categories will be
    *          returned. Must be greater than 0.
    */
-  public FacetRequest(CategoryPath path, int numResults) {
+  public FacetRequest(FacetLabel path, int numResults) {
     if (numResults <= 0) {
       throw new IllegalArgumentException("num results must be a positive (>0) number: " + numResults);
     }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult.java b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult.java
index aa2c239..8a0e920 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResult.java
@@ -8,7 +8,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.util.CollectionUtil;
 
@@ -36,7 +36,7 @@ import org.apache.lucene.util.CollectionUtil;
  */
 public class FacetResult {
   
-  private static FacetResultNode addIfNotExist(Map<CategoryPath, FacetResultNode> nodes, FacetResultNode node) {
+  private static FacetResultNode addIfNotExist(Map<FacetLabel, FacetResultNode> nodes, FacetResultNode node) {
     FacetResultNode n = nodes.get(node.label);
     if (n == null) {
       nodes.put(node.label, node);
@@ -51,7 +51,7 @@ public class FacetResult {
    * the hierarchy. The results are merged according to the following rules:
    * <ul>
    * <li>If two results share the same dimension (first component in their
-   * {@link CategoryPath}), they are merged.
+   * {@link FacetLabel}), they are merged.
    * <li>If a result is missing ancestors in the other results, e.g. A/B/C but
    * no corresponding A or A/B, these nodes are 'filled' with their label,
    * ordinal and value (obtained from the respective {@link FacetArrays}).
@@ -94,7 +94,7 @@ public class FacetResult {
             return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);
           }
         });
-        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<CategoryPath,FacetResultNode>();
+        Map<FacetLabel, FacetResultNode> mergedNodes = new HashMap<FacetLabel,FacetResultNode>();
         FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;
         for (FacetResult fr : frs) {
           FacetRequest freq = fr.getFacetRequest();
@@ -105,7 +105,7 @@ public class FacetResult {
           FacetResultNode frn = fr.getFacetResultNode();
           FacetResultNode merged = mergedNodes.get(frn.label);
           if (merged == null) {
-            CategoryPath parent = frn.label.subpath(frn.label.length - 1);
+            FacetLabel parent = frn.label.subpath(frn.label.length - 1);
             FacetResultNode childNode = frn;
             FacetResultNode parentNode = null;
             while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {
@@ -154,8 +154,8 @@ public class FacetResult {
         }
         
         // find the 'first' node to put on the FacetResult root
-        CategoryPath min = null;
-        for (CategoryPath cp : mergedNodes.keySet()) {
+        FacetLabel min = null;
+        for (FacetLabel cp : mergedNodes.keySet()) {
           if (min == null || cp.compareTo(min) < 0) {
             min = cp;
           }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResultNode.java b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResultNode.java
index bf49306..4e55c0b 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResultNode.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetResultNode.java
@@ -4,7 +4,7 @@ import java.util.Collections;
 import java.util.List;
 
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 
 /*
@@ -42,7 +42,7 @@ public class FacetResultNode implements Comparable<FacetResultNode> {
   public int ordinal;
 
   /**
-   * The {@link CategoryPath label} of this result. May be {@code null} if not
+   * The {@link FacetLabel label} of this result. May be {@code null} if not
    * computed, in which case use {@link TaxonomyReader#getPath(int)} to label
    * it.
    * <p>
@@ -50,7 +50,7 @@ public class FacetResultNode implements Comparable<FacetResultNode> {
    * {@link FacetRequest#getNumLabel()} &lt;
    * {@link FacetRequest#numResults} there will be unlabeled nodes.
    */
-  public CategoryPath label;
+  public FacetLabel label;
   
   /**
    * The value of this result. Its actual type depends on the
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetsCollector.java b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetsCollector.java
index f27d3e2..1b1f838 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/FacetsCollector.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/FacetsCollector.java
@@ -5,7 +5,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
@@ -203,7 +203,7 @@ public abstract class FacetsCollector extends Collector {
   /**
    * Returns a {@link FacetResult} per {@link FacetRequest} set in
    * {@link FacetSearchParams}. Note that if a {@link FacetRequest} defines a
-   * {@link CategoryPath} which does not exist in the taxonomy, an empty
+   * {@link FacetLabel} which does not exist in the taxonomy, an empty
    * {@link FacetResult} will be returned for it.
    */
   public final List<FacetResult> getFacetResults() throws IOException {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/MultiFacetsAggregator.java b/lucene/facet/src/java/org/apache/lucene/facet/search/MultiFacetsAggregator.java
index 1935ecb..cf96629 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/MultiFacetsAggregator.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/MultiFacetsAggregator.java
@@ -11,7 +11,7 @@ import org.apache.lucene.facet.search.FacetArrays;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetsAggregator;
 import org.apache.lucene.facet.search.FacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -41,7 +41,7 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  */
 public class MultiFacetsAggregator implements FacetsAggregator {
   
-  private final Map<CategoryPath,FacetsAggregator> categoryAggregators;
+  private final Map<FacetLabel,FacetsAggregator> categoryAggregators;
   private final List<FacetsAggregator> aggregators;
   
   /**
@@ -49,11 +49,11 @@ public class MultiFacetsAggregator implements FacetsAggregator {
    * <p>
    * The mapping is used to rollup the values of the specific category by the
    * corresponding {@link FacetsAggregator}. It is ok to pass differnet
-   * {@link FacetsAggregator} instances for each {@link CategoryPath} - the
+   * {@link FacetsAggregator} instances for each {@link FacetLabel} - the
    * constructor ensures that each aggregator <u>type</u> (determined by its
    * class) is invoked only once.
    */
-  public MultiFacetsAggregator(Map<CategoryPath,FacetsAggregator> aggregators) {
+  public MultiFacetsAggregator(Map<FacetLabel,FacetsAggregator> aggregators) {
     this.categoryAggregators = aggregators;
     
     // make sure that each FacetsAggregator class is invoked only once, or
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/SumScoreFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/search/SumScoreFacetRequest.java
index 09eb68c..6703fc5 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/SumScoreFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/SumScoreFacetRequest.java
@@ -1,7 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -29,7 +29,7 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
 public class SumScoreFacetRequest extends FacetRequest {
 
   /** Create a score facet request for a given node in the taxonomy. */
-  public SumScoreFacetRequest(CategoryPath path, int num) {
+  public SumScoreFacetRequest(FacetLabel path, int num) {
     super(path, num);
   }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/SumValueSourceFacetRequest.java b/lucene/facet/src/java/org/apache/lucene/facet/search/SumValueSourceFacetRequest.java
index 3c5288b..1d2e093 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/SumValueSourceFacetRequest.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/SumValueSourceFacetRequest.java
@@ -10,7 +10,7 @@ import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetsCollector.MatchingDocs;
 import org.apache.lucene.facet.search.OrdinalValueResolver.FloatValueResolver;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
@@ -176,7 +176,7 @@ public class SumValueSourceFacetRequest extends FacetRequest {
    * documents' values. You can also specify if the value source requires
    * document scores or not.
    */
-  public SumValueSourceFacetRequest(CategoryPath path, int num, ValueSource valueSource, boolean requiresDocScores) {
+  public SumValueSourceFacetRequest(FacetLabel path, int num, ValueSource valueSource, boolean requiresDocScores) {
     super(path, num);
     this.valueSource = valueSource;
     this.requiresDocScores = requiresDocScores;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/TaxonomyFacetsAccumulator.java b/lucene/facet/src/java/org/apache/lucene/facet/search/TaxonomyFacetsAccumulator.java
index a19ef68..b9fc5d8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/TaxonomyFacetsAccumulator.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/TaxonomyFacetsAccumulator.java
@@ -14,7 +14,7 @@ import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.FacetRequest.SortOrder;
 import org.apache.lucene.facet.search.FacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.ParallelTaxonomyArrays;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.IndexReader;
@@ -124,7 +124,7 @@ public class TaxonomyFacetsAccumulator extends FacetsAccumulator {
       CategoryListParams clp = e.getKey();
       List<FacetRequest> requests = e.getValue();
       Map<Class<? extends FacetsAggregator>,FacetsAggregator> aggClasses = new HashMap<Class<? extends FacetsAggregator>,FacetsAggregator>();
-      Map<CategoryPath,FacetsAggregator> perCategoryAggregator = new HashMap<CategoryPath,FacetsAggregator>();
+      Map<FacetLabel,FacetsAggregator> perCategoryAggregator = new HashMap<FacetLabel,FacetsAggregator>();
       for (FacetRequest fr : requests) {
         FacetsAggregator fa = fr.createFacetsAggregator(searchParams.indexingParams);
         if (fa == null) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler.java b/lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler.java
index 9952321..02c1061 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler.java
@@ -94,7 +94,7 @@ public class TopKInEachNodeHandler extends PartitionsFacetResultsHandler {
    *         too, excluded from the FacetResult tree.
    * @throws IOException
    *           in case
-   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}
+   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.FacetLabel)}
    *           does.
    * @see #fetchPartitionResult(int)
    */
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/FacetIndexWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/FacetIndexWriter.java
index 1905aa1..0e5db53 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/FacetIndexWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/FacetIndexWriter.java
@@ -29,7 +29,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.SortedSetDocValuesField;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.index.IndexDocument;
 import org.apache.lucene.index.IndexWriter;
@@ -155,7 +155,7 @@ public class FacetIndexWriter extends IndexWriter {
           throw new IllegalArgumentException("dimension \"" + facetField.dim + "\" is not hierarchical yet has " + facetField.path.length + " components");
         }
       
-        CategoryPath cp = CategoryPath.create(facetField.dim, facetField.path);
+        FacetLabel cp = FacetLabel.create(facetField.dim, facetField.path);
 
         int ordinal = taxoWriter.addCategory(cp);
         ordinals.ints[ordinals.length++] = ordinal;
@@ -193,7 +193,7 @@ public class FacetIndexWriter extends IndexWriter {
       //System.out.println("  field=" + indexedFieldName);
 
       for(SortedSetDocValuesFacetField facetField : ent.getValue()) {
-        CategoryPath cp = new CategoryPath(facetField.dim, facetField.label);
+        FacetLabel cp = new FacetLabel(facetField.dim, facetField.label);
         String fullPath = cp.toString(facetDelimChar);
         //System.out.println("add " + fullPath);
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
index 9412ad8..6dbe471 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/RangeFacetCounts.java
@@ -18,21 +18,17 @@ package org.apache.lucene.facet.simple;
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 import org.apache.lucene.facet.range.Range;
 import org.apache.lucene.facet.simple.SimpleFacetsCollector.MatchingDocs;
-import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.LongFieldSource;
 
 /**
- * Uses {@link RangeFacetRequest#getValues(AtomicReaderContext)} and accumulates
- * counts for provided ranges.
+ * accumulates counts for provided ranges.
  */
 public class RangeFacetCounts extends Facets {
   private final Range[] ranges;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillDownQuery.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillDownQuery.java
index 8036306..eb98893 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillDownQuery.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillDownQuery.java
@@ -23,7 +23,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.params.CategoryListParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
@@ -37,8 +37,8 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 
 /**
- * A {@link Query} for drill-down over {@link CategoryPath categories}. You
- * should call {@link #add(CategoryPath...)} for every group of categories you
+ * A {@link Query} for drill-down over {@link FacetLabel categories}. You
+ * should call {@link #add(FacetLabel...)} for every group of categories you
  * want to drill-down over. Each category in the group is {@code OR'ed} with
  * the others, and groups are {@code AND'ed}.
  * <p>
@@ -51,7 +51,7 @@ import org.apache.lucene.search.TermQuery;
  */
 public final class SimpleDrillDownQuery extends Query {
 
-  private static Term term(String field, char delimChar, CategoryPath path) {
+  private static Term term(String field, char delimChar, FacetLabel path) {
     return new Term(field, path.toString(delimChar));
   }
 
@@ -93,7 +93,7 @@ public final class SimpleDrillDownQuery extends Query {
   }
 
   /**
-   * Creates a new {@link DrillDownQuery} without a base query, 
+   * Creates a new {@code SimpleDrillDownQuery} without a base query, 
    * to perform a pure browsing query (equivalent to using
    * {@link MatchAllDocsQuery} as base).
    */
@@ -102,7 +102,7 @@ public final class SimpleDrillDownQuery extends Query {
   }
   
   /**
-   * Creates a new {@link DrillDownQuery} over the given base query. Can be
+   * Creates a new {@code SimpleDrillDownQuery} over the given base query. Can be
    * {@code null}, in which case the result {@link Query} from
    * {@link #rewrite(IndexReader)} will be a pure browsing query, filtering on
    * the added categories only.
@@ -119,17 +119,17 @@ public final class SimpleDrillDownQuery extends Query {
    * OR'd, and then the entire dimension is AND'd against the base query.
    */
   // nocommit can we remove CatPath here?
-  public void add(CategoryPath... paths) {
+  public void add(FacetLabel... paths) {
     add(FacetsConfig.DEFAULT_INDEXED_FIELD_NAME, Constants.DEFAULT_DELIM_CHAR, paths);
   }
 
   // nocommit can we remove CatPath here?
-  public void add(String field, CategoryPath... paths) {
+  public void add(String field, FacetLabel... paths) {
     add(field, Constants.DEFAULT_DELIM_CHAR, paths);
   }
 
   // nocommit can we remove CatPath here?
-  public void add(String field, char delimChar, CategoryPath... paths) {
+  public void add(String field, char delimChar, FacetLabel... paths) {
     Query q;
     if (paths[0].length == 0) {
       throw new IllegalArgumentException("all CategoryPaths must have length > 0");
@@ -142,7 +142,7 @@ public final class SimpleDrillDownQuery extends Query {
       q = new TermQuery(term(field, delimChar, paths[0]));
     } else {
       BooleanQuery bq = new BooleanQuery(true); // disable coord
-      for (CategoryPath cp : paths) {
+      for (FacetLabel cp : paths) {
         if (cp.length == 0) {
           throw new IllegalArgumentException("all CategoryPaths must have length > 0");
         }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
index aa27f0d..28cedba 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetResult.java
@@ -18,11 +18,11 @@ package org.apache.lucene.facet.simple;
  */
 
 import java.util.List;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 public final class SimpleFacetResult {
   /** Path whose children we counted. */
-  public final CategoryPath path;
+  public final FacetLabel path;
 
   /** Total value for this path (sum of all child counts, or
    *  sum of all child values), even those not included in
@@ -32,7 +32,7 @@ public final class SimpleFacetResult {
   /** Child counts. */
   public final LabelAndValue[] labelValues;
   
-  public SimpleFacetResult(CategoryPath path, Number value, LabelAndValue[] labelValues) {
+  public SimpleFacetResult(FacetLabel path, Number value, LabelAndValue[] labelValues) {
     this.path = path;
     this.value = value;
     this.labelValues = labelValues;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetsCollector.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetsCollector.java
index 9a44677..4479b72 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetsCollector.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleFacetsCollector.java
@@ -22,7 +22,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
index 69a3a87..80b7479 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/SortedSetDocValuesFacetCounts.java
@@ -29,7 +29,7 @@ import java.util.Map;
 import org.apache.lucene.facet.simple.SimpleFacetsCollector.MatchingDocs;
 import org.apache.lucene.facet.simple.SortedSetDocValuesReaderState.OrdRange;
 import org.apache.lucene.facet.simple.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiDocValues.MultiSortedSetDocValues;
@@ -40,7 +40,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.PriorityQueue;
 
 /** Compute facets counts from previously
- *  indexed {@link SortedSetDocValuesFacetFields},
+ *  indexed {@link SortedSetDocValuesFacetField},
  *  without require a separate taxonomy index.  Faceting is
  *  a bit slower (~25%), and there is added cost on every
  *  {@link IndexReader} open to create a new {@link
@@ -130,7 +130,7 @@ public class SortedSetDocValuesFacetCounts extends Facets {
       labelValues[i] = new LabelAndValue(s.substring(dim.length()+1, s.length()), ordAndCount.count);
     }
 
-    return new SimpleFacetResult(new CategoryPath(dim), dimCount, labelValues);
+    return new SimpleFacetResult(new FacetLabel(dim), dimCount, labelValues);
   }
 
   /** Does all the "real work" of tallying up the counts. */
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
index e848b94..4f75f00 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetCounts.java
@@ -25,7 +25,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.simple.SimpleFacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.ParallelTaxonomyArrays;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.BinaryDocValues;
@@ -100,7 +100,7 @@ public class TaxonomyFacetCounts extends Facets {
       String dim = ent.getKey();
       FacetsConfig.DimConfig ft = ent.getValue();
       if (ft.hierarchical && ft.multiValued == false) {
-        int dimRootOrd = taxoReader.getOrdinal(new CategoryPath(dim));
+        int dimRootOrd = taxoReader.getOrdinal(new FacetLabel(dim));
         // It can be -1 if this field was declared in the
         // facetsConfig but never indexed:
         if (dimRootOrd > 0) {
@@ -125,7 +125,7 @@ public class TaxonomyFacetCounts extends Facets {
    *  this path doesn't exist, else the count. */
   @Override
   public Number getSpecificValue(String dim, String... path) throws IOException {
-    int ord = taxoReader.getOrdinal(CategoryPath.create(dim, path));
+    int ord = taxoReader.getOrdinal(FacetLabel.create(dim, path));
     if (ord < 0) {
       return -1;
     }
@@ -134,7 +134,7 @@ public class TaxonomyFacetCounts extends Facets {
 
   @Override
   public SimpleFacetResult getTopChildren(int topN, String dim, String... path) throws IOException {
-    CategoryPath cp = CategoryPath.create(dim, path);
+    FacetLabel cp = FacetLabel.create(dim, path);
     int ord = taxoReader.getOrdinal(cp);
     if (ord == -1) {
       //System.out.println("no ord for path=" + path);
@@ -143,7 +143,7 @@ public class TaxonomyFacetCounts extends Facets {
     return getTopChildren(cp, ord, topN);
   }
 
-  private SimpleFacetResult getTopChildren(CategoryPath path, int dimOrd, int topN) throws IOException {
+  private SimpleFacetResult getTopChildren(FacetLabel path, int dimOrd, int topN) throws IOException {
 
     TopOrdCountQueue q = new TopOrdCountQueue(topN);
     
@@ -185,7 +185,7 @@ public class TaxonomyFacetCounts extends Facets {
     LabelAndValue[] labelValues = new LabelAndValue[q.size()];
     for(int i=labelValues.length-1;i>=0;i--) {
       TopOrdCountQueue.OrdAndCount ordAndCount = q.pop();
-      CategoryPath child = taxoReader.getPath(ordAndCount.ord);
+      FacetLabel child = taxoReader.getPath(ordAndCount.ord);
       labelValues[i] = new LabelAndValue(child.components[path.length], ordAndCount.count);
     }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
index ccd7c2a..db52577 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/simple/TaxonomyFacetSumValueSource.java
@@ -26,7 +26,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.simple.SimpleFacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.ParallelTaxonomyArrays;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.BinaryDocValues;
@@ -129,7 +129,7 @@ public class TaxonomyFacetSumValueSource extends Facets {
       String dim = ent.getKey();
       FacetsConfig.DimConfig ft = ent.getValue();
       if (ft.hierarchical && ft.multiValued == false) {
-        int dimRootOrd = taxoReader.getOrdinal(new CategoryPath(dim));
+        int dimRootOrd = taxoReader.getOrdinal(new FacetLabel(dim));
         assert dimRootOrd > 0;
         values[dimRootOrd] += rollup(children[dimRootOrd]);
       }
@@ -149,7 +149,7 @@ public class TaxonomyFacetSumValueSource extends Facets {
 
   @Override
   public Number getSpecificValue(String dim, String... path) throws IOException {
-    int ord = taxoReader.getOrdinal(CategoryPath.create(dim, path));
+    int ord = taxoReader.getOrdinal(FacetLabel.create(dim, path));
     if (ord < 0) {
       return -1;
     }
@@ -158,7 +158,7 @@ public class TaxonomyFacetSumValueSource extends Facets {
 
   @Override
   public SimpleFacetResult getTopChildren(int topN, String dim, String... path) throws IOException {
-    CategoryPath cp = CategoryPath.create(dim, path);
+    FacetLabel cp = FacetLabel.create(dim, path);
     int ord = taxoReader.getOrdinal(cp);
     if (ord == -1) {
       return null;
@@ -166,7 +166,7 @@ public class TaxonomyFacetSumValueSource extends Facets {
     return getTopChildren(cp, ord, topN);
   }
 
-  private SimpleFacetResult getTopChildren(CategoryPath path, int dimOrd, int topN) throws IOException {
+  private SimpleFacetResult getTopChildren(FacetLabel path, int dimOrd, int topN) throws IOException {
 
     TopOrdValueQueue q = new TopOrdValueQueue(topN);
     
@@ -207,7 +207,7 @@ public class TaxonomyFacetSumValueSource extends Facets {
     LabelAndValue[] labelValues = new LabelAndValue[q.size()];
     for(int i=labelValues.length-1;i>=0;i--) {
       TopOrdValueQueue.OrdAndValue ordAndValue = q.pop();
-      CategoryPath child = taxoReader.getPath(ordAndValue.ord);
+      FacetLabel child = taxoReader.getPath(ordAndValue.ord);
       labelValues[i] = new LabelAndValue(child.components[path.length], ordAndValue.value);
     }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java
index 0514ebf4..b15bb46 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java
@@ -33,7 +33,7 @@ import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsAccumulator;
 import org.apache.lucene.facet.search.FacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiDocValues;
@@ -234,7 +234,7 @@ public class SortedSetDocValuesAccumulator extends FacetsAccumulator {
             dimCount += counts[ord];
             FacetResultNode node = new FacetResultNode(ord, counts[ord]);
             dv.lookupOrd(ord, scratch);
-            node.label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));
+            node.label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));
             nodes.add(node);
           }
         }
@@ -258,7 +258,7 @@ public class SortedSetDocValuesAccumulator extends FacetsAccumulator {
         }
 
         FacetResultNode rootNode = new FacetResultNode(-1, dimCount);
-        rootNode.label = new CategoryPath(new String[] {dim});
+        rootNode.label = new FacetLabel(new String[] {dim});
         rootNode.subResults = nodes;
         results.add(new FacetResult(request, rootNode, nodes.size()));
         continue;
@@ -300,13 +300,13 @@ public class SortedSetDocValuesAccumulator extends FacetsAccumulator {
       }
 
       FacetResultNode rootNode = new FacetResultNode(-1, dimCount);
-      rootNode.label = new CategoryPath(new String[] {dim});
+      rootNode.label = new FacetLabel(new String[] {dim});
 
       FacetResultNode[] childNodes = new FacetResultNode[q.size()];
       for(int i=childNodes.length-1;i>=0;i--) {
         childNodes[i] = q.pop();
         dv.lookupOrd(childNodes[i].ordinal, scratch);
-        childNodes[i].label = new CategoryPath(scratch.utf8ToString().split(state.separatorRegex, 2));
+        childNodes[i].label = new FacetLabel(scratch.utf8ToString().split(state.separatorRegex, 2));
       }
       rootNode.subResults = Arrays.asList(childNodes);
       
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesFacetFields.java b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesFacetFields.java
index d21e7d5..18d94a7 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesFacetFields.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesFacetFields.java
@@ -28,7 +28,7 @@ import org.apache.lucene.facet.index.DrillDownStream;
 import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.BytesRef;
 
 /** Use this to index facets if you intend to
@@ -41,13 +41,13 @@ import org.apache.lucene.util.BytesRef;
 public class SortedSetDocValuesFacetFields extends FacetFields {
 
   /** Create a {@code SortedSetDocValuesFacetField} with the
-   *  provided {@link CategoryPath}. */
+   *  provided {@link FacetLabel}. */
   public SortedSetDocValuesFacetFields()  {
     this(FacetIndexingParams.DEFAULT);
   }
 
   /** Create a {@code SortedSetDocValuesFacetField} with the
-   *  provided {@link CategoryPath}, and custom {@link
+   *  provided {@link FacetLabel}, and custom {@link
    *  FacetIndexingParams}. */
   public SortedSetDocValuesFacetFields(FacetIndexingParams fip)  {
     super(null, fip);
@@ -57,19 +57,19 @@ public class SortedSetDocValuesFacetFields extends FacetFields {
   }
 
   @Override
-  public void addFields(Document doc, Iterable<CategoryPath> categories) throws IOException {
+  public void addFields(Document doc, Iterable<FacetLabel> categories) throws IOException {
     if (categories == null) {
       throw new IllegalArgumentException("categories should not be null");
     }
 
-    final Map<CategoryListParams,Iterable<CategoryPath>> categoryLists = createCategoryListMapping(categories);
-    for (Entry<CategoryListParams, Iterable<CategoryPath>> e : categoryLists.entrySet()) {
+    final Map<CategoryListParams,Iterable<FacetLabel>> categoryLists = createCategoryListMapping(categories);
+    for (Entry<CategoryListParams, Iterable<FacetLabel>> e : categoryLists.entrySet()) {
 
       CategoryListParams clp = e.getKey();
       String dvField = clp.field + SortedSetDocValuesReaderState.FACET_FIELD_EXTENSION;
 
       // Add sorted-set DV fields, one per value:
-      for(CategoryPath cp : e.getValue()) {
+      for(FacetLabel cp : e.getValue()) {
         if (cp.length != 2) {
           throw new IllegalArgumentException("only flat facets (dimension + label) are currently supported; got " + cp);
         }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath.java
deleted file mode 100644
index 62eeb9f..0000000
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath.java
+++ /dev/null
@@ -1,291 +0,0 @@
-package org.apache.lucene.facet.taxonomy;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_SIZE;
-
-import java.util.Arrays;
-import java.util.regex.Pattern;
-
-/**
- * Holds a sequence of string components, specifying the hierarchical name of a
- * category.
- * 
- * @lucene.experimental
- */
-// nocommit rename to FacetLabel?
-public class CategoryPath implements Comparable<CategoryPath> {
-
-  /*
-   * copied from DocumentWriterPerThread -- if a CategoryPath is resolved to a
-   * drill-down term which is encoded to a larger term than that length, it is
-   * silently dropped! Therefore we limit the number of characters to MAX/4 to
-   * be on the safe side.
-   */
-  /**
-   * The maximum number of characters a {@link CategoryPath} can have. That is
-   * {@link CategoryPath#toString(char)} length must not exceed that limit.
-   */
-  public final static int MAX_CATEGORY_PATH_LENGTH = (BYTE_BLOCK_SIZE - 2) / 4;
-
-  /** An empty {@link CategoryPath} */
-  public static final CategoryPath EMPTY = new CategoryPath();
-
-  /**
-   * The components of this {@link CategoryPath}. Note that this array may be
-   * shared with other {@link CategoryPath} instances, e.g. as a result of
-   * {@link #subpath(int)}, therefore you should traverse the array up to
-   * {@link #length} for this path's components.
-   */
-  public final String[] components;
-
-  /** The number of components of this {@link CategoryPath}. */
-  public final int length;
-
-  // Used by singleton EMPTY
-  private CategoryPath() {
-    components = null;
-    length = 0;
-  }
-
-  // Used by subpath
-  private CategoryPath(final CategoryPath copyFrom, final int prefixLen) {
-    // while the code which calls this method is safe, at some point a test
-    // tripped on AIOOBE in toString, but we failed to reproduce. adding the
-    // assert as a safety check.
-    assert prefixLen > 0 && prefixLen <= copyFrom.components.length : 
-      "prefixLen cannot be negative nor larger than the given components' length: prefixLen=" + prefixLen
-        + " components.length=" + copyFrom.components.length;
-    this.components = copyFrom.components;
-    length = prefixLen;
-  }
-  
-  /** Construct from the given path components. */
-  public CategoryPath(final String... components) {
-    assert components.length > 0 : "use CategoryPath.EMPTY to create an empty path";
-    long len = 0;
-    for (String comp : components) {
-      if (comp == null || comp.isEmpty()) {
-        throw new IllegalArgumentException("empty or null components not allowed: " + Arrays.toString(components));
-      }
-      len += comp.length();
-    }
-    len += components.length - 1; // add separators
-    if (len > MAX_CATEGORY_PATH_LENGTH) {
-      throw new IllegalArgumentException("category path exceeds maximum allowed path length: max="
-          + MAX_CATEGORY_PATH_LENGTH + " len=" + len
-          + " path=" + Arrays.toString(components).substring(0, 30) + "...");
-    }
-    this.components = components;
-    length = components.length;
-  }
-
-  // nocommit javadocs/rename
-  public static CategoryPath create(String dim, String... path) {
-    String[] components = new String[1+path.length];
-    components[0] = dim;
-    System.arraycopy(path, 0, components, 1, path.length);
-    return new CategoryPath(components);
-  }
-
-  /** Construct from a given path, separating path components with {@code delimiter}. */
-  public CategoryPath(final String pathString, final char delimiter) {
-    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {
-      throw new IllegalArgumentException("category path exceeds maximum allowed path length: max="
-              + MAX_CATEGORY_PATH_LENGTH + " len=" + pathString.length()
-              + " path=" + pathString.substring(0, 30) + "...");
-    }
-
-    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));
-    if (comps.length == 1 && comps[0].isEmpty()) {
-      components = null;
-      length = 0;
-    } else {
-      for (String comp : comps) {
-        if (comp == null || comp.isEmpty()) {
-          throw new IllegalArgumentException("empty or null components not allowed: " + Arrays.toString(comps));
-        }
-      }
-      components = comps;
-      length = components.length;
-    }
-  }
-
-  /**
-   * Returns the number of characters needed to represent the path, including
-   * delimiter characters, for using with
-   * {@link #copyFullPath(char[], int, char)}.
-   */
-  public int fullPathLength() {
-    if (length == 0) return 0;
-    
-    int charsNeeded = 0;
-    for (int i = 0; i < length; i++) {
-      charsNeeded += components[i].length();
-    }
-    charsNeeded += length - 1; // num delimter chars
-    return charsNeeded;
-  }
-
-  /**
-   * Compares this path with another {@link CategoryPath} for lexicographic
-   * order.
-   */
-  @Override
-  public int compareTo(CategoryPath other) {
-    final int len = length < other.length ? length : other.length;
-    for (int i = 0, j = 0; i < len; i++, j++) {
-      int cmp = components[i].compareTo(other.components[j]);
-      if (cmp < 0) return -1; // this is 'before'
-      if (cmp > 0) return 1; // this is 'after'
-    }
-    
-    // one is a prefix of the other
-    return length - other.length;
-  }
-
-  private void hasDelimiter(String offender, char delimiter) {
-    throw new IllegalArgumentException("delimiter character '" + delimiter + "' (U+" + Integer.toHexString(delimiter) + ") appears in path component \"" + offender + "\"");
-  }
-
-  private void noDelimiter(char[] buf, int offset, int len, char delimiter) {
-    for(int idx=0;idx<len;idx++) {
-      if (buf[offset+idx] == delimiter) {
-        hasDelimiter(new String(buf, offset, len), delimiter);
-      }
-    }
-  }
-
-  /**
-   * Copies the path components to the given {@code char[]}, starting at index
-   * {@code start}. {@code delimiter} is copied between the path components.
-   * Returns the number of chars copied.
-   * 
-   * <p>
-   * <b>NOTE:</b> this method relies on the array being large enough to hold the
-   * components and separators - the amount of needed space can be calculated
-   * with {@link #fullPathLength()}.
-   */
-  public int copyFullPath(char[] buf, int start, char delimiter) {
-    if (length == 0) {
-      return 0;
-    }
-
-    int idx = start;
-    int upto = length - 1;
-    for (int i = 0; i < upto; i++) {
-      int len = components[i].length();
-      components[i].getChars(0, len, buf, idx);
-      noDelimiter(buf, idx, len, delimiter);
-      idx += len;
-      buf[idx++] = delimiter;
-    }
-    components[upto].getChars(0, components[upto].length(), buf, idx);
-    noDelimiter(buf, idx, components[upto].length(), delimiter);
-    
-    return idx + components[upto].length() - start;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (!(obj instanceof CategoryPath)) {
-      return false;
-    }
-    
-    CategoryPath other = (CategoryPath) obj;
-    if (length != other.length) {
-      return false; // not same length, cannot be equal
-    }
-    
-    // CategoryPaths are more likely to differ at the last components, so start
-    // from last-first
-    for (int i = length - 1; i >= 0; i--) {
-      if (!components[i].equals(other.components[i])) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    if (length == 0) {
-      return 0;
-    }
-    
-    int hash = length;
-    for (int i = 0; i < length; i++) {
-      hash = hash * 31 + components[i].hashCode();
-    }
-    return hash;
-  }
-
-  /** Calculate a 64-bit hash function for this path. */
-  public long longHashCode() {
-    if (length == 0) {
-      return 0;
-    }
-    
-    long hash = length;
-    for (int i = 0; i < length; i++) {
-      hash = hash * 65599 + components[i].hashCode();
-    }
-    return hash;
-  }
-
-  /** Returns a sub-path of this path up to {@code length} components. */
-  public CategoryPath subpath(final int length) {
-    if (length >= this.length || length < 0) {
-      return this;
-    } else if (length == 0) {
-      return EMPTY;
-    } else {
-      return new CategoryPath(this, length);
-    }
-  }
-
-  /**
-   * Returns a string representation of the path, separating components with
-   * '/'.
-   * 
-   * @see #toString(char)
-   */
-  @Override
-  public String toString() {
-    return toString('/');
-  }
-
-  /**
-   * Returns a string representation of the path, separating components with the
-   * given delimiter.
-   */
-  public String toString(char delimiter) {
-    if (length == 0) return "";
-    
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < length; i++) {
-      if (components[i].indexOf(delimiter) != -1) {
-        hasDelimiter(components[i], delimiter);
-      }
-      sb.append(components[i]).append(delimiter);
-    }
-    sb.setLength(sb.length() - 1); // remove last delimiter
-    return sb.toString();
-  }
-
-}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java
new file mode 100644
index 0000000..ce0b3fc
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java
@@ -0,0 +1,291 @@
+package org.apache.lucene.facet.taxonomy;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_SIZE;
+
+import java.util.Arrays;
+import java.util.regex.Pattern;
+
+/**
+ * Holds a sequence of string components, specifying the hierarchical name of a
+ * category.
+ * 
+ * @lucene.experimental
+ */
+// nocommit rename to just Label under .facet?
+public class FacetLabel implements Comparable<FacetLabel> {
+
+  /*
+   * copied from DocumentWriterPerThread -- if a CategoryPath is resolved to a
+   * drill-down term which is encoded to a larger term than that length, it is
+   * silently dropped! Therefore we limit the number of characters to MAX/4 to
+   * be on the safe side.
+   */
+  /**
+   * The maximum number of characters a {@link FacetLabel} can have. That is
+   * {@link FacetLabel#toString(char)} length must not exceed that limit.
+   */
+  public final static int MAX_CATEGORY_PATH_LENGTH = (BYTE_BLOCK_SIZE - 2) / 4;
+
+  /** An empty {@link FacetLabel} */
+  public static final FacetLabel EMPTY = new FacetLabel();
+
+  /**
+   * The components of this {@link FacetLabel}. Note that this array may be
+   * shared with other {@link FacetLabel} instances, e.g. as a result of
+   * {@link #subpath(int)}, therefore you should traverse the array up to
+   * {@link #length} for this path's components.
+   */
+  public final String[] components;
+
+  /** The number of components of this {@link FacetLabel}. */
+  public final int length;
+
+  // Used by singleton EMPTY
+  private FacetLabel() {
+    components = null;
+    length = 0;
+  }
+
+  // Used by subpath
+  private FacetLabel(final FacetLabel copyFrom, final int prefixLen) {
+    // while the code which calls this method is safe, at some point a test
+    // tripped on AIOOBE in toString, but we failed to reproduce. adding the
+    // assert as a safety check.
+    assert prefixLen > 0 && prefixLen <= copyFrom.components.length : 
+      "prefixLen cannot be negative nor larger than the given components' length: prefixLen=" + prefixLen
+        + " components.length=" + copyFrom.components.length;
+    this.components = copyFrom.components;
+    length = prefixLen;
+  }
+  
+  /** Construct from the given path components. */
+  public FacetLabel(final String... components) {
+    assert components.length > 0 : "use CategoryPath.EMPTY to create an empty path";
+    long len = 0;
+    for (String comp : components) {
+      if (comp == null || comp.isEmpty()) {
+        throw new IllegalArgumentException("empty or null components not allowed: " + Arrays.toString(components));
+      }
+      len += comp.length();
+    }
+    len += components.length - 1; // add separators
+    if (len > MAX_CATEGORY_PATH_LENGTH) {
+      throw new IllegalArgumentException("category path exceeds maximum allowed path length: max="
+          + MAX_CATEGORY_PATH_LENGTH + " len=" + len
+          + " path=" + Arrays.toString(components).substring(0, 30) + "...");
+    }
+    this.components = components;
+    length = components.length;
+  }
+
+  // nocommit javadocs/rename
+  public static FacetLabel create(String dim, String... path) {
+    String[] components = new String[1+path.length];
+    components[0] = dim;
+    System.arraycopy(path, 0, components, 1, path.length);
+    return new FacetLabel(components);
+  }
+
+  /** Construct from a given path, separating path components with {@code delimiter}. */
+  public FacetLabel(final String pathString, final char delimiter) {
+    if (pathString.length() > MAX_CATEGORY_PATH_LENGTH) {
+      throw new IllegalArgumentException("category path exceeds maximum allowed path length: max="
+              + MAX_CATEGORY_PATH_LENGTH + " len=" + pathString.length()
+              + " path=" + pathString.substring(0, 30) + "...");
+    }
+
+    String[] comps = pathString.split(Pattern.quote(Character.toString(delimiter)));
+    if (comps.length == 1 && comps[0].isEmpty()) {
+      components = null;
+      length = 0;
+    } else {
+      for (String comp : comps) {
+        if (comp == null || comp.isEmpty()) {
+          throw new IllegalArgumentException("empty or null components not allowed: " + Arrays.toString(comps));
+        }
+      }
+      components = comps;
+      length = components.length;
+    }
+  }
+
+  /**
+   * Returns the number of characters needed to represent the path, including
+   * delimiter characters, for using with
+   * {@link #copyFullPath(char[], int, char)}.
+   */
+  public int fullPathLength() {
+    if (length == 0) return 0;
+    
+    int charsNeeded = 0;
+    for (int i = 0; i < length; i++) {
+      charsNeeded += components[i].length();
+    }
+    charsNeeded += length - 1; // num delimter chars
+    return charsNeeded;
+  }
+
+  /**
+   * Compares this path with another {@link FacetLabel} for lexicographic
+   * order.
+   */
+  @Override
+  public int compareTo(FacetLabel other) {
+    final int len = length < other.length ? length : other.length;
+    for (int i = 0, j = 0; i < len; i++, j++) {
+      int cmp = components[i].compareTo(other.components[j]);
+      if (cmp < 0) return -1; // this is 'before'
+      if (cmp > 0) return 1; // this is 'after'
+    }
+    
+    // one is a prefix of the other
+    return length - other.length;
+  }
+
+  private void hasDelimiter(String offender, char delimiter) {
+    throw new IllegalArgumentException("delimiter character '" + delimiter + "' (U+" + Integer.toHexString(delimiter) + ") appears in path component \"" + offender + "\"");
+  }
+
+  private void noDelimiter(char[] buf, int offset, int len, char delimiter) {
+    for(int idx=0;idx<len;idx++) {
+      if (buf[offset+idx] == delimiter) {
+        hasDelimiter(new String(buf, offset, len), delimiter);
+      }
+    }
+  }
+
+  /**
+   * Copies the path components to the given {@code char[]}, starting at index
+   * {@code start}. {@code delimiter} is copied between the path components.
+   * Returns the number of chars copied.
+   * 
+   * <p>
+   * <b>NOTE:</b> this method relies on the array being large enough to hold the
+   * components and separators - the amount of needed space can be calculated
+   * with {@link #fullPathLength()}.
+   */
+  public int copyFullPath(char[] buf, int start, char delimiter) {
+    if (length == 0) {
+      return 0;
+    }
+
+    int idx = start;
+    int upto = length - 1;
+    for (int i = 0; i < upto; i++) {
+      int len = components[i].length();
+      components[i].getChars(0, len, buf, idx);
+      noDelimiter(buf, idx, len, delimiter);
+      idx += len;
+      buf[idx++] = delimiter;
+    }
+    components[upto].getChars(0, components[upto].length(), buf, idx);
+    noDelimiter(buf, idx, components[upto].length(), delimiter);
+    
+    return idx + components[upto].length() - start;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (!(obj instanceof FacetLabel)) {
+      return false;
+    }
+    
+    FacetLabel other = (FacetLabel) obj;
+    if (length != other.length) {
+      return false; // not same length, cannot be equal
+    }
+    
+    // CategoryPaths are more likely to differ at the last components, so start
+    // from last-first
+    for (int i = length - 1; i >= 0; i--) {
+      if (!components[i].equals(other.components[i])) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    if (length == 0) {
+      return 0;
+    }
+    
+    int hash = length;
+    for (int i = 0; i < length; i++) {
+      hash = hash * 31 + components[i].hashCode();
+    }
+    return hash;
+  }
+
+  /** Calculate a 64-bit hash function for this path. */
+  public long longHashCode() {
+    if (length == 0) {
+      return 0;
+    }
+    
+    long hash = length;
+    for (int i = 0; i < length; i++) {
+      hash = hash * 65599 + components[i].hashCode();
+    }
+    return hash;
+  }
+
+  /** Returns a sub-path of this path up to {@code length} components. */
+  public FacetLabel subpath(final int length) {
+    if (length >= this.length || length < 0) {
+      return this;
+    } else if (length == 0) {
+      return EMPTY;
+    } else {
+      return new FacetLabel(this, length);
+    }
+  }
+
+  /**
+   * Returns a string representation of the path, separating components with
+   * '/'.
+   * 
+   * @see #toString(char)
+   */
+  @Override
+  public String toString() {
+    return toString('/');
+  }
+
+  /**
+   * Returns a string representation of the path, separating components with the
+   * given delimiter.
+   */
+  public String toString(char delimiter) {
+    if (length == 0) return "";
+    
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < length; i++) {
+      if (components[i].indexOf(delimiter) != -1) {
+        hasDelimiter(components[i], delimiter);
+      }
+      sb.append(components[i]).append(delimiter);
+    }
+    sb.setLength(sb.length() - 1); // remove last delimiter
+    return sb.toString();
+  }
+
+}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java
index d566c74..716dbaa 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java
@@ -92,7 +92,7 @@ public abstract class TaxonomyReader implements Closeable {
   
   /**
    * The root category (the category with the empty path) always has the ordinal
-   * 0, to which we give a name ROOT_ORDINAL. {@link #getOrdinal(CategoryPath)}
+   * 0, to which we give a name ROOT_ORDINAL. {@link #getOrdinal(FacetLabel)}
    * of an empty path will always return {@code ROOT_ORDINAL}, and
    * {@link #getPath(int)} with {@code ROOT_ORDINAL} will return the empty path.
    */
@@ -215,10 +215,10 @@ public abstract class TaxonomyReader implements Closeable {
    * @return the category's ordinal or {@link #INVALID_ORDINAL} if the category
    *         wasn't foun.
    */
-  public abstract int getOrdinal(CategoryPath categoryPath) throws IOException;
+  public abstract int getOrdinal(FacetLabel categoryPath) throws IOException;
   
   /** Returns the path name of the category with the given ordinal. */
-  public abstract CategoryPath getPath(int ordinal) throws IOException;
+  public abstract FacetLabel getPath(int ordinal) throws IOException;
   
   /** Returns the current refCount for this taxonomy reader. */
   public final int getRefCount() {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
index 46792b2..d00d1d0 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
@@ -64,7 +64,7 @@ public interface TaxonomyWriter extends Closeable, TwoPhaseCommit {
    * ordinal of a category is guaranteed to be smaller then the ordinal of
    * any of its descendants. 
    */ 
-  public int addCategory(CategoryPath categoryPath) throws IOException;
+  public int addCategory(FacetLabel categoryPath) throws IOException;
   
   /**
    * getParent() returns the ordinal of the parent category of the category
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
index c551d64..9601ffd 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyReader.java
@@ -6,7 +6,7 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import org.apache.lucene.facet.collections.LRUHashMap;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.ParallelTaxonomyArrays;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.index.CorruptIndexException; // javadocs
@@ -60,8 +60,8 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
   private final DirectoryReader indexReader;
 
   // TODO: test DoubleBarrelLRUCache and consider using it instead
-  private LRUHashMap<CategoryPath, Integer> ordinalCache;
-  private LRUHashMap<Integer, CategoryPath> categoryCache;
+  private LRUHashMap<FacetLabel, Integer> ordinalCache;
+  private LRUHashMap<Integer, FacetLabel> categoryCache;
 
   private volatile TaxonomyIndexArrays taxoArrays;
 
@@ -73,15 +73,15 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
    * arrays.
    */
   DirectoryTaxonomyReader(DirectoryReader indexReader, DirectoryTaxonomyWriter taxoWriter,
-      LRUHashMap<CategoryPath,Integer> ordinalCache, LRUHashMap<Integer,CategoryPath> categoryCache,
+      LRUHashMap<FacetLabel,Integer> ordinalCache, LRUHashMap<Integer,FacetLabel> categoryCache,
       TaxonomyIndexArrays taxoArrays) throws IOException {
     this.indexReader = indexReader;
     this.taxoWriter = taxoWriter;
     this.taxoEpoch = taxoWriter == null ? -1 : taxoWriter.getTaxonomyEpoch();
     
     // use the same instance of the cache, note the protective code in getOrdinal and getPath
-    this.ordinalCache = ordinalCache == null ? new LRUHashMap<CategoryPath,Integer>(DEFAULT_CACHE_VALUE) : ordinalCache;
-    this.categoryCache = categoryCache == null ? new LRUHashMap<Integer,CategoryPath>(DEFAULT_CACHE_VALUE) : categoryCache;
+    this.ordinalCache = ordinalCache == null ? new LRUHashMap<FacetLabel,Integer>(DEFAULT_CACHE_VALUE) : ordinalCache;
+    this.categoryCache = categoryCache == null ? new LRUHashMap<Integer,FacetLabel>(DEFAULT_CACHE_VALUE) : categoryCache;
     
     this.taxoArrays = taxoArrays != null ? new TaxonomyIndexArrays(indexReader, taxoArrays) : null;
   }
@@ -103,8 +103,8 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
 
     // These are the default cache sizes; they can be configured after
     // construction with the cache's setMaxSize() method
-    ordinalCache = new LRUHashMap<CategoryPath, Integer>(DEFAULT_CACHE_VALUE);
-    categoryCache = new LRUHashMap<Integer, CategoryPath>(DEFAULT_CACHE_VALUE);
+    ordinalCache = new LRUHashMap<FacetLabel, Integer>(DEFAULT_CACHE_VALUE);
+    categoryCache = new LRUHashMap<Integer, FacetLabel>(DEFAULT_CACHE_VALUE);
   }
   
   /**
@@ -122,8 +122,8 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
     
     // These are the default cache sizes; they can be configured after
     // construction with the cache's setMaxSize() method
-    ordinalCache = new LRUHashMap<CategoryPath, Integer>(DEFAULT_CACHE_VALUE);
-    categoryCache = new LRUHashMap<Integer, CategoryPath>(DEFAULT_CACHE_VALUE);
+    ordinalCache = new LRUHashMap<FacetLabel, Integer>(DEFAULT_CACHE_VALUE);
+    categoryCache = new LRUHashMap<Integer, FacetLabel>(DEFAULT_CACHE_VALUE);
   }
   
   private synchronized void initTaxoArrays() throws IOException {
@@ -242,7 +242,7 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
   }
 
   @Override
-  public int getOrdinal(CategoryPath cp) throws IOException {
+  public int getOrdinal(FacetLabel cp) throws IOException {
     ensureOpen();
     if (cp.length == 0) {
       return ROOT_ORDINAL;
@@ -288,7 +288,7 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
   }
 
   @Override
-  public CategoryPath getPath(int ordinal) throws IOException {
+  public FacetLabel getPath(int ordinal) throws IOException {
     ensureOpen();
     
     // Since the cache is shared with DTR instances allocated from
@@ -303,14 +303,14 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
     // wrapped as LRU?
     Integer catIDInteger = Integer.valueOf(ordinal);
     synchronized (categoryCache) {
-      CategoryPath res = categoryCache.get(catIDInteger);
+      FacetLabel res = categoryCache.get(catIDInteger);
       if (res != null) {
         return res;
       }
     }
     
     StoredDocument doc = indexReader.document(ordinal);
-    CategoryPath ret = new CategoryPath(doc.get(Consts.FULL), delimiter);
+    FacetLabel ret = new FacetLabel(doc.get(Consts.FULL), delimiter);
     synchronized (categoryCache) {
       categoryCache.put(catIDInteger, ret);
     }
@@ -326,7 +326,7 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
   
   /**
    * setCacheSize controls the maximum allowed size of each of the caches
-   * used by {@link #getPath(int)} and {@link #getOrdinal(CategoryPath)}.
+   * used by {@link #getPath(int)} and {@link #getOrdinal(FacetLabel)}.
    * <P>
    * Currently, if the given size is smaller than the current size of
    * a cache, it will not shrink, and rather we be limited to its current
@@ -364,7 +364,7 @@ public class DirectoryTaxonomyReader extends TaxonomyReader {
     int upperl = Math.min(max, indexReader.maxDoc());
     for (int i = 0; i < upperl; i++) {
       try {
-        CategoryPath category = this.getPath(i);
+        FacetLabel category = this.getPath(i);
         if (category == null) {
           sb.append(i + ": NULL!! \n");
           continue;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
index a269f5c..6230116 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
@@ -21,7 +21,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
@@ -248,7 +248,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
       cacheIsComplete = true;
       // Make sure that the taxonomy always contain the root category
       // with category id 0.
-      addCategory(CategoryPath.EMPTY);
+      addCategory(FacetLabel.EMPTY);
     } else {
       // There are some categories on the disk, which we have not yet
       // read into the cache, and therefore the cache is incomplete.
@@ -388,7 +388,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
    * returning the category's ordinal, or a negative number in case the
    * category does not yet exist in the taxonomy.
    */
-  protected synchronized int findCategory(CategoryPath categoryPath) throws IOException {
+  protected synchronized int findCategory(FacetLabel categoryPath) throws IOException {
     // If we can find the category in the cache, or we know the cache is
     // complete, we can return the response directly from it
     int res = cache.get(categoryPath);
@@ -447,7 +447,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
   }
 
   @Override
-  public int addCategory(CategoryPath categoryPath) throws IOException {
+  public int addCategory(FacetLabel categoryPath) throws IOException {
     ensureOpen();
     // check the cache outside the synchronized block. this results in better
     // concurrency when categories are there.
@@ -479,14 +479,14 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
    * parent is always added to the taxonomy before its child). We do this by
    * recursion.
    */
-  private int internalAddCategory(CategoryPath cp) throws IOException {
+  private int internalAddCategory(FacetLabel cp) throws IOException {
     // Find our parent's ordinal (recursively adding the parent category
     // to the taxonomy if it's not already there). Then add the parent
     // ordinal as payloads (rather than a stored field; payloads can be
     // more efficiently read into memory in bulk by LuceneTaxonomyReader)
     int parent;
     if (cp.length > 1) {
-      CategoryPath parentPath = cp.subpath(cp.length - 1);
+      FacetLabel parentPath = cp.subpath(cp.length - 1);
       parent = findCategory(parentPath);
       if (parent < 0) {
         parent = internalAddCategory(parentPath);
@@ -515,7 +515,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
    * Note that the methods calling addCategoryDocument() are synchornized, so
    * this method is effectively synchronized as well.
    */
-  private int addCategoryDocument(CategoryPath categoryPath, int parent) throws IOException {
+  private int addCategoryDocument(FacetLabel categoryPath, int parent) throws IOException {
     // Before Lucene 2.9, position increments >=0 were supported, so we
     // added 1 to parent to allow the parent -1 (the parent of the root).
     // Unfortunately, starting with Lucene 2.9, after LUCENE-1542, this is
@@ -596,7 +596,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
     }
   }
 
-  private void addToCache(CategoryPath categoryPath, int id) throws IOException {
+  private void addToCache(FacetLabel categoryPath, int id) throws IOException {
     if (cache.put(categoryPath, id)) {
       // If cache.put() returned true, it means the cache was limited in
       // size, became full, and parts of it had to be evicted. It is
@@ -729,7 +729,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
               // hence documents), there are no deletions in the index. Therefore, it
               // is sufficient to call next(), and then doc(), exactly once with no
               // 'validation' checks.
-              CategoryPath cp = new CategoryPath(t.utf8ToString(), delimiter);
+              FacetLabel cp = new FacetLabel(t.utf8ToString(), delimiter);
               docsEnum = termsEnum.docs(null, docsEnum, DocsEnum.FLAG_NONE);
               boolean res = cache.put(cp, docsEnum.nextDoc() + ctx.docBase);
               assert !res : "entries should not have been evicted from the cache";
@@ -819,7 +819,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
         te = terms.iterator(te);
         while (te.next() != null) {
           String value = te.term().utf8ToString();
-          CategoryPath cp = new CategoryPath(value, delimiter);
+          FacetLabel cp = new FacetLabel(value, delimiter);
           final int ordinal = addCategory(cp);
           docs = te.docs(null, docs, DocsEnum.FLAG_NONE);
           ordinalMap.addMapping(docs.nextDoc() + base, ordinal);
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/TaxonomyWriterCache.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/TaxonomyWriterCache.java
index bfcc611..5e7ffda 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/TaxonomyWriterCache.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/TaxonomyWriterCache.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.taxonomy.writercache;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 
 /*
@@ -37,7 +37,7 @@ import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
  * <p>
  * However, if it does so, it should clear out large parts of the cache at once,
  * because the user will typically need to work hard to recover from every cache
- * cleanup (see {@link #put(CategoryPath, int)}'s return value).
+ * cleanup (see {@link #put(FacetLabel, int)}'s return value).
  * <p>
  * <b>NOTE:</b> the cache may be accessed concurrently by multiple threads,
  * therefore cache implementations should take this into consideration.
@@ -62,7 +62,7 @@ public interface TaxonomyWriterCache {
    * it means the category does not exist. Otherwise, the category might
    * still exist, but just be missing from the cache.
    */
-  public int get(CategoryPath categoryPath);
+  public int get(FacetLabel categoryPath);
 
   /**
    * Add a category to the cache, with the given ordinal as the value.
@@ -82,7 +82,7 @@ public interface TaxonomyWriterCache {
    * It doesn't really matter, because normally the next thing we do after
    * finding that a category does not exist is to add it.
    */
-  public boolean put(CategoryPath categoryPath, int ordinal);
+  public boolean put(FacetLabel categoryPath, int ordinal);
 
   /**
    * Returns true if the cache is full, such that the next {@link #put} will
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CategoryPathUtils.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CategoryPathUtils.java
index f1d2e96..b9167b0 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CategoryPathUtils.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CategoryPathUtils.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.taxonomy.writercache.cl2o;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -19,11 +19,11 @@ import org.apache.lucene.facet.taxonomy.CategoryPath;
  * limitations under the License.
  */
 
-/** Utilities for use of {@link CategoryPath} by {@link CompactLabelToOrdinal}. */
+/** Utilities for use of {@link FacetLabel} by {@link CompactLabelToOrdinal}. */
 class CategoryPathUtils {
   
-  /** Serializes the given {@link CategoryPath} to the {@link CharBlockArray}. */
-  public static void serialize(CategoryPath cp, CharBlockArray charBlockArray) {
+  /** Serializes the given {@link FacetLabel} to the {@link CharBlockArray}. */
+  public static void serialize(FacetLabel cp, CharBlockArray charBlockArray) {
     charBlockArray.append((char) cp.length);
     if (cp.length == 0) {
       return;
@@ -36,7 +36,7 @@ class CategoryPathUtils {
 
   /**
    * Calculates a hash function of a path that was serialized with
-   * {@link #serialize(CategoryPath, CharBlockArray)}.
+   * {@link #serialize(FacetLabel, CharBlockArray)}.
    */
   public static int hashCodeOfSerialized(CharBlockArray charBlockArray, int offset) {
     int length = charBlockArray.charAt(offset++);
@@ -54,10 +54,10 @@ class CategoryPathUtils {
   }
 
   /**
-   * Check whether the {@link CategoryPath} is equal to the one serialized in
+   * Check whether the {@link FacetLabel} is equal to the one serialized in
    * {@link CharBlockArray}.
    */
-  public static boolean equalsToSerialized(CategoryPath cp, CharBlockArray charBlockArray, int offset) {
+  public static boolean equalsToSerialized(FacetLabel cp, CharBlockArray charBlockArray, int offset) {
     int n = charBlockArray.charAt(offset++);
     if (cp.length != n) {
       return false;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/Cl2oTaxonomyWriterCache.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/Cl2oTaxonomyWriterCache.java
index d0d5dea..7421338 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/Cl2oTaxonomyWriterCache.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/Cl2oTaxonomyWriterCache.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.taxonomy.writercache.cl2o;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
 
 /*
@@ -68,7 +68,7 @@ public class Cl2oTaxonomyWriterCache implements TaxonomyWriterCache {
   }
 
   @Override
-  public int get(CategoryPath categoryPath) {
+  public int get(FacetLabel categoryPath) {
     lock.readLock().lock();
     try {
       return cache.getOrdinal(categoryPath);
@@ -78,7 +78,7 @@ public class Cl2oTaxonomyWriterCache implements TaxonomyWriterCache {
   }
 
   @Override
-  public boolean put(CategoryPath categoryPath, int ordinal) {
+  public boolean put(FacetLabel categoryPath, int ordinal) {
     lock.writeLock().lock();
     try {
       cache.addLabel(categoryPath, ordinal);
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CollisionMap.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CollisionMap.java
index 306e2c8..f59ed2e 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CollisionMap.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CollisionMap.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.taxonomy.writercache.cl2o;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -103,7 +103,7 @@ public class CollisionMap {
     this.threshold = (int) (this.capacity * this.loadFactor);
   }
 
-  public int get(CategoryPath label, int hash) {
+  public int get(FacetLabel label, int hash) {
     int bucketIndex = indexFor(hash, this.capacity);
     Entry e = this.entries[bucketIndex];
 
@@ -117,7 +117,7 @@ public class CollisionMap {
     return e.cid;
   }
 
-  public int addLabel(CategoryPath label, int hash, int cid) {
+  public int addLabel(FacetLabel label, int hash, int cid) {
     int bucketIndex = indexFor(hash, this.capacity);
     for (Entry e = this.entries[bucketIndex]; e != null; e = e.next) {
       if (e.hash == hash && CategoryPathUtils.equalsToSerialized(label, labelRepository, e.offset)) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CompactLabelToOrdinal.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CompactLabelToOrdinal.java
index 0e2ae7d..da2883d 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CompactLabelToOrdinal.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/CompactLabelToOrdinal.java
@@ -27,7 +27,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Iterator;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /**
  * This is a very efficient LabelToOrdinal implementation that uses a
@@ -101,7 +101,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
 
   private void init() {
     labelRepository = new CharBlockArray();
-    CategoryPathUtils.serialize(CategoryPath.EMPTY, labelRepository);
+    CategoryPathUtils.serialize(FacetLabel.EMPTY, labelRepository);
 
     int c = this.capacity;
     for (int i = 0; i < this.hashArrays.length; i++) {
@@ -111,7 +111,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
   }
 
   @Override
-  public void addLabel(CategoryPath label, int ordinal) {
+  public void addLabel(FacetLabel label, int ordinal) {
     if (collisionMap.size() > threshold) {
       grow();
     }
@@ -130,7 +130,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
   }
 
   @Override
-  public int getOrdinal(CategoryPath label) {
+  public int getOrdinal(FacetLabel label) {
     if (label == null) {
       return LabelToOrdinal.INVALID_ORDINAL;
     }
@@ -199,7 +199,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
     }
   }
 
-  private boolean addLabel(HashArray a, CategoryPath label, int hash, int ordinal) {
+  private boolean addLabel(HashArray a, FacetLabel label, int hash, int ordinal) {
     int index = CompactLabelToOrdinal.indexFor(hash, a.offsets.length);
     int offset = a.offsets[index];
 
@@ -243,7 +243,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
     return false;
   }
 
-  private int getOrdinal(HashArray a, CategoryPath label, int hash) {
+  private int getOrdinal(HashArray a, FacetLabel label, int hash) {
     if (label == null) {
       return LabelToOrdinal.INVALID_ORDINAL;
     }
@@ -280,7 +280,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
   //
   // }
 
-  static int stringHashCode(CategoryPath label) {
+  static int stringHashCode(FacetLabel label) {
     int hash = label.hashCode();
 
     hash = hash ^ ((hash >>> 20) ^ (hash >>> 12));
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/LabelToOrdinal.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/LabelToOrdinal.java
index 982c29e..e1c8360 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/LabelToOrdinal.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/cl2o/LabelToOrdinal.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.taxonomy.writercache.cl2o;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -49,12 +49,12 @@ public abstract class LabelToOrdinal {
    * Throws an {@link IllegalArgumentException} if the same label with
    * a different ordinal was previoulsy added to this table.
    */
-  public abstract void addLabel(CategoryPath label, int ordinal);
+  public abstract void addLabel(FacetLabel label, int ordinal);
 
   /**
    * @return the ordinal assigned to the given label, 
    * or {@link #INVALID_ORDINAL} if the label cannot be found in this table.
    */
-  public abstract int getOrdinal(CategoryPath label);
+  public abstract int getOrdinal(FacetLabel label);
 
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java
index 5e2bb08..4aac2cd 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.taxonomy.writercache.lru;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
 
 /*
@@ -77,7 +77,7 @@ public class LruTaxonomyWriterCache implements TaxonomyWriterCache {
   }
 
   @Override
-  public synchronized int get(CategoryPath categoryPath) {
+  public synchronized int get(FacetLabel categoryPath) {
     Integer res = cache.get(categoryPath);
     if (res == null) {
       return -1;
@@ -87,7 +87,7 @@ public class LruTaxonomyWriterCache implements TaxonomyWriterCache {
   }
 
   @Override
-  public synchronized boolean put(CategoryPath categoryPath, int ordinal) {
+  public synchronized boolean put(FacetLabel categoryPath, int ordinal) {
     boolean ret = cache.put(categoryPath, new Integer(ordinal));
     // If the cache is full, we need to clear one or more old entries
     // from the cache. However, if we delete from the cache a recent
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java
index 8a61b0b..ef062d7 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.facet.taxonomy.writercache.lru;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -35,12 +35,12 @@ public class NameHashIntCacheLRU extends NameIntCacheLRU {
   }
 
   @Override
-  Object key(CategoryPath name) {
+  Object key(FacetLabel name) {
     return new Long(name.longHashCode());
   }
 
   @Override
-  Object key(CategoryPath name, int prefixLen) {
+  Object key(FacetLabel name, int prefixLen) {
     return new Long(name.subpath(prefixLen).longHashCode());
   }
   
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameIntCacheLRU.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameIntCacheLRU.java
index e2448eb..2f2c487 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameIntCacheLRU.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameIntCacheLRU.java
@@ -3,7 +3,7 @@ package org.apache.lucene.facet.taxonomy.writercache.lru;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -58,7 +58,7 @@ class NameIntCacheLRU {
     }
   }
 
-  Integer get (CategoryPath name) {
+  Integer get (FacetLabel name) {
     Integer res = cache.get(key(name));
     if (res==null) {
       nMisses ++;
@@ -69,11 +69,11 @@ class NameIntCacheLRU {
   }
 
   /** Subclasses can override this to provide caching by e.g. hash of the string. */
-  Object key(CategoryPath name) {
+  Object key(FacetLabel name) {
     return name;
   }
 
-  Object key(CategoryPath name, int prefixLen) {
+  Object key(FacetLabel name, int prefixLen) {
     return name.subpath(prefixLen);
   }
 
@@ -81,12 +81,12 @@ class NameIntCacheLRU {
    * Add a new value to cache.
    * Return true if cache became full and some room need to be made. 
    */
-  boolean put (CategoryPath name, Integer val) {
+  boolean put (FacetLabel name, Integer val) {
     cache.put(key(name), val);
     return isCacheFull();
   }
 
-  boolean put (CategoryPath name, int prefixLen, Integer val) {
+  boolean put (FacetLabel name, int prefixLen, Integer val) {
     cache.put(key(name, prefixLen), val);
     return isCacheFull();
   }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/util/PrintTaxonomyStats.java b/lucene/facet/src/java/org/apache/lucene/facet/util/PrintTaxonomyStats.java
index 10a70f7..65165d8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/util/PrintTaxonomyStats.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/util/PrintTaxonomyStats.java
@@ -21,7 +21,7 @@ import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
 
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader.ChildrenIterator;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -65,7 +65,7 @@ public class PrintTaxonomyStats {
       while (chilrenIt.next() != TaxonomyReader.INVALID_ORDINAL) {
         numImmediateChildren++;
       }
-      CategoryPath cp = r.getPath(child);
+      FacetLabel cp = r.getPath(child);
       out.println("/" + cp + ": " + numImmediateChildren + " immediate children; " + (1+countAllChildren(r, child)) + " total categories");
       if (printTree) {
         printAllChildren(out, r, child, "  ", 1);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
index 46321c3..9a49b79 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
@@ -25,7 +25,7 @@ import org.apache.lucene.facet.params.CategoryListParams.OrdinalPolicy;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -115,13 +115,13 @@ public abstract class FacetTestBase extends FacetTestCase {
   };
   
   /** Facets: facets[D][F] == category-path no. F for document no. D. */
-  private static final CategoryPath[][] DEFAULT_CATEGORIES = {
-      { new CategoryPath("root","a","f1"), new CategoryPath("root","a","f2") },
-      { new CategoryPath("root","a","f1"), new CategoryPath("root","a","f3") },
+  private static final FacetLabel[][] DEFAULT_CATEGORIES = {
+      { new FacetLabel("root","a","f1"), new FacetLabel("root","a","f2") },
+      { new FacetLabel("root","a","f1"), new FacetLabel("root","a","f3") },
   };
   
   /** categories to be added to specified doc */
-  protected List<CategoryPath> getCategories(int doc) {
+  protected List<FacetLabel> getCategories(int doc) {
     return Arrays.asList(DEFAULT_CATEGORIES[doc]);
   }
   
@@ -284,7 +284,7 @@ public abstract class FacetTestBase extends FacetTestCase {
   
   /** utility Create a dummy document with specified categories and content */
   protected final void indexDoc(FacetIndexingParams iParams, RandomIndexWriter iw,
-      TaxonomyWriter tw, String content, List<CategoryPath> categories) throws IOException {
+      TaxonomyWriter tw, String content, List<FacetLabel> categories) throws IOException {
     Document d = new Document();
     FacetFields facetFields = new FacetFields(tw, iParams);
     facetFields.addFields(d, categories);
@@ -293,10 +293,10 @@ public abstract class FacetTestBase extends FacetTestCase {
   }
   
   /** Build the "truth" with ALL the facets enumerating indexes content. */
-  protected Map<CategoryPath, Integer> facetCountsTruth() throws IOException {
+  protected Map<FacetLabel, Integer> facetCountsTruth() throws IOException {
     FacetIndexingParams iParams = getFacetIndexingParams(Integer.MAX_VALUE);
     String delim = String.valueOf(iParams.getFacetDelimChar());
-    Map<CategoryPath, Integer> res = new HashMap<CategoryPath, Integer>();
+    Map<FacetLabel, Integer> res = new HashMap<FacetLabel, Integer>();
     HashSet<String> handledTerms = new HashSet<String>();
     for (CategoryListParams clp : iParams.getAllCategoryListParams()) {
       if (!handledTerms.add(clp.field)) {
@@ -315,14 +315,14 @@ public abstract class FacetTestBase extends FacetTestCase {
         while (de.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
           cnt++;
         }
-        res.put(new CategoryPath(te.term().utf8ToString().split(delim)), cnt);
+        res.put(new FacetLabel(te.term().utf8ToString().split(delim)), cnt);
       }
     }
     return res;
   }
   
   /** Validate counts for returned facets, and that there are not too many results */
-  protected static void assertCountsAndCardinality(Map<CategoryPath, Integer> facetCountsTruth, List<FacetResult> facetResults) throws Exception {
+  protected static void assertCountsAndCardinality(Map<FacetLabel, Integer> facetCountsTruth, List<FacetResult> facetResults) throws Exception {
     for (FacetResult fr : facetResults) {
       FacetResultNode topResNode = fr.getFacetResultNode();
       FacetRequest freq = fr.getFacetRequest();
@@ -334,7 +334,7 @@ public abstract class FacetTestBase extends FacetTestCase {
   }
     
   /** Validate counts for returned facets, and that there are not too many results */
-  private static void assertCountsAndCardinality(Map<CategoryPath,Integer> facetCountsTruth,  FacetResultNode resNode, int reqNumResults) throws Exception {
+  private static void assertCountsAndCardinality(Map<FacetLabel,Integer> facetCountsTruth,  FacetResultNode resNode, int reqNumResults) throws Exception {
     int actualNumResults = resNode.subResults.size();
     if (VERBOSE) {
       System.out.println("NumResults: " + actualNumResults);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/associations/AssociationsFacetRequestTest.java b/lucene/facet/src/test/org/apache/lucene/facet/associations/AssociationsFacetRequestTest.java
index 81c8a6e..79cbc0f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/associations/AssociationsFacetRequestTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/associations/AssociationsFacetRequestTest.java
@@ -9,7 +9,7 @@ import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -47,10 +47,10 @@ public class AssociationsFacetRequestTest extends FacetTestCase {
   private static IndexReader reader;
   private static Directory taxoDir;
   
-  private static final CategoryPath aint = new CategoryPath("int", "a");
-  private static final CategoryPath bint = new CategoryPath("int", "b");
-  private static final CategoryPath afloat = new CategoryPath("float", "a");
-  private static final CategoryPath bfloat = new CategoryPath("float", "b");
+  private static final FacetLabel aint = new FacetLabel("int", "a");
+  private static final FacetLabel bint = new FacetLabel("int", "b");
+  private static final FacetLabel afloat = new FacetLabel("float", "a");
+  private static final FacetLabel bfloat = new FacetLabel("float", "b");
   
   @BeforeClass
   public static void beforeClassAssociationsFacetRequestTest() throws Exception {
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestFacetsAccumulatorWithComplement.java b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestFacetsAccumulatorWithComplement.java
index a821f3a..d80578b 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestFacetsAccumulatorWithComplement.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestFacetsAccumulatorWithComplement.java
@@ -11,7 +11,7 @@ import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.ParallelAtomicReader;
@@ -111,7 +111,7 @@ public class TestFacetsAccumulatorWithComplement extends FacetTestBase {
   
   /** compute facets with certain facet requests and docs */
   private List<FacetResult> findFacets(boolean withComplement) throws IOException {
-    FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(new CategoryPath("root","a"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(new FacetLabel("root","a"), 10));
     OldFacetsAccumulator sfa = new OldFacetsAccumulator(fsp, indexReader, taxoReader);
     sfa.setComplementThreshold(withComplement ? OldFacetsAccumulator.FORCE_COMPLEMENT : OldFacetsAccumulator.DISABLE_COMPLEMENT);
     FacetsCollector fc = FacetsCollector.create(sfa);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCounts.java
index 144356b..f4488bd 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCounts.java
@@ -12,7 +12,7 @@ import org.apache.lucene.facet.complements.TotalFacetCountsCache;
 import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -72,7 +72,7 @@ public class TestTotalFacetCounts extends FacetTestCase {
       }
       
       @Override
-      public CategoryListParams getCategoryListParams(CategoryPath category) {
+      public CategoryListParams getCategoryListParams(FacetLabel category) {
         return new CategoryListParams() {
           @Override
           public OrdinalPolicy getOrdinalPolicy(String dimension) {
@@ -89,7 +89,7 @@ public class TestTotalFacetCounts extends FacetTestCase {
     FacetFields facetFields = new FacetFields(taxoWriter, iParams);
     for (String cat : categories) {
       Document doc = new Document();
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel(cat, '/')));
       indexWriter.addDocument(doc);
     }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache.java b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache.java
index bc7d02e..cf09885 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/complements/TestTotalFacetCountsCache.java
@@ -21,7 +21,7 @@ import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -91,7 +91,7 @@ public class TestTotalFacetCountsCache extends FacetTestCase {
       TaxonomyWriter tw, String... strings) throws IOException {
     Document doc = new Document();
     FacetFields facetFields = new FacetFields(tw, iParams);
-    facetFields.addFields(doc, Collections.singletonList(new CategoryPath(strings)));
+    facetFields.addFields(doc, Collections.singletonList(new FacetLabel(strings)));
     iw.addDocument(doc);
   }
 
@@ -129,7 +129,7 @@ public class TestTotalFacetCountsCache extends FacetTestCase {
     
     for (String cat : CATEGORIES) {
       Document doc = new Document();
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath(cat, '/')));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel(cat, '/')));
       indexWriter.addDocument(doc);
     }
     
@@ -173,8 +173,8 @@ public class TestTotalFacetCountsCache extends FacetTestCase {
       @Override
       public void run() {
         try {
-          FacetSearchParams fsp = new FacetSearchParams(iParams, new CountFacetRequest(new CategoryPath("a"), 10),
-              new CountFacetRequest(new CategoryPath("b"), 10));
+          FacetSearchParams fsp = new FacetSearchParams(iParams, new CountFacetRequest(new FacetLabel("a"), 10),
+              new CountFacetRequest(new FacetLabel("b"), 10));
           IndexSearcher searcher = new IndexSearcher(indexReader);
           FacetsCollector fc = FacetsCollector.create(fsp, indexReader, taxoReader);
           searcher.search(new MatchAllDocsQuery(), fc);
@@ -352,7 +352,7 @@ public class TestTotalFacetCountsCache extends FacetTestCase {
     
     // Make the taxonomy grow without touching the index
     for (int i = 0; i < 10; i++) {
-      taxoWriter.addCategory(new CategoryPath("foo", Integer.toString(i)));
+      taxoWriter.addCategory(new FacetLabel("foo", Integer.toString(i)));
     }
     taxoWriter.commit();
     TaxonomyReader newTaxoReader = TaxonomyReader.openIfChanged(taxoReader);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/params/FacetIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/params/FacetIndexingParamsTest.java
index 20874b2..d08f1b9 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/params/FacetIndexingParamsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/params/FacetIndexingParamsTest.java
@@ -4,7 +4,7 @@ import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.DrillDownQuery;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.index.Term;
 import org.junit.Test;
@@ -33,11 +33,11 @@ public class FacetIndexingParamsTest extends FacetTestCase {
     FacetIndexingParams dfip = FacetIndexingParams.DEFAULT;
     assertNotNull("Missing default category list", dfip.getAllCategoryListParams());
     assertEquals("all categories have the same CategoryListParams by default",
-        dfip.getCategoryListParams(null), dfip.getCategoryListParams(new CategoryPath("a")));
+        dfip.getCategoryListParams(null), dfip.getCategoryListParams(new FacetLabel("a")));
     assertEquals("Expected default category list field is $facets", "$facets", dfip.getCategoryListParams(null).field);
     String expectedDDText = "a"
         + dfip.getFacetDelimChar() + "b";
-    CategoryPath cp = new CategoryPath("a", "b");
+    FacetLabel cp = new FacetLabel("a", "b");
     assertEquals("wrong drill-down term", new Term("$facets",
         expectedDDText), DrillDownQuery.term(dfip,cp));
     char[] buf = new char[20];
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java b/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java
index 62aec7c..6dbc5da 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/params/PerDimensionIndexingParamsTest.java
@@ -7,7 +7,7 @@ import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.DrillDownQuery;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.index.Term;
 import org.junit.Test;
@@ -33,11 +33,11 @@ public class PerDimensionIndexingParamsTest extends FacetTestCase {
 
   @Test
   public void testTopLevelSettings() {
-    FacetIndexingParams ifip = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
+    FacetIndexingParams ifip = new PerDimensionIndexingParams(Collections.<FacetLabel, CategoryListParams>emptyMap());
     assertNotNull("Missing default category list", ifip.getAllCategoryListParams());
     assertEquals("Expected default category list field is $facets", "$facets", ifip.getCategoryListParams(null).field);
     String expectedDDText = "a" + ifip.getFacetDelimChar() + "b";
-    CategoryPath cp = new CategoryPath("a", "b");
+    FacetLabel cp = new FacetLabel("a", "b");
     assertEquals("wrong drill-down term", new Term("$facets", expectedDDText), DrillDownQuery.term(ifip,cp));
     char[] buf = new char[20];
     int numchars = ifip.drillDownTermText(cp, buf);
@@ -55,9 +55,9 @@ public class PerDimensionIndexingParamsTest extends FacetTestCase {
   public void testCategoryListParamsAddition() {
     CategoryListParams clp = new CategoryListParams("clp");
     PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams(
-        Collections.<CategoryPath,CategoryListParams> singletonMap(new CategoryPath("a"), clp));
+        Collections.<FacetLabel,CategoryListParams> singletonMap(new FacetLabel("a"), clp));
     assertEquals("Expected category list field is " + clp.field, 
-        clp.field, tlfip.getCategoryListParams(new CategoryPath("a")).field);
+        clp.field, tlfip.getCategoryListParams(new FacetLabel("a")).field);
     assertNotSame("Unexpected default category list " + clp.field, clp, tlfip.getCategoryListParams(null));
   }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator.java b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator.java
index 39f16dc..93084e7 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeAccumulator.java
@@ -47,7 +47,7 @@ import org.apache.lucene.facet.search.FacetsAccumulator;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetFields;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -114,11 +114,11 @@ public class TestRangeAccumulator extends FacetTestCase {
       // For drill down by numeric range:
       doc.add(new LongField("field", l, Field.Store.NO));
 
-      CategoryPath cp;
+      FacetLabel cp;
       if ((l&3) == 0) {
-        cp = new CategoryPath("dim", "a");
+        cp = new FacetLabel("dim", "a");
       } else {
-        cp = new CategoryPath("dim", "b");
+        cp = new FacetLabel("dim", "b");
       }
       ff.addFields(doc, Collections.singletonList(cp));
       w.addDocument(doc);
@@ -132,7 +132,7 @@ public class TestRangeAccumulator extends FacetTestCase {
 
     IndexSearcher s = newSearcher(r);
 
-    final CountFacetRequest countRequest = new CountFacetRequest(new CategoryPath("dim"), 2);
+    final CountFacetRequest countRequest = new CountFacetRequest(new FacetLabel("dim"), 2);
     final RangeFacetRequest<LongRange> rangeRequest = new RangeFacetRequest<LongRange>("field",
                           new LongRange("less than 10", 0L, true, 10L, false),
                           new LongRange("less than or equal to 10", 0L, true, 10L, true),
@@ -183,7 +183,7 @@ public class TestRangeAccumulator extends FacetTestCase {
 
     // Second search, drill down on dim=b:
     ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("dim", "b"));
+    ddq.add(new FacetLabel("dim", "b"));
     dimSeen.clear();
     dsr = ds.search(null, ddq, 10, fsp);
 
@@ -221,11 +221,11 @@ public class TestRangeAccumulator extends FacetTestCase {
       // For drill down by numeric range:
       doc.add(new LongField("field", l, Field.Store.NO));
 
-      CategoryPath cp;
+      FacetLabel cp;
       if ((l&3) == 0) {
-        cp = new CategoryPath("dim", "a");
+        cp = new FacetLabel("dim", "a");
       } else {
-        cp = new CategoryPath("dim", "b");
+        cp = new FacetLabel("dim", "b");
       }
       ff.addFields(doc, Collections.singletonList(cp));
       w.addDocument(doc);
@@ -237,7 +237,7 @@ public class TestRangeAccumulator extends FacetTestCase {
     IndexSearcher s = newSearcher(r);
     final SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(s.getIndexReader());
 
-    final CountFacetRequest countRequest = new CountFacetRequest(new CategoryPath("dim"), 2);
+    final CountFacetRequest countRequest = new CountFacetRequest(new FacetLabel("dim"), 2);
     final RangeFacetRequest<LongRange> rangeRequest = new RangeFacetRequest<LongRange>("field",
                           new LongRange("less than 10", 0L, true, 10L, false),
                           new LongRange("less than or equal to 10", 0L, true, 10L, true),
@@ -288,7 +288,7 @@ public class TestRangeAccumulator extends FacetTestCase {
 
     // Second search, drill down on dim=b:
     ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("dim", "b"));
+    ddq.add(new FacetLabel("dim", "b"));
     dimSeen.clear();
     dsr = ds.search(null, ddq, 10, fsp);
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/sampling/OversampleWithDepthTest.java b/lucene/facet/src/test/org/apache/lucene/facet/sampling/OversampleWithDepthTest.java
index 08bc4a7..cd0098d 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/sampling/OversampleWithDepthTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/sampling/OversampleWithDepthTest.java
@@ -15,7 +15,7 @@ import org.apache.lucene.facet.search.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -63,7 +63,7 @@ public class OversampleWithDepthTest extends FacetTestCase {
     DirectoryReader r = DirectoryReader.open(indexDir);
     TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
     
-    CountFacetRequest facetRequest = new CountFacetRequest(new CategoryPath("root"), 10);
+    CountFacetRequest facetRequest = new CountFacetRequest(new FacetLabel("root"), 10);
     // Setting the depth to '2', should potentially get all categories
     facetRequest.setDepth(2);
     facetRequest.setResultMode(ResultMode.PER_NODE_IN_TREE);
@@ -100,7 +100,7 @@ public class OversampleWithDepthTest extends FacetTestCase {
     FacetFields facetFields = new FacetFields(tw, fip);
     for (int i = 0; i < 100; i++) {
       Document doc = new Document();
-      CategoryPath cp = new CategoryPath("root",Integer.toString(i / 10), Integer.toString(i));
+      FacetLabel cp = new FacetLabel("root",Integer.toString(i / 10), Integer.toString(i));
       facetFields.addFields(doc, Collections.singletonList(cp));
       w.addDocument(doc);
     }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/sampling/SamplerTest.java b/lucene/facet/src/test/org/apache/lucene/facet/sampling/SamplerTest.java
index 027aaf1..b0c7f29 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/sampling/SamplerTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/sampling/SamplerTest.java
@@ -10,7 +10,7 @@ import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.junit.After;
 import org.junit.Before;
@@ -50,10 +50,10 @@ public class SamplerTest extends FacetTestBase {
   }
   
   @Override
-  protected List<CategoryPath> getCategories(final int doc) {
-    return new ArrayList<CategoryPath>() {
+  protected List<FacetLabel> getCategories(final int doc) {
+    return new ArrayList<FacetLabel>() {
       {
-        add(new CategoryPath("root", "a", Integer.toString(doc % 10)));
+        add(new FacetLabel("root", "a", Integer.toString(doc % 10)));
       }
     };
   }
@@ -93,7 +93,7 @@ public class SamplerTest extends FacetTestBase {
     assertNull("Fixer should be null as the test is for no-fixing",
         sp.getSampleFixer());
     FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(
-        new CategoryPath("root", "a"), 1));
+        new FacetLabel("root", "a"), 1));
     SamplingAccumulator accumulator = new SamplingAccumulator(
         new RandomSampler(sp, random()), fsp, indexReader, taxoReader);
     
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java b/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
index e717647..66f0cb9 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
@@ -13,7 +13,7 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.facet.FacetTestBase;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 
 /*
@@ -78,9 +78,9 @@ public abstract class BaseTestTopK extends FacetTestBase {
   }
   
   @Override
-  protected List<CategoryPath> getCategories(int doc) {
+  protected List<FacetLabel> getCategories(int doc) {
     nextInt(doc);
-    CategoryPath cp = new CategoryPath(
+    FacetLabel cp = new FacetLabel(
         "a", 
         Integer.toString(nextInt / 1000), 
         Integer.toString(nextInt / 100), 
@@ -93,10 +93,10 @@ public abstract class BaseTestTopK extends FacetTestBase {
 
   protected FacetSearchParams searchParamsWithRequests(int numResults, FacetIndexingParams fip) {
     List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
-    facetRequests.add(new CountFacetRequest(new CategoryPath("a"), numResults));
-    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1"), numResults));
-    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1", "10"), numResults));
-    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "2",  "26", "267"), numResults));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("a"), numResults));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("a", "1"), numResults));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("a", "1", "10"), numResults));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("a", "2",  "26", "267"), numResults));
     return getFacetSearchParams(facetRequests, fip);
   }
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsAggregatorTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsAggregatorTest.java
index 9110c6c..ed62055 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsAggregatorTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsAggregatorTest.java
@@ -21,7 +21,7 @@ import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.params.PerDimensionOrdinalPolicy;
 import org.apache.lucene.facet.params.CategoryListParams.OrdinalPolicy;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -61,38 +61,38 @@ import org.junit.Test;
 public class CountingFacetsAggregatorTest extends FacetTestCase {
   
   private static final Term A = new Term("f", "a");
-  private static final CategoryPath CP_A = new CategoryPath("A"), CP_B = new CategoryPath("B");
-  private static final CategoryPath CP_C = new CategoryPath("C"), CP_D = new CategoryPath("D"); // indexed w/ NO_PARENTS
+  private static final FacetLabel CP_A = new FacetLabel("A"), CP_B = new FacetLabel("B");
+  private static final FacetLabel CP_C = new FacetLabel("C"), CP_D = new FacetLabel("D"); // indexed w/ NO_PARENTS
   private static final int NUM_CHILDREN_CP_A = 5, NUM_CHILDREN_CP_B = 3;
   private static final int NUM_CHILDREN_CP_C = 5, NUM_CHILDREN_CP_D = 5;
-  private static final CategoryPath[] CATEGORIES_A, CATEGORIES_B;
-  private static final CategoryPath[] CATEGORIES_C, CATEGORIES_D;
+  private static final FacetLabel[] CATEGORIES_A, CATEGORIES_B;
+  private static final FacetLabel[] CATEGORIES_C, CATEGORIES_D;
   static {
-    CATEGORIES_A = new CategoryPath[NUM_CHILDREN_CP_A];
+    CATEGORIES_A = new FacetLabel[NUM_CHILDREN_CP_A];
     for (int i = 0; i < NUM_CHILDREN_CP_A; i++) {
-      CATEGORIES_A[i] = new CategoryPath(CP_A.components[0], Integer.toString(i));
+      CATEGORIES_A[i] = new FacetLabel(CP_A.components[0], Integer.toString(i));
     }
-    CATEGORIES_B = new CategoryPath[NUM_CHILDREN_CP_B];
+    CATEGORIES_B = new FacetLabel[NUM_CHILDREN_CP_B];
     for (int i = 0; i < NUM_CHILDREN_CP_B; i++) {
-      CATEGORIES_B[i] = new CategoryPath(CP_B.components[0], Integer.toString(i));
+      CATEGORIES_B[i] = new FacetLabel(CP_B.components[0], Integer.toString(i));
     }
     
     // NO_PARENTS categories
-    CATEGORIES_C = new CategoryPath[NUM_CHILDREN_CP_C];
+    CATEGORIES_C = new FacetLabel[NUM_CHILDREN_CP_C];
     for (int i = 0; i < NUM_CHILDREN_CP_C; i++) {
-      CATEGORIES_C[i] = new CategoryPath(CP_C.components[0], Integer.toString(i));
+      CATEGORIES_C[i] = new FacetLabel(CP_C.components[0], Integer.toString(i));
     }
     
     // Multi-level categories
-    CATEGORIES_D = new CategoryPath[NUM_CHILDREN_CP_D];
+    CATEGORIES_D = new FacetLabel[NUM_CHILDREN_CP_D];
     for (int i = 0; i < NUM_CHILDREN_CP_D; i++) {
       String val = Integer.toString(i);
-      CATEGORIES_D[i] = new CategoryPath(CP_D.components[0], val, val + val); // e.g. D/1/11, D/2/22...
+      CATEGORIES_D[i] = new FacetLabel(CP_D.components[0], val, val + val); // e.g. D/1/11, D/2/22...
     }
   }
   
   private static Directory indexDir, taxoDir;
-  private static ObjectToIntMap<CategoryPath> allExpectedCounts, termExpectedCounts;
+  private static ObjectToIntMap<FacetLabel> allExpectedCounts, termExpectedCounts;
   private static FacetIndexingParams fip;
 
   @AfterClass
@@ -100,19 +100,19 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
     IOUtils.close(indexDir, taxoDir); 
   }
   
-  private static List<CategoryPath> randomCategories(Random random) {
+  private static List<FacetLabel> randomCategories(Random random) {
     // add random categories from the two dimensions, ensuring that the same
     // category is not added twice.
     int numFacetsA = random.nextInt(3) + 1; // 1-3
     int numFacetsB = random.nextInt(2) + 1; // 1-2
-    ArrayList<CategoryPath> categories_a = new ArrayList<CategoryPath>();
+    ArrayList<FacetLabel> categories_a = new ArrayList<FacetLabel>();
     categories_a.addAll(Arrays.asList(CATEGORIES_A));
-    ArrayList<CategoryPath> categories_b = new ArrayList<CategoryPath>();
+    ArrayList<FacetLabel> categories_b = new ArrayList<FacetLabel>();
     categories_b.addAll(Arrays.asList(CATEGORIES_B));
     Collections.shuffle(categories_a, random);
     Collections.shuffle(categories_b, random);
 
-    ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();
+    ArrayList<FacetLabel> categories = new ArrayList<FacetLabel>();
     categories.addAll(categories_a.subList(0, numFacetsA));
     categories.addAll(categories_b.subList(0, numFacetsB));
     
@@ -129,8 +129,8 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
   
   private static void addFacets(Document doc, FacetFields facetFields, boolean updateTermExpectedCounts) 
       throws IOException {
-    List<CategoryPath> docCategories = randomCategories(random());
-    for (CategoryPath cp : docCategories) {
+    List<FacetLabel> docCategories = randomCategories(random());
+    for (FacetLabel cp : docCategories) {
       if (cp.components[0].equals(CP_D.components[0])) {
         cp = cp.subpath(2); // we'll get counts for the 2nd level only
       }
@@ -163,7 +163,7 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
   }
   
   private static void indexDocsWithFacetsNoTerms(IndexWriter indexWriter, TaxonomyWriter taxoWriter, 
-      ObjectToIntMap<CategoryPath> expectedCounts) throws IOException {
+      ObjectToIntMap<FacetLabel> expectedCounts) throws IOException {
     Random random = random();
     int numDocs = atLeast(random, 2);
     FacetFields facetFields = new FacetFields(taxoWriter, fip);
@@ -176,7 +176,7 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
   }
   
   private static void indexDocsWithFacetsAndTerms(IndexWriter indexWriter, TaxonomyWriter taxoWriter, 
-      ObjectToIntMap<CategoryPath> expectedCounts) throws IOException {
+      ObjectToIntMap<FacetLabel> expectedCounts) throws IOException {
     Random random = random();
     int numDocs = atLeast(random, 2);
     FacetFields facetFields = new FacetFields(taxoWriter, fip);
@@ -190,7 +190,7 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
   }
   
   private static void indexDocsWithFacetsAndSomeTerms(IndexWriter indexWriter, TaxonomyWriter taxoWriter, 
-      ObjectToIntMap<CategoryPath> expectedCounts) throws IOException {
+      ObjectToIntMap<FacetLabel> expectedCounts) throws IOException {
     Random random = random();
     int numDocs = atLeast(random, 2);
     FacetFields facetFields = new FacetFields(taxoWriter, fip);
@@ -207,22 +207,22 @@ public class CountingFacetsAggregatorTest extends FacetTestCase {
   }
   
   // initialize expectedCounts w/ 0 for all categories
-  private static ObjectToIntMap<CategoryPath> newCounts() {
-    ObjectToIntMap<CategoryPath> counts = new ObjectToIntMap<CategoryPath>();
+  private static ObjectToIntMap<FacetLabel> newCounts() {
+    ObjectToIntMap<FacetLabel> counts = new ObjectToIntMap<FacetLabel>();
     counts.put(CP_A, 0);
     counts.put(CP_B, 0);
     counts.put(CP_C, 0);
     counts.put(CP_D, 0);
-    for (CategoryPath cp : CATEGORIES_A) {
+    for (FacetLabel cp : CATEGORIES_A) {
       counts.put(cp, 0);
     }
-    for (CategoryPath cp : CATEGORIES_B) {
+    for (FacetLabel cp : CATEGORIES_B) {
       counts.put(cp, 0);
     }
-    for (CategoryPath cp : CATEGORIES_C) {
+    for (FacetLabel cp : CATEGORIES_C) {
       counts.put(cp, 0);
     }
-    for (CategoryPath cp : CATEGORIES_D) {
+    for (FacetLabel cp : CATEGORIES_D) {
       counts.put(cp.subpath(2), 0);
     }
     return counts;
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownQueryTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownQueryTest.java
index 334c9c4..c47dbf8 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownQueryTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownQueryTest.java
@@ -33,7 +33,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.PerDimensionIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -83,7 +83,7 @@ public class DrillDownQueryTest extends FacetTestCase {
     TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
     
     for (int i = 0; i < 100; i++) {
-      ArrayList<CategoryPath> paths = new ArrayList<CategoryPath>();
+      ArrayList<FacetLabel> paths = new ArrayList<FacetLabel>();
       Document doc = new Document();
       if (i % 2 == 0) { // 50
         doc.add(new TextField("content", "foo", Field.Store.NO));
@@ -93,13 +93,13 @@ public class DrillDownQueryTest extends FacetTestCase {
       }
       if (i % 4 == 0) { // 25
         if (r.nextBoolean()) {
-          paths.add(new CategoryPath("a/1", '/'));
+          paths.add(new FacetLabel("a/1", '/'));
         } else {
-          paths.add(new CategoryPath("a/2", '/'));
+          paths.add(new FacetLabel("a/2", '/'));
         }
       }
       if (i % 5 == 0) { // 20
-        paths.add(new CategoryPath("b"));
+        paths.add(new FacetLabel("b"));
       }
       FacetFields facetFields = new FacetFields(taxoWriter);
       if (paths.size() > 0) {
@@ -116,9 +116,9 @@ public class DrillDownQueryTest extends FacetTestCase {
   }
   
   public DrillDownQueryTest() {
-    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
-    paramsMap.put(new CategoryPath("a"), randomCategoryListParams("testing_facets_a"));
-    paramsMap.put(new CategoryPath("b"), randomCategoryListParams("testing_facets_b"));
+    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
+    paramsMap.put(new FacetLabel("a"), randomCategoryListParams("testing_facets_a"));
+    paramsMap.put(new FacetLabel("b"), randomCategoryListParams("testing_facets_b"));
     nonDefaultParams = new PerDimensionIndexingParams(paramsMap);
     defaultParams = new FacetIndexingParams(randomCategoryListParams(CategoryListParams.DEFAULT_FIELD));
   }
@@ -127,10 +127,10 @@ public class DrillDownQueryTest extends FacetTestCase {
   public void testDefaultField() {
     String defaultField = CategoryListParams.DEFAULT_FIELD;
     
-    Term termA = DrillDownQuery.term(defaultParams, new CategoryPath("a"));
+    Term termA = DrillDownQuery.term(defaultParams, new FacetLabel("a"));
     assertEquals(new Term(defaultField, "a"), termA);
     
-    Term termB = DrillDownQuery.term(defaultParams, new CategoryPath("b"));
+    Term termB = DrillDownQuery.term(defaultParams, new FacetLabel("b"));
     assertEquals(new Term(defaultField, "b"), termB);
   }
   
@@ -140,8 +140,8 @@ public class DrillDownQueryTest extends FacetTestCase {
 
     // test (a/1 OR a/2) AND b
     DrillDownQuery q = new DrillDownQuery(defaultParams);
-    q.add(new CategoryPath("a/1", '/'), new CategoryPath("a/2", '/'));
-    q.add(new CategoryPath("b"));
+    q.add(new FacetLabel("a/1", '/'), new FacetLabel("a/2", '/'));
+    q.add(new FacetLabel("b"));
     TopDocs docs = searcher.search(q, 100);
     assertEquals(5, docs.totalHits);
   }
@@ -152,7 +152,7 @@ public class DrillDownQueryTest extends FacetTestCase {
 
     // Making sure the query yields 25 documents with the facet "a"
     DrillDownQuery q = new DrillDownQuery(defaultParams);
-    q.add(new CategoryPath("a"));
+    q.add(new FacetLabel("a"));
     QueryUtils.check(q);
     TopDocs docs = searcher.search(q, 100);
     assertEquals(25, docs.totalHits);
@@ -160,14 +160,14 @@ public class DrillDownQueryTest extends FacetTestCase {
     // Making sure the query yields 5 documents with the facet "b" and the
     // previous (facet "a") query as a base query
     DrillDownQuery q2 = new DrillDownQuery(defaultParams, q);
-    q2.add(new CategoryPath("b"));
+    q2.add(new FacetLabel("b"));
     docs = searcher.search(q2, 100);
     assertEquals(5, docs.totalHits);
 
     // Making sure that a query of both facet "a" and facet "b" yields 5 results
     DrillDownQuery q3 = new DrillDownQuery(defaultParams);
-    q3.add(new CategoryPath("a"));
-    q3.add(new CategoryPath("b"));
+    q3.add(new FacetLabel("a"));
+    q3.add(new FacetLabel("b"));
     docs = searcher.search(q3, 100);
     
     assertEquals(5, docs.totalHits);
@@ -175,7 +175,7 @@ public class DrillDownQueryTest extends FacetTestCase {
     // would gather together 10 results (10%..) 
     Query fooQuery = new TermQuery(new Term("content", "foo"));
     DrillDownQuery q4 = new DrillDownQuery(defaultParams, fooQuery);
-    q4.add(new CategoryPath("b"));
+    q4.add(new FacetLabel("b"));
     docs = searcher.search(q4, 100);
     assertEquals(10, docs.totalHits);
   }
@@ -186,12 +186,12 @@ public class DrillDownQueryTest extends FacetTestCase {
 
     // Create the base query to start with
     DrillDownQuery q = new DrillDownQuery(defaultParams);
-    q.add(new CategoryPath("a"));
+    q.add(new FacetLabel("a"));
     
     // Making sure the query yields 5 documents with the facet "b" and the
     // previous (facet "a") query as a base query
     DrillDownQuery q2 = new DrillDownQuery(defaultParams, q);
-    q2.add(new CategoryPath("b"));
+    q2.add(new FacetLabel("b"));
     TopDocs docs = searcher.search(q2, 100);
     assertEquals(5, docs.totalHits);
 
@@ -199,7 +199,7 @@ public class DrillDownQueryTest extends FacetTestCase {
     // would gather together 10 results (10%..) 
     Query fooQuery = new TermQuery(new Term("content", "foo"));
     DrillDownQuery q4 = new DrillDownQuery(defaultParams, fooQuery);
-    q4.add(new CategoryPath("b"));
+    q4.add(new FacetLabel("b"));
     docs = searcher.search(q4, 100);
     assertEquals(10, docs.totalHits);
   }
@@ -219,7 +219,7 @@ public class DrillDownQueryTest extends FacetTestCase {
     
     // create a drill-down query with category "a", scores should not change
     DrillDownQuery q2 = new DrillDownQuery(defaultParams, q);
-    q2.add(new CategoryPath("a"));
+    q2.add(new FacetLabel("a"));
     docs = searcher.search(q2, reader.maxDoc()); // fetch all available docs to this query
     for (ScoreDoc sd : docs.scoreDocs) {
       assertEquals("score of doc=" + sd.doc + " modified", scores[sd.doc], sd.score, 0f);
@@ -232,7 +232,7 @@ public class DrillDownQueryTest extends FacetTestCase {
     IndexSearcher searcher = newSearcher(reader);
     
     DrillDownQuery q = new DrillDownQuery(defaultParams);
-    q.add(new CategoryPath("a"));
+    q.add(new FacetLabel("a"));
     TopDocs docs = searcher.search(q, reader.maxDoc()); // fetch all available docs to this query
     for (ScoreDoc sd : docs.scoreDocs) {
       assertEquals(0f, sd.score, 0f);
@@ -241,20 +241,20 @@ public class DrillDownQueryTest extends FacetTestCase {
   
   @Test
   public void testTermNonDefault() {
-    Term termA = DrillDownQuery.term(nonDefaultParams, new CategoryPath("a"));
+    Term termA = DrillDownQuery.term(nonDefaultParams, new FacetLabel("a"));
     assertEquals(new Term("testing_facets_a", "a"), termA);
     
-    Term termB = DrillDownQuery.term(nonDefaultParams, new CategoryPath("b"));
+    Term termB = DrillDownQuery.term(nonDefaultParams, new FacetLabel("b"));
     assertEquals(new Term("testing_facets_b", "b"), termB);
   }
 
   @Test
   public void testClone() throws Exception {
     DrillDownQuery q = new DrillDownQuery(defaultParams, new MatchAllDocsQuery());
-    q.add(new CategoryPath("a"));
+    q.add(new FacetLabel("a"));
     
     DrillDownQuery clone = q.clone();
-    clone.add(new CategoryPath("b"));
+    clone.add(new FacetLabel("b"));
     
     assertFalse("query wasn't cloned: source=" + q + " clone=" + clone, q.toString().equals(clone.toString()));
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java
index c9f3a7c..7b3a06d 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/FacetRequestTest.java
@@ -2,7 +2,7 @@ package org.apache.lucene.facet.search;
 
 import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.search.CountFacetRequest;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.junit.Test;
 
 /*
@@ -26,7 +26,7 @@ public class FacetRequestTest extends FacetTestCase {
   
   @Test(expected=IllegalArgumentException.class)
   public void testIllegalNumResults() throws Exception {
-    assertNotNull(new CountFacetRequest(new CategoryPath("a", "b"), 0));
+    assertNotNull(new CountFacetRequest(new FacetLabel("a", "b"), 0));
   }
   
   @Test(expected=IllegalArgumentException.class)
@@ -36,8 +36,8 @@ public class FacetRequestTest extends FacetTestCase {
   
   @Test
   public void testHashAndEquals() {
-    CountFacetRequest fr1 = new CountFacetRequest(new CategoryPath("a"), 8);
-    CountFacetRequest fr2 = new CountFacetRequest(new CategoryPath("a"), 8);
+    CountFacetRequest fr1 = new CountFacetRequest(new FacetLabel("a"), 8);
+    CountFacetRequest fr2 = new CountFacetRequest(new FacetLabel("a"), 8);
     assertEquals("hashCode() should agree on both objects", fr1.hashCode(), fr2.hashCode());
     assertTrue("equals() should return true", fr1.equals(fr2));
     fr1.setDepth(10);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest.java
index 5d38db2..ad1cf74 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/FacetResultTest.java
@@ -32,7 +32,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.DrillSideways.DrillSidewaysResult;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -51,9 +51,9 @@ public class FacetResultTest extends FacetTestCase {
   
   private Document newDocument(FacetFields facetFields, String... categories) throws IOException {
     Document doc = new Document();
-    List<CategoryPath> cats = new ArrayList<CategoryPath>();
+    List<FacetLabel> cats = new ArrayList<FacetLabel>();
     for (String cat : categories) {
-      cats.add(new CategoryPath(cat, '/'));
+      cats.add(new FacetLabel(cat, '/'));
     }
     facetFields.addFields(doc, cats);
     return doc;
@@ -80,22 +80,22 @@ public class FacetResultTest extends FacetTestCase {
   
   private void searchIndex(TaxonomyReader taxoReader, IndexSearcher searcher, boolean fillMissingCounts, String[] exp,
       String[][] drillDowns, int[] numResults) throws IOException {
-    CategoryPath[][] cps = new CategoryPath[drillDowns.length][];
+    FacetLabel[][] cps = new FacetLabel[drillDowns.length][];
     for (int i = 0; i < cps.length; i++) {
-      cps[i] = new CategoryPath[drillDowns[i].length];
+      cps[i] = new FacetLabel[drillDowns[i].length];
       for (int j = 0; j < cps[i].length; j++) {
-        cps[i][j] = new CategoryPath(drillDowns[i][j], '/');
+        cps[i][j] = new FacetLabel(drillDowns[i][j], '/');
       }
     }
     DrillDownQuery ddq = new DrillDownQuery(FacetIndexingParams.DEFAULT, new MatchAllDocsQuery());
-    for (CategoryPath[] cats : cps) {
+    for (FacetLabel[] cats : cps) {
       ddq.add(cats);
     }
     
     List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
-    for (CategoryPath[] cats : cps) {
+    for (FacetLabel[] cats : cps) {
       for (int i = 0; i < cats.length; i++) {
-        CategoryPath cp = cats[i];
+        FacetLabel cp = cats[i];
         int numres = numResults == null ? 2 : numResults[i];
         // for each drill-down, add itself as well as its parent as requests, so
         // we get the drill-sideways
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest.java
index 14ced14..268f6bd 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/MultiCategoryListIteratorTest.java
@@ -12,7 +12,7 @@ import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.CategoryListIterator;
 import org.apache.lucene.facet.search.DocValuesCategoryListIterator;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -55,9 +55,9 @@ public class MultiCategoryListIteratorTest extends FacetTestCase {
     }
     
     // build the PerDimensionIndexingParams
-    HashMap<CategoryPath,CategoryListParams> clps = new HashMap<CategoryPath,CategoryListParams>();
+    HashMap<FacetLabel,CategoryListParams> clps = new HashMap<FacetLabel,CategoryListParams>();
     for (String dim : dimensions) {
-      CategoryPath cp = new CategoryPath(dim);
+      FacetLabel cp = new FacetLabel(dim);
       CategoryListParams clp = randomCategoryListParams("$" + dim);
       clps.put(cp, clp);
     }
@@ -73,10 +73,10 @@ public class MultiCategoryListIteratorTest extends FacetTestCase {
     for (int i = 0; i < ndocs; i++) {
       Document doc = new Document();
       int numCategories = random.nextInt(numDimensions) + 1;
-      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>();
+      ArrayList<FacetLabel> categories = new ArrayList<FacetLabel>();
       for (int j = 0; j < numCategories; j++) {
         String dimension = dimensions[random.nextInt(dimensions.length)];
-        categories.add(new CategoryPath(dimension, Integer.toString(i)));
+        categories.add(new FacetLabel(dimension, Integer.toString(i)));
       }
       facetFields.addFields(doc, categories);
       indexWriter.addDocument(doc);
@@ -88,7 +88,7 @@ public class MultiCategoryListIteratorTest extends FacetTestCase {
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
     CategoryListIterator[] iterators = new CategoryListIterator[numDimensions];
     for (int i = 0; i < iterators.length; i++) {
-      CategoryListParams clp = indexingParams.getCategoryListParams(new CategoryPath(dimensions[i]));
+      CategoryListParams clp = indexingParams.getCategoryListParams(new FacetLabel(dimensions[i]));
       IntDecoder decoder = clp.createEncoder().createMatchingDecoder();
       iterators[i] = new DocValuesCategoryListIterator(clp.field, decoder);
     }
@@ -101,7 +101,7 @@ public class MultiCategoryListIteratorTest extends FacetTestCase {
         cli.getOrdinals(i, ordinals);
         assertTrue("document " + i + " does not have categories", ordinals.length > 0);
         for (int j = 0; j < ordinals.length; j++) {
-          CategoryPath cp = taxoReader.getPath(ordinals.ints[j]);
+          FacetLabel cp = taxoReader.getPath(ordinals.ints[j]);
           assertNotNull("ordinal " + ordinals.ints[j] + " not found in taxonomy", cp);
           if (cp.length == 2) {
             int globalDoc = i + context.docBase;
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/OrdinalsCacheTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/OrdinalsCacheTest.java
index 1473deb..ef1e9ac 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/OrdinalsCacheTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/OrdinalsCacheTest.java
@@ -8,7 +8,7 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.DirectoryReader;
@@ -48,10 +48,10 @@ public class OrdinalsCacheTest extends FacetTestCase {
     FacetFields facetFields = new FacetFields(taxoWriter);
     
     Document doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("A", "1")));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("A", "1")));
     writer.addDocument(doc);
     doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("A", "2")));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("A", "2")));
     writer.addDocument(doc);
     writer.close();
     taxoWriter.close();
@@ -64,7 +64,7 @@ public class OrdinalsCacheTest extends FacetTestCase {
         public void run() {
           for (AtomicReaderContext context : reader.leaves()) {
             try {
-              OrdinalsCache.getCachedOrds(context, FacetIndexingParams.DEFAULT.getCategoryListParams(new CategoryPath("A")));
+              OrdinalsCache.getCachedOrds(context, FacetIndexingParams.DEFAULT.getCategoryListParams(new FacetLabel("A")));
             } catch (IOException e) {
               throw new RuntimeException(e);
             }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
index 7d2c879..07fba01 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
@@ -35,7 +35,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -62,9 +62,9 @@ public class TestDemoFacets extends FacetTestCase {
   private void add(String ... categoryPaths) throws IOException {
     Document doc = new Document();
     
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for(String categoryPath : categoryPaths) {
-      paths.add(new CategoryPath(categoryPath, '/'));
+      paths.add(new FacetLabel(categoryPath, '/'));
     }
     facetFields.addFields(doc, paths);
     writer.addDocument(doc);
@@ -99,8 +99,8 @@ public class TestDemoFacets extends FacetTestCase {
 
     // Count both "Publish Date" and "Author" dimensions:
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     // Aggregate the facet counts:
     FacetsCollector c = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
@@ -121,9 +121,9 @@ public class TestDemoFacets extends FacetTestCase {
 
     
     // Now user drills down on Publish Date/2010:
-    fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
+    fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("Author"), 10));
     DrillDownQuery q2 = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    q2.add(new CategoryPath("Publish Date/2010", '/'));
+    q2.add(new FacetLabel("Publish Date/2010", '/'));
     c = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
     searcher.search(q2, c);
     results = c.getFacetResults();
@@ -167,7 +167,7 @@ public class TestDemoFacets extends FacetTestCase {
 
     Document doc = new Document();
     doc.add(newTextField("field", "text", Field.Store.NO));
-    facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a/path", '/')));
+    facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a/path", '/')));
     writer.addDocument(doc);
     writer.close();
     taxoWriter.close();
@@ -193,7 +193,7 @@ public class TestDemoFacets extends FacetTestCase {
 
     Document doc = new Document();
     doc.add(newTextField("field", "text", Field.Store.NO));
-    facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a/path", '/')));
+    facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a/path", '/')));
     writer.addDocument(doc);
 
     // NRT open
@@ -205,7 +205,7 @@ public class TestDemoFacets extends FacetTestCase {
     taxoWriter.close();
     
     FacetSearchParams fsp = new FacetSearchParams(fip,
-                                                  new CountFacetRequest(new CategoryPath("a", '/'), 10));
+                                                  new CountFacetRequest(new FacetLabel("a", '/'), 10));
 
     // Aggregate the facet counts:
     FacetsCollector c = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
@@ -241,7 +241,7 @@ public class TestDemoFacets extends FacetTestCase {
     Document doc = new Document();
     doc.add(newTextField("field", "text", Field.Store.NO));
     BytesRef br = new BytesRef(new byte[] {(byte) 0xee, (byte) 0x92, (byte) 0xaa, (byte) 0xef, (byte) 0x9d, (byte) 0x89});
-    facetFields.addFields(doc, Collections.singletonList(new CategoryPath("dim/" + br.utf8ToString(), '/')));
+    facetFields.addFields(doc, Collections.singletonList(new FacetLabel("dim/" + br.utf8ToString(), '/')));
     try {
       writer.addDocument(doc);
     } catch (IllegalArgumentException iae) {
@@ -269,9 +269,9 @@ public class TestDemoFacets extends FacetTestCase {
     
     Document doc = new Document();
     doc.add(newTextField("field", "text", Field.Store.NO));
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for (int i = 0; i < numLabels; i++) {
-      paths.add(new CategoryPath("dim", "" + i));
+      paths.add(new FacetLabel("dim", "" + i));
     }
     facetFields.addFields(doc, paths);
     writer.addDocument(doc);
@@ -284,7 +284,7 @@ public class TestDemoFacets extends FacetTestCase {
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);
     taxoWriter.close();
     
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("dim"), Integer.MAX_VALUE));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("dim"), Integer.MAX_VALUE));
     
     // Aggregate the facet counts:
     FacetsCollector c = FacetsCollector.create(fsp, searcher.getIndexReader(), taxoReader);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways.java
index 38cc398..2248be0 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestDrillSideways.java
@@ -39,7 +39,7 @@ import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.DrillSideways.DrillSidewaysResult;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetFields;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -79,9 +79,9 @@ public class TestDrillSideways extends FacetTestCase {
 
   private void add(String ... categoryPaths) throws IOException {
     Document doc = new Document();
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
     for(String categoryPath : categoryPaths) {
-      paths.add(new CategoryPath(categoryPath, '/'));
+      paths.add(new FacetLabel(categoryPath, '/'));
     }
     facetFields.addFields(doc, paths);
     writer.addDocument(doc);
@@ -119,8 +119,8 @@ public class TestDrillSideways extends FacetTestCase {
     // Count both "Publish Date" and "Author" dimensions, in
     // drill-down:
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     DrillSideways ds = new DrillSideways(searcher, taxoReader);
 
@@ -128,7 +128,7 @@ public class TestDrillSideways extends FacetTestCase {
     // case the drill-sideways + drill-down counts ==
     // drill-down of just the query: 
     DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
     DrillSidewaysResult r = ds.search(null, ddq, 10, fsp);
 
     assertEquals(2, r.hits.totalHits);
@@ -146,7 +146,7 @@ public class TestDrillSideways extends FacetTestCase {
     // drill-sideways + drill-down counts == drill-down of
     // just the query:
     ddq = new DrillDownQuery(fsp.indexingParams);
-    ddq.add(new CategoryPath("Author", "Lisa"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
     r = ds.search(null, ddq, 10, fsp);
 
     assertEquals(2, r.hits.totalHits);
@@ -165,7 +165,7 @@ public class TestDrillSideways extends FacetTestCase {
     // Another simple case: drill-down on on single fields
     // but OR of two values
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"), new CategoryPath("Author", "Bob"));
+    ddq.add(new FacetLabel("Author", "Lisa"), new FacetLabel("Author", "Bob"));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(3, r.hits.totalHits);
     assertEquals(2, r.facetResults.size());
@@ -179,8 +179,8 @@ public class TestDrillSideways extends FacetTestCase {
 
     // More interesting case: drill-down on two fields
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"));
-    ddq.add(new CategoryPath("Publish Date", "2010"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
+    ddq.add(new FacetLabel("Publish Date", "2010"));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(1, r.hits.totalHits);
     assertEquals(2, r.facetResults.size());
@@ -196,9 +196,9 @@ public class TestDrillSideways extends FacetTestCase {
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
 
     // Drill down on Lisa or Bob:
-    ddq.add(new CategoryPath("Author", "Lisa"),
-            new CategoryPath("Author", "Bob"));
-    ddq.add(new CategoryPath("Publish Date", "2010"));
+    ddq.add(new FacetLabel("Author", "Lisa"),
+            new FacetLabel("Author", "Bob"));
+    ddq.add(new FacetLabel("Publish Date", "2010"));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(2, r.hits.totalHits);
     assertEquals(2, r.facetResults.size());
@@ -211,10 +211,10 @@ public class TestDrillSideways extends FacetTestCase {
 
     // Test drilling down on invalid field:
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Foobar", "Baz"));
+    ddq.add(new FacetLabel("Foobar", "Baz"));
     fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Foobar"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Foobar"), 10));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(0, r.hits.totalHits);
     assertEquals(2, r.facetResults.size());
@@ -223,11 +223,11 @@ public class TestDrillSideways extends FacetTestCase {
 
     // Test drilling down on valid term or'd with invalid term:
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"),
-            new CategoryPath("Author", "Tom"));
+    ddq.add(new FacetLabel("Author", "Lisa"),
+            new FacetLabel("Author", "Tom"));
     fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(2, r.hits.totalHits);
     assertEquals(2, r.facetResults.size());
@@ -242,10 +242,10 @@ public class TestDrillSideways extends FacetTestCase {
     // LUCENE-4915: test drilling down on a dimension but
     // NOT facet counting it:
     ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"),
-            new CategoryPath("Author", "Tom"));
+    ddq.add(new FacetLabel("Author", "Lisa"),
+            new FacetLabel("Author", "Tom"));
     fsp = new FacetSearchParams(
-              new CountFacetRequest(new CategoryPath("Publish Date"), 10));
+              new CountFacetRequest(new FacetLabel("Publish Date"), 10));
     r = ds.search(null, ddq, 10, fsp);
     assertEquals(2, r.hits.totalHits);
     assertEquals(1, r.facetResults.size());
@@ -255,10 +255,10 @@ public class TestDrillSideways extends FacetTestCase {
 
     // Test main query gets null scorer:
     fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
     ddq = new DrillDownQuery(fsp.indexingParams, new TermQuery(new Term("foobar", "baz")));
-    ddq.add(new CategoryPath("Author", "Lisa"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
     r = ds.search(null, ddq, 10, fsp);
 
     assertEquals(0, r.hits.totalHits);
@@ -304,11 +304,11 @@ public class TestDrillSideways extends FacetTestCase {
     // Count both "Publish Date" and "Author" dimensions, in
     // drill-down:
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
-        new CountFacetRequest(new CategoryPath("Author"), 10));
+        new CountFacetRequest(new FacetLabel("Publish Date"), 10), 
+        new CountFacetRequest(new FacetLabel("Author"), 10));
 
     DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
     DrillSidewaysResult r = new DrillSideways(searcher, taxoReader).search(null, ddq, 10, fsp);
 
     assertEquals(1, r.hits.totalHits);
@@ -403,11 +403,11 @@ public class TestDrillSideways extends FacetTestCase {
 
     // Two requests against the same dim:
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("dim"), 10), 
-        new CountFacetRequest(new CategoryPath("dim", "a"), 10));
+        new CountFacetRequest(new FacetLabel("dim"), 10), 
+        new CountFacetRequest(new FacetLabel("dim", "a"), 10));
 
     DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("dim", "a"));
+    ddq.add(new FacetLabel("dim", "a"));
     DrillSidewaysResult r = new DrillSideways(searcher, taxoReader).search(null, ddq, 10, fsp);
 
     assertEquals(3, r.hits.totalHits);
@@ -532,7 +532,7 @@ public class TestDrillSideways extends FacetTestCase {
       Document doc = new Document();
       doc.add(newStringField("id", rawDoc.id, Field.Store.YES));
       doc.add(newStringField("content", rawDoc.contentToken, Field.Store.NO));
-      List<CategoryPath> paths = new ArrayList<CategoryPath>();
+      List<FacetLabel> paths = new ArrayList<FacetLabel>();
 
       if (VERBOSE) {
         System.out.println("  doc id=" + rawDoc.id + " token=" + rawDoc.contentToken);
@@ -540,7 +540,7 @@ public class TestDrillSideways extends FacetTestCase {
       for(int dim=0;dim<numDims;dim++) {
         int dimValue = rawDoc.dims[dim];
         if (dimValue != -1) {
-          CategoryPath cp = new CategoryPath("dim" + dim, dimValues[dim][dimValue]);
+          FacetLabel cp = new FacetLabel("dim" + dim, dimValues[dim][dimValue]);
           paths.add(cp);
           doc.add(new StringField("dim" + dim, dimValues[dim][dimValue], Field.Store.YES));
           if (VERBOSE) {
@@ -549,7 +549,7 @@ public class TestDrillSideways extends FacetTestCase {
         }
         int dimValue2 = rawDoc.dims2[dim];
         if (dimValue2 != -1) {
-          CategoryPath cp = new CategoryPath("dim" + dim, dimValues[dim][dimValue2]);
+          FacetLabel cp = new FacetLabel("dim" + dim, dimValues[dim][dimValue2]);
           paths.add(cp);
           doc.add(new StringField("dim" + dim, dimValues[dim][dimValue2], Field.Store.YES));
           if (VERBOSE) {
@@ -632,7 +632,7 @@ public class TestDrillSideways extends FacetTestCase {
             if (VERBOSE) {
               System.out.println("  do facet request on dim=" + i);
             }
-            requests.add(new CountFacetRequest(new CategoryPath("dim" + i), dimValues[numDims-1].length));
+            requests.add(new CountFacetRequest(new FacetLabel("dim" + i), dimValues[numDims-1].length));
           } else {
             if (VERBOSE) {
               System.out.println("  skip facet request on dim=" + i);
@@ -696,10 +696,10 @@ public class TestDrillSideways extends FacetTestCase {
 
       for(int dim=0;dim<numDims;dim++) {
         if (drillDowns[dim] != null) {
-          CategoryPath[] paths = new CategoryPath[drillDowns[dim].length];
+          FacetLabel[] paths = new FacetLabel[drillDowns[dim].length];
           int upto = 0;
           for(String value : drillDowns[dim]) {
-            paths[upto++] = new CategoryPath("dim" + dim, value);
+            paths[upto++] = new FacetLabel("dim" + dim, value);
           }
           ddq.add(paths);
         }
@@ -1152,11 +1152,11 @@ public class TestDrillSideways extends FacetTestCase {
     taxoWriter.close();
 
     // Count "Author"
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("Author"), 10));
 
     DrillSideways ds = new DrillSideways(searcher, taxoReader);
     DrillDownQuery ddq = new DrillDownQuery(fsp.indexingParams, new MatchAllDocsQuery());
-    ddq.add(new CategoryPath("Author", "Lisa"));
+    ddq.add(new FacetLabel("Author", "Lisa"));
     
     DrillSidewaysResult r = ds.search(null, ddq, 10, fsp); // this used to fail on IllegalArgEx
     assertEquals(0, r.hits.totalHits);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
index ee2c9c3..bca36c6 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
@@ -29,7 +29,7 @@ import org.apache.lucene.facet.sampling.TakmiSampleFixer;
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesAccumulator;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -79,7 +79,7 @@ public class TestFacetsCollector extends FacetTestCase {
       if (random().nextBoolean()) { // don't match all documents
         doc.add(new StringField("f", "v", Store.NO));
       }
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a")));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a")));
       iw.addDocument(doc);
     }
     
@@ -89,7 +89,7 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryReader r = DirectoryReader.open(indexDir);
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
-    FacetSearchParams fsp = new FacetSearchParams(new SumScoreFacetRequest(new CategoryPath("a"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(new SumScoreFacetRequest(new FacetLabel("a"), 10));
     FacetsCollector fc = FacetsCollector.create(fsp, r, taxo);
     TopScoreDocCollector topDocs = TopScoreDocCollector.create(10, false);
     ConstantScoreQuery csq = new ConstantScoreQuery(new MatchAllDocsQuery());
@@ -113,15 +113,15 @@ public class TestFacetsCollector extends FacetTestCase {
     
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(taxoDir);
     IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
-    FacetIndexingParams fip = new PerDimensionIndexingParams(Collections.singletonMap(new CategoryPath("b"), new CategoryListParams("$b")));
+    FacetIndexingParams fip = new PerDimensionIndexingParams(Collections.singletonMap(new FacetLabel("b"), new CategoryListParams("$b")));
     
     FacetFields facetFields = new FacetFields(taxonomyWriter, fip);
     for(int i = atLeast(30); i > 0; --i) {
       Document doc = new Document();
       doc.add(new StringField("f", "v", Store.NO));
-      List<CategoryPath> cats = new ArrayList<CategoryPath>();
-      cats.add(new CategoryPath("a"));
-      cats.add(new CategoryPath("b"));
+      List<FacetLabel> cats = new ArrayList<FacetLabel>();
+      cats.add(new FacetLabel("a"));
+      cats.add(new FacetLabel("b"));
       facetFields.addFields(doc, cats);
       iw.addDocument(doc);
     }
@@ -133,8 +133,8 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
     FacetSearchParams sParams = new FacetSearchParams(fip,
-        new CountFacetRequest(new CategoryPath("a"), 10), 
-        new CountFacetRequest(new CategoryPath("b"), 10));
+        new CountFacetRequest(new FacetLabel("a"), 10), 
+        new CountFacetRequest(new FacetLabel("b"), 10));
     FacetsCollector fc = FacetsCollector.create(sParams, r, taxo);
     newSearcher(r).search(new MatchAllDocsQuery(), fc);
     
@@ -152,15 +152,15 @@ public class TestFacetsCollector extends FacetTestCase {
     
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(taxoDir);
     IndexWriter iw = new IndexWriter(indexDir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
-    FacetIndexingParams fip = new PerDimensionIndexingParams(Collections.singletonMap(new CategoryPath("b"), new CategoryListParams("$b")));
+    FacetIndexingParams fip = new PerDimensionIndexingParams(Collections.singletonMap(new FacetLabel("b"), new CategoryListParams("$b")));
     
     FacetFields facetFields = new FacetFields(taxonomyWriter, fip);
     for(int i = atLeast(30); i > 0; --i) {
       Document doc = new Document();
       doc.add(new StringField("f", "v", Store.NO));
-      List<CategoryPath> cats = new ArrayList<CategoryPath>();
-      cats.add(new CategoryPath("a"));
-      cats.add(new CategoryPath("b"));
+      List<FacetLabel> cats = new ArrayList<FacetLabel>();
+      cats.add(new FacetLabel("a"));
+      cats.add(new FacetLabel("b"));
       facetFields.addFields(doc, cats);
       iw.addDocument(doc);
     }
@@ -172,8 +172,8 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
     FacetSearchParams sParams = new FacetSearchParams(fip,
-        new CountFacetRequest(new CategoryPath("a"), 10), 
-        new SumScoreFacetRequest(new CategoryPath("b"), 10));
+        new CountFacetRequest(new FacetLabel("a"), 10), 
+        new SumScoreFacetRequest(new FacetLabel("b"), 10));
     
     FacetsCollector fc = FacetsCollector.create(sParams, r, taxo);
     TopScoreDocCollector topDocs = TopScoreDocCollector.create(10, false);
@@ -202,7 +202,7 @@ public class TestFacetsCollector extends FacetTestCase {
     FacetFields facetFields = new FacetFields(taxonomyWriter);
     for(int i = atLeast(30); i > 0; --i) {
       Document doc = new Document();
-      facetFields.addFields(doc, Arrays.asList(new CategoryPath("a"), new CategoryPath("b")));
+      facetFields.addFields(doc, Arrays.asList(new FacetLabel("a"), new FacetLabel("b")));
       iw.addDocument(doc);
     }
     
@@ -212,7 +212,7 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryReader r = DirectoryReader.open(indexDir);
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(CategoryPath.EMPTY, 10));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(FacetLabel.EMPTY, 10));
     
     final TaxonomyFacetsAccumulator fa = random().nextBoolean() ? new TaxonomyFacetsAccumulator(fsp, r, taxo) : new OldFacetsAccumulator(fsp, r, taxo);
     FacetsCollector fc = FacetsCollector.create(fa);
@@ -237,7 +237,7 @@ public class TestFacetsCollector extends FacetTestCase {
     
     FacetFields facetFields = new FacetFields(taxonomyWriter);
     Document doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("a/1", '/'), new CategoryPath("b/1", '/')));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("a/1", '/'), new FacetLabel("b/1", '/')));
     iw.addDocument(doc);
     taxonomyWriter.close();
     iw.close();
@@ -246,8 +246,8 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("a"), 10), 
-        new CountFacetRequest(new CategoryPath("b"), 10));
+        new CountFacetRequest(new FacetLabel("a"), 10), 
+        new CountFacetRequest(new FacetLabel("b"), 10));
     final TaxonomyFacetsAccumulator fa = random().nextBoolean() ? new TaxonomyFacetsAccumulator(fsp, r, taxo) : new OldFacetsAccumulator(fsp, r, taxo);
     final FacetsCollector fc = FacetsCollector.create(fa);
     newSearcher(r).search(new MatchAllDocsQuery(), fc);
@@ -269,7 +269,7 @@ public class TestFacetsCollector extends FacetTestCase {
     
     FacetFields facetFields = new FacetFields(taxonomyWriter);
     Document doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("a/1", '/'), new CategoryPath("b/1", '/')));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("a/1", '/'), new FacetLabel("b/1", '/')));
     iw.addDocument(doc);
     taxonomyWriter.close();
     iw.close();
@@ -278,8 +278,8 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
     FacetSearchParams fsp = new FacetSearchParams(
-        new CountFacetRequest(new CategoryPath("a"), 10), 
-        new CountFacetRequest(new CategoryPath("b"), 10));
+        new CountFacetRequest(new FacetLabel("a"), 10), 
+        new CountFacetRequest(new FacetLabel("b"), 10));
     final TaxonomyFacetsAccumulator fa = random().nextBoolean() ? new TaxonomyFacetsAccumulator(fsp, r, taxo) : new OldFacetsAccumulator(fsp, r, taxo);
     final FacetsCollector fc = FacetsCollector.create(fa);
     // this should populate the cached results, but doing search should clear the cache
@@ -311,7 +311,7 @@ public class TestFacetsCollector extends FacetTestCase {
     
     FacetFields facetFields = new FacetFields(taxonomyWriter);
     Document doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("a/1", '/')));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("a/1", '/')));
     iw.addDocument(doc);
     taxonomyWriter.close();
     iw.close();
@@ -320,14 +320,14 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // assert IntFacetResultHandler
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("a"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("a"), 10));
     TaxonomyFacetsAccumulator fa = random().nextBoolean() ? new TaxonomyFacetsAccumulator(fsp, r, taxo) : new OldFacetsAccumulator(fsp, r, taxo);
     FacetsCollector fc = FacetsCollector.create(fa);
     newSearcher(r).search(new MatchAllDocsQuery(), fc);
     assertTrue("invalid ordinal for child node: 0", 0 != fc.getFacetResults().get(0).getFacetResultNode().subResults.get(0).ordinal);
     
     // assert IntFacetResultHandler
-    fsp = new FacetSearchParams(new SumScoreFacetRequest(new CategoryPath("a"), 10));
+    fsp = new FacetSearchParams(new SumScoreFacetRequest(new FacetLabel("a"), 10));
     if (random().nextBoolean()) {
       fa = new TaxonomyFacetsAccumulator(fsp, r, taxo);
     } else {
@@ -352,7 +352,7 @@ public class TestFacetsCollector extends FacetTestCase {
     FacetFields facetFields = new FacetFields(taxonomyWriter);
     for (int i = 0; i < 10; i++) {
       Document doc = new Document();
-      facetFields.addFields(doc, Arrays.asList(new CategoryPath("a", Integer.toString(i))));
+      facetFields.addFields(doc, Arrays.asList(new FacetLabel("a", Integer.toString(i))));
       iw.addDocument(doc);
     }
     
@@ -362,7 +362,7 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryReader r = DirectoryReader.open(indexDir);
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
     
-    CountFacetRequest cfr = new CountFacetRequest(new CategoryPath("a"), 2);
+    CountFacetRequest cfr = new CountFacetRequest(new FacetLabel("a"), 2);
     cfr.setResultMode(random().nextBoolean() ? ResultMode.GLOBAL_FLAT : ResultMode.PER_NODE_IN_TREE);
     FacetSearchParams fsp = new FacetSearchParams(cfr);
     final TaxonomyFacetsAccumulator fa = random().nextBoolean() ? new TaxonomyFacetsAccumulator(fsp, r, taxo) : new OldFacetsAccumulator(fsp, r, taxo);
@@ -384,7 +384,7 @@ public class TestFacetsCollector extends FacetTestCase {
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
     FacetFields facetFields = new FacetFields(taxoWriter);
     Document doc = new Document();
-    facetFields.addFields(doc, Arrays.asList(new CategoryPath("A/1", '/')));
+    facetFields.addFields(doc, Arrays.asList(new FacetLabel("A/1", '/')));
     indexWriter.addDocument(doc);
     IOUtils.close(indexWriter, taxoWriter);
     
@@ -392,7 +392,7 @@ public class TestFacetsCollector extends FacetTestCase {
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoDir);
     IndexSearcher searcher = new IndexSearcher(indexReader);
     // ask to count a non-existing category to test labeling
-    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("B"), 5));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new FacetLabel("B"), 5));
     
     final SamplingParams sampleParams = new SamplingParams();
     sampleParams.setMaxSampleSize(100);
@@ -434,7 +434,7 @@ public class TestFacetsCollector extends FacetTestCase {
     searcher.search(new MatchAllDocsQuery(), fc);
     List<FacetResult> facetResults = fc.getFacetResults();
     assertNotNull(facetResults);
-    assertEquals("incorrect label returned for RangeAccumulator", new CategoryPath("f"), facetResults.get(0).getFacetResultNode().label);
+    assertEquals("incorrect label returned for RangeAccumulator", new FacetLabel("f"), facetResults.get(0).getFacetResultNode().label);
 
     IOUtils.close(indexReader, taxoReader);
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
index b69c433..90315a4 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
@@ -20,7 +20,7 @@ import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -58,16 +58,16 @@ import org.junit.Test;
 
 public class TestMultipleCategoryLists extends FacetTestCase {
 
-  private static final CategoryPath[] CATEGORIES = new CategoryPath[] {
-    new CategoryPath("Author", "Mark Twain"),
-    new CategoryPath("Author", "Stephen King"),
-    new CategoryPath("Author", "Kurt Vonnegut"),
-    new CategoryPath("Band", "Rock & Pop", "The Beatles"),
-    new CategoryPath("Band", "Punk", "The Ramones"),
-    new CategoryPath("Band", "Rock & Pop", "U2"),
-    new CategoryPath("Band", "Rock & Pop", "REM"),
-    new CategoryPath("Band", "Rock & Pop", "Dave Matthews Band"),
-    new CategoryPath("Composer", "Bach"),
+  private static final FacetLabel[] CATEGORIES = new FacetLabel[] {
+    new FacetLabel("Author", "Mark Twain"),
+    new FacetLabel("Author", "Stephen King"),
+    new FacetLabel("Author", "Kurt Vonnegut"),
+    new FacetLabel("Band", "Rock & Pop", "The Beatles"),
+    new FacetLabel("Band", "Punk", "The Ramones"),
+    new FacetLabel("Band", "Rock & Pop", "U2"),
+    new FacetLabel("Band", "Rock & Pop", "REM"),
+    new FacetLabel("Band", "Rock & Pop", "Dave Matthews Band"),
+    new FacetLabel("Composer", "Bach"),
   };
   
   @Test
@@ -81,7 +81,7 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<FacetLabel, CategoryListParams>emptyMap());
 
     seedIndex(iw, tw, iParams);
 
@@ -117,7 +117,7 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
 
     PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(
-        Collections.singletonMap(new CategoryPath("Author"), new CategoryListParams("$author")));
+        Collections.singletonMap(new FacetLabel("Author"), new CategoryListParams("$author")));
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -152,9 +152,9 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
 
-    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
-    paramsMap.put(new CategoryPath("Band"), new CategoryListParams("$music"));
-    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams("$music"));
+    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
+    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$music"));
+    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$music"));
     PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
@@ -201,9 +201,9 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
 
-    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
-    paramsMap.put(new CategoryPath("Band"), new CategoryListParams("$bands"));
-    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams("$composers"));
+    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
+    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$bands"));
+    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$composers"));
     PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
@@ -239,10 +239,10 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir, OpenMode.CREATE);
 
-    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
-    paramsMap.put(new CategoryPath("Band"), new CategoryListParams("$music"));
-    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams("$music"));
-    paramsMap.put(new CategoryPath("Author"), new CategoryListParams("$literature"));
+    Map<FacetLabel,CategoryListParams> paramsMap = new HashMap<FacetLabel,CategoryListParams>();
+    paramsMap.put(new FacetLabel("Band"), new CategoryListParams("$music"));
+    paramsMap.put(new FacetLabel("Composer"), new CategoryListParams("$music"));
+    paramsMap.put(new FacetLabel("Author"), new CategoryListParams("$literature"));
     PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
 
     seedIndex(iw, tw, iParams);
@@ -318,14 +318,14 @@ public class TestMultipleCategoryLists extends FacetTestCase {
     TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
     List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
-    facetRequests.add(new CountFacetRequest(new CategoryPath("Band"), 10));
-    CountFacetRequest bandDepth = new CountFacetRequest(new CategoryPath("Band"), 10);
+    facetRequests.add(new CountFacetRequest(new FacetLabel("Band"), 10));
+    CountFacetRequest bandDepth = new CountFacetRequest(new FacetLabel("Band"), 10);
     bandDepth.setDepth(2);
     // makes it easier to check the results in the test.
     bandDepth.setResultMode(ResultMode.GLOBAL_FLAT);
     facetRequests.add(bandDepth);
-    facetRequests.add(new CountFacetRequest(new CategoryPath("Author"), 10));
-    facetRequests.add(new CountFacetRequest(new CategoryPath("Band", "Rock & Pop"), 10));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("Author"), 10));
+    facetRequests.add(new CountFacetRequest(new FacetLabel("Band", "Rock & Pop"), 10));
 
     // Faceted search parameters indicate which facets are we interested in
     FacetSearchParams facetSearchParams = new FacetSearchParams(iParams, facetRequests);
@@ -338,7 +338,7 @@ public class TestMultipleCategoryLists extends FacetTestCase {
 
   private void seedIndex(RandomIndexWriter iw, TaxonomyWriter tw, FacetIndexingParams iParams) throws IOException {
     FacetFields facetFields = new FacetFields(tw, iParams);
-    for (CategoryPath cp : CATEGORIES) {
+    for (FacetLabel cp : CATEGORIES) {
       Document doc = new Document();
       facetFields.addFields(doc, Collections.singletonList(cp));
       doc.add(new TextField("content", "alpha", Field.Store.YES));
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java
index 83c2859..021314f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSameRequestAccumulation.java
@@ -6,7 +6,7 @@ import org.apache.lucene.facet.FacetTestBase;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.junit.After;
 import org.junit.Before;
@@ -43,7 +43,7 @@ public class TestSameRequestAccumulation extends FacetTestBase {
   // Following LUCENE-4461 - ensure requesting the (exact) same request more
   // than once does not alter the results
   public void testTwoSameRequests() throws Exception {
-    final CountFacetRequest facetRequest = new CountFacetRequest(new CategoryPath("root"), 10);
+    final CountFacetRequest facetRequest = new CountFacetRequest(new FacetLabel("root"), 10);
     FacetSearchParams fsp = new FacetSearchParams(fip, facetRequest);
     
     FacetsCollector fc = FacetsCollector.create(fsp, indexReader, taxoReader);
@@ -52,7 +52,7 @@ public class TestSameRequestAccumulation extends FacetTestBase {
     final String expected = fc.getFacetResults().get(0).toString();
 
     // now add the same facet request with duplicates (same instance and same one)
-    fsp = new FacetSearchParams(fip, facetRequest, facetRequest, new CountFacetRequest(new CategoryPath("root"), 10));
+    fsp = new FacetSearchParams(fip, facetRequest, facetRequest, new CountFacetRequest(new FacetLabel("root"), 10));
 
     // make sure the search params holds 3 requests now
     assertEquals(3, fsp.facetRequests.size());
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSearcherTaxonomyManager.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSearcherTaxonomyManager.java
index a61e460..653d7ef 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSearcherTaxonomyManager.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSearcherTaxonomyManager.java
@@ -31,7 +31,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.SearcherTaxonomyManager.SearcherAndTaxonomy;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.search.MatchAllDocsQuery;
@@ -59,7 +59,7 @@ public class TestSearcherTaxonomyManager extends FacetTestCase {
             List<String> paths = new ArrayList<String>();
             while (true) {
               Document doc = new Document();
-              List<CategoryPath> docPaths = new ArrayList<CategoryPath>();
+              List<FacetLabel> docPaths = new ArrayList<FacetLabel>();
               int numPaths = _TestUtil.nextInt(random(), 1, 5);
               for(int i=0;i<numPaths;i++) {
                 String path;
@@ -78,7 +78,7 @@ public class TestSearcherTaxonomyManager extends FacetTestCase {
                     }
                   }
                 }
-                docPaths.add(new CategoryPath("field", path));
+                docPaths.add(new FacetLabel("field", path));
               }
               try {
                 facetFields.addFields(doc, docPaths);
@@ -132,7 +132,7 @@ public class TestSearcherTaxonomyManager extends FacetTestCase {
         try {
           //System.out.println("search maxOrd=" + pair.taxonomyReader.getSize());
           int topN = _TestUtil.nextInt(random(), 1, 20);
-          CountFacetRequest cfr = new CountFacetRequest(new CategoryPath("field"), topN);
+          CountFacetRequest cfr = new CountFacetRequest(new FacetLabel("field"), topN);
           FacetSearchParams fsp = new FacetSearchParams(cfr);
           FacetsCollector fc = FacetsCollector.create(fsp, pair.searcher.getIndexReader(), pair.taxonomyReader);
           pair.searcher.search(new MatchAllDocsQuery(), fc);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java
index 8dabc38..429ea4e 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestStandardFacetsAccumulator.java
@@ -13,7 +13,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -57,7 +57,7 @@ public class TestStandardFacetsAccumulator extends FacetTestCase {
         doc.add(new StringField("f", "a", Store.NO));
       }
       if (facetFields != null) {
-        facetFields.addFields(doc, Collections.singletonList(new CategoryPath("A", Integer.toString(i))));
+        facetFields.addFields(doc, Collections.singletonList(new FacetLabel("A", Integer.toString(i))));
       }
       indexWriter.addDocument(doc);
     }
@@ -97,7 +97,7 @@ public class TestStandardFacetsAccumulator extends FacetTestCase {
     
     // search for "f:a", only segments 1 and 3 should match results
     Query q = new TermQuery(new Term("f", "a"));
-    FacetRequest countNoComplements = new CountFacetRequest(new CategoryPath("A"), 10);
+    FacetRequest countNoComplements = new CountFacetRequest(new FacetLabel("A"), 10);
     FacetSearchParams fsp = new FacetSearchParams(fip, countNoComplements);
     FacetsCollector fc = FacetsCollector.create(fsp , indexReader, taxoReader);
     indexSearcher.search(q, fc);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSumValueSourceFacetRequest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSumValueSourceFacetRequest.java
index 315f31c..e04af0c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestSumValueSourceFacetRequest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestSumValueSourceFacetRequest.java
@@ -14,7 +14,7 @@ import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.CategoryListParams;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -66,7 +66,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
     for (int i = 0; i < 4; i++) {
       Document doc = new Document();
       doc.add(new NumericDocValuesField("price", (i+1)));
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a", Integer.toString(i % 2))));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a", Integer.toString(i % 2))));
       iw.addDocument(doc);
     }
     
@@ -77,7 +77,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     ValueSource valueSource = new LongFieldSource("price");
-    FacetSearchParams fsp = new FacetSearchParams(new SumValueSourceFacetRequest(new CategoryPath("a"), 10, valueSource, false));
+    FacetSearchParams fsp = new FacetSearchParams(new SumValueSourceFacetRequest(new FacetLabel("a"), 10, valueSource, false));
     FacetsCollector fc = FacetsCollector.create(fsp, r, taxo);
     newSearcher(r).search(new MatchAllDocsQuery(), fc);
     
@@ -99,7 +99,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
     for (int i = 0; i < 4; i++) {
       Document doc = new Document();
       doc.add(new NumericDocValuesField("price", (i+1)));
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a", Integer.toString(i % 2))));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a", Integer.toString(i % 2))));
       iw.addDocument(doc);
     }
     
@@ -131,7 +131,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
       @Override public String description() { return "score()"; }
     };
     
-    FacetSearchParams fsp = new FacetSearchParams(new SumValueSourceFacetRequest(new CategoryPath("a"), 10, valueSource, true));
+    FacetSearchParams fsp = new FacetSearchParams(new SumValueSourceFacetRequest(new FacetLabel("a"), 10, valueSource, true));
     FacetsCollector fc = FacetsCollector.create(fsp, r, taxo);
     TopScoreDocCollector tsdc = TopScoreDocCollector.create(10, true);
     // score documents by their 'price' field - makes asserting the correct counts for the categories easier
@@ -161,7 +161,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
     for (int i = 0; i < 4; i++) {
       Document doc = new Document();
       doc.add(new NumericDocValuesField("price", (i+1)));
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath("a", Integer.toString(i % 2), "1")));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel("a", Integer.toString(i % 2), "1")));
       iw.addDocument(doc);
     }
     
@@ -172,7 +172,7 @@ public class TestSumValueSourceFacetRequest extends FacetTestCase {
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     ValueSource valueSource = new LongFieldSource("price");
-    FacetSearchParams fsp = new FacetSearchParams(fip, new SumValueSourceFacetRequest(new CategoryPath("a"), 10, valueSource, false));
+    FacetSearchParams fsp = new FacetSearchParams(fip, new SumValueSourceFacetRequest(new FacetLabel("a"), 10, valueSource, false));
     FacetsCollector fc = FacetsCollector.create(fsp, r, taxo);
     newSearcher(r).search(new MatchAllDocsQuery(), fc);
     
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
index e183043..8b9036f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
@@ -15,7 +15,7 @@ import org.apache.lucene.facet.old.OldFacetsAccumulator;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
@@ -107,35 +107,35 @@ public class TestTopKInEachNodeResultHandler extends FacetTestCase {
       // facet counts and compare to control
       Query q = new TermQuery(new Term("content", "alpha"));
 
-      CountFacetRequest cfra23 = new CountFacetRequest(new CategoryPath("a"), 2);
+      CountFacetRequest cfra23 = new CountFacetRequest(new FacetLabel("a"), 2);
       cfra23.setDepth(3);
       cfra23.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfra22 = new CountFacetRequest(new CategoryPath("a"), 2);
+      CountFacetRequest cfra22 = new CountFacetRequest(new FacetLabel("a"), 2);
       cfra22.setDepth(2);
       cfra22.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfra21 = new CountFacetRequest(new CategoryPath("a"), 2);
+      CountFacetRequest cfra21 = new CountFacetRequest(new FacetLabel("a"), 2);
       cfra21.setDepth(1);
       cfra21.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfrb22 = new CountFacetRequest(new CategoryPath("a", "b"), 2);
+      CountFacetRequest cfrb22 = new CountFacetRequest(new FacetLabel("a", "b"), 2);
       cfrb22.setDepth(2);
       cfrb22.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfrb23 = new CountFacetRequest(new CategoryPath("a", "b"), 2);
+      CountFacetRequest cfrb23 = new CountFacetRequest(new FacetLabel("a", "b"), 2);
       cfrb23.setDepth(3);
       cfrb23.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfrb21 = new CountFacetRequest(new CategoryPath("a", "b"), 2);
+      CountFacetRequest cfrb21 = new CountFacetRequest(new FacetLabel("a", "b"), 2);
       cfrb21.setDepth(1);
       cfrb21.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest doctor = new CountFacetRequest(new CategoryPath("Doctor"), 2);
+      CountFacetRequest doctor = new CountFacetRequest(new FacetLabel("Doctor"), 2);
       doctor.setDepth(1);
       doctor.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      CountFacetRequest cfrb20 = new CountFacetRequest(new CategoryPath("a", "b"), 2);
+      CountFacetRequest cfrb20 = new CountFacetRequest(new FacetLabel("a", "b"), 2);
       cfrb20.setDepth(0);
       cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
@@ -296,7 +296,7 @@ public class TestTopKInEachNodeResultHandler extends FacetTestCase {
       TaxonomyWriter tw, String... strings) throws IOException {
     Document d = new Document();
     FacetFields facetFields = new FacetFields(tw, iParams);
-    facetFields.addFields(d, Collections.singletonList(new CategoryPath(strings)));
+    facetFields.addFields(d, Collections.singletonList(new FacetLabel(strings)));
     d.add(new TextField("content", "alpha", Field.Store.YES));
     iw.addDocument(d);
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
index a890ea1..426206b 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
@@ -8,7 +8,7 @@ import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.params.CategoryListParams.OrdinalPolicy;
 import org.apache.lucene.facet.search.FacetRequest.ResultMode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.junit.Test;
 
@@ -31,20 +31,20 @@ import org.junit.Test;
 
 public class TestTopKResultsHandler extends BaseTestTopK {
 
-  private static final CategoryPath[] CATEGORIES = {
-    new CategoryPath( "a", "b"),
-    new CategoryPath( "a", "b", "1"),
-    new CategoryPath( "a", "b", "1"),
-    new CategoryPath( "a", "b", "2"),
-    new CategoryPath( "a", "b", "2"),
-    new CategoryPath( "a", "b", "3"),
-    new CategoryPath( "a", "b", "4"),
-    new CategoryPath( "a", "c"),
-    new CategoryPath( "a", "c"),
-    new CategoryPath( "a", "c"),
-    new CategoryPath( "a", "c"),
-    new CategoryPath( "a", "c"),
-    new CategoryPath( "a", "c", "1"),
+  private static final FacetLabel[] CATEGORIES = {
+    new FacetLabel( "a", "b"),
+    new FacetLabel( "a", "b", "1"),
+    new FacetLabel( "a", "b", "1"),
+    new FacetLabel( "a", "b", "2"),
+    new FacetLabel( "a", "b", "2"),
+    new FacetLabel( "a", "b", "3"),
+    new FacetLabel( "a", "b", "4"),
+    new FacetLabel( "a", "c"),
+    new FacetLabel( "a", "c"),
+    new FacetLabel( "a", "c"),
+    new FacetLabel( "a", "c"),
+    new FacetLabel( "a", "c"),
+    new FacetLabel( "a", "c", "1"),
   };
 
   @Override
@@ -58,7 +58,7 @@ public class TestTopKResultsHandler extends BaseTestTopK {
   }
   
   @Override
-  protected List<CategoryPath> getCategories(int doc) {
+  protected List<FacetLabel> getCategories(int doc) {
     return Arrays.asList(CATEGORIES[doc]);
   }
   
@@ -74,15 +74,15 @@ public class TestTopKResultsHandler extends BaseTestTopK {
       initIndex(fip);
 
       List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
-      facetRequests.add(new CountFacetRequest(new CategoryPath("a"), 100));
-      CountFacetRequest cfra = new CountFacetRequest(new CategoryPath("a"), 100);
+      facetRequests.add(new CountFacetRequest(new FacetLabel("a"), 100));
+      CountFacetRequest cfra = new CountFacetRequest(new FacetLabel("a"), 100);
       cfra.setDepth(3);
       // makes it easier to check the results in the test.
       cfra.setResultMode(ResultMode.GLOBAL_FLAT);
       facetRequests.add(cfra);
-      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b"), 100));
-      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b", "1"), 100));
-      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "c"), 100));
+      facetRequests.add(new CountFacetRequest(new FacetLabel("a", "b"), 100));
+      facetRequests.add(new CountFacetRequest(new FacetLabel("a", "b", "1"), 100));
+      facetRequests.add(new CountFacetRequest(new FacetLabel("a", "c"), 100));
       
       // do different facet counts and compare to control
       FacetSearchParams sParams = getFacetSearchParams(facetRequests, fip);
@@ -153,7 +153,7 @@ public class TestTopKResultsHandler extends BaseTestTopK {
       initIndex(fip);
 
       // do different facet counts and compare to control
-      CategoryPath path = new CategoryPath("a", "b");
+      FacetLabel path = new FacetLabel("a", "b");
       FacetSearchParams sParams = getFacetSearchParams(fip, new CountFacetRequest(path, Integer.MAX_VALUE));
       FacetsCollector fc = FacetsCollector.create(sParams, indexReader, taxoReader);
       
@@ -193,7 +193,7 @@ public class TestTopKResultsHandler extends BaseTestTopK {
       FacetIndexingParams fip = getFacetIndexingParams(partitionSize);
       initIndex(fip);
 
-      CategoryPath path = new CategoryPath("Miau Hattulla");
+      FacetLabel path = new FacetLabel("Miau Hattulla");
       FacetSearchParams sParams = getFacetSearchParams(fip, new CountFacetRequest(path, 10));
 
       FacetsCollector fc = FacetsCollector.create(sParams, indexReader, taxoReader);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
index a930a22..8e4dfcb 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestRangeFacets.java
@@ -47,7 +47,7 @@ import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsAccumulator;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.sortedset.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
index da99356..1f0a4e8 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestSortedSetDocValuesFacets.java
@@ -27,7 +27,7 @@ import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.simple.SortedSetDocValuesFacetCounts;
 import org.apache.lucene.facet.simple.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
@@ -80,8 +80,8 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
 
     // DrillDown:
     SimpleDrillDownQuery q = new SimpleDrillDownQuery();
-    q.add(new CategoryPath("a", "foo"));
-    q.add(new CategoryPath("b", "baz"));
+    q.add(new FacetLabel("a", "foo"));
+    q.add(new FacetLabel("b", "baz"));
     TopDocs hits = searcher.search(q, 1);
     assertEquals(1, hits.totalHits);
 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacets.java
index 2e01e0b..b27dacd 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacets.java
@@ -30,7 +30,7 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -117,7 +117,7 @@ public class TestTaxonomyFacets extends FacetTestCase {
 
     // Now user drills down on Publish Date/2010:
     SimpleDrillDownQuery q2 = new SimpleDrillDownQuery(new MatchAllDocsQuery());
-    q2.add(new CategoryPath("Publish Date", "2010"));
+    q2.add(new FacetLabel("Publish Date", "2010"));
     c = new SimpleFacetsCollector();
     searcher.search(q2, c);
     facets = new TaxonomyFacetCounts(taxoReader, fts, c);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetsSumValueSource.java b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetsSumValueSource.java
index 211ce61..4cbf663 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetsSumValueSource.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/simple/TestTaxonomyFacetsSumValueSource.java
@@ -31,7 +31,7 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.IntField;
 import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
index 008a007..db62bab 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
@@ -32,7 +32,7 @@ import org.apache.lucene.facet.search.DrillDownQuery;
 import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.IndexSearcher;
@@ -66,14 +66,14 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     // Mixup order we add these paths, to verify tie-break
     // order is by label (unicode sort) and has nothing to
     // do w/ order we added them:
-    List<CategoryPath> paths = new ArrayList<CategoryPath>();
-    paths.add(new CategoryPath("a", "foo"));
-    paths.add(new CategoryPath("a", "bar"));
-    paths.add(new CategoryPath("a", "zoo"));
+    List<FacetLabel> paths = new ArrayList<FacetLabel>();
+    paths.add(new FacetLabel("a", "foo"));
+    paths.add(new FacetLabel("a", "bar"));
+    paths.add(new FacetLabel("a", "zoo"));
     Collections.shuffle(paths, random());
 
-    paths.add(new CategoryPath("b", "baz"));
-    paths.add(new CategoryPath("b" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, "bazfoo"));
+    paths.add(new FacetLabel("b", "baz"));
+    paths.add(new FacetLabel("b" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, "bazfoo"));
 
     dvFields.addFields(doc, paths);
 
@@ -83,7 +83,7 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     }
 
     doc = new Document();
-    dvFields.addFields(doc, Collections.singletonList(new CategoryPath("a", "foo")));
+    dvFields.addFields(doc, Collections.singletonList(new FacetLabel("a", "foo")));
     writer.addDocument(doc);
 
     // NRT open
@@ -91,9 +91,9 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     writer.close();
 
     List<FacetRequest> requests = new ArrayList<FacetRequest>();
-    requests.add(new CountFacetRequest(new CategoryPath("a"), 10));
-    requests.add(new CountFacetRequest(new CategoryPath("b"), 10));
-    requests.add(new CountFacetRequest(new CategoryPath("b" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));
+    requests.add(new CountFacetRequest(new FacetLabel("a"), 10));
+    requests.add(new CountFacetRequest(new FacetLabel("b"), 10));
+    requests.add(new CountFacetRequest(new FacetLabel("b" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));
 
     final boolean doDimCount = random().nextBoolean();
 
@@ -133,13 +133,13 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     // DrillDown:
 
     DrillDownQuery q = new DrillDownQuery(fip);
-    q.add(new CategoryPath("a", "foo"));
-    q.add(new CategoryPath("b", "baz"));
+    q.add(new FacetLabel("a", "foo"));
+    q.add(new FacetLabel("b", "baz"));
     TopDocs hits = searcher.search(q, 1);
     assertEquals(1, hits.totalHits);
 
     q = new DrillDownQuery(fip);
-    q.add(new CategoryPath("a"));
+    q.add(new FacetLabel("a"));
     hits = searcher.search(q, 1);
     assertEquals(2, hits.totalHits);
 
@@ -156,24 +156,24 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields();
 
     Document doc = new Document();
-    dvFields.addFields(doc, Collections.singletonList(new CategoryPath("a", "foo")));
+    dvFields.addFields(doc, Collections.singletonList(new FacetLabel("a", "foo")));
     writer.addDocument(doc);
 
     IndexReader r = writer.getReader();
     SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(r);
 
     doc = new Document();
-    dvFields.addFields(doc, Collections.singletonList(new CategoryPath("a", "bar")));
+    dvFields.addFields(doc, Collections.singletonList(new FacetLabel("a", "bar")));
     writer.addDocument(doc);
 
     doc = new Document();
-    dvFields.addFields(doc, Collections.singletonList(new CategoryPath("a", "baz")));
+    dvFields.addFields(doc, Collections.singletonList(new FacetLabel("a", "baz")));
     writer.addDocument(doc);
 
     IndexSearcher searcher = newSearcher(writer.getReader());
 
     List<FacetRequest> requests = new ArrayList<FacetRequest>();
-    requests.add(new CountFacetRequest(new CategoryPath("a"), 10));
+    requests.add(new CountFacetRequest(new FacetLabel("a"), 10));
 
     FacetSearchParams fsp = new FacetSearchParams(requests);
     
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestCategoryPath.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestCategoryPath.java
index de5d3cb..6dca6c3 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestCategoryPath.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestCategoryPath.java
@@ -27,19 +27,19 @@ public class TestCategoryPath extends FacetTestCase {
   
   @Test 
   public void testBasic() {
-    assertEquals(0, CategoryPath.EMPTY.length);
-    assertEquals(1, new CategoryPath("hello").length);
-    assertEquals(2, new CategoryPath("hello", "world").length);
+    assertEquals(0, FacetLabel.EMPTY.length);
+    assertEquals(1, new FacetLabel("hello").length);
+    assertEquals(2, new FacetLabel("hello", "world").length);
   }
   
   @Test 
   public void testToString() {
     // When the category is empty, we expect an empty string
-    assertEquals("", CategoryPath.EMPTY.toString('/'));
+    assertEquals("", FacetLabel.EMPTY.toString('/'));
     // one category (so no delimiter needed)
-    assertEquals("hello", new CategoryPath("hello").toString('/'));
+    assertEquals("hello", new FacetLabel("hello").toString('/'));
     // more than one category (so no delimiter needed)
-    assertEquals("hello/world", new CategoryPath("hello", "world").toString('/'));
+    assertEquals("hello/world", new FacetLabel("hello", "world").toString('/'));
   }
 
   @Test 
@@ -48,7 +48,7 @@ public class TestCategoryPath extends FacetTestCase {
     for (int i = 0; i < components.length; i++) {
       components[i] = Integer.toString(i);
     }
-    CategoryPath cp = new CategoryPath(components);
+    FacetLabel cp = new FacetLabel(components);
     for (int i = 0; i < components.length; i++) {
       assertEquals(i, Integer.parseInt(cp.components[i]));
     }
@@ -56,15 +56,15 @@ public class TestCategoryPath extends FacetTestCase {
 
   @Test
   public void testDelimiterConstructor() {
-    CategoryPath p = new CategoryPath("", '/');
+    FacetLabel p = new FacetLabel("", '/');
     assertEquals(0, p.length);
-    p = new CategoryPath("hello", '/');
+    p = new FacetLabel("hello", '/');
     assertEquals(p.length, 1);
     assertEquals(p.toString('@'), "hello");
-    p = new CategoryPath("hi/there", '/');
+    p = new FacetLabel("hi/there", '/');
     assertEquals(p.length, 2);
     assertEquals(p.toString('@'), "hi@there");
-    p = new CategoryPath("how/are/you/doing?", '/');
+    p = new FacetLabel("how/are/you/doing?", '/');
     assertEquals(p.length, 4);
     assertEquals(p.toString('@'), "how@are@you@doing?");
   }
@@ -75,17 +75,17 @@ public class TestCategoryPath extends FacetTestCase {
     // defaults to creating an object with a 0 initial capacity.
     // If we change this default later, we also need to change this
     // test.
-    CategoryPath p = CategoryPath.EMPTY;
+    FacetLabel p = FacetLabel.EMPTY;
     assertEquals(0, p.length);
     assertEquals("", p.toString('/'));
   }
   
   @Test 
   public void testSubPath() {
-    final CategoryPath p = new CategoryPath("hi", "there", "man");
+    final FacetLabel p = new FacetLabel("hi", "there", "man");
     assertEquals(p.length, 3);
     
-    CategoryPath p1 = p.subpath(2);
+    FacetLabel p1 = p.subpath(2);
     assertEquals(2, p1.length);
     assertEquals("hi/there", p1.toString('/'));
 
@@ -109,38 +109,38 @@ public class TestCategoryPath extends FacetTestCase {
 
   @Test 
   public void testEquals() {
-    assertEquals(CategoryPath.EMPTY, CategoryPath.EMPTY);
-    assertFalse(CategoryPath.EMPTY.equals(new CategoryPath("hi")));
-    assertFalse(CategoryPath.EMPTY.equals(Integer.valueOf(3)));
-    assertEquals(new CategoryPath("hello", "world"), new CategoryPath("hello", "world"));    
+    assertEquals(FacetLabel.EMPTY, FacetLabel.EMPTY);
+    assertFalse(FacetLabel.EMPTY.equals(new FacetLabel("hi")));
+    assertFalse(FacetLabel.EMPTY.equals(Integer.valueOf(3)));
+    assertEquals(new FacetLabel("hello", "world"), new FacetLabel("hello", "world"));    
   }
   
   @Test 
   public void testHashCode() {
-    assertEquals(CategoryPath.EMPTY.hashCode(), CategoryPath.EMPTY.hashCode());
-    assertFalse(CategoryPath.EMPTY.hashCode() == new CategoryPath("hi").hashCode());
-    assertEquals(new CategoryPath("hello", "world").hashCode(), new CategoryPath("hello", "world").hashCode());
+    assertEquals(FacetLabel.EMPTY.hashCode(), FacetLabel.EMPTY.hashCode());
+    assertFalse(FacetLabel.EMPTY.hashCode() == new FacetLabel("hi").hashCode());
+    assertEquals(new FacetLabel("hello", "world").hashCode(), new FacetLabel("hello", "world").hashCode());
   }
   
   @Test 
   public void testLongHashCode() {
-    assertEquals(CategoryPath.EMPTY.longHashCode(), CategoryPath.EMPTY.longHashCode());
-    assertFalse(CategoryPath.EMPTY.longHashCode() == new CategoryPath("hi").longHashCode());
-    assertEquals(new CategoryPath("hello", "world").longHashCode(), new CategoryPath("hello", "world").longHashCode());
+    assertEquals(FacetLabel.EMPTY.longHashCode(), FacetLabel.EMPTY.longHashCode());
+    assertFalse(FacetLabel.EMPTY.longHashCode() == new FacetLabel("hi").longHashCode());
+    assertEquals(new FacetLabel("hello", "world").longHashCode(), new FacetLabel("hello", "world").longHashCode());
   }
   
   @Test 
   public void testArrayConstructor() {
-    CategoryPath p = new CategoryPath("hello", "world", "yo");
+    FacetLabel p = new FacetLabel("hello", "world", "yo");
     assertEquals(3, p.length);
     assertEquals("hello/world/yo", p.toString('/'));
   }
   
   @Test 
   public void testCharsNeededForFullPath() {
-    assertEquals(0, CategoryPath.EMPTY.fullPathLength());
+    assertEquals(0, FacetLabel.EMPTY.fullPathLength());
     String[] components = { "hello", "world", "yo" };
-    CategoryPath cp = new CategoryPath(components);
+    FacetLabel cp = new FacetLabel(components);
     int expectedCharsNeeded = 0;
     for (String comp : components) {
       expectedCharsNeeded += comp.length();
@@ -151,7 +151,7 @@ public class TestCategoryPath extends FacetTestCase {
   
   @Test 
   public void testCopyToCharArray() {
-    CategoryPath p = new CategoryPath("hello", "world", "yo");
+    FacetLabel p = new FacetLabel("hello", "world", "yo");
     char[] charArray = new char[p.fullPathLength()];
     int numCharsCopied = p.copyFullPath(charArray, 0, '.');
     assertEquals(p.fullPathLength(), numCharsCopied);
@@ -160,20 +160,20 @@ public class TestCategoryPath extends FacetTestCase {
   
   @Test 
   public void testCompareTo() {
-    CategoryPath p = new CategoryPath("a/b/c/d", '/');
-    CategoryPath pother = new CategoryPath("a/b/c/d", '/');
+    FacetLabel p = new FacetLabel("a/b/c/d", '/');
+    FacetLabel pother = new FacetLabel("a/b/c/d", '/');
     assertEquals(0, pother.compareTo(p));
     assertEquals(0, p.compareTo(pother));
-    pother = new CategoryPath("", '/');
+    pother = new FacetLabel("", '/');
     assertTrue(pother.compareTo(p) < 0);
     assertTrue(p.compareTo(pother) > 0);
-    pother = new CategoryPath("a/b_/c/d", '/');
+    pother = new FacetLabel("a/b_/c/d", '/');
     assertTrue(pother.compareTo(p) > 0);
     assertTrue(p.compareTo(pother) < 0);
-    pother = new CategoryPath("a/b/c", '/');
+    pother = new FacetLabel("a/b/c", '/');
     assertTrue(pother.compareTo(p) < 0);
     assertTrue(p.compareTo(pother) > 0);
-    pother = new CategoryPath("a/b/c/e", '/');
+    pother = new FacetLabel("a/b/c/e", '/');
     assertTrue(pother.compareTo(p) > 0);
     assertTrue(p.compareTo(pother) < 0);
   }
@@ -192,7 +192,7 @@ public class TestCategoryPath extends FacetTestCase {
 
     for (String[] components : components_tests) {
       try {
-        assertNotNull(new CategoryPath(components));
+        assertNotNull(new FacetLabel(components));
         fail("empty or null components should not be allowed: " + Arrays.toString(components));
       } catch (IllegalArgumentException e) {
         // ok
@@ -206,7 +206,7 @@ public class TestCategoryPath extends FacetTestCase {
     
     for (String path : path_tests) {
       try {
-        assertNotNull(new CategoryPath(path, '/'));
+        assertNotNull(new FacetLabel(path, '/'));
         fail("empty or null components should not be allowed: " + path);
       } catch (IllegalArgumentException e) {
         // ok
@@ -214,7 +214,7 @@ public class TestCategoryPath extends FacetTestCase {
     }
 
     // a trailing path separator is produces only one component
-    assertNotNull(new CategoryPath("test/", '/'));
+    assertNotNull(new FacetLabel("test/", '/'));
     
   }
 
@@ -222,7 +222,7 @@ public class TestCategoryPath extends FacetTestCase {
   public void testInvalidDelimChar() throws Exception {
     // Make sure CategoryPath doesn't silently corrupt:
     char[] buf = new char[100];
-    CategoryPath cp = new CategoryPath("foo/bar");
+    FacetLabel cp = new FacetLabel("foo/bar");
     try {
       cp.toString();
       fail("expected exception");
@@ -235,7 +235,7 @@ public class TestCategoryPath extends FacetTestCase {
     } catch (IllegalArgumentException iae) {
       // expected
     }
-    cp = new CategoryPath("abc", "foo/bar");
+    cp = new FacetLabel("abc", "foo/bar");
     try {
       cp.toString();
       fail("expected exception");
@@ -248,7 +248,7 @@ public class TestCategoryPath extends FacetTestCase {
     } catch (IllegalArgumentException iae) {
       // expected
     }
-    cp = new CategoryPath("foo:bar");
+    cp = new FacetLabel("foo:bar");
     try {
       cp.toString(':');
       fail("expected exception");
@@ -261,7 +261,7 @@ public class TestCategoryPath extends FacetTestCase {
     } catch (IllegalArgumentException iae) {
       // expected
     }
-    cp = new CategoryPath("abc", "foo:bar");
+    cp = new FacetLabel("abc", "foo:bar");
     try {
       cp.toString(':');
       fail("expected exception");
@@ -280,7 +280,7 @@ public class TestCategoryPath extends FacetTestCase {
   public void testLongPath() throws Exception {
     String bigComp = null;
     while (true) {
-      int len = CategoryPath.MAX_CATEGORY_PATH_LENGTH;
+      int len = FacetLabel.MAX_CATEGORY_PATH_LENGTH;
       bigComp = _TestUtil.randomSimpleString(random(), len, len);
       if (bigComp.indexOf('\u001f') != -1) {
         continue;
@@ -289,14 +289,14 @@ public class TestCategoryPath extends FacetTestCase {
     }
 
     try {
-      assertNotNull(new CategoryPath("dim", bigComp));
+      assertNotNull(new FacetLabel("dim", bigComp));
       fail("long paths should not be allowed; len=" + bigComp.length());
     } catch (IllegalArgumentException e) {
       // expected
     }
 
     try {
-      assertNotNull(new CategoryPath("dim\u001f" + bigComp, '\u001f'));
+      assertNotNull(new FacetLabel("dim\u001f" + bigComp, '\u001f'));
       fail("long paths should not be allowed; len=" + bigComp.length());
     } catch (IllegalArgumentException e) {
       // expected
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
index c5b3f7a..205c194 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
@@ -113,7 +113,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
    */
   public static void fillTaxonomy(TaxonomyWriter tw) throws IOException {
     for (int i = 0; i < categories.length; i++) {
-      int ordinal = tw.addCategory(new CategoryPath(categories[i]));
+      int ordinal = tw.addCategory(new FacetLabel(categories[i]));
       int expectedOrdinal = expectedPaths[i][expectedPaths[i].length-1];
       if (ordinal!=expectedOrdinal) {
         fail("For category "+showcat(categories[i])+" expected ordinal "+
@@ -140,7 +140,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     return sb.toString();
   }
 
-  private String showcat(CategoryPath path) {
+  private String showcat(FacetLabel path) {
     if (path==null) {
       return "<null>";
     }
@@ -232,7 +232,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     tw = new DirectoryTaxonomyWriter(indexDir);
     fillTaxonomy(tw);
     // Add one new category, just to make commit() do something:
-    tw.addCategory(new CategoryPath("hi"));
+    tw.addCategory(new FacetLabel("hi"));
     // Do a commit(). Here was a bug - if tw had a reader open, it should
     // be reopened after the commit. However, in our case the reader should
     // not be open (as explained above) but because it was not set to null,
@@ -254,34 +254,34 @@ public class TestTaxonomyCombined extends FacetTestCase {
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);
     assertEquals(1, tw.getSize()); // the root only
     // Test that adding a new top-level category works
-    assertEquals(1, tw.addCategory(new CategoryPath("a")));
+    assertEquals(1, tw.addCategory(new FacetLabel("a")));
     assertEquals(2, tw.getSize());
     // Test that adding the same category again is noticed, and the
     // same ordinal (and not a new one) is returned.
-    assertEquals(1, tw.addCategory(new CategoryPath("a")));
+    assertEquals(1, tw.addCategory(new FacetLabel("a")));
     assertEquals(2, tw.getSize());
     // Test that adding another top-level category returns a new ordinal,
     // not the same one
-    assertEquals(2, tw.addCategory(new CategoryPath("b")));
+    assertEquals(2, tw.addCategory(new FacetLabel("b")));
     assertEquals(3, tw.getSize());
     // Test that adding a category inside one of the above adds just one
     // new ordinal:
-    assertEquals(3, tw.addCategory(new CategoryPath("a","c")));
+    assertEquals(3, tw.addCategory(new FacetLabel("a","c")));
     assertEquals(4, tw.getSize());
     // Test that adding the same second-level category doesn't do anything:
-    assertEquals(3, tw.addCategory(new CategoryPath("a","c")));
+    assertEquals(3, tw.addCategory(new FacetLabel("a","c")));
     assertEquals(4, tw.getSize());
     // Test that adding a second-level category with two new components
     // indeed adds two categories
-    assertEquals(5, tw.addCategory(new CategoryPath("d","e")));
+    assertEquals(5, tw.addCategory(new FacetLabel("d","e")));
     assertEquals(6, tw.getSize());
     // Verify that the parents were added above in the order we expected
-    assertEquals(4, tw.addCategory(new CategoryPath("d")));
+    assertEquals(4, tw.addCategory(new FacetLabel("d")));
     // Similar, but inside a category that already exists:
-    assertEquals(7, tw.addCategory(new CategoryPath("b", "d","e")));
+    assertEquals(7, tw.addCategory(new FacetLabel("b", "d","e")));
     assertEquals(8, tw.getSize());
     // And now inside two levels of categories that already exist:
-    assertEquals(8, tw.addCategory(new CategoryPath("b", "d","f")));
+    assertEquals(8, tw.addCategory(new FacetLabel("b", "d","f")));
     assertEquals(9, tw.getSize());
     
     tw.close();
@@ -304,7 +304,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     assertEquals(1, tr.getSize());
     assertEquals(0, tr.getPath(0).length);
     assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParallelTaxonomyArrays().parents()[0]);
-    assertEquals(0, tr.getOrdinal(CategoryPath.EMPTY));
+    assertEquals(0, tr.getOrdinal(FacetLabel.EMPTY));
     tr.close();
     indexDir.close();
   }
@@ -323,7 +323,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     assertEquals(1, tr.getSize());
     assertEquals(0, tr.getPath(0).length);
     assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParallelTaxonomyArrays().parents()[0]);
-    assertEquals(0, tr.getOrdinal(CategoryPath.EMPTY));
+    assertEquals(0, tr.getOrdinal(FacetLabel.EMPTY));
     tw.close();
     tr.close();
     indexDir.close();
@@ -352,8 +352,8 @@ public class TestTaxonomyCombined extends FacetTestCase {
 
     // test TaxonomyReader.getCategory():
     for (int i = 1; i < tr.getSize(); i++) {
-      CategoryPath expectedCategory = new CategoryPath(expectedCategories[i]);
-      CategoryPath category = tr.getPath(i);
+      FacetLabel expectedCategory = new FacetLabel(expectedCategories[i]);
+      FacetLabel category = tr.getPath(i);
       if (!expectedCategory.equals(category)) {
         fail("For ordinal "+i+" expected category "+
             showcat(expectedCategory)+", but got "+showcat(category));
@@ -367,15 +367,15 @@ public class TestTaxonomyCombined extends FacetTestCase {
     // test TaxonomyReader.getOrdinal():
     for (int i = 1; i < expectedCategories.length; i++) {
       int expectedOrdinal = i;
-      int ordinal = tr.getOrdinal(new CategoryPath(expectedCategories[i]));
+      int ordinal = tr.getOrdinal(new FacetLabel(expectedCategories[i]));
       if (expectedOrdinal != ordinal) {
         fail("For category "+showcat(expectedCategories[i])+" expected ordinal "+
             expectedOrdinal+", but got "+ordinal);
       }
     }
     // (also test invalid categories:)
-    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath("non-existant")));
-    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new CategoryPath("Author", "Jules Verne")));
+    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel("non-existant")));
+    assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(new FacetLabel("Author", "Jules Verne")));
 
     tr.close();
     indexDir.close();
@@ -407,9 +407,9 @@ public class TestTaxonomyCombined extends FacetTestCase {
 
     // check parent of non-root ordinals:
     for (int ordinal=1; ordinal<tr.getSize(); ordinal++) {
-      CategoryPath me = tr.getPath(ordinal);
+      FacetLabel me = tr.getPath(ordinal);
       int parentOrdinal = parents[ordinal];
-      CategoryPath parent = tr.getPath(parentOrdinal);
+      FacetLabel parent = tr.getPath(parentOrdinal);
       if (parent==null) {
         fail("Parent of "+ordinal+" is "+parentOrdinal+
         ", but this is not a valid category.");
@@ -476,9 +476,9 @@ public class TestTaxonomyCombined extends FacetTestCase {
 
     // check parent of non-root ordinals:
     for (int ordinal = 1; ordinal < tr.getSize(); ordinal++) {
-      CategoryPath me = tr.getPath(ordinal);
+      FacetLabel me = tr.getPath(ordinal);
       int parentOrdinal = tw.getParent(ordinal);
-      CategoryPath parent = tr.getPath(parentOrdinal);
+      FacetLabel parent = tr.getPath(parentOrdinal);
       if (parent == null) {
         fail("Parent of " + ordinal + " is " + parentOrdinal
             + ", but this is not a valid category.");
@@ -668,7 +668,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
   public void testChildrenArraysGrowth() throws Exception {
     Directory indexDir = newDirectory();
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);
-    tw.addCategory(new CategoryPath("hi", "there"));
+    tw.addCategory(new FacetLabel("hi", "there"));
     tw.commit();
     TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);
     ParallelTaxonomyArrays ca = tr.getParallelTaxonomyArrays();
@@ -677,8 +677,8 @@ public class TestTaxonomyCombined extends FacetTestCase {
     assertEquals(3, ca.children().length);
     assertTrue(Arrays.equals(new int[] { 1, 2, -1 }, ca.children()));
     assertTrue(Arrays.equals(new int[] { -1, -1, -1 }, ca.siblings()));
-    tw.addCategory(new CategoryPath("hi", "ho"));
-    tw.addCategory(new CategoryPath("hello"));
+    tw.addCategory(new FacetLabel("hi", "ho"));
+    tw.addCategory(new FacetLabel("hello"));
     tw.commit();
     // Before refresh, nothing changed..
     ParallelTaxonomyArrays newca = tr.getParallelTaxonomyArrays();
@@ -708,8 +708,8 @@ public class TestTaxonomyCombined extends FacetTestCase {
     // compute base child arrays - after first chunk, and after the other
     Directory indexDirBase = newDirectory();
     TaxonomyWriter twBase = new DirectoryTaxonomyWriter(indexDirBase);
-    twBase.addCategory(new CategoryPath("a", "0"));
-    final CategoryPath abPath = new CategoryPath("a", "b");
+    twBase.addCategory(new FacetLabel("a", "0"));
+    final FacetLabel abPath = new FacetLabel("a", "b");
     twBase.addCategory(abPath);
     twBase.commit();
     TaxonomyReader trBase = new DirectoryTaxonomyReader(indexDirBase);
@@ -721,7 +721,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     
     final int numCategories = atLeast(800);
     for (int i = 0; i < numCategories; i++) {
-      twBase.addCategory(new CategoryPath("a", "b", Integer.toString(i)));
+      twBase.addCategory(new FacetLabel("a", "b", Integer.toString(i)));
     }
     twBase.close();
     
@@ -742,18 +742,18 @@ public class TestTaxonomyCombined extends FacetTestCase {
     indexDirBase.close();
   }
 
-  private void assertConsistentYoungestChild(final CategoryPath abPath,
+  private void assertConsistentYoungestChild(final FacetLabel abPath,
       final int abOrd, final int abYoungChildBase1, final int abYoungChildBase2, final int retry, int numCategories)
       throws Exception {
     SlowRAMDirectory indexDir = new SlowRAMDirectory(-1, null); // no slowness for intialization
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);
-    tw.addCategory(new CategoryPath("a", "0"));
+    tw.addCategory(new FacetLabel("a", "0"));
     tw.addCategory(abPath);
     tw.commit();
     
     final DirectoryTaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);
     for (int i = 0; i < numCategories; i++) {
-      final CategoryPath cp = new CategoryPath("a", "b", Integer.toString(i));
+      final FacetLabel cp = new FacetLabel("a", "b", Integer.toString(i));
       tw.addCategory(cp);
       assertEquals("Ordinal of "+cp+" must be invalid until Taxonomy Reader was refreshed", TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(cp));
     }
@@ -840,7 +840,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);
 
     assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)
-    tw.addCategory(new CategoryPath("Author"));
+    tw.addCategory(new FacetLabel("Author"));
     assertEquals(1, tr.getSize()); // still root only...
     assertNull(TaxonomyReader.openIfChanged(tr)); // this is not enough, because tw.commit() hasn't been done yet
     assertEquals(1, tr.getSize()); // still root only...
@@ -864,7 +864,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     // the parent of this category is correct (this requires the reader
     // to correctly update its prefetched parent vector), and that the
     // old information also wasn't ruined:
-    tw.addCategory(new CategoryPath("Author", "Richard Dawkins"));
+    tw.addCategory(new FacetLabel("Author", "Richard Dawkins"));
     int dawkins = 2;
     tw.commit();
     newTaxoReader = TaxonomyReader.openIfChanged(tr);
@@ -889,7 +889,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);
 
     // Test getOrdinal():
-    CategoryPath author = new CategoryPath("Author");
+    FacetLabel author = new FacetLabel("Author");
 
     assertEquals(1, tr.getSize()); // the empty taxonomy has size 1 (the root)
     assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getOrdinal(author));
@@ -924,13 +924,13 @@ public class TestTaxonomyCombined extends FacetTestCase {
     // native fslock impl gets angry if we use it, so use RAMDirectory explicitly.
     Directory indexDir = new RAMDirectory();
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(indexDir);
-    tw.addCategory(new CategoryPath("hi", "there"));
+    tw.addCategory(new FacetLabel("hi", "there"));
     tw.commit();
     // we deliberately not close the write now, and keep it open and
     // locked.
     // Verify that the writer worked:
     TaxonomyReader tr = new DirectoryTaxonomyReader(indexDir);
-    assertEquals(2, tr.getOrdinal(new CategoryPath("hi", "there")));
+    assertEquals(2, tr.getOrdinal(new FacetLabel("hi", "there")));
     // Try to open a second writer, with the first one locking the directory.
     // We expect to get a LockObtainFailedException.
     try {
@@ -943,14 +943,14 @@ public class TestTaxonomyCombined extends FacetTestCase {
     // write to the new writer.
     DirectoryTaxonomyWriter.unlock(indexDir);
     TaxonomyWriter tw2 = new DirectoryTaxonomyWriter(indexDir);
-    tw2.addCategory(new CategoryPath("hey"));
+    tw2.addCategory(new FacetLabel("hey"));
     tw2.close();
     // See that the writer indeed wrote:
     TaxonomyReader newtr = TaxonomyReader.openIfChanged(tr);
     assertNotNull(newtr);
     tr.close();
     tr = newtr;
-    assertEquals(3, tr.getOrdinal(new CategoryPath("hey")));
+    assertEquals(3, tr.getOrdinal(new FacetLabel("hey")));
     tr.close();
     tw.close();
     indexDir.close();
@@ -967,7 +967,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
    */
   public static void fillTaxonomyCheckPaths(TaxonomyWriter tw) throws IOException {
     for (int i = 0; i < categories.length; i++) {
-      int ordinal = tw.addCategory(new CategoryPath(categories[i]));
+      int ordinal = tw.addCategory(new FacetLabel(categories[i]));
       int expectedOrdinal = expectedPaths[i][expectedPaths[i].length-1];
       if (ordinal!=expectedOrdinal) {
         fail("For category "+showcat(categories[i])+" expected ordinal "+
@@ -1052,7 +1052,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);
     TaxonomyReader reader = new DirectoryTaxonomyReader(writer);
     
-    CategoryPath cp = new CategoryPath("a");
+    FacetLabel cp = new FacetLabel("a");
     writer.addCategory(cp);
     TaxonomyReader newReader = TaxonomyReader.openIfChanged(reader);
     assertNotNull("expected a new instance", newReader);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestAddTaxonomy.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestAddTaxonomy.java
index 925e857..c78b8d3 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestAddTaxonomy.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestAddTaxonomy.java
@@ -6,7 +6,7 @@ import java.util.Random;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.DiskOrdinalMap;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
@@ -48,7 +48,7 @@ public class TestAddTaxonomy extends FacetTestCase {
             while (numCats.decrementAndGet() > 0) {
               String cat = Integer.toString(random.nextInt(range));
               try {
-                tw.addCategory(new CategoryPath("a", cat));
+                tw.addCategory(new FacetLabel("a", cat));
               } catch (IOException e) {
                 throw new RuntimeException(e);
               }
@@ -97,7 +97,7 @@ public class TestAddTaxonomy extends FacetTestCase {
         // validate that all source categories exist in destination, and their
         // ordinals are as expected.
         for (int j = 1; j < srcSize; j++) {
-          CategoryPath cp = srcTR.getPath(j);
+          FacetLabel cp = srcTR.getPath(j);
           int destOrdinal = destTR.getOrdinal(cp);
           assertTrue(cp + " not found in destination", destOrdinal > 0);
           assertEquals(destOrdinal, map[j]);
@@ -113,8 +113,8 @@ public class TestAddTaxonomy extends FacetTestCase {
   public void testAddEmpty() throws Exception {
     Directory dest = newDirectory();
     DirectoryTaxonomyWriter destTW = new DirectoryTaxonomyWriter(dest);
-    destTW.addCategory(new CategoryPath("Author", "Rob Pike"));
-    destTW.addCategory(new CategoryPath("Aardvarks", "Bob"));
+    destTW.addCategory(new FacetLabel("Author", "Rob Pike"));
+    destTW.addCategory(new FacetLabel("Aardvarks", "Bob"));
     destTW.commit();
     
     Directory src = newDirectory();
@@ -134,8 +134,8 @@ public class TestAddTaxonomy extends FacetTestCase {
     
     Directory src = newDirectory();
     DirectoryTaxonomyWriter srcTW = new DirectoryTaxonomyWriter(src);
-    srcTW.addCategory(new CategoryPath("Author", "Rob Pike"));
-    srcTW.addCategory(new CategoryPath("Aardvarks", "Bob"));
+    srcTW.addCategory(new FacetLabel("Author", "Rob Pike"));
+    srcTW.addCategory(new FacetLabel("Aardvarks", "Bob"));
     srcTW.close();
     
     DirectoryTaxonomyWriter destTW = new DirectoryTaxonomyWriter(dest);
@@ -168,14 +168,14 @@ public class TestAddTaxonomy extends FacetTestCase {
   public void testSimple() throws Exception {
     Directory dest = newDirectory();
     DirectoryTaxonomyWriter tw1 = new DirectoryTaxonomyWriter(dest);
-    tw1.addCategory(new CategoryPath("Author", "Mark Twain"));
-    tw1.addCategory(new CategoryPath("Animals", "Dog"));
-    tw1.addCategory(new CategoryPath("Author", "Rob Pike"));
+    tw1.addCategory(new FacetLabel("Author", "Mark Twain"));
+    tw1.addCategory(new FacetLabel("Animals", "Dog"));
+    tw1.addCategory(new FacetLabel("Author", "Rob Pike"));
     
     Directory src = newDirectory();
     DirectoryTaxonomyWriter tw2 = new DirectoryTaxonomyWriter(src);
-    tw2.addCategory(new CategoryPath("Author", "Rob Pike"));
-    tw2.addCategory(new CategoryPath("Aardvarks", "Bob"));
+    tw2.addCategory(new FacetLabel("Author", "Rob Pike"));
+    tw2.addCategory(new FacetLabel("Aardvarks", "Bob"));
     tw2.close();
 
     OrdinalMap map = randomOrdinalMap();
@@ -196,7 +196,7 @@ public class TestAddTaxonomy extends FacetTestCase {
     Directory src = newDirectory();
     DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(src);
     for (int i = 0; i < numCategories; i++) {
-      tw.addCategory(new CategoryPath("a", Integer.toString(i)));
+      tw.addCategory(new FacetLabel("a", Integer.toString(i)));
     }
     tw.close();
     
@@ -209,7 +209,7 @@ public class TestAddTaxonomy extends FacetTestCase {
       public void run() {
         for (int i = 0; i < numCategories; i++) {
           try {
-            destTW.addCategory(new CategoryPath("a", Integer.toString(i)));
+            destTW.addCategory(new FacetLabel("a", Integer.toString(i)));
           } catch (IOException e) {
             // shouldn't happen - if it does, let the test fail on uncaught exception.
             throw new RuntimeException(e);
@@ -229,9 +229,9 @@ public class TestAddTaxonomy extends FacetTestCase {
     DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dest);
     // +2 to account for the root category + "a"
     assertEquals(numCategories + 2, dtr.getSize());
-    HashSet<CategoryPath> categories = new HashSet<CategoryPath>();
+    HashSet<FacetLabel> categories = new HashSet<FacetLabel>();
     for (int i = 1; i < dtr.getSize(); i++) {
-      CategoryPath cat = dtr.getPath(i);
+      FacetLabel cat = dtr.getPath(i);
       assertTrue("category " + cat + " already existed", categories.add(cat));
     }
     dtr.close();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
index a5b7658..ea78aea 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
@@ -10,7 +10,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.index.FacetFields;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
 import org.apache.lucene.facet.taxonomy.writercache.cl2o.Cl2oTaxonomyWriterCache;
 import org.apache.lucene.facet.taxonomy.writercache.lru.LruTaxonomyWriterCache;
@@ -46,9 +46,9 @@ public class TestConcurrentFacetedIndexing extends FacetTestCase {
     @Override
     public void close() {}
     @Override
-    public int get(CategoryPath categoryPath) { return -1; }
+    public int get(FacetLabel categoryPath) { return -1; }
     @Override
-    public boolean put(CategoryPath categoryPath, int ordinal) { return true; }
+    public boolean put(FacetLabel categoryPath, int ordinal) { return true; }
     @Override
     public boolean isFull() { return true; }
     @Override
@@ -56,12 +56,12 @@ public class TestConcurrentFacetedIndexing extends FacetTestCase {
     
   };
   
-  static CategoryPath newCategory() {
+  static FacetLabel newCategory() {
     Random r = random();
     String l1 = "l1." + r.nextInt(10); // l1.0-l1.9 (10 categories)
     String l2 = "l2." + r.nextInt(30); // l2.0-l2.29 (30 categories)
     String l3 = "l3." + r.nextInt(100); // l3.0-l3.99 (100 categories)
-    return new CategoryPath(l1, l2, l3);
+    return new FacetLabel(l1, l2, l3);
   }
   
   static TaxonomyWriterCache newTaxoWriterCache(int ndocs) {
@@ -99,9 +99,9 @@ public class TestConcurrentFacetedIndexing extends FacetTestCase {
             try {
               Document doc = new Document();
               int numCats = random.nextInt(3) + 1; // 1-3
-              List<CategoryPath> cats = new ArrayList<CategoryPath>(numCats);
+              List<FacetLabel> cats = new ArrayList<FacetLabel>(numCats);
               while (numCats-- > 0) {
-                CategoryPath cp = newCategory();
+                FacetLabel cp = newCategory();
                 cats.add(cp);
                 // add all prefixes to values
                 int level = cp.length;
@@ -128,11 +128,11 @@ public class TestConcurrentFacetedIndexing extends FacetTestCase {
     assertEquals("mismatch number of categories", values.size() + 1, tr.getSize()); // +1 for root category
     int[] parents = tr.getParallelTaxonomyArrays().parents();
     for (String cat : values.keySet()) {
-      CategoryPath cp = new CategoryPath(cat, '/');
+      FacetLabel cp = new FacetLabel(cat, '/');
       assertTrue("category not found " + cp, tr.getOrdinal(cp) > 0);
       int level = cp.length;
       int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)
-      CategoryPath path = CategoryPath.EMPTY;
+      FacetLabel path = FacetLabel.EMPTY;
       for (int i = 0; i < level; i++) {
         path = cp.subpath(i + 1);
         int ord = tr.getOrdinal(path);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyReader.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyReader.java
index 61e3669..fe5b09c 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyReader.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyReader.java
@@ -8,7 +8,7 @@ import java.util.Set;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader.ChildrenIterator;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -46,7 +46,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
   public void testCloseAfterIncRef() throws Exception {
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter ltw = new DirectoryTaxonomyWriter(dir);
-    ltw.addCategory(new CategoryPath("a"));
+    ltw.addCategory(new FacetLabel("a"));
     ltw.close();
     
     DirectoryTaxonomyReader ltr = new DirectoryTaxonomyReader(dir);
@@ -64,7 +64,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
   public void testCloseTwice() throws Exception {
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter ltw = new DirectoryTaxonomyWriter(dir);
-    ltw.addCategory(new CategoryPath("a"));
+    ltw.addCategory(new FacetLabel("a"));
     ltw.close();
     
     DirectoryTaxonomyReader ltr = new DirectoryTaxonomyReader(dir);
@@ -84,13 +84,13 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
       dir = newDirectory();
       ltw = new DirectoryTaxonomyWriter(dir);
       
-      ltw.addCategory(new CategoryPath("a"));
+      ltw.addCategory(new FacetLabel("a"));
       ltw.commit();
       
       ltr = new DirectoryTaxonomyReader(dir);
       assertNull("Nothing has changed", TaxonomyReader.openIfChanged(ltr));
       
-      ltw.addCategory(new CategoryPath("b"));
+      ltw.addCategory(new FacetLabel("b"));
       ltw.commit();
       
       DirectoryTaxonomyReader newtr = TaxonomyReader.openIfChanged(ltr);
@@ -106,7 +106,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
   public void testAlreadyClosed() throws Exception {
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter ltw = new DirectoryTaxonomyWriter(dir);
-    ltw.addCategory(new CategoryPath("a"));
+    ltw.addCategory(new FacetLabel("a"));
     ltw.close();
     
     DirectoryTaxonomyReader ltr = new DirectoryTaxonomyReader(dir);
@@ -140,16 +140,16 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     
     // prepare a few categories
     int  n = 10;
-    CategoryPath[] cp = new CategoryPath[n];
+    FacetLabel[] cp = new FacetLabel[n];
     for (int i=0; i<n; i++) {
-      cp[i] = new CategoryPath("a", Integer.toString(i));
+      cp[i] = new FacetLabel("a", Integer.toString(i));
     }
     
     try {
       dir = newDirectory();
       
       tw = new DirectoryTaxonomyWriter(dir);
-      tw.addCategory(new CategoryPath("a"));
+      tw.addCategory(new FacetLabel("a"));
       tw.close();
       
       tr = new DirectoryTaxonomyReader(dir);
@@ -183,7 +183,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     Directory dir = new RAMDirectory(); // no need for random directories here
 
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir);
-    taxoWriter.addCategory(new CategoryPath("a"));
+    taxoWriter.addCategory(new FacetLabel("a"));
     taxoWriter.commit();
 
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(dir);
@@ -192,7 +192,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     taxoReader.incRef();
     assertEquals("wrong refCount", 2, taxoReader.getRefCount());
 
-    taxoWriter.addCategory(new CategoryPath("a", "b"));
+    taxoWriter.addCategory(new FacetLabel("a", "b"));
     taxoWriter.commit();
     TaxonomyReader newtr = TaxonomyReader.openIfChanged(taxoReader);
     assertNotNull(newtr);
@@ -226,7 +226,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     for (int i = 0; i < numRounds; i++) {
       int numCats = random().nextInt(4) + 1;
       for (int j = 0; j < numCats; j++) {
-        writer.addCategory(new CategoryPath(Integer.toString(i), Integer.toString(j)));
+        writer.addCategory(new FacetLabel(Integer.toString(i), Integer.toString(j)));
       }
       numCategories += numCats + 1 /* one for round-parent */;
       TaxonomyReader newtr = TaxonomyReader.openIfChanged(reader);
@@ -236,11 +236,11 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
       
       // assert categories
       assertEquals(numCategories, reader.getSize());
-      int roundOrdinal = reader.getOrdinal(new CategoryPath(Integer.toString(i)));
+      int roundOrdinal = reader.getOrdinal(new FacetLabel(Integer.toString(i)));
       int[] parents = reader.getParallelTaxonomyArrays().parents();
       assertEquals(0, parents[roundOrdinal]); // round's parent is root
       for (int j = 0; j < numCats; j++) {
-        int ord = reader.getOrdinal(new CategoryPath(Integer.toString(i), Integer.toString(j)));
+        int ord = reader.getOrdinal(new FacetLabel(Integer.toString(i), Integer.toString(j)));
         assertEquals(roundOrdinal, parents[ord]); // round's parent is root
       }
     }
@@ -276,7 +276,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
 
     // add category and call forceMerge -- this should flush IW and merge segments down to 1
     // in ParentArray.initFromReader, this used to fail assuming there are no parents.
-    writer.addCategory(new CategoryPath("1"));
+    writer.addCategory(new FacetLabel("1"));
     iw.forceMerge(1);
     
     // now calling openIfChanged should trip on the bug
@@ -315,7 +315,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     
     // add a category so that the following DTR open will cause a flush and 
     // a new segment will be created
-    writer.addCategory(new CategoryPath("a"));
+    writer.addCategory(new FacetLabel("a"));
     
     TaxonomyReader reader = new DirectoryTaxonomyReader(writer);
     assertEquals(2, reader.getSize());
@@ -342,7 +342,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     // tests that if the taxonomy is recreated, no data is reused from the previous taxonomy
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);
-    CategoryPath cp_a = new CategoryPath("a");
+    FacetLabel cp_a = new FacetLabel("a");
     writer.addCategory(cp_a);
     writer.close();
     
@@ -353,7 +353,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     
     // now recreate, add a different category
     writer = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE);
-    CategoryPath cp_b = new CategoryPath("b");
+    FacetLabel cp_b = new FacetLabel("b");
     writer.addCategory(cp_b);
     writer.close();
     
@@ -384,7 +384,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
       Directory dir = newDirectory();
       DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);
       
-      CategoryPath cp_a = new CategoryPath("a");
+      FacetLabel cp_a = new FacetLabel("a");
       writer.addCategory(cp_a);
       if (!nrt) writer.commit();
       
@@ -393,7 +393,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
       assertEquals(1, r1.getOrdinal(cp_a));
       assertEquals(cp_a, r1.getPath(1));
       
-      CategoryPath cp_b = new CategoryPath("b");
+      FacetLabel cp_b = new FacetLabel("b");
       writer.addCategory(cp_b);
       if (!nrt) writer.commit();
       
@@ -421,7 +421,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     // only can work with NRT as well
     Directory src = newDirectory();
     DirectoryTaxonomyWriter w = new DirectoryTaxonomyWriter(src);
-    CategoryPath cp_b = new CategoryPath("b");
+    FacetLabel cp_b = new FacetLabel("b");
     w.addCategory(cp_b);
     w.close();
     
@@ -429,7 +429,7 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
       Directory dir = newDirectory();
       DirectoryTaxonomyWriter writer = new DirectoryTaxonomyWriter(dir);
       
-      CategoryPath cp_a = new CategoryPath("a");
+      FacetLabel cp_a = new FacetLabel("a");
       writer.addCategory(cp_a);
       if (!nrt) writer.commit();
       
@@ -474,29 +474,29 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     int numA = 0, numB = 0;
     Random random = random();
     // add the two categories for which we'll also add children (so asserts are simpler)
-    taxoWriter.addCategory(new CategoryPath("a"));
-    taxoWriter.addCategory(new CategoryPath("b"));
+    taxoWriter.addCategory(new FacetLabel("a"));
+    taxoWriter.addCategory(new FacetLabel("b"));
     for (int i = 0; i < numCategories; i++) {
       if (random.nextBoolean()) {
-        taxoWriter.addCategory(new CategoryPath("a", Integer.toString(i)));
+        taxoWriter.addCategory(new FacetLabel("a", Integer.toString(i)));
         ++numA;
       } else {
-        taxoWriter.addCategory(new CategoryPath("b", Integer.toString(i)));
+        taxoWriter.addCategory(new FacetLabel("b", Integer.toString(i)));
         ++numB;
       }
     }
     // add category with no children
-    taxoWriter.addCategory(new CategoryPath("c"));
+    taxoWriter.addCategory(new FacetLabel("c"));
     taxoWriter.close();
     
     DirectoryTaxonomyReader taxoReader = new DirectoryTaxonomyReader(dir);
 
     // non existing category
-    ChildrenIterator it = taxoReader.getChildren(taxoReader.getOrdinal(new CategoryPath("invalid")));
+    ChildrenIterator it = taxoReader.getChildren(taxoReader.getOrdinal(new FacetLabel("invalid")));
     assertEquals(TaxonomyReader.INVALID_ORDINAL, it.next());
 
     // a category with no children
-    it = taxoReader.getChildren(taxoReader.getOrdinal(new CategoryPath("c")));
+    it = taxoReader.getChildren(taxoReader.getOrdinal(new FacetLabel("c")));
     assertEquals(TaxonomyReader.INVALID_ORDINAL, it.next());
 
     // arbitrary negative ordinal
@@ -507,20 +507,20 @@ public class TestDirectoryTaxonomyReader extends FacetTestCase {
     Set<String> roots = new HashSet<String>(Arrays.asList("a", "b", "c"));
     it = taxoReader.getChildren(TaxonomyReader.ROOT_ORDINAL);
     while (!roots.isEmpty()) {
-      CategoryPath root = taxoReader.getPath(it.next());
+      FacetLabel root = taxoReader.getPath(it.next());
       assertEquals(1, root.length);
       assertTrue(roots.remove(root.components[0]));
     }
     assertEquals(TaxonomyReader.INVALID_ORDINAL, it.next());
     
     for (int i = 0; i < 2; i++) {
-      CategoryPath cp = i == 0 ? new CategoryPath("a") : new CategoryPath("b");
+      FacetLabel cp = i == 0 ? new FacetLabel("a") : new FacetLabel("b");
       int ordinal = taxoReader.getOrdinal(cp);
       it = taxoReader.getChildren(ordinal);
       int numChildren = 0;
       int child;
       while ((child = it.next()) != TaxonomyReader.INVALID_ORDINAL) {
-        CategoryPath path = taxoReader.getPath(child);
+        FacetLabel path = taxoReader.getPath(child);
         assertEquals(2, path.length);
         assertEquals(path.components[0], i == 0 ? "a" : "b");
         ++numChildren;
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
index 5bfcb0a..24ee75b 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
@@ -14,7 +14,7 @@ import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.index.FacetFields;
 import org.apache.lucene.facet.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.DrillDownQuery;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
@@ -59,9 +59,9 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     @Override
     public void close() {}
     @Override
-    public int get(CategoryPath categoryPath) { return -1; }
+    public int get(FacetLabel categoryPath) { return -1; }
     @Override
-    public boolean put(CategoryPath categoryPath, int ordinal) { return true; }
+    public boolean put(FacetLabel categoryPath, int ordinal) { return true; }
     @Override
     public boolean isFull() { return true; }
     @Override
@@ -77,7 +77,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     DirectoryTaxonomyWriter ltw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE_OR_APPEND, NO_OP_CACHE);
     assertFalse(DirectoryReader.indexExists(dir));
     ltw.commit(); // first commit, so that an index will be created
-    ltw.addCategory(new CategoryPath("a"));
+    ltw.addCategory(new FacetLabel("a"));
     
     IndexReader r = DirectoryReader.open(dir);
     assertEquals("No categories should have been committed to the underlying directory", 1, r.numDocs());
@@ -91,8 +91,8 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // Verifies taxonomy commit data
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE_OR_APPEND, NO_OP_CACHE);
-    taxoWriter.addCategory(new CategoryPath("a"));
-    taxoWriter.addCategory(new CategoryPath("b"));
+    taxoWriter.addCategory(new FacetLabel("a"));
+    taxoWriter.addCategory(new FacetLabel("b"));
     Map<String, String> userCommitData = new HashMap<String, String>();
     userCommitData.put("testing", "1 2 3");
     taxoWriter.setCommitData(userCommitData);
@@ -109,7 +109,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // in the commit data, otherwise DirTaxoReader.refresh() might not detect
     // that the taxonomy index has been recreated.
     taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE_OR_APPEND, NO_OP_CACHE);
-    taxoWriter.addCategory(new CategoryPath("c")); // add a category so that commit will happen
+    taxoWriter.addCategory(new FacetLabel("c")); // add a category so that commit will happen
     taxoWriter.setCommitData(new HashMap<String, String>(){{
       put("just", "data");
     }});
@@ -133,10 +133,10 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // Verifies that if rollback is called, DTW is closed.
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter dtw = new DirectoryTaxonomyWriter(dir);
-    dtw.addCategory(new CategoryPath("a"));
+    dtw.addCategory(new FacetLabel("a"));
     dtw.rollback();
     try {
-      dtw.addCategory(new CategoryPath("a"));
+      dtw.addCategory(new FacetLabel("a"));
       fail("should not have succeeded to add a category following rollback.");
     } catch (AlreadyClosedException e) {
       // expected
@@ -164,7 +164,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     DirectoryTaxonomyWriter dtw = new DirectoryTaxonomyWriter(dir);
     dtw.close();
     try {
-      dtw.addCategory(new CategoryPath("a"));
+      dtw.addCategory(new FacetLabel("a"));
       fail("should not have succeeded to add a category following close.");
     } catch (AlreadyClosedException e) {
       // expected
@@ -172,7 +172,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     dir.close();
   }
 
-  private void touchTaxo(DirectoryTaxonomyWriter taxoWriter, CategoryPath cp) throws IOException {
+  private void touchTaxo(DirectoryTaxonomyWriter taxoWriter, FacetLabel cp) throws IOException {
     taxoWriter.addCategory(cp);
     taxoWriter.setCommitData(new HashMap<String, String>(){{
       put("just", "data");
@@ -188,11 +188,11 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     Directory dir = newDirectory();
     
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE_OR_APPEND, NO_OP_CACHE);
-    touchTaxo(taxoWriter, new CategoryPath("a"));
+    touchTaxo(taxoWriter, new FacetLabel("a"));
     
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(dir);
 
-    touchTaxo(taxoWriter, new CategoryPath("b"));
+    touchTaxo(taxoWriter, new FacetLabel("b"));
     
     TaxonomyReader newtr = TaxonomyReader.openIfChanged(taxoReader);
     taxoReader.close();
@@ -202,11 +202,11 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // now recreate the taxonomy, and check that the epoch is preserved after opening DirTW again.
     taxoWriter.close();
     taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, NO_OP_CACHE);
-    touchTaxo(taxoWriter, new CategoryPath("c"));
+    touchTaxo(taxoWriter, new FacetLabel("c"));
     taxoWriter.close();
     
     taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE_OR_APPEND, NO_OP_CACHE);
-    touchTaxo(taxoWriter, new CategoryPath("d"));
+    touchTaxo(taxoWriter, new FacetLabel("d"));
     taxoWriter.close();
 
     newtr = TaxonomyReader.openIfChanged(taxoReader);
@@ -267,7 +267,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
           while (numCats.decrementAndGet() > 0) {
             try {
               int value = random.nextInt(range);
-              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),
+              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),
                   Integer.toString(value / 100000), Integer.toString(value));
               int ord = tw.addCategory(cp);
               assertTrue("invalid parent for ordinal " + ord + ", category " + cp, tw.getParent(ord) != -1);
@@ -295,11 +295,11 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     assertEquals("mismatch number of categories", values.size() + 1, dtr.getSize()); // +1 for root category
     int[] parents = dtr.getParallelTaxonomyArrays().parents();
     for (String cat : values.keySet()) {
-      CategoryPath cp = new CategoryPath(cat, '/');
+      FacetLabel cp = new FacetLabel(cat, '/');
       assertTrue("category not found " + cp, dtr.getOrdinal(cp) > 0);
       int level = cp.length;
       int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)
-      CategoryPath path = CategoryPath.EMPTY;
+      FacetLabel path = FacetLabel.EMPTY;
       for (int i = 0; i < level; i++) {
         path = cp.subpath(i + 1);
         int ord = dtr.getOrdinal(path);
@@ -322,13 +322,13 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
   public void testReplaceTaxonomy() throws Exception {
     Directory input = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(input);
-    int ordA = taxoWriter.addCategory(new CategoryPath("a"));
+    int ordA = taxoWriter.addCategory(new FacetLabel("a"));
     taxoWriter.close();
     
     Directory dir = newDirectory();
     taxoWriter = new DirectoryTaxonomyWriter(dir);
-    int ordB = taxoWriter.addCategory(new CategoryPath("b"));
-    taxoWriter.addCategory(new CategoryPath("c"));
+    int ordB = taxoWriter.addCategory(new FacetLabel("b"));
+    taxoWriter.addCategory(new FacetLabel("c"));
     taxoWriter.commit();
     
     long origEpoch = getEpoch(dir);
@@ -339,10 +339,10 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // LUCENE-4633: make sure that category "a" is not added again in any case
     taxoWriter.addTaxonomy(input, new MemoryOrdinalMap());
     assertEquals("no categories should have been added", 2, taxoWriter.getSize()); // root + 'a'
-    assertEquals("category 'a' received new ordinal?", ordA, taxoWriter.addCategory(new CategoryPath("a")));
+    assertEquals("category 'a' received new ordinal?", ordA, taxoWriter.addCategory(new FacetLabel("a")));
 
     // add the same category again -- it should not receive the same ordinal !
-    int newOrdB = taxoWriter.addCategory(new CategoryPath("b"));
+    int newOrdB = taxoWriter.addCategory(new FacetLabel("b"));
     assertNotSame("new ordinal cannot be the original ordinal", ordB, newOrdB);
     assertEquals("ordinal should have been 2 since only one category was added by replaceTaxonomy", 2, newOrdB);
 
@@ -362,8 +362,8 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // is being added.
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, NO_OP_CACHE);
-    int o1 = taxoWriter.addCategory(new CategoryPath("a"));
-    int o2 = taxoWriter.addCategory(new CategoryPath("a"));
+    int o1 = taxoWriter.addCategory(new FacetLabel("a"));
+    int o2 = taxoWriter.addCategory(new FacetLabel("a"));
     assertTrue("ordinal for same category that is added twice should be the same !", o1 == o2);
     taxoWriter.close();
     dir.close();
@@ -374,7 +374,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // LUCENE-4972: DTW used to create empty commits even if no changes were made
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir);
-    taxoWriter.addCategory(new CategoryPath("a"));
+    taxoWriter.addCategory(new FacetLabel("a"));
     taxoWriter.commit();
     
     long gen1 = SegmentInfos.getLastCommitGeneration(dir);
@@ -391,7 +391,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // LUCENE-4972: DTW used to create empty commits even if no changes were made
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir);
-    taxoWriter.addCategory(new CategoryPath("a"));
+    taxoWriter.addCategory(new FacetLabel("a"));
     taxoWriter.commit();
     
     long gen1 = SegmentInfos.getLastCommitGeneration(dir);
@@ -408,7 +408,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // LUCENE-4972: DTW used to create empty commits even if no changes were made
     Directory dir = newDirectory();
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(dir);
-    taxoWriter.addCategory(new CategoryPath("a"));
+    taxoWriter.addCategory(new FacetLabel("a"));
     taxoWriter.prepareCommit();
     taxoWriter.commit();
     
@@ -432,11 +432,11 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // Add one huge label:
     String bigs = null;
     int ordinal = -1;
-    CategoryPath cp = null;
+    FacetLabel cp = null;
     while (true) {
-      int len = CategoryPath.MAX_CATEGORY_PATH_LENGTH - 4; // for the dimension and separator
+      int len = FacetLabel.MAX_CATEGORY_PATH_LENGTH - 4; // for the dimension and separator
       bigs = _TestUtil.randomSimpleString(random(), len, len);
-      cp = new CategoryPath("dim", bigs);
+      cp = new FacetLabel("dim", bigs);
       ordinal = taxoWriter.addCategory(cp);
       Document doc = new Document();
       facetFields.addFields(doc, Collections.singletonList(cp));
@@ -447,9 +447,9 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     // Add tiny ones to cause a re-hash
     for (int i = 0; i < 3; i++) {
       String s = _TestUtil.randomSimpleString(random(), 1, 10);
-      taxoWriter.addCategory(new CategoryPath("dim", s));
+      taxoWriter.addCategory(new FacetLabel("dim", s));
       Document doc = new Document();
-      facetFields.addFields(doc, Collections.singletonList(new CategoryPath("dim", s)));
+      facetFields.addFields(doc, Collections.singletonList(new FacetLabel("dim", s)));
       indexWriter.addDocument(doc);
     }
 
@@ -476,11 +476,11 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
     
     // build source, large, taxonomy
     DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(srcTaxoDir);
-    int ord = taxoWriter.addCategory(new CategoryPath("A/1/1/1/1/1/1", '/'));
+    int ord = taxoWriter.addCategory(new FacetLabel("A/1/1/1/1/1/1", '/'));
     taxoWriter.close();
     
     taxoWriter = new DirectoryTaxonomyWriter(targetTaxoDir);
-    int ordinal = taxoWriter.addCategory(new CategoryPath("B/1", '/'));
+    int ordinal = taxoWriter.addCategory(new FacetLabel("B/1", '/'));
     assertEquals(1, taxoWriter.getParent(ordinal)); // call getParent to initialize taxoArrays
     taxoWriter.commit();
     
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCompactLabelToOrdinal.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCompactLabelToOrdinal.java
index 536fd1f..51b154f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCompactLabelToOrdinal.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/cl2o/TestCompactLabelToOrdinal.java
@@ -9,7 +9,7 @@ import java.util.Map;
 import java.util.Random;
 
 import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util._TestUtil;
 import org.junit.Test;
@@ -82,7 +82,7 @@ public class TestCompactLabelToOrdinal extends FacetTestCase {
       }
 
       int index = random.nextInt(numUniqueValues);
-      CategoryPath label = new CategoryPath(uniqueValues[index], '/');
+      FacetLabel label = new FacetLabel(uniqueValues[index], '/');
 
       int ord1 = map.getOrdinal(label);
       int ord2 = compact.getOrdinal(label);
@@ -97,7 +97,7 @@ public class TestCompactLabelToOrdinal extends FacetTestCase {
     }
 
     for (int i = 0; i < numUniqueValues; i++) {
-      CategoryPath label = new CategoryPath(uniqueValues[i], '/');
+      FacetLabel label = new FacetLabel(uniqueValues[i], '/');
       int ord1 = map.getOrdinal(label);
       int ord2 = compact.getOrdinal(label);
       assertEquals(ord1, ord2);
@@ -105,17 +105,17 @@ public class TestCompactLabelToOrdinal extends FacetTestCase {
   }
 
   private static class LabelToOrdinalMap extends LabelToOrdinal {
-    private Map<CategoryPath, Integer> map = new HashMap<CategoryPath, Integer>();
+    private Map<FacetLabel, Integer> map = new HashMap<FacetLabel, Integer>();
 
     LabelToOrdinalMap() { }
     
     @Override
-    public void addLabel(CategoryPath label, int ordinal) {
+    public void addLabel(FacetLabel label, int ordinal) {
       map.put(label, ordinal);
     }
 
     @Override
-    public int getOrdinal(CategoryPath label) {
+    public int getOrdinal(FacetLabel label) {
       Integer value = map.get(label);
       return (value != null) ? value.intValue() : LabelToOrdinal.INVALID_ORDINAL;
     }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/util/OrdinalMappingReaderTest.java b/lucene/facet/src/test/org/apache/lucene/facet/util/OrdinalMappingReaderTest.java
index 7dea42b..1989e11 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/util/OrdinalMappingReaderTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/util/OrdinalMappingReaderTest.java
@@ -15,7 +15,7 @@ import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
@@ -81,7 +81,7 @@ public class OrdinalMappingReaderTest extends FacetTestCase {
     DirectoryReader reader1 = DirectoryReader.open(dir);
     DirectoryTaxonomyReader taxReader = new DirectoryTaxonomyReader(taxDir);
     IndexSearcher searcher = newSearcher(reader1);
-    FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(new CategoryPath("tag"), NUM_DOCS));
+    FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(new FacetLabel("tag"), NUM_DOCS));
     FacetsCollector collector = FacetsCollector.create(fsp, reader1, taxReader);
     searcher.search(new MatchAllDocsQuery(), collector);
     FacetResult result = collector.getFacetResults().get(0);
@@ -107,10 +107,10 @@ public class OrdinalMappingReaderTest extends FacetTestCase {
     DirectoryTaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(taxDir);
     for (int i = 1; i <= NUM_DOCS; i++) {
       Document doc = new Document();
-      List<CategoryPath> categoryPaths = new ArrayList<CategoryPath>(i + 1);
+      List<FacetLabel> categoryPaths = new ArrayList<FacetLabel>(i + 1);
       for (int j = i; j <= NUM_DOCS; j++) {
         int facetValue = asc? j: NUM_DOCS - j;
-        categoryPaths.add(new CategoryPath("tag", Integer.toString(facetValue)));
+        categoryPaths.add(new FacetLabel("tag", Integer.toString(facetValue)));
       }
       FacetFields facetFields = new FacetFields(taxonomyWriter, fip);
       facetFields.addFields(doc, categoryPaths);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/util/TestFacetsPayloadMigrationReader.java b/lucene/facet/src/test/org/apache/lucene/facet/util/TestFacetsPayloadMigrationReader.java
index 6183be4..c7bb284 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/util/TestFacetsPayloadMigrationReader.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/util/TestFacetsPayloadMigrationReader.java
@@ -36,7 +36,7 @@ import org.apache.lucene.facet.search.FacetRequest;
 import org.apache.lucene.facet.search.FacetResult;
 import org.apache.lucene.facet.search.FacetResultNode;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -159,13 +159,13 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
     for (int i = 0; i < numDocs; i++) {
       Document doc = new Document();
       int numCategories = random.nextInt(3) + 1;
-      ArrayList<CategoryPath> categories = new ArrayList<CategoryPath>(numCategories);
+      ArrayList<FacetLabel> categories = new ArrayList<FacetLabel>(numCategories);
       HashSet<String> docDimensions = new HashSet<String>();
       while (numCategories-- > 0) {
         String dim = DIMENSIONS[random.nextInt(DIMENSIONS.length)];
         // we should only increment the expected count by 1 per document
         docDimensions.add(dim);
-        categories.add(new CategoryPath(dim, Integer.toString(i), Integer.toString(numCategories)));
+        categories.add(new FacetLabel(dim, Integer.toString(i), Integer.toString(numCategories)));
       }
       facetFields.addFields(doc, categories);
       doc.add(new StringField("docid", Integer.toString(i), Store.YES));
@@ -185,7 +185,7 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
       if (random.nextDouble() < 0.2) { // add some documents that will be deleted
         doc = new Document();
         doc.add(new StringField("del", "key", Store.NO));
-        facetFields.addFields(doc, Collections.singletonList(new CategoryPath("dummy")));
+        facetFields.addFields(doc, Collections.singletonList(new FacetLabel("dummy")));
         indexWriter.addDocument(doc);
       }
     }
@@ -264,7 +264,7 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
     // run faceted search and assert expected counts
     ArrayList<FacetRequest> requests = new ArrayList<FacetRequest>(expectedCounts.size());
     for (String dim : expectedCounts.keySet()) {
-      requests.add(new CountFacetRequest(new CategoryPath(dim), 5));
+      requests.add(new CountFacetRequest(new FacetLabel(dim), 5));
     }
     FacetSearchParams fsp = new FacetSearchParams(fip, requests);
     FacetsCollector fc = FacetsCollector.create(fsp, indexReader, taxoReader);
@@ -283,7 +283,7 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
       TaxonomyReader taxoReader, IndexSearcher searcher) throws IOException {
     // verify drill-down
     for (String dim : expectedCounts.keySet()) {
-      CategoryPath drillDownCP = new CategoryPath(dim);
+      FacetLabel drillDownCP = new FacetLabel(dim);
       FacetSearchParams fsp = new FacetSearchParams(fip, new CountFacetRequest(drillDownCP, 10));
       DrillDownQuery drillDown = new DrillDownQuery(fip, new MatchAllDocsQuery());
       drillDown.add(drillDownCP);
@@ -322,7 +322,7 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
     }
     foundOrdinals[0] = true; // ROOT ordinals isn't indexed
     // mark 'dummy' category ordinal as seen
-    int dummyOrdinal = taxoReader.getOrdinal(new CategoryPath("dummy"));
+    int dummyOrdinal = taxoReader.getOrdinal(new FacetLabel("dummy"));
     if (dummyOrdinal > 0) {
       foundOrdinals[dummyOrdinal] = true;
     }
@@ -331,7 +331,7 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
     int numPartitions = (int) Math.ceil(taxoReader.getSize() / (double) partitionSize);
     final IntsRef ordinals = new IntsRef(32);
     for (String dim : DIMENSIONS) {
-      CategoryListParams clp = fip.getCategoryListParams(new CategoryPath(dim));
+      CategoryListParams clp = fip.getCategoryListParams(new FacetLabel(dim));
       int partitionOffset = 0;
       for (int partition = 0; partition < numPartitions; partition++, partitionOffset += partitionSize) {
         final CategoryListIterator cli = clp.createCategoryListIterator(partition);
@@ -368,14 +368,14 @@ public class TestFacetsPayloadMigrationReader extends FacetTestCase {
     Directory taxoDir = newDirectory();
     
     // set custom CLP fields for two dimensions and use the default ($facets) for the other two
-    HashMap<CategoryPath,CategoryListParams> params = new HashMap<CategoryPath,CategoryListParams>();
-    params.put(new CategoryPath(DIMENSIONS[0]), new CategoryListParams(DIMENSIONS[0]) {
+    HashMap<FacetLabel,CategoryListParams> params = new HashMap<FacetLabel,CategoryListParams>();
+    params.put(new FacetLabel(DIMENSIONS[0]), new CategoryListParams(DIMENSIONS[0]) {
       @Override
       public OrdinalPolicy getOrdinalPolicy(String dimension) {
         return OrdinalPolicy.ALL_PARENTS;
       }
     });
-    params.put(new CategoryPath(DIMENSIONS[1]), new CategoryListParams(DIMENSIONS[1]) {
+    params.put(new FacetLabel(DIMENSIONS[1]), new CategoryListParams(DIMENSIONS[1]) {
       @Override
       public OrdinalPolicy getOrdinalPolicy(String dimension) {
         return OrdinalPolicy.ALL_PARENTS;
diff --git a/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest.java b/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest.java
index 587f7c6..b3758a5 100644
--- a/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest.java
+++ b/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest.java
@@ -32,7 +32,7 @@ import org.apache.lucene.facet.params.FacetSearchParams;
 import org.apache.lucene.facet.search.CountFacetRequest;
 import org.apache.lucene.facet.search.DrillDownQuery;
 import org.apache.lucene.facet.search.FacetsCollector;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -102,7 +102,7 @@ public class IndexAndTaxonomyReplicationClientTest extends ReplicatorTestCase {
         
         // verify faceted search
         int id = Integer.parseInt(indexReader.getIndexCommit().getUserData().get(VERSION_ID), 16);
-        CategoryPath cp = new CategoryPath("A", Integer.toString(id, 16));
+        FacetLabel cp = new FacetLabel("A", Integer.toString(id, 16));
         IndexSearcher searcher = new IndexSearcher(indexReader);
         FacetsCollector fc = FacetsCollector.create(new FacetSearchParams(new CountFacetRequest(cp, 10)), indexReader, taxoReader);
         searcher.search(new MatchAllDocsQuery(), fc);
@@ -178,7 +178,7 @@ public class IndexAndTaxonomyReplicationClientTest extends ReplicatorTestCase {
   private Document newDocument(TaxonomyWriter taxoWriter, int id) throws IOException {
     Document doc = new Document();
     FacetFields facetFields = new FacetFields(taxoWriter);
-    facetFields.addFields(doc, Collections.singleton(new CategoryPath("A", Integer.toString(id, 16))));
+    facetFields.addFields(doc, Collections.singleton(new FacetLabel("A", Integer.toString(id, 16))));
     return doc;
   }
   
diff --git a/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyRevisionTest.java b/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyRevisionTest.java
index 059b8bd..2c3b227 100644
--- a/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyRevisionTest.java
+++ b/lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyRevisionTest.java
@@ -26,7 +26,7 @@ import java.util.Map.Entry;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.facet.index.FacetFields;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.IndexWriter;
@@ -44,7 +44,7 @@ public class IndexAndTaxonomyRevisionTest extends ReplicatorTestCase {
   private Document newDocument(TaxonomyWriter taxoWriter) throws IOException {
     Document doc = new Document();
     FacetFields ff = new FacetFields(taxoWriter);
-    ff.addFields(doc, Collections.singleton(new CategoryPath("A")));
+    ff.addFields(doc, Collections.singleton(new FacetLabel("A")));
     return doc;
   }
   

