GitDiffStart: b3f2ad655f09ccbad3f30d6ae4463b27819d1ae0 | Wed Feb 29 05:17:39 2012 +0000
diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index 92a0ce6..425e056 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -53,11 +53,10 @@
 	<classpathentry kind="src" path="modules/queryparser/src/test"/>
 	<classpathentry kind="src" path="modules/suggest/src/java"/>
 	<classpathentry kind="src" path="modules/suggest/src/test"/>
-	<classpathentry kind="src" path="modules/spatial/base/src/java"/>
-	<classpathentry kind="src" path="modules/spatial/base/src/test"/>
-	<classpathentry kind="src" path="modules/spatial/strategy/src/java"/>
-	<classpathentry kind="src" path="modules/spatial/strategy/src/test"/>
-	<classpathentry kind="src" path="modules/spatial/strategy/src/test-files"/>
+	<classpathentry kind="src" path="modules/spatial/src/java"/>
+	<classpathentry kind="src" path="modules/spatial/src/test"/>
+	<classpathentry kind="src" path="modules/spatial/src/test-files"/>
+	<classpathentry kind="lib" path="modules/spatial/lib/spatial4j-0.1.jar"/>
 	<classpathentry kind="src" path="solr/core/src/java"/>
 	<classpathentry kind="src" path="solr/core/src/test"/>
 	<classpathentry kind="src" path="solr/core/src/test-files"/>
diff --git a/lucene/contrib/contrib-build.xml b/lucene/contrib/contrib-build.xml
index 659618a..a9b0b70 100644
--- a/lucene/contrib/contrib-build.xml
+++ b/lucene/contrib/contrib-build.xml
@@ -228,26 +228,15 @@
     <property name="sandbox.uptodate" value="true"/>
   </target>
 
-  <property name="spatial-base.jar" value="${common.dir}/../modules/spatial/build/base/lucene-spatial-base-${version}.jar"/>
-  <target name="check-spatial-base-uptodate" unless="spatial-base.uptodate">
-    <module-uptodate name="spatial/base" jarfile="${spatial-base.jar}" property="spatial-base.uptodate"/>
+  <property name="spatial.jar" value="${common.dir}/../modules/spatial/build/lucene-spatial-${version}.jar"/>
+  <target name="check-spatial-uptodate" unless="spatial.uptodate">
+    <module-uptodate name="spatial" jarfile="${spatial.jar}" property="spatial.uptodate"/>
   </target>
-  <target name="jar-spatial-base" unless="spatial-base.uptodate" depends="check-spatial-base-uptodate">
-  	<ant dir="${common.dir}/../modules/spatial/base" target="jar-core" inheritAll="false">
+  <target name="jar-spatial" unless="spatial.uptodate" depends="check-spatial-uptodate">
+  	<ant dir="${common.dir}/../modules/spatial" target="jar-core" inheritAll="false">
       <propertyset refid="uptodate.and.compiled.properties"/>
     </ant>
-    <property name="spatial-base.uptodate" value="true"/>
-  </target>
-
-  <property name="spatial-strategy.jar" value="${common.dir}/../modules/spatial/build/strategy/lucene-spatial-strategy-${version}.jar"/>
-  <target name="check-spatial-strategy-uptodate" unless="spatial-strategy.uptodate">
-    <module-uptodate name="spatial/strategy" jarfile="${spatial-strategy.jar}" property="spatial-strategy.uptodate"/>
-  </target>
-  <target name="jar-spatial-strategy" unless="spatial-strategy.uptodate" depends="check-spatial-strategy-uptodate">
-    <ant dir="${common.dir}/../modules/spatial/strategy" target="jar-core" inheritAll="false">
-      <propertyset refid="uptodate.and.compiled.properties"/>
-    </ant>
-    <property name="spatial-strategy.uptodate" value="true"/>
+    <property name="spatial.uptodate" value="true"/>
   </target>
 
   <property name="suggest.jar" value="${common.dir}/../modules/suggest/build/lucene-suggest-${version}.jar"/>
diff --git a/modules/spatial/base/build.xml b/modules/spatial/base/build.xml
deleted file mode 100644
index b5556e6..0000000
--- a/modules/spatial/base/build.xml
+++ /dev/null
@@ -1,46 +0,0 @@
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-
-<project name="spatial-base" default="default">
-  <description>
-    Spatial API without lucene dependencies
-  </description>
-
-  <property name="build.dir" location="../build/base" />
-  <property name="dist.dir" location="../dist/base" />
-  <property name="maven.dist.dir" location="../../dist/maven"/>
-
-  <path id="additional.dependencies">
-    <fileset dir="lib" includes="*.jar"/>
-  </path>
-  <pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
-
-  <import file="../../../lucene/contrib/contrib-build.xml"/>
-
-  <path id="classpath">
-    <path refid="base.classpath"/>
-  </path>
-
-  <path id="test.classpath">
-    <path refid="test.base.classpath" />
-  </path>
-
-  <target name="dist-maven" depends="jar-core,javadocs,common.dist-maven"/>
-  <target name="compile" depends="jar-queries,common.compile-core" />
-  <target name="test" depends="jar-analyzers-common,compile-test,validate,junit-mkdir,junit-sequential,junit-parallel" description="Runs unit tests"/>
-
-</project>
\ No newline at end of file
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
deleted file mode 100644
index c6ab3bf..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/ParseUtils.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-
-/**
- * Utility methods related to parsing shapes.
- * Methods here were formerly in DistanceUtils.
- */
-public class ParseUtils {
-  private ParseUtils() {
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidShapeException {
-    //TODO: Should we support sparse vectors?
-    if (out == null || out.length != dimension) out = new String[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = externalVal.trim();
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = externalVal.substring(start, end);
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidShapeException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidShapeException{
-    if (out == null || out.length != dimension) out = new double[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = Double.parseDouble(externalVal.trim());
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        //TODO: abstract common code with other parsePoint
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = Double.parseDouble(externalVal.substring(start, end));
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidShapeException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidShapeException {
-    return parseLatitudeLongitude(null, latLonStr);
-  }
-
-  /**
-   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
-   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
-   * <p/>
-   * The latitude is assumed to be the first part of the string and the longitude the second part.
-   *
-   * @param latLon    A preallocated array to hold the result
-   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
-   * @return The lat long
-   * @throws org.apache.lucene.spatial.base.exception.InvalidShapeException if there was an error parsing
-   */
-  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidShapeException {
-    if (latLon == null) {
-      latLon = new double[2];
-    }
-    double[] toks = parsePointDouble(null, latLonStr, 2);
-
-    if (toks[0] < -90.0 || toks[0] > 90.0) {
-      throw new InvalidShapeException(
-              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
-                      + toks[0] + "]");
-    }
-    latLon[0] = toks[0];
-
-
-    if (toks[1] < -180.0 || toks[1] > 180.0) {
-
-      throw new InvalidShapeException(
-              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
-                      + toks[1] + "]");
-    }
-    latLon[1] = toks[1];
-
-    return latLon;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
deleted file mode 100644
index 13ef61c..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContext.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.distance.*;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.shape.Circle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-
-import java.text.NumberFormat;
-import java.util.Locale;
-import java.util.StringTokenizer;
-
-/**
- * This holds things like distance units, distance calculator, and world bounds.
- * Threadsafe & immutable.
- */
-public abstract class SpatialContext {
-
-  //These are non-null
-  private final DistanceUnits units;
-  private final DistanceCalculator calculator;
-  private final Rectangle worldBounds;
-
-  public static RectangleImpl GEO_WORLDBOUNDS = new RectangleImpl(-180,180,-90,90);
-  public static RectangleImpl MAX_WORLDBOUNDS;
-  static {
-    double v = Double.MAX_VALUE;
-    MAX_WORLDBOUNDS = new RectangleImpl(-v, v, -v, v);
-  }
-  
-  protected final Double maxCircleDistance;//only for geo
-  protected final boolean NUDGE = false;//TODO document
-
-  /**
-   *
-   * @param units Required; and establishes geo vs cartesian.
-   * @param calculator Optional; defaults to Haversine or cartesian depending on units.
-   * @param worldBounds Optional; defaults to GEO_WORLDBOUNDS or MAX_WORLDBOUNDS depending on units.
-   */
-  protected SpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
-    if (units == null)
-      throw new IllegalArgumentException("units can't be null");
-    this.units = units;
-
-    if (calculator == null) {
-      calculator = isGeo()
-          ? new GeodesicSphereDistCalc.Haversine(units.earthRadius())
-          : new CartesianDistCalc();
-    }
-    this.calculator = calculator;
-
-    if (worldBounds == null) {
-      worldBounds = isGeo() ? GEO_WORLDBOUNDS : MAX_WORLDBOUNDS;
-    } else {
-      if (isGeo())
-        assert new RectangleImpl(worldBounds).equals(GEO_WORLDBOUNDS);
-      if (worldBounds.getCrossesDateLine())
-        throw new IllegalArgumentException("worldBounds shouldn't cross dateline: "+worldBounds);
-    }
-    //copy so we can ensure we have the right implementation
-    worldBounds = makeRect(worldBounds.getMinX(),worldBounds.getMaxX(),worldBounds.getMinY(),worldBounds.getMaxY());
-    this.worldBounds = worldBounds;
-    
-    this.maxCircleDistance = isGeo() ? calculator.degreesToDistance(180) : null;
-  }
-
-  public DistanceUnits getUnits() {
-    return units;
-  }
-
-  public DistanceCalculator getDistCalc() {
-    return calculator;
-  }
-
-  public Rectangle getWorldBounds() {
-    return worldBounds;
-  }
-
-  public double normX(double x) {
-    if (isGeo()) {
-      return DistanceUtils.normLonDEG(x);
-    } else {
-      return x;
-    }
-  }
-
-  public double normY(double y) {
-    if (isGeo()) {
-      y = DistanceUtils.normLatDEG(y);
-    }
-    return y;
-  }
-
-  /**
-   * Is this a geospatial context (true) or simply 2d spatial (false)
-   */
-  public boolean isGeo() {
-    return getUnits().isGeo();
-  }
-
-  /**
-   * Read a shape from a given string (ie, X Y, XMin XMax... WKT)
-   *
-   * (1) Point: X Y
-   *   1.23 4.56
-   *
-   * (2) BOX: XMin YMin XMax YMax
-   *   1.23 4.56 7.87 4.56
-   *
-   * (3) WKT
-   *   POLYGON( ... )
-   *   http://en.wikipedia.org/wiki/Well-known_text
-   *
-   */
-  public abstract Shape readShape(String value) throws InvalidShapeException;
-
-  public Point readLatCommaLonPoint(String value) throws InvalidShapeException {
-    double[] latLon = ParseUtils.parseLatitudeLongitude(value);
-    return makePoint(latLon[1],latLon[0]);
-  }
-
-  public abstract String toString(Shape shape);
-
-  /** Construct a point. The parameters will be normalized. */
-  public abstract Point makePoint( double x, double y );
-
-  /** Construct a rectangle. The parameters will be normalized. */
-  public abstract Rectangle makeRect(double minX, double maxX, double minY, double maxY);
-
-  /** Construct a circle. The parameters will be normalized. */
-  public Circle makeCircle(double x, double y, double distance) {
-    return makeCircle(makePoint(x,y),distance);
-  }
-
-  /**
-   *
-   * @param ctr
-   * @param distance The units of "distance" should be the same as {@link #getUnits()}.
-   */
-  public abstract Circle makeCircle(Point ctr, double distance);
-
-  protected Shape readStandardShape(String str) {
-    if (str.length() < 1) {
-      throw new InvalidShapeException(str);
-    }
-
-    if(Character.isLetter(str.charAt(0))) {
-      if( str.startsWith( "Circle(" ) ) {
-        int idx = str.lastIndexOf( ')' );
-        if( idx > 0 ) {
-          String body = str.substring( "Circle(".length(), idx );
-          StringTokenizer st = new StringTokenizer(body, " ");
-          String token = st.nextToken();
-          Point pt;
-          if (token.indexOf(',') != -1) {
-            pt = readLatCommaLonPoint(token);
-          } else {
-            double x = Double.parseDouble(token);
-            double y = Double.parseDouble(st.nextToken());
-            pt = makePoint(x,y);
-          }
-          Double d = null;
-
-          String arg = st.nextToken();
-          idx = arg.indexOf( '=' );
-          if( idx > 0 ) {
-            String k = arg.substring( 0,idx );
-            if( k.equals( "d" ) || k.equals( "distance" ) ) {
-              d = Double.parseDouble( arg.substring(idx+1));
-            }
-            else {
-              throw new InvalidShapeException( "unknown arg: "+k+" :: " +str );
-            }
-          }
-          else {
-            d = Double.parseDouble(arg);
-          }
-          if( st.hasMoreTokens() ) {
-            throw new InvalidShapeException( "Extra arguments: "+st.nextToken()+" :: " +str );
-          }
-          if( d == null ) {
-            throw new InvalidShapeException( "Missing Distance: "+str );
-          }
-          //NOTE: we are assuming the units of 'd' is the same as that of the spatial context.
-          return makeCircle(pt, d);
-        }
-      }
-      return null;
-    }
-
-    if (str.indexOf(',') != -1)
-      return readLatCommaLonPoint(str);
-    StringTokenizer st = new StringTokenizer(str, " ");
-    double p0 = Double.parseDouble(st.nextToken());
-    double p1 = Double.parseDouble(st.nextToken());
-    if (st.hasMoreTokens()) {
-      double p2 = Double.parseDouble(st.nextToken());
-      double p3 = Double.parseDouble(st.nextToken());
-      if (st.hasMoreTokens())
-        throw new InvalidShapeException("Only 4 numbers supported (rect) but found more: "+str);
-      return makeRect(p0, p2, p1, p3);
-    }
-    return makePoint(p0, p1);
-  }
-
-  public String writeRect(Rectangle rect) {
-    NumberFormat nf = NumberFormat.getInstance(Locale.US);
-    nf.setGroupingUsed(false);
-    nf.setMaximumFractionDigits(6);
-    nf.setMinimumFractionDigits(6);
-
-    return
-      nf.format(rect.getMinX()) + " " +
-      nf.format(rect.getMinY()) + " " +
-      nf.format(rect.getMaxX()) + " " +
-      nf.format(rect.getMaxY());
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName()+"{" +
-        "units=" + units +
-        ", calculator=" + calculator +
-        ", worldBounds=" + worldBounds +
-        '}';
-  }
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
deleted file mode 100644
index 7862bed..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/SpatialContextFactory.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContextFactory;
-import org.apache.lucene.spatial.base.distance.*;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import java.util.Map;
-
-/**
- * Factory for a SpatialContext.
- */
-public abstract class SpatialContextFactory {
-  protected Map<String, String> args;
-  protected ClassLoader classLoader;
-  
-  protected DistanceUnits units;
-  protected DistanceCalculator calculator;
-  protected Rectangle worldBounds;
-
-  /**
-   * The factory class is lookuped up via "spatialContextFactory" in args
-   * then falling back to a Java system property (with initial caps). If neither are specified
-   * then {@link SimpleSpatialContextFactory} is chosen.
-   * @param args
-   * @param classLoader
-   */
-  public static SpatialContext makeSpatialContext(Map<String,String> args, ClassLoader classLoader) {
-    SpatialContextFactory instance;
-    String cname = args.get("spatialContextFactory");
-    if (cname == null)
-      cname = System.getProperty("SpatialContextFactory");
-    if (cname == null)
-      instance = new SimpleSpatialContextFactory();
-    else {
-      try {
-        Class c = classLoader.loadClass(cname);
-        instance = (SpatialContextFactory) c.newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    instance.init(args,classLoader);
-    return instance.newSpatialContext();
-  }
-
-  protected void init(Map<String, String> args, ClassLoader classLoader) {
-    this.args = args;
-    this.classLoader = classLoader;
-    initUnits();
-    initCalculator();
-    initWorldBounds();
-  }
-
-  protected void initUnits() {
-    String unitsStr = args.get("units");
-    if (unitsStr != null)
-      units = DistanceUnits.findDistanceUnit(unitsStr);
-    if (units == null)
-      units = DistanceUnits.KILOMETERS;
-  }
-
-  protected void initCalculator() {
-    String calcStr = args.get("distCalculator");
-    if (calcStr == null)
-      return;
-    if (calcStr.equalsIgnoreCase("haversine")) {
-      calculator = new GeodesicSphereDistCalc.Haversine(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("lawOfCosines")) {
-      calculator = new GeodesicSphereDistCalc.LawOfCosines(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("vincentySphere")) {
-      calculator = new GeodesicSphereDistCalc.Vincenty(units.earthRadius());
-    } else if (calcStr.equalsIgnoreCase("cartesian")) {
-      calculator = new CartesianDistCalc();
-    } else if (calcStr.equalsIgnoreCase("cartesian^2")) {
-      calculator = new CartesianDistCalc(true);
-    } else {
-      throw new RuntimeException("Unknown calculator: "+calcStr);
-    }
-  }
-
-  protected void initWorldBounds() {
-    String worldBoundsStr = args.get("worldBounds");
-    if (worldBoundsStr == null)
-      return;
-    //kinda ugly we do this just to read a rectangle.  TODO refactor
-    SimpleSpatialContext simpleCtx = new SimpleSpatialContext(units, calculator, null);
-    worldBounds = (Rectangle) simpleCtx.readShape(worldBoundsStr);
-  }
-
-  /** Subclasses should simply construct the instance from the initialized configuration. */
-  protected abstract SpatialContext newSpatialContext();
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
deleted file mode 100644
index 413eae1..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContext.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.shape.Circle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.CircleImpl;
-import org.apache.lucene.spatial.base.shape.simple.GeoCircleImpl;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-
-import java.text.NumberFormat;
-import java.util.Locale;
-
-public class SimpleSpatialContext extends SpatialContext {
-
-  public static SimpleSpatialContext GEO_KM = new SimpleSpatialContext(DistanceUnits.KILOMETERS);
-
-  public SimpleSpatialContext(DistanceUnits units) {
-    this(units, null, null);
-  }
-
-  public SimpleSpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
-    super(units, calculator, worldBounds);
-  }
-
-  @Override
-  public Shape readShape(String value) throws InvalidShapeException {
-    Shape s = super.readStandardShape( value );
-    if( s == null ) {
-      throw new InvalidShapeException( "Unable to read: "+value );
-    }
-    return s;
-  }
-
-  @Override
-  public String toString(Shape shape) {
-    if (Point.class.isInstance(shape)) {
-      NumberFormat nf = NumberFormat.getInstance(Locale.US);
-      nf.setGroupingUsed(false);
-      nf.setMaximumFractionDigits(6);
-      nf.setMinimumFractionDigits(6);
-      Point point = (Point) shape;
-      return nf.format(point.getX()) + " " + nf.format(point.getY());
-    } else if (Rectangle.class.isInstance(shape)) {
-      return writeRect((Rectangle) shape);
-    }
-    return shape.toString();
-  }
-
-  @Override
-  public Circle makeCircle(Point point, double distance) {
-    if (distance < 0)
-      throw new InvalidShapeException("distance must be >= 0; got "+distance);
-    if (isGeo())
-      return new GeoCircleImpl( point, Math.min(distance,maxCircleDistance), this );
-    else
-      return new CircleImpl( point, distance, this );
-  }
-
-  @Override
-  public Rectangle makeRect(double minX, double maxX, double minY, double maxY) {
-    //--Normalize parameters
-    if (isGeo()) {
-      double delta = calcWidth(minX,maxX);
-      if (delta >= 360) {
-        //The only way to officially support complete longitude wrap-around is via western longitude = -180. We can't
-        // support any point because 0 is undifferentiated in sign.
-        minX = -180;
-        maxX = 180;
-      } else {
-        minX = normX(minX);
-        maxX = normX(maxX);
-        assert Math.abs(delta - calcWidth(minX,maxX)) < 0.0001;//recompute delta; should be the same
-      }
-      if (minY > maxY) {
-        throw new IllegalArgumentException("maxY must be >= minY");
-      }
-      if (minY < -90 || minY > 90 || maxY < -90 || maxY > 90)
-        throw new IllegalArgumentException("minY or maxY is outside of -90 to 90 bounds. What did you mean?");
-//      debatable what to do in this situation.
-//      if (minY < -90) {
-//        minX = -180;
-//        maxX = 180;
-//        maxY = Math.min(90,Math.max(maxY,-90 + (-90 - minY)));
-//        minY = -90;
-//      }
-//      if (maxY > 90) {
-//        minX = -180;
-//        maxX = 180;
-//        minY = Math.max(-90,Math.min(minY,90 - (maxY - 90)));
-//        maxY = 90;
-//      }
-
-    } else {
-      //these normalizations probably won't do anything since it's not geo but should probably call them any way.
-      minX = normX(minX);
-      maxX = normX(maxX);
-      minY = normY(minY);
-      maxY = normY(maxY);
-    }
-    return new RectangleImpl( minX, maxX, minY, maxY );
-  }
-
-  private double calcWidth(double minX,double maxX) {
-    double w = maxX - minX;
-    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
-      w += 360;
-      assert w >= 0;
-    }
-    return w;
-  }
-
-  @Override
-  public Point makePoint(double x, double y) {
-    return new PointImpl(normX(x),normY(y));
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
deleted file mode 100644
index 850b158..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/context/simple/SimpleSpatialContextFactory.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.SpatialContextFactory;
-
-
-public class SimpleSpatialContextFactory extends SpatialContextFactory {
-  @Override
-  protected SpatialContext newSpatialContext() {
-    return new SimpleSpatialContext(units,calculator,worldBounds);
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
deleted file mode 100644
index c71c581..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/AbstractDistanceCalculator.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.shape.Point;
-
-
-public abstract class AbstractDistanceCalculator implements DistanceCalculator {
-
-  @Override
-  public double distance(Point from, Point to) {
-    return distance(from, to.getX(), to.getY());
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName();
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
deleted file mode 100644
index 853eba7..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/CartesianDistCalc.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-public class CartesianDistCalc extends AbstractDistanceCalculator {
-
-  private final boolean squared;
-
-  public CartesianDistCalc() {
-    this.squared = false;
-  }
-
-  public CartesianDistCalc(boolean squared) {
-    this.squared = squared;
-  }
-
-  @Override
-  public double distance(Point from, double toX, double toY) {
-    double result = 0;
-
-    double v = from.getX() - toX;
-    result += (v * v);
-
-    v = from.getY() - toY;
-    result += (v * v);
-
-    if( squared )
-      return result;
-
-    return Math.sqrt(result);
-  }
-
-  @Override
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
-    if (dist == 0)
-      return from;
-    double bearingRAD = Math.toDegrees(bearingDEG);
-    double x = Math.sin(bearingRAD) * dist;
-    double y = Math.cos(bearingRAD) * dist;
-    return ctx.makePoint(from.getX()+x, from.getY()+y);
-  }
-
-  @Override
-  public double distanceToDegrees(double distance) {
-    throw new UnsupportedOperationException("no geo!");
-  }
-
-  @Override
-  public double degreesToDistance(double degrees) {
-    throw new UnsupportedOperationException("no geo!");
-  }
-
-  @Override
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
-    return ctx.makeRect(from.getX()-distance,from.getX()+distance,from.getY()-distance,from.getY()+distance);
-  }
-
-  @Override
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
-    return from.getY();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    CartesianDistCalc that = (CartesianDistCalc) o;
-
-    if (squared != that.squared) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    return (squared ? 1 : 0);
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
deleted file mode 100644
index d6cdb92..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceCalculator.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-public interface DistanceCalculator {
-
-  public double distance(Point from, Point to);
-  public double distance(Point from, double toX, double toY);
-
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx);
-  
-  /**
-   * Converts a distance to radians (multiples of the radius). A spherical
-   * earth model is assumed for geospatial, and non-geospatial is the identity function.
-   */
-  public double distanceToDegrees(double distance);
-
-  public double degreesToDistance(double degrees);
-
-  //public Point pointOnBearing(Point from, double angle);
-
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx);
-
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx);
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
deleted file mode 100644
index 8540b27..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUnits.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-/**
- * Enum representing difference distance units, currently only kilometers and
- * miles
- */
-public enum DistanceUnits {
-
-  //TODO do we need circumference?
-  KILOMETERS("km", DistanceUtils.EARTH_MEAN_RADIUS_KM, 40076),
-  MILES("miles", DistanceUtils.EARTH_MEAN_RADIUS_MI, 24902),
-  RADIANS("radians", 1, Math.PI * 2),//experimental
-  CARTESIAN("u", -1, -1);
-
-
-  private final String units;
-
-  private final double earthCircumference;
-
-  private final double earthRadius;
-
-  /**
-   * Creates a new DistanceUnit that represents the given unit
-   *
-   * @param units Distance unit in String form
-   * @param earthRadius Radius of the Earth in the specific distance unit
-   * @param earthCircumfence Circumference of the Earth in the specific distance unit
-   */
-  DistanceUnits(String units, double earthRadius, double earthCircumfence) {
-    this.units = units;
-    this.earthCircumference = earthCircumfence;
-    this.earthRadius = earthRadius;
-  }
-
-  /**
-   * Returns the DistanceUnit which represents the given unit
-   *
-   * @param unit Unit whose DistanceUnit should be found
-   * @return DistanceUnit representing the unit
-   * @throws IllegalArgumentException if no DistanceUnit which represents the given unit is found
-   */
-  public static DistanceUnits findDistanceUnit(String unit) {
-    if (MILES.getUnits().equalsIgnoreCase(unit) || unit.equalsIgnoreCase("mi")) {
-      return MILES;
-    }
-    if (KILOMETERS.getUnits().equalsIgnoreCase(unit)) {
-      return KILOMETERS;
-    }
-    if (CARTESIAN.getUnits().equalsIgnoreCase(unit) || unit.length()==0) {
-      return CARTESIAN;
-    }
-    throw new IllegalArgumentException("Unknown distance unit " + unit);
-  }
-
-  /**
-   * Converts the given distance in given DistanceUnit, to a distance in the unit represented by {@code this}
-   *
-   * @param distance Distance to convert
-   * @param from Unit to convert the distance from
-   * @return Given distance converted to the distance in the given unit
-   */
-  public double convert(double distance, DistanceUnits from) {
-    if (from == this) {
-      return distance;
-    }
-    if (this == CARTESIAN || from == CARTESIAN) {
-      throw new IllegalStateException("Can't convert cartesian distances: "+from+" -> "+this);
-    }
-    return (this == MILES) ? distance * DistanceUtils.KM_TO_MILES : distance * DistanceUtils.MILES_TO_KM;
-  }
-
-  /**
-   * Returns the string representation of the distance unit
-   *
-   * @return String representation of the distance unit
-   */
-  public String getUnits() {
-    return units;
-  }
-
-  /**
-   * Returns the <a href="http://en.wikipedia.org/wiki/Earth_radius">average earth radius</a>
-   *
-   * @return the average earth radius
-   */
-  public double earthRadius() {
-    return earthRadius;
-  }
-
-  /**
-   * Returns the <a href="http://www.lyberty.com/encyc/articles/earth.html">circumference of the Earth</a>
-   *
-   * @return  the circumference of the Earth
-   */
-  public double earthCircumference() {
-    return earthCircumference;
-  }
-  
-  public boolean isGeo() {
-    return earthRadius > 0;
-  }
-}
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
deleted file mode 100644
index 8b46f39..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/DistanceUtils.java
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import static java.lang.Math.toRadians;
-
-/**
- * Various distance calculations and constants.
- * Originally from Lucene 3x's old spatial module. It has been modified here.
- */
-public class DistanceUtils {
-
-  //pre-compute some angles that are commonly used
-  public static final double DEG_45_AS_RADS = Math.PI / 4.0;
-  public static final double SIN_45_AS_RADS = Math.sin(DEG_45_AS_RADS);
-  public static final double DEG_90_AS_RADS = Math.PI / 2;
-  public static final double DEG_180_AS_RADS = Math.PI;
-  public static final double DEG_225_AS_RADS = 5 * DEG_45_AS_RADS;
-  public static final double DEG_270_AS_RADS = 3 * DEG_90_AS_RADS;
-
-
-  public static final double KM_TO_MILES = 0.621371192;
-  public static final double MILES_TO_KM = 1 / KM_TO_MILES;//1.609
-
-  /**
-   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
-   *
-   * [1] http://en.wikipedia.org/wiki/Earth_radius
-   */
-  public static final double EARTH_MEAN_RADIUS_KM = 6371.0087714;
-  public static final double EARTH_EQUATORIAL_RADIUS_KM = 6378.1370;
-
-  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM * KM_TO_MILES;
-  public static final double EARTH_EQUATORIAL_RADIUS_MI = EARTH_EQUATORIAL_RADIUS_KM * KM_TO_MILES;
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1  The first vector
-   * @param vec2  The second vector
-   * @param power The power (2 for cartesian distance, 1 for manhattan, etc.)
-   * @return The length.
-   *         <p/>
-   *         See http://en.wikipedia.org/wiki/Lp_space
-   * @see #vectorDistance(double[], double[], double, double)
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
-    return vectorDistance(vec1, vec2, power, 1.0 / power);
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1         The first vector
-   * @param vec2         The second vector
-   * @param power        The power (2 for cartesian distance, 1 for manhattan, etc.)
-   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
-   * @return The length.
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
-    double result = 0;
-
-    if (power == 0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
-      }
-
-    } else if (power == 1.0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i];
-      }
-    } else if (power == 2.0) {
-      result = Math.sqrt(distSquaredCartesian(vec1, vec2));
-    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
-      for (int i = 0; i < vec1.length; i++) {
-        result = Math.max(result, Math.max(vec1[i], vec2[i]));
-      }
-    } else {
-      for (int i = 0; i < vec1.length; i++) {
-        result += Math.pow(vec1[i] - vec2[i], power);
-      }
-      result = Math.pow(result, oneOverPower);
-    }
-    return result;
-  }
-
-  /**
-   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
-   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximation).
-   *
-   * @param center     The center point
-   * @param result Holds the result, potentially resizing if needed.
-   * @param distance   The d from the center to the corner
-   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
-   * @return The point, either the upperLeft or the lower right
-   */
-  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
-    if (result == null || result.length != center.length) {
-      result = new double[center.length];
-    }
-    if (upperRight == false) {
-      distance = -distance;
-    }
-    //We don't care about the power here,
-    // b/c we are always in a rectangular coordinate system, so any norm can be used by
-    //using the definition of sine
-    distance = SIN_45_AS_RADS * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarly for cosine
-    for (int i = 0; i < center.length; i++) {
-      result[i] = center[i] + distance;
-    }
-    return result;
-  }
-
-  /**
-   * Given a start point (startLat, startLon) and a bearing on a sphere of radius <i>sphereRadius</i>, return the destination point.
-   *
-   *
-   * @param startLat The starting point latitude, in radians
-   * @param startLon The starting point longitude, in radians
-   * @param distanceRAD The distance to travel along the bearing in radians.
-   * @param bearingRAD The bearing, in radians.  North is a 0, moving clockwise till radians(360).
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @return The destination point, in radians.  First entry is latitude, second is longitude
-   */
-  public static double[] pointOnBearingRAD(double startLat, double startLon, double distanceRAD, double bearingRAD, double[] result) {
-    /*
- 	lat2 = asin(sin(lat1)*cos(d/R) + cos(lat1)*sin(d/R)*cos(θ))
-  	lon2 = lon1 + atan2(sin(θ)*sin(d/R)*cos(lat1), cos(d/R)??in(lat1)*sin(lat2))
-
-     */
-    double cosAngDist = Math.cos(distanceRAD);
-    double cosStartLat = Math.cos(startLat);
-    double sinAngDist = Math.sin(distanceRAD);
-    double sinStartLat = Math.sin(startLat);
-    double lat2 = Math.asin(sinStartLat * cosAngDist +
-            cosStartLat * sinAngDist * Math.cos(bearingRAD));
-
-    double lon2 = startLon + Math.atan2(Math.sin(bearingRAD) * sinAngDist * cosStartLat,
-            cosAngDist - sinStartLat * Math.sin(lat2));
-
-    /*lat2 = (lat2*180)/Math.PI;
-    lon2 = (lon2*180)/Math.PI;*/
-    //From Lucene.  Move back to Lucene when synced
-    // normalize lon first
-    if (result == null || result.length != 2){
-      result = new double[2];
-    }
-    result[0] = lat2;
-    result[1] = lon2;
-    normLngRAD(result);
-
-    // normalize lat - could flip poles
-    normLatRAD(result);
-    return result;
-  }
-
-  /**
-   * @param latLng The lat/lon, in radians. lat in position 0, lon in position 1
-   */
-  public static void normLatRAD(double[] latLng) {
-
-    if (latLng[0] > DEG_90_AS_RADS) {
-      latLng[0] = DEG_90_AS_RADS - (latLng[0] - DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    } else if (latLng[0] < -DEG_90_AS_RADS) {
-      latLng[0] = -DEG_90_AS_RADS - (latLng[0] + DEG_90_AS_RADS);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180_AS_RADS;
-      } else {
-        latLng[1] = latLng[1] - DEG_180_AS_RADS;
-      }
-    }
-
-  }
-
-  /**
-   * Returns a normalized Lng rectangle shape for the bounding box
-   *
-   * @param latLng The lat/lon, in radians, lat in position 0, lon in position 1
-   */
-  @Deprecated
-  public static void normLngRAD(double[] latLng) {
-    if (latLng[1] > DEG_180_AS_RADS) {
-      latLng[1] = -1.0 * (DEG_180_AS_RADS - (latLng[1] - DEG_180_AS_RADS));
-    } else if (latLng[1] < -DEG_180_AS_RADS) {
-      latLng[1] = (latLng[1] + DEG_180_AS_RADS) + DEG_180_AS_RADS;
-    }
-  }
-
-  /**
-   * Puts in range -180 <= lon_deg < +180.
-   */
-  public static double normLonDEG(double lon_deg) {
-    if (lon_deg >= -180 && lon_deg < 180)
-      return lon_deg;//common case, and avoids slight double precision shifting
-    double off = (lon_deg + 180) % 360;
-    return off < 0 ? 180 + off : -180 + off;
-  }
-
-  /**
-   * Puts in range -90 <= lat_deg <= 90.
-   */
-  public static double normLatDEG(double lat_deg) {
-    if (lat_deg >= -90 && lat_deg <= 90)
-      return lat_deg;//common case, and avoids slight double precision shifting
-    double off = Math.abs((lat_deg + 90) % 360);
-    return (off <= 180 ? off : 360-off) - 90;
-  }
-
-  public static Rectangle calcBoxByDistFromPtDEG(double lat, double lon, double distance, SpatialContext ctx) {
-    //See http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates Section 3.1, 3.2 and 3.3
-
-    double radius = ctx.getUnits().earthRadius();
-    double dist_rad = distance / radius;
-    double dist_deg = Math.toDegrees(dist_rad);
-
-    if (dist_deg == 0)
-      return ctx.makeRect(lon,lon,lat,lat);
-
-    if (dist_deg >= 180)//distance is >= opposite side of the globe
-      return ctx.getWorldBounds();
-
-    //--calc latitude bounds
-    double latN_deg = lat + dist_deg;
-    double latS_deg = lat - dist_deg;
-
-    if (latN_deg >= 90 || latS_deg <= -90) {//touches either pole
-      //we have special logic for longitude
-      double lonW_deg = -180, lonE_deg = 180;//world wrap: 360 deg
-      if (latN_deg <= 90 && latS_deg >= -90) {//doesn't pass either pole: 180 deg
-        lonW_deg = lon -90;
-        lonE_deg = lon +90;
-      }
-      if (latN_deg > 90)
-        latN_deg = 90;
-      if (latS_deg < -90)
-        latS_deg = -90;
-
-      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);
-    } else {
-      //--calc longitude bounds
-      double lon_delta_deg = calcBoxByDistFromPtVertAxisOffsetDEG(lat, lon, distance, radius);
-
-      double lonW_deg = lon -lon_delta_deg;
-      double lonE_deg = lon +lon_delta_deg;
-
-      return ctx.makeRect(lonW_deg, lonE_deg, latS_deg, latN_deg);//ctx will normalize longitude
-    }
-  }
-
-  public static double calcBoxByDistFromPtVertAxisOffsetDEG(double lat, double lon, double distance, double radius) {
-    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
-    if (distance == 0)
-      return 0;
-    double lat_rad = toRadians(lat);
-    double dist_rad = distance / radius;
-    double result_rad = Math.asin(Math.sin(dist_rad) / Math.cos(lat_rad));
-
-    if (!Double.isNaN(result_rad))
-      return Math.toDegrees(result_rad);
-    return 90;
-  }
-
-  public static double calcBoxByDistFromPtHorizAxisDEG(double lat, double lon, double distance, double radius) {
-    //http://gis.stackexchange.com/questions/19221/find-tangent-point-on-circle-furthest-east-or-west
-    if (distance == 0)
-      return lat;
-    double lat_rad = toRadians(lat);
-    double dist_rad = distance / radius;
-    double result_rad = Math.asin( Math.sin(lat_rad) / Math.cos(dist_rad));
-    if (!Double.isNaN(result_rad))
-      return Math.toDegrees(result_rad);
-    //TODO should we use use ctx.getBoundaryNudgeDegrees() offsets here or let caller?
-    if (lat > 0)
-      return 90;
-    if (lat < 0)
-      return -90;
-    return lat;
-  }
-
-  /**
-   * The square of the cartesian Distance.  Not really a distance, but useful if all that matters is
-   * comparing the result to another one.
-   *
-   * @param vec1 The first point
-   * @param vec2 The second point
-   * @return The squared cartesian distance
-   */
-  public static double distSquaredCartesian(double[] vec1, double[] vec2) {
-    double result = 0;
-    for (int i = 0; i < vec1.length; i++) {
-      double v = vec1[i] - vec2[i];
-      result += v * v;
-    }
-    return result;
-  }
-
-  /**
-   *
-   * @param lat1     The y coordinate of the first point, in radians
-   * @param lon1     The x coordinate of the first point, in radians
-   * @param lat2     The y coordinate of the second point, in radians
-   * @param lon2     The x coordinate of the second point, in radians
-   * @return The distance between the two points, as determined by the Haversine formula, in radians.
-   */
-  public static double distHaversineRAD(double lat1, double lon1, double lat2, double lon2) {
-    //TODO investigate slightly different formula using asin() and min() http://www.movable-type.co.uk/scripts/gis-faq-5.1.html
-
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-    double hsinX = Math.sin((lon1 - lon2) * 0.5);
-    double hsinY = Math.sin((lat1 - lat2) * 0.5);
-    double h = hsinY * hsinY +
-            (Math.cos(lat1) * Math.cos(lat2) * hsinX * hsinX);
-    return 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
-  }
-
-  /**
-   * Calculates the distance between two lat/lng's using the Law of Cosines. Due to numeric conditioning
-   * errors, it is not as accurate as the Haversine formula for small distances.  But with
-   * double precision, it isn't that bad -- <a href="http://www.movable-type.co.uk/scripts/latlong.html">
-   *   allegedly 1 meter</a>.
-   * <p/>
-   * See <a href="http://gis.stackexchange.com/questions/4906/why-is-law-of-cosines-more-preferable-than-haversine-when-calculating-distance-b">
-   *  Why is law of cosines more preferable than haversine when calculating distance between two latitude-longitude points?</a>
-   * <p/>
-   * The arguments and return value are in radians.
-   */
-  public static double distLawOfCosinesRAD(double lat1, double lon1, double lat2, double lon2) {
-    //TODO validate formula
-
-    //(MIGRATED FROM org.apache.lucene.spatial.geometry.LatLng.arcDistance())
-    // Imported from mq java client.  Variable references changed to match.
-
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-
-    // Get the m_dLongitude difference. Don't need to worry about
-    // crossing 180 since cos(x) = cos(-x)
-    double dLon = lon2 - lon1;
-
-    double a = DEG_90_AS_RADS - lat1;
-    double c = DEG_90_AS_RADS - lat2;
-    double cosB = (Math.cos(a) * Math.cos(c))
-        + (Math.sin(a) * Math.sin(c) * Math.cos(dLon));
-
-    // Find angle subtended (with some bounds checking) in radians
-    if (cosB < -1.0)
-      return Math.PI;
-    else if (cosB >= 1.0)
-      return 0;
-    else
-      return Math.acos(cosB);
-  }
-
-  /**
-   * Calculates the great circle distance using the Vincenty Formula, simplified for a spherical model. This formula
-   * is accurate for any pair of points. The equation
-   * was taken from <a href="http://en.wikipedia.org/wiki/Great-circle_distance">Wikipedia</a>.
-   * <p/>
-   * The arguments are in radians, and the result is in radians.
-   */
-  public static double distVincentyRAD(double lat1, double lon1, double lat2, double lon2) {
-    // Check for same position
-    if (lat1 == lat2 && lon1 == lon2)
-      return 0.0;
-
-    double cosLat1 = Math.cos(lat1);
-    double cosLat2 = Math.cos(lat2);
-    double sinLat1 = Math.sin(lat1);
-    double sinLat2 = Math.sin(lat2);
-    double dLon = lon2 - lon1;
-    double cosDLon = Math.cos(dLon);
-    double sinDLon = Math.sin(dLon);
-
-    double a = cosLat2 * sinDLon;
-    double b = cosLat1*sinLat2 - sinLat1*cosLat2*cosDLon;
-    double c = sinLat1*sinLat2 + cosLat1*cosLat2*cosDLon;
-    
-    return Math.atan2(Math.sqrt(a*a+b*b),c);
-  }
-
-  /**
-   * Converts a distance in the units of the radius to degrees (360 degrees are in a circle). A spherical
-   * earth model is assumed.
-   */
-  public static double dist2Degrees(double dist, double radius) {
-    return Math.toDegrees(dist2Radians(dist, radius));
-  }
-
-  /**
-   * Converts a distance in the units of the radius to radians (multiples of the radius). A spherical
-   * earth model is assumed.
-   */
-  public static double dist2Radians(double dist, double radius) {
-    return dist / radius;
-  }
-
-  public static double radians2Dist(double radians, double radius) {
-    return radians * radius;
-  }
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
deleted file mode 100644
index fe96f91..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/GeodesicSphereDistCalc.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-import static java.lang.Math.toRadians;
-
-/**
- * A base class for a Distance Calculator that assumes a spherical earth model.
- */
-public abstract class GeodesicSphereDistCalc extends AbstractDistanceCalculator {
-  protected final double radius;
-
-  public GeodesicSphereDistCalc(double radius) {
-    this.radius = radius;
-  }
-
-  @Override
-  public double distanceToDegrees(double distance) {
-    return DistanceUtils.dist2Degrees(distance, radius);
-  }
-
-  @Override
-  public double degreesToDistance(double degrees) {
-    return DistanceUtils.radians2Dist(toRadians(degrees), radius);
-  }
-
-  @Override
-  public Point pointOnBearing(Point from, double dist, double bearingDEG, SpatialContext ctx) {
-    //TODO avoid unnecessary double[] intermediate object
-    if (dist == 0)
-      return from;
-    double[] latLon = DistanceUtils.pointOnBearingRAD(
-        toRadians(from.getY()), toRadians(from.getX()),
-        DistanceUtils.dist2Radians(dist,ctx.getUnits().earthRadius()),
-        toRadians(bearingDEG), null);
-    return ctx.makePoint(Math.toDegrees(latLon[1]), Math.toDegrees(latLon[0]));
-  }
-
-  @Override
-  public Rectangle calcBoxByDistFromPt(Point from, double distance, SpatialContext ctx) {
-    assert radius == ctx.getUnits().earthRadius();
-    if (distance == 0)
-      return from.getBoundingBox();
-    return DistanceUtils.calcBoxByDistFromPtDEG(from.getY(), from.getX(), distance, ctx);
-  }
-
-  @Override
-  public double calcBoxByDistFromPtHorizAxis(Point from, double distance, SpatialContext ctx) {
-    return DistanceUtils.calcBoxByDistFromPtHorizAxisDEG(from.getY(), from.getX(), distance, radius);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    GeodesicSphereDistCalc that = (GeodesicSphereDistCalc) o;
-
-    if (Double.compare(that.radius, radius) != 0) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    long temp = radius != +0.0d ? Double.doubleToLongBits(radius) : 0L;
-    return (int) (temp ^ (temp >>> 32));
-  }
-
-  @Override
-  public final double distance(Point from, double toX, double toY) {
-    return distanceLatLonRAD(toRadians(from.getY()), toRadians(from.getX()), toRadians(toY), toRadians(toX)) * radius;
-  }
-
-  protected abstract double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2);
-
-  public static class Haversine extends GeodesicSphereDistCalc {
-
-    public Haversine(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distHaversineRAD(lat1,lon1,lat2,lon2);
-    }
-
-  }
-
-  public static class LawOfCosines extends GeodesicSphereDistCalc {
-
-    public LawOfCosines(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distLawOfCosinesRAD(lat1, lon1, lat2, lon2);
-    }
-
-  }
-
-  public static class Vincenty extends GeodesicSphereDistCalc {
-    public Vincenty(double radius) {
-      super(radius);
-    }
-
-    @Override
-    protected double distanceLatLonRAD(double lat1, double lon1, double lat2, double lon2) {
-      return DistanceUtils.distVincentyRAD(lat1, lon1, lat2, lon2);
-    }
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java
deleted file mode 100644
index 0a15a97..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/distance/package-info.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Ways to calculate distance
- */
-package org.apache.lucene.spatial.base.distance;
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
deleted file mode 100644
index a8c052d..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidShapeException.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-public class InvalidShapeException extends RuntimeException {
-
-  public InvalidShapeException(String reason, Throwable cause) {
-    super(reason, cause);
-  }
-
-  public InvalidShapeException(String reason) {
-    super(reason);
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
deleted file mode 100644
index 29dc10e..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/InvalidSpatialArgument.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-public class InvalidSpatialArgument extends RuntimeException {
-
-  public InvalidSpatialArgument(String reason, Throwable cause) {
-    super(reason, cause);
-  }
-
-  public InvalidSpatialArgument(String reason) {
-    super(reason);
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
deleted file mode 100644
index 74da848..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/exception/UnsupportedSpatialOperation.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.exception;
-
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-
-public class UnsupportedSpatialOperation extends UnsupportedOperationException {
-
-  public UnsupportedSpatialOperation(SpatialOperation op) {
-    super(op.getName());
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java
deleted file mode 100644
index 0bad39a..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/LineReader.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.Iterator;
-
-public abstract class LineReader<T> implements Iterator<T> {
-
-  private int count = 0;
-  private int lineNumber = 0;
-  private BufferedReader reader;
-  private String nextLine;
-
-  public abstract T parseLine( String line );
-
-  protected void readComment( String line ) {
-
-  }
-
-  public LineReader(InputStream in) throws IOException {
-    reader = new BufferedReader(
-        new InputStreamReader( in, "UTF-8" ) );
-    next();
-  }
-
-  public LineReader(Reader r) throws IOException {
-    if (r instanceof BufferedReader) {
-      reader = (BufferedReader) r;
-    } else {
-      reader = new BufferedReader(r);
-    }
-    next();
-  }
-
-  public LineReader(File f) throws IOException {
-    reader = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));
-    next();
-  }
-
-  @Override
-  public boolean hasNext() {
-    return nextLine != null;
-  }
-
-  @Override
-  public T next() {
-    T val = null;
-    if (nextLine != null) {
-      val = parseLine(nextLine);
-      count++;
-    }
-
-    if (reader != null) {
-      try {
-        while( reader != null ) {
-          nextLine = reader.readLine();
-          lineNumber++;
-          if (nextLine == null ) {
-            reader.close();
-            reader = null;
-          }
-          else if( nextLine.startsWith( "#" ) ) {
-            readComment( nextLine );
-          }
-          else {
-            nextLine = nextLine.trim();
-            if( nextLine.length() > 0 ) {
-              break;
-            }
-          }
-        }
-      } catch (IOException ioe) {
-        throw new RuntimeException("IOException thrown while reading/closing reader", ioe);
-      }
-    }
-    return val;
-  }
-
-  @Override
-  public void remove() {
-    throw new UnsupportedOperationException();
-  }
-
-  public int getLineNumber() {
-    return lineNumber;
-  }
-
-  public int getCount() {
-    return count;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
deleted file mode 100644
index cc6d8d6..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/Geoname.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.geonames;
-
-import java.sql.Date;
-
-public class Geoname {
-  public int id;
-  public String name; // name of geographical point (utf8) varchar(200)
-  public String nameASCII; // name of geographical point in plain ascii characters, varchar(200)
-  public String[] alternateNames; // alternatenames, comma separated varchar(5000)
-  public double latitude;
-  public double longitude;
-  public char featureClass;
-  public String featureCode; // 10
-  public String countryCode; // 2
-  public String[] countryCode2; // alternate country codes, comma separated, ISO-3166 2-letter country code, 60 characters
-  public String adminCode1; // fipscode (subject to change to iso code), see exceptions below, see file admin1Codes.txt for display names of this code; varchar(20)
-  public String adminCode2; // code for the second administrative division, a county in the US, see file admin2Codes.txt; varchar(80)
-  public String adminCode3; // code for third level administrative division, varchar(20)
-  public String adminCode4; // code for fourth level administrative division, varchar(20)
-  public Long population;
-  public Integer elevation; // in meters, integer
-  public Integer gtopo30;   // average elevation of 30'x30' (ca 900mx900m) area in meters, integer
-  public String timezone;
-  public Date modified;  // date of last modification in yyyy-MM-dd format
-
-  public Geoname(String line) {
-    String[] vals = line.split("\t");
-    id = Integer.parseInt(vals[0]);
-    name = vals[1];
-    nameASCII = vals[2];
-    alternateNames = vals[3].split(",");
-    latitude = Double.parseDouble(vals[4]);
-    longitude = Double.parseDouble(vals[5]);
-    featureClass = vals[6].length() > 0 ? vals[6].charAt(0) : 'S';
-    featureCode = vals[7];
-    countryCode = vals[8];
-    countryCode2 = vals[9].split(",");
-    adminCode1 = vals[10];
-    adminCode2 = vals[11];
-    adminCode3 = vals[12];
-    adminCode4 = vals[13];
-    if (vals[14].length() > 0) {
-      population = Long.decode(vals[14]);
-    }
-    if (vals[15].length() > 0) {
-      elevation = Integer.decode(vals[15]);
-    }
-    if (vals[16].length() > 0) {
-      gtopo30 = Integer.decode(vals[16]);
-    }
-    timezone = vals[17];
-    if (vals[18].length() > 0) {
-      modified = Date.valueOf(vals[18]);
-    }
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
deleted file mode 100644
index 9158d10..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/geonames/GeonamesReader.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.geonames;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.Reader;
-
-import org.apache.lucene.spatial.base.io.LineReader;
-
-public class GeonamesReader extends LineReader<Geoname> {
-
-  public GeonamesReader(Reader r) throws IOException {
-    super( r );
-  }
-
-  public GeonamesReader(File f) throws IOException {
-    super( f );
-  }
-
-  @Override
-  public Geoname parseLine(String line) {
-    return new Geoname( line );
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
deleted file mode 100644
index caefe07..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleData.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.sample;
-
-import java.util.Comparator;
-
-
-public class SampleData {
-  public String id;
-  public String name;
-  public String shape;
-
-  public SampleData(String line) {
-    String[] vals = line.split("\t");
-    id = vals[0];
-    name = vals[1];
-    shape = vals[2];
-  }
-
-  public static Comparator<SampleData> NAME_ORDER = new Comparator<SampleData>() {
-    @Override
-    public int compare(SampleData o1, SampleData o2) {
-      return o1.name.compareTo( o2.name );
-    }
-  };
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
deleted file mode 100644
index 8d79cb7..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/io/sample/SampleDataReader.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.io.sample;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-import org.apache.lucene.spatial.base.io.LineReader;
-
-public class SampleDataReader extends LineReader<SampleData> {
-
-  public SampleDataReader(InputStream r) throws IOException {
-    super( r );
-  }
-
-  public SampleDataReader(Reader r) throws IOException {
-    super( r );
-  }
-
-  public SampleDataReader(File f) throws IOException {
-    super( f );
-  }
-
-  @Override
-  public SampleData parseLine(String line) {
-    return new SampleData( line );
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java
deleted file mode 100644
index aa3585f..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/package-info.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * This package is spatal stuff without any lucene dependencies
- * Things implemented in this package could be calculated on the client side
- */
-package org.apache.lucene.spatial.base;
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java
deleted file mode 100644
index 9d3ecbd..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/Node.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Represents a grid cell. These are not necessarily threadsafe, although new Cell("") (world cell) must be.
- */
-public abstract class Node implements Comparable<Node> {
-  public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
-
-  /*
-  Holds a byte[] and/or String representation of the cell. Both are lazy constructed from the other.
-  Neither contains the trailing leaf byte.
-   */
-  private byte[] bytes;
-  private int b_off;
-  private int b_len;
-
-  private String token;//this is the only part of equality
-
-  protected SpatialRelation shapeRel;//set in getSubCells(filter), and via setLeaf().
-  private SpatialPrefixTree spatialPrefixTree;
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, String token) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.token = token;
-    if (token.length() > 0 && token.charAt(token.length() - 1) == (char) LEAF_BYTE) {
-      this.token = token.substring(0, token.length() - 1);
-      setLeaf();
-    }
-
-    if (getLevel() == 0)
-      getShape();//ensure any lazy instantiation completes to make this threadsafe
-  }
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, byte[] bytes, int off, int len) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  public void reset(byte[] bytes, int off, int len) {
-    assert getLevel() != 0;
-    token = null;
-    shapeRel = null;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  private void b_fixLeaf() {
-    if (bytes[b_off + b_len - 1] == LEAF_BYTE) {
-      b_len--;
-      setLeaf();
-    } else if (getLevel() == spatialPrefixTree.getMaxLevels()) {
-      setLeaf();
-    }
-  }
-
-  public SpatialRelation getShapeRel() {
-    return shapeRel;
-  }
-
-  public boolean isLeaf() {
-    return shapeRel == SpatialRelation.WITHIN;
-  }
-
-  public void setLeaf() {
-    assert getLevel() != 0;
-    shapeRel = SpatialRelation.WITHIN;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public String getTokenString() {
-    if (token == null) {
-      token = new String(bytes, b_off, b_len, SpatialPrefixTree.UTF8);
-    }
-    return token;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public byte[] getTokenBytes() {
-    if (bytes != null) {
-      if (b_off != 0 || b_len != bytes.length) {
-        throw new IllegalStateException("Not supported if byte[] needs to be recreated.");
-      }
-    } else {
-      bytes = token.getBytes(SpatialPrefixTree.UTF8);
-      b_off = 0;
-      b_len = bytes.length;
-    }
-    return bytes;
-  }
-
-  public int getLevel() {
-    return token != null ? token.length() : b_len;
-  }
-
-  //TODO add getParent() and update some algorithms to use this?
-  //public Cell getParent();
-
-  /**
-   * Like {@link #getSubCells()} but with the results filtered by a shape. If that shape is a {@link org.apache.lucene.spatial.base.shape.Point} then it
-   * must call {@link #getSubCell(org.apache.lucene.spatial.base.shape.Point)};
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @param shapeFilter an optional filter for the returned cells.
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  public Collection<Node> getSubCells(Shape shapeFilter) {
-    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
-    if (shapeFilter instanceof Point) {
-      return Collections.singleton(getSubCell((Point) shapeFilter));
-    }
-    Collection<Node> cells = getSubCells();
-
-    if (shapeFilter == null) {
-      return cells;
-    }
-    List<Node> copy = new ArrayList<Node>(cells.size());//copy since cells contractually isn't modifiable
-    for (Node cell : cells) {
-      SpatialRelation rel = cell.getShape().relate(shapeFilter, spatialPrefixTree.ctx);
-      if (rel == SpatialRelation.DISJOINT)
-        continue;
-      cell.shapeRel = rel;
-      copy.add(cell);
-    }
-    cells = copy;
-    return cells;
-  }
-
-  /**
-   * Performant implementations are expected to implement this efficiently by considering the current
-   * cell's boundary.
-   * Precondition: Never called when getLevel() == maxLevel.
-   * Precondition: this.getShape().relate(p) != DISJOINT.
-   */
-  public abstract Node getSubCell(Point p);
-
-  //TODO Cell getSubCell(byte b)
-
-  /**
-   * Gets the cells at the next grid cell level that cover this cell.
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  protected abstract Collection<Node> getSubCells();
-
-  /**
-   * {@link #getSubCells()}.size() -- usually a constant. Should be >=2
-   */
-  public abstract int getSubCellsSize();
-
-  public abstract Shape getShape();
-
-  public Point getCenter() {
-    return getShape().getCenter();
-  }
-
-  @Override
-  public int compareTo(Node o) {
-    return getTokenString().compareTo(o.getTokenString());
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return !(obj == null || !(obj instanceof Node)) && getTokenString().equals(((Node) obj).getTokenString());
-  }
-
-  @Override
-  public int hashCode() {
-    return getTokenString().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return getTokenString() + (isLeaf() ? (char) LEAF_BYTE : "");
-  }
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
deleted file mode 100644
index 58dbe1c..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTree.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to
- * variable precision.  Each string corresponds to a spatial region.
- *
- * Implementations of this class should be thread-safe and immutable once initialized.
- */
-public abstract class SpatialPrefixTree {
-
-  protected static final Charset UTF8 = Charset.forName("UTF-8");
-
-  protected final int maxLevels;
-
-  protected final SpatialContext ctx;
-
-  public SpatialPrefixTree(SpatialContext ctx, int maxLevels) {
-    assert maxLevels > 0;
-    this.ctx = ctx;
-    this.maxLevels = maxLevels;
-  }
-
-  public SpatialContext getSpatialContext() {
-    return ctx;
-  }
-
-  public int getMaxLevels() {
-    return maxLevels;
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName() + "(maxLevels:" + maxLevels + ",ctx:" + ctx + ")";
-  }
-
-  /**
-   * See {@link org.apache.lucene.spatial.base.query.SpatialArgs#getDistPrecision()}.
-   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.
-   *
-   * @param shape
-   * @param precision 0-0.5
-   * @return 1-maxLevels
-   */
-  public int getMaxLevelForPrecision(Shape shape, double precision) {
-    if (precision < 0 || precision > 0.5) {
-      throw new IllegalArgumentException("Precision " + precision + " must be between [0-0.5]");
-    }
-    if (precision == 0 || shape instanceof Point) {
-      return maxLevels;
-    }
-    double bboxArea = shape.getBoundingBox().getArea();
-    if (bboxArea == 0) {
-      return maxLevels;
-    }
-    double avgSideLenFromCenter = Math.sqrt(bboxArea) / 2;
-    return getLevelForDistance(avgSideLenFromCenter * precision);
-  }
-
-  /**
-   * Returns the level of the smallest grid size with a side length that is greater or equal to the provided
-   * distance.
-   *
-   * @param dist >= 0
-   * @return level [1-maxLevels]
-   */
-  public abstract int getLevelForDistance(double dist);
-
-  //TODO double getDistanceForLevel(int level)
-
-  private transient Node worldNode;//cached
-
-  /**
-   * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".
-   * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't
-   * generally threadsafe.
-   * TODO rename to getTopCell or is this fine?
-   */
-  public Node getWorldNode() {
-    if (worldNode == null) {
-      worldNode = getNode("");
-    }
-    return worldNode;
-  }
-
-  /**
-   * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.
-   * Precondition: Never called when token length > maxLevel.
-   */
-  public abstract Node getNode(String token);
-
-  public abstract Node getNode(byte[] bytes, int offset, int len);
-
-  public final Node getNode(byte[] bytes, int offset, int len, Node target) {
-    if (target == null) {
-      return getNode(bytes, offset, len);
-    }
-
-    target.reset(bytes, offset, len);
-    return target;
-  }
-
-  protected Node getNode(Point p, int level) {
-    return getNodes(p, level, false).get(0);
-  }
-
-  /**
-   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
-   * The result is a set of cells (no dups), sorted. Unmodifiable.
-   * <p/>
-   * This implementation checks if shape is a Point and if so uses an implementation that
-   * recursively calls {@link Node#getSubCell(org.apache.lucene.spatial.base.shape.Point)}. Cell subclasses
-   * ideally implement that method with a quick implementation, otherwise, subclasses should
-   * override this method to invoke {@link #getNodesAltPoint(org.apache.lucene.spatial.base.shape.Point, int, boolean)}.
-   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
-   */
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (detailLevel > maxLevels) {
-      throw new IllegalArgumentException("detailLevel > maxLevels");
-    }
-
-    List<Node> cells;
-    if (shape instanceof Point) {
-      //optimized point algorithm
-      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
-      cells = new ArrayList<Node>(initialCapacity);
-      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
-      assert cells.size() == initialCapacity;
-    } else {
-      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
-      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
-    }
-    if (inclParents) {
-      Node c = cells.remove(0);//remove getWorldNode()
-      assert c.getLevel() == 0;
-    }
-    return cells;
-  }
-
-  private void recursiveGetNodes(Node node, Shape shape, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (node.isLeaf()) {//cell is within shape
-      result.add(node);
-      return;
-    }
-    final Collection<Node> subCells = node.getSubCells(shape);
-    if (node.getLevel() == detailLevel - 1) {
-      if (subCells.size() < node.getSubCellsSize()) {
-        if (inclParents)
-          result.add(node);
-        for (Node subCell : subCells) {
-          subCell.setLeaf();
-        }
-        result.addAll(subCells);
-      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
-        node.setLeaf();
-        result.add(node);
-      }
-    } else {
-      if (inclParents) {
-        result.add(node);
-      }
-      for (Node subCell : subCells) {
-        recursiveGetNodes(subCell, shape, detailLevel, inclParents, result);//tail call
-      }
-    }
-  }
-
-  private void recursiveGetNodes(Node node, Point point, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (inclParents) {
-      result.add(node);
-    }
-    final Node pCell = node.getSubCell(point);
-    if (node.getLevel() == detailLevel - 1) {
-      pCell.setLeaf();
-      result.add(pCell);
-    } else {
-      recursiveGetNodes(pCell, point, detailLevel, inclParents, result);//tail call
-    }
-  }
-
-  /**
-   * Subclasses might override {@link #getNodes(org.apache.lucene.spatial.base.shape.Shape, int, boolean)}
-   * and check if the argument is a shape and if so, delegate
-   * to this implementation, which calls {@link #getNode(org.apache.lucene.spatial.base.shape.Point, int)} and
-   * then calls {@link #getNode(String)} repeatedly if inclParents is true.
-   */
-  protected final List<Node> getNodesAltPoint(Point p, int detailLevel, boolean inclParents) {
-    Node cell = getNode(p, detailLevel);
-    if (!inclParents) {
-      return Collections.singletonList(cell);
-    }
-
-    String endToken = cell.getTokenString();
-    assert endToken.length() == detailLevel;
-    List<Node> cells = new ArrayList<Node>(detailLevel);
-    for (int i = 1; i < detailLevel; i++) {
-      cells.add(getNode(endToken.substring(0, i)));
-    }
-    cells.add(cell);
-    return cells;
-  }
-
-  /**
-   * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
-   */
-  public static List<String> nodesToTokenStrings(Collection<Node> nodes) {
-    List<String> tokens = new ArrayList<String>((nodes.size()));
-    for (Node node : nodes) {
-      final String token = node.getTokenString();
-      if (node.isLeaf()) {
-        tokens.add(token + (char) Node.LEAF_BYTE);
-      } else {
-        tokens.add(token);
-      }
-    }
-    return tokens;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
deleted file mode 100644
index 0f24f9e..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeFactory.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashPrefixTree;
-import org.apache.lucene.spatial.base.prefix.quad.QuadPrefixTree;
-
-import java.util.Map;
-
-
-public abstract class SpatialPrefixTreeFactory {
-
-  private static final double DEFAULT_GEO_MAX_DETAIL_KM = 0.001;//1m
-
-  protected Map<String, String> args;
-  protected SpatialContext ctx;
-  protected Integer maxLevels;
-
-  /**
-   * The factory  is looked up via "prefixTree" in args, expecting "geohash" or "quad".
-   * If its neither of these, then "geohash" is chosen for a geo context, otherwise "quad" is chosen.
-   */
-  public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {
-    SpatialPrefixTreeFactory instance;
-    String cname = args.get("prefixTree");
-    if (cname == null)
-      cname = ctx.isGeo() ? "geohash" : "quad";
-    if ("geohash".equalsIgnoreCase(cname))
-      instance = new GeohashPrefixTree.Factory();
-    else if ("quad".equalsIgnoreCase(cname))
-      instance = new QuadPrefixTree.Factory();
-    else {
-      try {
-        Class c = classLoader.loadClass(cname);
-        instance = (SpatialPrefixTreeFactory) c.newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    instance.init(args,ctx);
-    return instance.newSPT();
-  }
-
-  protected void init(Map<String, String> args, SpatialContext ctx) {
-    this.args = args;
-    this.ctx = ctx;
-    initMaxLevels();
-  }
-
-  protected void initMaxLevels() {
-    String mlStr = args.get("maxLevels");
-    if (mlStr != null) {
-      maxLevels = Integer.valueOf(mlStr);
-      return;
-    }
-
-    double degrees;
-    String maxDetailDistStr = args.get("maxDetailDist");
-    if (maxDetailDistStr == null) {
-      if (!ctx.isGeo()) {
-        return;//let default to max
-      }
-      degrees = DistanceUtils.dist2Degrees(DEFAULT_GEO_MAX_DETAIL_KM, DistanceUnits.KILOMETERS.earthRadius());
-    } else {
-      degrees = DistanceUtils.dist2Degrees(Double.parseDouble(maxDetailDistStr), ctx.getUnits().earthRadius());
-    }
-    maxLevels = getLevelForDistance(degrees) + 1;//returns 1 greater
-  }
-
-  /** Calls {@link SpatialPrefixTree#getLevelForDistance(double)}. */
-  protected abstract int getLevelForDistance(double degrees);
-
-  protected abstract SpatialPrefixTree newSPT();
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
deleted file mode 100644
index 1f96c2c..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashPrefixTree.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.geohash;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * A SpatialPrefixGrid based on Geohashes.  Uses {@link GeohashUtils} to do all the geohash work.
- */
-public class GeohashPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      GeohashPrefixTree grid = new GeohashPrefixTree(ctx, GeohashPrefixTree.getMaxLevelsPossible());
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new GeohashPrefixTree(ctx,
-          maxLevels != null ? maxLevels : GeohashPrefixTree.getMaxLevelsPossible());
-    }
-  }
-
-  public GeohashPrefixTree(SpatialContext ctx, int maxLevels) {
-    super(ctx, maxLevels);
-    Rectangle bounds = ctx.getWorldBounds();
-    if (bounds.getMinX() != -180)
-      throw new IllegalArgumentException("Geohash only supports lat-lon world bounds. Got "+bounds);
-    int MAXP = getMaxLevelsPossible();
-    if (maxLevels <= 0 || maxLevels > MAXP)
-      throw new IllegalArgumentException("maxLen must be [1-"+MAXP+"] but got "+ maxLevels);
-  }
-
-  /** Any more than this and there's no point (double lat & lon are the same). */
-  public static int getMaxLevelsPossible() {
-    return GeohashUtils.MAX_PRECISION;
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    final int level = GeohashUtils.lookupHashLenForWidthHeight(dist, dist);
-    return Math.max(Math.min(level, maxLevels), 1);
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    return new GhCell(GeohashUtils.encodeLatLon(p.getY(), p.getX(), level));//args are lat,lon (y,x)
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new GhCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new GhCell(bytes, offset, len);
-  }
-
-  @Override
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    return shape instanceof Point ? super.getNodesAltPoint((Point) shape, detailLevel, inclParents) :
-        super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  class GhCell extends Node {
-    GhCell(String token) {
-      super(GeohashPrefixTree.this, token);
-    }
-
-    GhCell(byte[] bytes, int off, int len) {
-      super(GeohashPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      String[] hashes = GeohashUtils.getSubGeohashes(getGeohash());//sorted
-      List<Node> cells = new ArrayList<Node>(hashes.length);
-      for (String hash : hashes) {
-        cells.add(new GhCell(hash));
-      }
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 32;//8x4
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return GeohashPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null) {
-        shape = GeohashUtils.decodeBoundary(getGeohash(), ctx);
-      }
-      return shape;
-    }
-
-    @Override
-    public Point getCenter() {
-      return GeohashUtils.decode(getGeohash(), ctx);
-    }
-
-    private String getGeohash() {
-      return getTokenString();
-    }
-
-  }//class GhCell
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
deleted file mode 100644
index 15fed96..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/geohash/GeohashUtils.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.geohash;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Point;
-
-import java.util.Arrays;
-
-/**
- * Utilities for encoding and decoding geohashes. Based on
- * <a href="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</a>.
- */
-public class GeohashUtils {
-
-  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
-      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
-      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};//note: this is sorted
-
-  private static final int[] BASE_32_IDX;//sparse array of indexes from '0' to 'z'
-
-  public static final int MAX_PRECISION = 24;//DWS: I forget what level results in needless more precision but it's about this
-  private static final int[] BITS = {16, 8, 4, 2, 1};
-
-  static {
-    BASE_32_IDX = new int[BASE_32[BASE_32.length-1] - BASE_32[0] + 1];
-    assert BASE_32_IDX.length < 100;//reasonable length
-    Arrays.fill(BASE_32_IDX,-500);
-    for (int i = 0; i < BASE_32.length; i++) {
-      BASE_32_IDX[BASE_32[i] - BASE_32[0]] = i;
-    }
-  }
-
-  private GeohashUtils() {
-  }
-
-  /**
-   * Encodes the given latitude and longitude into a geohash
-   *
-   * @param latitude Latitude to encode
-   * @param longitude Longitude to encode
-   * @return Geohash encoding of the longitude and latitude
-   */
-  public static String encodeLatLon(double latitude, double longitude) {
-    return encodeLatLon(latitude, longitude, 12);
-  }
-
-  public static String encodeLatLon(double latitude, double longitude, int precision) {
-    double[] latInterval = {-90.0, 90.0};
-    double[] lngInterval = {-180.0, 180.0};
-
-    final StringBuilder geohash = new StringBuilder(precision);
-    boolean isEven = true;
-
-    int bit = 0;
-    int ch = 0;
-
-    while (geohash.length() < precision) {
-      double mid = 0.0;
-      if (isEven) {
-        mid = (lngInterval[0] + lngInterval[1]) / 2D;
-        if (longitude > mid) {
-          ch |= BITS[bit];
-          lngInterval[0] = mid;
-        } else {
-          lngInterval[1] = mid;
-        }
-      } else {
-        mid = (latInterval[0] + latInterval[1]) / 2D;
-        if (latitude > mid) {
-          ch |= BITS[bit];
-          latInterval[0] = mid;
-        } else {
-          latInterval[1] = mid;
-        }
-      }
-
-      isEven = !isEven;
-
-      if (bit < 4) {
-        bit++;
-      } else {
-        geohash.append(BASE_32[ch]);
-        bit = 0;
-        ch = 0;
-      }
-    }
-
-    return geohash.toString();
-  }
-
-  /**
-   * Decodes the given geohash into a latitude and longitude
-   *
-   * @param geohash Geohash to deocde
-   * @return Array with the latitude at index 0, and longitude at index 1
-   */
-  public static Point decode(String geohash, SpatialContext ctx) {
-    Rectangle rect = decodeBoundary(geohash,ctx);
-    double latitude = (rect.getMinY() + rect.getMaxY()) / 2D;
-    double longitude = (rect.getMinX() + rect.getMaxX()) / 2D;
-    return ctx.makePoint(longitude,latitude);
-	}
-
-  /** Returns min-max lat, min-max lon. */
-  public static Rectangle decodeBoundary(String geohash, SpatialContext ctx) {
-    double minY = -90, maxY = 90, minX = -180, maxX = 180;
-    boolean isEven = true;
-
-    for (int i = 0; i < geohash.length(); i++) {
-      char c = geohash.charAt(i);
-      if (c >= 'A' && c <= 'Z')
-        c -= ('A' - 'a');
-      final int cd = BASE_32_IDX[c - BASE_32[0]];//TODO check successful?
-
-      for (int mask : BITS) {
-        if (isEven) {
-          if ((cd & mask) != 0) {
-            minX = (minX + maxX) / 2D;
-          } else {
-            maxX = (minX + maxX) / 2D;
-          }
-        } else {
-          if ((cd & mask) != 0) {
-            minY = (minY + maxY) / 2D;
-          } else {
-            maxY = (minY + maxY) / 2D;
-          }
-        }
-        isEven = !isEven;
-      }
-
-    }
-    return ctx.makeRect(minX, maxX, minY, maxY);
-  }
-
-  /** Array of geohashes 1 level below the baseGeohash. Sorted. */
-  public static String[] getSubGeohashes(String baseGeohash) {
-    String[] hashes = new String[BASE_32.length];
-    for (int i = 0; i < BASE_32.length; i++) {//note: already sorted
-      char c = BASE_32[i];
-      hashes[i] = baseGeohash+c;
-    }
-    return hashes;
-  }
-
-  public static double[] lookupDegreesSizeForHashLen(int hashLen) {
-    return new double[]{hashLenToLatHeight[hashLen], hashLenToLonWidth[hashLen]};
-  }
-
-  /**
-   * Return the longest geohash length that will have a width & height >= specified arguments.
-   */
-  public static int lookupHashLenForWidthHeight(double width, double height) {
-    //loop through hash length arrays from beginning till we find one.
-    for(int len = 1; len <= MAX_PRECISION; len++) {
-      double latHeight = hashLenToLatHeight[len];
-      double lonWidth = hashLenToLonWidth[len];
-      if (latHeight < height || lonWidth < width)
-        return len-1;//previous length is big enough to encompass specified width & height
-    }
-    return MAX_PRECISION;
-  }
-
-  /** See the table at http://en.wikipedia.org/wiki/Geohash */
-  private static final double[] hashLenToLatHeight, hashLenToLonWidth;
-  static {
-    hashLenToLatHeight = new double[MAX_PRECISION +1];
-    hashLenToLonWidth = new double[MAX_PRECISION +1];
-    hashLenToLatHeight[0] = 90*2;
-    hashLenToLonWidth[0] = 180*2;
-    boolean even = false;
-    for(int i = 1; i <= MAX_PRECISION; i++) {
-      hashLenToLatHeight[i] = hashLenToLatHeight[i-1]/(even?8:4);
-      hashLenToLonWidth[i] = hashLenToLonWidth[i-1]/(even?4:8);
-      even = ! even;
-    }
-  }
-
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
deleted file mode 100644
index 6b156d3..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/package-info.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * The Spatial Prefix package supports spatial indexing by index-time tokens
- * where adding characters to a string gives greater resolution.
- *
- * Potential Implementations include:
- *  * http://en.wikipedia.org/wiki/Quadtree
- *  * http://en.wikipedia.org/wiki/Geohash
- *  * http://healpix.jpl.nasa.gov/
- */
-package org.apache.lucene.spatial.base.prefix;
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
deleted file mode 100644
index a1ea653..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/prefix/quad/QuadPrefixTree.java
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.quad;
-
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTreeFactory;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-
-import java.text.NumberFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-public class QuadPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      QuadPrefixTree grid = new QuadPrefixTree(ctx, MAX_LEVELS_POSSIBLE);
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new QuadPrefixTree(ctx,
-          maxLevels != null ? maxLevels : MAX_LEVELS_POSSIBLE);
-    }
-  }
-
-  public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
-
-  public static final int DEFAULT_MAX_LEVELS = 12;
-  private final double xmin;
-  private final double xmax;
-  private final double ymin;
-  private final double ymax;
-  private final double xmid;
-  private final double ymid;
-
-  private final double gridW;
-  public final double gridH;
-
-  final double[] levelW;
-  final double[] levelH;
-  final int[]    levelS; // side
-  final int[]    levelN; // number
-
-  public QuadPrefixTree(
-      SpatialContext ctx, Rectangle bounds, int maxLevels) {
-    super(ctx, maxLevels);
-    this.xmin = bounds.getMinX();
-    this.xmax = bounds.getMaxX();
-    this.ymin = bounds.getMinY();
-    this.ymax = bounds.getMaxY();
-
-    levelW = new double[maxLevels];
-    levelH = new double[maxLevels];
-    levelS = new int[maxLevels];
-    levelN = new int[maxLevels];
-
-    gridW = xmax - xmin;
-    gridH = ymax - ymin;
-    this.xmid = xmin + gridW/2.0;
-    this.ymid = ymin + gridH/2.0;
-    levelW[0] = gridW/2.0;
-    levelH[0] = gridH/2.0;
-    levelS[0] = 2;
-    levelN[0] = 4;
-
-    for (int i = 1; i < levelW.length; i++) {
-      levelW[i] = levelW[i - 1] / 2.0;
-      levelH[i] = levelH[i - 1] / 2.0;
-      levelS[i] = levelS[i - 1] * 2;
-      levelN[i] = levelN[i - 1] * 4;
-    }
-  }
-
-  public QuadPrefixTree(SpatialContext ctx) {
-    this(ctx, DEFAULT_MAX_LEVELS);
-  }
-
-  public QuadPrefixTree(
-      SpatialContext ctx, int maxLevels) {
-    this(ctx, ctx.getWorldBounds(), maxLevels);
-  }
-
-  public void printInfo() {
-    NumberFormat nf = NumberFormat.getNumberInstance();
-    nf.setMaximumFractionDigits(5);
-    nf.setMinimumFractionDigits(5);
-    nf.setMinimumIntegerDigits(3);
-
-    for (int i = 0; i < maxLevels; i++) {
-      System.out.println(i + "]\t" + nf.format(levelW[i]) + "\t" + nf.format(levelH[i]) + "\t" +
-          levelS[i] + "\t" + (levelS[i] * levelS[i]));
-    }
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    for (int i = 1; i < maxLevels; i++) {
-      //note: level[i] is actually a lookup for level i+1
-      if(dist > levelW[i] || dist > levelH[i]) {
-        return i;
-      }
-    }
-    return maxLevels;
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    List<Node> cells = new ArrayList<Node>(1);
-    build(xmid, ymid, 0, cells, new StringBuilder(), new PointImpl(p.getX(),p.getY()), level);
-    return cells.get(0);//note cells could be longer if p on edge
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new QuadCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new QuadCell(bytes, offset, len);
-  }
-
-  @Override //for performance
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (shape instanceof Point)
-      return super.getNodesAltPoint((Point) shape, detailLevel, inclParents);
-    else
-      return super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  private void build(
-      double x,
-      double y,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    // Z-Order
-    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
-    checkBattenberg('A', x - w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('B', x + w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('C', x - w, y - h, level, matches, str, shape, maxLevel);
-    checkBattenberg('D', x + w, y - h, level, matches, str, shape, maxLevel);
-
-    // possibly consider hilbert curve
-    // http://en.wikipedia.org/wiki/Hilbert_curve
-    // http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
-    // if we actually use the range property in the query, this could be useful
-  }
-
-  private void checkBattenberg(
-      char c,
-      double cx,
-      double cy,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    int strlen = str.length();
-    Rectangle rectangle = ctx.makeRect(cx - w, cx + w, cy - h, cy + h);
-    SpatialRelation v = shape.relate(rectangle, ctx);
-    if (SpatialRelation.CONTAINS == v) {
-      str.append(c);
-      //str.append(SpatialPrefixGrid.COVER);
-      matches.add(new QuadCell(str.toString(),v.transpose()));
-    } else if (SpatialRelation.DISJOINT == v) {
-      // nothing
-    } else { // SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
-      str.append(c);
-
-      int nextLevel = level+1;
-      if (nextLevel >= maxLevel) {
-        //str.append(SpatialPrefixGrid.INTERSECTS);
-        matches.add(new QuadCell(str.toString(),v.transpose()));
-      } else {
-        build(cx, cy, nextLevel, matches, str, shape, maxLevel);
-      }
-    }
-    str.setLength(strlen);
-  }
-
-  class QuadCell extends Node {
-
-    public QuadCell(String token) {
-      super(QuadPrefixTree.this, token);
-    }
-
-    public QuadCell(String token, SpatialRelation shapeRel) {
-      super(QuadPrefixTree.this, token);
-      this.shapeRel = shapeRel;
-    }
-
-    QuadCell(byte[] bytes, int off, int len) {
-      super(QuadPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      List<Node> cells = new ArrayList<Node>(4);
-      cells.add(new QuadCell(getTokenString()+"A"));
-      cells.add(new QuadCell(getTokenString()+"B"));
-      cells.add(new QuadCell(getTokenString()+"C"));
-      cells.add(new QuadCell(getTokenString()+"D"));
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 4;
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return QuadPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null)
-        shape = makeShape();
-      return shape;
-    }
-
-    private Rectangle makeShape() {
-      String token = getTokenString();
-      double xmin = QuadPrefixTree.this.xmin;
-      double ymin = QuadPrefixTree.this.ymin;
-
-      for (int i = 0; i < token.length(); i++) {
-        char c = token.charAt(i);
-        if ('A' == c || 'a' == c) {
-          ymin += levelH[i];
-        } else if ('B' == c || 'b' == c) {
-          xmin += levelW[i];
-          ymin += levelH[i];
-        } else if ('C' == c || 'c' == c) {
-          // nothing really
-        }
-        else if('D' == c || 'd' == c) {
-          xmin += levelW[i];
-        } else {
-          throw new RuntimeException("unexpected char: " + c);
-        }
-      }
-      int len = token.length();
-      double width, height;
-      if (len > 0) {
-        width = levelW[len-1];
-        height = levelH[len-1];
-      } else {
-        width = gridW;
-        height = gridH;
-      }
-      return ctx.makeRect(xmin, xmin + width, ymin, ymin + height);
-    }
-  }//QuadCell
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
deleted file mode 100644
index b604e92..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgs.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.query;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-public class SpatialArgs {
-
-  public static final double DEFAULT_DIST_PRECISION = 0.025d;
-
-  private SpatialOperation operation;
-  private Shape shape;
-  private double distPrecision = DEFAULT_DIST_PRECISION;
-
-  // Useful for 'distance' calculations
-  private Double min;
-  private Double max;
-
-  public SpatialArgs(SpatialOperation operation) {
-    this.operation = operation;
-  }
-
-  public SpatialArgs(SpatialOperation operation, Shape shape) {
-    this.operation = operation;
-    this.shape = shape;
-  }
-
-  /**
-   * Check if the arguments make sense -- throw an exception if not
-   */
-  public void validate() throws InvalidSpatialArgument {
-    if (operation.isTargetNeedsArea() && !shape.hasArea()) {
-      throw new InvalidSpatialArgument(operation + " only supports geometry with area");
-    }
-  }
-
-  public String toString( SpatialContext context ) {
-    StringBuilder str = new StringBuilder();
-    str.append( operation.getName() ).append( '(' );
-    str.append( context.toString( shape ) );
-    if( min != null ) {
-      str.append(" min=").append(min);
-    }
-    if( max != null ) {
-      str.append(" max=").append(max);
-    }
-    str.append(" distPrec=").append(String.format("%.2f%%", distPrecision/100d));
-    str.append( ')' );
-    return str.toString();
-  }
-
-  @Override
-  public String toString()
-  {
-    return toString( new SimpleSpatialContext(DistanceUnits.KILOMETERS) );
-  }
-
-  //------------------------------------------------
-  // Getters & Setters
-  //------------------------------------------------
-
-  public SpatialOperation getOperation() {
-    return operation;
-  }
-
-  public void setOperation(SpatialOperation operation) {
-    this.operation = operation;
-  }
-
-  /**
-   * Considers {@link SpatialOperation#BBoxWithin} in returning the shape.
-   */
-  public Shape getShape() {
-    if (shape != null && (operation == SpatialOperation.BBoxWithin || operation == SpatialOperation.BBoxIntersects))
-      return shape.getBoundingBox();
-    return shape;
-  }
-
-  public void setShape(Shape shape) {
-    this.shape = shape;
-  }
-
-  /**
-   * The fraction of the distance from the center of the query shape to its nearest edge that is considered acceptable
-   * error. The algorithm for computing the distance to the nearest edge is actually a little different. It normalizes
-   * the shape to a square given it's bounding box area:
-   * <pre>sqrt(shape.bbox.area)/2</pre>
-   * And the error distance is beyond the shape such that the shape is a minimum shape.
-   */
-  public Double getDistPrecision() {
-    return distPrecision;
-  }
-
-  public void setDistPrecision(Double distPrecision) {
-    if (distPrecision != null)
-      this.distPrecision = distPrecision;
-  }
-
-  public Double getMin() {
-    return min;
-  }
-
-  public void setMin(Double min) {
-    this.min = min;
-  }
-
-  public Double getMax() {
-    return max;
-  }
-
-  public void setMax(Double max) {
-    this.max = max;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
deleted file mode 100644
index 961dd25..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialArgsParser.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.query;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-public class SpatialArgsParser
-{
-  public SpatialArgs parse(String v, SpatialContext ctx) throws InvalidSpatialArgument, InvalidShapeException {
-    int idx = v.indexOf('(');
-    int edx = v.lastIndexOf(')');
-
-    if (idx < 0 || idx > edx) {
-      throw new InvalidSpatialArgument("missing parens: " + v, null);
-    }
-
-    SpatialOperation op = SpatialOperation.get(v.substring(0, idx).trim());
-
-    String body = v.substring(idx + 1, edx).trim();
-    if (body.length() < 1) {
-      throw new InvalidSpatialArgument("missing body : " + v, null);
-    }
-
-    Shape shape = ctx.readShape(body);
-    SpatialArgs args = new SpatialArgs(op,shape);
-
-    if (v.length() > (edx + 1)) {
-      body = v.substring( edx+1 ).trim();
-      if (body.length() > 0) {
-        Map<String,String> aa = parseMap(body);
-        args.setMin(readDouble(aa.remove("min")) );
-        args.setMax(readDouble(aa.remove("max")));
-        args.setDistPrecision(readDouble(aa.remove("distPrec")));
-        if (!aa.isEmpty()) {
-          throw new InvalidSpatialArgument("unused parameters: " + aa, null);
-        }
-      }
-    }
-    return args;
-  }
-
-  protected static Double readDouble(String v) {
-      return v == null ? null : Double.valueOf(v);
-  }
-
-  protected static boolean readBool(String v, boolean defaultValue) {
-      return v == null ? defaultValue : Boolean.parseBoolean(v);
-  }
-
-  protected static Map<String,String> parseMap(String body) {
-    Map<String,String> map = new HashMap<String,String>();
-    StringTokenizer st = new StringTokenizer(body, " \n\t");
-    while (st.hasMoreTokens()) {
-      String a = st.nextToken();
-      int idx = a.indexOf('=');
-      if (idx > 0) {
-        String k = a.substring(0, idx);
-        String v = a.substring(idx + 1);
-        map.put(k, v);
-      } else {
-        map.put(a, a);
-      }
-    }
-    return map;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
deleted file mode 100644
index b4be743..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/SpatialOperation.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/* See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * Esri Inc. licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.base.query;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-import org.apache.lucene.spatial.base.exception.InvalidSpatialArgument;
-
-/**
- * A clause that compares a stored geometry to a supplied geometry.
- */
-public class SpatialOperation implements Serializable {
-  // Private registry
-  private static final Map<String, SpatialOperation> registry = new HashMap<String, SpatialOperation>();
-  private static final List<SpatialOperation> list = new ArrayList<SpatialOperation>();
-
-  // Geometry Operations
-  public static final SpatialOperation BBoxIntersects = new SpatialOperation("BBoxIntersects", true, false, false);
-  public static final SpatialOperation BBoxWithin     = new SpatialOperation("BBoxWithin", true, false, false);
-  public static final SpatialOperation Contains       = new SpatialOperation("Contains", true, true, false);
-  public static final SpatialOperation Intersects     = new SpatialOperation("Intersects", true, false, false);
-  public static final SpatialOperation IsEqualTo      = new SpatialOperation("IsEqualTo", false, false, false);
-  public static final SpatialOperation IsDisjointTo   = new SpatialOperation("IsDisjointTo", false, false, false);
-  public static final SpatialOperation IsWithin       = new SpatialOperation("IsWithin", true, false, true);
-  public static final SpatialOperation Overlaps       = new SpatialOperation("Overlaps", true, false, true);
-
-  // Member variables
-  private final boolean scoreIsMeaningful;
-  private final boolean sourceNeedsArea;
-  private final boolean targetNeedsArea;
-  private final String name;
-
-  protected SpatialOperation(String name, boolean scoreIsMeaningful, boolean sourceNeedsArea, boolean targetNeedsArea) {
-    this.name = name;
-    this.scoreIsMeaningful = scoreIsMeaningful;
-    this.sourceNeedsArea = sourceNeedsArea;
-    this.targetNeedsArea = targetNeedsArea;
-    registry.put(name, this);
-    registry.put(name.toUpperCase(Locale.US), this);
-    list.add( this );
-  }
-
-  public static SpatialOperation get( String v ) {
-    SpatialOperation op = registry.get( v );
-    if( op == null ) {
-      op = registry.get(v.toUpperCase(Locale.US));
-    }
-    if( op == null ) {
-      throw new InvalidSpatialArgument("Unknown Operation: " + v );
-    }
-    return op;
-  }
-
-  public static List<SpatialOperation> values() {
-    return list;
-  }
-
-  public static boolean is( SpatialOperation op, SpatialOperation ... tst ) {
-    for( SpatialOperation t : tst ) {
-      if( op == t ) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-
-  // ================================================= Getters / Setters =============================================
-
-  public boolean isScoreIsMeaningful() {
-    return scoreIsMeaningful;
-  }
-
-  public boolean isSourceNeedsArea() {
-    return sourceNeedsArea;
-  }
-
-  public boolean isTargetNeedsArea() {
-    return targetNeedsArea;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  @Override
-  public String toString() {
-    return name;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java
deleted file mode 100644
index ded6980..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/query/package-info.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * Lucene spatial Query options
- * <ul>
- *  <li>useful for client side requets</li>
- * </ul>
- */
-package org.apache.lucene.spatial.base.query;
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java
deleted file mode 100644
index ad718f3..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Circle.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-/**
- * This is basically a circle.
- */
-public interface Circle extends Shape {
-  double getDistance();
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
deleted file mode 100644
index d2e6873..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/MultiShape.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-import java.util.Collection;
-
-/**
- * A collection of Shape objects.
- */
-public class MultiShape implements Shape {
-  private final Collection<Shape> geoms;
-  private final Rectangle bbox;
-
-  public MultiShape(Collection<Shape> geoms, SpatialContext ctx) {
-    this.geoms = geoms;
-    double minX = Double.MAX_VALUE;
-    double minY = Double.MAX_VALUE;
-    double maxX = Double.MIN_VALUE;
-    double maxY = Double.MIN_VALUE;
-    for (Shape geom : geoms) {
-      Rectangle r = geom.getBoundingBox();
-      minX = Math.min(minX,r.getMinX());
-      minY = Math.min(minY,r.getMinY());
-      maxX = Math.max(maxX,r.getMaxX());
-      maxY = Math.max(maxY,r.getMaxY());
-    }
-    this.bbox = ctx.makeRect(minX, maxX, minY, maxY);
-  }
-
-  @Override
-  public Rectangle getBoundingBox() {
-    return bbox;
-  }
-
-  @Override
-  public Point getCenter() {
-    return bbox.getCenter();
-  }
-
-  @Override
-  public boolean hasArea() {
-    for (Shape geom : geoms) {
-      if( geom.hasArea() ) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    boolean allOutside = true;
-    boolean allContains = true;
-    for (Shape geom : geoms) {
-      SpatialRelation sect = geom.relate(other, ctx);
-      if (sect != SpatialRelation.DISJOINT)
-        allOutside = false;
-      if (sect != SpatialRelation.CONTAINS)
-        allContains = false;
-      if (!allContains && !allOutside)
-        return SpatialRelation.INTERSECTS;//short circuit
-    }
-    if (allOutside)
-      return SpatialRelation.DISJOINT;
-    if (allContains)
-      return SpatialRelation.CONTAINS;
-    return SpatialRelation.INTERSECTS;
-  }
-
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    MultiShape rhs = (MultiShape) obj;
-    return new EqualsBuilder()
-                  .append(geoms, rhs.geoms)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(83, 29).append(geoms.hashCode()).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java
deleted file mode 100644
index fd66020..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Point.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-public interface Point extends Shape {
-
-  public double getX();
-  public double getY();
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
deleted file mode 100644
index f0935ff..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Rectangle.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-public interface Rectangle extends Shape {
-
-  public double getWidth();
-  public double getHeight();
-
-  public double getMinX();
-  public double getMinY();
-  public double getMaxX();
-  public double getMaxY();
-
-  /** If {@link #hasArea()} then this returns the area, otherwise it returns 0. */
-  public double getArea();
-  /** Only meaningful for geospatial contexts. */
-  public boolean getCrossesDateLine();
-
-  /* There is no axis line shape, and this is more efficient then creating a flat Rectangle for intersect(). */
-  public SpatialRelation relate_yRange(double minY, double maxY, SpatialContext ctx);
-  public SpatialRelation relate_xRange(double minX, double maxX, SpatialContext ctx);
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java
deleted file mode 100644
index 3292c11..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/Shape.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-
-public interface Shape {
-
-  /**
-   * Describe the relationship between the two objects.  For example
-   *
-   *   this is WITHIN other
-   *   this CONTAINS other
-   *   this is DISJOINT other
-   *   this INTERSECTS other
-   *
-   * The context object is optional -- it may include spatial reference.
-   */
-  SpatialRelation relate(Shape other, SpatialContext ctx);
-
-  /**
-   * Get the bounding box for this Shape
-   */
-  Rectangle getBoundingBox();
-
-  /**
-   * @return true if the shape has area.  This will be false for points and lines
-   */
-  boolean hasArea();
-
-  Point getCenter();
-}
-
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
deleted file mode 100644
index 4669433..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/SpatialRelation.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-/**
- * The set of spatial relationships.  Naming is consistent with OGC spec conventions as seen in SQL/MM and others.
- * No equality case.  If two Shape instances are equal then the result might be CONTAINS or WITHIN, and
- * some logic might fail under this edge condition when it's not careful to check.
- * Client code must be written to detect this and act accordingly.  In RectangleImpl.relate(), it checks
- * for this explicitly, for example.  TestShapes2D.assertRelation() checks too.
- */
-public enum SpatialRelation {
-  WITHIN,
-  CONTAINS,
-  DISJOINT,
-  INTERSECTS;
-  //Don't have these: TOUCHES, CROSSES, OVERLAPS
-
-  public SpatialRelation transpose() {
-    switch(this) {
-      case CONTAINS: return SpatialRelation.WITHIN;
-      case WITHIN: return SpatialRelation.CONTAINS;
-      default: return this;
-    }
-  }
-
-  /**
-   * If you were to call aShape.relate(bShape) and aShape.relate(cShape), you could call
-   * this to merge the intersect results as if bShape & cShape were combined into {@link MultiShape}.
-   * @param other
-   */
-  public SpatialRelation combine(SpatialRelation other) {
-    if (this == other)
-      return this;
-    if (this == WITHIN || other == WITHIN)
-      return WITHIN;
-    return INTERSECTS;
-  }
-
-  public boolean intersects() {
-    return this != DISJOINT;
-  }
-
-  /** Not commutative!  WITHIN.inverse().inverse() != WITHIN. */
-  public SpatialRelation inverse() {
-    switch(this) {
-      case DISJOINT: return CONTAINS;
-      case CONTAINS: return DISJOINT;
-      case WITHIN: return INTERSECTS;//not commutative!
-    }
-    return INTERSECTS;
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
deleted file mode 100644
index 4f195fa..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/CircleImpl.java
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.*;
-
-/**
- * A circle, also known as a point-radius, based on a
- * {@link org.apache.lucene.spatial.base.distance.DistanceCalculator} which does all the work. This implementation
- * should work for both cartesian 2D and geodetic sphere surfaces.
- * Threadsafe & immutable.
- */
-public class CircleImpl implements Circle {
-
-  protected final Point point;
-  protected final double distance;
-
-  protected final SpatialContext ctx;
-
-  /* below is calculated & cached: */
-  
-  protected final Rectangle enclosingBox;
-
-  //we don't have a line shape so we use a rectangle for these axis
-
-  public CircleImpl(Point p, double dist, SpatialContext ctx) {
-    //We assume any normalization / validation of params already occurred (including bounding dist)
-    this.point = p;
-    this.distance = dist;
-    this.ctx = ctx;
-    this.enclosingBox = ctx.getDistCalc().calcBoxByDistFromPt(point, distance, ctx);
-  }
-
-  public Point getCenter() {
-    return point;
-  }
-
-  @Override
-  public double getDistance() {
-    return distance;
-  }
-
-  public boolean contains(double x, double y) {
-    return ctx.getDistCalc().distance(point, x, y) <= distance;
-  }
-
-  @Override
-  public boolean hasArea() {
-    return distance > 0;
-  }
-
-  /**
-   * Note that the bounding box might contain a minX that is > maxX, due to WGS84 dateline.
-   */
-  @Override
-  public Rectangle getBoundingBox() {
-    return enclosingBox;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    assert this.ctx == ctx;
-//This shortcut was problematic in testing due to distinctions of CONTAINS/WITHIN for no-area shapes (lines, points).
-//    if (distance == 0) {
-//      return point.relate(other,ctx).intersects() ? SpatialRelation.WITHIN : SpatialRelation.DISJOINT;
-//    }
-
-    if (other instanceof Point) {
-      return relate((Point) other, ctx);
-    }
-    if (other instanceof Rectangle) {
-      return relate((Rectangle) other, ctx);
-    }
-    if (other instanceof Circle) {
-      return relate((Circle) other, ctx);
-    }
-    return other.relate(this, ctx).transpose();
-  }
-
-  public SpatialRelation relate(Point point, SpatialContext ctx) {
-    return contains(point.getX(),point.getY()) ? SpatialRelation.CONTAINS : SpatialRelation.DISJOINT;
-  }
-
-  public SpatialRelation relate(Rectangle r, SpatialContext ctx) {
-    //Note: Surprisingly complicated!
-
-    //--We start by leveraging the fact we have a calculated bbox that is "cheaper" than use of DistanceCalculator.
-    final SpatialRelation bboxSect = enclosingBox.relate(r, ctx);
-    if (bboxSect == SpatialRelation.DISJOINT || bboxSect == SpatialRelation.WITHIN)
-      return bboxSect;
-    else if (bboxSect == SpatialRelation.CONTAINS && enclosingBox.equals(r))//nasty identity edge-case
-      return SpatialRelation.WITHIN;
-    //bboxSect is INTERSECTS or CONTAINS
-    //The result can be DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
-
-    return relateRectanglePhase2(r, bboxSect, ctx);
-  }
-
-  protected SpatialRelation relateRectanglePhase2(final Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
-    /*
-     !! DOES NOT WORK WITH GEO CROSSING DATELINE OR WORLD-WRAP.
-     TODO upgrade to handle crossing dateline, but not world-wrap; use some x-shifting code from RectangleImpl.
-     */
-
-    //At this point, the only thing we are certain of is that circle is *NOT* WITHIN r, since the bounding box of a
-    // circle MUST be within r for the circle to be within r.
-
-    //--Quickly determine if they are DISJOINT or not.
-    //see http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection/1879223#1879223
-    final double closestX;
-    double ctr_x = getXAxis();
-    if ( ctr_x < r.getMinX() )
-      closestX = r.getMinX();
-    else if (ctr_x > r.getMaxX())
-      closestX = r.getMaxX();
-    else
-      closestX = ctr_x;
-
-    final double closestY;
-    double ctr_y = getYAxis();
-    if ( ctr_y < r.getMinY() )
-      closestY = r.getMinY();
-    else if (ctr_y > r.getMaxY())
-      closestY = r.getMaxY();
-    else
-      closestY = ctr_y;
-
-    //Check if there is an intersection from this circle to closestXY
-    boolean didContainOnClosestXY = false;
-    if (ctr_x == closestX) {
-      double deltaY = Math.abs(ctr_y - closestY);
-      double distYCirc = (ctr_y < closestY ? enclosingBox.getMaxY() - ctr_y : ctr_y - enclosingBox.getMinY());
-      if (deltaY > distYCirc)
-        return SpatialRelation.DISJOINT;
-    } else if (ctr_y == closestY) {
-      double deltaX = Math.abs(ctr_x - closestX);
-      double distXCirc = (ctr_x < closestX ? enclosingBox.getMaxX() - ctr_x : ctr_x - enclosingBox.getMinX());
-      if (deltaX > distXCirc)
-        return SpatialRelation.DISJOINT;
-    } else {
-      //fallback on more expensive calculation
-      didContainOnClosestXY = true;
-      if(! contains(closestX,closestY) )
-        return SpatialRelation.DISJOINT;
-    }
-
-    //At this point we know that it's *NOT* DISJOINT, so there is some level of intersection. It's *NOT* WITHIN either.
-    // The only question left is whether circle CONTAINS r or simply intersects it.
-
-    //If circle contains r, then its bbox MUST also CONTAIN r.
-    if (bboxSect != SpatialRelation.CONTAINS)
-      return SpatialRelation.INTERSECTS;
-
-    //Find the farthest point of r away from the center of the circle. If that point is contained, then all of r is
-    // contained.
-    double farthestX = r.getMaxX() - ctr_x > ctr_x - r.getMinX() ? r.getMaxX() : r.getMinX();
-    double farthestY = r.getMaxY() - ctr_y > ctr_y - r.getMinY() ? r.getMaxY() : r.getMinY();
-    if (contains(farthestX,farthestY))
-      return SpatialRelation.CONTAINS;
-    return SpatialRelation.INTERSECTS;
-  }
-
-  /**
-   * The y axis horizontal of maximal left-right extent of the circle.
-   */
-  protected double getYAxis() {
-    return point.getY();
-  }
-
-  protected double getXAxis() {
-    return point.getX();
-  }
-
-  public SpatialRelation relate(Circle circle, SpatialContext ctx) {
-    double crossDist = ctx.getDistCalc().distance(point, circle.getCenter());
-    double aDist = distance, bDist = circle.getDistance();
-    if (crossDist > aDist + bDist)
-      return SpatialRelation.DISJOINT;
-    if (crossDist < aDist && crossDist + bDist <= aDist)
-      return SpatialRelation.CONTAINS;
-    if (crossDist < bDist && crossDist + aDist <= bDist)
-      return SpatialRelation.WITHIN;
-
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public String toString() {
-    return "Circle(" + point + ",d=" + distance + ')';
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    CircleImpl rhs = (CircleImpl) obj;
-    return new EqualsBuilder()
-                  .append(point, rhs.point)
-                  .append(distance, rhs.distance)
-                  .append(ctx, rhs.ctx)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(11, 97).
-      append(point).
-      append(distance).
-      append(ctx).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
deleted file mode 100644
index 297d043..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/GeoCircleImpl.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-
-
-public class GeoCircleImpl extends CircleImpl {
-  private final double distDEG;// [0 TO 180]
-  private final GeoCircleImpl inverseCircle;//when distance reaches > 1/2 way around the world, cache the inverse.
-  private final double horizAxisY;//see getYAxis
-
-  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {
-    super(p, dist, ctx);
-    assert ctx.isGeo();
-
-    //In the direction of latitude (N,S), distance is the same number of degrees.
-    distDEG = ctx.getDistCalc().distanceToDegrees(distance);
-
-    if (distDEG > 90) {
-      assert enclosingBox.getWidth() == 360;
-      double backDistDEG = 180 - distDEG;
-      if (backDistDEG >= 0) {
-        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);
-        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);
-        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);
-      } else
-        inverseCircle = null;//whole globe
-      horizAxisY = getCenter().getY();//although probably not used
-    } else {
-      inverseCircle = null;
-      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);
-      //some rare numeric conditioning cases can cause this to be barely beyond the box
-      if (_horizAxisY > enclosingBox.getMaxY()) {
-        horizAxisY = enclosingBox.getMaxY();
-      } else if (_horizAxisY < enclosingBox.getMinY()) {
-        horizAxisY = enclosingBox.getMinY();
-      } else {
-        horizAxisY = _horizAxisY;
-      }
-      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();
-    }
-
-  }
-
-  @Override
-  protected double getYAxis() {
-    return horizAxisY;
-  }
-
-  /**
-   * Called after bounding box is intersected.
-   * @param bboxSect INTERSECTS or CONTAINS from enclosingBox's intersection
-   * @return DISJOINT, CONTAINS, or INTERSECTS (not WITHIN)
-   */
-  @Override
-  protected SpatialRelation relateRectanglePhase2(Rectangle r, SpatialRelation bboxSect, SpatialContext ctx) {
-
-    //Rectangle wraps around the world longitudinally creating a solid band; there are no corners to test intersection
-    if (r.getWidth() == 360) {
-      return SpatialRelation.INTERSECTS;
-    }
-
-    if (inverseCircle != null) {
-      return inverseCircle.relate(r, ctx).inverse();
-    }
-
-    //if a pole is wrapped, we have a separate algorithm
-    if (enclosingBox.getWidth() == 360) {
-      return relateRectangleCircleWrapsPole(r, ctx);
-    }
-
-    //This is an optimization path for when there are no dateline or pole issues.
-    if (!enclosingBox.getCrossesDateLine() && !r.getCrossesDateLine()) {
-      return super.relateRectanglePhase2(r, bboxSect, ctx);
-    }
-
-    //do quick check to see if all corners are within this circle for CONTAINS
-    int cornersIntersect = numCornersIntersect(r);
-    if (cornersIntersect == 4) {
-      //ensure r's x axis is within c's.  If it doesn't, r sneaks around the globe to touch the other side (intersect).
-      SpatialRelation xIntersect = r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx);
-      if (xIntersect == SpatialRelation.WITHIN)
-        return SpatialRelation.CONTAINS;
-      return SpatialRelation.INTERSECTS;
-    }
-
-    //INTERSECT or DISJOINT ?
-    if (cornersIntersect > 0)
-      return SpatialRelation.INTERSECTS;
-
-    //Now we check if one of the axis of the circle intersect with r.  If so we have
-    // intersection.
-
-    /* x axis intersects  */
-    if ( r.relate_yRange(getYAxis(), getYAxis(), ctx).intersects() // at y vertical
-          && r.relate_xRange(enclosingBox.getMinX(), enclosingBox.getMaxX(), ctx).intersects() )
-      return SpatialRelation.INTERSECTS;
-
-    /* y axis intersects */
-    if (r.relate_xRange(getXAxis(), getXAxis(), ctx).intersects()) { // at x horizontal
-      double yTop = getCenter().getY()+ distDEG;
-      assert yTop <= 90;
-      double yBot = getCenter().getY()- distDEG;
-      assert yBot >= -90;
-      if (r.relate_yRange(yBot, yTop, ctx).intersects())//back bottom
-        return SpatialRelation.INTERSECTS;
-    }
-
-    return SpatialRelation.DISJOINT;
-  }
-
-  private SpatialRelation relateRectangleCircleWrapsPole(Rectangle r, SpatialContext ctx) {
-    //This method handles the case where the circle wraps ONE pole, but not both.  For both,
-    // there is the inverseCircle case handled before now.  The only exception is for the case where
-    // the circle covers the entire globe, and we'll check that first.
-    if (distDEG == 180)//whole globe
-      return SpatialRelation.CONTAINS;
-
-    //Check if r is within the pole wrap region:
-    double yTop = getCenter().getY()+ distDEG;
-    if (yTop > 90) {
-      double yTopOverlap = yTop - 90;
-      assert yTopOverlap <= 90;
-      if (r.getMinY() >= 90 - yTopOverlap)
-        return SpatialRelation.CONTAINS;
-    } else {
-      double yBot = point.getY() - distDEG;
-      if (yBot < -90) {
-        double yBotOverlap = -90 - yBot;
-        assert yBotOverlap <= 90;
-        if (r.getMaxY() <= -90 + yBotOverlap)
-          return SpatialRelation.CONTAINS;
-      } else {
-        //This point is probably not reachable ??
-        assert yTop == 90 || yBot == -90;//we simply touch a pole
-        //continue
-      }
-    }
-
-    //If there are no corners to check intersection because r wraps completely...
-    if (r.getWidth() == 360)
-      return SpatialRelation.INTERSECTS;
-
-    //Check corners:
-    int cornersIntersect = numCornersIntersect(r);
-    // (It might be possible to reduce contains() calls within nCI() to exactly two, but this intersection
-    //  code is complicated enough as it is.)
-    if (cornersIntersect == 4) {//all
-      double backX = ctx.normX(getCenter().getX()+180);
-      if (r.relate_xRange(backX, backX, ctx).intersects())
-        return SpatialRelation.INTERSECTS;
-      else
-        return SpatialRelation.CONTAINS;
-    } else if (cornersIntersect == 0) {//none
-      double frontX = getCenter().getX();
-      if (r.relate_xRange(frontX, frontX, ctx).intersects())
-        return SpatialRelation.INTERSECTS;
-      else
-        return SpatialRelation.DISJOINT;
-    } else//partial
-      return SpatialRelation.INTERSECTS;
-  }
-
-  /** Returns either 0 for none, 1 for some, or 4 for all. */
-  private int numCornersIntersect(Rectangle r) {
-    //We play some logic games to avoid calling contains() which can be expensive.
-    boolean bool;//if true then all corners intersect, if false then no corners intersect
-    // for partial, we exit early with 1 and ignore bool.
-    bool = (contains(r.getMinX(),r.getMinY()));
-    if (contains(r.getMinX(),r.getMaxY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    if (contains(r.getMaxX(),r.getMinY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    if (contains(r.getMaxX(),r.getMaxY())) {
-      if (!bool)
-        return 1;//partial
-    } else {
-      if (bool)
-        return 1;//partial
-    }
-    return bool?4:0;
-  }
-
-  @Override
-  public String toString() {
-    //I'm deliberately making this look basic and not fully detailed with class name & misc fields.
-    //Add distance in degrees, which is easier to recognize, and earth radius agnostic.
-    String dStr = String.format("%.1f",distance);
-    if (ctx.isGeo()) {
-      double distDEG = ctx.getDistCalc().distanceToDegrees(distance);
-      dStr += String.format("=%.1f\u00B0",distDEG);
-    }
-    return "Circle(" + point + ",d=" + dStr + ')';
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
deleted file mode 100644
index 054e901..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/PointImpl.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
-
-
-public class PointImpl implements Point {
-
-  private final double x;
-  private final double y;
-
-  public PointImpl(double x, double y) {
-    this.x = x;
-    this.y = y;
-  }
-
-  @Override
-  public double getX() {
-    return x;
-  }
-
-  @Override
-  public double getY() {
-    return y;
-  }
-  @Override
-  public Rectangle getBoundingBox() {
-    return new RectangleImpl(x, x, y, y);
-  }
-
-  @Override
-  public PointImpl getCenter() {
-    return this;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    if (other instanceof Point)
-      return this.equals(other) ? SpatialRelation.INTERSECTS : SpatialRelation.DISJOINT;
-    return other.relate(this, ctx).transpose();
-  }
-
-  @Override
-  public boolean hasArea() {
-    return false;
-  }
-
-  @Override
-  public String toString() {
-    return "Pt(x="+x+",y="+y+")";
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    PointImpl rhs = (PointImpl) obj;
-    return new EqualsBuilder()
-                  .append(x, rhs.x)
-                  .append(y, rhs.y)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(5, 89).
-      append(x).
-      append(y).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java b/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
deleted file mode 100644
index fb8e3c8..0000000
--- a/modules/spatial/base/src/java/org/apache/lucene/spatial/base/shape/simple/RectangleImpl.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape.simple;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.shape.*;
-
-/**
- * A simple Rectangle implementation that also supports a longitudinal wrap-around. When minX > maxX, this will assume
- * it is world coordinates that cross the date line using degrees.
- * Immutable & threadsafe.
- */
-public class RectangleImpl implements Rectangle {
-
-  private final double minX;
-  private final double maxX;
-  private final double minY;
-  private final double maxY;
-
-  //TODO change to West South East North to be more consistent with OGC?
-  public RectangleImpl(double minX, double maxX, double minY, double maxY) {
-    //We assume any normalization / validation of params already occurred.
-    this.minX = minX;
-    this.maxX = maxX;
-    this.minY = minY;
-    this.maxY = maxY;
-    assert minY <= maxY;
-  }
-
-  /** Copy constructor. */
-  public RectangleImpl(Rectangle r) {
-    this(r.getMinX(),r.getMaxX(),r.getMinY(),r.getMaxY());
-  }
-
-  @Override
-  public boolean hasArea() {
-    return maxX != minX && maxY != minY;
-  }
-
-  @Override
-  public double getArea() {
-    return getWidth() * getHeight();
-  }
-
-  @Override
-  public boolean getCrossesDateLine() {
-    return (minX > maxX);
-  }
-
-  @Override
-  public double getHeight() {
-    return maxY - minY;
-  }
-
-  @Override
-  public double getWidth() {
-    double w = maxX - minX;
-    if (w < 0) {//only true when minX > maxX (WGS84 assumed)
-      w += 360;
-      assert w >= 0;
-    }
-    return w;
-  }
-
-  @Override
-  public double getMaxX() {
-    return maxX;
-  }
-
-  @Override
-  public double getMaxY() {
-    return maxY;
-  }
-
-  @Override
-  public double getMinX() {
-    return minX;
-  }
-
-  @Override
-  public double getMinY() {
-    return minY;
-  }
-
-  @Override
-  public Rectangle getBoundingBox() {
-    return this;
-  }
-
-  @Override
-  public SpatialRelation relate(Shape other, SpatialContext ctx) {
-    if (other instanceof Point) {
-      return relate((Point) other, ctx);
-    }
-    if (other instanceof Rectangle) {
-      return relate((Rectangle) other, ctx);
-    }
-    return other.relate(this, ctx).transpose();
-  }
-
-  public SpatialRelation relate(Point point, SpatialContext ctx) {
-    if (point.getY() > getMaxY() || point.getY() < getMinY() ||
-        (getCrossesDateLine() ?
-            (point.getX() < minX && point.getX() > maxX)
-            : (point.getX() < minX || point.getX() > maxX) ))
-      return SpatialRelation.DISJOINT;
-    return SpatialRelation.CONTAINS;
-  }
-
-  public SpatialRelation relate(Rectangle rect, SpatialContext ctx) {
-    SpatialRelation yIntersect = relate_yRange(rect.getMinY(), rect.getMaxY(), ctx);
-    if (yIntersect == SpatialRelation.DISJOINT)
-      return SpatialRelation.DISJOINT;
-
-    SpatialRelation xIntersect = relate_xRange(rect.getMinX(), rect.getMaxX(), ctx);
-    if (xIntersect == SpatialRelation.DISJOINT)
-      return SpatialRelation.DISJOINT;
-
-    if (xIntersect == yIntersect)//in agreement
-      return xIntersect;
-
-    //if one side is equal, return the other
-    if (getMinX() == rect.getMinX() && getMaxX() == rect.getMaxX())
-      return yIntersect;
-    if (getMinY() == rect.getMinY() && getMaxY() == rect.getMaxY())
-      return xIntersect;
-
-    return SpatialRelation.INTERSECTS;
-  }
-
-  public SpatialRelation relate_yRange(double ext_minY, double ext_maxY, SpatialContext ctx) {
-    if (ext_minY > maxY || ext_maxY < minY) {
-      return SpatialRelation.DISJOINT;
-    }
-
-    if (ext_minY >= minY && ext_maxY <= maxY) {
-      return SpatialRelation.CONTAINS;
-    }
-
-    if (ext_minY <= minY && ext_maxY >= maxY) {
-      return SpatialRelation.WITHIN;
-    }
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public SpatialRelation relate_xRange(double ext_minX, double ext_maxX, SpatialContext ctx) {
-    //For ext & this we have local minX and maxX variable pairs. We rotate them so that minX <= maxX
-    double minX = this.minX;
-    double maxX = this.maxX;
-    if (ctx.isGeo()) {
-      //the 360 check is an edge-case for complete world-wrap
-      double ext_width = ext_maxX - ext_minX;
-      if (ext_width < 0)//this logic unfortunately duplicates getWidth()
-        ext_width += 360;
-
-      if (ext_width < 360) {
-        ext_maxX = ext_minX + ext_width;
-      } else {
-        ext_maxX = 180+360;
-      }
-
-      if (getWidth() < 360) {
-        maxX = minX + getWidth();
-      } else {
-        maxX = 180+360;
-      }
-
-      if (maxX < ext_minX) {
-        minX += 360;
-        maxX += 360;
-      } else if (ext_maxX < minX) {
-        ext_minX += 360;
-        ext_maxX += 360;
-      }
-    }
-
-    if (ext_minX > maxX || ext_maxX < minX ) {
-      return SpatialRelation.DISJOINT;
-    }
-
-    if (ext_minX >= minX && ext_maxX <= maxX ) {
-      return SpatialRelation.CONTAINS;
-    }
-
-    if (ext_minX <= minX && ext_maxX >= maxX ) {
-      return SpatialRelation.WITHIN;
-    }
-    return SpatialRelation.INTERSECTS;
-  }
-
-  @Override
-  public String toString() {
-    return "Rect(minX=" + minX + ",maxX=" + maxX + ",minY=" + minY + ",maxY=" + maxY + ")";
-  }
-
-  @Override
-  public Point getCenter() {
-    final double y = getHeight() / 2 + minY;
-    double x = getWidth() / 2 + minX;
-    if (minX > maxX)//WGS84
-      x = DistanceUtils.normLonDEG(x);
-    return new PointImpl(x, y);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    RectangleImpl rhs = (RectangleImpl) obj;
-    return new EqualsBuilder()
-                  .append(minX, rhs.minX)
-                  .append(minY, rhs.minY)
-                  .append(maxX, rhs.maxX)
-                  .append(maxY, rhs.maxY)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(41, 37).
-    append(minX).append(minY).
-    append(maxX).append(maxY).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/base/src/java/overview.html b/modules/spatial/base/src/java/overview.html
deleted file mode 100644
index 65d1c29..0000000
--- a/modules/spatial/base/src/java/overview.html
+++ /dev/null
@@ -1,23 +0,0 @@
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-  <head>
-    <title>Apache Lucene Spatial Base</title>
-  </head>
-  <body>
-  </body>
-</html>
\ No newline at end of file
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/BaseSpatialContextTestCase.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/BaseSpatialContextTestCase.java
deleted file mode 100644
index b2c228e..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/BaseSpatialContextTestCase.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.query.SpatialArgsParser;
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-import org.apache.lucene.spatial.base.shape.MultiShape;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.CircleImpl;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.io.IOException;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-
-/**
- */
-@SuppressWarnings("unchecked")
-public abstract class BaseSpatialContextTestCase {
-
-  protected abstract SpatialContext getSpatialContext();
-
-  public static void checkArgParser(SpatialContext ctx) {
-    SpatialArgsParser parser = new SpatialArgsParser();
-
-    String arg = SpatialOperation.IsWithin + "(-10 -20 10 20)";
-    SpatialArgs out = parser.parse(arg, ctx);
-    assertEquals(SpatialOperation.IsWithin, out.getOperation());
-    Rectangle bounds = (Rectangle) out.getShape();
-    assertEquals(-10.0, bounds.getMinX(), 0D);
-    assertEquals(10.0, bounds.getMaxX(), 0D);
-
-    // Disjoint should not be scored
-    arg = SpatialOperation.IsDisjointTo + " (-10 10 -20 20)";
-    out = parser.parse(arg, ctx);
-    assertEquals(SpatialOperation.IsDisjointTo, out.getOperation());
-
-    try {
-      parser.parse(SpatialOperation.IsDisjointTo + "[ ]", ctx);
-      fail("spatial operations need args");
-    }
-    catch (Exception ex) {//expected
-    }
-
-    try {
-      parser.parse("XXXX(-10 10 -20 20)", ctx);
-      fail("unknown operation!");
-    }
-    catch (Exception ex) {//expected
-    }
-  }
-
-  public static void checkShapesImplementEquals( Class[] classes ) {
-
-    for( Class clazz : classes ) {
-      try {
-        clazz.getDeclaredMethod( "equals", Object.class );
-      } catch (Exception e) {
-        Assert.fail( "Shape needs to define 'equals' : " + clazz.getName() );
-      }
-      try {
-        clazz.getDeclaredMethod( "hashCode" );
-      } catch (Exception e) {
-        Assert.fail( "Shape needs to define 'hashCode' : " + clazz.getName() );
-      }
-    }
-  }
-
-  public static interface WriteReader {
-    Shape writeThenRead( Shape s ) throws IOException;
-  }
-
-  public static void checkBasicShapeIO( SpatialContext ctx, WriteReader help ) throws Exception {
-
-    // Simple Point
-    Shape s = ctx.readShape("10 20");
-    assertEquals(s,ctx.readShape("20,10"));//check comma for y,x format
-    assertEquals(s,ctx.readShape("20, 10"));//test space
-    Point p = (Point) s;
-    assertEquals(10.0, p.getX(), 0D);
-    assertEquals(20.0, p.getY(), 0D);
-    p = (Point) help.writeThenRead(s);
-    assertEquals(10.0, p.getX(), 0D);
-    assertEquals(20.0, p.getY(), 0D);
-    Assert.assertFalse(s.hasArea());
-
-    // BBOX
-    s = ctx.readShape("-10 -20 10 20");
-    Rectangle b = (Rectangle) s;
-    assertEquals(-10.0, b.getMinX(), 0D);
-    assertEquals(-20.0, b.getMinY(), 0D);
-    assertEquals(10.0, b.getMaxX(), 0D);
-    assertEquals(20.0, b.getMaxY(), 0D);
-    b = (Rectangle) help.writeThenRead(s);
-    assertEquals(-10.0, b.getMinX(), 0D);
-    assertEquals(-20.0, b.getMinY(), 0D);
-    assertEquals(10.0, b.getMaxX(), 0D);
-    assertEquals(20.0, b.getMaxY(), 0D);
-    Assert.assertTrue(s.hasArea());
-
-    // Point/Distance
-    s = ctx.readShape("Circle( 1.23 4.56 distance=7.89)");
-    CircleImpl circle = (CircleImpl)s;
-    assertEquals(1.23, circle.getCenter().getX(), 0D);
-    assertEquals(4.56, circle.getCenter().getY(), 0D);
-    assertEquals(7.89, circle.getDistance(), 0D);
-    Assert.assertTrue(s.hasArea());
-
-    Shape s2 = ctx.readShape("Circle( 4.56,1.23 d=7.89 )"); // use lat,lon and use 'd' abbreviation
-    assertEquals(s,s2);
-  }
-
-  //--------------------------------------------------------------
-  // Actual tests
-  //--------------------------------------------------------------
-
-  @Test
-  public void testArgsParser() throws Exception {
-    checkArgParser( getSpatialContext() );
-  }
-
-  @Test
-  public void testImplementsEqualsAndHash() throws Exception {
-    checkShapesImplementEquals( new Class[] {
-      PointImpl.class,
-      CircleImpl.class,
-      RectangleImpl.class,
-      MultiShape.class,
-    });
-  }
-
-  @Test
-  public void testSimpleShapeIO() throws Exception {
-    final SpatialContext io =  getSpatialContext();
-    checkBasicShapeIO( io, new WriteReader() {
-      @Override
-      public Shape writeThenRead(Shape s) {
-        String buff = io.toString( s );
-        return io.readShape( buff );
-      }
-    });
-  }
-
-  //Looking for more tests?  Shapes are tested in TestShapes2D.
-
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextFactoryTest.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextFactoryTest.java
deleted file mode 100644
index 9462b32..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextFactoryTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.CartesianDistCalc;
-import org.apache.lucene.spatial.base.distance.GeodesicSphereDistCalc;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-import org.junit.After;
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import static junit.framework.Assert.assertEquals;
-
-
-public class SpatialContextFactoryTest {
-  public static final String PROP = "SpatialContextFactory";
-
-  @After
-  public void tearDown() {
-    System.getProperties().remove(PROP);
-  }
-  
-  private SpatialContext call(String... argsStr) {
-    Map<String,String> args = new HashMap<String,String>();
-    for (int i = 0; i < argsStr.length; i+=2) {
-      String key = argsStr[i];
-      String val = argsStr[i+1];
-      args.put(key,val);
-    }
-    return SpatialContextFactory.makeSpatialContext(args, getClass().getClassLoader());
-  }
-  
-  @Test
-  public void testDefault() {
-    SpatialContext s = SimpleSpatialContext.GEO_KM;
-    SpatialContext t = call();//default
-    assertEquals(s.getClass(),t.getClass());
-    assertEquals(s.getUnits(),t.getUnits());
-    assertEquals(s.getDistCalc(),t.getDistCalc());
-    assertEquals(s.getWorldBounds(),t.getWorldBounds());
-  }
-  
-  @Test
-  public void testCustom() {
-    SpatialContext sc = call("units","u");
-    assertEquals(DistanceUnits.CARTESIAN,sc.getUnits());
-    assertEquals(new CartesianDistCalc(),sc.getDistCalc());
-
-    sc = call("units","u",
-        "distCalculator","cartesian^2",
-        "worldBounds","-100 0 75 200");//West South East North
-    assertEquals(new CartesianDistCalc(true),sc.getDistCalc());
-    assertEquals(new RectangleImpl(-100,75,0,200),sc.getWorldBounds());
-
-    sc = call("units","miles",
-        "distCalculator","lawOfCosines");
-    assertEquals(DistanceUnits.MILES,sc.getUnits());
-    assertEquals(new GeodesicSphereDistCalc.LawOfCosines(sc.getUnits().earthRadius()),
-        sc.getDistCalc());
-  }
-  
-  @Test
-  public void testSystemPropertyLookup() {
-    System.setProperty(PROP,DSCF.class.getName());
-    assertEquals(DistanceUnits.CARTESIAN,call().getUnits());//DSCF returns this
-  }
-
-  public static class DSCF extends SpatialContextFactory {
-
-    @Override
-    protected SpatialContext newSpatialContext() {
-      return new SimpleSpatialContext(DistanceUnits.CARTESIAN);
-    }
-  }
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextTestCase.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextTestCase.java
deleted file mode 100644
index d64a55b..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/context/SpatialContextTestCase.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.context;
-
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-
-
-/**
- */
-public class SpatialContextTestCase extends BaseSpatialContextTestCase {
-
-  @Override
-  protected SpatialContext getSpatialContext() {
-    return SimpleSpatialContext.GEO_KM;
-  }
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/distance/TestDistances.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/distance/TestDistances.java
deleted file mode 100644
index 5f0c712..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/distance/TestDistances.java
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.distance;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-
-
-public class TestDistances extends LuceneTestCase {
-
-  //NOTE!  These are sometimes modified by tests.
-  private SpatialContext ctx;
-  private double EPS;
-
-  @Before
-  public void beforeTest() {
-    ctx = new SimpleSpatialContext(DistanceUnits.KILOMETERS);
-    EPS = 10e-4;//delta when doing double assertions. Geo eps is not that small.
-  }
-
-  private DistanceCalculator dc() {
-    return ctx.getDistCalc();
-  }
-  
-  @Test
-  public void testSomeDistances() {
-    //See to verify: from http://www.movable-type.co.uk/scripts/latlong.html
-    Point ctr = pLL(0,100);
-    Assert.assertEquals(11100, dc().distance(ctr, pLL(10, 0)), 3);
-    Assert.assertEquals(11100, dc().distance(ctr, pLL(10, -160)), 3);
-
-    Assert.assertEquals(314.40338, dc().distance(pLL(1, 2), pLL(3, 4)), EPS);
-  }
-
-  @Test
-  public void testCalcBoxByDistFromPt() {
-    //first test regression
-    {
-      double d = 6894.1;
-      Point pCtr = pLL(-20, 84);
-      Point pTgt = pLL(-42, 15);
-      Assert.assertTrue(dc().distance(pCtr, pTgt) < d);
-      //since the pairwise distance is less than d, a bounding box from ctr with d should contain pTgt.
-      Rectangle r = dc().calcBoxByDistFromPt(pCtr, d, ctx);
-      Assert.assertEquals(SpatialRelation.CONTAINS, r.relate(pTgt, ctx));
-      checkBBox(pCtr,d);
-    }
-
-    Assert.assertEquals("0 dist, horiz line",
-        -45, dc().calcBoxByDistFromPtHorizAxis(ctx.makePoint(-180, -45), 0, ctx), 0);
-
-    double MAXDIST = ctx.getUnits().earthCircumference() / 2;
-    checkBBox(ctx.makePoint(0,0), MAXDIST);
-    checkBBox(ctx.makePoint(0,0), MAXDIST *0.999999);
-    checkBBox(ctx.makePoint(0,0),0);
-    checkBBox(ctx.makePoint(0,0),0.000001);
-    checkBBox(ctx.makePoint(0,90),0.000001);
-    checkBBox(ctx.makePoint(-32.7,-5.42),9829);
-    checkBBox(ctx.makePoint(0,90-20),ctx.getDistCalc().degreesToDistance(20));
-    {
-      double d = 0.010;//10m
-      checkBBox(ctx.makePoint(0,90-ctx.getDistCalc().distanceToDegrees(d+0.001)),d);
-    }
-
-    for (int T = 0; T < 100; T++) {
-      double lat = -90 + LuceneTestCase.random.nextDouble()*180;
-      double lon = -180 + LuceneTestCase.random.nextDouble()*360;
-      Point ctr = ctx.makePoint(lon, lat);
-      double dist = MAXDIST* LuceneTestCase.random.nextDouble();
-      checkBBox(ctr, dist);
-    }
-
-  }
-
-  private void checkBBox(Point ctr, double dist) {
-    String msg = "ctr: "+ctr+" dist: "+dist;
-
-    Rectangle r = dc().calcBoxByDistFromPt(ctr, dist, ctx);
-    double horizAxisLat = dc().calcBoxByDistFromPtHorizAxis(ctr,dist, ctx);
-    if (!Double.isNaN(horizAxisLat))
-      Assert.assertTrue(r.relate_yRange(horizAxisLat, horizAxisLat, ctx).intersects());
-
-    //horizontal
-    if (r.getWidth() >= 180) {
-      double calcDist = dc().distance(ctr,r.getMinX(), r.getMaxY() == 90 ? 90 : -90 );
-      Assert.assertTrue(msg, calcDist <= dist + EPS);
-      //horizAxisLat is meaningless in this context
-    } else {
-      Point tPt = findClosestPointOnVertToPoint(r.getMinX(), r.getMinY(), r.getMaxY(), ctr);
-      double calcDist = dc().distance(ctr,tPt);
-      Assert.assertEquals(msg, dist, calcDist, EPS);
-      Assert.assertEquals(msg, tPt.getY(), horizAxisLat, EPS);
-    }
-    
-    //vertical
-    double topDist = dc().distance(ctr,ctr.getX(),r.getMaxY());
-    if (r.getMaxY() == 90)
-      Assert.assertTrue(msg, topDist <= dist + EPS);
-    else
-      Assert.assertEquals(msg, dist, topDist, EPS);
-    double botDist = dc().distance(ctr,ctr.getX(),r.getMinY());
-    if (r.getMinY() == -90)
-      Assert.assertTrue(msg, botDist <= dist + EPS);
-    else
-      Assert.assertEquals(msg, dist, botDist, EPS);
-  }
-
-  private Point findClosestPointOnVertToPoint(double lon, double lowLat, double highLat, Point ctr) {
-    //A binary search algorithm to find the point along the vertical lon between lowLat & highLat that is closest
-    // to ctr, and returns the distance.
-    double midLat = (highLat - lowLat)/2 + lowLat;
-    double midLatDist = ctx.getDistCalc().distance(ctr,lon,midLat);
-    for(int L = 0; L < 100 && (highLat - lowLat > 0.001|| L < 20); L++) {
-      boolean bottom = (midLat - lowLat > highLat - midLat);
-      double newMid = bottom ? (midLat - lowLat)/2 + lowLat : (highLat - midLat)/2 + midLat;
-      double newMidDist = ctx.getDistCalc().distance(ctr,lon,newMid);
-      if (newMidDist < midLatDist) {
-        if (bottom) {
-          highLat = midLat;
-        } else {
-          lowLat = midLat;
-        }
-        midLat = newMid;
-        midLatDist = newMidDist;
-      } else {
-        if (bottom) {
-          lowLat = newMid;
-        } else {
-          highLat = newMid;
-        }
-      }
-    }
-    return ctx.makePoint(lon,midLat);
-  }
-
-  @Test
-  public void testDistCalcPointOnBearing_cartesian() {
-    ctx = new SimpleSpatialContext(DistanceUnits.CARTESIAN);
-    EPS = 10e-6;//tighter epsilon (aka delta)
-    for(int i = 0; i < 1000; i++) {
-      testDistCalcPointOnBearing(LuceneTestCase.random.nextInt(100));
-    }
-  }
-
-  @Test
-  public void testDistCalcPointOnBearing_geo() {
-    //The haversine formula has a higher error if the points are near antipodal. We adjust EPS tolerance for this case.
-    //TODO Eventually we should add the Vincenty formula for improved accuracy, or try some other cleverness.
-
-    //test known high delta
-//    {
-//      Point c = ctx.makePoint(-103,-79);
-//      double angRAD = Math.toRadians(236);
-//      double dist = 20025;
-//      Point p2 = dc().pointOnBearingRAD(c, dist, angRAD, ctx);
-//      //Pt(x=76.61200011750923,y=79.04946929870962)
-//      double calcDist = dc().distance(c, p2);
-//      assertEqualsRatio(dist, calcDist);
-//    }
-    double maxDist = ctx.getUnits().earthCircumference() / 2;
-    for(int i = 0; i < 1000; i++) {
-      int dist = LuceneTestCase.random.nextInt((int) maxDist);
-      EPS = (dist < maxDist*0.75 ? 10e-6 : 10e-3);
-      testDistCalcPointOnBearing(dist);
-    }
-  }
-
-  private void testDistCalcPointOnBearing(double dist) {
-    for(int angDEG = 0; angDEG < 360; angDEG += LuceneTestCase.random.nextInt(20)+1) {
-      Point c = ctx.makePoint(LuceneTestCase.random.nextInt(360),-90+ LuceneTestCase.random.nextInt(181));
-
-      //0 distance means same point
-      Point p2 = dc().pointOnBearing(c, 0, angDEG, ctx);
-      Assert.assertEquals(c, p2);
-
-      p2 = dc().pointOnBearing(c, dist, angDEG, ctx);
-      double calcDist = dc().distance(c, p2);
-      assertEqualsRatio(dist, calcDist);
-    }
-  }
-
-  private void assertEqualsRatio(double expected, double actual) {
-    double delta = Math.abs(actual - expected);
-    double base = Math.min(actual, expected);
-    double deltaRatio = base==0 ? delta : Math.min(delta,delta / base);
-    Assert.assertEquals(0, deltaRatio, EPS);
-  }
-
-  @Test
-  public void testNormLat() {
-    double[][] lats = new double[][] {
-        {1.23,1.23},//1.23 might become 1.2299999 after some math and we want to ensure that doesn't happen
-        {-90,-90},{90,90},{0,0}, {-100,-80},
-        {-90-180,90},{-90-360,-90},{90+180,-90},{90+360,90},
-        {-12+180,12}};
-    for (double[] pair : lats) {
-      Assert.assertEquals("input " + pair[0], pair[1], ctx.normY(pair[0]), 0);
-    }
-    for(int i = -1000; i < 1000; i += LuceneTestCase.random.nextInt(10)*10) {
-      double d = ctx.normY(i);
-      Assert.assertTrue(i + " " + d, d >= -90 && d <= 90);
-    }
-  }
-
-  @Test
-  public void testNormLon() {
-    double[][] lons = new double[][] {
-        {1.23,1.23},//1.23 might become 1.2299999 after some math and we want to ensure that doesn't happen
-        {-180,-180},{180,-180},{0,0}, {-190,170},
-        {-180-360,-180},{-180-720,-180},{180+360,-180},{180+720,-180}};
-    for (double[] pair : lons) {
-      Assert.assertEquals("input " + pair[0], pair[1], ctx.normX(pair[0]), 0);
-    }
-    for(int i = -1000; i < 1000; i += LuceneTestCase.random.nextInt(10)*10) {
-      double d = ctx.normX(i);
-      Assert.assertTrue(i + " " + d, d >= -180 && d < 180);
-    }
-  }
-
-  @Test
-  public void testDistToRadians() {
-    assertDistToRadians(0);
-    assertDistToRadians(500);
-    assertDistToRadians(ctx.getUnits().earthRadius());
-  }
-
-  private void assertDistToRadians(double dist) {
-    double radius = ctx.getUnits().earthRadius();
-    Assert.assertEquals(
-        DistanceUtils.pointOnBearingRAD(0, 0, DistanceUtils.dist2Radians(dist, radius), DistanceUtils.DEG_90_AS_RADS, null)[1],
-        DistanceUtils.dist2Radians(dist, radius), 10e-5);
-  }
-
-  private Point pLL(double lat, double lon) {
-    return ctx.makePoint(lon,lat);
-  }
-
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeTest.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeTest.java
deleted file mode 100644
index ad81006..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/SpatialPrefixTreeTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashPrefixTree;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-
-public class SpatialPrefixTreeTest {
-
-  //TODO plug in others and test them
-  private SimpleSpatialContext ctx;
-  private SpatialPrefixTree trie;
-
-  @Before
-  public void setUp() throws Exception {
-    ctx = SimpleSpatialContext.GEO_KM;
-    trie = new GeohashPrefixTree(ctx,4);
-  }
-
-  @Test
-  public void testNodeTraverse() {
-    Node prevN = null;
-    Node n = trie.getWorldNode();
-    assertEquals(0,n.getLevel());
-    assertEquals(ctx.getWorldBounds(),n.getShape());
-    while(n.getLevel() < trie.getMaxLevels()) {
-      prevN = n;
-      n = n.getSubCells().iterator().next();//TODO random which one?
-      
-      assertEquals(prevN.getLevel()+1,n.getLevel());
-      Rectangle prevNShape = (Rectangle) prevN.getShape();
-      Shape s = n.getShape();
-      Rectangle sbox = s.getBoundingBox();
-      assertTrue(prevNShape.getWidth() > sbox.getWidth());
-      assertTrue(prevNShape.getHeight() > sbox.getHeight());
-    }
-  }
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/TestGridMatchInfo.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/TestGridMatchInfo.java
deleted file mode 100644
index 12d4676..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/TestGridMatchInfo.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.prefix.quad.QuadPrefixTree;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
-import org.apache.lucene.spatial.base.shape.simple.RectangleImpl;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.util.List;
-
-
-/**
- */
-public class TestGridMatchInfo {
-
-  @Test @Ignore
-  public void testMatchInfo() {
-    // Check Validation
-    SpatialContext ctx = new SimpleSpatialContext(DistanceUnits.CARTESIAN,null,new RectangleImpl(0,10,0,10));
-    QuadPrefixTree grid = new QuadPrefixTree(ctx, 2);
-
-
-//    GeometricShapeFactory gsf = new GeometricShapeFactory();
-//    gsf.setCentre( new com.vividsolutions.jts.geom.Coordinate( 5,5 ) );
-//    gsf.setSize( 9.5 );
-//    Shape shape = new JtsGeometry( gsf.createCircle() );
-
-    Shape shape = new RectangleImpl(0, 6, 5, 10);
-
-    shape = new PointImpl(3, 3);
-
-    //TODO UPDATE BASED ON NEW API
-    List<String> m = SpatialPrefixTree.nodesToTokenStrings(grid.getNodes(shape,3,false));
-    System.out.println(m);
-
-    for (CharSequence s : m) {
-      System.out.println(s);
-    }
-
-
-//    // query should intersect everything one level down
-//    ArrayList<String> descr = new ArrayList<String>();
-//    descr.add( "AAA*" );
-//    descr.add( "AABC*" );
-//    System.out.println( descr );
-  }
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/geohash/TestGeohashUtils.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/geohash/TestGeohashUtils.java
deleted file mode 100644
index 809227e..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/prefix/geohash/TestGeohashUtils.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.prefix.geohash;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * Tests for {@link GeohashUtils}
- */
-public class TestGeohashUtils {
-  SpatialContext ctx = new SimpleSpatialContext( DistanceUnits.KILOMETERS );
-
-  /**
-   * Pass condition: lat=42.6, lng=-5.6 should be encoded as "ezs42e44yx96",
-   * lat=57.64911 lng=10.40744 should be encoded as "u4pruydqqvj8"
-   */
-  @Test
-  public void testEncode() {
-    String hash = GeohashUtils.encodeLatLon(42.6, -5.6);
-    assertEquals("ezs42e44yx96", hash);
-
-    hash = GeohashUtils.encodeLatLon(57.64911, 10.40744);
-    assertEquals("u4pruydqqvj8", hash);
-  }
-
-  /**
-   * Pass condition: lat=52.3738007, lng=4.8909347 should be encoded and then
-   * decoded within 0.00001 of the original value
-   */
-  @Test
-  public void testDecodePreciseLongitudeLatitude() {
-    String hash = GeohashUtils.encodeLatLon(52.3738007, 4.8909347);
-
-    Point point = GeohashUtils.decode(hash,ctx);
-
-    assertEquals(52.3738007, point.getY(), 0.00001D);
-    assertEquals(4.8909347, point.getX(), 0.00001D);
-  }
-
-  /**
-   * Pass condition: lat=84.6, lng=10.5 should be encoded and then decoded
-   * within 0.00001 of the original value
-   */
-  @Test
-  public void testDecodeImpreciseLongitudeLatitude() {
-    String hash = GeohashUtils.encodeLatLon(84.6, 10.5);
-
-    Point point = GeohashUtils.decode(hash, ctx);
-
-    assertEquals(84.6, point.getY(), 0.00001D);
-    assertEquals(10.5, point.getX(), 0.00001D);
-  }
-
-  /*
-   * see https://issues.apache.org/jira/browse/LUCENE-1815 for details
-   */
-  @Test
-  public void testDecodeEncode() {
-    String geoHash = "u173zq37x014";
-    assertEquals(geoHash, GeohashUtils.encodeLatLon(52.3738007, 4.8909347));
-    Point point = GeohashUtils.decode(geoHash,ctx);
-    assertEquals(52.37380061d, point.getY(), 0.000001d);
-    assertEquals(4.8909343d, point.getX(), 0.000001d);
-
-    assertEquals(geoHash, GeohashUtils.encodeLatLon(point.getY(), point.getX()));
-
-    geoHash = "u173";
-    point = GeohashUtils.decode("u173",ctx);
-    geoHash = GeohashUtils.encodeLatLon(point.getY(), point.getX());
-    final Point point2 = GeohashUtils.decode(geoHash, ctx);
-    assertEquals(point.getY(), point2.getY(), 0.000001d);
-    assertEquals(point.getX(), point2.getX(), 0.000001d);
-  }
-
-  /** see the table at http://en.wikipedia.org/wiki/Geohash */
-  @Test
-  public void testHashLenToWidth() {
-    double[] box = GeohashUtils.lookupDegreesSizeForHashLen(3);
-    assertEquals(1.40625,box[0],0.0001);
-    assertEquals(1.40625,box[1],0.0001);
-  }
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/AbstractTestShapes.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/AbstractTestShapes.java
deleted file mode 100644
index dcb740a..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/AbstractTestShapes.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Assert;
-import org.junit.Before;
-
-import java.util.Random;
-
-import static org.apache.lucene.spatial.base.shape.SpatialRelation.*;
-
-
-public abstract class AbstractTestShapes extends LuceneTestCase {
-
-  protected SpatialContext ctx;
-  private static final double EPS = 10e-9;
-
-  @Before
-  public void beforeClass() {
-    ctx = getContext();
-  }
-
-  protected void assertRelation(String msg, SpatialRelation expected, Shape a, Shape b) {
-    msg = a+" intersect "+b;//use different msg
-    _assertIntersect(msg,expected,a,b);
-    //check flipped a & b w/ transpose(), while we're at it
-    _assertIntersect("(transposed) " + msg, expected.transpose(), b, a);
-  }
-
-  private void _assertIntersect(String msg, SpatialRelation expected, Shape a, Shape b) {
-    SpatialRelation sect = a.relate(b, ctx);
-    if (sect == expected)
-      return;
-    if (expected == WITHIN || expected == CONTAINS) {
-      if (a.getClass().equals(b.getClass())) // they are the same shape type
-        Assert.assertEquals(msg, a, b);
-      else {
-        //they are effectively points or lines that are the same location
-        Assert.assertTrue(msg, !a.hasArea());
-        Assert.assertTrue(msg, !b.hasArea());
-
-        Rectangle aBBox = a.getBoundingBox();
-        Rectangle bBBox = b.getBoundingBox();
-        if (aBBox.getHeight() == 0 && bBBox.getHeight() == 0
-            && (aBBox.getMaxY() == 90 && bBBox.getMaxY() == 90
-          || aBBox.getMinY() == -90 && bBBox.getMinY() == -90))
-          ;//== a point at the pole
-        else
-          Assert.assertEquals(msg, aBBox, bBBox);
-      }
-    } else {
-      Assert.assertEquals(msg, expected, sect);
-    }
-  }
-
-  private void assertEqualsRatio(String msg, double expected, double actual) {
-    double delta = Math.abs(actual - expected);
-    double base = Math.min(actual, expected);
-    double deltaRatio = base==0 ? delta : Math.min(delta,delta / base);
-    Assert.assertEquals(msg, 0, deltaRatio, EPS);
-  }
-
-  protected void testRectangle(double minX, double width, double minY, double height) {
-    Rectangle r = ctx.makeRect(minX, minX + width, minY, minY+height);
-    //test equals & hashcode of duplicate
-    Rectangle r2 = ctx.makeRect(minX, minX + width, minY, minY+height);
-    Assert.assertEquals(r, r2);
-    Assert.assertEquals(r.hashCode(), r2.hashCode());
-
-    String msg = r.toString();
-
-    Assert.assertEquals(msg, width != 0 && height != 0, r.hasArea());
-    Assert.assertEquals(msg, width != 0 && height != 0, r.getArea() > 0);
-
-    assertEqualsRatio(msg, height, r.getHeight());
-    assertEqualsRatio(msg, width, r.getWidth());
-    Point center = r.getCenter();
-    msg += " ctr:"+center;
-    //System.out.println(msg);
-    assertRelation(msg, CONTAINS, r, center);
-
-    DistanceCalculator dc = ctx.getDistCalc();
-    double dUR = dc.distance(center, r.getMaxX(), r.getMaxY());
-    double dLR = dc.distance(center, r.getMaxX(), r.getMinY());
-    double dUL = dc.distance(center, r.getMinX(), r.getMaxY());
-    double dLL = dc.distance(center, r.getMinX(), r.getMinY());
-
-    Assert.assertEquals(msg, width != 0 || height != 0, dUR != 0);
-    if (dUR != 0)
-      Assert.assertTrue(dUR > 0 && dLL > 0);
-    assertEqualsRatio(msg, dUR, dUL);
-    assertEqualsRatio(msg, dLR, dLL);
-    if (!ctx.isGeo() || center.getY() == 0)
-      assertEqualsRatio(msg, dUR, dLL);
-  }
-
-  protected void testRectIntersect() {
-    final double INCR = 45;
-    final double Y = 10;
-    for(double left = -180; left <= 180; left += INCR) {
-      for(double right = left; right - left <= 360; right += INCR) {
-        Rectangle r = ctx.makeRect(left,right,-Y,Y);
-
-        //test contains (which also tests within)
-        for(double left2 = left; left2 <= right; left2 += INCR) {
-          for(double right2 = left2; right2 <= right; right2 += INCR) {
-            Rectangle r2 = ctx.makeRect(left2,right2,-Y,Y);
-            assertRelation(null, SpatialRelation.CONTAINS, r, r2);
-          }
-        }
-        //test point contains
-        assertRelation(null, SpatialRelation.CONTAINS, r, ctx.makePoint(left, Y));
-
-        //test disjoint
-        for(double left2 = right+INCR; left2 - left < 360; left2 += INCR) {
-          for(double right2 = left2; right2 - left < 360; right2 += INCR) {
-            Rectangle r2 = ctx.makeRect(left2,right2,-Y,Y);
-            assertRelation(null, SpatialRelation.DISJOINT, r, r2);
-
-            //test point disjoint
-            assertRelation(null, SpatialRelation.DISJOINT, r, ctx.makePoint(left2, Y));
-          }
-        }
-        //test intersect
-        for(double left2 = left+INCR; left2 <= right; left2 += INCR) {
-          for(double right2 = right+INCR; right2 - left < 360; right2 += INCR) {
-            Rectangle r2 = ctx.makeRect(left2,right2,-Y,Y);
-            assertRelation(null, SpatialRelation.INTERSECTS, r, r2);
-          }
-        }
-
-      }
-    }
-  }
-
-  protected void testCircle(double x, double y, double dist) {
-    Circle c = ctx.makeCircle(x, y, dist);
-    String msg = c.toString();
-    final Circle c2 = ctx.makeCircle(ctx.makePoint(x, y), dist);
-    Assert.assertEquals(c, c2);
-    Assert.assertEquals(c.hashCode(), c2.hashCode());
-
-    Assert.assertEquals(msg, dist > 0, c.hasArea());
-    final Rectangle bbox = c.getBoundingBox();
-    Assert.assertEquals(msg, dist > 0, bbox.getArea() > 0);
-    if (!ctx.isGeo()) {
-      //if not geo then units of dist == units of x,y
-      assertEqualsRatio(msg, bbox.getHeight(), dist * 2);
-      assertEqualsRatio(msg, bbox.getWidth(), dist * 2);
-    }
-    assertRelation(msg, CONTAINS, c, c.getCenter());
-    assertRelation(msg, CONTAINS, bbox, c);
-  }
-
-  protected void testCircleIntersect() {
-    //Now do some randomized tests:
-    int i_C = 0, i_I = 0, i_W = 0, i_O = 0;//counters for the different intersection cases
-    int laps = 0;
-    int MINLAPSPERCASE = 20;
-    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE || i_O < MINLAPSPERCASE) {
-      laps++;
-      double cX = randRange(-180,179);
-      double cY = randRange(-90,90);
-      double cR = randRange(0, 180);
-      double cR_dist = ctx.getDistCalc().distance(ctx.makePoint(0, 0), 0, cR);
-      Circle c = ctx.makeCircle(cX, cY, cR_dist);
-
-      double rX = randRange(-180,179);
-      double rW = randRange(0,360);
-      double rY1 = randRange(-90,90);
-      double rY2 = randRange(-90,90);
-      double rYmin = Math.min(rY1,rY2);
-      double rYmax = Math.max(rY1,rY2);
-      Rectangle r = ctx.makeRect(rX, rX+rW, rYmin, rYmax);
-
-      SpatialRelation ic = c.relate(r, ctx);
-
-      Point p;
-      switch (ic) {
-        case CONTAINS:
-          i_C++;
-          p = randomPointWithin(LuceneTestCase.random,r,ctx);
-          Assert.assertEquals(CONTAINS, c.relate(p, ctx));
-          break;
-        case INTERSECTS:
-          i_I++;
-          //hard to test anything here; instead we'll test it separately
-          break;
-        case WITHIN:
-          i_W++;
-          p = randomPointWithin(LuceneTestCase.random,c,ctx);
-          Assert.assertEquals(CONTAINS, r.relate(p, ctx));
-          break;
-        case DISJOINT:
-          i_O++;
-          p = randomPointWithin(LuceneTestCase.random,r,ctx);
-          Assert.assertEquals(DISJOINT, c.relate(p, ctx));
-          break;
-        default: Assert.fail("" + ic);
-      }
-    }
-    //System.out.println("Laps: "+laps);
-
-    //TODO deliberately test INTERSECTS based on known intersection point
-  }
-
-  /** Returns a random integer between [start, end] with a limited number of possibilities instead of end-start+1. */
-  private int randRange(int start, int end) {
-    //I tested this.
-    double r = LuceneTestCase.random.nextDouble();
-    final int BUCKETS = 91;
-    int ir = (int) Math.round(r*(BUCKETS-1));//put into buckets
-    int result = (int)((double)((end - start) * ir) / (double)(BUCKETS-1) + (double)start);
-    assert result >= start && result <= end;
-    return result;
-  }
-
-  private Point randomPointWithin(Random random, Circle c, SpatialContext ctx) {
-    double d = c.getDistance() * random.nextDouble();
-    double angleDEG = 360*random.nextDouble();
-    Point p = ctx.getDistCalc().pointOnBearing(c.getCenter(), d, angleDEG, ctx);
-    Assert.assertEquals(CONTAINS, c.relate(p, ctx));
-    return p;
-  }
-
-  private Point randomPointWithin(Random random, Rectangle r, SpatialContext ctx) {
-    double x = r.getMinX() + random.nextDouble()*r.getWidth();
-    double y = r.getMinY() + random.nextDouble()*r.getHeight();
-    Point p = ctx.makePoint(x,y);
-    Assert.assertEquals(CONTAINS, r.relate(p, ctx));
-    return p;
-  }
-
-  protected abstract SpatialContext getContext();
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapes2D.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapes2D.java
deleted file mode 100644
index 785f864..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapes2D.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.junit.Test;
-
-import static org.apache.lucene.spatial.base.shape.SpatialRelation.*;
-import static org.junit.Assert.*;
-import static org.junit.Assert.assertEquals;
-
-
-public class TestShapes2D extends AbstractTestShapes {
-
-  @Override
-  protected SpatialContext getContext() {
-    return new SimpleSpatialContext(DistanceUnits.CARTESIAN);
-  }
-
-  @Test
-  public void testSimplePoint() {
-    Point pt = ctx.makePoint(0,0);
-    String msg = pt.toString();
-
-    //test equals & hashcode
-    Point pt2 = ctx.makePoint(0,0);
-    assertEquals(msg, pt, pt2);
-    assertEquals(msg, pt.hashCode(), pt2.hashCode());
-
-    assertFalse(msg,pt.hasArea());
-    assertEquals(msg,pt.getCenter(),pt);
-    Rectangle bbox = pt.getBoundingBox();
-    assertFalse(msg,bbox.hasArea());
-    assertEquals(msg,pt,bbox.getCenter());
-
-    assertRelation(msg, CONTAINS, pt, pt2);
-    assertRelation(msg, DISJOINT, pt, ctx.makePoint(0, 1));
-    assertRelation(msg, DISJOINT, pt, ctx.makePoint(1, 0));
-    assertRelation(msg, DISJOINT, pt, ctx.makePoint(1, 1));
-  }
-
-  @Test
-  public void testSimpleRectangle() {
-    double[] minXs = new double[]{-1000,-360,-180,-20,0,20,180,1000};
-    for (double minX : minXs) {
-      double[] widths = new double[]{0,10,180,360,400};
-      for (double width : widths) {
-        testRectangle(minX, width, 0, 0);
-        testRectangle(minX, width, -10, 10);
-        testRectangle(minX, width, 5, 10);
-      }
-    }
-
-    testRectIntersect();
-  }
-
-  @Test
-  public void testSimpleCircle() {
-    double[] theXs = new double[]{-10,0,10};
-    for (double x : theXs) {
-      double[] theYs = new double[]{-20,0,20};
-      for (double y : theYs) {
-        testCircle(x, y, 0);
-        testCircle(x, y, 5);
-      }
-    }
-    //INTERSECTION:
-    //Start with some static tests that have shown to cause failures at some point:
-    assertEquals("getX not getY",INTERSECTS,ctx.makeCircle(107,-81,147).relate(ctx.makeRect(92, 121, -89, 74), ctx));
-
-    testCircleIntersect();
-  }
-
-
-}
diff --git a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapesGeo.java b/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapesGeo.java
deleted file mode 100644
index 747ab01..0000000
--- a/modules/spatial/base/src/test/org/apache/lucene/spatial/base/shape/TestShapesGeo.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.base.shape;
-
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.GeodesicSphereDistCalc;
-import org.junit.Test;
-
-import static org.apache.lucene.spatial.base.shape.SpatialRelation.*;
-
-
-public class TestShapesGeo extends AbstractTestShapes {
-
-  @Test
-  public void testGeoRectangle() {
-    double[] lons = new double[]{0,45,160,180,-45,-175, -180};//minX
-    for (double lon : lons) {
-      double[] lonWs = new double[]{0,20,180,200,355, 360};//width
-      for (double lonW : lonWs) {
-        testRectangle(lon, lonW, 0, 0);
-        testRectangle(lon, lonW, -10, 10);
-        testRectangle(lon, lonW, 80, 10);//polar cap
-        testRectangle(lon, lonW, -90, 180);//full lat range
-      }
-    }
-
-    //Test geo rectangle intersections
-    testRectIntersect();
-  }
-
-
-  @Test
-  public void testGeoCircle() {
-    //--Start with some static tests that once failed:
-
-    //Bug: numeric edge at pole, fails to init
-    ctx.makeCircle(
-        110,-12,ctx.getDistCalc().degreesToDistance(90 + 12));
-
-    //Bug: horizXAxis not in enclosing rectangle, assertion
-    ctx.makeCircle(-44,16,degToDist(106));
-    ctx.makeCircle(-36,-76,degToDist(14));
-    ctx.makeCircle(107,82,degToDist(172));
-
-// TODO need to update this test to be valid
-//    {
-//      //Bug in which distance was being confused as being in the same coordinate system as x,y.
-//      double distDeltaToPole = 0.001;//1m
-//      double distDeltaToPoleDEG = ctx.getDistCalc().distanceToDegrees(distDeltaToPole);
-//      double dist = 1;//1km
-//      double distDEG = ctx.getDistCalc().distanceToDegrees(dist);
-//      Circle c = ctx.makeCircle(0,90-distDeltaToPoleDEG-distDEG,dist);
-//      Rectangle cBBox = c.getBoundingBox();
-//      Rectangle r = ctx.makeRect(cBBox.getMaxX()*0.99,cBBox.getMaxX()+1,c.getCenter().getY(),c.getCenter().getY());
-//      assertEquals(INTERSECTS,c.getBoundingBox().relate(r, ctx));
-//      assertEquals("dist != xy space",INTERSECTS,c.relate(r,ctx));//once failed here
-//    }
-
-    assertEquals("wrong estimate", DISJOINT,ctx.makeCircle(-166,59,5226.2).relate(ctx.makeRect(36, 66, 23, 23), ctx));
-
-    assertEquals("bad CONTAINS (dateline)",INTERSECTS,ctx.makeCircle(56,-50,12231.5).relate(ctx.makeRect(108, 26, 39, 48), ctx));
-
-    assertEquals("bad CONTAINS (backwrap2)",INTERSECTS,
-        ctx.makeCircle(112,-3,degToDist(91)).relate(ctx.makeRect(-163, 29, -38, 10), ctx));
-
-    assertEquals("bad CONTAINS (r x-wrap)",INTERSECTS,
-        ctx.makeCircle(-139,47,degToDist(80)).relate(ctx.makeRect(-180, 180, -3, 12), ctx));
-
-    assertEquals("bad CONTAINS (pwrap)",INTERSECTS,
-        ctx.makeCircle(-139,47,degToDist(80)).relate(ctx.makeRect(-180, 179, -3, 12), ctx));
-
-    assertEquals("no-dist 1",WITHIN,
-        ctx.makeCircle(135,21,0).relate(ctx.makeRect(-103, -154, -47, 52), ctx));
-
-    assertEquals("bbox <= >= -90 bug",CONTAINS,
-        ctx.makeCircle(-64,-84,degToDist(124)).relate(ctx.makeRect(-96, 96, -10, -10), ctx));
-
-    //The horizontal axis line of a geo circle doesn't necessarily pass through c's ctr.
-    assertEquals("c's horiz axis doesn't pass through ctr",INTERSECTS,
-        ctx.makeCircle(71,-44,degToDist(40)).relate(ctx.makeRect(15, 27, -62, -34), ctx));
-
-    assertEquals("pole boundary",INTERSECTS,
-        ctx.makeCircle(-100,-12,degToDist(102)).relate(ctx.makeRect(143, 175, 4, 32), ctx));
-
-    assertEquals("full circle assert",CONTAINS,
-        ctx.makeCircle(-64,32,degToDist(180)).relate(ctx.makeRect(47, 47, -14, 90), ctx));
-
-    //--Now proceed with systematic testing:
-
-    double distToOpposeSide = ctx.getUnits().earthRadius()*Math.PI;
-    assertEquals(ctx.getWorldBounds(),ctx.makeCircle(0,0,distToOpposeSide).getBoundingBox());
-    //assertEquals(ctx.makeCircle(0,0,distToOpposeSide/2 - 500).getBoundingBox());
-
-    double[] theXs = new double[]{-180,-45,90};
-    for (double x : theXs) {
-      double[] theYs = new double[]{-90,-45,0,45,90};
-      for (double y : theYs) {
-        testCircle(x, y, 0);
-        testCircle(x, y, 500);
-        testCircle(x, y, degToDist(90));
-        testCircle(x, y, ctx.getUnits().earthRadius()*6);
-      }
-    }
-
-    testCircleIntersect();
-  }
-
-  private double degToDist(int deg) {
-    return ctx.getDistCalc().degreesToDistance(deg);
-  }
-
-  @Override
-  protected SpatialContext getContext() {
-    DistanceUnits units = DistanceUnits.KILOMETERS;
-    DistanceCalculator distCalc = new GeodesicSphereDistCalc.Haversine(units.earthRadius());//default
-    switch(random.nextInt(3)) {
-      case 2:
-        //TODO ENABLE WHEN WORKING
-        //distCalc = new GeodesicSphereDistCalc.LawOfCosines(units.earthRadius());
-        break;
-      case 1:
-        distCalc = new GeodesicSphereDistCalc.Vincenty(units.earthRadius());
-        break;
-    }
-    return new SimpleSpatialContext(units,
-        distCalc,
-        SpatialContext.GEO_WORLDBOUNDS);
-  }
-
-}
diff --git a/modules/spatial/build.xml b/modules/spatial/build.xml
index 549d063..9ce58d4 100644
--- a/modules/spatial/build.xml
+++ b/modules/spatial/build.xml
@@ -1,78 +1,41 @@
 <?xml version="1.0"?>
-
-<!--
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements.  See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version 2.0
-    the "License"); you may not use this file except in compliance with
-    the License.  You may obtain a copy of the License at
- 
-        http://www.apache.org/licenses/LICENSE-2.0
- 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
- -->
-
 <project name="spatial" default="default">
-
   <description>
-    Lucene Spatial Support
-      - base:	Spatial API w/o lucene dependencies
-      - strategy: Lucene based indexing strategies
+    Lucene Spatial
   </description>
-  
-  <target name="base">
-    <ant dir="base" />
-  </target>
 
-  <target name="strategy">
-    <ant dir="strategy" />
-  </target>
+  <property name="build.dir" location="build/" />
+  <property name="dist.dir" location="dist/" />
+  <property name="maven.dist.dir" location="../dist/maven" />
 
-  <target name="default" depends="compile"/>
-  <target name="compile" depends="base,strategy" />
+  <path id="additional.dependencies">
+    <fileset dir="lib" includes="*.jar"/>
+  </path>
 
-  <target name="clean">
-    <ant dir="base" target="clean" />
-    <ant dir="strategy" target="clean" />
-  </target>
+  <pathconvert property="project.classpath"
+               targetos="unix"
+               refid="additional.dependencies"
+  />
   
-  <target name="validate">
-    <ant dir="base" target="validate" />
-    <ant dir="strategy" target="validate" />
-  </target>
-  <target name="compile-core">
-    <ant dir="base" target="compile-core" />
-    <ant dir="strategy" target="compile-core" />
-  </target>
-  <target name="compile-test">
-    <ant dir="base" target="compile-test" />
-    <ant dir="strategy" target="compile-test" />
-  </target>
-  <target name="test">
-    <ant dir="base" target="test" />
-    <ant dir="strategy" target="test" />
-  </target>
+  <import file="../../lucene/contrib/contrib-build.xml"/>
+
+  <path id="classpath">
+    <path refid="base.classpath"/>
+    <pathelement path="${spatial-base.jar}" />
+    <pathelement path="${queries.jar}" />
+  </path>
 
-  <target name="build-artifacts-and-tests" depends="default,compile-test" />
+  <path id="test.classpath">
+    <path refid="test.base.classpath" />
+    <path refid="base.classpath"/>
+    <pathelement path="${analyzers-common.jar}" />
+    <pathelement path="src/test-files" />
+  </path>
 
-  <target name="dist-maven" depends="default,javadocs">
-    <ant dir="base" target="dist-maven" />
-    <ant dir="strategy" target="dist-maven" />
-  </target>  	
 
-  <target name="javadocs">
-    <ant dir="base" target="javadocs" />
-    <ant dir="strategy" target="javadocs" />
-  </target>  	
+  <target name="init" depends="contrib-build.init"/>
+  <target name="dist-maven" depends="jar-core,javadocs,common.dist-maven"/>
+  <target name="compile" depends="jar-queries,common.compile-core" />
+  <target name="test" depends="jar-analyzers-common,compile-test,validate,junit-mkdir,junit-sequential,junit-parallel" description="Runs unit tests"/>
 
-  <target name="javadocs-index.html">
-    <ant dir="base" target="javadocs-index.html" />
-    <ant dir="strategy" target="javadocs-index.html" />
-  </target>
-	
 </project>
diff --git a/modules/spatial/lib/spatial4j-0.1.jar b/modules/spatial/lib/spatial4j-0.1.jar
new file mode 100644
index 0000000..c9c91e8
--- /dev/null
+++ b/modules/spatial/lib/spatial4j-0.1.jar
@@ -0,0 +1,2 @@
+AnyObjectId[41698d61caf8eee1afdca7d39042a2eee1517ff5] was removed in git history.
+Apache SVN contains full history.
\ No newline at end of file
diff --git a/modules/spatial/lib/spatial4j-LICENSE-ASL.txt b/modules/spatial/lib/spatial4j-LICENSE-ASL.txt
new file mode 100644
index 0000000..75b5248
--- /dev/null
+++ b/modules/spatial/lib/spatial4j-LICENSE-ASL.txt
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/modules/spatial/lib/spatial4j-NOTICE.txt b/modules/spatial/lib/spatial4j-NOTICE.txt
new file mode 100644
index 0000000..f1de89c
--- /dev/null
+++ b/modules/spatial/lib/spatial4j-NOTICE.txt
@@ -0,0 +1,5 @@
+Apache Commons Lang
+Copyright 2001-2008 The Apache Software Foundation
+
+This product includes software developed by
+The Apache Software Foundation (http://www.apache.org/).
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java
index 584abcb..e186df4 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java
@@ -21,9 +21,9 @@ import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.shape.Shape;
 
 /**
  * must be thread safe
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java
index c82ed12..347a33c 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java
@@ -17,9 +17,9 @@
 
 package org.apache.lucene.spatial.strategy.prefix;
 
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.shape.Point;
+import com.spatial4j.core.prefix.Node;
+import com.spatial4j.core.prefix.SpatialPrefixTree;
+import com.spatial4j.core.shape.Point;
 import org.apache.lucene.spatial.strategy.util.ShapeFieldCacheProvider;
 import org.apache.lucene.util.BytesRef;
 
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java
index 307246d..0037552 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java
@@ -24,12 +24,12 @@ import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.StoredField;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.prefix.Node;
+import com.spatial4j.core.prefix.SpatialPrefixTree;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
 import org.apache.lucene.spatial.strategy.SpatialStrategy;
 import org.apache.lucene.spatial.strategy.util.CachedDistanceValueSource;
@@ -56,7 +56,7 @@ public abstract class PrefixTreeStrategy extends SpatialStrategy<SimpleSpatialFi
     this.defaultFieldValuesArrayLen = defaultFieldValuesArrayLen;
   }
 
-  /** See {@link SpatialPrefixTree#getMaxLevelForPrecision(org.apache.lucene.spatial.base.shape.Shape, double)}. */
+  /** See {@link SpatialPrefixTree#getMaxLevelForPrecision(com.spatial4j.core.shape.Shape, double)}. */
   public void setDistErrPct(double distErrPct) {
     this.distErrPct = distErrPct;
   }
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java
index 18f023f..89f836a 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java
@@ -21,10 +21,10 @@ import org.apache.lucene.index.*;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.base.shape.SpatialRelation;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+import com.spatial4j.core.prefix.Node;
+import com.spatial4j.core.prefix.SpatialPrefixTree;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.OpenBitSet;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java
index c644696..287731f 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java
@@ -22,11 +22,11 @@ import org.apache.lucene.search.FilteredQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.FunctionQuery;
-import org.apache.lucene.spatial.base.exception.UnsupportedSpatialOperation;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.prefix.SpatialPrefixTree;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
 
 
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java
index bef5026..3ef770e 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java
@@ -19,12 +19,12 @@ package org.apache.lucene.spatial.strategy.prefix;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.*;
-import org.apache.lucene.spatial.base.exception.UnsupportedSpatialOperation;
-import org.apache.lucene.spatial.base.prefix.Node;
-import org.apache.lucene.spatial.base.prefix.SpatialPrefixTree;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.prefix.Node;
+import com.spatial4j.core.prefix.SpatialPrefixTree;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
 
 import java.util.List;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java
index 3070aea..ceb8259 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java
@@ -22,8 +22,8 @@ import org.apache.commons.lang.builder.HashCodeBuilder;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.shape.Point;
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.shape.Point;
 
 import java.io.IOException;
 import java.util.List;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java
index 992a33e..c105eea 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java
@@ -20,7 +20,7 @@ package org.apache.lucene.spatial.strategy.util;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.shape.Shape;
 
 public class ShapeFieldCache<T extends Shape> {
   private List<T>[] cache;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java
index 38b42bd..4282132 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java
@@ -19,7 +19,7 @@ package org.apache.lucene.spatial.strategy.util;
 
 import org.apache.lucene.index.*;
 import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.util.BytesRef;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java
index 3ea40cb..26af994 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java
@@ -25,9 +25,9 @@ import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.FieldCache.DoubleParser;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.simple.PointImpl;
 import org.apache.lucene.util.Bits;
 
 import java.io.IOException;
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java
index 0475293..9d6ad18 100644
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java
@@ -24,15 +24,15 @@ import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.FieldCache.DoubleParser;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.exception.UnsupportedSpatialOperation;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-import org.apache.lucene.spatial.base.shape.Circle;
-import org.apache.lucene.spatial.base.shape.Point;
-import org.apache.lucene.spatial.base.shape.Rectangle;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.exception.InvalidShapeException;
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Circle;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.strategy.SpatialStrategy;
 import org.apache.lucene.spatial.strategy.util.CachingDoubleValueSource;
 import org.apache.lucene.spatial.strategy.util.NumericFieldInfo;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/SpatialTestQuery.java b/modules/spatial/src/test/org/apache/lucene/spatial/SpatialTestQuery.java
index d2f75d3..f512399 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/SpatialTestQuery.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/SpatialTestQuery.java
@@ -17,10 +17,10 @@
 
 package org.apache.lucene.spatial;
 
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.io.LineReader;
-import org.apache.lucene.spatial.base.query.SpatialArgs;
-import org.apache.lucene.spatial.base.query.SpatialArgsParser;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.io.LineReader;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialArgsParser;
 
 import java.io.IOException;
 import java.io.InputStream;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
index d7111df..816001c 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
@@ -23,11 +23,11 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.io.sample.SampleData;
-import org.apache.lucene.spatial.base.io.sample.SampleDataReader;
-import org.apache.lucene.spatial.base.query.SpatialArgsParser;
-import org.apache.lucene.spatial.base.shape.Shape;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.io.sample.SampleData;
+import com.spatial4j.core.io.sample.SampleDataReader;
+import com.spatial4j.core.query.SpatialArgsParser;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.strategy.SpatialFieldInfo;
 import org.apache.lucene.spatial.strategy.SpatialStrategy;
 import org.slf4j.Logger;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/TestTestFramework.java b/modules/spatial/src/test/org/apache/lucene/spatial/TestTestFramework.java
index 1a79cd6..5e1ffc0 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/TestTestFramework.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/TestTestFramework.java
@@ -17,11 +17,11 @@
 
 package org.apache.lucene.spatial;
 
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.query.SpatialArgsParser;
-import org.apache.lucene.spatial.base.query.SpatialOperation;
-import org.apache.lucene.spatial.base.shape.Rectangle;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.query.SpatialArgsParser;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Rectangle;
 import org.junit.Assert;
 import org.junit.Test;
 
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
index 3d38828..ab28aa5 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
@@ -17,8 +17,8 @@
 
 package org.apache.lucene.spatial.strategy.prefix;
 
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashPrefixTree;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.prefix.geohash.GeohashPrefixTree;
 import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
 import org.apache.lucene.spatial.SpatialMatchConcern;
 import org.apache.lucene.spatial.StrategyTestCase;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java
index 71fb4d8..87c881b 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java
@@ -17,8 +17,8 @@
 
 package org.apache.lucene.spatial.strategy.prefix;
 
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
 import org.junit.Before;
 
 
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java
index 4c36945..9851fa7 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java
@@ -20,12 +20,12 @@ package org.apache.lucene.spatial.strategy.prefix;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.prefix.quad.QuadPrefixTree;
-import org.apache.lucene.spatial.base.query.SpatialArgsParser;
-import org.apache.lucene.spatial.base.shape.Shape;
-import org.apache.lucene.spatial.base.shape.simple.PointImpl;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.prefix.quad.QuadPrefixTree;
+import com.spatial4j.core.query.SpatialArgsParser;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.simple.PointImpl;
 import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
 import org.apache.lucene.spatial.SpatialTestCase;
 import org.junit.Test;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java
index a981c48..10d678a 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java
@@ -18,7 +18,7 @@
 package org.apache.lucene.spatial.strategy.vector;
 
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.spatial.base.context.SpatialContext;
+import com.spatial4j.core.context.SpatialContext;
 import org.apache.lucene.spatial.strategy.util.NumericFieldInfo;
 import org.apache.lucene.spatial.SpatialMatchConcern;
 import org.apache.lucene.spatial.StrategyTestCase;
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java
index 19586bf..14bc89d 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java
@@ -17,8 +17,8 @@
 
 package org.apache.lucene.spatial.strategy.vector;
 
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
 
 public class TwoDoublesStrategyTestCase extends BaseTwoDoublesStrategyTestCase {
 
diff --git a/modules/spatial/strategy/build.xml b/modules/spatial/strategy/build.xml
deleted file mode 100644
index 1d84332..0000000
--- a/modules/spatial/strategy/build.xml
+++ /dev/null
@@ -1,55 +0,0 @@
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-
-<project name="spatial-strategy" default="default">
-  <description>
-    Lucene [Geo]Spatial Strategies
-  </description>
-
-  <property name="build.dir" location="../build/strategy" />
-  <property name="dist.dir" location="../dist/strategy" />
-  <property name="maven.dist.dir" location="../../dist/maven"/>
-
-
-  <path id="additional.dependencies">
-    <!--
-    <fileset dir="lib" includes="*.jar"/>
-    -->
-    <fileset dir="../base/lib" includes="*.jar"/>
-  </path>
-  <pathconvert property="project.classpath" targetos="unix" refid="additional.dependencies" />
-
-  <import file="../../../lucene/contrib/contrib-build.xml"/>
-
-  <path id="classpath">
-    <path refid="base.classpath"/>
-    <pathelement path="${spatial-base.jar}" />
-    <pathelement path="${queries.jar}" />
-  </path>
-
-  <path id="test.classpath">
-    <path refid="test.base.classpath" />
-    <path refid="base.classpath"/>
-    <pathelement path="${analyzers-common.jar}" />
-    <pathelement path="src/test-files" />
-  </path>
-
-  <target name="dist-maven" depends="jar-core,javadocs,common.dist-maven"/>
-  <target name="compile" depends="jar-spatial-base,jar-queries,common.compile-core" />
-  <target name="test" depends="jar-analyzers-common,compile-test,validate,junit-mkdir,junit-sequential,junit-parallel" description="Runs unit tests"/>
-
-</project>
\ No newline at end of file
diff --git a/solr/common-build.xml b/solr/common-build.xml
index dff9305..fa70724 100644
--- a/solr/common-build.xml
+++ b/solr/common-build.xml
@@ -134,7 +134,7 @@
 
   <target name="prep-lucene-jars" 
   	      depends="jar-lucene-core, jar-analyzers-phonetic, jar-analyzers-kuromoji, jar-suggest, jar-highlighter, jar-memory,
-  	               jar-misc, jar-spatial-base, jar-spatial-strategy, jar-grouping, jar-queries, jar-queryparser">
+  	               jar-misc, jar-spatial, jar-grouping, jar-queries, jar-queryparser">
   	  <property name="solr.deps.compiled" value="true"/>
   </target>
 	
diff --git a/solr/core/src/java/org/apache/solr/schema/GeoHashField.java b/solr/core/src/java/org/apache/solr/schema/GeoHashField.java
index d5a25a2..cab3f3f 100644
--- a/solr/core/src/java/org/apache/solr/schema/GeoHashField.java
+++ b/solr/core/src/java/org/apache/solr/schema/GeoHashField.java
@@ -22,12 +22,12 @@ import org.apache.lucene.queries.function.valuesource.LiteralValueSource;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.spatial.base.context.ParseUtils;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashUtils;
-import org.apache.lucene.spatial.base.shape.Point;
+import com.spatial4j.core.context.ParseUtils;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.exception.InvalidShapeException;
+import com.spatial4j.core.prefix.geohash.GeohashUtils;
+import com.spatial4j.core.shape.Point;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
@@ -44,7 +44,7 @@ import java.io.IOException;
  * href="http://en.wikipedia.org/wiki/Geohash">Geohash</a> field. The field is
  * provided as a lat/lon pair and is internally represented as a string.
  *
- * @see org.apache.lucene.spatial.base.context.ParseUtils#parseLatitudeLongitude(double[], String) 
+ * @see com.spatial4j.core.context.ParseUtils#parseLatitudeLongitude(double[], String) 
  */
 public class GeoHashField extends FieldType implements SpatialQueryable {
 
diff --git a/solr/core/src/java/org/apache/solr/schema/LatLonType.java b/solr/core/src/java/org/apache/solr/schema/LatLonType.java
index 6b1d0bf..9a66a0c 100644
--- a/solr/core/src/java/org/apache/solr/schema/LatLonType.java
+++ b/solr/core/src/java/org/apache/solr/schema/LatLonType.java
@@ -24,14 +24,14 @@ import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.VectorValueSource;
 import org.apache.lucene.search.*;
-import org.apache.lucene.spatial.base.context.ParseUtils;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.distance.GeodesicSphereDistCalc;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
-import org.apache.lucene.spatial.base.shape.Rectangle;
+import com.spatial4j.core.context.ParseUtils;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.distance.GeodesicSphereDistCalc;
+import com.spatial4j.core.exception.InvalidShapeException;
+import com.spatial4j.core.shape.Rectangle;
 import org.apache.lucene.util.Bits;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
diff --git a/solr/core/src/java/org/apache/solr/schema/PointType.java b/solr/core/src/java/org/apache/solr/schema/PointType.java
index 48da54e..7b7a8ba 100644
--- a/solr/core/src/java/org/apache/solr/schema/PointType.java
+++ b/solr/core/src/java/org/apache/solr/schema/PointType.java
@@ -25,9 +25,9 @@ import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.spatial.base.context.ParseUtils;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+import com.spatial4j.core.context.ParseUtils;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.exception.InvalidShapeException;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
diff --git a/solr/core/src/java/org/apache/solr/search/SpatialFilterQParser.java b/solr/core/src/java/org/apache/solr/search/SpatialFilterQParser.java
index 9440950..eabacac 100644
--- a/solr/core/src/java/org/apache/solr/search/SpatialFilterQParser.java
+++ b/solr/core/src/java/org/apache/solr/search/SpatialFilterQParser.java
@@ -19,8 +19,8 @@ package org.apache.solr.search;
 
 import org.apache.lucene.queryparser.classic.ParseException;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import com.spatial4j.core.distance.DistanceUnits;
+import com.spatial4j.core.distance.DistanceUtils;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.SpatialParams;
diff --git a/solr/core/src/java/org/apache/solr/search/SpatialOptions.java b/solr/core/src/java/org/apache/solr/search/SpatialOptions.java
index b9d8e6a..21fa225 100644
--- a/solr/core/src/java/org/apache/solr/search/SpatialOptions.java
+++ b/solr/core/src/java/org/apache/solr/search/SpatialOptions.java
@@ -16,7 +16,7 @@ package org.apache.solr.search;
  * limitations under the License.
  */
 
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
+import com.spatial4j.core.distance.DistanceUnits;
 import org.apache.solr.schema.SchemaField;
 
 /**
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/GeohashFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/GeohashFunction.java
index b0d1a1a..753ad41 100644
--- a/solr/core/src/java/org/apache/solr/search/function/distance/GeohashFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/GeohashFunction.java
@@ -19,7 +19,7 @@ package org.apache.solr.search.function.distance;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashUtils;
+import com.spatial4j.core.prefix.geohash.GeohashUtils;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
index be5f9dc..a16cb98 100644
--- a/solr/core/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
@@ -22,13 +22,13 @@ import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.spatial.base.context.SpatialContext;
-import org.apache.lucene.spatial.base.context.simple.SimpleSpatialContext;
-import org.apache.lucene.spatial.base.distance.DistanceCalculator;
-import org.apache.lucene.spatial.base.distance.DistanceUnits;
-import org.apache.lucene.spatial.base.distance.GeodesicSphereDistCalc;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashUtils;
-import org.apache.lucene.spatial.base.shape.Point;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.distance.DistanceUnits;
+import com.spatial4j.core.distance.GeodesicSphereDistCalc;
+import com.spatial4j.core.prefix.geohash.GeohashUtils;
+import com.spatial4j.core.shape.Point;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
index 78becba..1c6bbcc 100755
--- a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineConstFunction.java
@@ -26,9 +26,9 @@ import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.queries.function.valuesource.VectorValueSource;
 import org.apache.lucene.queryparser.classic.ParseException;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.spatial.base.context.ParseUtils;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.exception.InvalidShapeException;
+import com.spatial4j.core.context.ParseUtils;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.exception.InvalidShapeException;
 import org.apache.solr.common.params.SpatialParams;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.FunctionQParser;
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
index 8994558..f2a537d 100644
--- a/solr/core/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
@@ -22,7 +22,7 @@ import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import com.spatial4j.core.distance.DistanceUtils;
 import org.apache.solr.common.SolrException;
 
 import java.io.IOException;
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
index a1f184f..c82b05a 100644
--- a/solr/core/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.function.distance;
 
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.valuesource.MultiValueSource;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import com.spatial4j.core.distance.DistanceUtils;
 
 /**
  * While not strictly a distance, the Sq. Euclidean Distance is often all that is needed in many applications
diff --git a/solr/core/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java b/solr/core/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
index d5151d0..70cf81f 100644
--- a/solr/core/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
+++ b/solr/core/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
@@ -22,7 +22,7 @@ import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.queries.function.valuesource.MultiValueSource;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
+import com.spatial4j.core.distance.DistanceUtils;
 import org.apache.solr.common.SolrException;
 
 import java.io.IOException;
diff --git a/solr/core/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java b/solr/core/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
index b7ae752..48adc6e 100644
--- a/solr/core/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
+++ b/solr/core/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
@@ -16,8 +16,8 @@ package org.apache.solr.search.function.distance;
  * limitations under the License.
  */
 
-import org.apache.lucene.spatial.base.distance.DistanceUtils;
-import org.apache.lucene.spatial.base.prefix.geohash.GeohashUtils;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.prefix.geohash.GeohashUtils;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrException;
 import org.junit.BeforeClass;

