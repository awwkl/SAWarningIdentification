GitDiffStart: b22f711b6316df59789ac7421e972c0530cc0aef | Sat Jul 4 14:24:35 2015 +0000
diff --git a/solr/core/src/java/org/apache/solr/handler/SQLHandler.java b/solr/core/src/java/org/apache/solr/handler/SQLHandler.java
index 9b19c5c..1f64e1f 100644
--- a/solr/core/src/java/org/apache/solr/handler/SQLHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/SQLHandler.java
@@ -42,6 +42,7 @@ import org.apache.solr.client.solrj.io.stream.RollupStream;
 import org.apache.solr.client.solrj.io.stream.StreamContext;
 import org.apache.solr.client.solrj.io.stream.TupleStream;
 import org.apache.solr.client.solrj.io.stream.ExceptionStream;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
@@ -184,7 +185,21 @@ public class SQLHandler extends RequestHandlerBase implements SolrCoreAware {
       // Do the rollups in parallel
       // Maintain the sort of the Tuples coming from the workers.
       StreamComparator comp = bucketSortComp(buckets, sortDirection);
-      tupleStream = new ParallelStream(workerZkHost, workerCollection, tupleStream, numWorkers, comp);
+      ParallelStream parallelStream = new ParallelStream(workerZkHost, workerCollection, tupleStream, numWorkers, comp);
+
+      StreamFactory factory = new StreamFactory()
+          .withFunctionName("search", CloudSolrStream.class)
+          .withFunctionName("parallel", ParallelStream.class)
+          .withFunctionName("rollup", RollupStream.class)
+          .withFunctionName("sum", SumMetric.class)
+          .withFunctionName("min", MinMetric.class)
+          .withFunctionName("max", MaxMetric.class)
+          .withFunctionName("avg", MeanMetric.class)
+          .withFunctionName("count", CountMetric.class);
+
+      parallelStream.setStreamFactory(factory);
+      parallelStream.setObjectSerialize(false);
+      tupleStream = parallelStream;
     }
 
     //TODO: This should be done on the workers, but it won't serialize because it relies on Presto classes.
diff --git a/solr/core/src/java/org/apache/solr/handler/StreamHandler.java b/solr/core/src/java/org/apache/solr/handler/StreamHandler.java
index 3a0fe7a..ee801e9 100644
--- a/solr/core/src/java/org/apache/solr/handler/StreamHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/StreamHandler.java
@@ -34,11 +34,17 @@ import org.apache.solr.client.solrj.io.stream.MergeStream;
 import org.apache.solr.client.solrj.io.stream.ParallelStream;
 import org.apache.solr.client.solrj.io.stream.RankStream;
 import org.apache.solr.client.solrj.io.stream.ReducerStream;
+import org.apache.solr.client.solrj.io.stream.RollupStream;
 import org.apache.solr.client.solrj.io.stream.StreamContext;
 import org.apache.solr.client.solrj.io.stream.TupleStream;
 import org.apache.solr.client.solrj.io.stream.UniqueStream;
 import org.apache.solr.client.solrj.io.stream.expr.Expressible;
 import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.Base64;
 import org.apache.solr.common.util.NamedList;
@@ -65,7 +71,7 @@ public class StreamHandler extends RequestHandlerBase implements SolrCoreAware {
      * RequestHandler def. Example config override
      *  <lst name="streamFunctions">
      *    <str name="group">org.apache.solr.client.solrj.io.stream.ReducerStream</str>
-     *    <str name="count">org.apache.solr.client.solrj.io.stream.CountStream</str>
+     *    <str name="count">org.apache.solr.client.solrj.io.stream.RecordCountStream</str>
      *  </lst>
      * */
 
@@ -80,12 +86,22 @@ public class StreamHandler extends RequestHandlerBase implements SolrCoreAware {
     }
 
      streamFactory
-      .withStreamFunction("search", CloudSolrStream.class)
-      .withStreamFunction("merge", MergeStream.class)
-      .withStreamFunction("unique", UniqueStream.class)
-      .withStreamFunction("top", RankStream.class)
-      .withStreamFunction("group", ReducerStream.class)
-      .withStreamFunction("parallel", ParallelStream.class);
+       // streams
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("merge", MergeStream.class)
+      .withFunctionName("unique", UniqueStream.class)
+      .withFunctionName("top", RankStream.class)
+      .withFunctionName("group", ReducerStream.class)
+      .withFunctionName("parallel", ParallelStream.class)
+      .withFunctionName("rollup", RollupStream.class)
+      
+      // metrics
+      .withFunctionName("min", MinMetric.class)
+      .withFunctionName("max", MaxMetric.class)
+      .withFunctionName("avg", MeanMetric.class)
+      .withFunctionName("sum", SumMetric.class)
+      .withFunctionName("count", CountMetric.class)
+      ;
 
     
     // This pulls all the overrides and additions from the config
@@ -94,7 +110,7 @@ public class StreamHandler extends RequestHandlerBase implements SolrCoreAware {
       NamedList<?> functionMappings = (NamedList<?>)functionMappingsObj;
       for(Entry<String,?> functionMapping : functionMappings){
         Class<?> clazz = core.getResourceLoader().findClass((String)functionMapping.getValue(), Expressible.class);
-        streamFactory.withStreamFunction(functionMapping.getKey(), clazz);
+        streamFactory.withFunctionName(functionMapping.getKey(), clazz);
       }
     }
         
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/eq/FieldEqualitor.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/eq/FieldEqualitor.java
index 5798b7f..c6ca8cf 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/eq/FieldEqualitor.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/eq/FieldEqualitor.java
@@ -17,10 +17,15 @@
 
 package org.apache.solr.client.solrj.io.eq;
 
+import java.io.Serializable;
+import java.util.Comparator;
+
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.comp.ComparatorOrder;
 import org.apache.solr.client.solrj.io.comp.FieldComparator;
 import org.apache.solr.client.solrj.io.comp.MultipleFieldComparator;
 import org.apache.solr.client.solrj.io.comp.StreamComparator;
+import org.apache.solr.client.solrj.io.stream.expr.Expressible;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionValue;
 import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
@@ -106,4 +111,11 @@ public class FieldEqualitor implements StreamEqualitor {
     
     return false;
   }
+  
+  public String getLeftFieldName(){
+    return leftFieldName;
+  }
+  public String getRightFieldName(){
+    return rightFieldName;
+  }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelStream.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelStream.java
index 4a25de2..7c2bdbd 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelStream.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ParallelStream.java
@@ -80,6 +80,10 @@ public class ParallelStream extends CloudSolrStream implements Expressible {
     init(zkHost,collection, tStream, workers,comp);
   }
 
+  public void setStreamFactory(StreamFactory streamFactory) {
+    this.streamFactory = streamFactory;
+  }
+
   public ParallelStream(StreamExpression expression, StreamFactory factory) throws IOException {
     // grab all parameters out
     objectSerialize = false;
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream.java
index 814755d..6a5f867 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream.java
@@ -21,22 +21,34 @@ package org.apache.solr.client.solrj.io.stream;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.ArrayList;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.comp.FieldComparator;
 import org.apache.solr.client.solrj.io.comp.HashKey;
 import org.apache.solr.client.solrj.io.comp.StreamComparator;
+import org.apache.solr.client.solrj.io.eq.FieldEqualitor;
+import org.apache.solr.client.solrj.io.eq.MultipleFieldEqualitor;
+import org.apache.solr.client.solrj.io.eq.StreamEqualitor;
+import org.apache.solr.client.solrj.io.stream.expr.Expressible;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionNamedParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionValue;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 import org.apache.solr.client.solrj.io.stream.metrics.Bucket;
 import org.apache.solr.client.solrj.io.stream.metrics.Metric;
 
-public class RollupStream extends TupleStream {
+public class RollupStream extends TupleStream implements Expressible {
 
   private static final long serialVersionUID = 1;
 
   private PushBackStream tupleStream;
   private Bucket[] buckets;
   private Metric[] metrics;
+  
   private HashKey currentKey = new HashKey("-");
   private Metric[] currentMetrics;
   private boolean finished = false;
@@ -44,17 +56,102 @@ public class RollupStream extends TupleStream {
   public RollupStream(TupleStream tupleStream,
                       Bucket[] buckets,
                       Metric[] metrics) {
+    init(tupleStream, buckets, metrics);
+  }
+  
+  public RollupStream(StreamExpression expression, StreamFactory factory) throws IOException {
+    // grab all parameters out
+    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);
+    List<StreamExpression> metricExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, Metric.class);
+    StreamExpressionNamedParameter overExpression = factory.getNamedOperand(expression, "over");
+    
+    // validate expression contains only what we want.
+    if(expression.getParameters().size() != streamExpressions.size() + metricExpressions.size() + 1){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    if(1 != streamExpressions.size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expecting a single stream but found %d",expression, streamExpressions.size()));
+    }
+    if(0 == metricExpressions.size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expecting at least 1 metric but found %d",expression, metricExpressions.size()));
+    }
+    if(null == overExpression || !(overExpression.getParameter() instanceof StreamExpressionValue)){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expecting single 'over' parameter listing fields to rollup by but didn't find one",expression));
+    }
+    
+    // Construct the metrics
+    Metric[] metrics = new Metric[metricExpressions.size()];
+    for(int idx = 0; idx < metricExpressions.size(); ++idx){
+      metrics[idx] = factory.constructMetric(metricExpressions.get(idx));
+    }
+    
+    // Construct the buckets.
+    // Buckets are nothing more than equalitors (I think). We can use equalitors as helpers for creating the buckets, but because
+    // I feel I'm missing something wrt buckets I don't want to change the use of buckets in this class to instead be equalitors.    
+    StreamEqualitor streamEqualitor = factory.constructEqualitor(((StreamExpressionValue)overExpression.getParameter()).getValue(), FieldEqualitor.class);
+    List<FieldEqualitor> flattenedEqualitors = flattenEqualitor(streamEqualitor);
+    Bucket[] buckets = new Bucket[flattenedEqualitors.size()];
+    for(int idx = 0; idx < flattenedEqualitors.size(); ++idx){
+      buckets[idx] = new Bucket(flattenedEqualitors.get(idx).getLeftFieldName());
+      // while we're using equalitors we don't support those of the form a=b. Only single field names.
+    }
+    
+    init(factory.constructStream(streamExpressions.get(0)), buckets, metrics);
+  }
+  
+  private List<FieldEqualitor> flattenEqualitor(StreamEqualitor equalitor){
+    List<FieldEqualitor> flattenedList = new ArrayList<>();
+    
+    if(equalitor instanceof FieldEqualitor){
+      flattenedList.add((FieldEqualitor)equalitor);
+    }
+    else if(equalitor instanceof MultipleFieldEqualitor){
+      MultipleFieldEqualitor mEqualitor = (MultipleFieldEqualitor)equalitor;
+      for(StreamEqualitor subEqualitor : mEqualitor.getEqs()){
+        flattenedList.addAll(flattenEqualitor(subEqualitor));
+      }
+    }
+    
+    return flattenedList;
+  }
+  
+  private void init(TupleStream tupleStream, Bucket[] buckets, Metric[] metrics){
     this.tupleStream = new PushBackStream(tupleStream);
     this.buckets = buckets;
     this.metrics = metrics;
   }
 
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    // function name
+    StreamExpression expression = new StreamExpression(factory.getFunctionName(this.getClass()));
+    
+    // stream
+    expression.addParameter(tupleStream.toExpression(factory));
+        
+    // over
+    StringBuilder overBuilder = new StringBuilder();
+    for(Bucket bucket : buckets){
+      if(overBuilder.length() > 0){ overBuilder.append(","); }
+      overBuilder.append(bucket.toString());
+    }
+    expression.addParameter(new StreamExpressionNamedParameter("over",overBuilder.toString()));
+    
+    // metrics
+    for(Metric metric : metrics){
+      expression.addParameter(metric.toExpression(factory));
+    }
+    
+    return expression;
+  }
+
   public void setStreamContext(StreamContext context) {
     this.tupleStream.setStreamContext(context);
   }
 
   public List<TupleStream> children() {
-    List<TupleStream> l =  new ArrayList();
+    List<TupleStream> l =  new ArrayList<TupleStream>();
     l.add(tupleStream);
     return l;
   }
@@ -67,10 +164,6 @@ public class RollupStream extends TupleStream {
     tupleStream.close();
   }
 
-  public StreamComparator getStreamSort(){
-    return tupleStream.getStreamSort();
-  }
-
   public Tuple read() throws IOException {
 
     while(true) {
@@ -79,7 +172,7 @@ public class RollupStream extends TupleStream {
         if(!finished) {
           Map map = new HashMap();
           for(Metric metric : currentMetrics) {
-            map.put(metric.getName(), metric.getValue());
+            map.put(metric.getIdentifier(), metric.getValue());
           }
 
           for(int i=0; i<buckets.length; i++) {
@@ -110,7 +203,7 @@ public class RollupStream extends TupleStream {
         if(currentMetrics != null) {
           Map map = new HashMap();
           for(Metric metric : currentMetrics) {
-            map.put(metric.getName(), metric.getValue());
+            map.put(metric.getIdentifier(), metric.getValue());
           }
 
           for(int i=0; i<buckets.length; i++) {
@@ -137,4 +230,9 @@ public class RollupStream extends TupleStream {
   public int getCost() {
     return 0;
   }
+
+  @Override
+  public StreamComparator getStreamSort() {
+    return tupleStream.getStreamSort();
+  }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/Expressible.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/Expressible.java
index 1543d2c..b87ff53 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/Expressible.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/Expressible.java
@@ -23,5 +23,7 @@ import java.io.IOException;
  * Defines a stream that can be expressed in an expression
  */
 public interface Expressible {
+//  public String getFunctionName();
+//  public void setFunctionName(String functionName);
   StreamExpressionParameter toExpression(StreamFactory factory) throws IOException;
 }
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java
index b9af358..9601b23 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java
@@ -11,14 +11,13 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
 
-import org.apache.solr.client.solrj.io.Tuple;
 import org.apache.solr.client.solrj.io.comp.ComparatorOrder;
 import org.apache.solr.client.solrj.io.comp.MultipleFieldComparator;
 import org.apache.solr.client.solrj.io.comp.StreamComparator;
-import org.apache.solr.client.solrj.io.eq.Equalitor;
 import org.apache.solr.client.solrj.io.eq.MultipleFieldEqualitor;
 import org.apache.solr.client.solrj.io.eq.StreamEqualitor;
 import org.apache.solr.client.solrj.io.stream.TupleStream;
+import org.apache.solr.client.solrj.io.stream.metrics.Metric;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -43,11 +42,11 @@ import org.apache.solr.client.solrj.io.stream.TupleStream;
 public class StreamFactory implements Serializable {
   
   private transient HashMap<String,String> collectionZkHosts;
-  private transient HashMap<String,Class> streamFunctions;
+  private transient HashMap<String,Class> functionNames;
   
   public StreamFactory(){
     collectionZkHosts = new HashMap<String,String>();
-    streamFunctions = new HashMap<String,Class>();
+    functionNames = new HashMap<String,Class>();
   }
   
   public StreamFactory withCollectionZkHost(String collectionName, String zkHost){
@@ -61,11 +60,11 @@ public class StreamFactory implements Serializable {
     return null;
   }
   
-  public Map<String,Class> getStreamFunctions(){
-    return streamFunctions;
+  public Map<String,Class> getFunctionNames(){
+    return functionNames;
   }
-  public StreamFactory withStreamFunction(String streamFunction, Class clazz){
-    this.streamFunctions.put(streamFunction, clazz);
+  public StreamFactory withFunctionName(String functionName, Class clazz){
+    this.functionNames.put(functionName, clazz);
     return this;
   }
   
@@ -150,9 +149,9 @@ public class StreamFactory implements Serializable {
     
     parameterLoop:
     for(StreamExpression streamExpression : allStreamExpressions){
-      if(streamFunctions.containsKey(streamExpression.getFunctionName())){
+      if(functionNames.containsKey(streamExpression.getFunctionName())){
         for(Class clazz : clazzes){
-          if(!clazz.isAssignableFrom(streamFunctions.get(streamExpression.getFunctionName()))){
+          if(!clazz.isAssignableFrom(functionNames.get(streamExpression.getFunctionName()))){
             continue parameterLoop;
           }
         }
@@ -169,16 +168,32 @@ public class StreamFactory implements Serializable {
   }
   public TupleStream constructStream(StreamExpression expression) throws IOException{
     String function = expression.getFunctionName();
-    if(streamFunctions.containsKey(function)){
-      Class clazz = streamFunctions.get(function);
+    if(functionNames.containsKey(function)){
+      Class clazz = functionNames.get(function);
       if(Expressible.class.isAssignableFrom(clazz) && TupleStream.class.isAssignableFrom(clazz)){
-        TupleStream stream = (TupleStream)createInstance(streamFunctions.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});
+        TupleStream stream = (TupleStream)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});
         return stream;
       }
     }
     
     throw new IOException(String.format(Locale.ROOT,"Invalid stream expression %s - function '%s' is unknown (not mapped to a valid TupleStream)", expression, expression.getFunctionName()));
   }
+  
+  public Metric constructMetric(String expressionClause) throws IOException {
+    return constructMetric(StreamExpressionParser.parse(expressionClause));
+  }
+  public Metric constructMetric(StreamExpression expression) throws IOException{
+    String function = expression.getFunctionName();
+    if(functionNames.containsKey(function)){
+      Class clazz = functionNames.get(function);
+      if(Expressible.class.isAssignableFrom(clazz) && Metric.class.isAssignableFrom(clazz)){
+        Metric metric = (Metric)createInstance(functionNames.get(function), new Class[]{ StreamExpression.class, StreamFactory.class }, new Object[]{ expression, this});
+        return metric;
+      }
+    }
+    
+    throw new IOException(String.format(Locale.ROOT,"Invalid metric expression %s - function '%s' is unknown (not mapped to a valid Metric)", expression, expression.getFunctionName()));
+  }
 
   public StreamComparator constructComparator(String comparatorString, Class comparatorType) throws IOException {
     if(comparatorString.contains(",")){
@@ -233,8 +248,6 @@ public class StreamFactory implements Serializable {
   }
 
   public <T> T createInstance(Class<T> clazz, Class<?>[] paramTypes, Object[] params) throws IOException{
-    // This should use SolrResourceLoader - TODO
-    // This is adding a restriction that the class has a public constructor - we may not want to do that
     Constructor<T> ctor;
     try {
       ctor = clazz.getConstructor(paramTypes);
@@ -246,7 +259,7 @@ public class StreamFactory implements Serializable {
   }
   
   public String getFunctionName(Class clazz) throws IOException{
-    for(Entry<String,Class> entry : streamFunctions.entrySet()){
+    for(Entry<String,Class> entry : functionNames.entrySet()){
       if(entry.getValue() == clazz){
         return entry.getKey();
       }
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Bucket.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Bucket.java
index 5d7347a..260a225 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Bucket.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Bucket.java
@@ -1,4 +1,4 @@
-package org.apache.solr.client.solrj.io.stream.metrics;
+  package org.apache.solr.client.solrj.io.stream.metrics;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/CountMetric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/CountMetric.java
index 9054428..8a56164 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/CountMetric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/CountMetric.java
@@ -16,18 +16,44 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  * limitations under the License.
  */
 
+import java.io.IOException;
 import java.io.Serializable;
+import java.util.Locale;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 
-public class CountMetric implements Metric, Serializable {
+public class CountMetric extends Metric implements Serializable {
 
   private static final long serialVersionUID = 1;
 
   private long count;
-
-  public String getName() {
-    return "count(*)";
+  
+  public CountMetric(){
+    init("count");
+  }
+  public CountMetric(StreamExpression expression, StreamFactory factory) throws IOException{
+    // grab all parameters out
+    String functionName = expression.getFunctionName();
+    String columnName = factory.getValueOperand(expression, 0);
+    
+    // validate expression contains only what we want.
+    if(!"*".equals(columnName)){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expected %s(*)", expression, functionName));
+    }
+    if(1 != expression.getParameters().size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    init(functionName);
+    
+  }
+  
+  private void init(String functionName){
+    setFunctionName(functionName);
+    setIdentifier(functionName, "(*)");
   }
 
   public void update(Tuple tuple) {
@@ -41,4 +67,8 @@ public class CountMetric implements Metric, Serializable {
   public Metric newInstance() {
     return new CountMetric();
   }
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    return new StreamExpression(getFunctionName()).withParameter("*");
+  }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java
index ed060e8..857106c 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MaxMetric.java
@@ -17,27 +17,49 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  * limitations under the License.
  */
 
+import java.io.IOException;
 import java.io.Serializable;
+import java.util.Locale;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 
-public class MaxMetric implements Metric, Serializable {
+public class MaxMetric extends Metric implements Serializable {
 
   private static final long serialVersionUID = 1;
 
   public static final String MAX = "max";
   private long longMax = -Long.MIN_VALUE;
   private double doubleMax = -Double.MAX_VALUE;
-  private String column;
+  private String columnName;
 
-  public MaxMetric(String column) {
-    this.column = column;
+  public MaxMetric(String columnName){
+    init("max", columnName);
   }
-
-  public String getName() {
-    return "max("+column+")";
+  public MaxMetric(StreamExpression expression, StreamFactory factory) throws IOException{
+    // grab all parameters out
+    String functionName = expression.getFunctionName();
+    String columnName = factory.getValueOperand(expression, 0);
+    
+    // validate expression contains only what we want.
+    if(null == columnName){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expected %s(columnName)", expression, functionName));
+    }
+    if(1 != expression.getParameters().size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    init(functionName, columnName);    
   }
-
+  
+  private void init(String functionName, String columnName){
+    this.columnName = columnName;
+    setFunctionName(functionName);
+    setIdentifier(functionName, "(", columnName, ")");
+  }
+  
   public double getValue() {
     if(longMax == Long.MIN_VALUE) {
       return doubleMax;
@@ -47,7 +69,7 @@ public class MaxMetric implements Metric, Serializable {
   }
 
   public void update(Tuple tuple) {
-    Object o = tuple.get(column);
+    Object o = tuple.get(columnName);
     if(o instanceof Double) {
       double d = (double)o;
       if(d > doubleMax) {
@@ -62,6 +84,11 @@ public class MaxMetric implements Metric, Serializable {
   }
 
   public Metric newInstance() {
-    return new MaxMetric(column);
+    return new MaxMetric(columnName);
+  }
+  
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    return new StreamExpression(getFunctionName()).withParameter(columnName);
   }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MeanMetric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MeanMetric.java
index 8132f6d..aa77579 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MeanMetric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MeanMetric.java
@@ -17,43 +17,68 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  * limitations under the License.
  */
 
+import java.io.IOException;
 import java.io.Serializable;
-import java.util.Map;
-import java.util.HashMap;
+import java.util.Locale;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 
-public class MeanMetric implements Metric, Serializable {
-
+public class MeanMetric extends Metric implements Serializable {
+  // How'd the MeanMetric get to be so mean?
+  // Maybe it was born with it.
+  // Maybe it was mayba-mean.
+  //
+  // I'll see myself out.
+  
   private static final long serialVersionUID = 1;
 
-  private String column;
+  private String columnName;
   private double doubleSum;
   private long longSum;
   private long count;
 
-  public MeanMetric(String column) {
-    this.column = column;
+  public MeanMetric(String columnName){
+    init("avg", columnName);
   }
-
-  public String getName() {
-    return "avg("+column+")";
+  public MeanMetric(StreamExpression expression, StreamFactory factory) throws IOException{
+    // grab all parameters out
+    String functionName = expression.getFunctionName();
+    String columnName = factory.getValueOperand(expression, 0);
+    
+    // validate expression contains only what we want.
+    if(null == columnName){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expected %s(columnName)", expression, functionName));
+    }
+    if(1 != expression.getParameters().size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    init(functionName, columnName);    
   }
-
+  
+  private void init(String functionName, String columnName){
+    this.columnName = columnName;
+    setFunctionName(functionName);
+    setIdentifier(functionName, "(", columnName, ")");
+  }
+  
   public void update(Tuple tuple) {
     ++count;
-    Object o = tuple.get(column);
+    Object o = tuple.get(columnName);
     if(o instanceof Double) {
-      Double d = (Double)tuple.get(column);
+      Double d = (Double)tuple.get(columnName);
       doubleSum += d.doubleValue();
     } else {
-      Long l = (Long)tuple.get(column);
+      Long l = (Long)tuple.get(columnName);
       longSum += l.doubleValue();
     }
   }
 
   public Metric newInstance() {
-    return new MeanMetric(column);
+    return new MeanMetric(columnName);
   }
 
   public double getValue() {
@@ -67,4 +92,9 @@ public class MeanMetric implements Metric, Serializable {
       return ave;
     }
   }
+  
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    return new StreamExpression(getFunctionName()).withParameter(columnName);
+  }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Metric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Metric.java
index 19f22df..6d17280 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Metric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/Metric.java
@@ -18,11 +18,41 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  */
 
 import java.io.Serializable;
+
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.Expressible;
 
-public interface Metric extends Serializable {
-  public String getName();
-  public double getValue();
-  public void update(Tuple tuple);
-  public Metric newInstance();
+public abstract class Metric implements Serializable, Expressible {
+  
+  private static final long serialVersionUID = 1L;
+  private String functionName;
+  private String identifier;
+  
+//  @Override
+  public String getFunctionName(){
+    return functionName;
+  }
+  
+//  @Override
+  public void setFunctionName(String functionName){
+    this.functionName = functionName;
+  }
+  
+  public String getIdentifier(){
+    return identifier;
+  }
+  public void setIdentifier(String identifier){
+    this.identifier = identifier;
+  }
+  public void setIdentifier(String ... identifierParts){
+    StringBuilder sb = new StringBuilder();
+    for(String part : identifierParts){
+      sb.append(part);
+    }
+    this.identifier = sb.toString();
+  }
+  
+  public abstract double getValue();
+  public abstract void update(Tuple tuple);
+  public abstract Metric newInstance();
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java
index 630634d..48b77ae 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/MinMetric.java
@@ -17,25 +17,47 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  * limitations under the License.
  */
 
-import java.io.Serializable;
+import java.io.IOException;
+import java.util.Locale;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 
-public class MinMetric implements Metric, Serializable {
-
-  private static final long serialVersionUID = 1;
+public class MinMetric extends Metric {
 
+  private static final long serialVersionUID = 1L;
+  
   private long longMin = Long.MAX_VALUE;
   private double doubleMin = Double.MAX_VALUE;
-  private String column;
+  private String columnName;
 
-  public MinMetric(String column) {
-    this.column = column;
+  public MinMetric(String columnName){
+    init("min", columnName);
   }
-
-  public String getName() {
-    return "min("+column+")";
+  public MinMetric(StreamExpression expression, StreamFactory factory) throws IOException{
+    // grab all parameters out
+    String functionName = expression.getFunctionName();
+    String columnName = factory.getValueOperand(expression, 0);
+    
+    // validate expression contains only what we want.
+    if(null == columnName){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expected %s(columnName)", expression, functionName));
+    }
+    if(1 != expression.getParameters().size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    init(functionName, columnName);    
   }
+  
+  private void init(String functionName, String columnName){
+    this.columnName = columnName;
+    setFunctionName(functionName);
+    setIdentifier(functionName, "(", columnName, ")");
+  }
+  
 
   public double getValue() {
     if(longMin == Long.MAX_VALUE) {
@@ -46,7 +68,7 @@ public class MinMetric implements Metric, Serializable {
   }
 
   public void update(Tuple tuple) {
-    Object o = tuple.get(column);
+    Object o = tuple.get(columnName);
     if(o instanceof Double) {
       double d = (double)o;
       if(d < doubleMin) {
@@ -61,6 +83,11 @@ public class MinMetric implements Metric, Serializable {
   }
 
   public Metric newInstance() {
-    return new MinMetric(column);
+    return new MinMetric(columnName);
+  }
+
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    return new StreamExpression(getFunctionName()).withParameter(columnName);
   }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/SumMetric.java b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/SumMetric.java
index 916b971..f709530 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/SumMetric.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/metrics/SumMetric.java
@@ -17,28 +17,50 @@ package org.apache.solr.client.solrj.io.stream.metrics;
  * limitations under the License.
  */
 
+import java.io.IOException;
 import java.io.Serializable;
+import java.util.Locale;
 
 import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 
-public class SumMetric implements Metric, Serializable {
+public class SumMetric extends Metric implements Serializable {
 
   private static final long serialVersionUID = 1;
 
-  private String column;
+  private String columnName;
   private double doubleSum;
   private long longSum;
 
-  public SumMetric(String column) {
-    this.column = column;
+  public SumMetric(String columnName){
+    init("sum", columnName);
   }
-
-  public String getName() {
-    return "sum("+column+")";
+  public SumMetric(StreamExpression expression, StreamFactory factory) throws IOException{
+    // grab all parameters out
+    String functionName = expression.getFunctionName();
+    String columnName = factory.getValueOperand(expression, 0);
+    
+    // validate expression contains only what we want.
+    if(null == columnName){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expected %s(columnName)", expression, functionName));
+    }
+    if(1 != expression.getParameters().size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+    
+    init(functionName, columnName);    
+  }
+  
+  private void init(String functionName, String columnName){
+    this.columnName = columnName;
+    setFunctionName(functionName);
+    setIdentifier(functionName, "(", columnName, ")");
   }
 
   public void update(Tuple tuple) {
-    Object o = tuple.get(column);
+    Object o = tuple.get(columnName);
     if(o instanceof Double) {
       Double d = (Double)o;
       doubleSum += d.doubleValue();
@@ -49,7 +71,7 @@ public class SumMetric implements Metric, Serializable {
   }
 
   public Metric newInstance() {
-    return new SumMetric(column);
+    return new SumMetric(columnName);
   }
 
   public double getValue() {
@@ -59,4 +81,9 @@ public class SumMetric implements Metric, Serializable {
       return (double)longSum;
     }
   }
+  
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    return new StreamExpression(getFunctionName()).withParameter(columnName);
+  }
 }
\ No newline at end of file
diff --git a/solr/solrj/src/test-files/solrj/solr/collection1/conf/solrconfig-streaming.xml b/solr/solrj/src/test-files/solrj/solr/collection1/conf/solrconfig-streaming.xml
index 0b0c84f..45b0d6d 100644
--- a/solr/solrj/src/test-files/solrj/solr/collection1/conf/solrconfig-streaming.xml
+++ b/solr/solrj/src/test-files/solrj/solr/collection1/conf/solrconfig-streaming.xml
@@ -56,9 +56,12 @@
       <str name="wt">json</str>
       <str name="distrib">false</str>
     </lst>
-    <lst name="streamFunctions">
-      <str name="count">org.apache.solr.client.solrj.io.stream.CountStream</str>
-    </lst>
+    
+    <!-- This is how you provide other functions --> 
+    <!-- <lst name="streamFunctions">
+      <str name="recordCount">org.apache.solr.client.solrj.io.stream.RecordCountStream</str>
+    </lst> -->
+    
   </requestHandler>
   
   <requestDispatcher handleSelect="true" >
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/CountStream.java b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/CountStream.java
deleted file mode 100644
index 10be13a..0000000
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/CountStream.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package  org.apache.solr.client.solrj.io.stream;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-
-import org.apache.solr.client.solrj.io.Tuple;
-import org.apache.solr.client.solrj.io.comp.StreamComparator;
-import org.apache.solr.client.solrj.io.stream.expr.Expressible;
-import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
-import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
-import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
-
-public class CountStream extends TupleStream implements Expressible, Serializable {
-
-  private TupleStream stream;
-  private int count;
-
-  public CountStream(TupleStream stream) {
-    this.stream = stream;
-  }
-  
-  public CountStream(StreamExpression expression, StreamFactory factory) throws IOException{
-    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);
-    
-    // validate expression contains only what we want.
-    if(expression.getParameters().size() != streamExpressions.size()){
-      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
-    }
-        
-    if(1 != streamExpressions.size()){
-      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expecting a single stream but found %d",expression, streamExpressions.size()));
-    }
-    
-    stream = factory.constructStream(streamExpressions.get(0));
-  }
-  
-  @Override
-  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
-    // function name
-    StreamExpression expression = new StreamExpression(factory.getFunctionName(this.getClass()));
-    
-    // stream
-    if(stream instanceof Expressible){
-      expression.addParameter(((Expressible)stream).toExpression(factory));
-    }
-    else{
-      throw new IOException("This CountStream contains a non-expressible TupleStream - it cannot be converted to an expression");
-    }
-    
-    return expression;
-  }
-
-  public void close() throws IOException {
-    this.stream.close();
-  }
-
-  public void open() throws IOException {
-    this.stream.open();
-  }
-
-  public List<TupleStream> children() {
-    List<TupleStream> l = new ArrayList();
-    l.add(stream);
-    return l;
-  }
-
-  public void setStreamContext(StreamContext streamContext) {
-    stream.setStreamContext(streamContext);
-  }
-
-  public Tuple read() throws IOException {
-    Tuple t = stream.read();
-    if(t.EOF) {
-      t.put("count", count);
-      return t;
-    } else {
-      ++count;
-      return t;
-    }
-  }
-
-  @Override
-  public StreamComparator getStreamSort() {
-    return null;
-  }
-}
\ No newline at end of file
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/RecordCountStream.java b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/RecordCountStream.java
new file mode 100644
index 0000000..41450fd
--- /dev/null
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/RecordCountStream.java
@@ -0,0 +1,105 @@
+package  org.apache.solr.client.solrj.io.stream;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.solr.client.solrj.io.Tuple;
+import org.apache.solr.client.solrj.io.comp.StreamComparator;
+import org.apache.solr.client.solrj.io.stream.expr.Expressible;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
+import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;
+import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
+
+public class RecordCountStream extends TupleStream implements Expressible, Serializable {
+
+  private TupleStream stream;
+  private int count;
+
+  public RecordCountStream(TupleStream stream) {
+    this.stream = stream;
+  }
+  
+  public RecordCountStream(StreamExpression expression, StreamFactory factory) throws IOException{
+    List<StreamExpression> streamExpressions = factory.getExpressionOperandsRepresentingTypes(expression, Expressible.class, TupleStream.class);
+    
+    // validate expression contains only what we want.
+    if(expression.getParameters().size() != streamExpressions.size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - unknown operands found", expression));
+    }
+        
+    if(1 != streamExpressions.size()){
+      throw new IOException(String.format(Locale.ROOT,"Invalid expression %s - expecting a single stream but found %d",expression, streamExpressions.size()));
+    }
+    
+    stream = factory.constructStream(streamExpressions.get(0));
+  }
+  
+  @Override
+  public StreamExpressionParameter toExpression(StreamFactory factory) throws IOException {
+    // function name
+    StreamExpression expression = new StreamExpression(factory.getFunctionName(this.getClass()));
+    
+    // stream
+    if(stream instanceof Expressible){
+      expression.addParameter(((Expressible)stream).toExpression(factory));
+    }
+    else{
+      throw new IOException("This RecordCountStream contains a non-expressible TupleStream - it cannot be converted to an expression");
+    }
+    
+    return expression;
+  }
+
+  public void close() throws IOException {
+    this.stream.close();
+  }
+
+  public void open() throws IOException {
+    this.stream.open();
+  }
+
+  public List<TupleStream> children() {
+    List<TupleStream> l = new ArrayList();
+    l.add(stream);
+    return l;
+  }
+
+  public void setStreamContext(StreamContext streamContext) {
+    stream.setStreamContext(streamContext);
+  }
+
+  public Tuple read() throws IOException {
+    Tuple t = stream.read();
+    if(t.EOF) {
+      t.put("count", count);
+      return t;
+    } else {
+      ++count;
+      return t;
+    }
+  }
+
+  @Override
+  public StreamComparator getStreamSort() {
+    return null;
+  }
+}
\ No newline at end of file
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionTest.java b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionTest.java
index 350f44c..be77d4a 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionTest.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionTest.java
@@ -29,6 +29,13 @@ import org.apache.solr.client.solrj.io.Tuple;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParser;
 import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
+import org.apache.solr.client.solrj.io.stream.metrics.Bucket;
+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.Metric;
+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;
 import org.apache.solr.cloud.AbstractFullDistribZkTestBase;
 import org.apache.solr.cloud.AbstractZkTestCase;
 import org.apache.solr.common.SolrInputDocument;
@@ -118,10 +125,12 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     testRankStream();
     testReducerStream();
     testUniqueStream();
+    testRollupStream();
     testParallelUniqueStream();
     testParallelReducerStream();
     testParallelRankStream();
     testParallelMergeStream();
+    testParallelRollupStream();
   }
 
   private void testCloudSolrStream() throws Exception {
@@ -232,8 +241,8 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     
     StreamFactory factory = new StreamFactory()
       .withCollectionZkHost("collection1", zkServer.getZkAddress())
-      .withStreamFunction("search", CloudSolrStream.class)
-      .withStreamFunction("unique", UniqueStream.class);
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("unique", UniqueStream.class);
     
     // Basic test
     expression = StreamExpressionParser.parse("unique(search(collection1, q=*:*, fl=\"id,a_s,a_i,a_f\", sort=\"a_f asc, a_i asc\"), over=\"a_f\")");
@@ -285,9 +294,9 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     
     StreamFactory factory = new StreamFactory()
       .withCollectionZkHost("collection1", zkServer.getZkAddress())
-      .withStreamFunction("search", CloudSolrStream.class)
-      .withStreamFunction("unique", UniqueStream.class)
-      .withStreamFunction("merge", MergeStream.class);
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("unique", UniqueStream.class)
+      .withFunctionName("merge", MergeStream.class);
     
     // Basic test
     expression = StreamExpressionParser.parse("merge("
@@ -351,9 +360,9 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     
     StreamFactory factory = new StreamFactory()
       .withCollectionZkHost("collection1", zkServer.getZkAddress())
-      .withStreamFunction("search", CloudSolrStream.class)
-      .withStreamFunction("unique", UniqueStream.class)
-      .withStreamFunction("top", RankStream.class);
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("unique", UniqueStream.class)
+      .withFunctionName("top", RankStream.class);
     
     // Basic test
     expression = StreamExpressionParser.parse("top("
@@ -416,10 +425,10 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     
     StreamFactory factory = new StreamFactory()
       .withCollectionZkHost("collection1", zkServer.getZkAddress())
-      .withStreamFunction("search", CloudSolrStream.class)
-      .withStreamFunction("unique", UniqueStream.class)
-      .withStreamFunction("top", RankStream.class)
-      .withStreamFunction("group", ReducerStream.class);
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("unique", UniqueStream.class)
+      .withFunctionName("top", RankStream.class)
+      .withFunctionName("group", ReducerStream.class);
 
     // basic
     expression = StreamExpressionParser.parse("group("
@@ -469,6 +478,128 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     commit();
   }
 
+  private void testRollupStream() throws Exception {
+
+    indexr(id, "0", "a_s", "hello0", "a_i", "0", "a_f", "1");
+    indexr(id, "2", "a_s", "hello0", "a_i", "2", "a_f", "2");
+    indexr(id, "3", "a_s", "hello3", "a_i", "3", "a_f", "3");
+    indexr(id, "4", "a_s", "hello4", "a_i", "4", "a_f", "4");
+    indexr(id, "1", "a_s", "hello0", "a_i", "1", "a_f", "5");
+    indexr(id, "5", "a_s", "hello3", "a_i", "10", "a_f", "6");
+    indexr(id, "6", "a_s", "hello4", "a_i", "11", "a_f", "7");
+    indexr(id, "7", "a_s", "hello3", "a_i", "12", "a_f", "8");
+    indexr(id, "8", "a_s", "hello3", "a_i", "13", "a_f", "9");
+    indexr(id, "9", "a_s", "hello0", "a_i", "14", "a_f", "10");
+
+    commit();
+
+    StreamFactory factory = new StreamFactory()
+      .withCollectionZkHost("collection1", zkServer.getZkAddress())
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("rollup", RollupStream.class)
+      .withFunctionName("sum", SumMetric.class)
+      .withFunctionName("min", MinMetric.class)
+      .withFunctionName("max", MaxMetric.class)
+      .withFunctionName("avg", MeanMetric.class)
+      .withFunctionName("count", CountMetric.class);     
+    
+    StreamExpression expression;
+    TupleStream stream;
+    List<Tuple> tuples;
+
+    expression = StreamExpressionParser.parse("rollup("
+                                              + "search(collection1, q=*:*, fl=\"a_s,a_i,a_f\", sort=\"a_s asc\"),"
+                                              + "over=\"a_s\","
+                                              + "sum(a_i),"
+                                              + "sum(a_f),"
+                                              + "min(a_i),"
+                                              + "min(a_f),"
+                                              + "max(a_i),"
+                                              + "max(a_f),"
+                                              + "avg(a_i),"
+                                              + "avg(a_f),"
+                                              + "count(*),"
+                                              + ")");
+    stream = factory.constructStream(expression);
+    tuples = getTuples(stream);
+
+    assert(tuples.size() == 3);
+
+    //Test Long and Double Sums
+
+    Tuple tuple = tuples.get(0);
+    String bucket = tuple.getString("a_s");
+    Double sumi = tuple.getDouble("sum(a_i)");
+    Double sumf = tuple.getDouble("sum(a_f)");
+    Double mini = tuple.getDouble("min(a_i)");
+    Double minf = tuple.getDouble("min(a_f)");
+    Double maxi = tuple.getDouble("max(a_i)");
+    Double maxf = tuple.getDouble("max(a_f)");
+    Double avgi = tuple.getDouble("avg(a_i)");
+    Double avgf = tuple.getDouble("avg(a_f)");
+    Double count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello0"));
+    assertTrue(sumi.doubleValue() == 17.0D);
+    assertTrue(sumf.doubleValue() == 18.0D);
+    assertTrue(mini.doubleValue() == 0.0D);
+    assertTrue(minf.doubleValue() == 1.0D);
+    assertTrue(maxi.doubleValue() == 14.0D);
+    assertTrue(maxf.doubleValue() == 10.0D);
+    assertTrue(avgi.doubleValue() == 4.25D);
+    assertTrue(avgf.doubleValue() == 4.5D);
+    assertTrue(count.doubleValue() == 4);
+
+    tuple = tuples.get(1);
+    bucket = tuple.getString("a_s");
+    sumi = tuple.getDouble("sum(a_i)");
+    sumf = tuple.getDouble("sum(a_f)");
+    mini = tuple.getDouble("min(a_i)");
+    minf = tuple.getDouble("min(a_f)");
+    maxi = tuple.getDouble("max(a_i)");
+    maxf = tuple.getDouble("max(a_f)");
+    avgi = tuple.getDouble("avg(a_i)");
+    avgf = tuple.getDouble("avg(a_f)");
+    count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello3"));
+    assertTrue(sumi.doubleValue() == 38.0D);
+    assertTrue(sumf.doubleValue() == 26.0D);
+    assertTrue(mini.doubleValue() == 3.0D);
+    assertTrue(minf.doubleValue() == 3.0D);
+    assertTrue(maxi.doubleValue() == 13.0D);
+    assertTrue(maxf.doubleValue() == 9.0D);
+    assertTrue(avgi.doubleValue() == 9.5D);
+    assertTrue(avgf.doubleValue() == 6.5D);
+    assertTrue(count.doubleValue() == 4);
+
+    tuple = tuples.get(2);
+    bucket = tuple.getString("a_s");
+    sumi = tuple.getDouble("sum(a_i)");
+    sumf = tuple.getDouble("sum(a_f)");
+    mini = tuple.getDouble("min(a_i)");
+    minf = tuple.getDouble("min(a_f)");
+    maxi = tuple.getDouble("max(a_i)");
+    maxf = tuple.getDouble("max(a_f)");
+    avgi = tuple.getDouble("avg(a_i)");
+    avgf = tuple.getDouble("avg(a_f)");
+    count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello4"));
+    assertTrue(sumi.longValue() == 15);
+    assertTrue(sumf.doubleValue() == 11.0D);
+    assertTrue(mini.doubleValue() == 4.0D);
+    assertTrue(minf.doubleValue() == 4.0D);
+    assertTrue(maxi.doubleValue() == 11.0D);
+    assertTrue(maxf.doubleValue() == 7.0D);
+    assertTrue(avgi.doubleValue() == 7.5D);
+    assertTrue(avgf.doubleValue() == 5.5D);
+    assertTrue(count.doubleValue() == 2);
+
+    del("*:*");
+    commit();
+  }
+  
   private void testParallelUniqueStream() throws Exception {
 
     indexr(id, "0", "a_s", "hello0", "a_i", "0", "a_f", "0");
@@ -485,11 +616,11 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
 
     String zkHost = zkServer.getZkAddress();
     StreamFactory streamFactory = new StreamFactory().withCollectionZkHost("collection1", zkServer.getZkAddress())
-        .withStreamFunction("search", CloudSolrStream.class)
-        .withStreamFunction("unique", UniqueStream.class)
-        .withStreamFunction("top", RankStream.class)
-        .withStreamFunction("group", ReducerStream.class)
-        .withStreamFunction("parallel", ParallelStream.class);
+        .withFunctionName("search", CloudSolrStream.class)
+        .withFunctionName("unique", UniqueStream.class)
+        .withFunctionName("top", RankStream.class)
+        .withFunctionName("group", ReducerStream.class)
+        .withFunctionName("parallel", ParallelStream.class);
 
     ParallelStream pstream = (ParallelStream)streamFactory.constructStream("parallel(collection1, unique(search(collection1, q=*:*, fl=\"id,a_s,a_i,a_f\", sort=\"a_f asc, a_i asc\", partitionKeys=\"a_f\"), over=\"a_f\"), workers=\"2\", zkHost=\""+zkHost+"\", sort=\"a_f asc\")");
 
@@ -524,11 +655,11 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
 
     String zkHost = zkServer.getZkAddress();
     StreamFactory streamFactory = new StreamFactory().withCollectionZkHost("collection1", zkServer.getZkAddress())
-        .withStreamFunction("search", CloudSolrStream.class)
-        .withStreamFunction("unique", UniqueStream.class)
-        .withStreamFunction("top", RankStream.class)
-        .withStreamFunction("group", ReducerStream.class)
-        .withStreamFunction("parallel", ParallelStream.class);
+        .withFunctionName("search", CloudSolrStream.class)
+        .withFunctionName("unique", UniqueStream.class)
+        .withFunctionName("top", RankStream.class)
+        .withFunctionName("group", ReducerStream.class)
+        .withFunctionName("parallel", ParallelStream.class);
 
     ParallelStream pstream = (ParallelStream)streamFactory.constructStream("parallel(collection1, group(search(collection1, q=\"*:*\", fl=\"id,a_s,a_i,a_f\", sort=\"a_s asc,a_f asc\", partitionKeys=\"a_s\"), by=\"a_s asc\"), workers=\"2\", zkHost=\""+zkHost+"\", sort=\"a_s asc\")");
 
@@ -595,11 +726,11 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
 
     String zkHost = zkServer.getZkAddress();
     StreamFactory streamFactory = new StreamFactory().withCollectionZkHost("collection1", zkServer.getZkAddress())
-        .withStreamFunction("search", CloudSolrStream.class)
-        .withStreamFunction("unique", UniqueStream.class)
-        .withStreamFunction("top", RankStream.class)
-        .withStreamFunction("group", ReducerStream.class)
-        .withStreamFunction("parallel", ParallelStream.class);
+        .withFunctionName("search", CloudSolrStream.class)
+        .withFunctionName("unique", UniqueStream.class)
+        .withFunctionName("top", RankStream.class)
+        .withFunctionName("group", ReducerStream.class)
+        .withFunctionName("parallel", ParallelStream.class);
 
     ParallelStream pstream = (ParallelStream)streamFactory.constructStream("parallel("
         + "collection1, "
@@ -634,12 +765,12 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
 
     String zkHost = zkServer.getZkAddress();
     StreamFactory streamFactory = new StreamFactory().withCollectionZkHost("collection1", zkServer.getZkAddress())
-        .withStreamFunction("search", CloudSolrStream.class)
-        .withStreamFunction("unique", UniqueStream.class)
-        .withStreamFunction("top", RankStream.class)
-        .withStreamFunction("group", ReducerStream.class)
-        .withStreamFunction("merge", MergeStream.class)
-        .withStreamFunction("parallel", ParallelStream.class);
+        .withFunctionName("search", CloudSolrStream.class)
+        .withFunctionName("unique", UniqueStream.class)
+        .withFunctionName("top", RankStream.class)
+        .withFunctionName("group", ReducerStream.class)
+        .withFunctionName("merge", MergeStream.class)
+        .withFunctionName("parallel", ParallelStream.class);
 
     //Test ascending
     ParallelStream pstream = (ParallelStream)streamFactory.constructStream("parallel(collection1, merge(search(collection1, q=\"id:(4 1 8 7 9)\", fl=\"id,a_s,a_i\", sort=\"a_i asc\", partitionKeys=\"a_i\"), search(collection1, q=\"id:(0 2 3 6)\", fl=\"id,a_s,a_i\", sort=\"a_i asc\", partitionKeys=\"a_i\"), on=\"a_i asc\"), workers=\"2\", zkHost=\""+zkHost+"\", sort=\"a_i asc\")");
@@ -663,7 +794,132 @@ public class StreamExpressionTest extends AbstractFullDistribZkTestBase {
     del("*:*");
     commit();
   }
+  
+  private void testParallelRollupStream() throws Exception {
 
+    indexr(id, "0", "a_s", "hello0", "a_i", "0", "a_f", "1");
+    indexr(id, "2", "a_s", "hello0", "a_i", "2", "a_f", "2");
+    indexr(id, "3", "a_s", "hello3", "a_i", "3", "a_f", "3");
+    indexr(id, "4", "a_s", "hello4", "a_i", "4", "a_f", "4");
+    indexr(id, "1", "a_s", "hello0", "a_i", "1", "a_f", "5");
+    indexr(id, "5", "a_s", "hello3", "a_i", "10", "a_f", "6");
+    indexr(id, "6", "a_s", "hello4", "a_i", "11", "a_f", "7");
+    indexr(id, "7", "a_s", "hello3", "a_i", "12", "a_f", "8");
+    indexr(id, "8", "a_s", "hello3", "a_i", "13", "a_f", "9");
+    indexr(id, "9", "a_s", "hello0", "a_i", "14", "a_f", "10");
+
+    commit();
+
+    StreamFactory factory = new StreamFactory()
+      .withCollectionZkHost("collection1", zkServer.getZkAddress())
+      .withFunctionName("search", CloudSolrStream.class)
+      .withFunctionName("parallel", ParallelStream.class)
+      .withFunctionName("rollup", RollupStream.class)
+      .withFunctionName("sum", SumMetric.class)
+      .withFunctionName("min", MinMetric.class)
+      .withFunctionName("max", MaxMetric.class)
+      .withFunctionName("avg", MeanMetric.class)
+      .withFunctionName("count", CountMetric.class);     
+    
+    StreamExpression expression;
+    TupleStream stream;
+    List<Tuple> tuples;
+
+    expression = StreamExpressionParser.parse("parallel(collection1,"
+                                              + "rollup("
+                                                + "search(collection1, q=*:*, fl=\"a_s,a_i,a_f\", sort=\"a_s asc\", partitionKeys=\"a_s\"),"
+                                                + "over=\"a_s\","
+                                                + "sum(a_i),"
+                                                + "sum(a_f),"
+                                                + "min(a_i),"
+                                                + "min(a_f),"
+                                                + "max(a_i),"
+                                                + "max(a_f),"
+                                                + "avg(a_i),"
+                                                + "avg(a_f),"
+                                                + "count(*)"
+                                              + "),"
+                                              + "workers=\"2\", zkHost=\""+zkServer.getZkAddress()+"\", sort=\"a_s asc\")"
+                                              );
+    stream = factory.constructStream(expression);
+    tuples = getTuples(stream);
+
+    assert(tuples.size() == 3);
+
+    //Test Long and Double Sums
+
+    Tuple tuple = tuples.get(0);
+    String bucket = tuple.getString("a_s");
+    Double sumi = tuple.getDouble("sum(a_i)");
+    Double sumf = tuple.getDouble("sum(a_f)");
+    Double mini = tuple.getDouble("min(a_i)");
+    Double minf = tuple.getDouble("min(a_f)");
+    Double maxi = tuple.getDouble("max(a_i)");
+    Double maxf = tuple.getDouble("max(a_f)");
+    Double avgi = tuple.getDouble("avg(a_i)");
+    Double avgf = tuple.getDouble("avg(a_f)");
+    Double count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello0"));
+    assertTrue(sumi.doubleValue() == 17.0D);
+    assertTrue(sumf.doubleValue() == 18.0D);
+    assertTrue(mini.doubleValue() == 0.0D);
+    assertTrue(minf.doubleValue() == 1.0D);
+    assertTrue(maxi.doubleValue() == 14.0D);
+    assertTrue(maxf.doubleValue() == 10.0D);
+    assertTrue(avgi.doubleValue() == 4.25D);
+    assertTrue(avgf.doubleValue() == 4.5D);
+    assertTrue(count.doubleValue() == 4);
+
+    tuple = tuples.get(1);
+    bucket = tuple.getString("a_s");
+    sumi = tuple.getDouble("sum(a_i)");
+    sumf = tuple.getDouble("sum(a_f)");
+    mini = tuple.getDouble("min(a_i)");
+    minf = tuple.getDouble("min(a_f)");
+    maxi = tuple.getDouble("max(a_i)");
+    maxf = tuple.getDouble("max(a_f)");
+    avgi = tuple.getDouble("avg(a_i)");
+    avgf = tuple.getDouble("avg(a_f)");
+    count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello3"));
+    assertTrue(sumi.doubleValue() == 38.0D);
+    assertTrue(sumf.doubleValue() == 26.0D);
+    assertTrue(mini.doubleValue() == 3.0D);
+    assertTrue(minf.doubleValue() == 3.0D);
+    assertTrue(maxi.doubleValue() == 13.0D);
+    assertTrue(maxf.doubleValue() == 9.0D);
+    assertTrue(avgi.doubleValue() == 9.5D);
+    assertTrue(avgf.doubleValue() == 6.5D);
+    assertTrue(count.doubleValue() == 4);
+
+    tuple = tuples.get(2);
+    bucket = tuple.getString("a_s");
+    sumi = tuple.getDouble("sum(a_i)");
+    sumf = tuple.getDouble("sum(a_f)");
+    mini = tuple.getDouble("min(a_i)");
+    minf = tuple.getDouble("min(a_f)");
+    maxi = tuple.getDouble("max(a_i)");
+    maxf = tuple.getDouble("max(a_f)");
+    avgi = tuple.getDouble("avg(a_i)");
+    avgf = tuple.getDouble("avg(a_f)");
+    count = tuple.getDouble("count(*)");
+
+    assertTrue(bucket.equals("hello4"));
+    assertTrue(sumi.longValue() == 15);
+    assertTrue(sumf.doubleValue() == 11.0D);
+    assertTrue(mini.doubleValue() == 4.0D);
+    assertTrue(minf.doubleValue() == 4.0D);
+    assertTrue(maxi.doubleValue() == 11.0D);
+    assertTrue(maxf.doubleValue() == 7.0D);
+    assertTrue(avgi.doubleValue() == 7.5D);
+    assertTrue(avgf.doubleValue() == 5.5D);
+    assertTrue(count.doubleValue() == 2);
+
+    del("*:*");
+    commit();
+  }
 
   protected List<Tuple> getTuples(TupleStream tupleStream) throws IOException {
     tupleStream.open();
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionToExpessionTest.java b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionToExpessionTest.java
index 5c5260f..95a3df4 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionToExpessionTest.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamExpressionToExpessionTest.java
@@ -17,15 +17,15 @@ package org.apache.solr.client.solrj.io.stream;
  * limitations under the License.
  */
 
-import java.util.List;
-
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.solr.client.solrj.io.Tuple;
-import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;
-import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionNamedParameter;
 import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParser;
-import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionValue;
 import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
+import org.apache.solr.client.solrj.io.stream.metrics.CountMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MaxMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.MeanMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.Metric;
+import org.apache.solr.client.solrj.io.stream.metrics.MinMetric;
+import org.apache.solr.client.solrj.io.stream.metrics.SumMetric;
 import org.junit.Test;
 
 /**
@@ -40,11 +40,16 @@ public class StreamExpressionToExpessionTest extends LuceneTestCase {
     
     factory = new StreamFactory()
                     .withCollectionZkHost("collection1", "testhost:1234")
-                    .withStreamFunction("search", CloudSolrStream.class)
-                    .withStreamFunction("merge", MergeStream.class)
-                    .withStreamFunction("unique", UniqueStream.class)
-                    .withStreamFunction("top", RankStream.class)
-                    .withStreamFunction("group", ReducerStream.class)
+                    .withFunctionName("search", CloudSolrStream.class)
+                    .withFunctionName("merge", MergeStream.class)
+                    .withFunctionName("unique", UniqueStream.class)
+                    .withFunctionName("top", RankStream.class)
+                    .withFunctionName("group", ReducerStream.class)
+                    .withFunctionName("count", CountMetric.class)
+                    .withFunctionName("sum", SumMetric.class)
+                    .withFunctionName("min", MinMetric.class)
+                    .withFunctionName("max", MaxMetric.class)
+                    .withFunctionName("avg", MeanMetric.class)
                     ;
   }
   
@@ -133,5 +138,69 @@ public class StreamExpressionToExpessionTest extends LuceneTestCase {
     assertTrue(expressionString.contains("group(search(collection1"));
     assertTrue(expressionString.contains("by=\"a_s desc\""));
   }
+  
+  @Test
+  public void testCountMetric() throws Exception {
+
+    Metric metric;
+    String expressionString;
+    
+    // Basic test
+    metric = new CountMetric(StreamExpressionParser.parse("count(*)"), factory);
+    expressionString = metric.toExpression(factory).toString();
+    
+    assertEquals("count(*)", expressionString);
+  }
+  
+  @Test
+  public void testMaxMetric() throws Exception {
+
+    Metric metric;
+    String expressionString;
+    
+    // Basic test
+    metric = new MaxMetric(StreamExpressionParser.parse("max(foo)"), factory);
+    expressionString = metric.toExpression(factory).toString();
+    
+    assertEquals("max(foo)", expressionString);
+  }
+  
+  @Test
+  public void testMinMetric() throws Exception {
+
+    Metric metric;
+    String expressionString;
+    
+    // Basic test
+    metric = new MinMetric(StreamExpressionParser.parse("min(foo)"), factory);
+    expressionString = metric.toExpression(factory).toString();
+    
+    assertEquals("min(foo)", expressionString);
+  }
+
+  @Test
+  public void testMeanMetric() throws Exception {
+
+    Metric metric;
+    String expressionString;
+    
+    // Basic test
+    metric = new MeanMetric(StreamExpressionParser.parse("avg(foo)"), factory);
+    expressionString = metric.toExpression(factory).toString();
+    
+    assertEquals("avg(foo)", expressionString);
+  }
+  
+  @Test
+  public void testSumMetric() throws Exception {
 
+    Metric metric;
+    String expressionString;
+    
+    // Basic test
+    metric = new SumMetric(StreamExpressionParser.parse("sum(foo)"), factory);
+    expressionString = metric.toExpression(factory).toString();
+    
+    assertEquals("sum(foo)", expressionString);
+  }
 }
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java
index 63a8610..e739b77 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/io/stream/StreamingTest.java
@@ -31,6 +31,7 @@ import org.apache.solr.client.solrj.io.Tuple;
 import org.apache.solr.client.solrj.io.comp.ComparatorOrder;
 import org.apache.solr.client.solrj.io.comp.MultipleFieldComparator;
 import org.apache.solr.client.solrj.io.comp.FieldComparator;
+import org.apache.solr.client.solrj.io.comp.StreamComparator;
 import org.apache.solr.client.solrj.io.eq.FieldEqualitor;
 import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;
 import org.apache.solr.client.solrj.io.stream.metrics.Bucket;
@@ -112,12 +113,12 @@ public class StreamingTest extends AbstractFullDistribZkTestBase {
     sliceCount = 2;
 
     streamFactory = new StreamFactory()
-                    .withStreamFunction("search", CloudSolrStream.class)
-                    .withStreamFunction("merge", MergeStream.class)
-                    .withStreamFunction("unique", UniqueStream.class)
-                    .withStreamFunction("top", RankStream.class)
-                    .withStreamFunction("group", ReducerStream.class)
-                    .withStreamFunction("count", CountStream.class)
+                    .withFunctionName("search", CloudSolrStream.class)
+                    .withFunctionName("merge", MergeStream.class)
+                    .withFunctionName("unique", UniqueStream.class)
+                    .withFunctionName("top", RankStream.class)
+                    .withFunctionName("group", ReducerStream.class)
+                    .withFunctionName("count", RecordCountStream.class)
                     ;
   }
 
@@ -144,18 +145,6 @@ public class StreamingTest extends AbstractFullDistribZkTestBase {
     assert(tuples.size() == 4);
     assertOrder(tuples, 0,1,3,4);
 
-
-    try {
-      params = mapParams("q","*:*","fl","id,a_s,a_i,a_f","sort", "a_f asc,a_i asc");
-      stream = new CloudSolrStream(zkHost, "collection1", params);
-      ustream = new UniqueStream(stream, new FieldEqualitor("a_i"));
-      throw new Exception("Equalitors did not match but no excepion was thrown");
-    } catch(Exception e) {
-      if(!e.getMessage().equals("Invalid UniqueStream - substream comparator (sort) must be a superset of this stream's equalitor.")) {
-        throw e;
-      }
-    }
-
     del("*:*");
     commit();
 
@@ -385,18 +374,6 @@ public class StreamingTest extends AbstractFullDistribZkTestBase {
     List<Map> maps2 = t2.getMaps();
     assertMaps(maps2, 4, 6);
 
-    try {
-
-      paramsA = mapParams("q","*:*","fl","id,a_s, a_i,  a_f","sort", "a_i asc  ,  a_f   asc");
-      stream = new CloudSolrStream(zkHost, "collection1", paramsA);
-      rstream = new ReducerStream(stream, new FieldComparator("a_s",ComparatorOrder.ASCENDING));
-      throw new Exception("Sorts did not match up and Exception was not not thrown.");
-    } catch (Exception e) {
-      if(!e.getMessage().equals("Invalid ReducerStream - substream comparator (sort) must be a superset of this stream's comparator.")) {
-        throw e;
-      }
-    }
-
 
 
     del("*:*");
@@ -957,35 +934,6 @@ public class StreamingTest extends AbstractFullDistribZkTestBase {
     assert(tuples.size() == 5);
     assertOrder(tuples, 2,0,1,3,4);
 
-    try {
-      paramsA = mapParams("q","id:(2 4 1)","fl","id,a_s,a_i,a_f","sort", "a_f desc,a_i desc");
-      streamA = new CloudSolrStream(zkHost, "collection1", paramsA);
-
-      paramsB = mapParams("q","id:(0 3)","fl","id,a_s,a_i,a_f","sort", "a_f asc,a_i desc");
-      streamB = new CloudSolrStream(zkHost, "collection1", paramsB);
-      mstream = new MergeStream(streamA, streamB, new MultipleFieldComparator(new FieldComparator("a_f",ComparatorOrder.ASCENDING),new FieldComparator("a_i",ComparatorOrder.DESCENDING)));
-      throw new Exception("Sorts did not match up and Exception was not not thrown.");
-    } catch(Exception e) {
-      if(!e.getMessage().equals("Invalid MergeStream - both substream comparators (sort) must be a superset of this stream's comparator.")) {
-        throw e;
-      }
-    }
-
-    try {
-      paramsA = mapParams("q","id:(2 4 1)","fl","id,a_s,a_i,a_f","sort", "a_f asc,a_i desc");
-      streamA = new CloudSolrStream(zkHost, "collection1", paramsA);
-
-      paramsB = mapParams("q","id:(0 3)","fl","id,a_s,a_i,a_f","sort", "a_f asc,a_i asc");
-      streamB = new CloudSolrStream(zkHost, "collection1", paramsB);
-      mstream = new MergeStream(streamA, streamB, new MultipleFieldComparator(new FieldComparator("a_f",ComparatorOrder.ASCENDING),new FieldComparator("a_i",ComparatorOrder.DESCENDING)));
-      throw new Exception("Sorts did not match up and Exception was not not thrown.");
-    } catch(Exception e) {
-      if(!e.getMessage().equals("Invalid MergeStream - both substream comparators (sort) must be a superset of this stream's comparator.")) {
-        throw e;
-      }
-    }
-
-
     del("*:*");
     commit();
   }
@@ -1067,7 +1015,7 @@ public class StreamingTest extends AbstractFullDistribZkTestBase {
     CloudSolrStream streamB = new CloudSolrStream(zkHost, "collection1", paramsB);
 
     MergeStream mstream = new MergeStream(streamA, streamB, new FieldComparator("a_i",ComparatorOrder.ASCENDING));
-    CountStream cstream = new CountStream(mstream);
+    RecordCountStream cstream = new RecordCountStream(mstream);
     ParallelStream pstream = new ParallelStream(zkHost, "collection1", cstream, 2, new FieldComparator("a_i",ComparatorOrder.ASCENDING));
     List<Tuple> tuples = getTuples(pstream);
 

