GitDiffStart: 9b3b890f45b81755b2c84a9cc4ec5060deb35e70 | Thu Jan 21 11:54:50 2010 +0000
diff --git a/contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram.java b/contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram.java
index c125d7e..0318033 100644
--- a/contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram.java
+++ b/contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram.java
@@ -35,6 +35,7 @@ package org.tartarus.snowball;
 import java.lang.reflect.InvocationTargetException;
 
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * This is the rev 502 of the Snowball SVN trunk,
@@ -432,7 +433,7 @@ public abstract class SnowballProgram {
 	final int newLength = limit + adjustment;
 	//resize if necessary
 	if (newLength > current.length) {
-	  char newBuffer[] = new char[ArrayUtil.getNextSize(newLength)];
+	  char newBuffer[] = new char[ArrayUtil.oversize(newLength, RamUsageEstimator.NUM_BYTES_CHAR)];
 	  System.arraycopy(current, 0, newBuffer, 0, limit);
 	  current = newBuffer;
 	}
diff --git a/contrib/snowball/.cvsignore b/contrib/snowball/.cvsignore
new file mode 100644
index 0000000..4184133
--- /dev/null
+++ b/contrib/snowball/.cvsignore
@@ -0,0 +1,2 @@
+build
+snowball
diff --git a/contrib/snowball/LICENSE.txt b/contrib/snowball/LICENSE.txt
new file mode 100644
index 0000000..8c563ab
--- /dev/null
+++ b/contrib/snowball/LICENSE.txt
@@ -0,0 +1,16 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
diff --git a/contrib/snowball/README.txt b/contrib/snowball/README.txt
new file mode 100644
index 0000000..06bc451
--- /dev/null
+++ b/contrib/snowball/README.txt
@@ -0,0 +1,25 @@
+Lucene Snowball README file
+
+This project provides pre-compiled version of the Snowball stemmers
+based on revision 500 of the Tartarus Snowball repository,
+together with classes integrating them with the Lucene search engine.
+
+A few changes has been made to the static Snowball code and compiled stemmers:
+
+ * Class SnowballProgram is made abstract and contains new abstract method stem() to avoid reflection in Lucene filter class SnowballFilter.
+ * All use of StringBuffers has been refactored to StringBuilder for speed.
+ * Snowball BSD license header has been added to the Java classes to avoid having RAT adding new ASL headers.
+
+
+IMPORTANT NOTICE ON BACKWARDS COMPATIBILITY!
+
+An index created using the Snowball module in Lucene 2.3.2 and below
+might not be compatible with the Snowball module in Lucene 2.4 or greater.
+
+For more information about this issue see:
+https://issues.apache.org/jira/browse/LUCENE-1142
+
+
+For more information on Snowball, see:
+  http://snowball.tartarus.org/
+
diff --git a/contrib/snowball/SNOWBALL-LICENSE.txt b/contrib/snowball/SNOWBALL-LICENSE.txt
new file mode 100644
index 0000000..68c1711
--- /dev/null
+++ b/contrib/snowball/SNOWBALL-LICENSE.txt
@@ -0,0 +1,26 @@
+Copyright (c) 2001, Dr Martin Porter
+Copyright (c) 2002, Richard Boulton
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+    * this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+    * notice, this list of conditions and the following disclaimer in the
+    * documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holders nor the names of its contributors
+    * may be used to endorse or promote products derived from this software
+    * without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/contrib/snowball/bin/.cvsignore b/contrib/snowball/bin/.cvsignore
new file mode 100644
index 0000000..6a1f952
--- /dev/null
+++ b/contrib/snowball/bin/.cvsignore
@@ -0,0 +1 @@
+snowball
diff --git a/contrib/snowball/bin/snowball.sh b/contrib/snowball/bin/snowball.sh
new file mode 100755
index 0000000..ccce879
--- /dev/null
+++ b/contrib/snowball/bin/snowball.sh
@@ -0,0 +1,7 @@
+#!/bin/csh -f
+set infile = $1
+set outdir = $2
+
+set name = $infile:h:t:uStemmer
+
+exec $0:h/snowball $infile -o $outdir/$name -n $name -java
diff --git a/contrib/snowball/build.xml b/contrib/snowball/build.xml
new file mode 100644
index 0000000..e23fd64
--- /dev/null
+++ b/contrib/snowball/build.xml
@@ -0,0 +1,155 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="snowball" default="default">
+
+  <description>
+    Snowball Analyzers
+  </description>
+
+  <import file="../contrib-build.xml"/>
+
+  <property name="snowball.cvsroot" value=":pserver:cvsuser@cvs.tartarus.org:/home/cvs"/>
+  <property name="snowball.cvs.password" value="anonymous"/>
+  <property name="snowball.root" value="snowball/website"/>
+  <property name="bin.dir" location="bin"/>
+
+  <property name="analyzers.jar" location="${common.dir}/build/contrib/analyzers/common/lucene-analyzers-${version}.jar"/>
+  <available property="analyzers.jar.present" type="file" file="${analyzers.jar}"/>
+  
+  <path id="classpath">
+	<pathelement path="${lucene.jar}"/>
+	<pathelement path="${analyzers.jar}"/>
+	<pathelement path="${project.classpath}"/>
+  </path>
+
+  <target name="jar" depends="compile" description="Create JAR">
+    <jarify>
+      <metainf-includes>
+        <metainf dir=".">
+          <include name="SNOWBALL-LICENSE.txt"/>
+        </metainf>
+      </metainf-includes>
+    </jarify>
+  </target>
+
+  <target name="jar-src" depends="init"
+    description="Packages the sources as JAR file">
+  	<jarify basedir="${src.dir}" destfile="${build.dir}/${final.name}-src.jar">
+  	  <metainf-includes>
+        <metainf dir=".">
+          <include name="SNOWBALL-LICENSE.txt"/>
+        </metainf>
+      </metainf-includes>
+  	</jarify>
+  </target>
+
+	
+  <!-- ====================================================== -->
+  <!-- Download Snowball code                                 -->
+  <!-- ====================================================== -->
+  <target name="download" depends="init">
+    <cvs cvsRoot="${snowball.cvsroot}"
+      package="${snowball.root}"
+      passfile="snowball.cvspass"/>
+  </target>
+
+  <target name="create-passfile">
+    <cvspass cvsroot="${snowball.cvsroot}"
+      password="${snowball.cvs.password}"
+      passfile="snowball.cvspass"
+      />
+  </target>
+
+  <!-- ====================================================== -->
+  <!-- Compile Snowball C code                                -->
+  <!-- ====================================================== -->
+  <target name="compile-compiler" depends="download">
+    <apply failonerror="true" executable="gcc" parallel="true">
+      <arg value="-O"/>
+      <arg value="-o"/>
+      <arg value="${bin.dir}/snowball"/>
+      <fileset dir="${snowball.root}/p" includes="*.c"/>
+    </apply>
+  </target>
+
+  <!-- ====================================================== -->
+  <!-- Generate Java code                                     -->
+  <!-- ====================================================== -->
+  <target name="generate" depends="compile-compiler">
+    <apply failonerror="true" executable="${bin.dir}/snowball.sh">
+      <srcfile/>
+      <arg value="${src.dir}/net/sf/snowball/ext"/>
+      <fileset dir="${snowball.root}" includes="**/stem.sbl"/>
+    </apply>
+
+    <copy todir="${src.dir}/net">
+      <fileset dir="${snowball.root}/net">
+        <include name="**/*.java"/>
+      </fileset>
+    </copy>
+
+  </target>
+
+
+  <target name="docs">
+    <taskdef
+      name="anakia"
+      classname="org.apache.velocity.anakia.AnakiaTask"
+      >
+      <classpath refid="anakia.classpath"/>
+    </taskdef>
+
+    <anakia
+      basedir="${docs.src}"
+      destdir="${docs.dest}/"
+      extension=".html" style="./site.vsl"
+      projectFile="stylesheets/project.xml"
+      excludes="**/stylesheets/** empty.xml"
+      includes="**/*.xml"
+      lastModifiedCheck="true"
+      templatePath="${jakarta.site2.home}/xdocs/stylesheets"
+      >
+    </anakia>
+
+  </target>
+
+  <target name="compile-core" depends="build-analyzers, common.compile-core" />
+  <target name="compile-test" depends="download-vocab-tests, common.compile-test" />
+  
+  <target name="build-analyzers" unless="analyzers.jar.present">
+    <echo>Snowball building dependency ${analyzers.jar}</echo>
+    <ant antfile="../analyzers/build.xml" target="default" inheritall="false" dir="../analyzers" />
+  </target>
+
+  <property name="snowball.vocab.rev" value="500"/>
+  <property name="snowball.vocab.url" 
+  	value="svn://svn.tartarus.org/snowball/trunk/data"/>
+  <property name="vocab.dir" value="src/test/org/apache/lucene/analysis/snowball"/>
+	
+  <target name="download-vocab-tests" depends="compile-core"
+    description="Downloads Snowball vocabulary tests">
+    <sequential>
+      <mkdir dir="${vocab.dir}"/>
+      <exec dir="${vocab.dir}" executable="${svn.exe}" failifexecutionfails="false" failonerror="true">
+        <arg line="checkout --trust-server-cert --non-interactive -r ${snowball.vocab.rev} ${snowball.vocab.url}"/>
+      </exec>
+    </sequential>
+  </target>
+</project>
diff --git a/contrib/snowball/docs/index.html b/contrib/snowball/docs/index.html
new file mode 100644
index 0000000..ba66000
--- /dev/null
+++ b/contrib/snowball/docs/index.html
@@ -0,0 +1,148 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+
+<!-- Content Stylesheet for Site -->
+
+        
+<!-- start the processing -->
+    <!-- ====================================================================== -->
+    <!-- GENERATED FILE, DO NOT EDIT, EDIT THE XML FILE IN xdocs INSTEAD! -->
+    <!-- Main Page Section -->
+    <!-- ====================================================================== -->
+    <html>
+        <head>
+            <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
+
+                                                    <meta name="author" value="Doug Cutting">
+            <meta name="email" value="cutting@apache.org">
+            
+           
+                                    
+                        
+            <title>Snowball Stemmers for Lucene - Overview - Snowball Stemmers for Lucene</title>
+        </head>
+
+        <body bgcolor="#ffffff" text="#000000" link="#525D76">        
+            <table border="0" width="100%" cellspacing="0">
+                <!-- TOP IMAGE -->
+                <tr>
+                    <td colspan="2">
+<a href="http://jakarta.apache.org"><img src="http://jakarta.apache.org/images/jakarta-logo.gif" align="left" border="0"/></a>
+</td>
+                </tr>
+            </table>
+            <table border="0" width="100%" cellspacing="4">
+                <tr><td colspan="2">
+                    <hr noshade="" size="1"/>
+                </td></tr>
+                
+                <tr>
+                    <!-- LEFT SIDE NAVIGATION -->
+                    <td width="20%" valign="top" nowrap="true">
+                    
+    <!-- ============================================================ -->
+
+                <p><strong>Documentation</strong></p>
+        <ul>
+                    <li>    <a href="./api/index.html">Javadoc</a>
+</li>
+                </ul>
+            <p><strong>Download</strong></p>
+        <ul>
+                    <li>    <a href="http://jakarta.apache.org/builds/jakarta-lucene-sandbox/snowball/">Releases</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/site/cvsindex.html">CVS Repository</a>
+</li>
+                </ul>
+            <p><strong>Links</strong></p>
+        <ul>
+                    <li>    <a href="http://snowball.tartarus.org/">Snowball Home</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/lucene/">Lucene Home</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/lucene/docs/lucene-sandbox/">Lucene Sandbox</a>
+</li>
+                </ul>
+            <p><strong>Jakarta</strong></p>
+        <ul>
+                    <li>    <a href="http://jakarta.apache.org/site/getinvolved.html">Get Involved</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/site/acknowledgements.html">Acknowledgements</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/site/contact.html">Contact</a>
+</li>
+                    <li>    <a href="http://jakarta.apache.org/site/legal.html">Legal</a>
+</li>
+                </ul>
+                        </td>
+                    <td width="80%" align="left" valign="top">
+                                                                    <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Snowball Stemmers for Lucene"><strong>Snowball Stemmers for Lucene</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>
+This project provides pre-compiled version of the Snowball stemmers
+together with classes integrating them with the Lucene search engine.
+</p>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                                <table border="0" cellspacing="0" cellpadding="2" width="100%">
+      <tr><td bgcolor="#525D76">
+        <font color="#ffffff" face="arial,helvetica,sanserif">
+          <a name="Download"><strong>Download</strong></a>
+        </font>
+      </td></tr>
+      <tr><td>
+        <blockquote>
+                                    <p>
+Releases of the stemmers are available
+<a href="http://jakarta.apache.org/builds/jakarta-lucene-sandbox/snowball/">
+here</a>
+</p>
+                            </blockquote>
+        </p>
+      </td></tr>
+      <tr><td><br/></td></tr>
+    </table>
+                                        </td>
+                </tr>
+
+                <!-- FOOTER -->
+                <tr><td colspan="2">
+                    <hr noshade="" size="1"/>
+                </td></tr>
+                <tr><td colspan="2">
+                    <div align="center"><font color="#525D76" size="-1"><em>
+                    Copyright &#169; 1999-2004, The Apache Software Foundation
+                    </em></font></div>
+                </td></tr>
+            </table>
+        </body>
+    </html>
+<!-- end the processing -->
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/contrib/snowball/pom.xml.template b/contrib/snowball/pom.xml.template
new file mode 100644
index 0000000..4667ba3
--- /dev/null
+++ b/contrib/snowball/pom.xml.template
@@ -0,0 +1,43 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <!--
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+    
+    http://www.apache.org/licenses/LICENSE-2.0
+    
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+  -->
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.lucene</groupId>
+    <artifactId>lucene-contrib</artifactId>
+    <version>@version@</version>
+  </parent>
+  <groupId>org.apache.lucene</groupId>
+  <artifactId>lucene-snowball</artifactId>
+  <name>Lucene Snowball</name>
+  <version>@version@</version>
+  <description>Snowball Analyzers</description>
+  <packaging>jar</packaging>
+  <dependencies>
+    <dependency>
+      <groupId>org.apache.lucene</groupId>
+      <artifactId>lucene-analyzers</artifactId>
+      <version>@version@</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/contrib/snowball/snowball.cvspass b/contrib/snowball/snowball.cvspass
new file mode 100644
index 0000000..af3f492
--- /dev/null
+++ b/contrib/snowball/snowball.cvspass
@@ -0,0 +1 @@
+:pserver:cvsuser@cvs.tartarus.org:/home/cvs Ay=0=a%0bZ
diff --git a/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballAnalyzer.java b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballAnalyzer.java
new file mode 100644
index 0000000..c015007
--- /dev/null
+++ b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballAnalyzer.java
@@ -0,0 +1,121 @@
+package org.apache.lucene.analysis.snowball;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.standard.*;
+import org.apache.lucene.analysis.tr.TurkishLowerCaseFilter;
+import org.apache.lucene.util.Version;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Set;
+
+/** Filters {@link StandardTokenizer} with {@link StandardFilter}, {@link
+ * LowerCaseFilter}, {@link StopFilter} and {@link SnowballFilter}.
+ *
+ * Available stemmers are listed in org.tartarus.snowball.ext.  The name of a
+ * stemmer is the part of the class name before "Stemmer", e.g., the stemmer in
+ * {@link org.tartarus.snowball.ext.EnglishStemmer} is named "English".
+ *
+ * <p><b>NOTE</b>: This class uses the same {@link Version}
+ * dependent settings as {@link StandardAnalyzer}, with the following addition:
+ * <ul>
+ *   <li> As of 3.1, uses {@link TurkishLowerCaseFilter} for Turkish language.
+ * </ul>
+ * </p>
+ */
+public final class SnowballAnalyzer extends Analyzer {
+  private String name;
+  private Set<?> stopSet;
+  private final Version matchVersion;
+
+  /** Builds the named analyzer with no stop words. */
+  public SnowballAnalyzer(Version matchVersion, String name) {
+    this.name = name;
+    this.matchVersion = matchVersion;
+  }
+
+  /** 
+   * Builds the named analyzer with the given stop words.
+   * @deprecated Use {@link #SnowballAnalyzer(Version, String, Set)} instead.  
+   */
+  @Deprecated
+  public SnowballAnalyzer(Version matchVersion, String name, String[] stopWords) {
+    this(matchVersion, name);
+    stopSet = StopFilter.makeStopSet(matchVersion, stopWords);
+  }
+  
+  /** Builds the named analyzer with the given stop words. */
+  public SnowballAnalyzer(Version matchVersion, String name, Set<?> stopWords) {
+    this(matchVersion, name);
+    stopSet = CharArraySet.unmodifiableSet(CharArraySet.copy(matchVersion,
+        stopWords));
+  }
+
+  /** Constructs a {@link StandardTokenizer} filtered by a {@link
+      StandardFilter}, a {@link LowerCaseFilter}, a {@link StopFilter},
+      and a {@link SnowballFilter} */
+  @Override
+  public TokenStream tokenStream(String fieldName, Reader reader) {
+    TokenStream result = new StandardTokenizer(matchVersion, reader);
+    result = new StandardFilter(result);
+    // Use a special lowercase filter for turkish, the stemmer expects it.
+    if (matchVersion.onOrAfter(Version.LUCENE_31) && name.equals("Turkish"))
+      result = new TurkishLowerCaseFilter(result);
+    else
+      result = new LowerCaseFilter(matchVersion, result);
+    if (stopSet != null)
+      result = new StopFilter(matchVersion,
+                              result, stopSet);
+    result = new SnowballFilter(result, name);
+    return result;
+  }
+  
+  private class SavedStreams {
+    Tokenizer source;
+    TokenStream result;
+  }
+  
+  /** Returns a (possibly reused) {@link StandardTokenizer} filtered by a 
+   * {@link StandardFilter}, a {@link LowerCaseFilter}, 
+   * a {@link StopFilter}, and a {@link SnowballFilter} */
+  @Override
+  public TokenStream reusableTokenStream(String fieldName, Reader reader)
+      throws IOException {
+    SavedStreams streams = (SavedStreams) getPreviousTokenStream();
+    if (streams == null) {
+      streams = new SavedStreams();
+      streams.source = new StandardTokenizer(matchVersion, reader);
+      streams.result = new StandardFilter(streams.source);
+      // Use a special lowercase filter for turkish, the stemmer expects it.
+      if (matchVersion.onOrAfter(Version.LUCENE_31) && name.equals("Turkish"))
+        streams.result = new TurkishLowerCaseFilter(streams.result);
+      else
+        streams.result = new LowerCaseFilter(matchVersion, streams.result);
+      if (stopSet != null)
+        streams.result = new StopFilter(matchVersion,
+                                        streams.result, stopSet);
+      streams.result = new SnowballFilter(streams.result, name);
+      setPreviousTokenStream(streams);
+    } else {
+      streams.source.reset(reader);
+    }
+    return streams.result;
+  }
+}
diff --git a/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballFilter.java b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballFilter.java
new file mode 100644
index 0000000..56d8202
--- /dev/null
+++ b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/SnowballFilter.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.analysis.snowball;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.analysis.tr.TurkishLowerCaseFilter; // javadoc @link
+import org.apache.lucene.analysis.LowerCaseFilter; // javadoc @link
+import org.tartarus.snowball.SnowballProgram;
+
+/**
+ * A filter that stems words using a Snowball-generated stemmer.
+ *
+ * Available stemmers are listed in {@link org.tartarus.snowball.ext}.
+ * <p><b>NOTE</b>: SnowballFilter expects lowercased text.
+ * <ul>
+ *  <li>For the Turkish language, see {@link TurkishLowerCaseFilter}.
+ *  <li>For other languages, see {@link LowerCaseFilter}.
+ * </ul>
+ * </p>
+ */
+public final class SnowballFilter extends TokenFilter {
+
+  private SnowballProgram stemmer;
+
+  private TermAttribute termAtt;
+  
+  public SnowballFilter(TokenStream input, SnowballProgram stemmer) {
+    super(input);
+    this.stemmer = stemmer;
+    termAtt = addAttribute(TermAttribute.class);
+  }
+
+  /**
+   * Construct the named stemming filter.
+   *
+   * Available stemmers are listed in {@link org.tartarus.snowball.ext}.
+   * The name of a stemmer is the part of the class name before "Stemmer",
+   * e.g., the stemmer in {@link org.tartarus.snowball.ext.EnglishStemmer} is named "English".
+   *
+   * @param in the input tokens to stem
+   * @param name the name of a stemmer
+   */
+  public SnowballFilter(TokenStream in, String name) {
+    super(in);
+    try {      
+      Class<?> stemClass = Class.forName("org.tartarus.snowball.ext." + name + "Stemmer");
+      stemmer = (SnowballProgram) stemClass.newInstance();
+    } catch (Exception e) {
+      throw new RuntimeException(e.toString());
+    }
+    termAtt = addAttribute(TermAttribute.class);
+  }
+
+  /** Returns the next input Token, after being stemmed */
+  @Override
+  public final boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char termBuffer[] = termAtt.termBuffer();
+      final int length = termAtt.termLength();
+      stemmer.setCurrent(termBuffer, length);
+      stemmer.stem();
+      final char finalTerm[] = stemmer.getCurrentBuffer();
+      final int newLength = stemmer.getCurrentBufferLength();
+      if (finalTerm != termBuffer)
+        termAtt.setTermBuffer(finalTerm, 0, newLength);
+      else
+        termAtt.setTermLength(newLength); 
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
diff --git a/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/package.html b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/package.html
new file mode 100644
index 0000000..907d9f4
--- /dev/null
+++ b/contrib/snowball/src/java/org/apache/lucene/analysis/snowball/package.html
@@ -0,0 +1,24 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<body>
+{@link org.apache.lucene.analysis.TokenFilter} and {@link
+org.apache.lucene.analysis.Analyzer} implementations that use Snowball
+stemmers.
+</body>
+</html>
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/Among.java b/contrib/snowball/src/java/org/tartarus/snowball/Among.java
new file mode 100644
index 0000000..f8291eb
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/Among.java
@@ -0,0 +1,63 @@
+/*
+
+Copyright (c) 2001, Dr Martin Porter
+Copyright (c) 2002, Richard Boulton
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+    * this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+    * notice, this list of conditions and the following disclaimer in the
+    * documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holders nor the names of its contributors
+    * may be used to endorse or promote products derived from this software
+    * without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+package org.tartarus.snowball;
+
+import java.lang.reflect.Method;
+
+public class Among {
+    public Among (String s, int substring_i, int result,
+		  String methodname, SnowballProgram methodobject) {
+        this.s_size = s.length();
+        this.s = s.toCharArray();
+        this.substring_i = substring_i;
+	this.result = result;
+	this.methodobject = methodobject;
+	if (methodname.length() == 0) {
+	    this.method = null;
+	} else {
+	    try {
+		this.method = methodobject.getClass().
+		getDeclaredMethod(methodname, new Class[0]);
+	    } catch (NoSuchMethodException e) {
+		throw new RuntimeException(e);
+	    }
+	}
+    }
+
+    public final int s_size; /* search string */
+    public final char[] s; /* search string */
+    public final int substring_i; /* index to longest matching substring */
+    public final int result;      /* result of the lookup */
+    public final Method method; /* method to use if substring matches */
+    public final SnowballProgram methodobject; /* object to invoke method on */
+   
+};
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram.java b/contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram.java
new file mode 100644
index 0000000..0318033
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/SnowballProgram.java
@@ -0,0 +1,566 @@
+/*
+
+Copyright (c) 2001, Dr Martin Porter
+Copyright (c) 2002, Richard Boulton
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+    * this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+    * notice, this list of conditions and the following disclaimer in the
+    * documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holders nor the names of its contributors
+    * may be used to endorse or promote products derived from this software
+    * without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+
+package org.tartarus.snowball;
+
+import java.lang.reflect.InvocationTargetException;
+
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
+
+/**
+ * This is the rev 502 of the Snowball SVN trunk,
+ * but modified:
+ * made abstract and introduced abstract method stem to avoid expensive reflection in filter class.
+ * refactored StringBuffers to StringBuilder
+ * uses char[] as buffer instead of StringBuffer/StringBuilder
+ * eq_s,eq_s_b,insert,replace_s take CharSequence like eq_v and eq_v_b
+ */
+public abstract class SnowballProgram {
+    protected SnowballProgram()
+    {
+	current = new char[8];
+	setCurrent("");
+    }
+
+    public abstract boolean stem();
+
+    /**
+     * Set the current string.
+     */
+    public void setCurrent(String value)
+    {
+	current = value.toCharArray();
+	cursor = 0;
+	limit = value.length();
+	limit_backward = 0;
+	bra = cursor;
+	ket = limit;
+    }
+
+    /**
+     * Get the current string.
+     */
+    public String getCurrent()
+    {
+      return new String(current, 0, limit);
+    }
+    
+    /**
+     * Set the current string.
+     * @param text character array containing input
+     * @param length valid length of text.
+     */
+    public void setCurrent(char text[], int length) {
+      current = text;
+      cursor = 0;
+      limit = length;
+      limit_backward = 0;
+      bra = cursor;
+      ket = limit;
+    }
+
+    /**
+     * Get the current buffer containing the stem.
+     * <p>
+     * NOTE: this may be a reference to a different character array than the
+     * one originally provided with setCurrent, in the exceptional case that 
+     * stemming produced a longer intermediate or result string. 
+     * </p>
+     * <p>
+     * It is necessary to use {@link #getCurrentBufferLength()} to determine
+     * the valid length of the returned buffer. For example, many words are
+     * stemmed simply by subtracting from the length to remove suffixes.
+     * </p>
+     * @see #getCurrentBufferLength()
+     */
+    public char[] getCurrentBuffer() {
+      return current;
+    }
+    
+    /**
+     * Get the valid length of the character array in 
+     * {@link #getCurrentBuffer()}. 
+     * @return valid length of the array.
+     */
+    public int getCurrentBufferLength() {
+      return limit;
+    }
+
+    // current string
+    private char current[];
+
+    protected int cursor;
+    protected int limit;
+    protected int limit_backward;
+    protected int bra;
+    protected int ket;
+
+    protected void copy_from(SnowballProgram other)
+    {
+	current          = other.current;
+	cursor           = other.cursor;
+	limit            = other.limit;
+	limit_backward   = other.limit_backward;
+	bra              = other.bra;
+	ket              = other.ket;
+    }
+
+    protected boolean in_grouping(char [] s, int min, int max)
+    {
+	if (cursor >= limit) return false;
+	char ch = current[cursor];
+	if (ch > max || ch < min) return false;
+	ch -= min;
+	if ((s[ch >> 3] & (0X1 << (ch & 0X7))) == 0) return false;
+	cursor++;
+	return true;
+    }
+
+    protected boolean in_grouping_b(char [] s, int min, int max)
+    {
+	if (cursor <= limit_backward) return false;
+	char ch = current[cursor - 1];
+	if (ch > max || ch < min) return false;
+	ch -= min;
+	if ((s[ch >> 3] & (0X1 << (ch & 0X7))) == 0) return false;
+	cursor--;
+	return true;
+    }
+
+    protected boolean out_grouping(char [] s, int min, int max)
+    {
+	if (cursor >= limit) return false;
+	char ch = current[cursor];
+	if (ch > max || ch < min) {
+	    cursor++;
+	    return true;
+	}
+	ch -= min;
+	if ((s[ch >> 3] & (0X1 << (ch & 0X7))) == 0) {
+	    cursor ++;
+	    return true;
+	}
+	return false;
+    }
+
+    protected boolean out_grouping_b(char [] s, int min, int max)
+    {
+	if (cursor <= limit_backward) return false;
+	char ch = current[cursor - 1];
+	if (ch > max || ch < min) {
+	    cursor--;
+	    return true;
+	}
+	ch -= min;
+	if ((s[ch >> 3] & (0X1 << (ch & 0X7))) == 0) {
+	    cursor--;
+	    return true;
+	}
+	return false;
+    }
+
+    protected boolean in_range(int min, int max)
+    {
+	if (cursor >= limit) return false;
+	char ch = current[cursor];
+	if (ch > max || ch < min) return false;
+	cursor++;
+	return true;
+    }
+
+    protected boolean in_range_b(int min, int max)
+    {
+	if (cursor <= limit_backward) return false;
+	char ch = current[cursor - 1];
+	if (ch > max || ch < min) return false;
+	cursor--;
+	return true;
+    }
+
+    protected boolean out_range(int min, int max)
+    {
+	if (cursor >= limit) return false;
+	char ch = current[cursor];
+	if (!(ch > max || ch < min)) return false;
+	cursor++;
+	return true;
+    }
+
+    protected boolean out_range_b(int min, int max)
+    {
+	if (cursor <= limit_backward) return false;
+	char ch = current[cursor - 1];
+	if(!(ch > max || ch < min)) return false;
+	cursor--;
+	return true;
+    }
+
+    protected boolean eq_s(int s_size, CharSequence s)
+    {
+	if (limit - cursor < s_size) return false;
+	int i;
+	for (i = 0; i != s_size; i++) {
+	    if (current[cursor + i] != s.charAt(i)) return false;
+	}
+	cursor += s_size;
+	return true;
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected boolean eq_s(int s_size, String s)
+    {
+	return eq_s(s_size, (CharSequence)s);
+    }
+
+    protected boolean eq_s_b(int s_size, CharSequence s)
+    {
+	if (cursor - limit_backward < s_size) return false;
+	int i;
+	for (i = 0; i != s_size; i++) {
+	    if (current[cursor - s_size + i] != s.charAt(i)) return false;
+	}
+	cursor -= s_size;
+	return true;
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected boolean eq_s_b(int s_size, String s)
+    {
+	return eq_s_b(s_size, (CharSequence)s);
+    }
+
+    protected boolean eq_v(CharSequence s)
+    {
+	return eq_s(s.length(), s);
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected boolean eq_v(StringBuilder s)
+    {
+	return eq_s(s.length(), (CharSequence)s);
+    }
+
+    protected boolean eq_v_b(CharSequence s)
+    {   return eq_s_b(s.length(), s);
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected boolean eq_v_b(StringBuilder s)
+    {   return eq_s_b(s.length(), (CharSequence)s);
+    }
+
+    protected int find_among(Among v[], int v_size)
+    {
+	int i = 0;
+	int j = v_size;
+
+	int c = cursor;
+	int l = limit;
+
+	int common_i = 0;
+	int common_j = 0;
+
+	boolean first_key_inspected = false;
+
+	while(true) {
+	    int k = i + ((j - i) >> 1);
+	    int diff = 0;
+	    int common = common_i < common_j ? common_i : common_j; // smaller
+	    Among w = v[k];
+	    int i2;
+	    for (i2 = common; i2 < w.s_size; i2++) {
+		if (c + common == l) {
+		    diff = -1;
+		    break;
+		}
+		diff = current[c + common] - w.s[i2];
+		if (diff != 0) break;
+		common++;
+	    }
+	    if (diff < 0) {
+		j = k;
+		common_j = common;
+	    } else {
+		i = k;
+		common_i = common;
+	    }
+	    if (j - i <= 1) {
+		if (i > 0) break; // v->s has been inspected
+		if (j == i) break; // only one item in v
+
+		// - but now we need to go round once more to get
+		// v->s inspected. This looks messy, but is actually
+		// the optimal approach.
+
+		if (first_key_inspected) break;
+		first_key_inspected = true;
+	    }
+	}
+	while(true) {
+	    Among w = v[i];
+	    if (common_i >= w.s_size) {
+		cursor = c + w.s_size;
+		if (w.method == null) return w.result;
+		boolean res;
+		try {
+		    Object resobj = w.method.invoke(w.methodobject,
+						    new Object[0]);
+		    res = resobj.toString().equals("true");
+		} catch (InvocationTargetException e) {
+		    res = false;
+		    // FIXME - debug message
+		} catch (IllegalAccessException e) {
+		    res = false;
+		    // FIXME - debug message
+		}
+		cursor = c + w.s_size;
+		if (res) return w.result;
+	    }
+	    i = w.substring_i;
+	    if (i < 0) return 0;
+	}
+    }
+
+    // find_among_b is for backwards processing. Same comments apply
+    protected int find_among_b(Among v[], int v_size)
+    {
+	int i = 0;
+	int j = v_size;
+
+	int c = cursor;
+	int lb = limit_backward;
+
+	int common_i = 0;
+	int common_j = 0;
+
+	boolean first_key_inspected = false;
+
+	while(true) {
+	    int k = i + ((j - i) >> 1);
+	    int diff = 0;
+	    int common = common_i < common_j ? common_i : common_j;
+	    Among w = v[k];
+	    int i2;
+	    for (i2 = w.s_size - 1 - common; i2 >= 0; i2--) {
+		if (c - common == lb) {
+		    diff = -1;
+		    break;
+		}
+		diff = current[c - 1 - common] - w.s[i2];
+		if (diff != 0) break;
+		common++;
+	    }
+	    if (diff < 0) {
+		j = k;
+		common_j = common;
+	    } else {
+		i = k;
+		common_i = common;
+	    }
+	    if (j - i <= 1) {
+		if (i > 0) break;
+		if (j == i) break;
+		if (first_key_inspected) break;
+		first_key_inspected = true;
+	    }
+	}
+	while(true) {
+	    Among w = v[i];
+	    if (common_i >= w.s_size) {
+		cursor = c - w.s_size;
+		if (w.method == null) return w.result;
+
+		boolean res;
+		try {
+		    Object resobj = w.method.invoke(w.methodobject,
+						    new Object[0]);
+		    res = resobj.toString().equals("true");
+		} catch (InvocationTargetException e) {
+		    res = false;
+		    // FIXME - debug message
+		} catch (IllegalAccessException e) {
+		    res = false;
+		    // FIXME - debug message
+		}
+		cursor = c - w.s_size;
+		if (res) return w.result;
+	    }
+	    i = w.substring_i;
+	    if (i < 0) return 0;
+	}
+    }
+
+    /* to replace chars between c_bra and c_ket in current by the
+     * chars in s.
+     */
+    protected int replace_s(int c_bra, int c_ket, CharSequence s)
+    {
+	final int adjustment = s.length() - (c_ket - c_bra);
+	final int newLength = limit + adjustment;
+	//resize if necessary
+	if (newLength > current.length) {
+	  char newBuffer[] = new char[ArrayUtil.oversize(newLength, RamUsageEstimator.NUM_BYTES_CHAR)];
+	  System.arraycopy(current, 0, newBuffer, 0, limit);
+	  current = newBuffer;
+	}
+	// if the substring being replaced is longer or shorter than the
+	// replacement, need to shift things around
+	if (adjustment != 0 && c_ket < limit) {
+	  System.arraycopy(current, c_ket, current, c_bra + s.length(), 
+	      limit - c_ket);
+	}
+	// insert the replacement text
+	// Note, faster is s.getChars(0, s.length(), current, c_bra);
+	// but would have to duplicate this method for both String and StringBuilder
+	for (int i = 0; i < s.length(); i++)
+	  current[c_bra + i] = s.charAt(i);
+	
+	limit += adjustment;
+	if (cursor >= c_ket) cursor += adjustment;
+	else if (cursor > c_bra) cursor = c_bra;
+	return adjustment;
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected int replace_s(int c_bra, int c_ket, String s) {
+	return replace_s(c_bra, c_ket, (CharSequence)s);
+    }
+
+    protected void slice_check()
+    {
+	if (bra < 0 ||
+	    bra > ket ||
+	    ket > limit)
+	{
+	    System.err.println("faulty slice operation");
+	// FIXME: report error somehow.
+	/*
+	    fprintf(stderr, "faulty slice operation:\n");
+	    debug(z, -1, 0);
+	    exit(1);
+	    */
+	}
+    }
+
+    protected void slice_from(CharSequence s)
+    {
+	slice_check();
+	replace_s(bra, ket, s);
+    }
+ 
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected void slice_from(String s)
+    {
+	slice_from((CharSequence)s);
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected void slice_from(StringBuilder s)
+    {
+	slice_from((CharSequence)s);
+    }
+
+    protected void slice_del()
+    {
+	slice_from((CharSequence)"");
+    }
+
+    protected void insert(int c_bra, int c_ket, CharSequence s)
+    {
+	int adjustment = replace_s(c_bra, c_ket, s);
+	if (c_bra <= bra) bra += adjustment;
+	if (c_bra <= ket) ket += adjustment;
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected void insert(int c_bra, int c_ket, String s)
+    {
+	insert(c_bra, c_ket, (CharSequence)s);
+    }
+
+    /** @deprecated for binary back compat. Will be removed in Lucene 4.0 */
+    @Deprecated
+    protected void insert(int c_bra, int c_ket, StringBuilder s)
+    {
+	insert(c_bra, c_ket, (CharSequence)s);
+    }
+
+    /* Copy the slice into the supplied StringBuffer */
+    protected StringBuilder slice_to(StringBuilder s)
+    {
+	slice_check();
+	int len = ket - bra;
+	s.setLength(0);
+	s.append(current, bra, len);
+	return s;
+    }
+
+    protected StringBuilder assign_to(StringBuilder s)
+    {
+	s.setLength(0);
+	s.append(current, 0, limit);
+	return s;
+    }
+
+/*
+extern void debug(struct SN_env * z, int number, int line_count)
+{   int i;
+    int limit = SIZE(z->p);
+    //if (number >= 0) printf("%3d (line %4d): '", number, line_count);
+    if (number >= 0) printf("%3d (line %4d): [%d]'", number, line_count,limit);
+    for (i = 0; i <= limit; i++)
+    {   if (z->lb == i) printf("{");
+        if (z->bra == i) printf("[");
+        if (z->c == i) printf("|");
+        if (z->ket == i) printf("]");
+        if (z->l == i) printf("}");
+        if (i < limit)
+        {   int ch = z->p[i];
+            if (ch == 0) ch = '#';
+            printf("%c", ch);
+        }
+    }
+    printf("'\n");
+}
+*/
+
+};
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/TestApp.java b/contrib/snowball/src/java/org/tartarus/snowball/TestApp.java
new file mode 100644
index 0000000..2a253e2
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/TestApp.java
@@ -0,0 +1,108 @@
+/*
+
+Copyright (c) 2001, Dr Martin Porter
+Copyright (c) 2002, Richard Boulton
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+    * this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+    * notice, this list of conditions and the following disclaimer in the
+    * documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holders nor the names of its contributors
+    * may be used to endorse or promote products derived from this software
+    * without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+package org.tartarus.snowball;
+
+import java.lang.reflect.Method;
+import java.io.Reader;
+import java.io.Writer;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.FileInputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.OutputStream;
+import java.io.FileOutputStream;
+
+public class TestApp {
+    private static void usage()
+    {
+        System.err.println("Usage: TestApp <algorithm> <input file> [-o <output file>]");
+    }
+
+    public static void main(String [] args) throws Throwable {
+	if (args.length < 2) {
+            usage();
+            return;
+        }
+
+	Class stemClass = Class.forName("org.tartarus.snowball.ext." +
+					args[0] + "Stemmer");
+        SnowballProgram stemmer = (SnowballProgram) stemClass.newInstance();
+	Method stemMethod = stemClass.getMethod("stem", new Class[0]);
+
+	Reader reader;
+	reader = new InputStreamReader(new FileInputStream(args[1]));
+	reader = new BufferedReader(reader);
+
+	StringBuffer input = new StringBuffer();
+
+        OutputStream outstream;
+
+	if (args.length > 2) {
+            if (args.length == 4 && args[2].equals("-o")) {
+                outstream = new FileOutputStream(args[3]);
+            } else {
+                usage();
+                return;
+            }
+	} else {
+	    outstream = System.out;
+	}
+	Writer output = new OutputStreamWriter(outstream);
+	output = new BufferedWriter(output);
+
+	int repeat = 1;
+	if (args.length > 4) {
+	    repeat = Integer.parseInt(args[4]);
+	}
+
+	Object [] emptyArgs = new Object[0];
+	int character;
+	while ((character = reader.read()) != -1) {
+	    char ch = (char) character;
+	    if (Character.isWhitespace((char) ch)) {
+		if (input.length() > 0) {
+		    stemmer.setCurrent(input.toString());
+		    for (int i = repeat; i != 0; i--) {
+			stemMethod.invoke(stemmer, emptyArgs);
+		    }
+		    output.write(stemmer.getCurrent());
+		    output.write('\n');
+		    input.delete(0, input.length());
+		}
+	    } else {
+		input.append(Character.toLowerCase(ch));
+	    }
+	}
+	output.flush();
+    }
+}
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/DanishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/DanishStemmer.java
new file mode 100644
index 0000000..216c124
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/DanishStemmer.java
@@ -0,0 +1,423 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class DanishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "hed", -1, 1, "", this),
+            new Among ( "ethed", 0, 1, "", this),
+            new Among ( "ered", -1, 1, "", this),
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "erede", 3, 1, "", this),
+            new Among ( "ende", 3, 1, "", this),
+            new Among ( "erende", 5, 1, "", this),
+            new Among ( "ene", 3, 1, "", this),
+            new Among ( "erne", 3, 1, "", this),
+            new Among ( "ere", 3, 1, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "heden", 10, 1, "", this),
+            new Among ( "eren", 10, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "heder", 13, 1, "", this),
+            new Among ( "erer", 13, 1, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "heds", 16, 1, "", this),
+            new Among ( "es", 16, 1, "", this),
+            new Among ( "endes", 18, 1, "", this),
+            new Among ( "erendes", 19, 1, "", this),
+            new Among ( "enes", 18, 1, "", this),
+            new Among ( "ernes", 18, 1, "", this),
+            new Among ( "eres", 18, 1, "", this),
+            new Among ( "ens", 16, 1, "", this),
+            new Among ( "hedens", 24, 1, "", this),
+            new Among ( "erens", 24, 1, "", this),
+            new Among ( "ers", 16, 1, "", this),
+            new Among ( "ets", 16, 1, "", this),
+            new Among ( "erets", 28, 1, "", this),
+            new Among ( "et", -1, 1, "", this),
+            new Among ( "eret", 30, 1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "gd", -1, -1, "", this),
+            new Among ( "dt", -1, -1, "", this),
+            new Among ( "gt", -1, -1, "", this),
+            new Among ( "kt", -1, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "lig", 0, 1, "", this),
+            new Among ( "elig", 1, 1, "", this),
+            new Among ( "els", -1, 1, "", this),
+            new Among ( "l\u00F8st", -1, 2, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+        private static final char g_s_ending[] = {239, 254, 42, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16 };
+
+        private int I_x;
+        private int I_p1;
+        private StringBuilder S_ch = new StringBuilder();
+
+        private void copy_from(DanishStemmer other) {
+            I_x = other.I_x;
+            I_p1 = other.I_p1;
+            S_ch = other.S_ch;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            // (, line 29
+            I_p1 = limit;
+            // test, line 33
+            v_1 = cursor;
+            // (, line 33
+            // hop, line 33
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // setmark x, line 33
+            I_x = cursor;
+            cursor = v_1;
+            // goto, line 34
+            golab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 248)))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_2;
+                    break golab0;
+                } while (false);
+                cursor = v_2;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 34
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 248)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 34
+            I_p1 = cursor;
+            // try, line 35
+            lab4: do {
+                // (, line 35
+                if (!(I_p1 < I_x))
+                {
+                    break lab4;
+                }
+                I_p1 = I_x;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_main_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 40
+            // setlimit, line 41
+            v_1 = limit - cursor;
+            // tomark, line 41
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 41
+            // [, line 41
+            ket = cursor;
+            // substring, line 41
+            among_var = find_among_b(a_0, 32);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 41
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 48
+                    // delete, line 48
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 50
+                    if (!(in_grouping_b(g_s_ending, 97, 229)))
+                    {
+                        return false;
+                    }
+                    // delete, line 50
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_consonant_pair() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 54
+            // test, line 55
+            v_1 = limit - cursor;
+            // (, line 55
+            // setlimit, line 56
+            v_2 = limit - cursor;
+            // tomark, line 56
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_3 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_2;
+            // (, line 56
+            // [, line 56
+            ket = cursor;
+            // substring, line 56
+            if (find_among_b(a_1, 4) == 0)
+            {
+                limit_backward = v_3;
+                return false;
+            }
+            // ], line 56
+            bra = cursor;
+            limit_backward = v_3;
+            cursor = limit - v_1;
+            // next, line 62
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 62
+            bra = cursor;
+            // delete, line 62
+            slice_del();
+            return true;
+        }
+
+        private boolean r_other_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 65
+            // do, line 66
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 66
+                // [, line 66
+                ket = cursor;
+                // literal, line 66
+                if (!(eq_s_b(2, "st")))
+                {
+                    break lab0;
+                }
+                // ], line 66
+                bra = cursor;
+                // literal, line 66
+                if (!(eq_s_b(2, "ig")))
+                {
+                    break lab0;
+                }
+                // delete, line 66
+                slice_del();
+            } while (false);
+            cursor = limit - v_1;
+            // setlimit, line 67
+            v_2 = limit - cursor;
+            // tomark, line 67
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_3 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_2;
+            // (, line 67
+            // [, line 67
+            ket = cursor;
+            // substring, line 67
+            among_var = find_among_b(a_2, 5);
+            if (among_var == 0)
+            {
+                limit_backward = v_3;
+                return false;
+            }
+            // ], line 67
+            bra = cursor;
+            limit_backward = v_3;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 70
+                    // delete, line 70
+                    slice_del();
+                    // do, line 70
+                    v_4 = limit - cursor;
+                    lab1: do {
+                        // call consonant_pair, line 70
+                        if (!r_consonant_pair())
+                        {
+                            break lab1;
+                        }
+                    } while (false);
+                    cursor = limit - v_4;
+                    break;
+                case 2:
+                    // (, line 72
+                    // <-, line 72
+                    slice_from("l\u00F8s");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_undouble() {
+            int v_1;
+            int v_2;
+            // (, line 75
+            // setlimit, line 76
+            v_1 = limit - cursor;
+            // tomark, line 76
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 76
+            // [, line 76
+            ket = cursor;
+            if (!(out_grouping_b(g_v, 97, 248)))
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 76
+            bra = cursor;
+            // -> ch, line 76
+            S_ch = slice_to(S_ch);
+            limit_backward = v_2;
+            // name ch, line 77
+            if (!(eq_v_b(S_ch)))
+            {
+                return false;
+            }
+            // delete, line 78
+            slice_del();
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 82
+            // do, line 84
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 84
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 85
+            limit_backward = cursor; cursor = limit;
+            // (, line 85
+            // do, line 86
+            v_2 = limit - cursor;
+            lab1: do {
+                // call main_suffix, line 86
+                if (!r_main_suffix())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 87
+            v_3 = limit - cursor;
+            lab2: do {
+                // call consonant_pair, line 87
+                if (!r_consonant_pair())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 88
+            v_4 = limit - cursor;
+            lab3: do {
+                // call other_suffix, line 88
+                if (!r_other_suffix())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            // do, line 89
+            v_5 = limit - cursor;
+            lab4: do {
+                // call undouble, line 89
+                if (!r_undouble())
+                {
+                    break lab4;
+                }
+            } while (false);
+            cursor = limit - v_5;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/DutchStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/DutchStemmer.java
new file mode 100644
index 0000000..a719993
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/DutchStemmer.java
@@ -0,0 +1,837 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class DutchStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 6, "", this),
+            new Among ( "\u00E1", 0, 1, "", this),
+            new Among ( "\u00E4", 0, 1, "", this),
+            new Among ( "\u00E9", 0, 2, "", this),
+            new Among ( "\u00EB", 0, 2, "", this),
+            new Among ( "\u00ED", 0, 3, "", this),
+            new Among ( "\u00EF", 0, 3, "", this),
+            new Among ( "\u00F3", 0, 4, "", this),
+            new Among ( "\u00F6", 0, 4, "", this),
+            new Among ( "\u00FA", 0, 5, "", this),
+            new Among ( "\u00FC", 0, 5, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "I", 0, 2, "", this),
+            new Among ( "Y", 0, 1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "dd", -1, -1, "", this),
+            new Among ( "kk", -1, -1, "", this),
+            new Among ( "tt", -1, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ene", -1, 2, "", this),
+            new Among ( "se", -1, 3, "", this),
+            new Among ( "en", -1, 2, "", this),
+            new Among ( "heden", 2, 1, "", this),
+            new Among ( "s", -1, 3, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "end", -1, 1, "", this),
+            new Among ( "ig", -1, 2, "", this),
+            new Among ( "ing", -1, 1, "", this),
+            new Among ( "lijk", -1, 3, "", this),
+            new Among ( "baar", -1, 4, "", this),
+            new Among ( "bar", -1, 5, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "aa", -1, -1, "", this),
+            new Among ( "ee", -1, -1, "", this),
+            new Among ( "oo", -1, -1, "", this),
+            new Among ( "uu", -1, -1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+        private static final char g_v_I[] = {1, 0, 0, 17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+        private static final char g_v_j[] = {17, 67, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+        private int I_p2;
+        private int I_p1;
+        private boolean B_e_found;
+
+        private void copy_from(DutchStemmer other) {
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            B_e_found = other.B_e_found;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            // (, line 41
+            // test, line 42
+            v_1 = cursor;
+            // repeat, line 42
+            replab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    // (, line 42
+                    // [, line 43
+                    bra = cursor;
+                    // substring, line 43
+                    among_var = find_among(a_0, 11);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 43
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 45
+                            // <-, line 45
+                            slice_from("a");
+                            break;
+                        case 2:
+                            // (, line 47
+                            // <-, line 47
+                            slice_from("e");
+                            break;
+                        case 3:
+                            // (, line 49
+                            // <-, line 49
+                            slice_from("i");
+                            break;
+                        case 4:
+                            // (, line 51
+                            // <-, line 51
+                            slice_from("o");
+                            break;
+                        case 5:
+                            // (, line 53
+                            // <-, line 53
+                            slice_from("u");
+                            break;
+                        case 6:
+                            // (, line 54
+                            // next, line 54
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_2;
+                break replab0;
+            }
+            cursor = v_1;
+            // try, line 57
+            v_3 = cursor;
+            lab2: do {
+                // (, line 57
+                // [, line 57
+                bra = cursor;
+                // literal, line 57
+                if (!(eq_s(1, "y")))
+                {
+                    cursor = v_3;
+                    break lab2;
+                }
+                // ], line 57
+                ket = cursor;
+                // <-, line 57
+                slice_from("Y");
+            } while (false);
+            // repeat, line 58
+            replab3: while(true)
+            {
+                v_4 = cursor;
+                lab4: do {
+                    // goto, line 58
+                    golab5: while(true)
+                    {
+                        v_5 = cursor;
+                        lab6: do {
+                            // (, line 58
+                            if (!(in_grouping(g_v, 97, 232)))
+                            {
+                                break lab6;
+                            }
+                            // [, line 59
+                            bra = cursor;
+                            // or, line 59
+                            lab7: do {
+                                v_6 = cursor;
+                                lab8: do {
+                                    // (, line 59
+                                    // literal, line 59
+                                    if (!(eq_s(1, "i")))
+                                    {
+                                        break lab8;
+                                    }
+                                    // ], line 59
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 232)))
+                                    {
+                                        break lab8;
+                                    }
+                                    // <-, line 59
+                                    slice_from("I");
+                                    break lab7;
+                                } while (false);
+                                cursor = v_6;
+                                // (, line 60
+                                // literal, line 60
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab6;
+                                }
+                                // ], line 60
+                                ket = cursor;
+                                // <-, line 60
+                                slice_from("Y");
+                            } while (false);
+                            cursor = v_5;
+                            break golab5;
+                        } while (false);
+                        cursor = v_5;
+                        if (cursor >= limit)
+                        {
+                            break lab4;
+                        }
+                        cursor++;
+                    }
+                    continue replab3;
+                } while (false);
+                cursor = v_4;
+                break replab3;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            // (, line 64
+            I_p1 = limit;
+            I_p2 = limit;
+            // gopast, line 69
+            golab0: while(true)
+            {
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 232)))
+                    {
+                        break lab1;
+                    }
+                    break golab0;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 69
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 232)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 69
+            I_p1 = cursor;
+            // try, line 70
+            lab4: do {
+                // (, line 70
+                if (!(I_p1 < 3))
+                {
+                    break lab4;
+                }
+                I_p1 = 3;
+            } while (false);
+            // gopast, line 71
+            golab5: while(true)
+            {
+                lab6: do {
+                    if (!(in_grouping(g_v, 97, 232)))
+                    {
+                        break lab6;
+                    }
+                    break golab5;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 71
+            golab7: while(true)
+            {
+                lab8: do {
+                    if (!(out_grouping(g_v, 97, 232)))
+                    {
+                        break lab8;
+                    }
+                    break golab7;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p2, line 71
+            I_p2 = cursor;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 75
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 75
+                    // [, line 77
+                    bra = cursor;
+                    // substring, line 77
+                    among_var = find_among(a_1, 3);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 77
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 78
+                            // <-, line 78
+                            slice_from("y");
+                            break;
+                        case 2:
+                            // (, line 79
+                            // <-, line 79
+                            slice_from("i");
+                            break;
+                        case 3:
+                            // (, line 80
+                            // next, line 80
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_undouble() {
+            int v_1;
+            // (, line 90
+            // test, line 91
+            v_1 = limit - cursor;
+            // among, line 91
+            if (find_among_b(a_2, 3) == 0)
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            // [, line 91
+            ket = cursor;
+            // next, line 91
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 91
+            bra = cursor;
+            // delete, line 91
+            slice_del();
+            return true;
+        }
+
+        private boolean r_e_ending() {
+            int v_1;
+            // (, line 94
+            // unset e_found, line 95
+            B_e_found = false;
+            // [, line 96
+            ket = cursor;
+            // literal, line 96
+            if (!(eq_s_b(1, "e")))
+            {
+                return false;
+            }
+            // ], line 96
+            bra = cursor;
+            // call R1, line 96
+            if (!r_R1())
+            {
+                return false;
+            }
+            // test, line 96
+            v_1 = limit - cursor;
+            if (!(out_grouping_b(g_v, 97, 232)))
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            // delete, line 96
+            slice_del();
+            // set e_found, line 97
+            B_e_found = true;
+            // call undouble, line 98
+            if (!r_undouble())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_en_ending() {
+            int v_1;
+            int v_2;
+            // (, line 101
+            // call R1, line 102
+            if (!r_R1())
+            {
+                return false;
+            }
+            // and, line 102
+            v_1 = limit - cursor;
+            if (!(out_grouping_b(g_v, 97, 232)))
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            // not, line 102
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 102
+                    if (!(eq_s_b(3, "gem")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // delete, line 102
+            slice_del();
+            // call undouble, line 103
+            if (!r_undouble())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            // (, line 106
+            // do, line 107
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 107
+                // [, line 108
+                ket = cursor;
+                // substring, line 108
+                among_var = find_among_b(a_3, 5);
+                if (among_var == 0)
+                {
+                    break lab0;
+                }
+                // ], line 108
+                bra = cursor;
+                switch(among_var) {
+                    case 0:
+                        break lab0;
+                    case 1:
+                        // (, line 110
+                        // call R1, line 110
+                        if (!r_R1())
+                        {
+                            break lab0;
+                        }
+                        // <-, line 110
+                        slice_from("heid");
+                        break;
+                    case 2:
+                        // (, line 113
+                        // call en_ending, line 113
+                        if (!r_en_ending())
+                        {
+                            break lab0;
+                        }
+                        break;
+                    case 3:
+                        // (, line 116
+                        // call R1, line 116
+                        if (!r_R1())
+                        {
+                            break lab0;
+                        }
+                        if (!(out_grouping_b(g_v_j, 97, 232)))
+                        {
+                            break lab0;
+                        }
+                        // delete, line 116
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // do, line 120
+            v_2 = limit - cursor;
+            lab1: do {
+                // call e_ending, line 120
+                if (!r_e_ending())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 122
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 122
+                // [, line 122
+                ket = cursor;
+                // literal, line 122
+                if (!(eq_s_b(4, "heid")))
+                {
+                    break lab2;
+                }
+                // ], line 122
+                bra = cursor;
+                // call R2, line 122
+                if (!r_R2())
+                {
+                    break lab2;
+                }
+                // not, line 122
+                {
+                    v_4 = limit - cursor;
+                    lab3: do {
+                        // literal, line 122
+                        if (!(eq_s_b(1, "c")))
+                        {
+                            break lab3;
+                        }
+                        break lab2;
+                    } while (false);
+                    cursor = limit - v_4;
+                }
+                // delete, line 122
+                slice_del();
+                // [, line 123
+                ket = cursor;
+                // literal, line 123
+                if (!(eq_s_b(2, "en")))
+                {
+                    break lab2;
+                }
+                // ], line 123
+                bra = cursor;
+                // call en_ending, line 123
+                if (!r_en_ending())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 126
+            v_5 = limit - cursor;
+            lab4: do {
+                // (, line 126
+                // [, line 127
+                ket = cursor;
+                // substring, line 127
+                among_var = find_among_b(a_4, 6);
+                if (among_var == 0)
+                {
+                    break lab4;
+                }
+                // ], line 127
+                bra = cursor;
+                switch(among_var) {
+                    case 0:
+                        break lab4;
+                    case 1:
+                        // (, line 129
+                        // call R2, line 129
+                        if (!r_R2())
+                        {
+                            break lab4;
+                        }
+                        // delete, line 129
+                        slice_del();
+                        // or, line 130
+                        lab5: do {
+                            v_6 = limit - cursor;
+                            lab6: do {
+                                // (, line 130
+                                // [, line 130
+                                ket = cursor;
+                                // literal, line 130
+                                if (!(eq_s_b(2, "ig")))
+                                {
+                                    break lab6;
+                                }
+                                // ], line 130
+                                bra = cursor;
+                                // call R2, line 130
+                                if (!r_R2())
+                                {
+                                    break lab6;
+                                }
+                                // not, line 130
+                                {
+                                    v_7 = limit - cursor;
+                                    lab7: do {
+                                        // literal, line 130
+                                        if (!(eq_s_b(1, "e")))
+                                        {
+                                            break lab7;
+                                        }
+                                        break lab6;
+                                    } while (false);
+                                    cursor = limit - v_7;
+                                }
+                                // delete, line 130
+                                slice_del();
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_6;
+                            // call undouble, line 130
+                            if (!r_undouble())
+                            {
+                                break lab4;
+                            }
+                        } while (false);
+                        break;
+                    case 2:
+                        // (, line 133
+                        // call R2, line 133
+                        if (!r_R2())
+                        {
+                            break lab4;
+                        }
+                        // not, line 133
+                        {
+                            v_8 = limit - cursor;
+                            lab8: do {
+                                // literal, line 133
+                                if (!(eq_s_b(1, "e")))
+                                {
+                                    break lab8;
+                                }
+                                break lab4;
+                            } while (false);
+                            cursor = limit - v_8;
+                        }
+                        // delete, line 133
+                        slice_del();
+                        break;
+                    case 3:
+                        // (, line 136
+                        // call R2, line 136
+                        if (!r_R2())
+                        {
+                            break lab4;
+                        }
+                        // delete, line 136
+                        slice_del();
+                        // call e_ending, line 136
+                        if (!r_e_ending())
+                        {
+                            break lab4;
+                        }
+                        break;
+                    case 4:
+                        // (, line 139
+                        // call R2, line 139
+                        if (!r_R2())
+                        {
+                            break lab4;
+                        }
+                        // delete, line 139
+                        slice_del();
+                        break;
+                    case 5:
+                        // (, line 142
+                        // call R2, line 142
+                        if (!r_R2())
+                        {
+                            break lab4;
+                        }
+                        // Boolean test e_found, line 142
+                        if (!(B_e_found))
+                        {
+                            break lab4;
+                        }
+                        // delete, line 142
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_5;
+            // do, line 146
+            v_9 = limit - cursor;
+            lab9: do {
+                // (, line 146
+                if (!(out_grouping_b(g_v_I, 73, 232)))
+                {
+                    break lab9;
+                }
+                // test, line 148
+                v_10 = limit - cursor;
+                // (, line 148
+                // among, line 149
+                if (find_among_b(a_5, 4) == 0)
+                {
+                    break lab9;
+                }
+                if (!(out_grouping_b(g_v, 97, 232)))
+                {
+                    break lab9;
+                }
+                cursor = limit - v_10;
+                // [, line 152
+                ket = cursor;
+                // next, line 152
+                if (cursor <= limit_backward)
+                {
+                    break lab9;
+                }
+                cursor--;
+                // ], line 152
+                bra = cursor;
+                // delete, line 152
+                slice_del();
+            } while (false);
+            cursor = limit - v_9;
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 157
+            // do, line 159
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 159
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 160
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 160
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 161
+            limit_backward = cursor; cursor = limit;
+            // do, line 162
+            v_3 = limit - cursor;
+            lab2: do {
+                // call standard_suffix, line 162
+                if (!r_standard_suffix())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            cursor = limit_backward;            // do, line 163
+            v_4 = cursor;
+            lab3: do {
+                // call postlude, line 163
+                if (!r_postlude())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = v_4;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/EnglishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/EnglishStemmer.java
new file mode 100644
index 0000000..9ca87a3
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/EnglishStemmer.java
@@ -0,0 +1,1314 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class EnglishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "arsen", -1, -1, "", this),
+            new Among ( "commun", -1, -1, "", this),
+            new Among ( "gener", -1, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "'", -1, 1, "", this),
+            new Among ( "'s'", 0, 1, "", this),
+            new Among ( "'s", -1, 1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ied", -1, 2, "", this),
+            new Among ( "s", -1, 3, "", this),
+            new Among ( "ies", 1, 2, "", this),
+            new Among ( "sses", 1, 1, "", this),
+            new Among ( "ss", 1, -1, "", this),
+            new Among ( "us", 1, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "bb", 0, 2, "", this),
+            new Among ( "dd", 0, 2, "", this),
+            new Among ( "ff", 0, 2, "", this),
+            new Among ( "gg", 0, 2, "", this),
+            new Among ( "bl", 0, 1, "", this),
+            new Among ( "mm", 0, 2, "", this),
+            new Among ( "nn", 0, 2, "", this),
+            new Among ( "pp", 0, 2, "", this),
+            new Among ( "rr", 0, 2, "", this),
+            new Among ( "at", 0, 1, "", this),
+            new Among ( "tt", 0, 2, "", this),
+            new Among ( "iz", 0, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ed", -1, 2, "", this),
+            new Among ( "eed", 0, 1, "", this),
+            new Among ( "ing", -1, 2, "", this),
+            new Among ( "edly", -1, 2, "", this),
+            new Among ( "eedly", 3, 1, "", this),
+            new Among ( "ingly", -1, 2, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "anci", -1, 3, "", this),
+            new Among ( "enci", -1, 2, "", this),
+            new Among ( "ogi", -1, 13, "", this),
+            new Among ( "li", -1, 16, "", this),
+            new Among ( "bli", 3, 12, "", this),
+            new Among ( "abli", 4, 4, "", this),
+            new Among ( "alli", 3, 8, "", this),
+            new Among ( "fulli", 3, 14, "", this),
+            new Among ( "lessli", 3, 15, "", this),
+            new Among ( "ousli", 3, 10, "", this),
+            new Among ( "entli", 3, 5, "", this),
+            new Among ( "aliti", -1, 8, "", this),
+            new Among ( "biliti", -1, 12, "", this),
+            new Among ( "iviti", -1, 11, "", this),
+            new Among ( "tional", -1, 1, "", this),
+            new Among ( "ational", 14, 7, "", this),
+            new Among ( "alism", -1, 8, "", this),
+            new Among ( "ation", -1, 7, "", this),
+            new Among ( "ization", 17, 6, "", this),
+            new Among ( "izer", -1, 6, "", this),
+            new Among ( "ator", -1, 7, "", this),
+            new Among ( "iveness", -1, 11, "", this),
+            new Among ( "fulness", -1, 9, "", this),
+            new Among ( "ousness", -1, 10, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "icate", -1, 4, "", this),
+            new Among ( "ative", -1, 6, "", this),
+            new Among ( "alize", -1, 3, "", this),
+            new Among ( "iciti", -1, 4, "", this),
+            new Among ( "ical", -1, 4, "", this),
+            new Among ( "tional", -1, 1, "", this),
+            new Among ( "ational", 5, 2, "", this),
+            new Among ( "ful", -1, 5, "", this),
+            new Among ( "ness", -1, 5, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "ance", -1, 1, "", this),
+            new Among ( "ence", -1, 1, "", this),
+            new Among ( "able", -1, 1, "", this),
+            new Among ( "ible", -1, 1, "", this),
+            new Among ( "ate", -1, 1, "", this),
+            new Among ( "ive", -1, 1, "", this),
+            new Among ( "ize", -1, 1, "", this),
+            new Among ( "iti", -1, 1, "", this),
+            new Among ( "al", -1, 1, "", this),
+            new Among ( "ism", -1, 1, "", this),
+            new Among ( "ion", -1, 2, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "ous", -1, 1, "", this),
+            new Among ( "ant", -1, 1, "", this),
+            new Among ( "ent", -1, 1, "", this),
+            new Among ( "ment", 15, 1, "", this),
+            new Among ( "ement", 16, 1, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "l", -1, 2, "", this)
+        };
+
+        private Among a_9[] = {
+            new Among ( "succeed", -1, -1, "", this),
+            new Among ( "proceed", -1, -1, "", this),
+            new Among ( "exceed", -1, -1, "", this),
+            new Among ( "canning", -1, -1, "", this),
+            new Among ( "inning", -1, -1, "", this),
+            new Among ( "earring", -1, -1, "", this),
+            new Among ( "herring", -1, -1, "", this),
+            new Among ( "outing", -1, -1, "", this)
+        };
+
+        private Among a_10[] = {
+            new Among ( "andes", -1, -1, "", this),
+            new Among ( "atlas", -1, -1, "", this),
+            new Among ( "bias", -1, -1, "", this),
+            new Among ( "cosmos", -1, -1, "", this),
+            new Among ( "dying", -1, 3, "", this),
+            new Among ( "early", -1, 9, "", this),
+            new Among ( "gently", -1, 7, "", this),
+            new Among ( "howe", -1, -1, "", this),
+            new Among ( "idly", -1, 6, "", this),
+            new Among ( "lying", -1, 4, "", this),
+            new Among ( "news", -1, -1, "", this),
+            new Among ( "only", -1, 10, "", this),
+            new Among ( "singly", -1, 11, "", this),
+            new Among ( "skies", -1, 2, "", this),
+            new Among ( "skis", -1, 1, "", this),
+            new Among ( "sky", -1, -1, "", this),
+            new Among ( "tying", -1, 5, "", this),
+            new Among ( "ugly", -1, 8, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1 };
+
+        private static final char g_v_WXY[] = {1, 17, 65, 208, 1 };
+
+        private static final char g_valid_LI[] = {55, 141, 2 };
+
+        private boolean B_Y_found;
+        private int I_p2;
+        private int I_p1;
+
+        private void copy_from(EnglishStemmer other) {
+            B_Y_found = other.B_Y_found;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 25
+            // unset Y_found, line 26
+            B_Y_found = false;
+            // do, line 27
+            v_1 = cursor;
+            lab0: do {
+                // (, line 27
+                // [, line 27
+                bra = cursor;
+                // literal, line 27
+                if (!(eq_s(1, "'")))
+                {
+                    break lab0;
+                }
+                // ], line 27
+                ket = cursor;
+                // delete, line 27
+                slice_del();
+            } while (false);
+            cursor = v_1;
+            // do, line 28
+            v_2 = cursor;
+            lab1: do {
+                // (, line 28
+                // [, line 28
+                bra = cursor;
+                // literal, line 28
+                if (!(eq_s(1, "y")))
+                {
+                    break lab1;
+                }
+                // ], line 28
+                ket = cursor;
+                // <-, line 28
+                slice_from("Y");
+                // set Y_found, line 28
+                B_Y_found = true;
+            } while (false);
+            cursor = v_2;
+            // do, line 29
+            v_3 = cursor;
+            lab2: do {
+                // repeat, line 29
+                replab3: while(true)
+                {
+                    v_4 = cursor;
+                    lab4: do {
+                        // (, line 29
+                        // goto, line 29
+                        golab5: while(true)
+                        {
+                            v_5 = cursor;
+                            lab6: do {
+                                // (, line 29
+                                if (!(in_grouping(g_v, 97, 121)))
+                                {
+                                    break lab6;
+                                }
+                                // [, line 29
+                                bra = cursor;
+                                // literal, line 29
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab6;
+                                }
+                                // ], line 29
+                                ket = cursor;
+                                cursor = v_5;
+                                break golab5;
+                            } while (false);
+                            cursor = v_5;
+                            if (cursor >= limit)
+                            {
+                                break lab4;
+                            }
+                            cursor++;
+                        }
+                        // <-, line 29
+                        slice_from("Y");
+                        // set Y_found, line 29
+                        B_Y_found = true;
+                        continue replab3;
+                    } while (false);
+                    cursor = v_4;
+                    break replab3;
+                }
+            } while (false);
+            cursor = v_3;
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            // (, line 32
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 35
+            v_1 = cursor;
+            lab0: do {
+                // (, line 35
+                // or, line 41
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // among, line 36
+                        if (find_among(a_0, 3) == 0)
+                        {
+                            break lab2;
+                        }
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 41
+                    // gopast, line 41
+                    golab3: while(true)
+                    {
+                        lab4: do {
+                            if (!(in_grouping(g_v, 97, 121)))
+                            {
+                                break lab4;
+                            }
+                            break golab3;
+                        } while (false);
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    }
+                    // gopast, line 41
+                    golab5: while(true)
+                    {
+                        lab6: do {
+                            if (!(out_grouping(g_v, 97, 121)))
+                            {
+                                break lab6;
+                            }
+                            break golab5;
+                        } while (false);
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    }
+                } while (false);
+                // setmark p1, line 42
+                I_p1 = cursor;
+                // gopast, line 43
+                golab7: while(true)
+                {
+                    lab8: do {
+                        if (!(in_grouping(g_v, 97, 121)))
+                        {
+                            break lab8;
+                        }
+                        break golab7;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // gopast, line 43
+                golab9: while(true)
+                {
+                    lab10: do {
+                        if (!(out_grouping(g_v, 97, 121)))
+                        {
+                            break lab10;
+                        }
+                        break golab9;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 43
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_1;
+            return true;
+        }
+
+        private boolean r_shortv() {
+            int v_1;
+            // (, line 49
+            // or, line 51
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 50
+                    if (!(out_grouping_b(g_v_WXY, 89, 121)))
+                    {
+                        break lab1;
+                    }
+                    if (!(in_grouping_b(g_v, 97, 121)))
+                    {
+                        break lab1;
+                    }
+                    if (!(out_grouping_b(g_v, 97, 121)))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 52
+                if (!(out_grouping_b(g_v, 97, 121)))
+                {
+                    return false;
+                }
+                if (!(in_grouping_b(g_v, 97, 121)))
+                {
+                    return false;
+                }
+                // atlimit, line 52
+                if (cursor > limit_backward)
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1a() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 58
+            // try, line 59
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 59
+                // [, line 60
+                ket = cursor;
+                // substring, line 60
+                among_var = find_among_b(a_1, 3);
+                if (among_var == 0)
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // ], line 60
+                bra = cursor;
+                switch(among_var) {
+                    case 0:
+                        cursor = limit - v_1;
+                        break lab0;
+                    case 1:
+                        // (, line 62
+                        // delete, line 62
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            // [, line 65
+            ket = cursor;
+            // substring, line 65
+            among_var = find_among_b(a_2, 6);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 65
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 66
+                    // <-, line 66
+                    slice_from("ss");
+                    break;
+                case 2:
+                    // (, line 68
+                    // or, line 68
+                    lab1: do {
+                        v_2 = limit - cursor;
+                        lab2: do {
+                            // (, line 68
+                            // hop, line 68
+                            {
+                                int c = cursor - 2;
+                                if (limit_backward > c || c > limit)
+                                {
+                                    break lab2;
+                                }
+                                cursor = c;
+                            }
+                            // <-, line 68
+                            slice_from("i");
+                            break lab1;
+                        } while (false);
+                        cursor = limit - v_2;
+                        // <-, line 68
+                        slice_from("ie");
+                    } while (false);
+                    break;
+                case 3:
+                    // (, line 69
+                    // next, line 69
+                    if (cursor <= limit_backward)
+                    {
+                        return false;
+                    }
+                    cursor--;
+                    // gopast, line 69
+                    golab3: while(true)
+                    {
+                        lab4: do {
+                            if (!(in_grouping_b(g_v, 97, 121)))
+                            {
+                                break lab4;
+                            }
+                            break golab3;
+                        } while (false);
+                        if (cursor <= limit_backward)
+                        {
+                            return false;
+                        }
+                        cursor--;
+                    }
+                    // delete, line 69
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1b() {
+            int among_var;
+            int v_1;
+            int v_3;
+            int v_4;
+            // (, line 74
+            // [, line 75
+            ket = cursor;
+            // substring, line 75
+            among_var = find_among_b(a_4, 6);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 75
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 77
+                    // call R1, line 77
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 77
+                    slice_from("ee");
+                    break;
+                case 2:
+                    // (, line 79
+                    // test, line 80
+                    v_1 = limit - cursor;
+                    // gopast, line 80
+                    golab0: while(true)
+                    {
+                        lab1: do {
+                            if (!(in_grouping_b(g_v, 97, 121)))
+                            {
+                                break lab1;
+                            }
+                            break golab0;
+                        } while (false);
+                        if (cursor <= limit_backward)
+                        {
+                            return false;
+                        }
+                        cursor--;
+                    }
+                    cursor = limit - v_1;
+                    // delete, line 80
+                    slice_del();
+                    // test, line 81
+                    v_3 = limit - cursor;
+                    // substring, line 81
+                    among_var = find_among_b(a_3, 13);
+                    if (among_var == 0)
+                    {
+                        return false;
+                    }
+                    cursor = limit - v_3;
+                    switch(among_var) {
+                        case 0:
+                            return false;
+                        case 1:
+                            // (, line 83
+                            // <+, line 83
+                            {
+                                int c = cursor;
+                                insert(cursor, cursor, "e");
+                                cursor = c;
+                            }
+                            break;
+                        case 2:
+                            // (, line 86
+                            // [, line 86
+                            ket = cursor;
+                            // next, line 86
+                            if (cursor <= limit_backward)
+                            {
+                                return false;
+                            }
+                            cursor--;
+                            // ], line 86
+                            bra = cursor;
+                            // delete, line 86
+                            slice_del();
+                            break;
+                        case 3:
+                            // (, line 87
+                            // atmark, line 87
+                            if (cursor != I_p1)
+                            {
+                                return false;
+                            }
+                            // test, line 87
+                            v_4 = limit - cursor;
+                            // call shortv, line 87
+                            if (!r_shortv())
+                            {
+                                return false;
+                            }
+                            cursor = limit - v_4;
+                            // <+, line 87
+                            {
+                                int c = cursor;
+                                insert(cursor, cursor, "e");
+                                cursor = c;
+                            }
+                            break;
+                    }
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1c() {
+            int v_1;
+            int v_2;
+            // (, line 93
+            // [, line 94
+            ket = cursor;
+            // or, line 94
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // literal, line 94
+                    if (!(eq_s_b(1, "y")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // literal, line 94
+                if (!(eq_s_b(1, "Y")))
+                {
+                    return false;
+                }
+            } while (false);
+            // ], line 94
+            bra = cursor;
+            if (!(out_grouping_b(g_v, 97, 121)))
+            {
+                return false;
+            }
+            // not, line 95
+            {
+                v_2 = limit - cursor;
+                lab2: do {
+                    // atlimit, line 95
+                    if (cursor > limit_backward)
+                    {
+                        break lab2;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // <-, line 96
+            slice_from("i");
+            return true;
+        }
+
+        private boolean r_Step_2() {
+            int among_var;
+            // (, line 99
+            // [, line 100
+            ket = cursor;
+            // substring, line 100
+            among_var = find_among_b(a_5, 24);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 100
+            bra = cursor;
+            // call R1, line 100
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 101
+                    // <-, line 101
+                    slice_from("tion");
+                    break;
+                case 2:
+                    // (, line 102
+                    // <-, line 102
+                    slice_from("ence");
+                    break;
+                case 3:
+                    // (, line 103
+                    // <-, line 103
+                    slice_from("ance");
+                    break;
+                case 4:
+                    // (, line 104
+                    // <-, line 104
+                    slice_from("able");
+                    break;
+                case 5:
+                    // (, line 105
+                    // <-, line 105
+                    slice_from("ent");
+                    break;
+                case 6:
+                    // (, line 107
+                    // <-, line 107
+                    slice_from("ize");
+                    break;
+                case 7:
+                    // (, line 109
+                    // <-, line 109
+                    slice_from("ate");
+                    break;
+                case 8:
+                    // (, line 111
+                    // <-, line 111
+                    slice_from("al");
+                    break;
+                case 9:
+                    // (, line 112
+                    // <-, line 112
+                    slice_from("ful");
+                    break;
+                case 10:
+                    // (, line 114
+                    // <-, line 114
+                    slice_from("ous");
+                    break;
+                case 11:
+                    // (, line 116
+                    // <-, line 116
+                    slice_from("ive");
+                    break;
+                case 12:
+                    // (, line 118
+                    // <-, line 118
+                    slice_from("ble");
+                    break;
+                case 13:
+                    // (, line 119
+                    // literal, line 119
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        return false;
+                    }
+                    // <-, line 119
+                    slice_from("og");
+                    break;
+                case 14:
+                    // (, line 120
+                    // <-, line 120
+                    slice_from("ful");
+                    break;
+                case 15:
+                    // (, line 121
+                    // <-, line 121
+                    slice_from("less");
+                    break;
+                case 16:
+                    // (, line 122
+                    if (!(in_grouping_b(g_valid_LI, 99, 116)))
+                    {
+                        return false;
+                    }
+                    // delete, line 122
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_3() {
+            int among_var;
+            // (, line 126
+            // [, line 127
+            ket = cursor;
+            // substring, line 127
+            among_var = find_among_b(a_6, 9);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 127
+            bra = cursor;
+            // call R1, line 127
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 128
+                    // <-, line 128
+                    slice_from("tion");
+                    break;
+                case 2:
+                    // (, line 129
+                    // <-, line 129
+                    slice_from("ate");
+                    break;
+                case 3:
+                    // (, line 130
+                    // <-, line 130
+                    slice_from("al");
+                    break;
+                case 4:
+                    // (, line 132
+                    // <-, line 132
+                    slice_from("ic");
+                    break;
+                case 5:
+                    // (, line 134
+                    // delete, line 134
+                    slice_del();
+                    break;
+                case 6:
+                    // (, line 136
+                    // call R2, line 136
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 136
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_4() {
+            int among_var;
+            int v_1;
+            // (, line 140
+            // [, line 141
+            ket = cursor;
+            // substring, line 141
+            among_var = find_among_b(a_7, 18);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 141
+            bra = cursor;
+            // call R2, line 141
+            if (!r_R2())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 144
+                    // delete, line 144
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 145
+                    // or, line 145
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // literal, line 145
+                            if (!(eq_s_b(1, "s")))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // literal, line 145
+                        if (!(eq_s_b(1, "t")))
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 145
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_5() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 149
+            // [, line 150
+            ket = cursor;
+            // substring, line 150
+            among_var = find_among_b(a_8, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 150
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 151
+                    // or, line 151
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // call R2, line 151
+                            if (!r_R2())
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // (, line 151
+                        // call R1, line 151
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // not, line 151
+                        {
+                            v_2 = limit - cursor;
+                            lab2: do {
+                                // call shortv, line 151
+                                if (!r_shortv())
+                                {
+                                    break lab2;
+                                }
+                                return false;
+                            } while (false);
+                            cursor = limit - v_2;
+                        }
+                    } while (false);
+                    // delete, line 151
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 152
+                    // call R2, line 152
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // literal, line 152
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        return false;
+                    }
+                    // delete, line 152
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_exception2() {
+            // (, line 156
+            // [, line 158
+            ket = cursor;
+            // substring, line 158
+            if (find_among_b(a_9, 8) == 0)
+            {
+                return false;
+            }
+            // ], line 158
+            bra = cursor;
+            // atlimit, line 158
+            if (cursor > limit_backward)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_exception1() {
+            int among_var;
+            // (, line 168
+            // [, line 170
+            bra = cursor;
+            // substring, line 170
+            among_var = find_among(a_10, 18);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 170
+            ket = cursor;
+            // atlimit, line 170
+            if (cursor < limit)
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 174
+                    // <-, line 174
+                    slice_from("ski");
+                    break;
+                case 2:
+                    // (, line 175
+                    // <-, line 175
+                    slice_from("sky");
+                    break;
+                case 3:
+                    // (, line 176
+                    // <-, line 176
+                    slice_from("die");
+                    break;
+                case 4:
+                    // (, line 177
+                    // <-, line 177
+                    slice_from("lie");
+                    break;
+                case 5:
+                    // (, line 178
+                    // <-, line 178
+                    slice_from("tie");
+                    break;
+                case 6:
+                    // (, line 182
+                    // <-, line 182
+                    slice_from("idl");
+                    break;
+                case 7:
+                    // (, line 183
+                    // <-, line 183
+                    slice_from("gentl");
+                    break;
+                case 8:
+                    // (, line 184
+                    // <-, line 184
+                    slice_from("ugli");
+                    break;
+                case 9:
+                    // (, line 185
+                    // <-, line 185
+                    slice_from("earli");
+                    break;
+                case 10:
+                    // (, line 186
+                    // <-, line 186
+                    slice_from("onli");
+                    break;
+                case 11:
+                    // (, line 187
+                    // <-, line 187
+                    slice_from("singl");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int v_1;
+            int v_2;
+            // (, line 203
+            // Boolean test Y_found, line 203
+            if (!(B_Y_found))
+            {
+                return false;
+            }
+            // repeat, line 203
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 203
+                    // goto, line 203
+                    golab2: while(true)
+                    {
+                        v_2 = cursor;
+                        lab3: do {
+                            // (, line 203
+                            // [, line 203
+                            bra = cursor;
+                            // literal, line 203
+                            if (!(eq_s(1, "Y")))
+                            {
+                                break lab3;
+                            }
+                            // ], line 203
+                            ket = cursor;
+                            cursor = v_2;
+                            break golab2;
+                        } while (false);
+                        cursor = v_2;
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    // <-, line 203
+                    slice_from("y");
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            int v_12;
+            int v_13;
+            // (, line 205
+            // or, line 207
+            lab0: do {
+                v_1 = cursor;
+                lab1: do {
+                    // call exception1, line 207
+                    if (!r_exception1())
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = v_1;
+                lab2: do {
+                    // not, line 208
+                    {
+                        v_2 = cursor;
+                        lab3: do {
+                            // hop, line 208
+                            {
+                                int c = cursor + 3;
+                                if (0 > c || c > limit)
+                                {
+                                    break lab3;
+                                }
+                                cursor = c;
+                            }
+                            break lab2;
+                        } while (false);
+                        cursor = v_2;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = v_1;
+                // (, line 208
+                // do, line 209
+                v_3 = cursor;
+                lab4: do {
+                    // call prelude, line 209
+                    if (!r_prelude())
+                    {
+                        break lab4;
+                    }
+                } while (false);
+                cursor = v_3;
+                // do, line 210
+                v_4 = cursor;
+                lab5: do {
+                    // call mark_regions, line 210
+                    if (!r_mark_regions())
+                    {
+                        break lab5;
+                    }
+                } while (false);
+                cursor = v_4;
+                // backwards, line 211
+                limit_backward = cursor; cursor = limit;
+                // (, line 211
+                // do, line 213
+                v_5 = limit - cursor;
+                lab6: do {
+                    // call Step_1a, line 213
+                    if (!r_Step_1a())
+                    {
+                        break lab6;
+                    }
+                } while (false);
+                cursor = limit - v_5;
+                // or, line 215
+                lab7: do {
+                    v_6 = limit - cursor;
+                    lab8: do {
+                        // call exception2, line 215
+                        if (!r_exception2())
+                        {
+                            break lab8;
+                        }
+                        break lab7;
+                    } while (false);
+                    cursor = limit - v_6;
+                    // (, line 215
+                    // do, line 217
+                    v_7 = limit - cursor;
+                    lab9: do {
+                        // call Step_1b, line 217
+                        if (!r_Step_1b())
+                        {
+                            break lab9;
+                        }
+                    } while (false);
+                    cursor = limit - v_7;
+                    // do, line 218
+                    v_8 = limit - cursor;
+                    lab10: do {
+                        // call Step_1c, line 218
+                        if (!r_Step_1c())
+                        {
+                            break lab10;
+                        }
+                    } while (false);
+                    cursor = limit - v_8;
+                    // do, line 220
+                    v_9 = limit - cursor;
+                    lab11: do {
+                        // call Step_2, line 220
+                        if (!r_Step_2())
+                        {
+                            break lab11;
+                        }
+                    } while (false);
+                    cursor = limit - v_9;
+                    // do, line 221
+                    v_10 = limit - cursor;
+                    lab12: do {
+                        // call Step_3, line 221
+                        if (!r_Step_3())
+                        {
+                            break lab12;
+                        }
+                    } while (false);
+                    cursor = limit - v_10;
+                    // do, line 222
+                    v_11 = limit - cursor;
+                    lab13: do {
+                        // call Step_4, line 222
+                        if (!r_Step_4())
+                        {
+                            break lab13;
+                        }
+                    } while (false);
+                    cursor = limit - v_11;
+                    // do, line 224
+                    v_12 = limit - cursor;
+                    lab14: do {
+                        // call Step_5, line 224
+                        if (!r_Step_5())
+                        {
+                            break lab14;
+                        }
+                    } while (false);
+                    cursor = limit - v_12;
+                } while (false);
+                cursor = limit_backward;                // do, line 227
+                v_13 = cursor;
+                lab15: do {
+                    // call postlude, line 227
+                    if (!r_postlude())
+                    {
+                        break lab15;
+                    }
+                } while (false);
+                cursor = v_13;
+            } while (false);
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/FinnishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/FinnishStemmer.java
new file mode 100644
index 0000000..bd6e793
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/FinnishStemmer.java
@@ -0,0 +1,1034 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class FinnishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "pa", -1, 1, "", this),
+            new Among ( "sti", -1, 2, "", this),
+            new Among ( "kaan", -1, 1, "", this),
+            new Among ( "han", -1, 1, "", this),
+            new Among ( "kin", -1, 1, "", this),
+            new Among ( "h\u00E4n", -1, 1, "", this),
+            new Among ( "k\u00E4\u00E4n", -1, 1, "", this),
+            new Among ( "ko", -1, 1, "", this),
+            new Among ( "p\u00E4", -1, 1, "", this),
+            new Among ( "k\u00F6", -1, 1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "lla", -1, -1, "", this),
+            new Among ( "na", -1, -1, "", this),
+            new Among ( "ssa", -1, -1, "", this),
+            new Among ( "ta", -1, -1, "", this),
+            new Among ( "lta", 3, -1, "", this),
+            new Among ( "sta", 3, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ll\u00E4", -1, -1, "", this),
+            new Among ( "n\u00E4", -1, -1, "", this),
+            new Among ( "ss\u00E4", -1, -1, "", this),
+            new Among ( "t\u00E4", -1, -1, "", this),
+            new Among ( "lt\u00E4", 3, -1, "", this),
+            new Among ( "st\u00E4", 3, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "lle", -1, -1, "", this),
+            new Among ( "ine", -1, -1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "nsa", -1, 3, "", this),
+            new Among ( "mme", -1, 3, "", this),
+            new Among ( "nne", -1, 3, "", this),
+            new Among ( "ni", -1, 2, "", this),
+            new Among ( "si", -1, 1, "", this),
+            new Among ( "an", -1, 4, "", this),
+            new Among ( "en", -1, 6, "", this),
+            new Among ( "\u00E4n", -1, 5, "", this),
+            new Among ( "ns\u00E4", -1, 3, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "aa", -1, -1, "", this),
+            new Among ( "ee", -1, -1, "", this),
+            new Among ( "ii", -1, -1, "", this),
+            new Among ( "oo", -1, -1, "", this),
+            new Among ( "uu", -1, -1, "", this),
+            new Among ( "\u00E4\u00E4", -1, -1, "", this),
+            new Among ( "\u00F6\u00F6", -1, -1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "a", -1, 8, "", this),
+            new Among ( "lla", 0, -1, "", this),
+            new Among ( "na", 0, -1, "", this),
+            new Among ( "ssa", 0, -1, "", this),
+            new Among ( "ta", 0, -1, "", this),
+            new Among ( "lta", 4, -1, "", this),
+            new Among ( "sta", 4, -1, "", this),
+            new Among ( "tta", 4, 9, "", this),
+            new Among ( "lle", -1, -1, "", this),
+            new Among ( "ine", -1, -1, "", this),
+            new Among ( "ksi", -1, -1, "", this),
+            new Among ( "n", -1, 7, "", this),
+            new Among ( "han", 11, 1, "", this),
+            new Among ( "den", 11, -1, "r_VI", this),
+            new Among ( "seen", 11, -1, "r_LONG", this),
+            new Among ( "hen", 11, 2, "", this),
+            new Among ( "tten", 11, -1, "r_VI", this),
+            new Among ( "hin", 11, 3, "", this),
+            new Among ( "siin", 11, -1, "r_VI", this),
+            new Among ( "hon", 11, 4, "", this),
+            new Among ( "h\u00E4n", 11, 5, "", this),
+            new Among ( "h\u00F6n", 11, 6, "", this),
+            new Among ( "\u00E4", -1, 8, "", this),
+            new Among ( "ll\u00E4", 22, -1, "", this),
+            new Among ( "n\u00E4", 22, -1, "", this),
+            new Among ( "ss\u00E4", 22, -1, "", this),
+            new Among ( "t\u00E4", 22, -1, "", this),
+            new Among ( "lt\u00E4", 26, -1, "", this),
+            new Among ( "st\u00E4", 26, -1, "", this),
+            new Among ( "tt\u00E4", 26, 9, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "eja", -1, -1, "", this),
+            new Among ( "mma", -1, 1, "", this),
+            new Among ( "imma", 1, -1, "", this),
+            new Among ( "mpa", -1, 1, "", this),
+            new Among ( "impa", 3, -1, "", this),
+            new Among ( "mmi", -1, 1, "", this),
+            new Among ( "immi", 5, -1, "", this),
+            new Among ( "mpi", -1, 1, "", this),
+            new Among ( "impi", 7, -1, "", this),
+            new Among ( "ej\u00E4", -1, -1, "", this),
+            new Among ( "mm\u00E4", -1, 1, "", this),
+            new Among ( "imm\u00E4", 10, -1, "", this),
+            new Among ( "mp\u00E4", -1, 1, "", this),
+            new Among ( "imp\u00E4", 12, -1, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "i", -1, -1, "", this),
+            new Among ( "j", -1, -1, "", this)
+        };
+
+        private Among a_9[] = {
+            new Among ( "mma", -1, 1, "", this),
+            new Among ( "imma", 0, -1, "", this)
+        };
+
+        private static final char g_AEI[] = {17, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8 };
+
+        private static final char g_V1[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+        private static final char g_V2[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+        private static final char g_particle_end[] = {17, 97, 24, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32 };
+
+        private boolean B_ending_removed;
+        private StringBuilder S_x = new StringBuilder();
+        private int I_p2;
+        private int I_p1;
+
+        private void copy_from(FinnishStemmer other) {
+            B_ending_removed = other.B_ending_removed;
+            S_x = other.S_x;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_3;
+            // (, line 41
+            I_p1 = limit;
+            I_p2 = limit;
+            // goto, line 46
+            golab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    if (!(in_grouping(g_V1, 97, 246)))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_1;
+                    break golab0;
+                } while (false);
+                cursor = v_1;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 46
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_V1, 97, 246)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 46
+            I_p1 = cursor;
+            // goto, line 47
+            golab4: while(true)
+            {
+                v_3 = cursor;
+                lab5: do {
+                    if (!(in_grouping(g_V1, 97, 246)))
+                    {
+                        break lab5;
+                    }
+                    cursor = v_3;
+                    break golab4;
+                } while (false);
+                cursor = v_3;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 47
+            golab6: while(true)
+            {
+                lab7: do {
+                    if (!(out_grouping(g_V1, 97, 246)))
+                    {
+                        break lab7;
+                    }
+                    break golab6;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p2, line 47
+            I_p2 = cursor;
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_particle_etc() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 54
+            // setlimit, line 55
+            v_1 = limit - cursor;
+            // tomark, line 55
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 55
+            // [, line 55
+            ket = cursor;
+            // substring, line 55
+            among_var = find_among_b(a_0, 10);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 55
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 62
+                    if (!(in_grouping_b(g_particle_end, 97, 246)))
+                    {
+                        return false;
+                    }
+                    break;
+                case 2:
+                    // (, line 64
+                    // call R2, line 64
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    break;
+            }
+            // delete, line 66
+            slice_del();
+            return true;
+        }
+
+        private boolean r_possessive() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 68
+            // setlimit, line 69
+            v_1 = limit - cursor;
+            // tomark, line 69
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 69
+            // [, line 69
+            ket = cursor;
+            // substring, line 69
+            among_var = find_among_b(a_4, 9);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 69
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 72
+                    // not, line 72
+                    {
+                        v_3 = limit - cursor;
+                        lab0: do {
+                            // literal, line 72
+                            if (!(eq_s_b(1, "k")))
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_3;
+                    }
+                    // delete, line 72
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 74
+                    // delete, line 74
+                    slice_del();
+                    // [, line 74
+                    ket = cursor;
+                    // literal, line 74
+                    if (!(eq_s_b(3, "kse")))
+                    {
+                        return false;
+                    }
+                    // ], line 74
+                    bra = cursor;
+                    // <-, line 74
+                    slice_from("ksi");
+                    break;
+                case 3:
+                    // (, line 78
+                    // delete, line 78
+                    slice_del();
+                    break;
+                case 4:
+                    // (, line 81
+                    // among, line 81
+                    if (find_among_b(a_1, 6) == 0)
+                    {
+                        return false;
+                    }
+                    // delete, line 81
+                    slice_del();
+                    break;
+                case 5:
+                    // (, line 83
+                    // among, line 83
+                    if (find_among_b(a_2, 6) == 0)
+                    {
+                        return false;
+                    }
+                    // delete, line 84
+                    slice_del();
+                    break;
+                case 6:
+                    // (, line 86
+                    // among, line 86
+                    if (find_among_b(a_3, 2) == 0)
+                    {
+                        return false;
+                    }
+                    // delete, line 86
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_LONG() {
+            // among, line 91
+            if (find_among_b(a_5, 7) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_VI() {
+            // (, line 93
+            // literal, line 93
+            if (!(eq_s_b(1, "i")))
+            {
+                return false;
+            }
+            if (!(in_grouping_b(g_V2, 97, 246)))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_case_ending() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 95
+            // setlimit, line 96
+            v_1 = limit - cursor;
+            // tomark, line 96
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 96
+            // [, line 96
+            ket = cursor;
+            // substring, line 96
+            among_var = find_among_b(a_6, 30);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 96
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 98
+                    // literal, line 98
+                    if (!(eq_s_b(1, "a")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 2:
+                    // (, line 99
+                    // literal, line 99
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 3:
+                    // (, line 100
+                    // literal, line 100
+                    if (!(eq_s_b(1, "i")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 4:
+                    // (, line 101
+                    // literal, line 101
+                    if (!(eq_s_b(1, "o")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 5:
+                    // (, line 102
+                    // literal, line 102
+                    if (!(eq_s_b(1, "\u00E4")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 6:
+                    // (, line 103
+                    // literal, line 103
+                    if (!(eq_s_b(1, "\u00F6")))
+                    {
+                        return false;
+                    }
+                    break;
+                case 7:
+                    // (, line 111
+                    // try, line 111
+                    v_3 = limit - cursor;
+                    lab0: do {
+                        // (, line 111
+                        // and, line 113
+                        v_4 = limit - cursor;
+                        // or, line 112
+                        lab1: do {
+                            v_5 = limit - cursor;
+                            lab2: do {
+                                // call LONG, line 111
+                                if (!r_LONG())
+                                {
+                                    break lab2;
+                                }
+                                break lab1;
+                            } while (false);
+                            cursor = limit - v_5;
+                            // literal, line 112
+                            if (!(eq_s_b(2, "ie")))
+                            {
+                                cursor = limit - v_3;
+                                break lab0;
+                            }
+                        } while (false);
+                        cursor = limit - v_4;
+                        // next, line 113
+                        if (cursor <= limit_backward)
+                        {
+                            cursor = limit - v_3;
+                            break lab0;
+                        }
+                        cursor--;
+                        // ], line 113
+                        bra = cursor;
+                    } while (false);
+                    break;
+                case 8:
+                    // (, line 119
+                    if (!(in_grouping_b(g_V1, 97, 246)))
+                    {
+                        return false;
+                    }
+                    if (!(out_grouping_b(g_V1, 97, 246)))
+                    {
+                        return false;
+                    }
+                    break;
+                case 9:
+                    // (, line 121
+                    // literal, line 121
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        return false;
+                    }
+                    break;
+            }
+            // delete, line 138
+            slice_del();
+            // set ending_removed, line 139
+            B_ending_removed = true;
+            return true;
+        }
+
+        private boolean r_other_endings() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 141
+            // setlimit, line 142
+            v_1 = limit - cursor;
+            // tomark, line 142
+            if (cursor < I_p2)
+            {
+                return false;
+            }
+            cursor = I_p2;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 142
+            // [, line 142
+            ket = cursor;
+            // substring, line 142
+            among_var = find_among_b(a_7, 14);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 142
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 146
+                    // not, line 146
+                    {
+                        v_3 = limit - cursor;
+                        lab0: do {
+                            // literal, line 146
+                            if (!(eq_s_b(2, "po")))
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_3;
+                    }
+                    break;
+            }
+            // delete, line 151
+            slice_del();
+            return true;
+        }
+
+        private boolean r_i_plural() {
+            int v_1;
+            int v_2;
+            // (, line 153
+            // setlimit, line 154
+            v_1 = limit - cursor;
+            // tomark, line 154
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 154
+            // [, line 154
+            ket = cursor;
+            // substring, line 154
+            if (find_among_b(a_8, 2) == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 154
+            bra = cursor;
+            limit_backward = v_2;
+            // delete, line 158
+            slice_del();
+            return true;
+        }
+
+        private boolean r_t_plural() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            // (, line 160
+            // setlimit, line 161
+            v_1 = limit - cursor;
+            // tomark, line 161
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 161
+            // [, line 162
+            ket = cursor;
+            // literal, line 162
+            if (!(eq_s_b(1, "t")))
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 162
+            bra = cursor;
+            // test, line 162
+            v_3 = limit - cursor;
+            if (!(in_grouping_b(g_V1, 97, 246)))
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            cursor = limit - v_3;
+            // delete, line 163
+            slice_del();
+            limit_backward = v_2;
+            // setlimit, line 165
+            v_4 = limit - cursor;
+            // tomark, line 165
+            if (cursor < I_p2)
+            {
+                return false;
+            }
+            cursor = I_p2;
+            v_5 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_4;
+            // (, line 165
+            // [, line 165
+            ket = cursor;
+            // substring, line 165
+            among_var = find_among_b(a_9, 2);
+            if (among_var == 0)
+            {
+                limit_backward = v_5;
+                return false;
+            }
+            // ], line 165
+            bra = cursor;
+            limit_backward = v_5;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 167
+                    // not, line 167
+                    {
+                        v_6 = limit - cursor;
+                        lab0: do {
+                            // literal, line 167
+                            if (!(eq_s_b(2, "po")))
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_6;
+                    }
+                    break;
+            }
+            // delete, line 170
+            slice_del();
+            return true;
+        }
+
+        private boolean r_tidy() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            // (, line 172
+            // setlimit, line 173
+            v_1 = limit - cursor;
+            // tomark, line 173
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 173
+            // do, line 174
+            v_3 = limit - cursor;
+            lab0: do {
+                // (, line 174
+                // and, line 174
+                v_4 = limit - cursor;
+                // call LONG, line 174
+                if (!r_LONG())
+                {
+                    break lab0;
+                }
+                cursor = limit - v_4;
+                // (, line 174
+                // [, line 174
+                ket = cursor;
+                // next, line 174
+                if (cursor <= limit_backward)
+                {
+                    break lab0;
+                }
+                cursor--;
+                // ], line 174
+                bra = cursor;
+                // delete, line 174
+                slice_del();
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 175
+            v_5 = limit - cursor;
+            lab1: do {
+                // (, line 175
+                // [, line 175
+                ket = cursor;
+                if (!(in_grouping_b(g_AEI, 97, 228)))
+                {
+                    break lab1;
+                }
+                // ], line 175
+                bra = cursor;
+                if (!(out_grouping_b(g_V1, 97, 246)))
+                {
+                    break lab1;
+                }
+                // delete, line 175
+                slice_del();
+            } while (false);
+            cursor = limit - v_5;
+            // do, line 176
+            v_6 = limit - cursor;
+            lab2: do {
+                // (, line 176
+                // [, line 176
+                ket = cursor;
+                // literal, line 176
+                if (!(eq_s_b(1, "j")))
+                {
+                    break lab2;
+                }
+                // ], line 176
+                bra = cursor;
+                // or, line 176
+                lab3: do {
+                    v_7 = limit - cursor;
+                    lab4: do {
+                        // literal, line 176
+                        if (!(eq_s_b(1, "o")))
+                        {
+                            break lab4;
+                        }
+                        break lab3;
+                    } while (false);
+                    cursor = limit - v_7;
+                    // literal, line 176
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        break lab2;
+                    }
+                } while (false);
+                // delete, line 176
+                slice_del();
+            } while (false);
+            cursor = limit - v_6;
+            // do, line 177
+            v_8 = limit - cursor;
+            lab5: do {
+                // (, line 177
+                // [, line 177
+                ket = cursor;
+                // literal, line 177
+                if (!(eq_s_b(1, "o")))
+                {
+                    break lab5;
+                }
+                // ], line 177
+                bra = cursor;
+                // literal, line 177
+                if (!(eq_s_b(1, "j")))
+                {
+                    break lab5;
+                }
+                // delete, line 177
+                slice_del();
+            } while (false);
+            cursor = limit - v_8;
+            limit_backward = v_2;
+            // goto, line 179
+            golab6: while(true)
+            {
+                v_9 = limit - cursor;
+                lab7: do {
+                    if (!(out_grouping_b(g_V1, 97, 246)))
+                    {
+                        break lab7;
+                    }
+                    cursor = limit - v_9;
+                    break golab6;
+                } while (false);
+                cursor = limit - v_9;
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+            }
+            // [, line 179
+            ket = cursor;
+            // next, line 179
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 179
+            bra = cursor;
+            // -> x, line 179
+            S_x = slice_to(S_x);
+            // name x, line 179
+            if (!(eq_v_b(S_x)))
+            {
+                return false;
+            }
+            // delete, line 179
+            slice_del();
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            // (, line 183
+            // do, line 185
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 185
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // unset ending_removed, line 186
+            B_ending_removed = false;
+            // backwards, line 187
+            limit_backward = cursor; cursor = limit;
+            // (, line 187
+            // do, line 188
+            v_2 = limit - cursor;
+            lab1: do {
+                // call particle_etc, line 188
+                if (!r_particle_etc())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 189
+            v_3 = limit - cursor;
+            lab2: do {
+                // call possessive, line 189
+                if (!r_possessive())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 190
+            v_4 = limit - cursor;
+            lab3: do {
+                // call case_ending, line 190
+                if (!r_case_ending())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            // do, line 191
+            v_5 = limit - cursor;
+            lab4: do {
+                // call other_endings, line 191
+                if (!r_other_endings())
+                {
+                    break lab4;
+                }
+            } while (false);
+            cursor = limit - v_5;
+            // or, line 192
+            lab5: do {
+                v_6 = limit - cursor;
+                lab6: do {
+                    // (, line 192
+                    // Boolean test ending_removed, line 192
+                    if (!(B_ending_removed))
+                    {
+                        break lab6;
+                    }
+                    // do, line 192
+                    v_7 = limit - cursor;
+                    lab7: do {
+                        // call i_plural, line 192
+                        if (!r_i_plural())
+                        {
+                            break lab7;
+                        }
+                    } while (false);
+                    cursor = limit - v_7;
+                    break lab5;
+                } while (false);
+                cursor = limit - v_6;
+                // do, line 192
+                v_8 = limit - cursor;
+                lab8: do {
+                    // call t_plural, line 192
+                    if (!r_t_plural())
+                    {
+                        break lab8;
+                    }
+                } while (false);
+                cursor = limit - v_8;
+            } while (false);
+            // do, line 193
+            v_9 = limit - cursor;
+            lab9: do {
+                // call tidy, line 193
+                if (!r_tidy())
+                {
+                    break lab9;
+                }
+            } while (false);
+            cursor = limit - v_9;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/FrenchStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/FrenchStemmer.java
new file mode 100644
index 0000000..04485b2
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/FrenchStemmer.java
@@ -0,0 +1,1501 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class FrenchStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "col", -1, -1, "", this),
+            new Among ( "par", -1, -1, "", this),
+            new Among ( "tap", -1, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 4, "", this),
+            new Among ( "I", 0, 1, "", this),
+            new Among ( "U", 0, 2, "", this),
+            new Among ( "Y", 0, 3, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "iqU", -1, 3, "", this),
+            new Among ( "abl", -1, 3, "", this),
+            new Among ( "I\u00E8r", -1, 4, "", this),
+            new Among ( "i\u00E8r", -1, 4, "", this),
+            new Among ( "eus", -1, 2, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ic", -1, 2, "", this),
+            new Among ( "abil", -1, 1, "", this),
+            new Among ( "iv", -1, 3, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "iqUe", -1, 1, "", this),
+            new Among ( "atrice", -1, 2, "", this),
+            new Among ( "ance", -1, 1, "", this),
+            new Among ( "ence", -1, 5, "", this),
+            new Among ( "logie", -1, 3, "", this),
+            new Among ( "able", -1, 1, "", this),
+            new Among ( "isme", -1, 1, "", this),
+            new Among ( "euse", -1, 11, "", this),
+            new Among ( "iste", -1, 1, "", this),
+            new Among ( "ive", -1, 8, "", this),
+            new Among ( "if", -1, 8, "", this),
+            new Among ( "usion", -1, 4, "", this),
+            new Among ( "ation", -1, 2, "", this),
+            new Among ( "ution", -1, 4, "", this),
+            new Among ( "ateur", -1, 2, "", this),
+            new Among ( "iqUes", -1, 1, "", this),
+            new Among ( "atrices", -1, 2, "", this),
+            new Among ( "ances", -1, 1, "", this),
+            new Among ( "ences", -1, 5, "", this),
+            new Among ( "logies", -1, 3, "", this),
+            new Among ( "ables", -1, 1, "", this),
+            new Among ( "ismes", -1, 1, "", this),
+            new Among ( "euses", -1, 11, "", this),
+            new Among ( "istes", -1, 1, "", this),
+            new Among ( "ives", -1, 8, "", this),
+            new Among ( "ifs", -1, 8, "", this),
+            new Among ( "usions", -1, 4, "", this),
+            new Among ( "ations", -1, 2, "", this),
+            new Among ( "utions", -1, 4, "", this),
+            new Among ( "ateurs", -1, 2, "", this),
+            new Among ( "ments", -1, 15, "", this),
+            new Among ( "ements", 30, 6, "", this),
+            new Among ( "issements", 31, 12, "", this),
+            new Among ( "it\u00E9s", -1, 7, "", this),
+            new Among ( "ment", -1, 15, "", this),
+            new Among ( "ement", 34, 6, "", this),
+            new Among ( "issement", 35, 12, "", this),
+            new Among ( "amment", 34, 13, "", this),
+            new Among ( "emment", 34, 14, "", this),
+            new Among ( "aux", -1, 10, "", this),
+            new Among ( "eaux", 39, 9, "", this),
+            new Among ( "eux", -1, 1, "", this),
+            new Among ( "it\u00E9", -1, 7, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ira", -1, 1, "", this),
+            new Among ( "ie", -1, 1, "", this),
+            new Among ( "isse", -1, 1, "", this),
+            new Among ( "issante", -1, 1, "", this),
+            new Among ( "i", -1, 1, "", this),
+            new Among ( "irai", 4, 1, "", this),
+            new Among ( "ir", -1, 1, "", this),
+            new Among ( "iras", -1, 1, "", this),
+            new Among ( "ies", -1, 1, "", this),
+            new Among ( "\u00EEmes", -1, 1, "", this),
+            new Among ( "isses", -1, 1, "", this),
+            new Among ( "issantes", -1, 1, "", this),
+            new Among ( "\u00EEtes", -1, 1, "", this),
+            new Among ( "is", -1, 1, "", this),
+            new Among ( "irais", 13, 1, "", this),
+            new Among ( "issais", 13, 1, "", this),
+            new Among ( "irions", -1, 1, "", this),
+            new Among ( "issions", -1, 1, "", this),
+            new Among ( "irons", -1, 1, "", this),
+            new Among ( "issons", -1, 1, "", this),
+            new Among ( "issants", -1, 1, "", this),
+            new Among ( "it", -1, 1, "", this),
+            new Among ( "irait", 21, 1, "", this),
+            new Among ( "issait", 21, 1, "", this),
+            new Among ( "issant", -1, 1, "", this),
+            new Among ( "iraIent", -1, 1, "", this),
+            new Among ( "issaIent", -1, 1, "", this),
+            new Among ( "irent", -1, 1, "", this),
+            new Among ( "issent", -1, 1, "", this),
+            new Among ( "iront", -1, 1, "", this),
+            new Among ( "\u00EEt", -1, 1, "", this),
+            new Among ( "iriez", -1, 1, "", this),
+            new Among ( "issiez", -1, 1, "", this),
+            new Among ( "irez", -1, 1, "", this),
+            new Among ( "issez", -1, 1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "a", -1, 3, "", this),
+            new Among ( "era", 0, 2, "", this),
+            new Among ( "asse", -1, 3, "", this),
+            new Among ( "ante", -1, 3, "", this),
+            new Among ( "\u00E9e", -1, 2, "", this),
+            new Among ( "ai", -1, 3, "", this),
+            new Among ( "erai", 5, 2, "", this),
+            new Among ( "er", -1, 2, "", this),
+            new Among ( "as", -1, 3, "", this),
+            new Among ( "eras", 8, 2, "", this),
+            new Among ( "\u00E2mes", -1, 3, "", this),
+            new Among ( "asses", -1, 3, "", this),
+            new Among ( "antes", -1, 3, "", this),
+            new Among ( "\u00E2tes", -1, 3, "", this),
+            new Among ( "\u00E9es", -1, 2, "", this),
+            new Among ( "ais", -1, 3, "", this),
+            new Among ( "erais", 15, 2, "", this),
+            new Among ( "ions", -1, 1, "", this),
+            new Among ( "erions", 17, 2, "", this),
+            new Among ( "assions", 17, 3, "", this),
+            new Among ( "erons", -1, 2, "", this),
+            new Among ( "ants", -1, 3, "", this),
+            new Among ( "\u00E9s", -1, 2, "", this),
+            new Among ( "ait", -1, 3, "", this),
+            new Among ( "erait", 23, 2, "", this),
+            new Among ( "ant", -1, 3, "", this),
+            new Among ( "aIent", -1, 3, "", this),
+            new Among ( "eraIent", 26, 2, "", this),
+            new Among ( "\u00E8rent", -1, 2, "", this),
+            new Among ( "assent", -1, 3, "", this),
+            new Among ( "eront", -1, 2, "", this),
+            new Among ( "\u00E2t", -1, 3, "", this),
+            new Among ( "ez", -1, 2, "", this),
+            new Among ( "iez", 32, 2, "", this),
+            new Among ( "eriez", 33, 2, "", this),
+            new Among ( "assiez", 33, 3, "", this),
+            new Among ( "erez", 32, 2, "", this),
+            new Among ( "\u00E9", -1, 2, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "e", -1, 3, "", this),
+            new Among ( "I\u00E8re", 0, 2, "", this),
+            new Among ( "i\u00E8re", 0, 2, "", this),
+            new Among ( "ion", -1, 1, "", this),
+            new Among ( "Ier", -1, 2, "", this),
+            new Among ( "ier", -1, 2, "", this),
+            new Among ( "\u00EB", -1, 4, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "ell", -1, -1, "", this),
+            new Among ( "eill", -1, -1, "", this),
+            new Among ( "enn", -1, -1, "", this),
+            new Among ( "onn", -1, -1, "", this),
+            new Among ( "ett", -1, -1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 130, 103, 8, 5 };
+
+        private static final char g_keep_with_s[] = {1, 65, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128 };
+
+        private int I_p2;
+        private int I_p1;
+        private int I_pV;
+
+        private void copy_from(FrenchStemmer other) {
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // repeat, line 38
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // goto, line 38
+                    golab2: while(true)
+                    {
+                        v_2 = cursor;
+                        lab3: do {
+                            // (, line 38
+                            // or, line 44
+                            lab4: do {
+                                v_3 = cursor;
+                                lab5: do {
+                                    // (, line 40
+                                    if (!(in_grouping(g_v, 97, 251)))
+                                    {
+                                        break lab5;
+                                    }
+                                    // [, line 40
+                                    bra = cursor;
+                                    // or, line 40
+                                    lab6: do {
+                                        v_4 = cursor;
+                                        lab7: do {
+                                            // (, line 40
+                                            // literal, line 40
+                                            if (!(eq_s(1, "u")))
+                                            {
+                                                break lab7;
+                                            }
+                                            // ], line 40
+                                            ket = cursor;
+                                            if (!(in_grouping(g_v, 97, 251)))
+                                            {
+                                                break lab7;
+                                            }
+                                            // <-, line 40
+                                            slice_from("U");
+                                            break lab6;
+                                        } while (false);
+                                        cursor = v_4;
+                                        lab8: do {
+                                            // (, line 41
+                                            // literal, line 41
+                                            if (!(eq_s(1, "i")))
+                                            {
+                                                break lab8;
+                                            }
+                                            // ], line 41
+                                            ket = cursor;
+                                            if (!(in_grouping(g_v, 97, 251)))
+                                            {
+                                                break lab8;
+                                            }
+                                            // <-, line 41
+                                            slice_from("I");
+                                            break lab6;
+                                        } while (false);
+                                        cursor = v_4;
+                                        // (, line 42
+                                        // literal, line 42
+                                        if (!(eq_s(1, "y")))
+                                        {
+                                            break lab5;
+                                        }
+                                        // ], line 42
+                                        ket = cursor;
+                                        // <-, line 42
+                                        slice_from("Y");
+                                    } while (false);
+                                    break lab4;
+                                } while (false);
+                                cursor = v_3;
+                                lab9: do {
+                                    // (, line 45
+                                    // [, line 45
+                                    bra = cursor;
+                                    // literal, line 45
+                                    if (!(eq_s(1, "y")))
+                                    {
+                                        break lab9;
+                                    }
+                                    // ], line 45
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 251)))
+                                    {
+                                        break lab9;
+                                    }
+                                    // <-, line 45
+                                    slice_from("Y");
+                                    break lab4;
+                                } while (false);
+                                cursor = v_3;
+                                // (, line 47
+                                // literal, line 47
+                                if (!(eq_s(1, "q")))
+                                {
+                                    break lab3;
+                                }
+                                // [, line 47
+                                bra = cursor;
+                                // literal, line 47
+                                if (!(eq_s(1, "u")))
+                                {
+                                    break lab3;
+                                }
+                                // ], line 47
+                                ket = cursor;
+                                // <-, line 47
+                                slice_from("U");
+                            } while (false);
+                            cursor = v_2;
+                            break golab2;
+                        } while (false);
+                        cursor = v_2;
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_4;
+            // (, line 50
+            I_pV = limit;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 56
+            v_1 = cursor;
+            lab0: do {
+                // (, line 56
+                // or, line 58
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // (, line 57
+                        if (!(in_grouping(g_v, 97, 251)))
+                        {
+                            break lab2;
+                        }
+                        if (!(in_grouping(g_v, 97, 251)))
+                        {
+                            break lab2;
+                        }
+                        // next, line 57
+                        if (cursor >= limit)
+                        {
+                            break lab2;
+                        }
+                        cursor++;
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    lab3: do {
+                        // among, line 59
+                        if (find_among(a_0, 3) == 0)
+                        {
+                            break lab3;
+                        }
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 66
+                    // next, line 66
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                    // gopast, line 66
+                    golab4: while(true)
+                    {
+                        lab5: do {
+                            if (!(in_grouping(g_v, 97, 251)))
+                            {
+                                break lab5;
+                            }
+                            break golab4;
+                        } while (false);
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    }
+                } while (false);
+                // setmark pV, line 67
+                I_pV = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 69
+            v_4 = cursor;
+            lab6: do {
+                // (, line 69
+                // gopast, line 70
+                golab7: while(true)
+                {
+                    lab8: do {
+                        if (!(in_grouping(g_v, 97, 251)))
+                        {
+                            break lab8;
+                        }
+                        break golab7;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // gopast, line 70
+                golab9: while(true)
+                {
+                    lab10: do {
+                        if (!(out_grouping(g_v, 97, 251)))
+                        {
+                            break lab10;
+                        }
+                        break golab9;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 70
+                I_p1 = cursor;
+                // gopast, line 71
+                golab11: while(true)
+                {
+                    lab12: do {
+                        if (!(in_grouping(g_v, 97, 251)))
+                        {
+                            break lab12;
+                        }
+                        break golab11;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // gopast, line 71
+                golab13: while(true)
+                {
+                    lab14: do {
+                        if (!(out_grouping(g_v, 97, 251)))
+                        {
+                            break lab14;
+                        }
+                        break golab13;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 71
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_4;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 75
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 75
+                    // [, line 77
+                    bra = cursor;
+                    // substring, line 77
+                    among_var = find_among(a_1, 4);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 77
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 78
+                            // <-, line 78
+                            slice_from("i");
+                            break;
+                        case 2:
+                            // (, line 79
+                            // <-, line 79
+                            slice_from("u");
+                            break;
+                        case 3:
+                            // (, line 80
+                            // <-, line 80
+                            slice_from("y");
+                            break;
+                        case 4:
+                            // (, line 81
+                            // next, line 81
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_RV() {
+            if (!(I_pV <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            // (, line 91
+            // [, line 92
+            ket = cursor;
+            // substring, line 92
+            among_var = find_among_b(a_4, 43);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 92
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 96
+                    // call R2, line 96
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 96
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 99
+                    // call R2, line 99
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 99
+                    slice_del();
+                    // try, line 100
+                    v_1 = limit - cursor;
+                    lab0: do {
+                        // (, line 100
+                        // [, line 100
+                        ket = cursor;
+                        // literal, line 100
+                        if (!(eq_s_b(2, "ic")))
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // ], line 100
+                        bra = cursor;
+                        // or, line 100
+                        lab1: do {
+                            v_2 = limit - cursor;
+                            lab2: do {
+                                // (, line 100
+                                // call R2, line 100
+                                if (!r_R2())
+                                {
+                                    break lab2;
+                                }
+                                // delete, line 100
+                                slice_del();
+                                break lab1;
+                            } while (false);
+                            cursor = limit - v_2;
+                            // <-, line 100
+                            slice_from("iqU");
+                        } while (false);
+                    } while (false);
+                    break;
+                case 3:
+                    // (, line 104
+                    // call R2, line 104
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 104
+                    slice_from("log");
+                    break;
+                case 4:
+                    // (, line 107
+                    // call R2, line 107
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 107
+                    slice_from("u");
+                    break;
+                case 5:
+                    // (, line 110
+                    // call R2, line 110
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 110
+                    slice_from("ent");
+                    break;
+                case 6:
+                    // (, line 113
+                    // call RV, line 114
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 114
+                    slice_del();
+                    // try, line 115
+                    v_3 = limit - cursor;
+                    lab3: do {
+                        // (, line 115
+                        // [, line 116
+                        ket = cursor;
+                        // substring, line 116
+                        among_var = find_among_b(a_2, 6);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_3;
+                            break lab3;
+                        }
+                        // ], line 116
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_3;
+                                break lab3;
+                            case 1:
+                                // (, line 117
+                                // call R2, line 117
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab3;
+                                }
+                                // delete, line 117
+                                slice_del();
+                                // [, line 117
+                                ket = cursor;
+                                // literal, line 117
+                                if (!(eq_s_b(2, "at")))
+                                {
+                                    cursor = limit - v_3;
+                                    break lab3;
+                                }
+                                // ], line 117
+                                bra = cursor;
+                                // call R2, line 117
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab3;
+                                }
+                                // delete, line 117
+                                slice_del();
+                                break;
+                            case 2:
+                                // (, line 118
+                                // or, line 118
+                                lab4: do {
+                                    v_4 = limit - cursor;
+                                    lab5: do {
+                                        // (, line 118
+                                        // call R2, line 118
+                                        if (!r_R2())
+                                        {
+                                            break lab5;
+                                        }
+                                        // delete, line 118
+                                        slice_del();
+                                        break lab4;
+                                    } while (false);
+                                    cursor = limit - v_4;
+                                    // (, line 118
+                                    // call R1, line 118
+                                    if (!r_R1())
+                                    {
+                                        cursor = limit - v_3;
+                                        break lab3;
+                                    }
+                                    // <-, line 118
+                                    slice_from("eux");
+                                } while (false);
+                                break;
+                            case 3:
+                                // (, line 120
+                                // call R2, line 120
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab3;
+                                }
+                                // delete, line 120
+                                slice_del();
+                                break;
+                            case 4:
+                                // (, line 122
+                                // call RV, line 122
+                                if (!r_RV())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab3;
+                                }
+                                // <-, line 122
+                                slice_from("i");
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 7:
+                    // (, line 128
+                    // call R2, line 129
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 129
+                    slice_del();
+                    // try, line 130
+                    v_5 = limit - cursor;
+                    lab6: do {
+                        // (, line 130
+                        // [, line 131
+                        ket = cursor;
+                        // substring, line 131
+                        among_var = find_among_b(a_3, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_5;
+                            break lab6;
+                        }
+                        // ], line 131
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_5;
+                                break lab6;
+                            case 1:
+                                // (, line 132
+                                // or, line 132
+                                lab7: do {
+                                    v_6 = limit - cursor;
+                                    lab8: do {
+                                        // (, line 132
+                                        // call R2, line 132
+                                        if (!r_R2())
+                                        {
+                                            break lab8;
+                                        }
+                                        // delete, line 132
+                                        slice_del();
+                                        break lab7;
+                                    } while (false);
+                                    cursor = limit - v_6;
+                                    // <-, line 132
+                                    slice_from("abl");
+                                } while (false);
+                                break;
+                            case 2:
+                                // (, line 133
+                                // or, line 133
+                                lab9: do {
+                                    v_7 = limit - cursor;
+                                    lab10: do {
+                                        // (, line 133
+                                        // call R2, line 133
+                                        if (!r_R2())
+                                        {
+                                            break lab10;
+                                        }
+                                        // delete, line 133
+                                        slice_del();
+                                        break lab9;
+                                    } while (false);
+                                    cursor = limit - v_7;
+                                    // <-, line 133
+                                    slice_from("iqU");
+                                } while (false);
+                                break;
+                            case 3:
+                                // (, line 134
+                                // call R2, line 134
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_5;
+                                    break lab6;
+                                }
+                                // delete, line 134
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 8:
+                    // (, line 140
+                    // call R2, line 141
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 141
+                    slice_del();
+                    // try, line 142
+                    v_8 = limit - cursor;
+                    lab11: do {
+                        // (, line 142
+                        // [, line 142
+                        ket = cursor;
+                        // literal, line 142
+                        if (!(eq_s_b(2, "at")))
+                        {
+                            cursor = limit - v_8;
+                            break lab11;
+                        }
+                        // ], line 142
+                        bra = cursor;
+                        // call R2, line 142
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_8;
+                            break lab11;
+                        }
+                        // delete, line 142
+                        slice_del();
+                        // [, line 142
+                        ket = cursor;
+                        // literal, line 142
+                        if (!(eq_s_b(2, "ic")))
+                        {
+                            cursor = limit - v_8;
+                            break lab11;
+                        }
+                        // ], line 142
+                        bra = cursor;
+                        // or, line 142
+                        lab12: do {
+                            v_9 = limit - cursor;
+                            lab13: do {
+                                // (, line 142
+                                // call R2, line 142
+                                if (!r_R2())
+                                {
+                                    break lab13;
+                                }
+                                // delete, line 142
+                                slice_del();
+                                break lab12;
+                            } while (false);
+                            cursor = limit - v_9;
+                            // <-, line 142
+                            slice_from("iqU");
+                        } while (false);
+                    } while (false);
+                    break;
+                case 9:
+                    // (, line 144
+                    // <-, line 144
+                    slice_from("eau");
+                    break;
+                case 10:
+                    // (, line 145
+                    // call R1, line 145
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 145
+                    slice_from("al");
+                    break;
+                case 11:
+                    // (, line 147
+                    // or, line 147
+                    lab14: do {
+                        v_10 = limit - cursor;
+                        lab15: do {
+                            // (, line 147
+                            // call R2, line 147
+                            if (!r_R2())
+                            {
+                                break lab15;
+                            }
+                            // delete, line 147
+                            slice_del();
+                            break lab14;
+                        } while (false);
+                        cursor = limit - v_10;
+                        // (, line 147
+                        // call R1, line 147
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // <-, line 147
+                        slice_from("eux");
+                    } while (false);
+                    break;
+                case 12:
+                    // (, line 150
+                    // call R1, line 150
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    if (!(out_grouping_b(g_v, 97, 251)))
+                    {
+                        return false;
+                    }
+                    // delete, line 150
+                    slice_del();
+                    break;
+                case 13:
+                    // (, line 155
+                    // call RV, line 155
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // fail, line 155
+                    // (, line 155
+                    // <-, line 155
+                    slice_from("ant");
+                    return false;
+                case 14:
+                    // (, line 156
+                    // call RV, line 156
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // fail, line 156
+                    // (, line 156
+                    // <-, line 156
+                    slice_from("ent");
+                    return false;
+                case 15:
+                    // (, line 158
+                    // test, line 158
+                    v_11 = limit - cursor;
+                    // (, line 158
+                    if (!(in_grouping_b(g_v, 97, 251)))
+                    {
+                        return false;
+                    }
+                    // call RV, line 158
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    cursor = limit - v_11;
+                    // fail, line 158
+                    // (, line 158
+                    // delete, line 158
+                    slice_del();
+                    return false;
+            }
+            return true;
+        }
+
+        private boolean r_i_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // setlimit, line 163
+            v_1 = limit - cursor;
+            // tomark, line 163
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 163
+            // [, line 164
+            ket = cursor;
+            // substring, line 164
+            among_var = find_among_b(a_5, 35);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 164
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 170
+                    if (!(out_grouping_b(g_v, 97, 251)))
+                    {
+                        limit_backward = v_2;
+                        return false;
+                    }
+                    // delete, line 170
+                    slice_del();
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // setlimit, line 174
+            v_1 = limit - cursor;
+            // tomark, line 174
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 174
+            // [, line 175
+            ket = cursor;
+            // substring, line 175
+            among_var = find_among_b(a_6, 38);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 175
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 177
+                    // call R2, line 177
+                    if (!r_R2())
+                    {
+                        limit_backward = v_2;
+                        return false;
+                    }
+                    // delete, line 177
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 185
+                    // delete, line 185
+                    slice_del();
+                    break;
+                case 3:
+                    // (, line 190
+                    // delete, line 190
+                    slice_del();
+                    // try, line 191
+                    v_3 = limit - cursor;
+                    lab0: do {
+                        // (, line 191
+                        // [, line 191
+                        ket = cursor;
+                        // literal, line 191
+                        if (!(eq_s_b(1, "e")))
+                        {
+                            cursor = limit - v_3;
+                            break lab0;
+                        }
+                        // ], line 191
+                        bra = cursor;
+                        // delete, line 191
+                        slice_del();
+                    } while (false);
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_residual_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 198
+            // try, line 199
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 199
+                // [, line 199
+                ket = cursor;
+                // literal, line 199
+                if (!(eq_s_b(1, "s")))
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // ], line 199
+                bra = cursor;
+                // test, line 199
+                v_2 = limit - cursor;
+                if (!(out_grouping_b(g_keep_with_s, 97, 232)))
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                cursor = limit - v_2;
+                // delete, line 199
+                slice_del();
+            } while (false);
+            // setlimit, line 200
+            v_3 = limit - cursor;
+            // tomark, line 200
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_4 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_3;
+            // (, line 200
+            // [, line 201
+            ket = cursor;
+            // substring, line 201
+            among_var = find_among_b(a_7, 7);
+            if (among_var == 0)
+            {
+                limit_backward = v_4;
+                return false;
+            }
+            // ], line 201
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_4;
+                    return false;
+                case 1:
+                    // (, line 202
+                    // call R2, line 202
+                    if (!r_R2())
+                    {
+                        limit_backward = v_4;
+                        return false;
+                    }
+                    // or, line 202
+                    lab1: do {
+                        v_5 = limit - cursor;
+                        lab2: do {
+                            // literal, line 202
+                            if (!(eq_s_b(1, "s")))
+                            {
+                                break lab2;
+                            }
+                            break lab1;
+                        } while (false);
+                        cursor = limit - v_5;
+                        // literal, line 202
+                        if (!(eq_s_b(1, "t")))
+                        {
+                            limit_backward = v_4;
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 202
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 204
+                    // <-, line 204
+                    slice_from("i");
+                    break;
+                case 3:
+                    // (, line 205
+                    // delete, line 205
+                    slice_del();
+                    break;
+                case 4:
+                    // (, line 206
+                    // literal, line 206
+                    if (!(eq_s_b(2, "gu")))
+                    {
+                        limit_backward = v_4;
+                        return false;
+                    }
+                    // delete, line 206
+                    slice_del();
+                    break;
+            }
+            limit_backward = v_4;
+            return true;
+        }
+
+        private boolean r_un_double() {
+            int v_1;
+            // (, line 211
+            // test, line 212
+            v_1 = limit - cursor;
+            // among, line 212
+            if (find_among_b(a_8, 5) == 0)
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            // [, line 212
+            ket = cursor;
+            // next, line 212
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 212
+            bra = cursor;
+            // delete, line 212
+            slice_del();
+            return true;
+        }
+
+        private boolean r_un_accent() {
+            int v_3;
+            // (, line 215
+            // atleast, line 216
+            {
+                int v_1 = 1;
+                // atleast, line 216
+                replab0: while(true)
+                {
+                    lab1: do {
+                        if (!(out_grouping_b(g_v, 97, 251)))
+                        {
+                            break lab1;
+                        }
+                        v_1--;
+                        continue replab0;
+                    } while (false);
+                    break replab0;
+                }
+                if (v_1 > 0)
+                {
+                    return false;
+                }
+            }
+            // [, line 217
+            ket = cursor;
+            // or, line 217
+            lab2: do {
+                v_3 = limit - cursor;
+                lab3: do {
+                    // literal, line 217
+                    if (!(eq_s_b(1, "\u00E9")))
+                    {
+                        break lab3;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                // literal, line 217
+                if (!(eq_s_b(1, "\u00E8")))
+                {
+                    return false;
+                }
+            } while (false);
+            // ], line 217
+            bra = cursor;
+            // <-, line 217
+            slice_from("e");
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            // (, line 221
+            // do, line 223
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 223
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 224
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 224
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 225
+            limit_backward = cursor; cursor = limit;
+            // (, line 225
+            // do, line 227
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 227
+                // or, line 237
+                lab3: do {
+                    v_4 = limit - cursor;
+                    lab4: do {
+                        // (, line 228
+                        // and, line 233
+                        v_5 = limit - cursor;
+                        // (, line 229
+                        // or, line 229
+                        lab5: do {
+                            v_6 = limit - cursor;
+                            lab6: do {
+                                // call standard_suffix, line 229
+                                if (!r_standard_suffix())
+                                {
+                                    break lab6;
+                                }
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_6;
+                            lab7: do {
+                                // call i_verb_suffix, line 230
+                                if (!r_i_verb_suffix())
+                                {
+                                    break lab7;
+                                }
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_6;
+                            // call verb_suffix, line 231
+                            if (!r_verb_suffix())
+                            {
+                                break lab4;
+                            }
+                        } while (false);
+                        cursor = limit - v_5;
+                        // try, line 234
+                        v_7 = limit - cursor;
+                        lab8: do {
+                            // (, line 234
+                            // [, line 234
+                            ket = cursor;
+                            // or, line 234
+                            lab9: do {
+                                v_8 = limit - cursor;
+                                lab10: do {
+                                    // (, line 234
+                                    // literal, line 234
+                                    if (!(eq_s_b(1, "Y")))
+                                    {
+                                        break lab10;
+                                    }
+                                    // ], line 234
+                                    bra = cursor;
+                                    // <-, line 234
+                                    slice_from("i");
+                                    break lab9;
+                                } while (false);
+                                cursor = limit - v_8;
+                                // (, line 235
+                                // literal, line 235
+                                if (!(eq_s_b(1, "\u00E7")))
+                                {
+                                    cursor = limit - v_7;
+                                    break lab8;
+                                }
+                                // ], line 235
+                                bra = cursor;
+                                // <-, line 235
+                                slice_from("c");
+                            } while (false);
+                        } while (false);
+                        break lab3;
+                    } while (false);
+                    cursor = limit - v_4;
+                    // call residual_suffix, line 238
+                    if (!r_residual_suffix())
+                    {
+                        break lab2;
+                    }
+                } while (false);
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 243
+            v_9 = limit - cursor;
+            lab11: do {
+                // call un_double, line 243
+                if (!r_un_double())
+                {
+                    break lab11;
+                }
+            } while (false);
+            cursor = limit - v_9;
+            // do, line 244
+            v_10 = limit - cursor;
+            lab12: do {
+                // call un_accent, line 244
+                if (!r_un_accent())
+                {
+                    break lab12;
+                }
+            } while (false);
+            cursor = limit - v_10;
+            cursor = limit_backward;            // do, line 246
+            v_11 = cursor;
+            lab13: do {
+                // call postlude, line 246
+                if (!r_postlude())
+                {
+                    break lab13;
+                }
+            } while (false);
+            cursor = v_11;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/German2Stemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/German2Stemmer.java
new file mode 100644
index 0000000..5167518
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/German2Stemmer.java
@@ -0,0 +1,726 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class German2Stemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 6, "", this),
+            new Among ( "ae", 0, 2, "", this),
+            new Among ( "oe", 0, 3, "", this),
+            new Among ( "qu", 0, 5, "", this),
+            new Among ( "ue", 0, 4, "", this),
+            new Among ( "\u00DF", 0, 1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 6, "", this),
+            new Among ( "U", 0, 2, "", this),
+            new Among ( "Y", 0, 1, "", this),
+            new Among ( "\u00E4", 0, 3, "", this),
+            new Among ( "\u00F6", 0, 4, "", this),
+            new Among ( "\u00FC", 0, 5, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "em", -1, 1, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "ern", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "es", 5, 1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "st", -1, 2, "", this),
+            new Among ( "est", 2, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "lich", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "end", -1, 1, "", this),
+            new Among ( "ig", -1, 2, "", this),
+            new Among ( "ung", -1, 1, "", this),
+            new Among ( "lich", -1, 3, "", this),
+            new Among ( "isch", -1, 2, "", this),
+            new Among ( "ik", -1, 2, "", this),
+            new Among ( "heit", -1, 3, "", this),
+            new Among ( "keit", -1, 4, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32, 8 };
+
+        private static final char g_s_ending[] = {117, 30, 5 };
+
+        private static final char g_st_ending[] = {117, 30, 4 };
+
+        private int I_x;
+        private int I_p2;
+        private int I_p1;
+
+        private void copy_from(German2Stemmer other) {
+            I_x = other.I_x;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 28
+            // test, line 30
+            v_1 = cursor;
+            // repeat, line 30
+            replab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    // goto, line 30
+                    golab2: while(true)
+                    {
+                        v_3 = cursor;
+                        lab3: do {
+                            // (, line 30
+                            if (!(in_grouping(g_v, 97, 252)))
+                            {
+                                break lab3;
+                            }
+                            // [, line 31
+                            bra = cursor;
+                            // or, line 31
+                            lab4: do {
+                                v_4 = cursor;
+                                lab5: do {
+                                    // (, line 31
+                                    // literal, line 31
+                                    if (!(eq_s(1, "u")))
+                                    {
+                                        break lab5;
+                                    }
+                                    // ], line 31
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 252)))
+                                    {
+                                        break lab5;
+                                    }
+                                    // <-, line 31
+                                    slice_from("U");
+                                    break lab4;
+                                } while (false);
+                                cursor = v_4;
+                                // (, line 32
+                                // literal, line 32
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab3;
+                                }
+                                // ], line 32
+                                ket = cursor;
+                                if (!(in_grouping(g_v, 97, 252)))
+                                {
+                                    break lab3;
+                                }
+                                // <-, line 32
+                                slice_from("Y");
+                            } while (false);
+                            cursor = v_3;
+                            break golab2;
+                        } while (false);
+                        cursor = v_3;
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_2;
+                break replab0;
+            }
+            cursor = v_1;
+            // repeat, line 35
+            replab6: while(true)
+            {
+                v_5 = cursor;
+                lab7: do {
+                    // (, line 35
+                    // [, line 36
+                    bra = cursor;
+                    // substring, line 36
+                    among_var = find_among(a_0, 6);
+                    if (among_var == 0)
+                    {
+                        break lab7;
+                    }
+                    // ], line 36
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab7;
+                        case 1:
+                            // (, line 37
+                            // <-, line 37
+                            slice_from("ss");
+                            break;
+                        case 2:
+                            // (, line 38
+                            // <-, line 38
+                            slice_from("\u00E4");
+                            break;
+                        case 3:
+                            // (, line 39
+                            // <-, line 39
+                            slice_from("\u00F6");
+                            break;
+                        case 4:
+                            // (, line 40
+                            // <-, line 40
+                            slice_from("\u00FC");
+                            break;
+                        case 5:
+                            // (, line 41
+                            // hop, line 41
+                            {
+                                int c = cursor + 2;
+                                if (0 > c || c > limit)
+                                {
+                                    break lab7;
+                                }
+                                cursor = c;
+                            }
+                            break;
+                        case 6:
+                            // (, line 42
+                            // next, line 42
+                            if (cursor >= limit)
+                            {
+                                break lab7;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab6;
+                } while (false);
+                cursor = v_5;
+                break replab6;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            // (, line 48
+            I_p1 = limit;
+            I_p2 = limit;
+            // test, line 53
+            v_1 = cursor;
+            // (, line 53
+            // hop, line 53
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // setmark x, line 53
+            I_x = cursor;
+            cursor = v_1;
+            // gopast, line 55
+            golab0: while(true)
+            {
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 252)))
+                    {
+                        break lab1;
+                    }
+                    break golab0;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 55
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 252)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 55
+            I_p1 = cursor;
+            // try, line 56
+            lab4: do {
+                // (, line 56
+                if (!(I_p1 < I_x))
+                {
+                    break lab4;
+                }
+                I_p1 = I_x;
+            } while (false);
+            // gopast, line 57
+            golab5: while(true)
+            {
+                lab6: do {
+                    if (!(in_grouping(g_v, 97, 252)))
+                    {
+                        break lab6;
+                    }
+                    break golab5;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 57
+            golab7: while(true)
+            {
+                lab8: do {
+                    if (!(out_grouping(g_v, 97, 252)))
+                    {
+                        break lab8;
+                    }
+                    break golab7;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p2, line 57
+            I_p2 = cursor;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 61
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 61
+                    // [, line 63
+                    bra = cursor;
+                    // substring, line 63
+                    among_var = find_among(a_1, 6);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 63
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 64
+                            // <-, line 64
+                            slice_from("y");
+                            break;
+                        case 2:
+                            // (, line 65
+                            // <-, line 65
+                            slice_from("u");
+                            break;
+                        case 3:
+                            // (, line 66
+                            // <-, line 66
+                            slice_from("a");
+                            break;
+                        case 4:
+                            // (, line 67
+                            // <-, line 67
+                            slice_from("o");
+                            break;
+                        case 5:
+                            // (, line 68
+                            // <-, line 68
+                            slice_from("u");
+                            break;
+                        case 6:
+                            // (, line 69
+                            // next, line 69
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            // (, line 79
+            // do, line 80
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 80
+                // [, line 81
+                ket = cursor;
+                // substring, line 81
+                among_var = find_among_b(a_2, 7);
+                if (among_var == 0)
+                {
+                    break lab0;
+                }
+                // ], line 81
+                bra = cursor;
+                // call R1, line 81
+                if (!r_R1())
+                {
+                    break lab0;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab0;
+                    case 1:
+                        // (, line 83
+                        // delete, line 83
+                        slice_del();
+                        break;
+                    case 2:
+                        // (, line 86
+                        if (!(in_grouping_b(g_s_ending, 98, 116)))
+                        {
+                            break lab0;
+                        }
+                        // delete, line 86
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // do, line 90
+            v_2 = limit - cursor;
+            lab1: do {
+                // (, line 90
+                // [, line 91
+                ket = cursor;
+                // substring, line 91
+                among_var = find_among_b(a_3, 4);
+                if (among_var == 0)
+                {
+                    break lab1;
+                }
+                // ], line 91
+                bra = cursor;
+                // call R1, line 91
+                if (!r_R1())
+                {
+                    break lab1;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab1;
+                    case 1:
+                        // (, line 93
+                        // delete, line 93
+                        slice_del();
+                        break;
+                    case 2:
+                        // (, line 96
+                        if (!(in_grouping_b(g_st_ending, 98, 116)))
+                        {
+                            break lab1;
+                        }
+                        // hop, line 96
+                        {
+                            int c = cursor - 3;
+                            if (limit_backward > c || c > limit)
+                            {
+                                break lab1;
+                            }
+                            cursor = c;
+                        }
+                        // delete, line 96
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 100
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 100
+                // [, line 101
+                ket = cursor;
+                // substring, line 101
+                among_var = find_among_b(a_5, 8);
+                if (among_var == 0)
+                {
+                    break lab2;
+                }
+                // ], line 101
+                bra = cursor;
+                // call R2, line 101
+                if (!r_R2())
+                {
+                    break lab2;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab2;
+                    case 1:
+                        // (, line 103
+                        // delete, line 103
+                        slice_del();
+                        // try, line 104
+                        v_4 = limit - cursor;
+                        lab3: do {
+                            // (, line 104
+                            // [, line 104
+                            ket = cursor;
+                            // literal, line 104
+                            if (!(eq_s_b(2, "ig")))
+                            {
+                                cursor = limit - v_4;
+                                break lab3;
+                            }
+                            // ], line 104
+                            bra = cursor;
+                            // not, line 104
+                            {
+                                v_5 = limit - cursor;
+                                lab4: do {
+                                    // literal, line 104
+                                    if (!(eq_s_b(1, "e")))
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor = limit - v_4;
+                                    break lab3;
+                                } while (false);
+                                cursor = limit - v_5;
+                            }
+                            // call R2, line 104
+                            if (!r_R2())
+                            {
+                                cursor = limit - v_4;
+                                break lab3;
+                            }
+                            // delete, line 104
+                            slice_del();
+                        } while (false);
+                        break;
+                    case 2:
+                        // (, line 107
+                        // not, line 107
+                        {
+                            v_6 = limit - cursor;
+                            lab5: do {
+                                // literal, line 107
+                                if (!(eq_s_b(1, "e")))
+                                {
+                                    break lab5;
+                                }
+                                break lab2;
+                            } while (false);
+                            cursor = limit - v_6;
+                        }
+                        // delete, line 107
+                        slice_del();
+                        break;
+                    case 3:
+                        // (, line 110
+                        // delete, line 110
+                        slice_del();
+                        // try, line 111
+                        v_7 = limit - cursor;
+                        lab6: do {
+                            // (, line 111
+                            // [, line 112
+                            ket = cursor;
+                            // or, line 112
+                            lab7: do {
+                                v_8 = limit - cursor;
+                                lab8: do {
+                                    // literal, line 112
+                                    if (!(eq_s_b(2, "er")))
+                                    {
+                                        break lab8;
+                                    }
+                                    break lab7;
+                                } while (false);
+                                cursor = limit - v_8;
+                                // literal, line 112
+                                if (!(eq_s_b(2, "en")))
+                                {
+                                    cursor = limit - v_7;
+                                    break lab6;
+                                }
+                            } while (false);
+                            // ], line 112
+                            bra = cursor;
+                            // call R1, line 112
+                            if (!r_R1())
+                            {
+                                cursor = limit - v_7;
+                                break lab6;
+                            }
+                            // delete, line 112
+                            slice_del();
+                        } while (false);
+                        break;
+                    case 4:
+                        // (, line 116
+                        // delete, line 116
+                        slice_del();
+                        // try, line 117
+                        v_9 = limit - cursor;
+                        lab9: do {
+                            // (, line 117
+                            // [, line 118
+                            ket = cursor;
+                            // substring, line 118
+                            among_var = find_among_b(a_4, 2);
+                            if (among_var == 0)
+                            {
+                                cursor = limit - v_9;
+                                break lab9;
+                            }
+                            // ], line 118
+                            bra = cursor;
+                            // call R2, line 118
+                            if (!r_R2())
+                            {
+                                cursor = limit - v_9;
+                                break lab9;
+                            }
+                            switch(among_var) {
+                                case 0:
+                                    cursor = limit - v_9;
+                                    break lab9;
+                                case 1:
+                                    // (, line 120
+                                    // delete, line 120
+                                    slice_del();
+                                    break;
+                            }
+                        } while (false);
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 130
+            // do, line 131
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 131
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 132
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 132
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 133
+            limit_backward = cursor; cursor = limit;
+            // do, line 134
+            v_3 = limit - cursor;
+            lab2: do {
+                // call standard_suffix, line 134
+                if (!r_standard_suffix())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            cursor = limit_backward;            // do, line 135
+            v_4 = cursor;
+            lab3: do {
+                // call postlude, line 135
+                if (!r_postlude())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = v_4;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/GermanStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/GermanStemmer.java
new file mode 100644
index 0000000..7946779
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/GermanStemmer.java
@@ -0,0 +1,688 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class GermanStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 6, "", this),
+            new Among ( "U", 0, 2, "", this),
+            new Among ( "Y", 0, 1, "", this),
+            new Among ( "\u00E4", 0, 3, "", this),
+            new Among ( "\u00F6", 0, 4, "", this),
+            new Among ( "\u00FC", 0, 5, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "em", -1, 1, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "ern", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "es", 5, 1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "st", -1, 2, "", this),
+            new Among ( "est", 2, 1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "lich", -1, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "end", -1, 1, "", this),
+            new Among ( "ig", -1, 2, "", this),
+            new Among ( "ung", -1, 1, "", this),
+            new Among ( "lich", -1, 3, "", this),
+            new Among ( "isch", -1, 2, "", this),
+            new Among ( "ik", -1, 2, "", this),
+            new Among ( "heit", -1, 3, "", this),
+            new Among ( "keit", -1, 4, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 32, 8 };
+
+        private static final char g_s_ending[] = {117, 30, 5 };
+
+        private static final char g_st_ending[] = {117, 30, 4 };
+
+        private int I_x;
+        private int I_p2;
+        private int I_p1;
+
+        private void copy_from(GermanStemmer other) {
+            I_x = other.I_x;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            // (, line 28
+            // test, line 30
+            v_1 = cursor;
+            // repeat, line 30
+            replab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    // (, line 30
+                    // or, line 33
+                    lab2: do {
+                        v_3 = cursor;
+                        lab3: do {
+                            // (, line 31
+                            // [, line 32
+                            bra = cursor;
+                            // literal, line 32
+                            if (!(eq_s(1, "\u00DF")))
+                            {
+                                break lab3;
+                            }
+                            // ], line 32
+                            ket = cursor;
+                            // <-, line 32
+                            slice_from("ss");
+                            break lab2;
+                        } while (false);
+                        cursor = v_3;
+                        // next, line 33
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    } while (false);
+                    continue replab0;
+                } while (false);
+                cursor = v_2;
+                break replab0;
+            }
+            cursor = v_1;
+            // repeat, line 36
+            replab4: while(true)
+            {
+                v_4 = cursor;
+                lab5: do {
+                    // goto, line 36
+                    golab6: while(true)
+                    {
+                        v_5 = cursor;
+                        lab7: do {
+                            // (, line 36
+                            if (!(in_grouping(g_v, 97, 252)))
+                            {
+                                break lab7;
+                            }
+                            // [, line 37
+                            bra = cursor;
+                            // or, line 37
+                            lab8: do {
+                                v_6 = cursor;
+                                lab9: do {
+                                    // (, line 37
+                                    // literal, line 37
+                                    if (!(eq_s(1, "u")))
+                                    {
+                                        break lab9;
+                                    }
+                                    // ], line 37
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 252)))
+                                    {
+                                        break lab9;
+                                    }
+                                    // <-, line 37
+                                    slice_from("U");
+                                    break lab8;
+                                } while (false);
+                                cursor = v_6;
+                                // (, line 38
+                                // literal, line 38
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab7;
+                                }
+                                // ], line 38
+                                ket = cursor;
+                                if (!(in_grouping(g_v, 97, 252)))
+                                {
+                                    break lab7;
+                                }
+                                // <-, line 38
+                                slice_from("Y");
+                            } while (false);
+                            cursor = v_5;
+                            break golab6;
+                        } while (false);
+                        cursor = v_5;
+                        if (cursor >= limit)
+                        {
+                            break lab5;
+                        }
+                        cursor++;
+                    }
+                    continue replab4;
+                } while (false);
+                cursor = v_4;
+                break replab4;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            // (, line 42
+            I_p1 = limit;
+            I_p2 = limit;
+            // test, line 47
+            v_1 = cursor;
+            // (, line 47
+            // hop, line 47
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // setmark x, line 47
+            I_x = cursor;
+            cursor = v_1;
+            // gopast, line 49
+            golab0: while(true)
+            {
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 252)))
+                    {
+                        break lab1;
+                    }
+                    break golab0;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 49
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 252)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 49
+            I_p1 = cursor;
+            // try, line 50
+            lab4: do {
+                // (, line 50
+                if (!(I_p1 < I_x))
+                {
+                    break lab4;
+                }
+                I_p1 = I_x;
+            } while (false);
+            // gopast, line 51
+            golab5: while(true)
+            {
+                lab6: do {
+                    if (!(in_grouping(g_v, 97, 252)))
+                    {
+                        break lab6;
+                    }
+                    break golab5;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 51
+            golab7: while(true)
+            {
+                lab8: do {
+                    if (!(out_grouping(g_v, 97, 252)))
+                    {
+                        break lab8;
+                    }
+                    break golab7;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p2, line 51
+            I_p2 = cursor;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 55
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 55
+                    // [, line 57
+                    bra = cursor;
+                    // substring, line 57
+                    among_var = find_among(a_0, 6);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 57
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 58
+                            // <-, line 58
+                            slice_from("y");
+                            break;
+                        case 2:
+                            // (, line 59
+                            // <-, line 59
+                            slice_from("u");
+                            break;
+                        case 3:
+                            // (, line 60
+                            // <-, line 60
+                            slice_from("a");
+                            break;
+                        case 4:
+                            // (, line 61
+                            // <-, line 61
+                            slice_from("o");
+                            break;
+                        case 5:
+                            // (, line 62
+                            // <-, line 62
+                            slice_from("u");
+                            break;
+                        case 6:
+                            // (, line 63
+                            // next, line 63
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            // (, line 73
+            // do, line 74
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 74
+                // [, line 75
+                ket = cursor;
+                // substring, line 75
+                among_var = find_among_b(a_1, 7);
+                if (among_var == 0)
+                {
+                    break lab0;
+                }
+                // ], line 75
+                bra = cursor;
+                // call R1, line 75
+                if (!r_R1())
+                {
+                    break lab0;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab0;
+                    case 1:
+                        // (, line 77
+                        // delete, line 77
+                        slice_del();
+                        break;
+                    case 2:
+                        // (, line 80
+                        if (!(in_grouping_b(g_s_ending, 98, 116)))
+                        {
+                            break lab0;
+                        }
+                        // delete, line 80
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // do, line 84
+            v_2 = limit - cursor;
+            lab1: do {
+                // (, line 84
+                // [, line 85
+                ket = cursor;
+                // substring, line 85
+                among_var = find_among_b(a_2, 4);
+                if (among_var == 0)
+                {
+                    break lab1;
+                }
+                // ], line 85
+                bra = cursor;
+                // call R1, line 85
+                if (!r_R1())
+                {
+                    break lab1;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab1;
+                    case 1:
+                        // (, line 87
+                        // delete, line 87
+                        slice_del();
+                        break;
+                    case 2:
+                        // (, line 90
+                        if (!(in_grouping_b(g_st_ending, 98, 116)))
+                        {
+                            break lab1;
+                        }
+                        // hop, line 90
+                        {
+                            int c = cursor - 3;
+                            if (limit_backward > c || c > limit)
+                            {
+                                break lab1;
+                            }
+                            cursor = c;
+                        }
+                        // delete, line 90
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 94
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 94
+                // [, line 95
+                ket = cursor;
+                // substring, line 95
+                among_var = find_among_b(a_4, 8);
+                if (among_var == 0)
+                {
+                    break lab2;
+                }
+                // ], line 95
+                bra = cursor;
+                // call R2, line 95
+                if (!r_R2())
+                {
+                    break lab2;
+                }
+                switch(among_var) {
+                    case 0:
+                        break lab2;
+                    case 1:
+                        // (, line 97
+                        // delete, line 97
+                        slice_del();
+                        // try, line 98
+                        v_4 = limit - cursor;
+                        lab3: do {
+                            // (, line 98
+                            // [, line 98
+                            ket = cursor;
+                            // literal, line 98
+                            if (!(eq_s_b(2, "ig")))
+                            {
+                                cursor = limit - v_4;
+                                break lab3;
+                            }
+                            // ], line 98
+                            bra = cursor;
+                            // not, line 98
+                            {
+                                v_5 = limit - cursor;
+                                lab4: do {
+                                    // literal, line 98
+                                    if (!(eq_s_b(1, "e")))
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor = limit - v_4;
+                                    break lab3;
+                                } while (false);
+                                cursor = limit - v_5;
+                            }
+                            // call R2, line 98
+                            if (!r_R2())
+                            {
+                                cursor = limit - v_4;
+                                break lab3;
+                            }
+                            // delete, line 98
+                            slice_del();
+                        } while (false);
+                        break;
+                    case 2:
+                        // (, line 101
+                        // not, line 101
+                        {
+                            v_6 = limit - cursor;
+                            lab5: do {
+                                // literal, line 101
+                                if (!(eq_s_b(1, "e")))
+                                {
+                                    break lab5;
+                                }
+                                break lab2;
+                            } while (false);
+                            cursor = limit - v_6;
+                        }
+                        // delete, line 101
+                        slice_del();
+                        break;
+                    case 3:
+                        // (, line 104
+                        // delete, line 104
+                        slice_del();
+                        // try, line 105
+                        v_7 = limit - cursor;
+                        lab6: do {
+                            // (, line 105
+                            // [, line 106
+                            ket = cursor;
+                            // or, line 106
+                            lab7: do {
+                                v_8 = limit - cursor;
+                                lab8: do {
+                                    // literal, line 106
+                                    if (!(eq_s_b(2, "er")))
+                                    {
+                                        break lab8;
+                                    }
+                                    break lab7;
+                                } while (false);
+                                cursor = limit - v_8;
+                                // literal, line 106
+                                if (!(eq_s_b(2, "en")))
+                                {
+                                    cursor = limit - v_7;
+                                    break lab6;
+                                }
+                            } while (false);
+                            // ], line 106
+                            bra = cursor;
+                            // call R1, line 106
+                            if (!r_R1())
+                            {
+                                cursor = limit - v_7;
+                                break lab6;
+                            }
+                            // delete, line 106
+                            slice_del();
+                        } while (false);
+                        break;
+                    case 4:
+                        // (, line 110
+                        // delete, line 110
+                        slice_del();
+                        // try, line 111
+                        v_9 = limit - cursor;
+                        lab9: do {
+                            // (, line 111
+                            // [, line 112
+                            ket = cursor;
+                            // substring, line 112
+                            among_var = find_among_b(a_3, 2);
+                            if (among_var == 0)
+                            {
+                                cursor = limit - v_9;
+                                break lab9;
+                            }
+                            // ], line 112
+                            bra = cursor;
+                            // call R2, line 112
+                            if (!r_R2())
+                            {
+                                cursor = limit - v_9;
+                                break lab9;
+                            }
+                            switch(among_var) {
+                                case 0:
+                                    cursor = limit - v_9;
+                                    break lab9;
+                                case 1:
+                                    // (, line 114
+                                    // delete, line 114
+                                    slice_del();
+                                    break;
+                            }
+                        } while (false);
+                        break;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 124
+            // do, line 125
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 125
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 126
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 126
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 127
+            limit_backward = cursor; cursor = limit;
+            // do, line 128
+            v_3 = limit - cursor;
+            lab2: do {
+                // call standard_suffix, line 128
+                if (!r_standard_suffix())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            cursor = limit_backward;            // do, line 129
+            v_4 = cursor;
+            lab3: do {
+                // call postlude, line 129
+                if (!r_postlude())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = v_4;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/HungarianStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/HungarianStemmer.java
new file mode 100644
index 0000000..6aad5e5
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/HungarianStemmer.java
@@ -0,0 +1,1158 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class HungarianStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "cs", -1, -1, "", this),
+            new Among ( "dzs", -1, -1, "", this),
+            new Among ( "gy", -1, -1, "", this),
+            new Among ( "ly", -1, -1, "", this),
+            new Among ( "ny", -1, -1, "", this),
+            new Among ( "sz", -1, -1, "", this),
+            new Among ( "ty", -1, -1, "", this),
+            new Among ( "zs", -1, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "\u00E1", -1, 1, "", this),
+            new Among ( "\u00E9", -1, 2, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "bb", -1, -1, "", this),
+            new Among ( "cc", -1, -1, "", this),
+            new Among ( "dd", -1, -1, "", this),
+            new Among ( "ff", -1, -1, "", this),
+            new Among ( "gg", -1, -1, "", this),
+            new Among ( "jj", -1, -1, "", this),
+            new Among ( "kk", -1, -1, "", this),
+            new Among ( "ll", -1, -1, "", this),
+            new Among ( "mm", -1, -1, "", this),
+            new Among ( "nn", -1, -1, "", this),
+            new Among ( "pp", -1, -1, "", this),
+            new Among ( "rr", -1, -1, "", this),
+            new Among ( "ccs", -1, -1, "", this),
+            new Among ( "ss", -1, -1, "", this),
+            new Among ( "zzs", -1, -1, "", this),
+            new Among ( "tt", -1, -1, "", this),
+            new Among ( "vv", -1, -1, "", this),
+            new Among ( "ggy", -1, -1, "", this),
+            new Among ( "lly", -1, -1, "", this),
+            new Among ( "nny", -1, -1, "", this),
+            new Among ( "tty", -1, -1, "", this),
+            new Among ( "ssz", -1, -1, "", this),
+            new Among ( "zz", -1, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "al", -1, 1, "", this),
+            new Among ( "el", -1, 2, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ba", -1, -1, "", this),
+            new Among ( "ra", -1, -1, "", this),
+            new Among ( "be", -1, -1, "", this),
+            new Among ( "re", -1, -1, "", this),
+            new Among ( "ig", -1, -1, "", this),
+            new Among ( "nak", -1, -1, "", this),
+            new Among ( "nek", -1, -1, "", this),
+            new Among ( "val", -1, -1, "", this),
+            new Among ( "vel", -1, -1, "", this),
+            new Among ( "ul", -1, -1, "", this),
+            new Among ( "n\u00E1l", -1, -1, "", this),
+            new Among ( "n\u00E9l", -1, -1, "", this),
+            new Among ( "b\u00F3l", -1, -1, "", this),
+            new Among ( "r\u00F3l", -1, -1, "", this),
+            new Among ( "t\u00F3l", -1, -1, "", this),
+            new Among ( "b\u00F5l", -1, -1, "", this),
+            new Among ( "r\u00F5l", -1, -1, "", this),
+            new Among ( "t\u00F5l", -1, -1, "", this),
+            new Among ( "\u00FCl", -1, -1, "", this),
+            new Among ( "n", -1, -1, "", this),
+            new Among ( "an", 19, -1, "", this),
+            new Among ( "ban", 20, -1, "", this),
+            new Among ( "en", 19, -1, "", this),
+            new Among ( "ben", 22, -1, "", this),
+            new Among ( "k\u00E9ppen", 22, -1, "", this),
+            new Among ( "on", 19, -1, "", this),
+            new Among ( "\u00F6n", 19, -1, "", this),
+            new Among ( "k\u00E9pp", -1, -1, "", this),
+            new Among ( "kor", -1, -1, "", this),
+            new Among ( "t", -1, -1, "", this),
+            new Among ( "at", 29, -1, "", this),
+            new Among ( "et", 29, -1, "", this),
+            new Among ( "k\u00E9nt", 29, -1, "", this),
+            new Among ( "ank\u00E9nt", 32, -1, "", this),
+            new Among ( "enk\u00E9nt", 32, -1, "", this),
+            new Among ( "onk\u00E9nt", 32, -1, "", this),
+            new Among ( "ot", 29, -1, "", this),
+            new Among ( "\u00E9rt", 29, -1, "", this),
+            new Among ( "\u00F6t", 29, -1, "", this),
+            new Among ( "hez", -1, -1, "", this),
+            new Among ( "hoz", -1, -1, "", this),
+            new Among ( "h\u00F6z", -1, -1, "", this),
+            new Among ( "v\u00E1", -1, -1, "", this),
+            new Among ( "v\u00E9", -1, -1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "\u00E1n", -1, 2, "", this),
+            new Among ( "\u00E9n", -1, 1, "", this),
+            new Among ( "\u00E1nk\u00E9nt", -1, 3, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "stul", -1, 2, "", this),
+            new Among ( "astul", 0, 1, "", this),
+            new Among ( "\u00E1stul", 0, 3, "", this),
+            new Among ( "st\u00FCl", -1, 2, "", this),
+            new Among ( "est\u00FCl", 3, 1, "", this),
+            new Among ( "\u00E9st\u00FCl", 3, 4, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "\u00E1", -1, 1, "", this),
+            new Among ( "\u00E9", -1, 2, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "k", -1, 7, "", this),
+            new Among ( "ak", 0, 4, "", this),
+            new Among ( "ek", 0, 6, "", this),
+            new Among ( "ok", 0, 5, "", this),
+            new Among ( "\u00E1k", 0, 1, "", this),
+            new Among ( "\u00E9k", 0, 2, "", this),
+            new Among ( "\u00F6k", 0, 3, "", this)
+        };
+
+        private Among a_9[] = {
+            new Among ( "\u00E9i", -1, 7, "", this),
+            new Among ( "\u00E1\u00E9i", 0, 6, "", this),
+            new Among ( "\u00E9\u00E9i", 0, 5, "", this),
+            new Among ( "\u00E9", -1, 9, "", this),
+            new Among ( "k\u00E9", 3, 4, "", this),
+            new Among ( "ak\u00E9", 4, 1, "", this),
+            new Among ( "ek\u00E9", 4, 1, "", this),
+            new Among ( "ok\u00E9", 4, 1, "", this),
+            new Among ( "\u00E1k\u00E9", 4, 3, "", this),
+            new Among ( "\u00E9k\u00E9", 4, 2, "", this),
+            new Among ( "\u00F6k\u00E9", 4, 1, "", this),
+            new Among ( "\u00E9\u00E9", 3, 8, "", this)
+        };
+
+        private Among a_10[] = {
+            new Among ( "a", -1, 18, "", this),
+            new Among ( "ja", 0, 17, "", this),
+            new Among ( "d", -1, 16, "", this),
+            new Among ( "ad", 2, 13, "", this),
+            new Among ( "ed", 2, 13, "", this),
+            new Among ( "od", 2, 13, "", this),
+            new Among ( "\u00E1d", 2, 14, "", this),
+            new Among ( "\u00E9d", 2, 15, "", this),
+            new Among ( "\u00F6d", 2, 13, "", this),
+            new Among ( "e", -1, 18, "", this),
+            new Among ( "je", 9, 17, "", this),
+            new Among ( "nk", -1, 4, "", this),
+            new Among ( "unk", 11, 1, "", this),
+            new Among ( "\u00E1nk", 11, 2, "", this),
+            new Among ( "\u00E9nk", 11, 3, "", this),
+            new Among ( "\u00FCnk", 11, 1, "", this),
+            new Among ( "uk", -1, 8, "", this),
+            new Among ( "juk", 16, 7, "", this),
+            new Among ( "\u00E1juk", 17, 5, "", this),
+            new Among ( "\u00FCk", -1, 8, "", this),
+            new Among ( "j\u00FCk", 19, 7, "", this),
+            new Among ( "\u00E9j\u00FCk", 20, 6, "", this),
+            new Among ( "m", -1, 12, "", this),
+            new Among ( "am", 22, 9, "", this),
+            new Among ( "em", 22, 9, "", this),
+            new Among ( "om", 22, 9, "", this),
+            new Among ( "\u00E1m", 22, 10, "", this),
+            new Among ( "\u00E9m", 22, 11, "", this),
+            new Among ( "o", -1, 18, "", this),
+            new Among ( "\u00E1", -1, 19, "", this),
+            new Among ( "\u00E9", -1, 20, "", this)
+        };
+
+        private Among a_11[] = {
+            new Among ( "id", -1, 10, "", this),
+            new Among ( "aid", 0, 9, "", this),
+            new Among ( "jaid", 1, 6, "", this),
+            new Among ( "eid", 0, 9, "", this),
+            new Among ( "jeid", 3, 6, "", this),
+            new Among ( "\u00E1id", 0, 7, "", this),
+            new Among ( "\u00E9id", 0, 8, "", this),
+            new Among ( "i", -1, 15, "", this),
+            new Among ( "ai", 7, 14, "", this),
+            new Among ( "jai", 8, 11, "", this),
+            new Among ( "ei", 7, 14, "", this),
+            new Among ( "jei", 10, 11, "", this),
+            new Among ( "\u00E1i", 7, 12, "", this),
+            new Among ( "\u00E9i", 7, 13, "", this),
+            new Among ( "itek", -1, 24, "", this),
+            new Among ( "eitek", 14, 21, "", this),
+            new Among ( "jeitek", 15, 20, "", this),
+            new Among ( "\u00E9itek", 14, 23, "", this),
+            new Among ( "ik", -1, 29, "", this),
+            new Among ( "aik", 18, 26, "", this),
+            new Among ( "jaik", 19, 25, "", this),
+            new Among ( "eik", 18, 26, "", this),
+            new Among ( "jeik", 21, 25, "", this),
+            new Among ( "\u00E1ik", 18, 27, "", this),
+            new Among ( "\u00E9ik", 18, 28, "", this),
+            new Among ( "ink", -1, 20, "", this),
+            new Among ( "aink", 25, 17, "", this),
+            new Among ( "jaink", 26, 16, "", this),
+            new Among ( "eink", 25, 17, "", this),
+            new Among ( "jeink", 28, 16, "", this),
+            new Among ( "\u00E1ink", 25, 18, "", this),
+            new Among ( "\u00E9ink", 25, 19, "", this),
+            new Among ( "aitok", -1, 21, "", this),
+            new Among ( "jaitok", 32, 20, "", this),
+            new Among ( "\u00E1itok", -1, 22, "", this),
+            new Among ( "im", -1, 5, "", this),
+            new Among ( "aim", 35, 4, "", this),
+            new Among ( "jaim", 36, 1, "", this),
+            new Among ( "eim", 35, 4, "", this),
+            new Among ( "jeim", 38, 1, "", this),
+            new Among ( "\u00E1im", 35, 2, "", this),
+            new Among ( "\u00E9im", 35, 3, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 52, 14 };
+
+        private int I_p1;
+
+        private void copy_from(HungarianStemmer other) {
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 44
+            I_p1 = limit;
+            // or, line 51
+            lab0: do {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 48
+                    if (!(in_grouping(g_v, 97, 252)))
+                    {
+                        break lab1;
+                    }
+                    // goto, line 48
+                    golab2: while(true)
+                    {
+                        v_2 = cursor;
+                        lab3: do {
+                            if (!(out_grouping(g_v, 97, 252)))
+                            {
+                                break lab3;
+                            }
+                            cursor = v_2;
+                            break golab2;
+                        } while (false);
+                        cursor = v_2;
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    // or, line 49
+                    lab4: do {
+                        v_3 = cursor;
+                        lab5: do {
+                            // among, line 49
+                            if (find_among(a_0, 8) == 0)
+                            {
+                                break lab5;
+                            }
+                            break lab4;
+                        } while (false);
+                        cursor = v_3;
+                        // next, line 49
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    } while (false);
+                    // setmark p1, line 50
+                    I_p1 = cursor;
+                    break lab0;
+                } while (false);
+                cursor = v_1;
+                // (, line 53
+                if (!(out_grouping(g_v, 97, 252)))
+                {
+                    return false;
+                }
+                // gopast, line 53
+                golab6: while(true)
+                {
+                    lab7: do {
+                        if (!(in_grouping(g_v, 97, 252)))
+                        {
+                            break lab7;
+                        }
+                        break golab6;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        return false;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 53
+                I_p1 = cursor;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_v_ending() {
+            int among_var;
+            // (, line 60
+            // [, line 61
+            ket = cursor;
+            // substring, line 61
+            among_var = find_among_b(a_1, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 61
+            bra = cursor;
+            // call R1, line 61
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 62
+                    // <-, line 62
+                    slice_from("a");
+                    break;
+                case 2:
+                    // (, line 63
+                    // <-, line 63
+                    slice_from("e");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_double() {
+            int v_1;
+            // (, line 67
+            // test, line 68
+            v_1 = limit - cursor;
+            // among, line 68
+            if (find_among_b(a_2, 23) == 0)
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_undouble() {
+            // (, line 72
+            // next, line 73
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // [, line 73
+            ket = cursor;
+            // hop, line 73
+            {
+                int c = cursor - 1;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // ], line 73
+            bra = cursor;
+            // delete, line 73
+            slice_del();
+            return true;
+        }
+
+        private boolean r_instrum() {
+            int among_var;
+            // (, line 76
+            // [, line 77
+            ket = cursor;
+            // substring, line 77
+            among_var = find_among_b(a_3, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 77
+            bra = cursor;
+            // call R1, line 77
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 78
+                    // call double, line 78
+                    if (!r_double())
+                    {
+                        return false;
+                    }
+                    break;
+                case 2:
+                    // (, line 79
+                    // call double, line 79
+                    if (!r_double())
+                    {
+                        return false;
+                    }
+                    break;
+            }
+            // delete, line 81
+            slice_del();
+            // call undouble, line 82
+            if (!r_undouble())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_case() {
+            // (, line 86
+            // [, line 87
+            ket = cursor;
+            // substring, line 87
+            if (find_among_b(a_4, 44) == 0)
+            {
+                return false;
+            }
+            // ], line 87
+            bra = cursor;
+            // call R1, line 87
+            if (!r_R1())
+            {
+                return false;
+            }
+            // delete, line 111
+            slice_del();
+            // call v_ending, line 112
+            if (!r_v_ending())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_case_special() {
+            int among_var;
+            // (, line 115
+            // [, line 116
+            ket = cursor;
+            // substring, line 116
+            among_var = find_among_b(a_5, 3);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 116
+            bra = cursor;
+            // call R1, line 116
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 117
+                    // <-, line 117
+                    slice_from("e");
+                    break;
+                case 2:
+                    // (, line 118
+                    // <-, line 118
+                    slice_from("a");
+                    break;
+                case 3:
+                    // (, line 119
+                    // <-, line 119
+                    slice_from("a");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_case_other() {
+            int among_var;
+            // (, line 123
+            // [, line 124
+            ket = cursor;
+            // substring, line 124
+            among_var = find_among_b(a_6, 6);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 124
+            bra = cursor;
+            // call R1, line 124
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 125
+                    // delete, line 125
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 126
+                    // delete, line 126
+                    slice_del();
+                    break;
+                case 3:
+                    // (, line 127
+                    // <-, line 127
+                    slice_from("a");
+                    break;
+                case 4:
+                    // (, line 128
+                    // <-, line 128
+                    slice_from("e");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_factive() {
+            int among_var;
+            // (, line 132
+            // [, line 133
+            ket = cursor;
+            // substring, line 133
+            among_var = find_among_b(a_7, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 133
+            bra = cursor;
+            // call R1, line 133
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 134
+                    // call double, line 134
+                    if (!r_double())
+                    {
+                        return false;
+                    }
+                    break;
+                case 2:
+                    // (, line 135
+                    // call double, line 135
+                    if (!r_double())
+                    {
+                        return false;
+                    }
+                    break;
+            }
+            // delete, line 137
+            slice_del();
+            // call undouble, line 138
+            if (!r_undouble())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_plural() {
+            int among_var;
+            // (, line 141
+            // [, line 142
+            ket = cursor;
+            // substring, line 142
+            among_var = find_among_b(a_8, 7);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 142
+            bra = cursor;
+            // call R1, line 142
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 143
+                    // <-, line 143
+                    slice_from("a");
+                    break;
+                case 2:
+                    // (, line 144
+                    // <-, line 144
+                    slice_from("e");
+                    break;
+                case 3:
+                    // (, line 145
+                    // delete, line 145
+                    slice_del();
+                    break;
+                case 4:
+                    // (, line 146
+                    // delete, line 146
+                    slice_del();
+                    break;
+                case 5:
+                    // (, line 147
+                    // delete, line 147
+                    slice_del();
+                    break;
+                case 6:
+                    // (, line 148
+                    // delete, line 148
+                    slice_del();
+                    break;
+                case 7:
+                    // (, line 149
+                    // delete, line 149
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_owned() {
+            int among_var;
+            // (, line 153
+            // [, line 154
+            ket = cursor;
+            // substring, line 154
+            among_var = find_among_b(a_9, 12);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 154
+            bra = cursor;
+            // call R1, line 154
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 155
+                    // delete, line 155
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 156
+                    // <-, line 156
+                    slice_from("e");
+                    break;
+                case 3:
+                    // (, line 157
+                    // <-, line 157
+                    slice_from("a");
+                    break;
+                case 4:
+                    // (, line 158
+                    // delete, line 158
+                    slice_del();
+                    break;
+                case 5:
+                    // (, line 159
+                    // <-, line 159
+                    slice_from("e");
+                    break;
+                case 6:
+                    // (, line 160
+                    // <-, line 160
+                    slice_from("a");
+                    break;
+                case 7:
+                    // (, line 161
+                    // delete, line 161
+                    slice_del();
+                    break;
+                case 8:
+                    // (, line 162
+                    // <-, line 162
+                    slice_from("e");
+                    break;
+                case 9:
+                    // (, line 163
+                    // delete, line 163
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_sing_owner() {
+            int among_var;
+            // (, line 167
+            // [, line 168
+            ket = cursor;
+            // substring, line 168
+            among_var = find_among_b(a_10, 31);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 168
+            bra = cursor;
+            // call R1, line 168
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 169
+                    // delete, line 169
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 170
+                    // <-, line 170
+                    slice_from("a");
+                    break;
+                case 3:
+                    // (, line 171
+                    // <-, line 171
+                    slice_from("e");
+                    break;
+                case 4:
+                    // (, line 172
+                    // delete, line 172
+                    slice_del();
+                    break;
+                case 5:
+                    // (, line 173
+                    // <-, line 173
+                    slice_from("a");
+                    break;
+                case 6:
+                    // (, line 174
+                    // <-, line 174
+                    slice_from("e");
+                    break;
+                case 7:
+                    // (, line 175
+                    // delete, line 175
+                    slice_del();
+                    break;
+                case 8:
+                    // (, line 176
+                    // delete, line 176
+                    slice_del();
+                    break;
+                case 9:
+                    // (, line 177
+                    // delete, line 177
+                    slice_del();
+                    break;
+                case 10:
+                    // (, line 178
+                    // <-, line 178
+                    slice_from("a");
+                    break;
+                case 11:
+                    // (, line 179
+                    // <-, line 179
+                    slice_from("e");
+                    break;
+                case 12:
+                    // (, line 180
+                    // delete, line 180
+                    slice_del();
+                    break;
+                case 13:
+                    // (, line 181
+                    // delete, line 181
+                    slice_del();
+                    break;
+                case 14:
+                    // (, line 182
+                    // <-, line 182
+                    slice_from("a");
+                    break;
+                case 15:
+                    // (, line 183
+                    // <-, line 183
+                    slice_from("e");
+                    break;
+                case 16:
+                    // (, line 184
+                    // delete, line 184
+                    slice_del();
+                    break;
+                case 17:
+                    // (, line 185
+                    // delete, line 185
+                    slice_del();
+                    break;
+                case 18:
+                    // (, line 186
+                    // delete, line 186
+                    slice_del();
+                    break;
+                case 19:
+                    // (, line 187
+                    // <-, line 187
+                    slice_from("a");
+                    break;
+                case 20:
+                    // (, line 188
+                    // <-, line 188
+                    slice_from("e");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_plur_owner() {
+            int among_var;
+            // (, line 192
+            // [, line 193
+            ket = cursor;
+            // substring, line 193
+            among_var = find_among_b(a_11, 42);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 193
+            bra = cursor;
+            // call R1, line 193
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 194
+                    // delete, line 194
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 195
+                    // <-, line 195
+                    slice_from("a");
+                    break;
+                case 3:
+                    // (, line 196
+                    // <-, line 196
+                    slice_from("e");
+                    break;
+                case 4:
+                    // (, line 197
+                    // delete, line 197
+                    slice_del();
+                    break;
+                case 5:
+                    // (, line 198
+                    // delete, line 198
+                    slice_del();
+                    break;
+                case 6:
+                    // (, line 199
+                    // delete, line 199
+                    slice_del();
+                    break;
+                case 7:
+                    // (, line 200
+                    // <-, line 200
+                    slice_from("a");
+                    break;
+                case 8:
+                    // (, line 201
+                    // <-, line 201
+                    slice_from("e");
+                    break;
+                case 9:
+                    // (, line 202
+                    // delete, line 202
+                    slice_del();
+                    break;
+                case 10:
+                    // (, line 203
+                    // delete, line 203
+                    slice_del();
+                    break;
+                case 11:
+                    // (, line 204
+                    // delete, line 204
+                    slice_del();
+                    break;
+                case 12:
+                    // (, line 205
+                    // <-, line 205
+                    slice_from("a");
+                    break;
+                case 13:
+                    // (, line 206
+                    // <-, line 206
+                    slice_from("e");
+                    break;
+                case 14:
+                    // (, line 207
+                    // delete, line 207
+                    slice_del();
+                    break;
+                case 15:
+                    // (, line 208
+                    // delete, line 208
+                    slice_del();
+                    break;
+                case 16:
+                    // (, line 209
+                    // delete, line 209
+                    slice_del();
+                    break;
+                case 17:
+                    // (, line 210
+                    // delete, line 210
+                    slice_del();
+                    break;
+                case 18:
+                    // (, line 211
+                    // <-, line 211
+                    slice_from("a");
+                    break;
+                case 19:
+                    // (, line 212
+                    // <-, line 212
+                    slice_from("e");
+                    break;
+                case 20:
+                    // (, line 214
+                    // delete, line 214
+                    slice_del();
+                    break;
+                case 21:
+                    // (, line 215
+                    // delete, line 215
+                    slice_del();
+                    break;
+                case 22:
+                    // (, line 216
+                    // <-, line 216
+                    slice_from("a");
+                    break;
+                case 23:
+                    // (, line 217
+                    // <-, line 217
+                    slice_from("e");
+                    break;
+                case 24:
+                    // (, line 218
+                    // delete, line 218
+                    slice_del();
+                    break;
+                case 25:
+                    // (, line 219
+                    // delete, line 219
+                    slice_del();
+                    break;
+                case 26:
+                    // (, line 220
+                    // delete, line 220
+                    slice_del();
+                    break;
+                case 27:
+                    // (, line 221
+                    // <-, line 221
+                    slice_from("a");
+                    break;
+                case 28:
+                    // (, line 222
+                    // <-, line 222
+                    slice_from("e");
+                    break;
+                case 29:
+                    // (, line 223
+                    // delete, line 223
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            // (, line 228
+            // do, line 229
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 229
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 230
+            limit_backward = cursor; cursor = limit;
+            // (, line 230
+            // do, line 231
+            v_2 = limit - cursor;
+            lab1: do {
+                // call instrum, line 231
+                if (!r_instrum())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 232
+            v_3 = limit - cursor;
+            lab2: do {
+                // call case, line 232
+                if (!r_case())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 233
+            v_4 = limit - cursor;
+            lab3: do {
+                // call case_special, line 233
+                if (!r_case_special())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            // do, line 234
+            v_5 = limit - cursor;
+            lab4: do {
+                // call case_other, line 234
+                if (!r_case_other())
+                {
+                    break lab4;
+                }
+            } while (false);
+            cursor = limit - v_5;
+            // do, line 235
+            v_6 = limit - cursor;
+            lab5: do {
+                // call factive, line 235
+                if (!r_factive())
+                {
+                    break lab5;
+                }
+            } while (false);
+            cursor = limit - v_6;
+            // do, line 236
+            v_7 = limit - cursor;
+            lab6: do {
+                // call owned, line 236
+                if (!r_owned())
+                {
+                    break lab6;
+                }
+            } while (false);
+            cursor = limit - v_7;
+            // do, line 237
+            v_8 = limit - cursor;
+            lab7: do {
+                // call sing_owner, line 237
+                if (!r_sing_owner())
+                {
+                    break lab7;
+                }
+            } while (false);
+            cursor = limit - v_8;
+            // do, line 238
+            v_9 = limit - cursor;
+            lab8: do {
+                // call plur_owner, line 238
+                if (!r_plur_owner())
+                {
+                    break lab8;
+                }
+            } while (false);
+            cursor = limit - v_9;
+            // do, line 239
+            v_10 = limit - cursor;
+            lab9: do {
+                // call plural, line 239
+                if (!r_plural())
+                {
+                    break lab9;
+                }
+            } while (false);
+            cursor = limit - v_10;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/ItalianStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/ItalianStemmer.java
new file mode 100644
index 0000000..d352b86
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/ItalianStemmer.java
@@ -0,0 +1,1180 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class ItalianStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 7, "", this),
+            new Among ( "qu", 0, 6, "", this),
+            new Among ( "\u00E1", 0, 1, "", this),
+            new Among ( "\u00E9", 0, 2, "", this),
+            new Among ( "\u00ED", 0, 3, "", this),
+            new Among ( "\u00F3", 0, 4, "", this),
+            new Among ( "\u00FA", 0, 5, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "I", 0, 1, "", this),
+            new Among ( "U", 0, 2, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "la", -1, -1, "", this),
+            new Among ( "cela", 0, -1, "", this),
+            new Among ( "gliela", 0, -1, "", this),
+            new Among ( "mela", 0, -1, "", this),
+            new Among ( "tela", 0, -1, "", this),
+            new Among ( "vela", 0, -1, "", this),
+            new Among ( "le", -1, -1, "", this),
+            new Among ( "cele", 6, -1, "", this),
+            new Among ( "gliele", 6, -1, "", this),
+            new Among ( "mele", 6, -1, "", this),
+            new Among ( "tele", 6, -1, "", this),
+            new Among ( "vele", 6, -1, "", this),
+            new Among ( "ne", -1, -1, "", this),
+            new Among ( "cene", 12, -1, "", this),
+            new Among ( "gliene", 12, -1, "", this),
+            new Among ( "mene", 12, -1, "", this),
+            new Among ( "sene", 12, -1, "", this),
+            new Among ( "tene", 12, -1, "", this),
+            new Among ( "vene", 12, -1, "", this),
+            new Among ( "ci", -1, -1, "", this),
+            new Among ( "li", -1, -1, "", this),
+            new Among ( "celi", 20, -1, "", this),
+            new Among ( "glieli", 20, -1, "", this),
+            new Among ( "meli", 20, -1, "", this),
+            new Among ( "teli", 20, -1, "", this),
+            new Among ( "veli", 20, -1, "", this),
+            new Among ( "gli", 20, -1, "", this),
+            new Among ( "mi", -1, -1, "", this),
+            new Among ( "si", -1, -1, "", this),
+            new Among ( "ti", -1, -1, "", this),
+            new Among ( "vi", -1, -1, "", this),
+            new Among ( "lo", -1, -1, "", this),
+            new Among ( "celo", 31, -1, "", this),
+            new Among ( "glielo", 31, -1, "", this),
+            new Among ( "melo", 31, -1, "", this),
+            new Among ( "telo", 31, -1, "", this),
+            new Among ( "velo", 31, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ando", -1, 1, "", this),
+            new Among ( "endo", -1, 1, "", this),
+            new Among ( "ar", -1, 2, "", this),
+            new Among ( "er", -1, 2, "", this),
+            new Among ( "ir", -1, 2, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ic", -1, -1, "", this),
+            new Among ( "abil", -1, -1, "", this),
+            new Among ( "os", -1, -1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "abil", -1, 1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "ica", -1, 1, "", this),
+            new Among ( "logia", -1, 3, "", this),
+            new Among ( "osa", -1, 1, "", this),
+            new Among ( "ista", -1, 1, "", this),
+            new Among ( "iva", -1, 9, "", this),
+            new Among ( "anza", -1, 1, "", this),
+            new Among ( "enza", -1, 5, "", this),
+            new Among ( "ice", -1, 1, "", this),
+            new Among ( "atrice", 7, 1, "", this),
+            new Among ( "iche", -1, 1, "", this),
+            new Among ( "logie", -1, 3, "", this),
+            new Among ( "abile", -1, 1, "", this),
+            new Among ( "ibile", -1, 1, "", this),
+            new Among ( "usione", -1, 4, "", this),
+            new Among ( "azione", -1, 2, "", this),
+            new Among ( "uzione", -1, 4, "", this),
+            new Among ( "atore", -1, 2, "", this),
+            new Among ( "ose", -1, 1, "", this),
+            new Among ( "ante", -1, 1, "", this),
+            new Among ( "mente", -1, 1, "", this),
+            new Among ( "amente", 19, 7, "", this),
+            new Among ( "iste", -1, 1, "", this),
+            new Among ( "ive", -1, 9, "", this),
+            new Among ( "anze", -1, 1, "", this),
+            new Among ( "enze", -1, 5, "", this),
+            new Among ( "ici", -1, 1, "", this),
+            new Among ( "atrici", 25, 1, "", this),
+            new Among ( "ichi", -1, 1, "", this),
+            new Among ( "abili", -1, 1, "", this),
+            new Among ( "ibili", -1, 1, "", this),
+            new Among ( "ismi", -1, 1, "", this),
+            new Among ( "usioni", -1, 4, "", this),
+            new Among ( "azioni", -1, 2, "", this),
+            new Among ( "uzioni", -1, 4, "", this),
+            new Among ( "atori", -1, 2, "", this),
+            new Among ( "osi", -1, 1, "", this),
+            new Among ( "anti", -1, 1, "", this),
+            new Among ( "amenti", -1, 6, "", this),
+            new Among ( "imenti", -1, 6, "", this),
+            new Among ( "isti", -1, 1, "", this),
+            new Among ( "ivi", -1, 9, "", this),
+            new Among ( "ico", -1, 1, "", this),
+            new Among ( "ismo", -1, 1, "", this),
+            new Among ( "oso", -1, 1, "", this),
+            new Among ( "amento", -1, 6, "", this),
+            new Among ( "imento", -1, 6, "", this),
+            new Among ( "ivo", -1, 9, "", this),
+            new Among ( "it\u00E0", -1, 8, "", this),
+            new Among ( "ist\u00E0", -1, 1, "", this),
+            new Among ( "ist\u00E8", -1, 1, "", this),
+            new Among ( "ist\u00EC", -1, 1, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "isca", -1, 1, "", this),
+            new Among ( "enda", -1, 1, "", this),
+            new Among ( "ata", -1, 1, "", this),
+            new Among ( "ita", -1, 1, "", this),
+            new Among ( "uta", -1, 1, "", this),
+            new Among ( "ava", -1, 1, "", this),
+            new Among ( "eva", -1, 1, "", this),
+            new Among ( "iva", -1, 1, "", this),
+            new Among ( "erebbe", -1, 1, "", this),
+            new Among ( "irebbe", -1, 1, "", this),
+            new Among ( "isce", -1, 1, "", this),
+            new Among ( "ende", -1, 1, "", this),
+            new Among ( "are", -1, 1, "", this),
+            new Among ( "ere", -1, 1, "", this),
+            new Among ( "ire", -1, 1, "", this),
+            new Among ( "asse", -1, 1, "", this),
+            new Among ( "ate", -1, 1, "", this),
+            new Among ( "avate", 16, 1, "", this),
+            new Among ( "evate", 16, 1, "", this),
+            new Among ( "ivate", 16, 1, "", this),
+            new Among ( "ete", -1, 1, "", this),
+            new Among ( "erete", 20, 1, "", this),
+            new Among ( "irete", 20, 1, "", this),
+            new Among ( "ite", -1, 1, "", this),
+            new Among ( "ereste", -1, 1, "", this),
+            new Among ( "ireste", -1, 1, "", this),
+            new Among ( "ute", -1, 1, "", this),
+            new Among ( "erai", -1, 1, "", this),
+            new Among ( "irai", -1, 1, "", this),
+            new Among ( "isci", -1, 1, "", this),
+            new Among ( "endi", -1, 1, "", this),
+            new Among ( "erei", -1, 1, "", this),
+            new Among ( "irei", -1, 1, "", this),
+            new Among ( "assi", -1, 1, "", this),
+            new Among ( "ati", -1, 1, "", this),
+            new Among ( "iti", -1, 1, "", this),
+            new Among ( "eresti", -1, 1, "", this),
+            new Among ( "iresti", -1, 1, "", this),
+            new Among ( "uti", -1, 1, "", this),
+            new Among ( "avi", -1, 1, "", this),
+            new Among ( "evi", -1, 1, "", this),
+            new Among ( "ivi", -1, 1, "", this),
+            new Among ( "isco", -1, 1, "", this),
+            new Among ( "ando", -1, 1, "", this),
+            new Among ( "endo", -1, 1, "", this),
+            new Among ( "Yamo", -1, 1, "", this),
+            new Among ( "iamo", -1, 1, "", this),
+            new Among ( "avamo", -1, 1, "", this),
+            new Among ( "evamo", -1, 1, "", this),
+            new Among ( "ivamo", -1, 1, "", this),
+            new Among ( "eremo", -1, 1, "", this),
+            new Among ( "iremo", -1, 1, "", this),
+            new Among ( "assimo", -1, 1, "", this),
+            new Among ( "ammo", -1, 1, "", this),
+            new Among ( "emmo", -1, 1, "", this),
+            new Among ( "eremmo", 54, 1, "", this),
+            new Among ( "iremmo", 54, 1, "", this),
+            new Among ( "immo", -1, 1, "", this),
+            new Among ( "ano", -1, 1, "", this),
+            new Among ( "iscano", 58, 1, "", this),
+            new Among ( "avano", 58, 1, "", this),
+            new Among ( "evano", 58, 1, "", this),
+            new Among ( "ivano", 58, 1, "", this),
+            new Among ( "eranno", -1, 1, "", this),
+            new Among ( "iranno", -1, 1, "", this),
+            new Among ( "ono", -1, 1, "", this),
+            new Among ( "iscono", 65, 1, "", this),
+            new Among ( "arono", 65, 1, "", this),
+            new Among ( "erono", 65, 1, "", this),
+            new Among ( "irono", 65, 1, "", this),
+            new Among ( "erebbero", -1, 1, "", this),
+            new Among ( "irebbero", -1, 1, "", this),
+            new Among ( "assero", -1, 1, "", this),
+            new Among ( "essero", -1, 1, "", this),
+            new Among ( "issero", -1, 1, "", this),
+            new Among ( "ato", -1, 1, "", this),
+            new Among ( "ito", -1, 1, "", this),
+            new Among ( "uto", -1, 1, "", this),
+            new Among ( "avo", -1, 1, "", this),
+            new Among ( "evo", -1, 1, "", this),
+            new Among ( "ivo", -1, 1, "", this),
+            new Among ( "ar", -1, 1, "", this),
+            new Among ( "ir", -1, 1, "", this),
+            new Among ( "er\u00E0", -1, 1, "", this),
+            new Among ( "ir\u00E0", -1, 1, "", this),
+            new Among ( "er\u00F2", -1, 1, "", this),
+            new Among ( "ir\u00F2", -1, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2, 1 };
+
+        private static final char g_AEIO[] = {17, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 8, 2 };
+
+        private static final char g_CG[] = {17 };
+
+        private int I_p2;
+        private int I_p1;
+        private int I_pV;
+
+        private void copy_from(ItalianStemmer other) {
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 34
+            // test, line 35
+            v_1 = cursor;
+            // repeat, line 35
+            replab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    // (, line 35
+                    // [, line 36
+                    bra = cursor;
+                    // substring, line 36
+                    among_var = find_among(a_0, 7);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 36
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 37
+                            // <-, line 37
+                            slice_from("\u00E0");
+                            break;
+                        case 2:
+                            // (, line 38
+                            // <-, line 38
+                            slice_from("\u00E8");
+                            break;
+                        case 3:
+                            // (, line 39
+                            // <-, line 39
+                            slice_from("\u00EC");
+                            break;
+                        case 4:
+                            // (, line 40
+                            // <-, line 40
+                            slice_from("\u00F2");
+                            break;
+                        case 5:
+                            // (, line 41
+                            // <-, line 41
+                            slice_from("\u00F9");
+                            break;
+                        case 6:
+                            // (, line 42
+                            // <-, line 42
+                            slice_from("qU");
+                            break;
+                        case 7:
+                            // (, line 43
+                            // next, line 43
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_2;
+                break replab0;
+            }
+            cursor = v_1;
+            // repeat, line 46
+            replab2: while(true)
+            {
+                v_3 = cursor;
+                lab3: do {
+                    // goto, line 46
+                    golab4: while(true)
+                    {
+                        v_4 = cursor;
+                        lab5: do {
+                            // (, line 46
+                            if (!(in_grouping(g_v, 97, 249)))
+                            {
+                                break lab5;
+                            }
+                            // [, line 47
+                            bra = cursor;
+                            // or, line 47
+                            lab6: do {
+                                v_5 = cursor;
+                                lab7: do {
+                                    // (, line 47
+                                    // literal, line 47
+                                    if (!(eq_s(1, "u")))
+                                    {
+                                        break lab7;
+                                    }
+                                    // ], line 47
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 249)))
+                                    {
+                                        break lab7;
+                                    }
+                                    // <-, line 47
+                                    slice_from("U");
+                                    break lab6;
+                                } while (false);
+                                cursor = v_5;
+                                // (, line 48
+                                // literal, line 48
+                                if (!(eq_s(1, "i")))
+                                {
+                                    break lab5;
+                                }
+                                // ], line 48
+                                ket = cursor;
+                                if (!(in_grouping(g_v, 97, 249)))
+                                {
+                                    break lab5;
+                                }
+                                // <-, line 48
+                                slice_from("I");
+                            } while (false);
+                            cursor = v_4;
+                            break golab4;
+                        } while (false);
+                        cursor = v_4;
+                        if (cursor >= limit)
+                        {
+                            break lab3;
+                        }
+                        cursor++;
+                    }
+                    continue replab2;
+                } while (false);
+                cursor = v_3;
+                break replab2;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_6;
+            int v_8;
+            // (, line 52
+            I_pV = limit;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 58
+            v_1 = cursor;
+            lab0: do {
+                // (, line 58
+                // or, line 60
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // (, line 59
+                        if (!(in_grouping(g_v, 97, 249)))
+                        {
+                            break lab2;
+                        }
+                        // or, line 59
+                        lab3: do {
+                            v_3 = cursor;
+                            lab4: do {
+                                // (, line 59
+                                if (!(out_grouping(g_v, 97, 249)))
+                                {
+                                    break lab4;
+                                }
+                                // gopast, line 59
+                                golab5: while(true)
+                                {
+                                    lab6: do {
+                                        if (!(in_grouping(g_v, 97, 249)))
+                                        {
+                                            break lab6;
+                                        }
+                                        break golab5;
+                                    } while (false);
+                                    if (cursor >= limit)
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor++;
+                                }
+                                break lab3;
+                            } while (false);
+                            cursor = v_3;
+                            // (, line 59
+                            if (!(in_grouping(g_v, 97, 249)))
+                            {
+                                break lab2;
+                            }
+                            // gopast, line 59
+                            golab7: while(true)
+                            {
+                                lab8: do {
+                                    if (!(out_grouping(g_v, 97, 249)))
+                                    {
+                                        break lab8;
+                                    }
+                                    break golab7;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab2;
+                                }
+                                cursor++;
+                            }
+                        } while (false);
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 61
+                    if (!(out_grouping(g_v, 97, 249)))
+                    {
+                        break lab0;
+                    }
+                    // or, line 61
+                    lab9: do {
+                        v_6 = cursor;
+                        lab10: do {
+                            // (, line 61
+                            if (!(out_grouping(g_v, 97, 249)))
+                            {
+                                break lab10;
+                            }
+                            // gopast, line 61
+                            golab11: while(true)
+                            {
+                                lab12: do {
+                                    if (!(in_grouping(g_v, 97, 249)))
+                                    {
+                                        break lab12;
+                                    }
+                                    break golab11;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab10;
+                                }
+                                cursor++;
+                            }
+                            break lab9;
+                        } while (false);
+                        cursor = v_6;
+                        // (, line 61
+                        if (!(in_grouping(g_v, 97, 249)))
+                        {
+                            break lab0;
+                        }
+                        // next, line 61
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    } while (false);
+                } while (false);
+                // setmark pV, line 62
+                I_pV = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 64
+            v_8 = cursor;
+            lab13: do {
+                // (, line 64
+                // gopast, line 65
+                golab14: while(true)
+                {
+                    lab15: do {
+                        if (!(in_grouping(g_v, 97, 249)))
+                        {
+                            break lab15;
+                        }
+                        break golab14;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 65
+                golab16: while(true)
+                {
+                    lab17: do {
+                        if (!(out_grouping(g_v, 97, 249)))
+                        {
+                            break lab17;
+                        }
+                        break golab16;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 65
+                I_p1 = cursor;
+                // gopast, line 66
+                golab18: while(true)
+                {
+                    lab19: do {
+                        if (!(in_grouping(g_v, 97, 249)))
+                        {
+                            break lab19;
+                        }
+                        break golab18;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 66
+                golab20: while(true)
+                {
+                    lab21: do {
+                        if (!(out_grouping(g_v, 97, 249)))
+                        {
+                            break lab21;
+                        }
+                        break golab20;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 66
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_8;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 70
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 70
+                    // [, line 72
+                    bra = cursor;
+                    // substring, line 72
+                    among_var = find_among(a_1, 3);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 72
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 73
+                            // <-, line 73
+                            slice_from("i");
+                            break;
+                        case 2:
+                            // (, line 74
+                            // <-, line 74
+                            slice_from("u");
+                            break;
+                        case 3:
+                            // (, line 75
+                            // next, line 75
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_RV() {
+            if (!(I_pV <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_attached_pronoun() {
+            int among_var;
+            // (, line 86
+            // [, line 87
+            ket = cursor;
+            // substring, line 87
+            if (find_among_b(a_2, 37) == 0)
+            {
+                return false;
+            }
+            // ], line 87
+            bra = cursor;
+            // among, line 97
+            among_var = find_among_b(a_3, 5);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 97
+            // call RV, line 97
+            if (!r_RV())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 98
+                    // delete, line 98
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 99
+                    // <-, line 99
+                    slice_from("e");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 103
+            // [, line 104
+            ket = cursor;
+            // substring, line 104
+            among_var = find_among_b(a_6, 51);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 104
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 111
+                    // call R2, line 111
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 111
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 113
+                    // call R2, line 113
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 113
+                    slice_del();
+                    // try, line 114
+                    v_1 = limit - cursor;
+                    lab0: do {
+                        // (, line 114
+                        // [, line 114
+                        ket = cursor;
+                        // literal, line 114
+                        if (!(eq_s_b(2, "ic")))
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // ], line 114
+                        bra = cursor;
+                        // call R2, line 114
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // delete, line 114
+                        slice_del();
+                    } while (false);
+                    break;
+                case 3:
+                    // (, line 117
+                    // call R2, line 117
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 117
+                    slice_from("log");
+                    break;
+                case 4:
+                    // (, line 119
+                    // call R2, line 119
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 119
+                    slice_from("u");
+                    break;
+                case 5:
+                    // (, line 121
+                    // call R2, line 121
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 121
+                    slice_from("ente");
+                    break;
+                case 6:
+                    // (, line 123
+                    // call RV, line 123
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 123
+                    slice_del();
+                    break;
+                case 7:
+                    // (, line 124
+                    // call R1, line 125
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 125
+                    slice_del();
+                    // try, line 126
+                    v_2 = limit - cursor;
+                    lab1: do {
+                        // (, line 126
+                        // [, line 127
+                        ket = cursor;
+                        // substring, line 127
+                        among_var = find_among_b(a_4, 4);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_2;
+                            break lab1;
+                        }
+                        // ], line 127
+                        bra = cursor;
+                        // call R2, line 127
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_2;
+                            break lab1;
+                        }
+                        // delete, line 127
+                        slice_del();
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_2;
+                                break lab1;
+                            case 1:
+                                // (, line 128
+                                // [, line 128
+                                ket = cursor;
+                                // literal, line 128
+                                if (!(eq_s_b(2, "at")))
+                                {
+                                    cursor = limit - v_2;
+                                    break lab1;
+                                }
+                                // ], line 128
+                                bra = cursor;
+                                // call R2, line 128
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_2;
+                                    break lab1;
+                                }
+                                // delete, line 128
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 8:
+                    // (, line 133
+                    // call R2, line 134
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 134
+                    slice_del();
+                    // try, line 135
+                    v_3 = limit - cursor;
+                    lab2: do {
+                        // (, line 135
+                        // [, line 136
+                        ket = cursor;
+                        // substring, line 136
+                        among_var = find_among_b(a_5, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_3;
+                            break lab2;
+                        }
+                        // ], line 136
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_3;
+                                break lab2;
+                            case 1:
+                                // (, line 137
+                                // call R2, line 137
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab2;
+                                }
+                                // delete, line 137
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 9:
+                    // (, line 141
+                    // call R2, line 142
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 142
+                    slice_del();
+                    // try, line 143
+                    v_4 = limit - cursor;
+                    lab3: do {
+                        // (, line 143
+                        // [, line 143
+                        ket = cursor;
+                        // literal, line 143
+                        if (!(eq_s_b(2, "at")))
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // ], line 143
+                        bra = cursor;
+                        // call R2, line 143
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // delete, line 143
+                        slice_del();
+                        // [, line 143
+                        ket = cursor;
+                        // literal, line 143
+                        if (!(eq_s_b(2, "ic")))
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // ], line 143
+                        bra = cursor;
+                        // call R2, line 143
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // delete, line 143
+                        slice_del();
+                    } while (false);
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // setlimit, line 148
+            v_1 = limit - cursor;
+            // tomark, line 148
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 148
+            // [, line 149
+            ket = cursor;
+            // substring, line 149
+            among_var = find_among_b(a_7, 87);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 149
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 163
+                    // delete, line 163
+                    slice_del();
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_vowel_suffix() {
+            int v_1;
+            int v_2;
+            // (, line 170
+            // try, line 171
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 171
+                // [, line 172
+                ket = cursor;
+                if (!(in_grouping_b(g_AEIO, 97, 242)))
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // ], line 172
+                bra = cursor;
+                // call RV, line 172
+                if (!r_RV())
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // delete, line 172
+                slice_del();
+                // [, line 173
+                ket = cursor;
+                // literal, line 173
+                if (!(eq_s_b(1, "i")))
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // ], line 173
+                bra = cursor;
+                // call RV, line 173
+                if (!r_RV())
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // delete, line 173
+                slice_del();
+            } while (false);
+            // try, line 175
+            v_2 = limit - cursor;
+            lab1: do {
+                // (, line 175
+                // [, line 176
+                ket = cursor;
+                // literal, line 176
+                if (!(eq_s_b(1, "h")))
+                {
+                    cursor = limit - v_2;
+                    break lab1;
+                }
+                // ], line 176
+                bra = cursor;
+                if (!(in_grouping_b(g_CG, 99, 103)))
+                {
+                    cursor = limit - v_2;
+                    break lab1;
+                }
+                // call RV, line 176
+                if (!r_RV())
+                {
+                    cursor = limit - v_2;
+                    break lab1;
+                }
+                // delete, line 176
+                slice_del();
+            } while (false);
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            // (, line 181
+            // do, line 182
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 182
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 183
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 183
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 184
+            limit_backward = cursor; cursor = limit;
+            // (, line 184
+            // do, line 185
+            v_3 = limit - cursor;
+            lab2: do {
+                // call attached_pronoun, line 185
+                if (!r_attached_pronoun())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 186
+            v_4 = limit - cursor;
+            lab3: do {
+                // (, line 186
+                // or, line 186
+                lab4: do {
+                    v_5 = limit - cursor;
+                    lab5: do {
+                        // call standard_suffix, line 186
+                        if (!r_standard_suffix())
+                        {
+                            break lab5;
+                        }
+                        break lab4;
+                    } while (false);
+                    cursor = limit - v_5;
+                    // call verb_suffix, line 186
+                    if (!r_verb_suffix())
+                    {
+                        break lab3;
+                    }
+                } while (false);
+            } while (false);
+            cursor = limit - v_4;
+            // do, line 187
+            v_6 = limit - cursor;
+            lab6: do {
+                // call vowel_suffix, line 187
+                if (!r_vowel_suffix())
+                {
+                    break lab6;
+                }
+            } while (false);
+            cursor = limit - v_6;
+            cursor = limit_backward;            // do, line 189
+            v_7 = cursor;
+            lab7: do {
+                // call postlude, line 189
+                if (!r_postlude())
+                {
+                    break lab7;
+                }
+            } while (false);
+            cursor = v_7;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/KpStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/KpStemmer.java
new file mode 100644
index 0000000..d35317a
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/KpStemmer.java
@@ -0,0 +1,2181 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class KpStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "nde", -1, 7, "", this),
+            new Among ( "en", -1, 6, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "'s", 2, 1, "", this),
+            new Among ( "es", 2, 4, "", this),
+            new Among ( "ies", 4, 3, "", this),
+            new Among ( "aus", 2, 5, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "de", -1, 5, "", this),
+            new Among ( "ge", -1, 2, "", this),
+            new Among ( "ische", -1, 4, "", this),
+            new Among ( "je", -1, 1, "", this),
+            new Among ( "lijke", -1, 3, "", this),
+            new Among ( "le", -1, 9, "", this),
+            new Among ( "ene", -1, 10, "", this),
+            new Among ( "re", -1, 8, "", this),
+            new Among ( "se", -1, 7, "", this),
+            new Among ( "te", -1, 6, "", this),
+            new Among ( "ieve", -1, 11, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "heid", -1, 3, "", this),
+            new Among ( "fie", -1, 7, "", this),
+            new Among ( "gie", -1, 8, "", this),
+            new Among ( "atie", -1, 1, "", this),
+            new Among ( "isme", -1, 5, "", this),
+            new Among ( "ing", -1, 5, "", this),
+            new Among ( "arij", -1, 6, "", this),
+            new Among ( "erij", -1, 5, "", this),
+            new Among ( "sel", -1, 3, "", this),
+            new Among ( "rder", -1, 4, "", this),
+            new Among ( "ster", -1, 3, "", this),
+            new Among ( "iteit", -1, 2, "", this),
+            new Among ( "dst", -1, 10, "", this),
+            new Among ( "tst", -1, 9, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "end", -1, 10, "", this),
+            new Among ( "atief", -1, 2, "", this),
+            new Among ( "erig", -1, 10, "", this),
+            new Among ( "achtig", -1, 9, "", this),
+            new Among ( "ioneel", -1, 1, "", this),
+            new Among ( "baar", -1, 3, "", this),
+            new Among ( "laar", -1, 5, "", this),
+            new Among ( "naar", -1, 4, "", this),
+            new Among ( "raar", -1, 6, "", this),
+            new Among ( "eriger", -1, 10, "", this),
+            new Among ( "achtiger", -1, 9, "", this),
+            new Among ( "lijker", -1, 8, "", this),
+            new Among ( "tant", -1, 7, "", this),
+            new Among ( "erigst", -1, 10, "", this),
+            new Among ( "achtigst", -1, 9, "", this),
+            new Among ( "lijkst", -1, 8, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "iger", -1, 1, "", this),
+            new Among ( "igst", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ft", -1, 2, "", this),
+            new Among ( "kt", -1, 1, "", this),
+            new Among ( "pt", -1, 3, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "bb", -1, 1, "", this),
+            new Among ( "cc", -1, 2, "", this),
+            new Among ( "dd", -1, 3, "", this),
+            new Among ( "ff", -1, 4, "", this),
+            new Among ( "gg", -1, 5, "", this),
+            new Among ( "hh", -1, 6, "", this),
+            new Among ( "jj", -1, 7, "", this),
+            new Among ( "kk", -1, 8, "", this),
+            new Among ( "ll", -1, 9, "", this),
+            new Among ( "mm", -1, 10, "", this),
+            new Among ( "nn", -1, 11, "", this),
+            new Among ( "pp", -1, 12, "", this),
+            new Among ( "qq", -1, 13, "", this),
+            new Among ( "rr", -1, 14, "", this),
+            new Among ( "ss", -1, 15, "", this),
+            new Among ( "tt", -1, 16, "", this),
+            new Among ( "v", -1, 21, "", this),
+            new Among ( "vv", 16, 17, "", this),
+            new Among ( "ww", -1, 18, "", this),
+            new Among ( "xx", -1, 19, "", this),
+            new Among ( "z", -1, 22, "", this),
+            new Among ( "zz", 20, 20, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "d", -1, 1, "", this),
+            new Among ( "t", -1, 2, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1 };
+
+        private static final char g_v_WX[] = {17, 65, 208, 1 };
+
+        private static final char g_AOU[] = {1, 64, 16 };
+
+        private static final char g_AIOU[] = {1, 65, 16 };
+
+        private boolean B_GE_removed;
+        private boolean B_stemmed;
+        private boolean B_Y_found;
+        private int I_p2;
+        private int I_p1;
+        private int I_x;
+        private StringBuilder S_ch = new StringBuilder();
+
+        private void copy_from(KpStemmer other) {
+            B_GE_removed = other.B_GE_removed;
+            B_stemmed = other.B_stemmed;
+            B_Y_found = other.B_Y_found;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_x = other.I_x;
+            S_ch = other.S_ch;
+            super.copy_from(other);
+        }
+
+        private boolean r_R1() {
+            // (, line 32
+            // setmark x, line 32
+            I_x = cursor;
+            if (!(I_x >= I_p1))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            // (, line 33
+            // setmark x, line 33
+            I_x = cursor;
+            if (!(I_x >= I_p2))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_V() {
+            int v_1;
+            int v_2;
+            // test, line 35
+            v_1 = limit - cursor;
+            // (, line 35
+            // or, line 35
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    if (!(in_grouping_b(g_v, 97, 121)))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 35
+                if (!(eq_s_b(2, "ij")))
+                {
+                    return false;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_VX() {
+            int v_1;
+            int v_2;
+            // test, line 36
+            v_1 = limit - cursor;
+            // (, line 36
+            // next, line 36
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // or, line 36
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    if (!(in_grouping_b(g_v, 97, 121)))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 36
+                if (!(eq_s_b(2, "ij")))
+                {
+                    return false;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_C() {
+            int v_1;
+            int v_2;
+            // test, line 37
+            v_1 = limit - cursor;
+            // (, line 37
+            // not, line 37
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 37
+                    if (!(eq_s_b(2, "ij")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            if (!(out_grouping_b(g_v, 97, 121)))
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_lengthen_V() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            // do, line 39
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 39
+                if (!(out_grouping_b(g_v_WX, 97, 121)))
+                {
+                    break lab0;
+                }
+                // [, line 40
+                ket = cursor;
+                // or, line 40
+                lab1: do {
+                    v_2 = limit - cursor;
+                    lab2: do {
+                        // (, line 40
+                        if (!(in_grouping_b(g_AOU, 97, 117)))
+                        {
+                            break lab2;
+                        }
+                        // ], line 40
+                        bra = cursor;
+                        // test, line 40
+                        v_3 = limit - cursor;
+                        // (, line 40
+                        // or, line 40
+                        lab3: do {
+                            v_4 = limit - cursor;
+                            lab4: do {
+                                if (!(out_grouping_b(g_v, 97, 121)))
+                                {
+                                    break lab4;
+                                }
+                                break lab3;
+                            } while (false);
+                            cursor = limit - v_4;
+                            // atlimit, line 40
+                            if (cursor > limit_backward)
+                            {
+                                break lab2;
+                            }
+                        } while (false);
+                        cursor = limit - v_3;
+                        break lab1;
+                    } while (false);
+                    cursor = limit - v_2;
+                    // (, line 41
+                    // literal, line 41
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab0;
+                    }
+                    // ], line 41
+                    bra = cursor;
+                    // test, line 41
+                    v_5 = limit - cursor;
+                    // (, line 41
+                    // or, line 41
+                    lab5: do {
+                        v_6 = limit - cursor;
+                        lab6: do {
+                            if (!(out_grouping_b(g_v, 97, 121)))
+                            {
+                                break lab6;
+                            }
+                            break lab5;
+                        } while (false);
+                        cursor = limit - v_6;
+                        // atlimit, line 41
+                        if (cursor > limit_backward)
+                        {
+                            break lab0;
+                        }
+                    } while (false);
+                    // not, line 42
+                    {
+                        v_7 = limit - cursor;
+                        lab7: do {
+                            if (!(in_grouping_b(g_AIOU, 97, 117)))
+                            {
+                                break lab7;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_7;
+                    }
+                    // not, line 43
+                    {
+                        v_8 = limit - cursor;
+                        lab8: do {
+                            // (, line 43
+                            // next, line 43
+                            if (cursor <= limit_backward)
+                            {
+                                break lab8;
+                            }
+                            cursor--;
+                            if (!(in_grouping_b(g_AIOU, 97, 117)))
+                            {
+                                break lab8;
+                            }
+                            if (!(out_grouping_b(g_v, 97, 121)))
+                            {
+                                break lab8;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_8;
+                    }
+                    cursor = limit - v_5;
+                } while (false);
+                // -> ch, line 44
+                S_ch = slice_to(S_ch);
+                // <+ ch, line 44
+                {
+                    int c = cursor;
+                    insert(cursor, cursor, S_ch);
+                    cursor = c;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_Step_1() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 48
+            // [, line 49
+            ket = cursor;
+            // among, line 49
+            among_var = find_among_b(a_0, 7);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 49
+            // ], line 49
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 51
+                    // delete, line 51
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 52
+                    // call R1, line 52
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // not, line 52
+                    {
+                        v_1 = limit - cursor;
+                        lab0: do {
+                            // (, line 52
+                            // literal, line 52
+                            if (!(eq_s_b(1, "t")))
+                            {
+                                break lab0;
+                            }
+                            // call R1, line 52
+                            if (!r_R1())
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_1;
+                    }
+                    // call C, line 52
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // delete, line 52
+                    slice_del();
+                    break;
+                case 3:
+                    // (, line 53
+                    // call R1, line 53
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 53
+                    slice_from("ie");
+                    break;
+                case 4:
+                    // (, line 55
+                    // or, line 55
+                    lab1: do {
+                        v_2 = limit - cursor;
+                        lab2: do {
+                            // (, line 55
+                            // literal, line 55
+                            if (!(eq_s_b(2, "ar")))
+                            {
+                                break lab2;
+                            }
+                            // call R1, line 55
+                            if (!r_R1())
+                            {
+                                break lab2;
+                            }
+                            // call C, line 55
+                            if (!r_C())
+                            {
+                                break lab2;
+                            }
+                            // ], line 55
+                            bra = cursor;
+                            // delete, line 55
+                            slice_del();
+                            // call lengthen_V, line 55
+                            if (!r_lengthen_V())
+                            {
+                                break lab2;
+                            }
+                            break lab1;
+                        } while (false);
+                        cursor = limit - v_2;
+                        lab3: do {
+                            // (, line 56
+                            // literal, line 56
+                            if (!(eq_s_b(2, "er")))
+                            {
+                                break lab3;
+                            }
+                            // call R1, line 56
+                            if (!r_R1())
+                            {
+                                break lab3;
+                            }
+                            // call C, line 56
+                            if (!r_C())
+                            {
+                                break lab3;
+                            }
+                            // ], line 56
+                            bra = cursor;
+                            // delete, line 56
+                            slice_del();
+                            break lab1;
+                        } while (false);
+                        cursor = limit - v_2;
+                        // (, line 57
+                        // call R1, line 57
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // call C, line 57
+                        if (!r_C())
+                        {
+                            return false;
+                        }
+                        // <-, line 57
+                        slice_from("e");
+                    } while (false);
+                    break;
+                case 5:
+                    // (, line 59
+                    // call R1, line 59
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call V, line 59
+                    if (!r_V())
+                    {
+                        return false;
+                    }
+                    // <-, line 59
+                    slice_from("au");
+                    break;
+                case 6:
+                    // (, line 60
+                    // or, line 60
+                    lab4: do {
+                        v_3 = limit - cursor;
+                        lab5: do {
+                            // (, line 60
+                            // literal, line 60
+                            if (!(eq_s_b(3, "hed")))
+                            {
+                                break lab5;
+                            }
+                            // call R1, line 60
+                            if (!r_R1())
+                            {
+                                break lab5;
+                            }
+                            // ], line 60
+                            bra = cursor;
+                            // <-, line 60
+                            slice_from("heid");
+                            break lab4;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab6: do {
+                            // (, line 61
+                            // literal, line 61
+                            if (!(eq_s_b(2, "nd")))
+                            {
+                                break lab6;
+                            }
+                            // delete, line 61
+                            slice_del();
+                            break lab4;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab7: do {
+                            // (, line 62
+                            // literal, line 62
+                            if (!(eq_s_b(1, "d")))
+                            {
+                                break lab7;
+                            }
+                            // call R1, line 62
+                            if (!r_R1())
+                            {
+                                break lab7;
+                            }
+                            // call C, line 62
+                            if (!r_C())
+                            {
+                                break lab7;
+                            }
+                            // ], line 62
+                            bra = cursor;
+                            // delete, line 62
+                            slice_del();
+                            break lab4;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab8: do {
+                            // (, line 63
+                            // or, line 63
+                            lab9: do {
+                                v_4 = limit - cursor;
+                                lab10: do {
+                                    // literal, line 63
+                                    if (!(eq_s_b(1, "i")))
+                                    {
+                                        break lab10;
+                                    }
+                                    break lab9;
+                                } while (false);
+                                cursor = limit - v_4;
+                                // literal, line 63
+                                if (!(eq_s_b(1, "j")))
+                                {
+                                    break lab8;
+                                }
+                            } while (false);
+                            // call V, line 63
+                            if (!r_V())
+                            {
+                                break lab8;
+                            }
+                            // delete, line 63
+                            slice_del();
+                            break lab4;
+                        } while (false);
+                        cursor = limit - v_3;
+                        // (, line 64
+                        // call R1, line 64
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // call C, line 64
+                        if (!r_C())
+                        {
+                            return false;
+                        }
+                        // delete, line 64
+                        slice_del();
+                        // call lengthen_V, line 64
+                        if (!r_lengthen_V())
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    break;
+                case 7:
+                    // (, line 65
+                    // <-, line 65
+                    slice_from("nd");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_2() {
+            int among_var;
+            int v_1;
+            // (, line 70
+            // [, line 71
+            ket = cursor;
+            // among, line 71
+            among_var = find_among_b(a_1, 11);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 71
+            // ], line 71
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 72
+                    // or, line 72
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // (, line 72
+                            // literal, line 72
+                            if (!(eq_s_b(2, "'t")))
+                            {
+                                break lab1;
+                            }
+                            // ], line 72
+                            bra = cursor;
+                            // delete, line 72
+                            slice_del();
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab2: do {
+                            // (, line 73
+                            // literal, line 73
+                            if (!(eq_s_b(2, "et")))
+                            {
+                                break lab2;
+                            }
+                            // ], line 73
+                            bra = cursor;
+                            // call R1, line 73
+                            if (!r_R1())
+                            {
+                                break lab2;
+                            }
+                            // call C, line 73
+                            if (!r_C())
+                            {
+                                break lab2;
+                            }
+                            // delete, line 73
+                            slice_del();
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab3: do {
+                            // (, line 74
+                            // literal, line 74
+                            if (!(eq_s_b(3, "rnt")))
+                            {
+                                break lab3;
+                            }
+                            // ], line 74
+                            bra = cursor;
+                            // <-, line 74
+                            slice_from("rn");
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab4: do {
+                            // (, line 75
+                            // literal, line 75
+                            if (!(eq_s_b(1, "t")))
+                            {
+                                break lab4;
+                            }
+                            // ], line 75
+                            bra = cursor;
+                            // call R1, line 75
+                            if (!r_R1())
+                            {
+                                break lab4;
+                            }
+                            // call VX, line 75
+                            if (!r_VX())
+                            {
+                                break lab4;
+                            }
+                            // delete, line 75
+                            slice_del();
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab5: do {
+                            // (, line 76
+                            // literal, line 76
+                            if (!(eq_s_b(3, "ink")))
+                            {
+                                break lab5;
+                            }
+                            // ], line 76
+                            bra = cursor;
+                            // <-, line 76
+                            slice_from("ing");
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab6: do {
+                            // (, line 77
+                            // literal, line 77
+                            if (!(eq_s_b(2, "mp")))
+                            {
+                                break lab6;
+                            }
+                            // ], line 77
+                            bra = cursor;
+                            // <-, line 77
+                            slice_from("m");
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        lab7: do {
+                            // (, line 78
+                            // literal, line 78
+                            if (!(eq_s_b(1, "'")))
+                            {
+                                break lab7;
+                            }
+                            // ], line 78
+                            bra = cursor;
+                            // call R1, line 78
+                            if (!r_R1())
+                            {
+                                break lab7;
+                            }
+                            // delete, line 78
+                            slice_del();
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // (, line 79
+                        // ], line 79
+                        bra = cursor;
+                        // call R1, line 79
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // call C, line 79
+                        if (!r_C())
+                        {
+                            return false;
+                        }
+                        // delete, line 79
+                        slice_del();
+                    } while (false);
+                    break;
+                case 2:
+                    // (, line 80
+                    // call R1, line 80
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 80
+                    slice_from("g");
+                    break;
+                case 3:
+                    // (, line 81
+                    // call R1, line 81
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 81
+                    slice_from("lijk");
+                    break;
+                case 4:
+                    // (, line 82
+                    // call R1, line 82
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 82
+                    slice_from("isch");
+                    break;
+                case 5:
+                    // (, line 83
+                    // call R1, line 83
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 83
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // delete, line 83
+                    slice_del();
+                    break;
+                case 6:
+                    // (, line 84
+                    // call R1, line 84
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 84
+                    slice_from("t");
+                    break;
+                case 7:
+                    // (, line 85
+                    // call R1, line 85
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 85
+                    slice_from("s");
+                    break;
+                case 8:
+                    // (, line 86
+                    // call R1, line 86
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 86
+                    slice_from("r");
+                    break;
+                case 9:
+                    // (, line 87
+                    // call R1, line 87
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 87
+                    slice_del();
+                    // attach, line 87
+                    insert(cursor, cursor, "l");
+                    // call lengthen_V, line 87
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 10:
+                    // (, line 88
+                    // call R1, line 88
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 88
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // delete, line 88
+                    slice_del();
+                    // attach, line 88
+                    insert(cursor, cursor, "en");
+                    // call lengthen_V, line 88
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 11:
+                    // (, line 89
+                    // call R1, line 89
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 89
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // <-, line 89
+                    slice_from("ief");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_3() {
+            int among_var;
+            // (, line 94
+            // [, line 95
+            ket = cursor;
+            // among, line 95
+            among_var = find_among_b(a_2, 14);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 95
+            // ], line 95
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 96
+                    // call R1, line 96
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 96
+                    slice_from("eer");
+                    break;
+                case 2:
+                    // (, line 97
+                    // call R1, line 97
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 97
+                    slice_del();
+                    // call lengthen_V, line 97
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 3:
+                    // (, line 100
+                    // call R1, line 100
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 100
+                    slice_del();
+                    break;
+                case 4:
+                    // (, line 101
+                    // <-, line 101
+                    slice_from("r");
+                    break;
+                case 5:
+                    // (, line 104
+                    // call R1, line 104
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 104
+                    slice_del();
+                    // call lengthen_V, line 104
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 6:
+                    // (, line 105
+                    // call R1, line 105
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 105
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // <-, line 105
+                    slice_from("aar");
+                    break;
+                case 7:
+                    // (, line 106
+                    // call R2, line 106
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 106
+                    slice_del();
+                    // attach, line 106
+                    insert(cursor, cursor, "f");
+                    // call lengthen_V, line 106
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 8:
+                    // (, line 107
+                    // call R2, line 107
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 107
+                    slice_del();
+                    // attach, line 107
+                    insert(cursor, cursor, "g");
+                    // call lengthen_V, line 107
+                    if (!r_lengthen_V())
+                    {
+                        return false;
+                    }
+                    break;
+                case 9:
+                    // (, line 108
+                    // call R1, line 108
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 108
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // <-, line 108
+                    slice_from("t");
+                    break;
+                case 10:
+                    // (, line 109
+                    // call R1, line 109
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // call C, line 109
+                    if (!r_C())
+                    {
+                        return false;
+                    }
+                    // <-, line 109
+                    slice_from("d");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_4() {
+            int among_var;
+            int v_1;
+            // (, line 114
+            // or, line 134
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 115
+                    // [, line 115
+                    ket = cursor;
+                    // among, line 115
+                    among_var = find_among_b(a_3, 16);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // (, line 115
+                    // ], line 115
+                    bra = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 116
+                            // call R1, line 116
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 116
+                            slice_from("ie");
+                            break;
+                        case 2:
+                            // (, line 117
+                            // call R1, line 117
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 117
+                            slice_from("eer");
+                            break;
+                        case 3:
+                            // (, line 118
+                            // call R1, line 118
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // delete, line 118
+                            slice_del();
+                            break;
+                        case 4:
+                            // (, line 119
+                            // call R1, line 119
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // call V, line 119
+                            if (!r_V())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 119
+                            slice_from("n");
+                            break;
+                        case 5:
+                            // (, line 120
+                            // call R1, line 120
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // call V, line 120
+                            if (!r_V())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 120
+                            slice_from("l");
+                            break;
+                        case 6:
+                            // (, line 121
+                            // call R1, line 121
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // call V, line 121
+                            if (!r_V())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 121
+                            slice_from("r");
+                            break;
+                        case 7:
+                            // (, line 122
+                            // call R1, line 122
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 122
+                            slice_from("teer");
+                            break;
+                        case 8:
+                            // (, line 124
+                            // call R1, line 124
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // <-, line 124
+                            slice_from("lijk");
+                            break;
+                        case 9:
+                            // (, line 127
+                            // call R1, line 127
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // delete, line 127
+                            slice_del();
+                            break;
+                        case 10:
+                            // (, line 131
+                            // call R1, line 131
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            // call C, line 131
+                            if (!r_C())
+                            {
+                                break lab1;
+                            }
+                            // delete, line 131
+                            slice_del();
+                            // call lengthen_V, line 131
+                            if (!r_lengthen_V())
+                            {
+                                break lab1;
+                            }
+                            break;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 135
+                // [, line 135
+                ket = cursor;
+                // among, line 135
+                among_var = find_among_b(a_4, 3);
+                if (among_var == 0)
+                {
+                    return false;
+                }
+                // (, line 135
+                // ], line 135
+                bra = cursor;
+                switch(among_var) {
+                    case 0:
+                        return false;
+                    case 1:
+                        // (, line 138
+                        // call R1, line 138
+                        if (!r_R1())
+                        {
+                            return false;
+                        }
+                        // call C, line 138
+                        if (!r_C())
+                        {
+                            return false;
+                        }
+                        // delete, line 138
+                        slice_del();
+                        // call lengthen_V, line 138
+                        if (!r_lengthen_V())
+                        {
+                            return false;
+                        }
+                        break;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_Step_7() {
+            int among_var;
+            // (, line 144
+            // [, line 145
+            ket = cursor;
+            // among, line 145
+            among_var = find_among_b(a_5, 3);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 145
+            // ], line 145
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 146
+                    // <-, line 146
+                    slice_from("k");
+                    break;
+                case 2:
+                    // (, line 147
+                    // <-, line 147
+                    slice_from("f");
+                    break;
+                case 3:
+                    // (, line 148
+                    // <-, line 148
+                    slice_from("p");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_6() {
+            int among_var;
+            // (, line 153
+            // [, line 154
+            ket = cursor;
+            // among, line 154
+            among_var = find_among_b(a_6, 22);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 154
+            // ], line 154
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 155
+                    // <-, line 155
+                    slice_from("b");
+                    break;
+                case 2:
+                    // (, line 156
+                    // <-, line 156
+                    slice_from("c");
+                    break;
+                case 3:
+                    // (, line 157
+                    // <-, line 157
+                    slice_from("d");
+                    break;
+                case 4:
+                    // (, line 158
+                    // <-, line 158
+                    slice_from("f");
+                    break;
+                case 5:
+                    // (, line 159
+                    // <-, line 159
+                    slice_from("g");
+                    break;
+                case 6:
+                    // (, line 160
+                    // <-, line 160
+                    slice_from("h");
+                    break;
+                case 7:
+                    // (, line 161
+                    // <-, line 161
+                    slice_from("j");
+                    break;
+                case 8:
+                    // (, line 162
+                    // <-, line 162
+                    slice_from("k");
+                    break;
+                case 9:
+                    // (, line 163
+                    // <-, line 163
+                    slice_from("l");
+                    break;
+                case 10:
+                    // (, line 164
+                    // <-, line 164
+                    slice_from("m");
+                    break;
+                case 11:
+                    // (, line 165
+                    // <-, line 165
+                    slice_from("n");
+                    break;
+                case 12:
+                    // (, line 166
+                    // <-, line 166
+                    slice_from("p");
+                    break;
+                case 13:
+                    // (, line 167
+                    // <-, line 167
+                    slice_from("q");
+                    break;
+                case 14:
+                    // (, line 168
+                    // <-, line 168
+                    slice_from("r");
+                    break;
+                case 15:
+                    // (, line 169
+                    // <-, line 169
+                    slice_from("s");
+                    break;
+                case 16:
+                    // (, line 170
+                    // <-, line 170
+                    slice_from("t");
+                    break;
+                case 17:
+                    // (, line 171
+                    // <-, line 171
+                    slice_from("v");
+                    break;
+                case 18:
+                    // (, line 172
+                    // <-, line 172
+                    slice_from("w");
+                    break;
+                case 19:
+                    // (, line 173
+                    // <-, line 173
+                    slice_from("x");
+                    break;
+                case 20:
+                    // (, line 174
+                    // <-, line 174
+                    slice_from("z");
+                    break;
+                case 21:
+                    // (, line 175
+                    // <-, line 175
+                    slice_from("f");
+                    break;
+                case 22:
+                    // (, line 176
+                    // <-, line 176
+                    slice_from("s");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1c() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 181
+            // [, line 182
+            ket = cursor;
+            // among, line 182
+            among_var = find_among_b(a_7, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // (, line 182
+            // ], line 182
+            bra = cursor;
+            // call R1, line 182
+            if (!r_R1())
+            {
+                return false;
+            }
+            // call C, line 182
+            if (!r_C())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 183
+                    // not, line 183
+                    {
+                        v_1 = limit - cursor;
+                        lab0: do {
+                            // (, line 183
+                            // literal, line 183
+                            if (!(eq_s_b(1, "n")))
+                            {
+                                break lab0;
+                            }
+                            // call R1, line 183
+                            if (!r_R1())
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_1;
+                    }
+                    // delete, line 183
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 184
+                    // not, line 184
+                    {
+                        v_2 = limit - cursor;
+                        lab1: do {
+                            // (, line 184
+                            // literal, line 184
+                            if (!(eq_s_b(1, "h")))
+                            {
+                                break lab1;
+                            }
+                            // call R1, line 184
+                            if (!r_R1())
+                            {
+                                break lab1;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_2;
+                    }
+                    // delete, line 184
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Lose_prefix() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 189
+            // [, line 190
+            bra = cursor;
+            // literal, line 190
+            if (!(eq_s(2, "ge")))
+            {
+                return false;
+            }
+            // ], line 190
+            ket = cursor;
+            // test, line 190
+            v_1 = cursor;
+            // hop, line 190
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = v_1;
+            // (, line 190
+            // goto, line 190
+            golab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 121)))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_2;
+                    break golab0;
+                } while (false);
+                cursor = v_2;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // goto, line 190
+            golab2: while(true)
+            {
+                v_3 = cursor;
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 121)))
+                    {
+                        break lab3;
+                    }
+                    cursor = v_3;
+                    break golab2;
+                } while (false);
+                cursor = v_3;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // set GE_removed, line 191
+            B_GE_removed = true;
+            // delete, line 192
+            slice_del();
+            return true;
+        }
+
+        private boolean r_Lose_infix() {
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 195
+            // next, line 196
+            if (cursor >= limit)
+            {
+                return false;
+            }
+            cursor++;
+            // gopast, line 197
+            golab0: while(true)
+            {
+                lab1: do {
+                    // (, line 197
+                    // [, line 197
+                    bra = cursor;
+                    // literal, line 197
+                    if (!(eq_s(2, "ge")))
+                    {
+                        break lab1;
+                    }
+                    // ], line 197
+                    ket = cursor;
+                    break golab0;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // test, line 197
+            v_2 = cursor;
+            // hop, line 197
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = v_2;
+            // (, line 197
+            // goto, line 197
+            golab2: while(true)
+            {
+                v_3 = cursor;
+                lab3: do {
+                    if (!(in_grouping(g_v, 97, 121)))
+                    {
+                        break lab3;
+                    }
+                    cursor = v_3;
+                    break golab2;
+                } while (false);
+                cursor = v_3;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // goto, line 197
+            golab4: while(true)
+            {
+                v_4 = cursor;
+                lab5: do {
+                    if (!(out_grouping(g_v, 97, 121)))
+                    {
+                        break lab5;
+                    }
+                    cursor = v_4;
+                    break golab4;
+                } while (false);
+                cursor = v_4;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // set GE_removed, line 198
+            B_GE_removed = true;
+            // delete, line 199
+            slice_del();
+            return true;
+        }
+
+        private boolean r_measure() {
+            int v_1;
+            int v_2;
+            int v_5;
+            int v_6;
+            int v_9;
+            int v_10;
+            // (, line 202
+            // do, line 203
+            v_1 = cursor;
+            lab0: do {
+                // (, line 203
+                // tolimit, line 204
+                cursor = limit;
+                // setmark p1, line 205
+                I_p1 = cursor;
+                // setmark p2, line 206
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 208
+            v_2 = cursor;
+            lab1: do {
+                // (, line 208
+                // repeat, line 209
+                replab2: while(true)
+                {
+                    lab3: do {
+                        if (!(out_grouping(g_v, 97, 121)))
+                        {
+                            break lab3;
+                        }
+                        continue replab2;
+                    } while (false);
+                    break replab2;
+                }
+                // atleast, line 209
+                {
+                    int v_4 = 1;
+                    // atleast, line 209
+                    replab4: while(true)
+                    {
+                        v_5 = cursor;
+                        lab5: do {
+                            // (, line 209
+                            // or, line 209
+                            lab6: do {
+                                v_6 = cursor;
+                                lab7: do {
+                                    // literal, line 209
+                                    if (!(eq_s(2, "ij")))
+                                    {
+                                        break lab7;
+                                    }
+                                    break lab6;
+                                } while (false);
+                                cursor = v_6;
+                                if (!(in_grouping(g_v, 97, 121)))
+                                {
+                                    break lab5;
+                                }
+                            } while (false);
+                            v_4--;
+                            continue replab4;
+                        } while (false);
+                        cursor = v_5;
+                        break replab4;
+                    }
+                    if (v_4 > 0)
+                    {
+                        break lab1;
+                    }
+                }
+                if (!(out_grouping(g_v, 97, 121)))
+                {
+                    break lab1;
+                }
+                // setmark p1, line 209
+                I_p1 = cursor;
+                // repeat, line 210
+                replab8: while(true)
+                {
+                    lab9: do {
+                        if (!(out_grouping(g_v, 97, 121)))
+                        {
+                            break lab9;
+                        }
+                        continue replab8;
+                    } while (false);
+                    break replab8;
+                }
+                // atleast, line 210
+                {
+                    int v_8 = 1;
+                    // atleast, line 210
+                    replab10: while(true)
+                    {
+                        v_9 = cursor;
+                        lab11: do {
+                            // (, line 210
+                            // or, line 210
+                            lab12: do {
+                                v_10 = cursor;
+                                lab13: do {
+                                    // literal, line 210
+                                    if (!(eq_s(2, "ij")))
+                                    {
+                                        break lab13;
+                                    }
+                                    break lab12;
+                                } while (false);
+                                cursor = v_10;
+                                if (!(in_grouping(g_v, 97, 121)))
+                                {
+                                    break lab11;
+                                }
+                            } while (false);
+                            v_8--;
+                            continue replab10;
+                        } while (false);
+                        cursor = v_9;
+                        break replab10;
+                    }
+                    if (v_8 > 0)
+                    {
+                        break lab1;
+                    }
+                }
+                if (!(out_grouping(g_v, 97, 121)))
+                {
+                    break lab1;
+                }
+                // setmark p2, line 210
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_2;
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            int v_12;
+            int v_13;
+            int v_14;
+            int v_15;
+            int v_16;
+            int v_18;
+            int v_19;
+            int v_20;
+            // (, line 214
+            // unset Y_found, line 216
+            B_Y_found = false;
+            // unset stemmed, line 217
+            B_stemmed = false;
+            // do, line 218
+            v_1 = cursor;
+            lab0: do {
+                // (, line 218
+                // [, line 218
+                bra = cursor;
+                // literal, line 218
+                if (!(eq_s(1, "y")))
+                {
+                    break lab0;
+                }
+                // ], line 218
+                ket = cursor;
+                // <-, line 218
+                slice_from("Y");
+                // set Y_found, line 218
+                B_Y_found = true;
+            } while (false);
+            cursor = v_1;
+            // do, line 219
+            v_2 = cursor;
+            lab1: do {
+                // repeat, line 219
+                replab2: while(true)
+                {
+                    v_3 = cursor;
+                    lab3: do {
+                        // (, line 219
+                        // goto, line 219
+                        golab4: while(true)
+                        {
+                            v_4 = cursor;
+                            lab5: do {
+                                // (, line 219
+                                if (!(in_grouping(g_v, 97, 121)))
+                                {
+                                    break lab5;
+                                }
+                                // [, line 219
+                                bra = cursor;
+                                // literal, line 219
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab5;
+                                }
+                                // ], line 219
+                                ket = cursor;
+                                cursor = v_4;
+                                break golab4;
+                            } while (false);
+                            cursor = v_4;
+                            if (cursor >= limit)
+                            {
+                                break lab3;
+                            }
+                            cursor++;
+                        }
+                        // <-, line 219
+                        slice_from("Y");
+                        // set Y_found, line 219
+                        B_Y_found = true;
+                        continue replab2;
+                    } while (false);
+                    cursor = v_3;
+                    break replab2;
+                }
+            } while (false);
+            cursor = v_2;
+            // call measure, line 221
+            if (!r_measure())
+            {
+                return false;
+            }
+            // backwards, line 223
+            limit_backward = cursor; cursor = limit;
+            // (, line 223
+            // do, line 224
+            v_5 = limit - cursor;
+            lab6: do {
+                // (, line 224
+                // call Step_1, line 224
+                if (!r_Step_1())
+                {
+                    break lab6;
+                }
+                // set stemmed, line 224
+                B_stemmed = true;
+            } while (false);
+            cursor = limit - v_5;
+            // do, line 225
+            v_6 = limit - cursor;
+            lab7: do {
+                // (, line 225
+                // call Step_2, line 225
+                if (!r_Step_2())
+                {
+                    break lab7;
+                }
+                // set stemmed, line 225
+                B_stemmed = true;
+            } while (false);
+            cursor = limit - v_6;
+            // do, line 226
+            v_7 = limit - cursor;
+            lab8: do {
+                // (, line 226
+                // call Step_3, line 226
+                if (!r_Step_3())
+                {
+                    break lab8;
+                }
+                // set stemmed, line 226
+                B_stemmed = true;
+            } while (false);
+            cursor = limit - v_7;
+            // do, line 227
+            v_8 = limit - cursor;
+            lab9: do {
+                // (, line 227
+                // call Step_4, line 227
+                if (!r_Step_4())
+                {
+                    break lab9;
+                }
+                // set stemmed, line 227
+                B_stemmed = true;
+            } while (false);
+            cursor = limit - v_8;
+            cursor = limit_backward;            // unset GE_removed, line 229
+            B_GE_removed = false;
+            // do, line 230
+            v_9 = cursor;
+            lab10: do {
+                // (, line 230
+                // and, line 230
+                v_10 = cursor;
+                // call Lose_prefix, line 230
+                if (!r_Lose_prefix())
+                {
+                    break lab10;
+                }
+                cursor = v_10;
+                // call measure, line 230
+                if (!r_measure())
+                {
+                    break lab10;
+                }
+            } while (false);
+            cursor = v_9;
+            // backwards, line 231
+            limit_backward = cursor; cursor = limit;
+            // (, line 231
+            // do, line 232
+            v_11 = limit - cursor;
+            lab11: do {
+                // (, line 232
+                // Boolean test GE_removed, line 232
+                if (!(B_GE_removed))
+                {
+                    break lab11;
+                }
+                // call Step_1c, line 232
+                if (!r_Step_1c())
+                {
+                    break lab11;
+                }
+            } while (false);
+            cursor = limit - v_11;
+            cursor = limit_backward;            // unset GE_removed, line 234
+            B_GE_removed = false;
+            // do, line 235
+            v_12 = cursor;
+            lab12: do {
+                // (, line 235
+                // and, line 235
+                v_13 = cursor;
+                // call Lose_infix, line 235
+                if (!r_Lose_infix())
+                {
+                    break lab12;
+                }
+                cursor = v_13;
+                // call measure, line 235
+                if (!r_measure())
+                {
+                    break lab12;
+                }
+            } while (false);
+            cursor = v_12;
+            // backwards, line 236
+            limit_backward = cursor; cursor = limit;
+            // (, line 236
+            // do, line 237
+            v_14 = limit - cursor;
+            lab13: do {
+                // (, line 237
+                // Boolean test GE_removed, line 237
+                if (!(B_GE_removed))
+                {
+                    break lab13;
+                }
+                // call Step_1c, line 237
+                if (!r_Step_1c())
+                {
+                    break lab13;
+                }
+            } while (false);
+            cursor = limit - v_14;
+            cursor = limit_backward;            // backwards, line 239
+            limit_backward = cursor; cursor = limit;
+            // (, line 239
+            // do, line 240
+            v_15 = limit - cursor;
+            lab14: do {
+                // (, line 240
+                // call Step_7, line 240
+                if (!r_Step_7())
+                {
+                    break lab14;
+                }
+                // set stemmed, line 240
+                B_stemmed = true;
+            } while (false);
+            cursor = limit - v_15;
+            // do, line 241
+            v_16 = limit - cursor;
+            lab15: do {
+                // (, line 241
+                // or, line 241
+                lab16: do {
+                    lab17: do {
+                        // Boolean test stemmed, line 241
+                        if (!(B_stemmed))
+                        {
+                            break lab17;
+                        }
+                        break lab16;
+                    } while (false);
+                    // Boolean test GE_removed, line 241
+                    if (!(B_GE_removed))
+                    {
+                        break lab15;
+                    }
+                } while (false);
+                // call Step_6, line 241
+                if (!r_Step_6())
+                {
+                    break lab15;
+                }
+            } while (false);
+            cursor = limit - v_16;
+            cursor = limit_backward;            // do, line 243
+            v_18 = cursor;
+            lab18: do {
+                // (, line 243
+                // Boolean test Y_found, line 243
+                if (!(B_Y_found))
+                {
+                    break lab18;
+                }
+                // repeat, line 243
+                replab19: while(true)
+                {
+                    v_19 = cursor;
+                    lab20: do {
+                        // (, line 243
+                        // goto, line 243
+                        golab21: while(true)
+                        {
+                            v_20 = cursor;
+                            lab22: do {
+                                // (, line 243
+                                // [, line 243
+                                bra = cursor;
+                                // literal, line 243
+                                if (!(eq_s(1, "Y")))
+                                {
+                                    break lab22;
+                                }
+                                // ], line 243
+                                ket = cursor;
+                                cursor = v_20;
+                                break golab21;
+                            } while (false);
+                            cursor = v_20;
+                            if (cursor >= limit)
+                            {
+                                break lab20;
+                            }
+                            cursor++;
+                        }
+                        // <-, line 243
+                        slice_from("y");
+                        continue replab19;
+                    } while (false);
+                    cursor = v_19;
+                    break replab19;
+                }
+            } while (false);
+            cursor = v_18;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/LovinsStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/LovinsStemmer.java
new file mode 100644
index 0000000..c64d5ef
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/LovinsStemmer.java
@@ -0,0 +1,1908 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class LovinsStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "d", -1, -1, "", this),
+            new Among ( "f", -1, -1, "", this),
+            new Among ( "ph", -1, -1, "", this),
+            new Among ( "th", -1, -1, "", this),
+            new Among ( "l", -1, -1, "", this),
+            new Among ( "er", -1, -1, "", this),
+            new Among ( "or", -1, -1, "", this),
+            new Among ( "es", -1, -1, "", this),
+            new Among ( "t", -1, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "s'", -1, 1, "r_A", this),
+            new Among ( "a", -1, 1, "r_A", this),
+            new Among ( "ia", 1, 1, "r_A", this),
+            new Among ( "ata", 1, 1, "r_A", this),
+            new Among ( "ic", -1, 1, "r_A", this),
+            new Among ( "aic", 4, 1, "r_A", this),
+            new Among ( "allic", 4, 1, "r_BB", this),
+            new Among ( "aric", 4, 1, "r_A", this),
+            new Among ( "atic", 4, 1, "r_B", this),
+            new Among ( "itic", 4, 1, "r_H", this),
+            new Among ( "antic", 4, 1, "r_C", this),
+            new Among ( "istic", 4, 1, "r_A", this),
+            new Among ( "alistic", 11, 1, "r_B", this),
+            new Among ( "aristic", 11, 1, "r_A", this),
+            new Among ( "ivistic", 11, 1, "r_A", this),
+            new Among ( "ed", -1, 1, "r_E", this),
+            new Among ( "anced", 15, 1, "r_B", this),
+            new Among ( "enced", 15, 1, "r_A", this),
+            new Among ( "ished", 15, 1, "r_A", this),
+            new Among ( "ied", 15, 1, "r_A", this),
+            new Among ( "ened", 15, 1, "r_E", this),
+            new Among ( "ioned", 15, 1, "r_A", this),
+            new Among ( "ated", 15, 1, "r_I", this),
+            new Among ( "ented", 15, 1, "r_C", this),
+            new Among ( "ized", 15, 1, "r_F", this),
+            new Among ( "arized", 24, 1, "r_A", this),
+            new Among ( "oid", -1, 1, "r_A", this),
+            new Among ( "aroid", 26, 1, "r_A", this),
+            new Among ( "hood", -1, 1, "r_A", this),
+            new Among ( "ehood", 28, 1, "r_A", this),
+            new Among ( "ihood", 28, 1, "r_A", this),
+            new Among ( "elihood", 30, 1, "r_E", this),
+            new Among ( "ward", -1, 1, "r_A", this),
+            new Among ( "e", -1, 1, "r_A", this),
+            new Among ( "ae", 33, 1, "r_A", this),
+            new Among ( "ance", 33, 1, "r_B", this),
+            new Among ( "icance", 35, 1, "r_A", this),
+            new Among ( "ence", 33, 1, "r_A", this),
+            new Among ( "ide", 33, 1, "r_L", this),
+            new Among ( "icide", 38, 1, "r_A", this),
+            new Among ( "otide", 38, 1, "r_A", this),
+            new Among ( "age", 33, 1, "r_B", this),
+            new Among ( "able", 33, 1, "r_A", this),
+            new Among ( "atable", 42, 1, "r_A", this),
+            new Among ( "izable", 42, 1, "r_E", this),
+            new Among ( "arizable", 44, 1, "r_A", this),
+            new Among ( "ible", 33, 1, "r_A", this),
+            new Among ( "encible", 46, 1, "r_A", this),
+            new Among ( "ene", 33, 1, "r_E", this),
+            new Among ( "ine", 33, 1, "r_M", this),
+            new Among ( "idine", 49, 1, "r_I", this),
+            new Among ( "one", 33, 1, "r_R", this),
+            new Among ( "ature", 33, 1, "r_E", this),
+            new Among ( "eature", 52, 1, "r_Z", this),
+            new Among ( "ese", 33, 1, "r_A", this),
+            new Among ( "wise", 33, 1, "r_A", this),
+            new Among ( "ate", 33, 1, "r_A", this),
+            new Among ( "entiate", 56, 1, "r_A", this),
+            new Among ( "inate", 56, 1, "r_A", this),
+            new Among ( "ionate", 56, 1, "r_D", this),
+            new Among ( "ite", 33, 1, "r_AA", this),
+            new Among ( "ive", 33, 1, "r_A", this),
+            new Among ( "ative", 61, 1, "r_A", this),
+            new Among ( "ize", 33, 1, "r_F", this),
+            new Among ( "alize", 63, 1, "r_A", this),
+            new Among ( "icalize", 64, 1, "r_A", this),
+            new Among ( "ialize", 64, 1, "r_A", this),
+            new Among ( "entialize", 66, 1, "r_A", this),
+            new Among ( "ionalize", 64, 1, "r_A", this),
+            new Among ( "arize", 63, 1, "r_A", this),
+            new Among ( "ing", -1, 1, "r_N", this),
+            new Among ( "ancing", 70, 1, "r_B", this),
+            new Among ( "encing", 70, 1, "r_A", this),
+            new Among ( "aging", 70, 1, "r_B", this),
+            new Among ( "ening", 70, 1, "r_E", this),
+            new Among ( "ioning", 70, 1, "r_A", this),
+            new Among ( "ating", 70, 1, "r_I", this),
+            new Among ( "enting", 70, 1, "r_C", this),
+            new Among ( "ying", 70, 1, "r_B", this),
+            new Among ( "izing", 70, 1, "r_F", this),
+            new Among ( "arizing", 79, 1, "r_A", this),
+            new Among ( "ish", -1, 1, "r_C", this),
+            new Among ( "yish", 81, 1, "r_A", this),
+            new Among ( "i", -1, 1, "r_A", this),
+            new Among ( "al", -1, 1, "r_BB", this),
+            new Among ( "ical", 84, 1, "r_A", this),
+            new Among ( "aical", 85, 1, "r_A", this),
+            new Among ( "istical", 85, 1, "r_A", this),
+            new Among ( "oidal", 84, 1, "r_A", this),
+            new Among ( "eal", 84, 1, "r_Y", this),
+            new Among ( "ial", 84, 1, "r_A", this),
+            new Among ( "ancial", 90, 1, "r_A", this),
+            new Among ( "arial", 90, 1, "r_A", this),
+            new Among ( "ential", 90, 1, "r_A", this),
+            new Among ( "ional", 84, 1, "r_A", this),
+            new Among ( "ational", 94, 1, "r_B", this),
+            new Among ( "izational", 95, 1, "r_A", this),
+            new Among ( "ental", 84, 1, "r_A", this),
+            new Among ( "ful", -1, 1, "r_A", this),
+            new Among ( "eful", 98, 1, "r_A", this),
+            new Among ( "iful", 98, 1, "r_A", this),
+            new Among ( "yl", -1, 1, "r_R", this),
+            new Among ( "ism", -1, 1, "r_B", this),
+            new Among ( "icism", 102, 1, "r_A", this),
+            new Among ( "oidism", 102, 1, "r_A", this),
+            new Among ( "alism", 102, 1, "r_B", this),
+            new Among ( "icalism", 105, 1, "r_A", this),
+            new Among ( "ionalism", 105, 1, "r_A", this),
+            new Among ( "inism", 102, 1, "r_J", this),
+            new Among ( "ativism", 102, 1, "r_A", this),
+            new Among ( "um", -1, 1, "r_U", this),
+            new Among ( "ium", 110, 1, "r_A", this),
+            new Among ( "ian", -1, 1, "r_A", this),
+            new Among ( "ician", 112, 1, "r_A", this),
+            new Among ( "en", -1, 1, "r_F", this),
+            new Among ( "ogen", 114, 1, "r_A", this),
+            new Among ( "on", -1, 1, "r_S", this),
+            new Among ( "ion", 116, 1, "r_Q", this),
+            new Among ( "ation", 117, 1, "r_B", this),
+            new Among ( "ication", 118, 1, "r_G", this),
+            new Among ( "entiation", 118, 1, "r_A", this),
+            new Among ( "ination", 118, 1, "r_A", this),
+            new Among ( "isation", 118, 1, "r_A", this),
+            new Among ( "arisation", 122, 1, "r_A", this),
+            new Among ( "entation", 118, 1, "r_A", this),
+            new Among ( "ization", 118, 1, "r_F", this),
+            new Among ( "arization", 125, 1, "r_A", this),
+            new Among ( "action", 117, 1, "r_G", this),
+            new Among ( "o", -1, 1, "r_A", this),
+            new Among ( "ar", -1, 1, "r_X", this),
+            new Among ( "ear", 129, 1, "r_Y", this),
+            new Among ( "ier", -1, 1, "r_A", this),
+            new Among ( "ariser", -1, 1, "r_A", this),
+            new Among ( "izer", -1, 1, "r_F", this),
+            new Among ( "arizer", 133, 1, "r_A", this),
+            new Among ( "or", -1, 1, "r_T", this),
+            new Among ( "ator", 135, 1, "r_A", this),
+            new Among ( "s", -1, 1, "r_W", this),
+            new Among ( "'s", 137, 1, "r_A", this),
+            new Among ( "as", 137, 1, "r_B", this),
+            new Among ( "ics", 137, 1, "r_A", this),
+            new Among ( "istics", 140, 1, "r_A", this),
+            new Among ( "es", 137, 1, "r_E", this),
+            new Among ( "ances", 142, 1, "r_B", this),
+            new Among ( "ences", 142, 1, "r_A", this),
+            new Among ( "ides", 142, 1, "r_L", this),
+            new Among ( "oides", 145, 1, "r_A", this),
+            new Among ( "ages", 142, 1, "r_B", this),
+            new Among ( "ies", 142, 1, "r_P", this),
+            new Among ( "acies", 148, 1, "r_A", this),
+            new Among ( "ancies", 148, 1, "r_A", this),
+            new Among ( "encies", 148, 1, "r_A", this),
+            new Among ( "aries", 148, 1, "r_A", this),
+            new Among ( "ities", 148, 1, "r_A", this),
+            new Among ( "alities", 153, 1, "r_A", this),
+            new Among ( "ivities", 153, 1, "r_A", this),
+            new Among ( "ines", 142, 1, "r_M", this),
+            new Among ( "nesses", 142, 1, "r_A", this),
+            new Among ( "ates", 142, 1, "r_A", this),
+            new Among ( "atives", 142, 1, "r_A", this),
+            new Among ( "ings", 137, 1, "r_N", this),
+            new Among ( "is", 137, 1, "r_A", this),
+            new Among ( "als", 137, 1, "r_BB", this),
+            new Among ( "ials", 162, 1, "r_A", this),
+            new Among ( "entials", 163, 1, "r_A", this),
+            new Among ( "ionals", 162, 1, "r_A", this),
+            new Among ( "isms", 137, 1, "r_B", this),
+            new Among ( "ians", 137, 1, "r_A", this),
+            new Among ( "icians", 167, 1, "r_A", this),
+            new Among ( "ions", 137, 1, "r_B", this),
+            new Among ( "ations", 169, 1, "r_B", this),
+            new Among ( "arisations", 170, 1, "r_A", this),
+            new Among ( "entations", 170, 1, "r_A", this),
+            new Among ( "izations", 170, 1, "r_A", this),
+            new Among ( "arizations", 173, 1, "r_A", this),
+            new Among ( "ars", 137, 1, "r_O", this),
+            new Among ( "iers", 137, 1, "r_A", this),
+            new Among ( "izers", 137, 1, "r_F", this),
+            new Among ( "ators", 137, 1, "r_A", this),
+            new Among ( "less", 137, 1, "r_A", this),
+            new Among ( "eless", 179, 1, "r_A", this),
+            new Among ( "ness", 137, 1, "r_A", this),
+            new Among ( "eness", 181, 1, "r_E", this),
+            new Among ( "ableness", 182, 1, "r_A", this),
+            new Among ( "eableness", 183, 1, "r_E", this),
+            new Among ( "ibleness", 182, 1, "r_A", this),
+            new Among ( "ateness", 182, 1, "r_A", this),
+            new Among ( "iteness", 182, 1, "r_A", this),
+            new Among ( "iveness", 182, 1, "r_A", this),
+            new Among ( "ativeness", 188, 1, "r_A", this),
+            new Among ( "ingness", 181, 1, "r_A", this),
+            new Among ( "ishness", 181, 1, "r_A", this),
+            new Among ( "iness", 181, 1, "r_A", this),
+            new Among ( "ariness", 192, 1, "r_E", this),
+            new Among ( "alness", 181, 1, "r_A", this),
+            new Among ( "icalness", 194, 1, "r_A", this),
+            new Among ( "antialness", 194, 1, "r_A", this),
+            new Among ( "entialness", 194, 1, "r_A", this),
+            new Among ( "ionalness", 194, 1, "r_A", this),
+            new Among ( "fulness", 181, 1, "r_A", this),
+            new Among ( "lessness", 181, 1, "r_A", this),
+            new Among ( "ousness", 181, 1, "r_A", this),
+            new Among ( "eousness", 201, 1, "r_A", this),
+            new Among ( "iousness", 201, 1, "r_A", this),
+            new Among ( "itousness", 201, 1, "r_A", this),
+            new Among ( "entness", 181, 1, "r_A", this),
+            new Among ( "ants", 137, 1, "r_B", this),
+            new Among ( "ists", 137, 1, "r_A", this),
+            new Among ( "icists", 207, 1, "r_A", this),
+            new Among ( "us", 137, 1, "r_V", this),
+            new Among ( "ous", 209, 1, "r_A", this),
+            new Among ( "eous", 210, 1, "r_A", this),
+            new Among ( "aceous", 211, 1, "r_A", this),
+            new Among ( "antaneous", 211, 1, "r_A", this),
+            new Among ( "ious", 210, 1, "r_A", this),
+            new Among ( "acious", 214, 1, "r_B", this),
+            new Among ( "itous", 210, 1, "r_A", this),
+            new Among ( "ant", -1, 1, "r_B", this),
+            new Among ( "icant", 217, 1, "r_A", this),
+            new Among ( "ent", -1, 1, "r_C", this),
+            new Among ( "ement", 219, 1, "r_A", this),
+            new Among ( "izement", 220, 1, "r_A", this),
+            new Among ( "ist", -1, 1, "r_A", this),
+            new Among ( "icist", 222, 1, "r_A", this),
+            new Among ( "alist", 222, 1, "r_A", this),
+            new Among ( "icalist", 224, 1, "r_A", this),
+            new Among ( "ialist", 224, 1, "r_A", this),
+            new Among ( "ionist", 222, 1, "r_A", this),
+            new Among ( "entist", 222, 1, "r_A", this),
+            new Among ( "y", -1, 1, "r_B", this),
+            new Among ( "acy", 229, 1, "r_A", this),
+            new Among ( "ancy", 229, 1, "r_B", this),
+            new Among ( "ency", 229, 1, "r_A", this),
+            new Among ( "ly", 229, 1, "r_B", this),
+            new Among ( "ealy", 233, 1, "r_Y", this),
+            new Among ( "ably", 233, 1, "r_A", this),
+            new Among ( "ibly", 233, 1, "r_A", this),
+            new Among ( "edly", 233, 1, "r_E", this),
+            new Among ( "iedly", 237, 1, "r_A", this),
+            new Among ( "ely", 233, 1, "r_E", this),
+            new Among ( "ately", 239, 1, "r_A", this),
+            new Among ( "ively", 239, 1, "r_A", this),
+            new Among ( "atively", 241, 1, "r_A", this),
+            new Among ( "ingly", 233, 1, "r_B", this),
+            new Among ( "atingly", 243, 1, "r_A", this),
+            new Among ( "ily", 233, 1, "r_A", this),
+            new Among ( "lily", 245, 1, "r_A", this),
+            new Among ( "arily", 245, 1, "r_A", this),
+            new Among ( "ally", 233, 1, "r_B", this),
+            new Among ( "ically", 248, 1, "r_A", this),
+            new Among ( "aically", 249, 1, "r_A", this),
+            new Among ( "allically", 249, 1, "r_C", this),
+            new Among ( "istically", 249, 1, "r_A", this),
+            new Among ( "alistically", 252, 1, "r_B", this),
+            new Among ( "oidally", 248, 1, "r_A", this),
+            new Among ( "ially", 248, 1, "r_A", this),
+            new Among ( "entially", 255, 1, "r_A", this),
+            new Among ( "ionally", 248, 1, "r_A", this),
+            new Among ( "ationally", 257, 1, "r_B", this),
+            new Among ( "izationally", 258, 1, "r_B", this),
+            new Among ( "entally", 248, 1, "r_A", this),
+            new Among ( "fully", 233, 1, "r_A", this),
+            new Among ( "efully", 261, 1, "r_A", this),
+            new Among ( "ifully", 261, 1, "r_A", this),
+            new Among ( "enly", 233, 1, "r_E", this),
+            new Among ( "arly", 233, 1, "r_K", this),
+            new Among ( "early", 265, 1, "r_Y", this),
+            new Among ( "lessly", 233, 1, "r_A", this),
+            new Among ( "ously", 233, 1, "r_A", this),
+            new Among ( "eously", 268, 1, "r_A", this),
+            new Among ( "iously", 268, 1, "r_A", this),
+            new Among ( "ently", 233, 1, "r_A", this),
+            new Among ( "ary", 229, 1, "r_F", this),
+            new Among ( "ery", 229, 1, "r_E", this),
+            new Among ( "icianry", 229, 1, "r_A", this),
+            new Among ( "atory", 229, 1, "r_A", this),
+            new Among ( "ity", 229, 1, "r_A", this),
+            new Among ( "acity", 276, 1, "r_A", this),
+            new Among ( "icity", 276, 1, "r_A", this),
+            new Among ( "eity", 276, 1, "r_A", this),
+            new Among ( "ality", 276, 1, "r_A", this),
+            new Among ( "icality", 280, 1, "r_A", this),
+            new Among ( "iality", 280, 1, "r_A", this),
+            new Among ( "antiality", 282, 1, "r_A", this),
+            new Among ( "entiality", 282, 1, "r_A", this),
+            new Among ( "ionality", 280, 1, "r_A", this),
+            new Among ( "elity", 276, 1, "r_A", this),
+            new Among ( "ability", 276, 1, "r_A", this),
+            new Among ( "izability", 287, 1, "r_A", this),
+            new Among ( "arizability", 288, 1, "r_A", this),
+            new Among ( "ibility", 276, 1, "r_A", this),
+            new Among ( "inity", 276, 1, "r_CC", this),
+            new Among ( "arity", 276, 1, "r_B", this),
+            new Among ( "ivity", 276, 1, "r_A", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "bb", -1, -1, "", this),
+            new Among ( "dd", -1, -1, "", this),
+            new Among ( "gg", -1, -1, "", this),
+            new Among ( "ll", -1, -1, "", this),
+            new Among ( "mm", -1, -1, "", this),
+            new Among ( "nn", -1, -1, "", this),
+            new Among ( "pp", -1, -1, "", this),
+            new Among ( "rr", -1, -1, "", this),
+            new Among ( "ss", -1, -1, "", this),
+            new Among ( "tt", -1, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "uad", -1, 18, "", this),
+            new Among ( "vad", -1, 19, "", this),
+            new Among ( "cid", -1, 20, "", this),
+            new Among ( "lid", -1, 21, "", this),
+            new Among ( "erid", -1, 22, "", this),
+            new Among ( "pand", -1, 23, "", this),
+            new Among ( "end", -1, 24, "", this),
+            new Among ( "ond", -1, 25, "", this),
+            new Among ( "lud", -1, 26, "", this),
+            new Among ( "rud", -1, 27, "", this),
+            new Among ( "ul", -1, 9, "", this),
+            new Among ( "her", -1, 28, "", this),
+            new Among ( "metr", -1, 7, "", this),
+            new Among ( "istr", -1, 6, "", this),
+            new Among ( "urs", -1, 5, "", this),
+            new Among ( "uct", -1, 2, "", this),
+            new Among ( "et", -1, 32, "", this),
+            new Among ( "mit", -1, 29, "", this),
+            new Among ( "ent", -1, 30, "", this),
+            new Among ( "umpt", -1, 3, "", this),
+            new Among ( "rpt", -1, 4, "", this),
+            new Among ( "ert", -1, 31, "", this),
+            new Among ( "yt", -1, 33, "", this),
+            new Among ( "iev", -1, 1, "", this),
+            new Among ( "olv", -1, 8, "", this),
+            new Among ( "ax", -1, 14, "", this),
+            new Among ( "ex", -1, 15, "", this),
+            new Among ( "bex", 26, 10, "", this),
+            new Among ( "dex", 26, 11, "", this),
+            new Among ( "pex", 26, 12, "", this),
+            new Among ( "tex", 26, 13, "", this),
+            new Among ( "ix", -1, 16, "", this),
+            new Among ( "lux", -1, 17, "", this),
+            new Among ( "yz", -1, 34, "", this)
+        };
+
+
+        private void copy_from(LovinsStemmer other) {
+            super.copy_from(other);
+        }
+
+        private boolean r_A() {
+            // (, line 21
+            // hop, line 21
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            return true;
+        }
+
+        private boolean r_B() {
+            // (, line 22
+            // hop, line 22
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            return true;
+        }
+
+        private boolean r_C() {
+            // (, line 23
+            // hop, line 23
+            {
+                int c = cursor - 4;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            return true;
+        }
+
+        private boolean r_D() {
+            // (, line 24
+            // hop, line 24
+            {
+                int c = cursor - 5;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            return true;
+        }
+
+        private boolean r_E() {
+            int v_1;
+            int v_2;
+            // (, line 25
+            // test, line 25
+            v_1 = limit - cursor;
+            // hop, line 25
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 25
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 25
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            return true;
+        }
+
+        private boolean r_F() {
+            int v_1;
+            int v_2;
+            // (, line 26
+            // test, line 26
+            v_1 = limit - cursor;
+            // hop, line 26
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 26
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 26
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            return true;
+        }
+
+        private boolean r_G() {
+            int v_1;
+            // (, line 27
+            // test, line 27
+            v_1 = limit - cursor;
+            // hop, line 27
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // literal, line 27
+            if (!(eq_s_b(1, "f")))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_H() {
+            int v_1;
+            int v_2;
+            // (, line 28
+            // test, line 28
+            v_1 = limit - cursor;
+            // hop, line 28
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 28
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 28
+                    if (!(eq_s_b(1, "t")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 28
+                if (!(eq_s_b(2, "ll")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_I() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 29
+            // test, line 29
+            v_1 = limit - cursor;
+            // hop, line 29
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 29
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 29
+                    if (!(eq_s_b(1, "o")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 29
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 29
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            return true;
+        }
+
+        private boolean r_J() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 30
+            // test, line 30
+            v_1 = limit - cursor;
+            // hop, line 30
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 30
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 30
+                    if (!(eq_s_b(1, "a")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 30
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 30
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            return true;
+        }
+
+        private boolean r_K() {
+            int v_1;
+            int v_2;
+            // (, line 31
+            // test, line 31
+            v_1 = limit - cursor;
+            // hop, line 31
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 31
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 31
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                lab2: do {
+                    // literal, line 31
+                    if (!(eq_s_b(1, "i")))
+                    {
+                        break lab2;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // (, line 31
+                // literal, line 31
+                if (!(eq_s_b(1, "e")))
+                {
+                    return false;
+                }
+                // next, line 31
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // literal, line 31
+                if (!(eq_s_b(1, "u")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_L() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 32
+            // test, line 32
+            v_1 = limit - cursor;
+            // hop, line 32
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 32
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 32
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 32
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 32
+                    if (!(eq_s_b(1, "x")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            // not, line 32
+            {
+                v_4 = limit - cursor;
+                lab2: do {
+                    // (, line 32
+                    // literal, line 32
+                    if (!(eq_s_b(1, "s")))
+                    {
+                        break lab2;
+                    }
+                    // not, line 32
+                    {
+                        v_5 = limit - cursor;
+                        lab3: do {
+                            // literal, line 32
+                            if (!(eq_s_b(1, "o")))
+                            {
+                                break lab3;
+                            }
+                            break lab2;
+                        } while (false);
+                        cursor = limit - v_5;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_4;
+            }
+            return true;
+        }
+
+        private boolean r_M() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 33
+            // test, line 33
+            v_1 = limit - cursor;
+            // hop, line 33
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 33
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 33
+                    if (!(eq_s_b(1, "a")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 33
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 33
+                    if (!(eq_s_b(1, "c")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            // not, line 33
+            {
+                v_4 = limit - cursor;
+                lab2: do {
+                    // literal, line 33
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab2;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_4;
+            }
+            // not, line 33
+            {
+                v_5 = limit - cursor;
+                lab3: do {
+                    // literal, line 33
+                    if (!(eq_s_b(1, "m")))
+                    {
+                        break lab3;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_5;
+            }
+            return true;
+        }
+
+        private boolean r_N() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 34
+            // test, line 34
+            v_1 = limit - cursor;
+            // hop, line 34
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // (, line 34
+            // hop, line 34
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // or, line 34
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // not, line 34
+                    {
+                        v_3 = limit - cursor;
+                        lab2: do {
+                            // literal, line 34
+                            if (!(eq_s_b(1, "s")))
+                            {
+                                break lab2;
+                            }
+                            break lab1;
+                        } while (false);
+                        cursor = limit - v_3;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // hop, line 34
+                {
+                    int c = cursor - 2;
+                    if (limit_backward > c || c > limit)
+                    {
+                        return false;
+                    }
+                    cursor = c;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_O() {
+            int v_1;
+            int v_2;
+            // (, line 35
+            // test, line 35
+            v_1 = limit - cursor;
+            // hop, line 35
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 35
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 35
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 35
+                if (!(eq_s_b(1, "i")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_P() {
+            int v_1;
+            int v_2;
+            // (, line 36
+            // test, line 36
+            v_1 = limit - cursor;
+            // hop, line 36
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 36
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 36
+                    if (!(eq_s_b(1, "c")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            return true;
+        }
+
+        private boolean r_Q() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 37
+            // test, line 37
+            v_1 = limit - cursor;
+            // hop, line 37
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // test, line 37
+            v_2 = limit - cursor;
+            // hop, line 37
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_2;
+            // not, line 37
+            {
+                v_3 = limit - cursor;
+                lab0: do {
+                    // literal, line 37
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            // not, line 37
+            {
+                v_4 = limit - cursor;
+                lab1: do {
+                    // literal, line 37
+                    if (!(eq_s_b(1, "n")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_4;
+            }
+            return true;
+        }
+
+        private boolean r_R() {
+            int v_1;
+            int v_2;
+            // (, line 38
+            // test, line 38
+            v_1 = limit - cursor;
+            // hop, line 38
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 38
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 38
+                    if (!(eq_s_b(1, "n")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 38
+                if (!(eq_s_b(1, "r")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_S() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 39
+            // test, line 39
+            v_1 = limit - cursor;
+            // hop, line 39
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 39
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 39
+                    if (!(eq_s_b(2, "dr")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // (, line 39
+                // literal, line 39
+                if (!(eq_s_b(1, "t")))
+                {
+                    return false;
+                }
+                // not, line 39
+                {
+                    v_3 = limit - cursor;
+                    lab2: do {
+                        // literal, line 39
+                        if (!(eq_s_b(1, "t")))
+                        {
+                            break lab2;
+                        }
+                        return false;
+                    } while (false);
+                    cursor = limit - v_3;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_T() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 40
+            // test, line 40
+            v_1 = limit - cursor;
+            // hop, line 40
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 40
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 40
+                    if (!(eq_s_b(1, "s")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // (, line 40
+                // literal, line 40
+                if (!(eq_s_b(1, "t")))
+                {
+                    return false;
+                }
+                // not, line 40
+                {
+                    v_3 = limit - cursor;
+                    lab2: do {
+                        // literal, line 40
+                        if (!(eq_s_b(1, "o")))
+                        {
+                            break lab2;
+                        }
+                        return false;
+                    } while (false);
+                    cursor = limit - v_3;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_U() {
+            int v_1;
+            int v_2;
+            // (, line 41
+            // test, line 41
+            v_1 = limit - cursor;
+            // hop, line 41
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 41
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 41
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                lab2: do {
+                    // literal, line 41
+                    if (!(eq_s_b(1, "m")))
+                    {
+                        break lab2;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                lab3: do {
+                    // literal, line 41
+                    if (!(eq_s_b(1, "n")))
+                    {
+                        break lab3;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 41
+                if (!(eq_s_b(1, "r")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_V() {
+            int v_1;
+            // (, line 42
+            // test, line 42
+            v_1 = limit - cursor;
+            // hop, line 42
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // literal, line 42
+            if (!(eq_s_b(1, "c")))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_W() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 43
+            // test, line 43
+            v_1 = limit - cursor;
+            // hop, line 43
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 43
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 43
+                    if (!(eq_s_b(1, "s")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 43
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 43
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            return true;
+        }
+
+        private boolean r_X() {
+            int v_1;
+            int v_2;
+            // (, line 44
+            // test, line 44
+            v_1 = limit - cursor;
+            // hop, line 44
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // or, line 44
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 44
+                    if (!(eq_s_b(1, "l")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                lab2: do {
+                    // literal, line 44
+                    if (!(eq_s_b(1, "i")))
+                    {
+                        break lab2;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // (, line 44
+                // literal, line 44
+                if (!(eq_s_b(1, "e")))
+                {
+                    return false;
+                }
+                // next, line 44
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // literal, line 44
+                if (!(eq_s_b(1, "u")))
+                {
+                    return false;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_Y() {
+            int v_1;
+            // (, line 45
+            // test, line 45
+            v_1 = limit - cursor;
+            // hop, line 45
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // literal, line 45
+            if (!(eq_s_b(2, "in")))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_Z() {
+            int v_1;
+            int v_2;
+            // (, line 46
+            // test, line 46
+            v_1 = limit - cursor;
+            // hop, line 46
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 46
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 46
+                    if (!(eq_s_b(1, "f")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            return true;
+        }
+
+        private boolean r_AA() {
+            int v_1;
+            // (, line 47
+            // test, line 47
+            v_1 = limit - cursor;
+            // hop, line 47
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // among, line 47
+            if (find_among_b(a_0, 9) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_BB() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 49
+            // test, line 49
+            v_1 = limit - cursor;
+            // hop, line 49
+            {
+                int c = cursor - 3;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // not, line 49
+            {
+                v_2 = limit - cursor;
+                lab0: do {
+                    // literal, line 49
+                    if (!(eq_s_b(3, "met")))
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_2;
+            }
+            // not, line 49
+            {
+                v_3 = limit - cursor;
+                lab1: do {
+                    // literal, line 49
+                    if (!(eq_s_b(4, "ryst")))
+                    {
+                        break lab1;
+                    }
+                    return false;
+                } while (false);
+                cursor = limit - v_3;
+            }
+            return true;
+        }
+
+        private boolean r_CC() {
+            int v_1;
+            // (, line 50
+            // test, line 50
+            v_1 = limit - cursor;
+            // hop, line 50
+            {
+                int c = cursor - 2;
+                if (limit_backward > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            cursor = limit - v_1;
+            // literal, line 50
+            if (!(eq_s_b(1, "l")))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_endings() {
+            int among_var;
+            // (, line 55
+            // [, line 56
+            ket = cursor;
+            // substring, line 56
+            among_var = find_among_b(a_1, 294);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 56
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 145
+                    // delete, line 145
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_undouble() {
+            int v_1;
+            // (, line 151
+            // test, line 152
+            v_1 = limit - cursor;
+            // substring, line 152
+            if (find_among_b(a_2, 10) == 0)
+            {
+                return false;
+            }
+            cursor = limit - v_1;
+            // [, line 154
+            ket = cursor;
+            // next, line 154
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 154
+            bra = cursor;
+            // delete, line 154
+            slice_del();
+            return true;
+        }
+
+        private boolean r_respell() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            // (, line 159
+            // [, line 160
+            ket = cursor;
+            // substring, line 160
+            among_var = find_among_b(a_3, 34);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 160
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 161
+                    // <-, line 161
+                    slice_from("ief");
+                    break;
+                case 2:
+                    // (, line 162
+                    // <-, line 162
+                    slice_from("uc");
+                    break;
+                case 3:
+                    // (, line 163
+                    // <-, line 163
+                    slice_from("um");
+                    break;
+                case 4:
+                    // (, line 164
+                    // <-, line 164
+                    slice_from("rb");
+                    break;
+                case 5:
+                    // (, line 165
+                    // <-, line 165
+                    slice_from("ur");
+                    break;
+                case 6:
+                    // (, line 166
+                    // <-, line 166
+                    slice_from("ister");
+                    break;
+                case 7:
+                    // (, line 167
+                    // <-, line 167
+                    slice_from("meter");
+                    break;
+                case 8:
+                    // (, line 168
+                    // <-, line 168
+                    slice_from("olut");
+                    break;
+                case 9:
+                    // (, line 169
+                    // not, line 169
+                    {
+                        v_1 = limit - cursor;
+                        lab0: do {
+                            // literal, line 169
+                            if (!(eq_s_b(1, "a")))
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_1;
+                    }
+                    // not, line 169
+                    {
+                        v_2 = limit - cursor;
+                        lab1: do {
+                            // literal, line 169
+                            if (!(eq_s_b(1, "i")))
+                            {
+                                break lab1;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_2;
+                    }
+                    // not, line 169
+                    {
+                        v_3 = limit - cursor;
+                        lab2: do {
+                            // literal, line 169
+                            if (!(eq_s_b(1, "o")))
+                            {
+                                break lab2;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_3;
+                    }
+                    // <-, line 169
+                    slice_from("l");
+                    break;
+                case 10:
+                    // (, line 170
+                    // <-, line 170
+                    slice_from("bic");
+                    break;
+                case 11:
+                    // (, line 171
+                    // <-, line 171
+                    slice_from("dic");
+                    break;
+                case 12:
+                    // (, line 172
+                    // <-, line 172
+                    slice_from("pic");
+                    break;
+                case 13:
+                    // (, line 173
+                    // <-, line 173
+                    slice_from("tic");
+                    break;
+                case 14:
+                    // (, line 174
+                    // <-, line 174
+                    slice_from("ac");
+                    break;
+                case 15:
+                    // (, line 175
+                    // <-, line 175
+                    slice_from("ec");
+                    break;
+                case 16:
+                    // (, line 176
+                    // <-, line 176
+                    slice_from("ic");
+                    break;
+                case 17:
+                    // (, line 177
+                    // <-, line 177
+                    slice_from("luc");
+                    break;
+                case 18:
+                    // (, line 178
+                    // <-, line 178
+                    slice_from("uas");
+                    break;
+                case 19:
+                    // (, line 179
+                    // <-, line 179
+                    slice_from("vas");
+                    break;
+                case 20:
+                    // (, line 180
+                    // <-, line 180
+                    slice_from("cis");
+                    break;
+                case 21:
+                    // (, line 181
+                    // <-, line 181
+                    slice_from("lis");
+                    break;
+                case 22:
+                    // (, line 182
+                    // <-, line 182
+                    slice_from("eris");
+                    break;
+                case 23:
+                    // (, line 183
+                    // <-, line 183
+                    slice_from("pans");
+                    break;
+                case 24:
+                    // (, line 184
+                    // not, line 184
+                    {
+                        v_4 = limit - cursor;
+                        lab3: do {
+                            // literal, line 184
+                            if (!(eq_s_b(1, "s")))
+                            {
+                                break lab3;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_4;
+                    }
+                    // <-, line 184
+                    slice_from("ens");
+                    break;
+                case 25:
+                    // (, line 185
+                    // <-, line 185
+                    slice_from("ons");
+                    break;
+                case 26:
+                    // (, line 186
+                    // <-, line 186
+                    slice_from("lus");
+                    break;
+                case 27:
+                    // (, line 187
+                    // <-, line 187
+                    slice_from("rus");
+                    break;
+                case 28:
+                    // (, line 188
+                    // not, line 188
+                    {
+                        v_5 = limit - cursor;
+                        lab4: do {
+                            // literal, line 188
+                            if (!(eq_s_b(1, "p")))
+                            {
+                                break lab4;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_5;
+                    }
+                    // not, line 188
+                    {
+                        v_6 = limit - cursor;
+                        lab5: do {
+                            // literal, line 188
+                            if (!(eq_s_b(1, "t")))
+                            {
+                                break lab5;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_6;
+                    }
+                    // <-, line 188
+                    slice_from("hes");
+                    break;
+                case 29:
+                    // (, line 189
+                    // <-, line 189
+                    slice_from("mis");
+                    break;
+                case 30:
+                    // (, line 190
+                    // not, line 190
+                    {
+                        v_7 = limit - cursor;
+                        lab6: do {
+                            // literal, line 190
+                            if (!(eq_s_b(1, "m")))
+                            {
+                                break lab6;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_7;
+                    }
+                    // <-, line 190
+                    slice_from("ens");
+                    break;
+                case 31:
+                    // (, line 192
+                    // <-, line 192
+                    slice_from("ers");
+                    break;
+                case 32:
+                    // (, line 193
+                    // not, line 193
+                    {
+                        v_8 = limit - cursor;
+                        lab7: do {
+                            // literal, line 193
+                            if (!(eq_s_b(1, "n")))
+                            {
+                                break lab7;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_8;
+                    }
+                    // <-, line 193
+                    slice_from("es");
+                    break;
+                case 33:
+                    // (, line 194
+                    // <-, line 194
+                    slice_from("ys");
+                    break;
+                case 34:
+                    // (, line 195
+                    // <-, line 195
+                    slice_from("ys");
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 200
+            // backwards, line 202
+            limit_backward = cursor; cursor = limit;
+            // (, line 202
+            // do, line 203
+            v_1 = limit - cursor;
+            lab0: do {
+                // call endings, line 203
+                if (!r_endings())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // do, line 204
+            v_2 = limit - cursor;
+            lab1: do {
+                // call undouble, line 204
+                if (!r_undouble())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 205
+            v_3 = limit - cursor;
+            lab2: do {
+                // call respell, line 205
+                if (!r_respell())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/NorwegianStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/NorwegianStemmer.java
new file mode 100644
index 0000000..b2a3c29
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/NorwegianStemmer.java
@@ -0,0 +1,358 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class NorwegianStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "a", -1, 1, "", this),
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "ede", 1, 1, "", this),
+            new Among ( "ande", 1, 1, "", this),
+            new Among ( "ende", 1, 1, "", this),
+            new Among ( "ane", 1, 1, "", this),
+            new Among ( "ene", 1, 1, "", this),
+            new Among ( "hetene", 6, 1, "", this),
+            new Among ( "erte", 1, 3, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "heten", 9, 1, "", this),
+            new Among ( "ar", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "heter", 12, 1, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "as", 14, 1, "", this),
+            new Among ( "es", 14, 1, "", this),
+            new Among ( "edes", 16, 1, "", this),
+            new Among ( "endes", 16, 1, "", this),
+            new Among ( "enes", 16, 1, "", this),
+            new Among ( "hetenes", 19, 1, "", this),
+            new Among ( "ens", 14, 1, "", this),
+            new Among ( "hetens", 21, 1, "", this),
+            new Among ( "ers", 14, 1, "", this),
+            new Among ( "ets", 14, 1, "", this),
+            new Among ( "et", -1, 1, "", this),
+            new Among ( "het", 25, 1, "", this),
+            new Among ( "ert", -1, 3, "", this),
+            new Among ( "ast", -1, 1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "dt", -1, -1, "", this),
+            new Among ( "vt", -1, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "leg", -1, 1, "", this),
+            new Among ( "eleg", 0, 1, "", this),
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "eig", 2, 1, "", this),
+            new Among ( "lig", 2, 1, "", this),
+            new Among ( "elig", 4, 1, "", this),
+            new Among ( "els", -1, 1, "", this),
+            new Among ( "lov", -1, 1, "", this),
+            new Among ( "elov", 7, 1, "", this),
+            new Among ( "slov", 7, 1, "", this),
+            new Among ( "hetslov", 9, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 128 };
+
+        private static final char g_s_ending[] = {119, 125, 149, 1 };
+
+        private int I_x;
+        private int I_p1;
+
+        private void copy_from(NorwegianStemmer other) {
+            I_x = other.I_x;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            // (, line 26
+            I_p1 = limit;
+            // test, line 30
+            v_1 = cursor;
+            // (, line 30
+            // hop, line 30
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // setmark x, line 30
+            I_x = cursor;
+            cursor = v_1;
+            // goto, line 31
+            golab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 248)))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_2;
+                    break golab0;
+                } while (false);
+                cursor = v_2;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 31
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 248)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 31
+            I_p1 = cursor;
+            // try, line 32
+            lab4: do {
+                // (, line 32
+                if (!(I_p1 < I_x))
+                {
+                    break lab4;
+                }
+                I_p1 = I_x;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_main_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 37
+            // setlimit, line 38
+            v_1 = limit - cursor;
+            // tomark, line 38
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 38
+            // [, line 38
+            ket = cursor;
+            // substring, line 38
+            among_var = find_among_b(a_0, 29);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 38
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 44
+                    // delete, line 44
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 46
+                    // or, line 46
+                    lab0: do {
+                        v_3 = limit - cursor;
+                        lab1: do {
+                            if (!(in_grouping_b(g_s_ending, 98, 122)))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_3;
+                        // (, line 46
+                        // literal, line 46
+                        if (!(eq_s_b(1, "k")))
+                        {
+                            return false;
+                        }
+                        if (!(out_grouping_b(g_v, 97, 248)))
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 46
+                    slice_del();
+                    break;
+                case 3:
+                    // (, line 48
+                    // <-, line 48
+                    slice_from("er");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_consonant_pair() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 52
+            // test, line 53
+            v_1 = limit - cursor;
+            // (, line 53
+            // setlimit, line 54
+            v_2 = limit - cursor;
+            // tomark, line 54
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_3 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_2;
+            // (, line 54
+            // [, line 54
+            ket = cursor;
+            // substring, line 54
+            if (find_among_b(a_1, 2) == 0)
+            {
+                limit_backward = v_3;
+                return false;
+            }
+            // ], line 54
+            bra = cursor;
+            limit_backward = v_3;
+            cursor = limit - v_1;
+            // next, line 59
+            if (cursor <= limit_backward)
+            {
+                return false;
+            }
+            cursor--;
+            // ], line 59
+            bra = cursor;
+            // delete, line 59
+            slice_del();
+            return true;
+        }
+
+        private boolean r_other_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 62
+            // setlimit, line 63
+            v_1 = limit - cursor;
+            // tomark, line 63
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 63
+            // [, line 63
+            ket = cursor;
+            // substring, line 63
+            among_var = find_among_b(a_2, 11);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 63
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 67
+                    // delete, line 67
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 72
+            // do, line 74
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 74
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 75
+            limit_backward = cursor; cursor = limit;
+            // (, line 75
+            // do, line 76
+            v_2 = limit - cursor;
+            lab1: do {
+                // call main_suffix, line 76
+                if (!r_main_suffix())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 77
+            v_3 = limit - cursor;
+            lab2: do {
+                // call consonant_pair, line 77
+                if (!r_consonant_pair())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 78
+            v_4 = limit - cursor;
+            lab3: do {
+                // call other_suffix, line 78
+                if (!r_other_suffix())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/PorterStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/PorterStemmer.java
new file mode 100644
index 0000000..4ef1b60
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/PorterStemmer.java
@@ -0,0 +1,906 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class PorterStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "s", -1, 3, "", this),
+            new Among ( "ies", 0, 2, "", this),
+            new Among ( "sses", 0, 1, "", this),
+            new Among ( "ss", 0, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "bb", 0, 2, "", this),
+            new Among ( "dd", 0, 2, "", this),
+            new Among ( "ff", 0, 2, "", this),
+            new Among ( "gg", 0, 2, "", this),
+            new Among ( "bl", 0, 1, "", this),
+            new Among ( "mm", 0, 2, "", this),
+            new Among ( "nn", 0, 2, "", this),
+            new Among ( "pp", 0, 2, "", this),
+            new Among ( "rr", 0, 2, "", this),
+            new Among ( "at", 0, 1, "", this),
+            new Among ( "tt", 0, 2, "", this),
+            new Among ( "iz", 0, 1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ed", -1, 2, "", this),
+            new Among ( "eed", 0, 1, "", this),
+            new Among ( "ing", -1, 2, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "anci", -1, 3, "", this),
+            new Among ( "enci", -1, 2, "", this),
+            new Among ( "abli", -1, 4, "", this),
+            new Among ( "eli", -1, 6, "", this),
+            new Among ( "alli", -1, 9, "", this),
+            new Among ( "ousli", -1, 12, "", this),
+            new Among ( "entli", -1, 5, "", this),
+            new Among ( "aliti", -1, 10, "", this),
+            new Among ( "biliti", -1, 14, "", this),
+            new Among ( "iviti", -1, 13, "", this),
+            new Among ( "tional", -1, 1, "", this),
+            new Among ( "ational", 10, 8, "", this),
+            new Among ( "alism", -1, 10, "", this),
+            new Among ( "ation", -1, 8, "", this),
+            new Among ( "ization", 13, 7, "", this),
+            new Among ( "izer", -1, 7, "", this),
+            new Among ( "ator", -1, 8, "", this),
+            new Among ( "iveness", -1, 13, "", this),
+            new Among ( "fulness", -1, 11, "", this),
+            new Among ( "ousness", -1, 12, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "icate", -1, 2, "", this),
+            new Among ( "ative", -1, 3, "", this),
+            new Among ( "alize", -1, 1, "", this),
+            new Among ( "iciti", -1, 2, "", this),
+            new Among ( "ical", -1, 2, "", this),
+            new Among ( "ful", -1, 3, "", this),
+            new Among ( "ness", -1, 3, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "ance", -1, 1, "", this),
+            new Among ( "ence", -1, 1, "", this),
+            new Among ( "able", -1, 1, "", this),
+            new Among ( "ible", -1, 1, "", this),
+            new Among ( "ate", -1, 1, "", this),
+            new Among ( "ive", -1, 1, "", this),
+            new Among ( "ize", -1, 1, "", this),
+            new Among ( "iti", -1, 1, "", this),
+            new Among ( "al", -1, 1, "", this),
+            new Among ( "ism", -1, 1, "", this),
+            new Among ( "ion", -1, 2, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "ous", -1, 1, "", this),
+            new Among ( "ant", -1, 1, "", this),
+            new Among ( "ent", -1, 1, "", this),
+            new Among ( "ment", 15, 1, "", this),
+            new Among ( "ement", 16, 1, "", this),
+            new Among ( "ou", -1, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1 };
+
+        private static final char g_v_WXY[] = {1, 17, 65, 208, 1 };
+
+        private boolean B_Y_found;
+        private int I_p2;
+        private int I_p1;
+
+        private void copy_from(PorterStemmer other) {
+            B_Y_found = other.B_Y_found;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_shortv() {
+            // (, line 19
+            if (!(out_grouping_b(g_v_WXY, 89, 121)))
+            {
+                return false;
+            }
+            if (!(in_grouping_b(g_v, 97, 121)))
+            {
+                return false;
+            }
+            if (!(out_grouping_b(g_v, 97, 121)))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1a() {
+            int among_var;
+            // (, line 24
+            // [, line 25
+            ket = cursor;
+            // substring, line 25
+            among_var = find_among_b(a_0, 4);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 25
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 26
+                    // <-, line 26
+                    slice_from("ss");
+                    break;
+                case 2:
+                    // (, line 27
+                    // <-, line 27
+                    slice_from("i");
+                    break;
+                case 3:
+                    // (, line 29
+                    // delete, line 29
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1b() {
+            int among_var;
+            int v_1;
+            int v_3;
+            int v_4;
+            // (, line 33
+            // [, line 34
+            ket = cursor;
+            // substring, line 34
+            among_var = find_among_b(a_2, 3);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 34
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 35
+                    // call R1, line 35
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // <-, line 35
+                    slice_from("ee");
+                    break;
+                case 2:
+                    // (, line 37
+                    // test, line 38
+                    v_1 = limit - cursor;
+                    // gopast, line 38
+                    golab0: while(true)
+                    {
+                        lab1: do {
+                            if (!(in_grouping_b(g_v, 97, 121)))
+                            {
+                                break lab1;
+                            }
+                            break golab0;
+                        } while (false);
+                        if (cursor <= limit_backward)
+                        {
+                            return false;
+                        }
+                        cursor--;
+                    }
+                    cursor = limit - v_1;
+                    // delete, line 38
+                    slice_del();
+                    // test, line 39
+                    v_3 = limit - cursor;
+                    // substring, line 39
+                    among_var = find_among_b(a_1, 13);
+                    if (among_var == 0)
+                    {
+                        return false;
+                    }
+                    cursor = limit - v_3;
+                    switch(among_var) {
+                        case 0:
+                            return false;
+                        case 1:
+                            // (, line 41
+                            // <+, line 41
+                            {
+                                int c = cursor;
+                                insert(cursor, cursor, "e");
+                                cursor = c;
+                            }
+                            break;
+                        case 2:
+                            // (, line 44
+                            // [, line 44
+                            ket = cursor;
+                            // next, line 44
+                            if (cursor <= limit_backward)
+                            {
+                                return false;
+                            }
+                            cursor--;
+                            // ], line 44
+                            bra = cursor;
+                            // delete, line 44
+                            slice_del();
+                            break;
+                        case 3:
+                            // (, line 45
+                            // atmark, line 45
+                            if (cursor != I_p1)
+                            {
+                                return false;
+                            }
+                            // test, line 45
+                            v_4 = limit - cursor;
+                            // call shortv, line 45
+                            if (!r_shortv())
+                            {
+                                return false;
+                            }
+                            cursor = limit - v_4;
+                            // <+, line 45
+                            {
+                                int c = cursor;
+                                insert(cursor, cursor, "e");
+                                cursor = c;
+                            }
+                            break;
+                    }
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_1c() {
+            int v_1;
+            // (, line 51
+            // [, line 52
+            ket = cursor;
+            // or, line 52
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // literal, line 52
+                    if (!(eq_s_b(1, "y")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // literal, line 52
+                if (!(eq_s_b(1, "Y")))
+                {
+                    return false;
+                }
+            } while (false);
+            // ], line 52
+            bra = cursor;
+            // gopast, line 53
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(in_grouping_b(g_v, 97, 121)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+            }
+            // <-, line 54
+            slice_from("i");
+            return true;
+        }
+
+        private boolean r_Step_2() {
+            int among_var;
+            // (, line 57
+            // [, line 58
+            ket = cursor;
+            // substring, line 58
+            among_var = find_among_b(a_3, 20);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 58
+            bra = cursor;
+            // call R1, line 58
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 59
+                    // <-, line 59
+                    slice_from("tion");
+                    break;
+                case 2:
+                    // (, line 60
+                    // <-, line 60
+                    slice_from("ence");
+                    break;
+                case 3:
+                    // (, line 61
+                    // <-, line 61
+                    slice_from("ance");
+                    break;
+                case 4:
+                    // (, line 62
+                    // <-, line 62
+                    slice_from("able");
+                    break;
+                case 5:
+                    // (, line 63
+                    // <-, line 63
+                    slice_from("ent");
+                    break;
+                case 6:
+                    // (, line 64
+                    // <-, line 64
+                    slice_from("e");
+                    break;
+                case 7:
+                    // (, line 66
+                    // <-, line 66
+                    slice_from("ize");
+                    break;
+                case 8:
+                    // (, line 68
+                    // <-, line 68
+                    slice_from("ate");
+                    break;
+                case 9:
+                    // (, line 69
+                    // <-, line 69
+                    slice_from("al");
+                    break;
+                case 10:
+                    // (, line 71
+                    // <-, line 71
+                    slice_from("al");
+                    break;
+                case 11:
+                    // (, line 72
+                    // <-, line 72
+                    slice_from("ful");
+                    break;
+                case 12:
+                    // (, line 74
+                    // <-, line 74
+                    slice_from("ous");
+                    break;
+                case 13:
+                    // (, line 76
+                    // <-, line 76
+                    slice_from("ive");
+                    break;
+                case 14:
+                    // (, line 77
+                    // <-, line 77
+                    slice_from("ble");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_3() {
+            int among_var;
+            // (, line 81
+            // [, line 82
+            ket = cursor;
+            // substring, line 82
+            among_var = find_among_b(a_4, 7);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 82
+            bra = cursor;
+            // call R1, line 82
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 83
+                    // <-, line 83
+                    slice_from("al");
+                    break;
+                case 2:
+                    // (, line 85
+                    // <-, line 85
+                    slice_from("ic");
+                    break;
+                case 3:
+                    // (, line 87
+                    // delete, line 87
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_4() {
+            int among_var;
+            int v_1;
+            // (, line 91
+            // [, line 92
+            ket = cursor;
+            // substring, line 92
+            among_var = find_among_b(a_5, 19);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 92
+            bra = cursor;
+            // call R2, line 92
+            if (!r_R2())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 95
+                    // delete, line 95
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 96
+                    // or, line 96
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // literal, line 96
+                            if (!(eq_s_b(1, "s")))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // literal, line 96
+                        if (!(eq_s_b(1, "t")))
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 96
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_Step_5a() {
+            int v_1;
+            int v_2;
+            // (, line 100
+            // [, line 101
+            ket = cursor;
+            // literal, line 101
+            if (!(eq_s_b(1, "e")))
+            {
+                return false;
+            }
+            // ], line 101
+            bra = cursor;
+            // or, line 102
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // call R2, line 102
+                    if (!r_R2())
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 102
+                // call R1, line 102
+                if (!r_R1())
+                {
+                    return false;
+                }
+                // not, line 102
+                {
+                    v_2 = limit - cursor;
+                    lab2: do {
+                        // call shortv, line 102
+                        if (!r_shortv())
+                        {
+                            break lab2;
+                        }
+                        return false;
+                    } while (false);
+                    cursor = limit - v_2;
+                }
+            } while (false);
+            // delete, line 103
+            slice_del();
+            return true;
+        }
+
+        private boolean r_Step_5b() {
+            // (, line 106
+            // [, line 107
+            ket = cursor;
+            // literal, line 107
+            if (!(eq_s_b(1, "l")))
+            {
+                return false;
+            }
+            // ], line 107
+            bra = cursor;
+            // call R2, line 108
+            if (!r_R2())
+            {
+                return false;
+            }
+            // literal, line 108
+            if (!(eq_s_b(1, "l")))
+            {
+                return false;
+            }
+            // delete, line 109
+            slice_del();
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_10;
+            int v_11;
+            int v_12;
+            int v_13;
+            int v_14;
+            int v_15;
+            int v_16;
+            int v_17;
+            int v_18;
+            int v_19;
+            int v_20;
+            // (, line 113
+            // unset Y_found, line 115
+            B_Y_found = false;
+            // do, line 116
+            v_1 = cursor;
+            lab0: do {
+                // (, line 116
+                // [, line 116
+                bra = cursor;
+                // literal, line 116
+                if (!(eq_s(1, "y")))
+                {
+                    break lab0;
+                }
+                // ], line 116
+                ket = cursor;
+                // <-, line 116
+                slice_from("Y");
+                // set Y_found, line 116
+                B_Y_found = true;
+            } while (false);
+            cursor = v_1;
+            // do, line 117
+            v_2 = cursor;
+            lab1: do {
+                // repeat, line 117
+                replab2: while(true)
+                {
+                    v_3 = cursor;
+                    lab3: do {
+                        // (, line 117
+                        // goto, line 117
+                        golab4: while(true)
+                        {
+                            v_4 = cursor;
+                            lab5: do {
+                                // (, line 117
+                                if (!(in_grouping(g_v, 97, 121)))
+                                {
+                                    break lab5;
+                                }
+                                // [, line 117
+                                bra = cursor;
+                                // literal, line 117
+                                if (!(eq_s(1, "y")))
+                                {
+                                    break lab5;
+                                }
+                                // ], line 117
+                                ket = cursor;
+                                cursor = v_4;
+                                break golab4;
+                            } while (false);
+                            cursor = v_4;
+                            if (cursor >= limit)
+                            {
+                                break lab3;
+                            }
+                            cursor++;
+                        }
+                        // <-, line 117
+                        slice_from("Y");
+                        // set Y_found, line 117
+                        B_Y_found = true;
+                        continue replab2;
+                    } while (false);
+                    cursor = v_3;
+                    break replab2;
+                }
+            } while (false);
+            cursor = v_2;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 121
+            v_5 = cursor;
+            lab6: do {
+                // (, line 121
+                // gopast, line 122
+                golab7: while(true)
+                {
+                    lab8: do {
+                        if (!(in_grouping(g_v, 97, 121)))
+                        {
+                            break lab8;
+                        }
+                        break golab7;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // gopast, line 122
+                golab9: while(true)
+                {
+                    lab10: do {
+                        if (!(out_grouping(g_v, 97, 121)))
+                        {
+                            break lab10;
+                        }
+                        break golab9;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 122
+                I_p1 = cursor;
+                // gopast, line 123
+                golab11: while(true)
+                {
+                    lab12: do {
+                        if (!(in_grouping(g_v, 97, 121)))
+                        {
+                            break lab12;
+                        }
+                        break golab11;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // gopast, line 123
+                golab13: while(true)
+                {
+                    lab14: do {
+                        if (!(out_grouping(g_v, 97, 121)))
+                        {
+                            break lab14;
+                        }
+                        break golab13;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab6;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 123
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_5;
+            // backwards, line 126
+            limit_backward = cursor; cursor = limit;
+            // (, line 126
+            // do, line 127
+            v_10 = limit - cursor;
+            lab15: do {
+                // call Step_1a, line 127
+                if (!r_Step_1a())
+                {
+                    break lab15;
+                }
+            } while (false);
+            cursor = limit - v_10;
+            // do, line 128
+            v_11 = limit - cursor;
+            lab16: do {
+                // call Step_1b, line 128
+                if (!r_Step_1b())
+                {
+                    break lab16;
+                }
+            } while (false);
+            cursor = limit - v_11;
+            // do, line 129
+            v_12 = limit - cursor;
+            lab17: do {
+                // call Step_1c, line 129
+                if (!r_Step_1c())
+                {
+                    break lab17;
+                }
+            } while (false);
+            cursor = limit - v_12;
+            // do, line 130
+            v_13 = limit - cursor;
+            lab18: do {
+                // call Step_2, line 130
+                if (!r_Step_2())
+                {
+                    break lab18;
+                }
+            } while (false);
+            cursor = limit - v_13;
+            // do, line 131
+            v_14 = limit - cursor;
+            lab19: do {
+                // call Step_3, line 131
+                if (!r_Step_3())
+                {
+                    break lab19;
+                }
+            } while (false);
+            cursor = limit - v_14;
+            // do, line 132
+            v_15 = limit - cursor;
+            lab20: do {
+                // call Step_4, line 132
+                if (!r_Step_4())
+                {
+                    break lab20;
+                }
+            } while (false);
+            cursor = limit - v_15;
+            // do, line 133
+            v_16 = limit - cursor;
+            lab21: do {
+                // call Step_5a, line 133
+                if (!r_Step_5a())
+                {
+                    break lab21;
+                }
+            } while (false);
+            cursor = limit - v_16;
+            // do, line 134
+            v_17 = limit - cursor;
+            lab22: do {
+                // call Step_5b, line 134
+                if (!r_Step_5b())
+                {
+                    break lab22;
+                }
+            } while (false);
+            cursor = limit - v_17;
+            cursor = limit_backward;            // do, line 137
+            v_18 = cursor;
+            lab23: do {
+                // (, line 137
+                // Boolean test Y_found, line 137
+                if (!(B_Y_found))
+                {
+                    break lab23;
+                }
+                // repeat, line 137
+                replab24: while(true)
+                {
+                    v_19 = cursor;
+                    lab25: do {
+                        // (, line 137
+                        // goto, line 137
+                        golab26: while(true)
+                        {
+                            v_20 = cursor;
+                            lab27: do {
+                                // (, line 137
+                                // [, line 137
+                                bra = cursor;
+                                // literal, line 137
+                                if (!(eq_s(1, "Y")))
+                                {
+                                    break lab27;
+                                }
+                                // ], line 137
+                                ket = cursor;
+                                cursor = v_20;
+                                break golab26;
+                            } while (false);
+                            cursor = v_20;
+                            if (cursor >= limit)
+                            {
+                                break lab25;
+                            }
+                            cursor++;
+                        }
+                        // <-, line 137
+                        slice_from("y");
+                        continue replab24;
+                    } while (false);
+                    cursor = v_19;
+                    break replab24;
+                }
+            } while (false);
+            cursor = v_18;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/PortugueseStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/PortugueseStemmer.java
new file mode 100644
index 0000000..cbd20d6
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/PortugueseStemmer.java
@@ -0,0 +1,1116 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class PortugueseStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "\u00E3", 0, 1, "", this),
+            new Among ( "\u00F5", 0, 2, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "a~", 0, 1, "", this),
+            new Among ( "o~", 0, 2, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ic", -1, -1, "", this),
+            new Among ( "ad", -1, -1, "", this),
+            new Among ( "os", -1, -1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ante", -1, 1, "", this),
+            new Among ( "avel", -1, 1, "", this),
+            new Among ( "\u00EDvel", -1, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "abil", -1, 1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ica", -1, 1, "", this),
+            new Among ( "\u00E2ncia", -1, 1, "", this),
+            new Among ( "\u00EAncia", -1, 4, "", this),
+            new Among ( "ira", -1, 9, "", this),
+            new Among ( "adora", -1, 1, "", this),
+            new Among ( "osa", -1, 1, "", this),
+            new Among ( "ista", -1, 1, "", this),
+            new Among ( "iva", -1, 8, "", this),
+            new Among ( "eza", -1, 1, "", this),
+            new Among ( "log\u00EDa", -1, 2, "", this),
+            new Among ( "idade", -1, 7, "", this),
+            new Among ( "ante", -1, 1, "", this),
+            new Among ( "mente", -1, 6, "", this),
+            new Among ( "amente", 12, 5, "", this),
+            new Among ( "\u00E1vel", -1, 1, "", this),
+            new Among ( "\u00EDvel", -1, 1, "", this),
+            new Among ( "uci\u00F3n", -1, 3, "", this),
+            new Among ( "ico", -1, 1, "", this),
+            new Among ( "ismo", -1, 1, "", this),
+            new Among ( "oso", -1, 1, "", this),
+            new Among ( "amento", -1, 1, "", this),
+            new Among ( "imento", -1, 1, "", this),
+            new Among ( "ivo", -1, 8, "", this),
+            new Among ( "a\u00E7a~o", -1, 1, "", this),
+            new Among ( "ador", -1, 1, "", this),
+            new Among ( "icas", -1, 1, "", this),
+            new Among ( "\u00EAncias", -1, 4, "", this),
+            new Among ( "iras", -1, 9, "", this),
+            new Among ( "adoras", -1, 1, "", this),
+            new Among ( "osas", -1, 1, "", this),
+            new Among ( "istas", -1, 1, "", this),
+            new Among ( "ivas", -1, 8, "", this),
+            new Among ( "ezas", -1, 1, "", this),
+            new Among ( "log\u00EDas", -1, 2, "", this),
+            new Among ( "idades", -1, 7, "", this),
+            new Among ( "uciones", -1, 3, "", this),
+            new Among ( "adores", -1, 1, "", this),
+            new Among ( "antes", -1, 1, "", this),
+            new Among ( "a\u00E7o~es", -1, 1, "", this),
+            new Among ( "icos", -1, 1, "", this),
+            new Among ( "ismos", -1, 1, "", this),
+            new Among ( "osos", -1, 1, "", this),
+            new Among ( "amentos", -1, 1, "", this),
+            new Among ( "imentos", -1, 1, "", this),
+            new Among ( "ivos", -1, 8, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "ada", -1, 1, "", this),
+            new Among ( "ida", -1, 1, "", this),
+            new Among ( "ia", -1, 1, "", this),
+            new Among ( "aria", 2, 1, "", this),
+            new Among ( "eria", 2, 1, "", this),
+            new Among ( "iria", 2, 1, "", this),
+            new Among ( "ara", -1, 1, "", this),
+            new Among ( "era", -1, 1, "", this),
+            new Among ( "ira", -1, 1, "", this),
+            new Among ( "ava", -1, 1, "", this),
+            new Among ( "asse", -1, 1, "", this),
+            new Among ( "esse", -1, 1, "", this),
+            new Among ( "isse", -1, 1, "", this),
+            new Among ( "aste", -1, 1, "", this),
+            new Among ( "este", -1, 1, "", this),
+            new Among ( "iste", -1, 1, "", this),
+            new Among ( "ei", -1, 1, "", this),
+            new Among ( "arei", 16, 1, "", this),
+            new Among ( "erei", 16, 1, "", this),
+            new Among ( "irei", 16, 1, "", this),
+            new Among ( "am", -1, 1, "", this),
+            new Among ( "iam", 20, 1, "", this),
+            new Among ( "ariam", 21, 1, "", this),
+            new Among ( "eriam", 21, 1, "", this),
+            new Among ( "iriam", 21, 1, "", this),
+            new Among ( "aram", 20, 1, "", this),
+            new Among ( "eram", 20, 1, "", this),
+            new Among ( "iram", 20, 1, "", this),
+            new Among ( "avam", 20, 1, "", this),
+            new Among ( "em", -1, 1, "", this),
+            new Among ( "arem", 29, 1, "", this),
+            new Among ( "erem", 29, 1, "", this),
+            new Among ( "irem", 29, 1, "", this),
+            new Among ( "assem", 29, 1, "", this),
+            new Among ( "essem", 29, 1, "", this),
+            new Among ( "issem", 29, 1, "", this),
+            new Among ( "ado", -1, 1, "", this),
+            new Among ( "ido", -1, 1, "", this),
+            new Among ( "ando", -1, 1, "", this),
+            new Among ( "endo", -1, 1, "", this),
+            new Among ( "indo", -1, 1, "", this),
+            new Among ( "ara~o", -1, 1, "", this),
+            new Among ( "era~o", -1, 1, "", this),
+            new Among ( "ira~o", -1, 1, "", this),
+            new Among ( "ar", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "ir", -1, 1, "", this),
+            new Among ( "as", -1, 1, "", this),
+            new Among ( "adas", 47, 1, "", this),
+            new Among ( "idas", 47, 1, "", this),
+            new Among ( "ias", 47, 1, "", this),
+            new Among ( "arias", 50, 1, "", this),
+            new Among ( "erias", 50, 1, "", this),
+            new Among ( "irias", 50, 1, "", this),
+            new Among ( "aras", 47, 1, "", this),
+            new Among ( "eras", 47, 1, "", this),
+            new Among ( "iras", 47, 1, "", this),
+            new Among ( "avas", 47, 1, "", this),
+            new Among ( "es", -1, 1, "", this),
+            new Among ( "ardes", 58, 1, "", this),
+            new Among ( "erdes", 58, 1, "", this),
+            new Among ( "irdes", 58, 1, "", this),
+            new Among ( "ares", 58, 1, "", this),
+            new Among ( "eres", 58, 1, "", this),
+            new Among ( "ires", 58, 1, "", this),
+            new Among ( "asses", 58, 1, "", this),
+            new Among ( "esses", 58, 1, "", this),
+            new Among ( "isses", 58, 1, "", this),
+            new Among ( "astes", 58, 1, "", this),
+            new Among ( "estes", 58, 1, "", this),
+            new Among ( "istes", 58, 1, "", this),
+            new Among ( "is", -1, 1, "", this),
+            new Among ( "ais", 71, 1, "", this),
+            new Among ( "eis", 71, 1, "", this),
+            new Among ( "areis", 73, 1, "", this),
+            new Among ( "ereis", 73, 1, "", this),
+            new Among ( "ireis", 73, 1, "", this),
+            new Among ( "\u00E1reis", 73, 1, "", this),
+            new Among ( "\u00E9reis", 73, 1, "", this),
+            new Among ( "\u00EDreis", 73, 1, "", this),
+            new Among ( "\u00E1sseis", 73, 1, "", this),
+            new Among ( "\u00E9sseis", 73, 1, "", this),
+            new Among ( "\u00EDsseis", 73, 1, "", this),
+            new Among ( "\u00E1veis", 73, 1, "", this),
+            new Among ( "\u00EDeis", 73, 1, "", this),
+            new Among ( "ar\u00EDeis", 84, 1, "", this),
+            new Among ( "er\u00EDeis", 84, 1, "", this),
+            new Among ( "ir\u00EDeis", 84, 1, "", this),
+            new Among ( "ados", -1, 1, "", this),
+            new Among ( "idos", -1, 1, "", this),
+            new Among ( "amos", -1, 1, "", this),
+            new Among ( "\u00E1ramos", 90, 1, "", this),
+            new Among ( "\u00E9ramos", 90, 1, "", this),
+            new Among ( "\u00EDramos", 90, 1, "", this),
+            new Among ( "\u00E1vamos", 90, 1, "", this),
+            new Among ( "\u00EDamos", 90, 1, "", this),
+            new Among ( "ar\u00EDamos", 95, 1, "", this),
+            new Among ( "er\u00EDamos", 95, 1, "", this),
+            new Among ( "ir\u00EDamos", 95, 1, "", this),
+            new Among ( "emos", -1, 1, "", this),
+            new Among ( "aremos", 99, 1, "", this),
+            new Among ( "eremos", 99, 1, "", this),
+            new Among ( "iremos", 99, 1, "", this),
+            new Among ( "\u00E1ssemos", 99, 1, "", this),
+            new Among ( "\u00EAssemos", 99, 1, "", this),
+            new Among ( "\u00EDssemos", 99, 1, "", this),
+            new Among ( "imos", -1, 1, "", this),
+            new Among ( "armos", -1, 1, "", this),
+            new Among ( "ermos", -1, 1, "", this),
+            new Among ( "irmos", -1, 1, "", this),
+            new Among ( "\u00E1mos", -1, 1, "", this),
+            new Among ( "ar\u00E1s", -1, 1, "", this),
+            new Among ( "er\u00E1s", -1, 1, "", this),
+            new Among ( "ir\u00E1s", -1, 1, "", this),
+            new Among ( "eu", -1, 1, "", this),
+            new Among ( "iu", -1, 1, "", this),
+            new Among ( "ou", -1, 1, "", this),
+            new Among ( "ar\u00E1", -1, 1, "", this),
+            new Among ( "er\u00E1", -1, 1, "", this),
+            new Among ( "ir\u00E1", -1, 1, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "a", -1, 1, "", this),
+            new Among ( "i", -1, 1, "", this),
+            new Among ( "o", -1, 1, "", this),
+            new Among ( "os", -1, 1, "", this),
+            new Among ( "\u00E1", -1, 1, "", this),
+            new Among ( "\u00ED", -1, 1, "", this),
+            new Among ( "\u00F3", -1, 1, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "\u00E7", -1, 2, "", this),
+            new Among ( "\u00E9", -1, 1, "", this),
+            new Among ( "\u00EA", -1, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 19, 12, 2 };
+
+        private int I_p2;
+        private int I_p1;
+        private int I_pV;
+
+        private void copy_from(PortugueseStemmer other) {
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int among_var;
+            int v_1;
+            // repeat, line 36
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 36
+                    // [, line 37
+                    bra = cursor;
+                    // substring, line 37
+                    among_var = find_among(a_0, 3);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 37
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 38
+                            // <-, line 38
+                            slice_from("a~");
+                            break;
+                        case 2:
+                            // (, line 39
+                            // <-, line 39
+                            slice_from("o~");
+                            break;
+                        case 3:
+                            // (, line 40
+                            // next, line 40
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_6;
+            int v_8;
+            // (, line 44
+            I_pV = limit;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 50
+            v_1 = cursor;
+            lab0: do {
+                // (, line 50
+                // or, line 52
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // (, line 51
+                        if (!(in_grouping(g_v, 97, 250)))
+                        {
+                            break lab2;
+                        }
+                        // or, line 51
+                        lab3: do {
+                            v_3 = cursor;
+                            lab4: do {
+                                // (, line 51
+                                if (!(out_grouping(g_v, 97, 250)))
+                                {
+                                    break lab4;
+                                }
+                                // gopast, line 51
+                                golab5: while(true)
+                                {
+                                    lab6: do {
+                                        if (!(in_grouping(g_v, 97, 250)))
+                                        {
+                                            break lab6;
+                                        }
+                                        break golab5;
+                                    } while (false);
+                                    if (cursor >= limit)
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor++;
+                                }
+                                break lab3;
+                            } while (false);
+                            cursor = v_3;
+                            // (, line 51
+                            if (!(in_grouping(g_v, 97, 250)))
+                            {
+                                break lab2;
+                            }
+                            // gopast, line 51
+                            golab7: while(true)
+                            {
+                                lab8: do {
+                                    if (!(out_grouping(g_v, 97, 250)))
+                                    {
+                                        break lab8;
+                                    }
+                                    break golab7;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab2;
+                                }
+                                cursor++;
+                            }
+                        } while (false);
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 53
+                    if (!(out_grouping(g_v, 97, 250)))
+                    {
+                        break lab0;
+                    }
+                    // or, line 53
+                    lab9: do {
+                        v_6 = cursor;
+                        lab10: do {
+                            // (, line 53
+                            if (!(out_grouping(g_v, 97, 250)))
+                            {
+                                break lab10;
+                            }
+                            // gopast, line 53
+                            golab11: while(true)
+                            {
+                                lab12: do {
+                                    if (!(in_grouping(g_v, 97, 250)))
+                                    {
+                                        break lab12;
+                                    }
+                                    break golab11;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab10;
+                                }
+                                cursor++;
+                            }
+                            break lab9;
+                        } while (false);
+                        cursor = v_6;
+                        // (, line 53
+                        if (!(in_grouping(g_v, 97, 250)))
+                        {
+                            break lab0;
+                        }
+                        // next, line 53
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    } while (false);
+                } while (false);
+                // setmark pV, line 54
+                I_pV = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 56
+            v_8 = cursor;
+            lab13: do {
+                // (, line 56
+                // gopast, line 57
+                golab14: while(true)
+                {
+                    lab15: do {
+                        if (!(in_grouping(g_v, 97, 250)))
+                        {
+                            break lab15;
+                        }
+                        break golab14;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 57
+                golab16: while(true)
+                {
+                    lab17: do {
+                        if (!(out_grouping(g_v, 97, 250)))
+                        {
+                            break lab17;
+                        }
+                        break golab16;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 57
+                I_p1 = cursor;
+                // gopast, line 58
+                golab18: while(true)
+                {
+                    lab19: do {
+                        if (!(in_grouping(g_v, 97, 250)))
+                        {
+                            break lab19;
+                        }
+                        break golab18;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 58
+                golab20: while(true)
+                {
+                    lab21: do {
+                        if (!(out_grouping(g_v, 97, 250)))
+                        {
+                            break lab21;
+                        }
+                        break golab20;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 58
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_8;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 62
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 62
+                    // [, line 63
+                    bra = cursor;
+                    // substring, line 63
+                    among_var = find_among(a_1, 3);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 63
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 64
+                            // <-, line 64
+                            slice_from("\u00E3");
+                            break;
+                        case 2:
+                            // (, line 65
+                            // <-, line 65
+                            slice_from("\u00F5");
+                            break;
+                        case 3:
+                            // (, line 66
+                            // next, line 66
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_RV() {
+            if (!(I_pV <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 76
+            // [, line 77
+            ket = cursor;
+            // substring, line 77
+            among_var = find_among_b(a_5, 45);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 77
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 92
+                    // call R2, line 93
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 93
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 97
+                    // call R2, line 98
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 98
+                    slice_from("log");
+                    break;
+                case 3:
+                    // (, line 101
+                    // call R2, line 102
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 102
+                    slice_from("u");
+                    break;
+                case 4:
+                    // (, line 105
+                    // call R2, line 106
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 106
+                    slice_from("ente");
+                    break;
+                case 5:
+                    // (, line 109
+                    // call R1, line 110
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 110
+                    slice_del();
+                    // try, line 111
+                    v_1 = limit - cursor;
+                    lab0: do {
+                        // (, line 111
+                        // [, line 112
+                        ket = cursor;
+                        // substring, line 112
+                        among_var = find_among_b(a_2, 4);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // ], line 112
+                        bra = cursor;
+                        // call R2, line 112
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // delete, line 112
+                        slice_del();
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_1;
+                                break lab0;
+                            case 1:
+                                // (, line 113
+                                // [, line 113
+                                ket = cursor;
+                                // literal, line 113
+                                if (!(eq_s_b(2, "at")))
+                                {
+                                    cursor = limit - v_1;
+                                    break lab0;
+                                }
+                                // ], line 113
+                                bra = cursor;
+                                // call R2, line 113
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_1;
+                                    break lab0;
+                                }
+                                // delete, line 113
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 6:
+                    // (, line 121
+                    // call R2, line 122
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 122
+                    slice_del();
+                    // try, line 123
+                    v_2 = limit - cursor;
+                    lab1: do {
+                        // (, line 123
+                        // [, line 124
+                        ket = cursor;
+                        // substring, line 124
+                        among_var = find_among_b(a_3, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_2;
+                            break lab1;
+                        }
+                        // ], line 124
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_2;
+                                break lab1;
+                            case 1:
+                                // (, line 127
+                                // call R2, line 127
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_2;
+                                    break lab1;
+                                }
+                                // delete, line 127
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 7:
+                    // (, line 133
+                    // call R2, line 134
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 134
+                    slice_del();
+                    // try, line 135
+                    v_3 = limit - cursor;
+                    lab2: do {
+                        // (, line 135
+                        // [, line 136
+                        ket = cursor;
+                        // substring, line 136
+                        among_var = find_among_b(a_4, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_3;
+                            break lab2;
+                        }
+                        // ], line 136
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_3;
+                                break lab2;
+                            case 1:
+                                // (, line 139
+                                // call R2, line 139
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab2;
+                                }
+                                // delete, line 139
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 8:
+                    // (, line 145
+                    // call R2, line 146
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 146
+                    slice_del();
+                    // try, line 147
+                    v_4 = limit - cursor;
+                    lab3: do {
+                        // (, line 147
+                        // [, line 148
+                        ket = cursor;
+                        // literal, line 148
+                        if (!(eq_s_b(2, "at")))
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // ], line 148
+                        bra = cursor;
+                        // call R2, line 148
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // delete, line 148
+                        slice_del();
+                    } while (false);
+                    break;
+                case 9:
+                    // (, line 152
+                    // call RV, line 153
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // literal, line 153
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        return false;
+                    }
+                    // <-, line 154
+                    slice_from("ir");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // setlimit, line 159
+            v_1 = limit - cursor;
+            // tomark, line 159
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 159
+            // [, line 160
+            ket = cursor;
+            // substring, line 160
+            among_var = find_among_b(a_6, 120);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 160
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 179
+                    // delete, line 179
+                    slice_del();
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_residual_suffix() {
+            int among_var;
+            // (, line 183
+            // [, line 184
+            ket = cursor;
+            // substring, line 184
+            among_var = find_among_b(a_7, 7);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 184
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 187
+                    // call RV, line 187
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 187
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_residual_form() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 191
+            // [, line 192
+            ket = cursor;
+            // substring, line 192
+            among_var = find_among_b(a_8, 4);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 192
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 194
+                    // call RV, line 194
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 194
+                    slice_del();
+                    // [, line 194
+                    ket = cursor;
+                    // or, line 194
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // (, line 194
+                            // literal, line 194
+                            if (!(eq_s_b(1, "u")))
+                            {
+                                break lab1;
+                            }
+                            // ], line 194
+                            bra = cursor;
+                            // test, line 194
+                            v_2 = limit - cursor;
+                            // literal, line 194
+                            if (!(eq_s_b(1, "g")))
+                            {
+                                break lab1;
+                            }
+                            cursor = limit - v_2;
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // (, line 195
+                        // literal, line 195
+                        if (!(eq_s_b(1, "i")))
+                        {
+                            return false;
+                        }
+                        // ], line 195
+                        bra = cursor;
+                        // test, line 195
+                        v_3 = limit - cursor;
+                        // literal, line 195
+                        if (!(eq_s_b(1, "c")))
+                        {
+                            return false;
+                        }
+                        cursor = limit - v_3;
+                    } while (false);
+                    // call RV, line 195
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 195
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 196
+                    // <-, line 196
+                    slice_from("c");
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            // (, line 201
+            // do, line 202
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 202
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 203
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 203
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 204
+            limit_backward = cursor; cursor = limit;
+            // (, line 204
+            // do, line 205
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 205
+                // or, line 209
+                lab3: do {
+                    v_4 = limit - cursor;
+                    lab4: do {
+                        // (, line 206
+                        // and, line 207
+                        v_5 = limit - cursor;
+                        // (, line 206
+                        // or, line 206
+                        lab5: do {
+                            v_6 = limit - cursor;
+                            lab6: do {
+                                // call standard_suffix, line 206
+                                if (!r_standard_suffix())
+                                {
+                                    break lab6;
+                                }
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_6;
+                            // call verb_suffix, line 206
+                            if (!r_verb_suffix())
+                            {
+                                break lab4;
+                            }
+                        } while (false);
+                        cursor = limit - v_5;
+                        // do, line 207
+                        v_7 = limit - cursor;
+                        lab7: do {
+                            // (, line 207
+                            // [, line 207
+                            ket = cursor;
+                            // literal, line 207
+                            if (!(eq_s_b(1, "i")))
+                            {
+                                break lab7;
+                            }
+                            // ], line 207
+                            bra = cursor;
+                            // test, line 207
+                            v_8 = limit - cursor;
+                            // literal, line 207
+                            if (!(eq_s_b(1, "c")))
+                            {
+                                break lab7;
+                            }
+                            cursor = limit - v_8;
+                            // call RV, line 207
+                            if (!r_RV())
+                            {
+                                break lab7;
+                            }
+                            // delete, line 207
+                            slice_del();
+                        } while (false);
+                        cursor = limit - v_7;
+                        break lab3;
+                    } while (false);
+                    cursor = limit - v_4;
+                    // call residual_suffix, line 209
+                    if (!r_residual_suffix())
+                    {
+                        break lab2;
+                    }
+                } while (false);
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 211
+            v_9 = limit - cursor;
+            lab8: do {
+                // call residual_form, line 211
+                if (!r_residual_form())
+                {
+                    break lab8;
+                }
+            } while (false);
+            cursor = limit - v_9;
+            cursor = limit_backward;            // do, line 213
+            v_10 = cursor;
+            lab9: do {
+                // call postlude, line 213
+                if (!r_postlude())
+                {
+                    break lab9;
+                }
+            } while (false);
+            cursor = v_10;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/RomanianStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/RomanianStemmer.java
new file mode 100644
index 0000000..b26a7f0
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/RomanianStemmer.java
@@ -0,0 +1,1024 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class RomanianStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 3, "", this),
+            new Among ( "I", 0, 1, "", this),
+            new Among ( "U", 0, 2, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "ea", -1, 3, "", this),
+            new Among ( "a\u0163ia", -1, 7, "", this),
+            new Among ( "aua", -1, 2, "", this),
+            new Among ( "iua", -1, 4, "", this),
+            new Among ( "a\u0163ie", -1, 7, "", this),
+            new Among ( "ele", -1, 3, "", this),
+            new Among ( "ile", -1, 5, "", this),
+            new Among ( "iile", 6, 4, "", this),
+            new Among ( "iei", -1, 4, "", this),
+            new Among ( "atei", -1, 6, "", this),
+            new Among ( "ii", -1, 4, "", this),
+            new Among ( "ului", -1, 1, "", this),
+            new Among ( "ul", -1, 1, "", this),
+            new Among ( "elor", -1, 3, "", this),
+            new Among ( "ilor", -1, 4, "", this),
+            new Among ( "iilor", 14, 4, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "icala", -1, 4, "", this),
+            new Among ( "iciva", -1, 4, "", this),
+            new Among ( "ativa", -1, 5, "", this),
+            new Among ( "itiva", -1, 6, "", this),
+            new Among ( "icale", -1, 4, "", this),
+            new Among ( "a\u0163iune", -1, 5, "", this),
+            new Among ( "i\u0163iune", -1, 6, "", this),
+            new Among ( "atoare", -1, 5, "", this),
+            new Among ( "itoare", -1, 6, "", this),
+            new Among ( "\u0103toare", -1, 5, "", this),
+            new Among ( "icitate", -1, 4, "", this),
+            new Among ( "abilitate", -1, 1, "", this),
+            new Among ( "ibilitate", -1, 2, "", this),
+            new Among ( "ivitate", -1, 3, "", this),
+            new Among ( "icive", -1, 4, "", this),
+            new Among ( "ative", -1, 5, "", this),
+            new Among ( "itive", -1, 6, "", this),
+            new Among ( "icali", -1, 4, "", this),
+            new Among ( "atori", -1, 5, "", this),
+            new Among ( "icatori", 18, 4, "", this),
+            new Among ( "itori", -1, 6, "", this),
+            new Among ( "\u0103tori", -1, 5, "", this),
+            new Among ( "icitati", -1, 4, "", this),
+            new Among ( "abilitati", -1, 1, "", this),
+            new Among ( "ivitati", -1, 3, "", this),
+            new Among ( "icivi", -1, 4, "", this),
+            new Among ( "ativi", -1, 5, "", this),
+            new Among ( "itivi", -1, 6, "", this),
+            new Among ( "icit\u0103i", -1, 4, "", this),
+            new Among ( "abilit\u0103i", -1, 1, "", this),
+            new Among ( "ivit\u0103i", -1, 3, "", this),
+            new Among ( "icit\u0103\u0163i", -1, 4, "", this),
+            new Among ( "abilit\u0103\u0163i", -1, 1, "", this),
+            new Among ( "ivit\u0103\u0163i", -1, 3, "", this),
+            new Among ( "ical", -1, 4, "", this),
+            new Among ( "ator", -1, 5, "", this),
+            new Among ( "icator", 35, 4, "", this),
+            new Among ( "itor", -1, 6, "", this),
+            new Among ( "\u0103tor", -1, 5, "", this),
+            new Among ( "iciv", -1, 4, "", this),
+            new Among ( "ativ", -1, 5, "", this),
+            new Among ( "itiv", -1, 6, "", this),
+            new Among ( "ical\u0103", -1, 4, "", this),
+            new Among ( "iciv\u0103", -1, 4, "", this),
+            new Among ( "ativ\u0103", -1, 5, "", this),
+            new Among ( "itiv\u0103", -1, 6, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ica", -1, 1, "", this),
+            new Among ( "abila", -1, 1, "", this),
+            new Among ( "ibila", -1, 1, "", this),
+            new Among ( "oasa", -1, 1, "", this),
+            new Among ( "ata", -1, 1, "", this),
+            new Among ( "ita", -1, 1, "", this),
+            new Among ( "anta", -1, 1, "", this),
+            new Among ( "ista", -1, 3, "", this),
+            new Among ( "uta", -1, 1, "", this),
+            new Among ( "iva", -1, 1, "", this),
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "ice", -1, 1, "", this),
+            new Among ( "abile", -1, 1, "", this),
+            new Among ( "ibile", -1, 1, "", this),
+            new Among ( "isme", -1, 3, "", this),
+            new Among ( "iune", -1, 2, "", this),
+            new Among ( "oase", -1, 1, "", this),
+            new Among ( "ate", -1, 1, "", this),
+            new Among ( "itate", 17, 1, "", this),
+            new Among ( "ite", -1, 1, "", this),
+            new Among ( "ante", -1, 1, "", this),
+            new Among ( "iste", -1, 3, "", this),
+            new Among ( "ute", -1, 1, "", this),
+            new Among ( "ive", -1, 1, "", this),
+            new Among ( "ici", -1, 1, "", this),
+            new Among ( "abili", -1, 1, "", this),
+            new Among ( "ibili", -1, 1, "", this),
+            new Among ( "iuni", -1, 2, "", this),
+            new Among ( "atori", -1, 1, "", this),
+            new Among ( "osi", -1, 1, "", this),
+            new Among ( "ati", -1, 1, "", this),
+            new Among ( "itati", 30, 1, "", this),
+            new Among ( "iti", -1, 1, "", this),
+            new Among ( "anti", -1, 1, "", this),
+            new Among ( "isti", -1, 3, "", this),
+            new Among ( "uti", -1, 1, "", this),
+            new Among ( "i\u015Fti", -1, 3, "", this),
+            new Among ( "ivi", -1, 1, "", this),
+            new Among ( "it\u0103i", -1, 1, "", this),
+            new Among ( "o\u015Fi", -1, 1, "", this),
+            new Among ( "it\u0103\u0163i", -1, 1, "", this),
+            new Among ( "abil", -1, 1, "", this),
+            new Among ( "ibil", -1, 1, "", this),
+            new Among ( "ism", -1, 3, "", this),
+            new Among ( "ator", -1, 1, "", this),
+            new Among ( "os", -1, 1, "", this),
+            new Among ( "at", -1, 1, "", this),
+            new Among ( "it", -1, 1, "", this),
+            new Among ( "ant", -1, 1, "", this),
+            new Among ( "ist", -1, 3, "", this),
+            new Among ( "ut", -1, 1, "", this),
+            new Among ( "iv", -1, 1, "", this),
+            new Among ( "ic\u0103", -1, 1, "", this),
+            new Among ( "abil\u0103", -1, 1, "", this),
+            new Among ( "ibil\u0103", -1, 1, "", this),
+            new Among ( "oas\u0103", -1, 1, "", this),
+            new Among ( "at\u0103", -1, 1, "", this),
+            new Among ( "it\u0103", -1, 1, "", this),
+            new Among ( "ant\u0103", -1, 1, "", this),
+            new Among ( "ist\u0103", -1, 3, "", this),
+            new Among ( "ut\u0103", -1, 1, "", this),
+            new Among ( "iv\u0103", -1, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "ea", -1, 1, "", this),
+            new Among ( "ia", -1, 1, "", this),
+            new Among ( "esc", -1, 1, "", this),
+            new Among ( "\u0103sc", -1, 1, "", this),
+            new Among ( "ind", -1, 1, "", this),
+            new Among ( "\u00E2nd", -1, 1, "", this),
+            new Among ( "are", -1, 1, "", this),
+            new Among ( "ere", -1, 1, "", this),
+            new Among ( "ire", -1, 1, "", this),
+            new Among ( "\u00E2re", -1, 1, "", this),
+            new Among ( "se", -1, 2, "", this),
+            new Among ( "ase", 10, 1, "", this),
+            new Among ( "sese", 10, 2, "", this),
+            new Among ( "ise", 10, 1, "", this),
+            new Among ( "use", 10, 1, "", this),
+            new Among ( "\u00E2se", 10, 1, "", this),
+            new Among ( "e\u015Fte", -1, 1, "", this),
+            new Among ( "\u0103\u015Fte", -1, 1, "", this),
+            new Among ( "eze", -1, 1, "", this),
+            new Among ( "ai", -1, 1, "", this),
+            new Among ( "eai", 19, 1, "", this),
+            new Among ( "iai", 19, 1, "", this),
+            new Among ( "sei", -1, 2, "", this),
+            new Among ( "e\u015Fti", -1, 1, "", this),
+            new Among ( "\u0103\u015Fti", -1, 1, "", this),
+            new Among ( "ui", -1, 1, "", this),
+            new Among ( "ezi", -1, 1, "", this),
+            new Among ( "\u00E2i", -1, 1, "", this),
+            new Among ( "a\u015Fi", -1, 1, "", this),
+            new Among ( "se\u015Fi", -1, 2, "", this),
+            new Among ( "ase\u015Fi", 29, 1, "", this),
+            new Among ( "sese\u015Fi", 29, 2, "", this),
+            new Among ( "ise\u015Fi", 29, 1, "", this),
+            new Among ( "use\u015Fi", 29, 1, "", this),
+            new Among ( "\u00E2se\u015Fi", 29, 1, "", this),
+            new Among ( "i\u015Fi", -1, 1, "", this),
+            new Among ( "u\u015Fi", -1, 1, "", this),
+            new Among ( "\u00E2\u015Fi", -1, 1, "", this),
+            new Among ( "a\u0163i", -1, 2, "", this),
+            new Among ( "ea\u0163i", 38, 1, "", this),
+            new Among ( "ia\u0163i", 38, 1, "", this),
+            new Among ( "e\u0163i", -1, 2, "", this),
+            new Among ( "i\u0163i", -1, 2, "", this),
+            new Among ( "\u00E2\u0163i", -1, 2, "", this),
+            new Among ( "ar\u0103\u0163i", -1, 1, "", this),
+            new Among ( "ser\u0103\u0163i", -1, 2, "", this),
+            new Among ( "aser\u0103\u0163i", 45, 1, "", this),
+            new Among ( "seser\u0103\u0163i", 45, 2, "", this),
+            new Among ( "iser\u0103\u0163i", 45, 1, "", this),
+            new Among ( "user\u0103\u0163i", 45, 1, "", this),
+            new Among ( "\u00E2ser\u0103\u0163i", 45, 1, "", this),
+            new Among ( "ir\u0103\u0163i", -1, 1, "", this),
+            new Among ( "ur\u0103\u0163i", -1, 1, "", this),
+            new Among ( "\u00E2r\u0103\u0163i", -1, 1, "", this),
+            new Among ( "am", -1, 1, "", this),
+            new Among ( "eam", 54, 1, "", this),
+            new Among ( "iam", 54, 1, "", this),
+            new Among ( "em", -1, 2, "", this),
+            new Among ( "asem", 57, 1, "", this),
+            new Among ( "sesem", 57, 2, "", this),
+            new Among ( "isem", 57, 1, "", this),
+            new Among ( "usem", 57, 1, "", this),
+            new Among ( "\u00E2sem", 57, 1, "", this),
+            new Among ( "im", -1, 2, "", this),
+            new Among ( "\u00E2m", -1, 2, "", this),
+            new Among ( "\u0103m", -1, 2, "", this),
+            new Among ( "ar\u0103m", 65, 1, "", this),
+            new Among ( "ser\u0103m", 65, 2, "", this),
+            new Among ( "aser\u0103m", 67, 1, "", this),
+            new Among ( "seser\u0103m", 67, 2, "", this),
+            new Among ( "iser\u0103m", 67, 1, "", this),
+            new Among ( "user\u0103m", 67, 1, "", this),
+            new Among ( "\u00E2ser\u0103m", 67, 1, "", this),
+            new Among ( "ir\u0103m", 65, 1, "", this),
+            new Among ( "ur\u0103m", 65, 1, "", this),
+            new Among ( "\u00E2r\u0103m", 65, 1, "", this),
+            new Among ( "au", -1, 1, "", this),
+            new Among ( "eau", 76, 1, "", this),
+            new Among ( "iau", 76, 1, "", this),
+            new Among ( "indu", -1, 1, "", this),
+            new Among ( "\u00E2ndu", -1, 1, "", this),
+            new Among ( "ez", -1, 1, "", this),
+            new Among ( "easc\u0103", -1, 1, "", this),
+            new Among ( "ar\u0103", -1, 1, "", this),
+            new Among ( "ser\u0103", -1, 2, "", this),
+            new Among ( "aser\u0103", 84, 1, "", this),
+            new Among ( "seser\u0103", 84, 2, "", this),
+            new Among ( "iser\u0103", 84, 1, "", this),
+            new Among ( "user\u0103", 84, 1, "", this),
+            new Among ( "\u00E2ser\u0103", 84, 1, "", this),
+            new Among ( "ir\u0103", -1, 1, "", this),
+            new Among ( "ur\u0103", -1, 1, "", this),
+            new Among ( "\u00E2r\u0103", -1, 1, "", this),
+            new Among ( "eaz\u0103", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "a", -1, 1, "", this),
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "ie", 1, 1, "", this),
+            new Among ( "i", -1, 1, "", this),
+            new Among ( "\u0103", -1, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 32, 0, 0, 4 };
+
+        private boolean B_standard_suffix_removed;
+        private int I_p2;
+        private int I_p1;
+        private int I_pV;
+
+        private void copy_from(RomanianStemmer other) {
+            B_standard_suffix_removed = other.B_standard_suffix_removed;
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_prelude() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 31
+            // repeat, line 32
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // goto, line 32
+                    golab2: while(true)
+                    {
+                        v_2 = cursor;
+                        lab3: do {
+                            // (, line 32
+                            if (!(in_grouping(g_v, 97, 259)))
+                            {
+                                break lab3;
+                            }
+                            // [, line 33
+                            bra = cursor;
+                            // or, line 33
+                            lab4: do {
+                                v_3 = cursor;
+                                lab5: do {
+                                    // (, line 33
+                                    // literal, line 33
+                                    if (!(eq_s(1, "u")))
+                                    {
+                                        break lab5;
+                                    }
+                                    // ], line 33
+                                    ket = cursor;
+                                    if (!(in_grouping(g_v, 97, 259)))
+                                    {
+                                        break lab5;
+                                    }
+                                    // <-, line 33
+                                    slice_from("U");
+                                    break lab4;
+                                } while (false);
+                                cursor = v_3;
+                                // (, line 34
+                                // literal, line 34
+                                if (!(eq_s(1, "i")))
+                                {
+                                    break lab3;
+                                }
+                                // ], line 34
+                                ket = cursor;
+                                if (!(in_grouping(g_v, 97, 259)))
+                                {
+                                    break lab3;
+                                }
+                                // <-, line 34
+                                slice_from("I");
+                            } while (false);
+                            cursor = v_2;
+                            break golab2;
+                        } while (false);
+                        cursor = v_2;
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_6;
+            int v_8;
+            // (, line 38
+            I_pV = limit;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 44
+            v_1 = cursor;
+            lab0: do {
+                // (, line 44
+                // or, line 46
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // (, line 45
+                        if (!(in_grouping(g_v, 97, 259)))
+                        {
+                            break lab2;
+                        }
+                        // or, line 45
+                        lab3: do {
+                            v_3 = cursor;
+                            lab4: do {
+                                // (, line 45
+                                if (!(out_grouping(g_v, 97, 259)))
+                                {
+                                    break lab4;
+                                }
+                                // gopast, line 45
+                                golab5: while(true)
+                                {
+                                    lab6: do {
+                                        if (!(in_grouping(g_v, 97, 259)))
+                                        {
+                                            break lab6;
+                                        }
+                                        break golab5;
+                                    } while (false);
+                                    if (cursor >= limit)
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor++;
+                                }
+                                break lab3;
+                            } while (false);
+                            cursor = v_3;
+                            // (, line 45
+                            if (!(in_grouping(g_v, 97, 259)))
+                            {
+                                break lab2;
+                            }
+                            // gopast, line 45
+                            golab7: while(true)
+                            {
+                                lab8: do {
+                                    if (!(out_grouping(g_v, 97, 259)))
+                                    {
+                                        break lab8;
+                                    }
+                                    break golab7;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab2;
+                                }
+                                cursor++;
+                            }
+                        } while (false);
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 47
+                    if (!(out_grouping(g_v, 97, 259)))
+                    {
+                        break lab0;
+                    }
+                    // or, line 47
+                    lab9: do {
+                        v_6 = cursor;
+                        lab10: do {
+                            // (, line 47
+                            if (!(out_grouping(g_v, 97, 259)))
+                            {
+                                break lab10;
+                            }
+                            // gopast, line 47
+                            golab11: while(true)
+                            {
+                                lab12: do {
+                                    if (!(in_grouping(g_v, 97, 259)))
+                                    {
+                                        break lab12;
+                                    }
+                                    break golab11;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab10;
+                                }
+                                cursor++;
+                            }
+                            break lab9;
+                        } while (false);
+                        cursor = v_6;
+                        // (, line 47
+                        if (!(in_grouping(g_v, 97, 259)))
+                        {
+                            break lab0;
+                        }
+                        // next, line 47
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    } while (false);
+                } while (false);
+                // setmark pV, line 48
+                I_pV = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 50
+            v_8 = cursor;
+            lab13: do {
+                // (, line 50
+                // gopast, line 51
+                golab14: while(true)
+                {
+                    lab15: do {
+                        if (!(in_grouping(g_v, 97, 259)))
+                        {
+                            break lab15;
+                        }
+                        break golab14;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 51
+                golab16: while(true)
+                {
+                    lab17: do {
+                        if (!(out_grouping(g_v, 97, 259)))
+                        {
+                            break lab17;
+                        }
+                        break golab16;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 51
+                I_p1 = cursor;
+                // gopast, line 52
+                golab18: while(true)
+                {
+                    lab19: do {
+                        if (!(in_grouping(g_v, 97, 259)))
+                        {
+                            break lab19;
+                        }
+                        break golab18;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 52
+                golab20: while(true)
+                {
+                    lab21: do {
+                        if (!(out_grouping(g_v, 97, 259)))
+                        {
+                            break lab21;
+                        }
+                        break golab20;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 52
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_8;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 56
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 56
+                    // [, line 58
+                    bra = cursor;
+                    // substring, line 58
+                    among_var = find_among(a_0, 3);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 58
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 59
+                            // <-, line 59
+                            slice_from("i");
+                            break;
+                        case 2:
+                            // (, line 60
+                            // <-, line 60
+                            slice_from("u");
+                            break;
+                        case 3:
+                            // (, line 61
+                            // next, line 61
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_RV() {
+            if (!(I_pV <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_step_0() {
+            int among_var;
+            int v_1;
+            // (, line 72
+            // [, line 73
+            ket = cursor;
+            // substring, line 73
+            among_var = find_among_b(a_1, 16);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 73
+            bra = cursor;
+            // call R1, line 73
+            if (!r_R1())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 75
+                    // delete, line 75
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 77
+                    // <-, line 77
+                    slice_from("a");
+                    break;
+                case 3:
+                    // (, line 79
+                    // <-, line 79
+                    slice_from("e");
+                    break;
+                case 4:
+                    // (, line 81
+                    // <-, line 81
+                    slice_from("i");
+                    break;
+                case 5:
+                    // (, line 83
+                    // not, line 83
+                    {
+                        v_1 = limit - cursor;
+                        lab0: do {
+                            // literal, line 83
+                            if (!(eq_s_b(2, "ab")))
+                            {
+                                break lab0;
+                            }
+                            return false;
+                        } while (false);
+                        cursor = limit - v_1;
+                    }
+                    // <-, line 83
+                    slice_from("i");
+                    break;
+                case 6:
+                    // (, line 85
+                    // <-, line 85
+                    slice_from("at");
+                    break;
+                case 7:
+                    // (, line 87
+                    // <-, line 87
+                    slice_from("a\u0163i");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_combo_suffix() {
+            int among_var;
+            int v_1;
+            // test, line 91
+            v_1 = limit - cursor;
+            // (, line 91
+            // [, line 92
+            ket = cursor;
+            // substring, line 92
+            among_var = find_among_b(a_2, 46);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 92
+            bra = cursor;
+            // call R1, line 92
+            if (!r_R1())
+            {
+                return false;
+            }
+            // (, line 92
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 100
+                    // <-, line 101
+                    slice_from("abil");
+                    break;
+                case 2:
+                    // (, line 103
+                    // <-, line 104
+                    slice_from("ibil");
+                    break;
+                case 3:
+                    // (, line 106
+                    // <-, line 107
+                    slice_from("iv");
+                    break;
+                case 4:
+                    // (, line 112
+                    // <-, line 113
+                    slice_from("ic");
+                    break;
+                case 5:
+                    // (, line 117
+                    // <-, line 118
+                    slice_from("at");
+                    break;
+                case 6:
+                    // (, line 121
+                    // <-, line 122
+                    slice_from("it");
+                    break;
+            }
+            // set standard_suffix_removed, line 125
+            B_standard_suffix_removed = true;
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            // (, line 129
+            // unset standard_suffix_removed, line 130
+            B_standard_suffix_removed = false;
+            // repeat, line 131
+            replab0: while(true)
+            {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // call combo_suffix, line 131
+                    if (!r_combo_suffix())
+                    {
+                        break lab1;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = limit - v_1;
+                break replab0;
+            }
+            // [, line 132
+            ket = cursor;
+            // substring, line 132
+            among_var = find_among_b(a_3, 62);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 132
+            bra = cursor;
+            // call R2, line 132
+            if (!r_R2())
+            {
+                return false;
+            }
+            // (, line 132
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 148
+                    // delete, line 149
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 151
+                    // literal, line 152
+                    if (!(eq_s_b(1, "\u0163")))
+                    {
+                        return false;
+                    }
+                    // ], line 152
+                    bra = cursor;
+                    // <-, line 152
+                    slice_from("t");
+                    break;
+                case 3:
+                    // (, line 155
+                    // <-, line 156
+                    slice_from("ist");
+                    break;
+            }
+            // set standard_suffix_removed, line 160
+            B_standard_suffix_removed = true;
+            return true;
+        }
+
+        private boolean r_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            // setlimit, line 164
+            v_1 = limit - cursor;
+            // tomark, line 164
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 164
+            // [, line 165
+            ket = cursor;
+            // substring, line 165
+            among_var = find_among_b(a_4, 94);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 165
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 200
+                    // or, line 200
+                    lab0: do {
+                        v_3 = limit - cursor;
+                        lab1: do {
+                            if (!(out_grouping_b(g_v, 97, 259)))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_3;
+                        // literal, line 200
+                        if (!(eq_s_b(1, "u")))
+                        {
+                            limit_backward = v_2;
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 200
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 214
+                    // delete, line 214
+                    slice_del();
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_vowel_suffix() {
+            int among_var;
+            // (, line 218
+            // [, line 219
+            ket = cursor;
+            // substring, line 219
+            among_var = find_among_b(a_5, 5);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 219
+            bra = cursor;
+            // call RV, line 219
+            if (!r_RV())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 220
+                    // delete, line 220
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            // (, line 225
+            // do, line 226
+            v_1 = cursor;
+            lab0: do {
+                // call prelude, line 226
+                if (!r_prelude())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // do, line 227
+            v_2 = cursor;
+            lab1: do {
+                // call mark_regions, line 227
+                if (!r_mark_regions())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = v_2;
+            // backwards, line 228
+            limit_backward = cursor; cursor = limit;
+            // (, line 228
+            // do, line 229
+            v_3 = limit - cursor;
+            lab2: do {
+                // call step_0, line 229
+                if (!r_step_0())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 230
+            v_4 = limit - cursor;
+            lab3: do {
+                // call standard_suffix, line 230
+                if (!r_standard_suffix())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            // do, line 231
+            v_5 = limit - cursor;
+            lab4: do {
+                // (, line 231
+                // or, line 231
+                lab5: do {
+                    v_6 = limit - cursor;
+                    lab6: do {
+                        // Boolean test standard_suffix_removed, line 231
+                        if (!(B_standard_suffix_removed))
+                        {
+                            break lab6;
+                        }
+                        break lab5;
+                    } while (false);
+                    cursor = limit - v_6;
+                    // call verb_suffix, line 231
+                    if (!r_verb_suffix())
+                    {
+                        break lab4;
+                    }
+                } while (false);
+            } while (false);
+            cursor = limit - v_5;
+            // do, line 232
+            v_7 = limit - cursor;
+            lab7: do {
+                // call vowel_suffix, line 232
+                if (!r_vowel_suffix())
+                {
+                    break lab7;
+                }
+            } while (false);
+            cursor = limit - v_7;
+            cursor = limit_backward;            // do, line 234
+            v_8 = cursor;
+            lab8: do {
+                // call postlude, line 234
+                if (!r_postlude())
+                {
+                    break lab8;
+                }
+            } while (false);
+            cursor = v_8;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/RussianStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/RussianStemmer.java
new file mode 100644
index 0000000..fad1835
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/RussianStemmer.java
@@ -0,0 +1,727 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class RussianStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "\u0432", -1, 1, "", this),
+            new Among ( "\u0438\u0432", 0, 2, "", this),
+            new Among ( "\u044B\u0432", 0, 2, "", this),
+            new Among ( "\u0432\u0448\u0438", -1, 1, "", this),
+            new Among ( "\u0438\u0432\u0448\u0438", 3, 2, "", this),
+            new Among ( "\u044B\u0432\u0448\u0438", 3, 2, "", this),
+            new Among ( "\u0432\u0448\u0438\u0441\u044C", -1, 1, "", this),
+            new Among ( "\u0438\u0432\u0448\u0438\u0441\u044C", 6, 2, "", this),
+            new Among ( "\u044B\u0432\u0448\u0438\u0441\u044C", 6, 2, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "\u0435\u0435", -1, 1, "", this),
+            new Among ( "\u0438\u0435", -1, 1, "", this),
+            new Among ( "\u043E\u0435", -1, 1, "", this),
+            new Among ( "\u044B\u0435", -1, 1, "", this),
+            new Among ( "\u0438\u043C\u0438", -1, 1, "", this),
+            new Among ( "\u044B\u043C\u0438", -1, 1, "", this),
+            new Among ( "\u0435\u0439", -1, 1, "", this),
+            new Among ( "\u0438\u0439", -1, 1, "", this),
+            new Among ( "\u043E\u0439", -1, 1, "", this),
+            new Among ( "\u044B\u0439", -1, 1, "", this),
+            new Among ( "\u0435\u043C", -1, 1, "", this),
+            new Among ( "\u0438\u043C", -1, 1, "", this),
+            new Among ( "\u043E\u043C", -1, 1, "", this),
+            new Among ( "\u044B\u043C", -1, 1, "", this),
+            new Among ( "\u0435\u0433\u043E", -1, 1, "", this),
+            new Among ( "\u043E\u0433\u043E", -1, 1, "", this),
+            new Among ( "\u0435\u043C\u0443", -1, 1, "", this),
+            new Among ( "\u043E\u043C\u0443", -1, 1, "", this),
+            new Among ( "\u0438\u0445", -1, 1, "", this),
+            new Among ( "\u044B\u0445", -1, 1, "", this),
+            new Among ( "\u0435\u044E", -1, 1, "", this),
+            new Among ( "\u043E\u044E", -1, 1, "", this),
+            new Among ( "\u0443\u044E", -1, 1, "", this),
+            new Among ( "\u044E\u044E", -1, 1, "", this),
+            new Among ( "\u0430\u044F", -1, 1, "", this),
+            new Among ( "\u044F\u044F", -1, 1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "\u0435\u043C", -1, 1, "", this),
+            new Among ( "\u043D\u043D", -1, 1, "", this),
+            new Among ( "\u0432\u0448", -1, 1, "", this),
+            new Among ( "\u0438\u0432\u0448", 2, 2, "", this),
+            new Among ( "\u044B\u0432\u0448", 2, 2, "", this),
+            new Among ( "\u0449", -1, 1, "", this),
+            new Among ( "\u044E\u0449", 5, 1, "", this),
+            new Among ( "\u0443\u044E\u0449", 6, 2, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "\u0441\u044C", -1, 1, "", this),
+            new Among ( "\u0441\u044F", -1, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "\u043B\u0430", -1, 1, "", this),
+            new Among ( "\u0438\u043B\u0430", 0, 2, "", this),
+            new Among ( "\u044B\u043B\u0430", 0, 2, "", this),
+            new Among ( "\u043D\u0430", -1, 1, "", this),
+            new Among ( "\u0435\u043D\u0430", 3, 2, "", this),
+            new Among ( "\u0435\u0442\u0435", -1, 1, "", this),
+            new Among ( "\u0438\u0442\u0435", -1, 2, "", this),
+            new Among ( "\u0439\u0442\u0435", -1, 1, "", this),
+            new Among ( "\u0435\u0439\u0442\u0435", 7, 2, "", this),
+            new Among ( "\u0443\u0439\u0442\u0435", 7, 2, "", this),
+            new Among ( "\u043B\u0438", -1, 1, "", this),
+            new Among ( "\u0438\u043B\u0438", 10, 2, "", this),
+            new Among ( "\u044B\u043B\u0438", 10, 2, "", this),
+            new Among ( "\u0439", -1, 1, "", this),
+            new Among ( "\u0435\u0439", 13, 2, "", this),
+            new Among ( "\u0443\u0439", 13, 2, "", this),
+            new Among ( "\u043B", -1, 1, "", this),
+            new Among ( "\u0438\u043B", 16, 2, "", this),
+            new Among ( "\u044B\u043B", 16, 2, "", this),
+            new Among ( "\u0435\u043C", -1, 1, "", this),
+            new Among ( "\u0438\u043C", -1, 2, "", this),
+            new Among ( "\u044B\u043C", -1, 2, "", this),
+            new Among ( "\u043D", -1, 1, "", this),
+            new Among ( "\u0435\u043D", 22, 2, "", this),
+            new Among ( "\u043B\u043E", -1, 1, "", this),
+            new Among ( "\u0438\u043B\u043E", 24, 2, "", this),
+            new Among ( "\u044B\u043B\u043E", 24, 2, "", this),
+            new Among ( "\u043D\u043E", -1, 1, "", this),
+            new Among ( "\u0435\u043D\u043E", 27, 2, "", this),
+            new Among ( "\u043D\u043D\u043E", 27, 1, "", this),
+            new Among ( "\u0435\u0442", -1, 1, "", this),
+            new Among ( "\u0443\u0435\u0442", 30, 2, "", this),
+            new Among ( "\u0438\u0442", -1, 2, "", this),
+            new Among ( "\u044B\u0442", -1, 2, "", this),
+            new Among ( "\u044E\u0442", -1, 1, "", this),
+            new Among ( "\u0443\u044E\u0442", 34, 2, "", this),
+            new Among ( "\u044F\u0442", -1, 2, "", this),
+            new Among ( "\u043D\u044B", -1, 1, "", this),
+            new Among ( "\u0435\u043D\u044B", 37, 2, "", this),
+            new Among ( "\u0442\u044C", -1, 1, "", this),
+            new Among ( "\u0438\u0442\u044C", 39, 2, "", this),
+            new Among ( "\u044B\u0442\u044C", 39, 2, "", this),
+            new Among ( "\u0435\u0448\u044C", -1, 1, "", this),
+            new Among ( "\u0438\u0448\u044C", -1, 2, "", this),
+            new Among ( "\u044E", -1, 2, "", this),
+            new Among ( "\u0443\u044E", 44, 2, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "\u0430", -1, 1, "", this),
+            new Among ( "\u0435\u0432", -1, 1, "", this),
+            new Among ( "\u043E\u0432", -1, 1, "", this),
+            new Among ( "\u0435", -1, 1, "", this),
+            new Among ( "\u0438\u0435", 3, 1, "", this),
+            new Among ( "\u044C\u0435", 3, 1, "", this),
+            new Among ( "\u0438", -1, 1, "", this),
+            new Among ( "\u0435\u0438", 6, 1, "", this),
+            new Among ( "\u0438\u0438", 6, 1, "", this),
+            new Among ( "\u0430\u043C\u0438", 6, 1, "", this),
+            new Among ( "\u044F\u043C\u0438", 6, 1, "", this),
+            new Among ( "\u0438\u044F\u043C\u0438", 10, 1, "", this),
+            new Among ( "\u0439", -1, 1, "", this),
+            new Among ( "\u0435\u0439", 12, 1, "", this),
+            new Among ( "\u0438\u0435\u0439", 13, 1, "", this),
+            new Among ( "\u0438\u0439", 12, 1, "", this),
+            new Among ( "\u043E\u0439", 12, 1, "", this),
+            new Among ( "\u0430\u043C", -1, 1, "", this),
+            new Among ( "\u0435\u043C", -1, 1, "", this),
+            new Among ( "\u0438\u0435\u043C", 18, 1, "", this),
+            new Among ( "\u043E\u043C", -1, 1, "", this),
+            new Among ( "\u044F\u043C", -1, 1, "", this),
+            new Among ( "\u0438\u044F\u043C", 21, 1, "", this),
+            new Among ( "\u043E", -1, 1, "", this),
+            new Among ( "\u0443", -1, 1, "", this),
+            new Among ( "\u0430\u0445", -1, 1, "", this),
+            new Among ( "\u044F\u0445", -1, 1, "", this),
+            new Among ( "\u0438\u044F\u0445", 26, 1, "", this),
+            new Among ( "\u044B", -1, 1, "", this),
+            new Among ( "\u044C", -1, 1, "", this),
+            new Among ( "\u044E", -1, 1, "", this),
+            new Among ( "\u0438\u044E", 30, 1, "", this),
+            new Among ( "\u044C\u044E", 30, 1, "", this),
+            new Among ( "\u044F", -1, 1, "", this),
+            new Among ( "\u0438\u044F", 33, 1, "", this),
+            new Among ( "\u044C\u044F", 33, 1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "\u043E\u0441\u0442", -1, 1, "", this),
+            new Among ( "\u043E\u0441\u0442\u044C", -1, 1, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "\u0435\u0439\u0448\u0435", -1, 1, "", this),
+            new Among ( "\u043D", -1, 2, "", this),
+            new Among ( "\u0435\u0439\u0448", -1, 1, "", this),
+            new Among ( "\u044C", -1, 3, "", this)
+        };
+
+        private static final char g_v[] = {33, 65, 8, 232 };
+
+        private int I_p2;
+        private int I_pV;
+
+        private void copy_from(RussianStemmer other) {
+            I_p2 = other.I_p2;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            // (, line 57
+            I_pV = limit;
+            I_p2 = limit;
+            // do, line 61
+            v_1 = cursor;
+            lab0: do {
+                // (, line 61
+                // gopast, line 62
+                golab1: while(true)
+                {
+                    lab2: do {
+                        if (!(in_grouping(g_v, 1072, 1103)))
+                        {
+                            break lab2;
+                        }
+                        break golab1;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // setmark pV, line 62
+                I_pV = cursor;
+                // gopast, line 62
+                golab3: while(true)
+                {
+                    lab4: do {
+                        if (!(out_grouping(g_v, 1072, 1103)))
+                        {
+                            break lab4;
+                        }
+                        break golab3;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // gopast, line 63
+                golab5: while(true)
+                {
+                    lab6: do {
+                        if (!(in_grouping(g_v, 1072, 1103)))
+                        {
+                            break lab6;
+                        }
+                        break golab5;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // gopast, line 63
+                golab7: while(true)
+                {
+                    lab8: do {
+                        if (!(out_grouping(g_v, 1072, 1103)))
+                        {
+                            break lab8;
+                        }
+                        break golab7;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab0;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 63
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_1;
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_perfective_gerund() {
+            int among_var;
+            int v_1;
+            // (, line 71
+            // [, line 72
+            ket = cursor;
+            // substring, line 72
+            among_var = find_among_b(a_0, 9);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 72
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 76
+                    // or, line 76
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // literal, line 76
+                            if (!(eq_s_b(1, "\u0430")))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // literal, line 76
+                        if (!(eq_s_b(1, "\u044F")))
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 76
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 83
+                    // delete, line 83
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_adjective() {
+            int among_var;
+            // (, line 87
+            // [, line 88
+            ket = cursor;
+            // substring, line 88
+            among_var = find_among_b(a_1, 26);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 88
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 97
+                    // delete, line 97
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_adjectival() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 101
+            // call adjective, line 102
+            if (!r_adjective())
+            {
+                return false;
+            }
+            // try, line 109
+            v_1 = limit - cursor;
+            lab0: do {
+                // (, line 109
+                // [, line 110
+                ket = cursor;
+                // substring, line 110
+                among_var = find_among_b(a_2, 8);
+                if (among_var == 0)
+                {
+                    cursor = limit - v_1;
+                    break lab0;
+                }
+                // ], line 110
+                bra = cursor;
+                switch(among_var) {
+                    case 0:
+                        cursor = limit - v_1;
+                        break lab0;
+                    case 1:
+                        // (, line 115
+                        // or, line 115
+                        lab1: do {
+                            v_2 = limit - cursor;
+                            lab2: do {
+                                // literal, line 115
+                                if (!(eq_s_b(1, "\u0430")))
+                                {
+                                    break lab2;
+                                }
+                                break lab1;
+                            } while (false);
+                            cursor = limit - v_2;
+                            // literal, line 115
+                            if (!(eq_s_b(1, "\u044F")))
+                            {
+                                cursor = limit - v_1;
+                                break lab0;
+                            }
+                        } while (false);
+                        // delete, line 115
+                        slice_del();
+                        break;
+                    case 2:
+                        // (, line 122
+                        // delete, line 122
+                        slice_del();
+                        break;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_reflexive() {
+            int among_var;
+            // (, line 128
+            // [, line 129
+            ket = cursor;
+            // substring, line 129
+            among_var = find_among_b(a_3, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 129
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 132
+                    // delete, line 132
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_verb() {
+            int among_var;
+            int v_1;
+            // (, line 136
+            // [, line 137
+            ket = cursor;
+            // substring, line 137
+            among_var = find_among_b(a_4, 46);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 137
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 143
+                    // or, line 143
+                    lab0: do {
+                        v_1 = limit - cursor;
+                        lab1: do {
+                            // literal, line 143
+                            if (!(eq_s_b(1, "\u0430")))
+                            {
+                                break lab1;
+                            }
+                            break lab0;
+                        } while (false);
+                        cursor = limit - v_1;
+                        // literal, line 143
+                        if (!(eq_s_b(1, "\u044F")))
+                        {
+                            return false;
+                        }
+                    } while (false);
+                    // delete, line 143
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 151
+                    // delete, line 151
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_noun() {
+            int among_var;
+            // (, line 159
+            // [, line 160
+            ket = cursor;
+            // substring, line 160
+            among_var = find_among_b(a_5, 36);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 160
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 167
+                    // delete, line 167
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_derivational() {
+            int among_var;
+            // (, line 175
+            // [, line 176
+            ket = cursor;
+            // substring, line 176
+            among_var = find_among_b(a_6, 2);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 176
+            bra = cursor;
+            // call R2, line 176
+            if (!r_R2())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 179
+                    // delete, line 179
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_tidy_up() {
+            int among_var;
+            // (, line 183
+            // [, line 184
+            ket = cursor;
+            // substring, line 184
+            among_var = find_among_b(a_7, 4);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 184
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 188
+                    // delete, line 188
+                    slice_del();
+                    // [, line 189
+                    ket = cursor;
+                    // literal, line 189
+                    if (!(eq_s_b(1, "\u043D")))
+                    {
+                        return false;
+                    }
+                    // ], line 189
+                    bra = cursor;
+                    // literal, line 189
+                    if (!(eq_s_b(1, "\u043D")))
+                    {
+                        return false;
+                    }
+                    // delete, line 189
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 192
+                    // literal, line 192
+                    if (!(eq_s_b(1, "\u043D")))
+                    {
+                        return false;
+                    }
+                    // delete, line 192
+                    slice_del();
+                    break;
+                case 3:
+                    // (, line 194
+                    // delete, line 194
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            // (, line 199
+            // do, line 201
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 201
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 202
+            limit_backward = cursor; cursor = limit;
+            // setlimit, line 202
+            v_2 = limit - cursor;
+            // tomark, line 202
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_3 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_2;
+            // (, line 202
+            // do, line 203
+            v_4 = limit - cursor;
+            lab1: do {
+                // (, line 203
+                // or, line 204
+                lab2: do {
+                    v_5 = limit - cursor;
+                    lab3: do {
+                        // call perfective_gerund, line 204
+                        if (!r_perfective_gerund())
+                        {
+                            break lab3;
+                        }
+                        break lab2;
+                    } while (false);
+                    cursor = limit - v_5;
+                    // (, line 205
+                    // try, line 205
+                    v_6 = limit - cursor;
+                    lab4: do {
+                        // call reflexive, line 205
+                        if (!r_reflexive())
+                        {
+                            cursor = limit - v_6;
+                            break lab4;
+                        }
+                    } while (false);
+                    // or, line 206
+                    lab5: do {
+                        v_7 = limit - cursor;
+                        lab6: do {
+                            // call adjectival, line 206
+                            if (!r_adjectival())
+                            {
+                                break lab6;
+                            }
+                            break lab5;
+                        } while (false);
+                        cursor = limit - v_7;
+                        lab7: do {
+                            // call verb, line 206
+                            if (!r_verb())
+                            {
+                                break lab7;
+                            }
+                            break lab5;
+                        } while (false);
+                        cursor = limit - v_7;
+                        // call noun, line 206
+                        if (!r_noun())
+                        {
+                            break lab1;
+                        }
+                    } while (false);
+                } while (false);
+            } while (false);
+            cursor = limit - v_4;
+            // try, line 209
+            v_8 = limit - cursor;
+            lab8: do {
+                // (, line 209
+                // [, line 209
+                ket = cursor;
+                // literal, line 209
+                if (!(eq_s_b(1, "\u0438")))
+                {
+                    cursor = limit - v_8;
+                    break lab8;
+                }
+                // ], line 209
+                bra = cursor;
+                // delete, line 209
+                slice_del();
+            } while (false);
+            // do, line 212
+            v_9 = limit - cursor;
+            lab9: do {
+                // call derivational, line 212
+                if (!r_derivational())
+                {
+                    break lab9;
+                }
+            } while (false);
+            cursor = limit - v_9;
+            // do, line 213
+            v_10 = limit - cursor;
+            lab10: do {
+                // call tidy_up, line 213
+                if (!r_tidy_up())
+                {
+                    break lab10;
+                }
+            } while (false);
+            cursor = limit - v_10;
+            limit_backward = v_3;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/SpanishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/SpanishStemmer.java
new file mode 100644
index 0000000..acca4c4
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/SpanishStemmer.java
@@ -0,0 +1,1182 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class SpanishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "", -1, 6, "", this),
+            new Among ( "\u00E1", 0, 1, "", this),
+            new Among ( "\u00E9", 0, 2, "", this),
+            new Among ( "\u00ED", 0, 3, "", this),
+            new Among ( "\u00F3", 0, 4, "", this),
+            new Among ( "\u00FA", 0, 5, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "la", -1, -1, "", this),
+            new Among ( "sela", 0, -1, "", this),
+            new Among ( "le", -1, -1, "", this),
+            new Among ( "me", -1, -1, "", this),
+            new Among ( "se", -1, -1, "", this),
+            new Among ( "lo", -1, -1, "", this),
+            new Among ( "selo", 5, -1, "", this),
+            new Among ( "las", -1, -1, "", this),
+            new Among ( "selas", 7, -1, "", this),
+            new Among ( "les", -1, -1, "", this),
+            new Among ( "los", -1, -1, "", this),
+            new Among ( "selos", 10, -1, "", this),
+            new Among ( "nos", -1, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ando", -1, 6, "", this),
+            new Among ( "iendo", -1, 6, "", this),
+            new Among ( "yendo", -1, 7, "", this),
+            new Among ( "\u00E1ndo", -1, 2, "", this),
+            new Among ( "i\u00E9ndo", -1, 1, "", this),
+            new Among ( "ar", -1, 6, "", this),
+            new Among ( "er", -1, 6, "", this),
+            new Among ( "ir", -1, 6, "", this),
+            new Among ( "\u00E1r", -1, 3, "", this),
+            new Among ( "\u00E9r", -1, 4, "", this),
+            new Among ( "\u00EDr", -1, 5, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "ic", -1, -1, "", this),
+            new Among ( "ad", -1, -1, "", this),
+            new Among ( "os", -1, -1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "able", -1, 1, "", this),
+            new Among ( "ible", -1, 1, "", this),
+            new Among ( "ante", -1, 1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "ic", -1, 1, "", this),
+            new Among ( "abil", -1, 1, "", this),
+            new Among ( "iv", -1, 1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "ica", -1, 1, "", this),
+            new Among ( "ancia", -1, 2, "", this),
+            new Among ( "encia", -1, 5, "", this),
+            new Among ( "adora", -1, 2, "", this),
+            new Among ( "osa", -1, 1, "", this),
+            new Among ( "ista", -1, 1, "", this),
+            new Among ( "iva", -1, 9, "", this),
+            new Among ( "anza", -1, 1, "", this),
+            new Among ( "log\u00EDa", -1, 3, "", this),
+            new Among ( "idad", -1, 8, "", this),
+            new Among ( "able", -1, 1, "", this),
+            new Among ( "ible", -1, 1, "", this),
+            new Among ( "ante", -1, 2, "", this),
+            new Among ( "mente", -1, 7, "", this),
+            new Among ( "amente", 13, 6, "", this),
+            new Among ( "aci\u00F3n", -1, 2, "", this),
+            new Among ( "uci\u00F3n", -1, 4, "", this),
+            new Among ( "ico", -1, 1, "", this),
+            new Among ( "ismo", -1, 1, "", this),
+            new Among ( "oso", -1, 1, "", this),
+            new Among ( "amiento", -1, 1, "", this),
+            new Among ( "imiento", -1, 1, "", this),
+            new Among ( "ivo", -1, 9, "", this),
+            new Among ( "ador", -1, 2, "", this),
+            new Among ( "icas", -1, 1, "", this),
+            new Among ( "ancias", -1, 2, "", this),
+            new Among ( "encias", -1, 5, "", this),
+            new Among ( "adoras", -1, 2, "", this),
+            new Among ( "osas", -1, 1, "", this),
+            new Among ( "istas", -1, 1, "", this),
+            new Among ( "ivas", -1, 9, "", this),
+            new Among ( "anzas", -1, 1, "", this),
+            new Among ( "log\u00EDas", -1, 3, "", this),
+            new Among ( "idades", -1, 8, "", this),
+            new Among ( "ables", -1, 1, "", this),
+            new Among ( "ibles", -1, 1, "", this),
+            new Among ( "aciones", -1, 2, "", this),
+            new Among ( "uciones", -1, 4, "", this),
+            new Among ( "adores", -1, 2, "", this),
+            new Among ( "antes", -1, 2, "", this),
+            new Among ( "icos", -1, 1, "", this),
+            new Among ( "ismos", -1, 1, "", this),
+            new Among ( "osos", -1, 1, "", this),
+            new Among ( "amientos", -1, 1, "", this),
+            new Among ( "imientos", -1, 1, "", this),
+            new Among ( "ivos", -1, 9, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "ya", -1, 1, "", this),
+            new Among ( "ye", -1, 1, "", this),
+            new Among ( "yan", -1, 1, "", this),
+            new Among ( "yen", -1, 1, "", this),
+            new Among ( "yeron", -1, 1, "", this),
+            new Among ( "yendo", -1, 1, "", this),
+            new Among ( "yo", -1, 1, "", this),
+            new Among ( "yas", -1, 1, "", this),
+            new Among ( "yes", -1, 1, "", this),
+            new Among ( "yais", -1, 1, "", this),
+            new Among ( "yamos", -1, 1, "", this),
+            new Among ( "y\u00F3", -1, 1, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "aba", -1, 2, "", this),
+            new Among ( "ada", -1, 2, "", this),
+            new Among ( "ida", -1, 2, "", this),
+            new Among ( "ara", -1, 2, "", this),
+            new Among ( "iera", -1, 2, "", this),
+            new Among ( "\u00EDa", -1, 2, "", this),
+            new Among ( "ar\u00EDa", 5, 2, "", this),
+            new Among ( "er\u00EDa", 5, 2, "", this),
+            new Among ( "ir\u00EDa", 5, 2, "", this),
+            new Among ( "ad", -1, 2, "", this),
+            new Among ( "ed", -1, 2, "", this),
+            new Among ( "id", -1, 2, "", this),
+            new Among ( "ase", -1, 2, "", this),
+            new Among ( "iese", -1, 2, "", this),
+            new Among ( "aste", -1, 2, "", this),
+            new Among ( "iste", -1, 2, "", this),
+            new Among ( "an", -1, 2, "", this),
+            new Among ( "aban", 16, 2, "", this),
+            new Among ( "aran", 16, 2, "", this),
+            new Among ( "ieran", 16, 2, "", this),
+            new Among ( "\u00EDan", 16, 2, "", this),
+            new Among ( "ar\u00EDan", 20, 2, "", this),
+            new Among ( "er\u00EDan", 20, 2, "", this),
+            new Among ( "ir\u00EDan", 20, 2, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "asen", 24, 2, "", this),
+            new Among ( "iesen", 24, 2, "", this),
+            new Among ( "aron", -1, 2, "", this),
+            new Among ( "ieron", -1, 2, "", this),
+            new Among ( "ar\u00E1n", -1, 2, "", this),
+            new Among ( "er\u00E1n", -1, 2, "", this),
+            new Among ( "ir\u00E1n", -1, 2, "", this),
+            new Among ( "ado", -1, 2, "", this),
+            new Among ( "ido", -1, 2, "", this),
+            new Among ( "ando", -1, 2, "", this),
+            new Among ( "iendo", -1, 2, "", this),
+            new Among ( "ar", -1, 2, "", this),
+            new Among ( "er", -1, 2, "", this),
+            new Among ( "ir", -1, 2, "", this),
+            new Among ( "as", -1, 2, "", this),
+            new Among ( "abas", 39, 2, "", this),
+            new Among ( "adas", 39, 2, "", this),
+            new Among ( "idas", 39, 2, "", this),
+            new Among ( "aras", 39, 2, "", this),
+            new Among ( "ieras", 39, 2, "", this),
+            new Among ( "\u00EDas", 39, 2, "", this),
+            new Among ( "ar\u00EDas", 45, 2, "", this),
+            new Among ( "er\u00EDas", 45, 2, "", this),
+            new Among ( "ir\u00EDas", 45, 2, "", this),
+            new Among ( "es", -1, 1, "", this),
+            new Among ( "ases", 49, 2, "", this),
+            new Among ( "ieses", 49, 2, "", this),
+            new Among ( "abais", -1, 2, "", this),
+            new Among ( "arais", -1, 2, "", this),
+            new Among ( "ierais", -1, 2, "", this),
+            new Among ( "\u00EDais", -1, 2, "", this),
+            new Among ( "ar\u00EDais", 55, 2, "", this),
+            new Among ( "er\u00EDais", 55, 2, "", this),
+            new Among ( "ir\u00EDais", 55, 2, "", this),
+            new Among ( "aseis", -1, 2, "", this),
+            new Among ( "ieseis", -1, 2, "", this),
+            new Among ( "asteis", -1, 2, "", this),
+            new Among ( "isteis", -1, 2, "", this),
+            new Among ( "\u00E1is", -1, 2, "", this),
+            new Among ( "\u00E9is", -1, 1, "", this),
+            new Among ( "ar\u00E9is", 64, 2, "", this),
+            new Among ( "er\u00E9is", 64, 2, "", this),
+            new Among ( "ir\u00E9is", 64, 2, "", this),
+            new Among ( "ados", -1, 2, "", this),
+            new Among ( "idos", -1, 2, "", this),
+            new Among ( "amos", -1, 2, "", this),
+            new Among ( "\u00E1bamos", 70, 2, "", this),
+            new Among ( "\u00E1ramos", 70, 2, "", this),
+            new Among ( "i\u00E9ramos", 70, 2, "", this),
+            new Among ( "\u00EDamos", 70, 2, "", this),
+            new Among ( "ar\u00EDamos", 74, 2, "", this),
+            new Among ( "er\u00EDamos", 74, 2, "", this),
+            new Among ( "ir\u00EDamos", 74, 2, "", this),
+            new Among ( "emos", -1, 1, "", this),
+            new Among ( "aremos", 78, 2, "", this),
+            new Among ( "eremos", 78, 2, "", this),
+            new Among ( "iremos", 78, 2, "", this),
+            new Among ( "\u00E1semos", 78, 2, "", this),
+            new Among ( "i\u00E9semos", 78, 2, "", this),
+            new Among ( "imos", -1, 2, "", this),
+            new Among ( "ar\u00E1s", -1, 2, "", this),
+            new Among ( "er\u00E1s", -1, 2, "", this),
+            new Among ( "ir\u00E1s", -1, 2, "", this),
+            new Among ( "\u00EDs", -1, 2, "", this),
+            new Among ( "ar\u00E1", -1, 2, "", this),
+            new Among ( "er\u00E1", -1, 2, "", this),
+            new Among ( "ir\u00E1", -1, 2, "", this),
+            new Among ( "ar\u00E9", -1, 2, "", this),
+            new Among ( "er\u00E9", -1, 2, "", this),
+            new Among ( "ir\u00E9", -1, 2, "", this),
+            new Among ( "i\u00F3", -1, 2, "", this)
+        };
+
+        private Among a_9[] = {
+            new Among ( "a", -1, 1, "", this),
+            new Among ( "e", -1, 2, "", this),
+            new Among ( "o", -1, 1, "", this),
+            new Among ( "os", -1, 1, "", this),
+            new Among ( "\u00E1", -1, 1, "", this),
+            new Among ( "\u00E9", -1, 2, "", this),
+            new Among ( "\u00ED", -1, 1, "", this),
+            new Among ( "\u00F3", -1, 1, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 17, 4, 10 };
+
+        private int I_p2;
+        private int I_p1;
+        private int I_pV;
+
+        private void copy_from(SpanishStemmer other) {
+            I_p2 = other.I_p2;
+            I_p1 = other.I_p1;
+            I_pV = other.I_pV;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_6;
+            int v_8;
+            // (, line 31
+            I_pV = limit;
+            I_p1 = limit;
+            I_p2 = limit;
+            // do, line 37
+            v_1 = cursor;
+            lab0: do {
+                // (, line 37
+                // or, line 39
+                lab1: do {
+                    v_2 = cursor;
+                    lab2: do {
+                        // (, line 38
+                        if (!(in_grouping(g_v, 97, 252)))
+                        {
+                            break lab2;
+                        }
+                        // or, line 38
+                        lab3: do {
+                            v_3 = cursor;
+                            lab4: do {
+                                // (, line 38
+                                if (!(out_grouping(g_v, 97, 252)))
+                                {
+                                    break lab4;
+                                }
+                                // gopast, line 38
+                                golab5: while(true)
+                                {
+                                    lab6: do {
+                                        if (!(in_grouping(g_v, 97, 252)))
+                                        {
+                                            break lab6;
+                                        }
+                                        break golab5;
+                                    } while (false);
+                                    if (cursor >= limit)
+                                    {
+                                        break lab4;
+                                    }
+                                    cursor++;
+                                }
+                                break lab3;
+                            } while (false);
+                            cursor = v_3;
+                            // (, line 38
+                            if (!(in_grouping(g_v, 97, 252)))
+                            {
+                                break lab2;
+                            }
+                            // gopast, line 38
+                            golab7: while(true)
+                            {
+                                lab8: do {
+                                    if (!(out_grouping(g_v, 97, 252)))
+                                    {
+                                        break lab8;
+                                    }
+                                    break golab7;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab2;
+                                }
+                                cursor++;
+                            }
+                        } while (false);
+                        break lab1;
+                    } while (false);
+                    cursor = v_2;
+                    // (, line 40
+                    if (!(out_grouping(g_v, 97, 252)))
+                    {
+                        break lab0;
+                    }
+                    // or, line 40
+                    lab9: do {
+                        v_6 = cursor;
+                        lab10: do {
+                            // (, line 40
+                            if (!(out_grouping(g_v, 97, 252)))
+                            {
+                                break lab10;
+                            }
+                            // gopast, line 40
+                            golab11: while(true)
+                            {
+                                lab12: do {
+                                    if (!(in_grouping(g_v, 97, 252)))
+                                    {
+                                        break lab12;
+                                    }
+                                    break golab11;
+                                } while (false);
+                                if (cursor >= limit)
+                                {
+                                    break lab10;
+                                }
+                                cursor++;
+                            }
+                            break lab9;
+                        } while (false);
+                        cursor = v_6;
+                        // (, line 40
+                        if (!(in_grouping(g_v, 97, 252)))
+                        {
+                            break lab0;
+                        }
+                        // next, line 40
+                        if (cursor >= limit)
+                        {
+                            break lab0;
+                        }
+                        cursor++;
+                    } while (false);
+                } while (false);
+                // setmark pV, line 41
+                I_pV = cursor;
+            } while (false);
+            cursor = v_1;
+            // do, line 43
+            v_8 = cursor;
+            lab13: do {
+                // (, line 43
+                // gopast, line 44
+                golab14: while(true)
+                {
+                    lab15: do {
+                        if (!(in_grouping(g_v, 97, 252)))
+                        {
+                            break lab15;
+                        }
+                        break golab14;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 44
+                golab16: while(true)
+                {
+                    lab17: do {
+                        if (!(out_grouping(g_v, 97, 252)))
+                        {
+                            break lab17;
+                        }
+                        break golab16;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p1, line 44
+                I_p1 = cursor;
+                // gopast, line 45
+                golab18: while(true)
+                {
+                    lab19: do {
+                        if (!(in_grouping(g_v, 97, 252)))
+                        {
+                            break lab19;
+                        }
+                        break golab18;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // gopast, line 45
+                golab20: while(true)
+                {
+                    lab21: do {
+                        if (!(out_grouping(g_v, 97, 252)))
+                        {
+                            break lab21;
+                        }
+                        break golab20;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        break lab13;
+                    }
+                    cursor++;
+                }
+                // setmark p2, line 45
+                I_p2 = cursor;
+            } while (false);
+            cursor = v_8;
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int among_var;
+            int v_1;
+            // repeat, line 49
+            replab0: while(true)
+            {
+                v_1 = cursor;
+                lab1: do {
+                    // (, line 49
+                    // [, line 50
+                    bra = cursor;
+                    // substring, line 50
+                    among_var = find_among(a_0, 6);
+                    if (among_var == 0)
+                    {
+                        break lab1;
+                    }
+                    // ], line 50
+                    ket = cursor;
+                    switch(among_var) {
+                        case 0:
+                            break lab1;
+                        case 1:
+                            // (, line 51
+                            // <-, line 51
+                            slice_from("a");
+                            break;
+                        case 2:
+                            // (, line 52
+                            // <-, line 52
+                            slice_from("e");
+                            break;
+                        case 3:
+                            // (, line 53
+                            // <-, line 53
+                            slice_from("i");
+                            break;
+                        case 4:
+                            // (, line 54
+                            // <-, line 54
+                            slice_from("o");
+                            break;
+                        case 5:
+                            // (, line 55
+                            // <-, line 55
+                            slice_from("u");
+                            break;
+                        case 6:
+                            // (, line 57
+                            // next, line 57
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                            break;
+                    }
+                    continue replab0;
+                } while (false);
+                cursor = v_1;
+                break replab0;
+            }
+            return true;
+        }
+
+        private boolean r_RV() {
+            if (!(I_pV <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R1() {
+            if (!(I_p1 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_R2() {
+            if (!(I_p2 <= cursor))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_attached_pronoun() {
+            int among_var;
+            // (, line 67
+            // [, line 68
+            ket = cursor;
+            // substring, line 68
+            if (find_among_b(a_1, 13) == 0)
+            {
+                return false;
+            }
+            // ], line 68
+            bra = cursor;
+            // substring, line 72
+            among_var = find_among_b(a_2, 11);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // call RV, line 72
+            if (!r_RV())
+            {
+                return false;
+            }
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 73
+                    // ], line 73
+                    bra = cursor;
+                    // <-, line 73
+                    slice_from("iendo");
+                    break;
+                case 2:
+                    // (, line 74
+                    // ], line 74
+                    bra = cursor;
+                    // <-, line 74
+                    slice_from("ando");
+                    break;
+                case 3:
+                    // (, line 75
+                    // ], line 75
+                    bra = cursor;
+                    // <-, line 75
+                    slice_from("ar");
+                    break;
+                case 4:
+                    // (, line 76
+                    // ], line 76
+                    bra = cursor;
+                    // <-, line 76
+                    slice_from("er");
+                    break;
+                case 5:
+                    // (, line 77
+                    // ], line 77
+                    bra = cursor;
+                    // <-, line 77
+                    slice_from("ir");
+                    break;
+                case 6:
+                    // (, line 81
+                    // delete, line 81
+                    slice_del();
+                    break;
+                case 7:
+                    // (, line 82
+                    // literal, line 82
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        return false;
+                    }
+                    // delete, line 82
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_standard_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            // (, line 86
+            // [, line 87
+            ket = cursor;
+            // substring, line 87
+            among_var = find_among_b(a_6, 46);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 87
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 98
+                    // call R2, line 99
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 99
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 104
+                    // call R2, line 105
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 105
+                    slice_del();
+                    // try, line 106
+                    v_1 = limit - cursor;
+                    lab0: do {
+                        // (, line 106
+                        // [, line 106
+                        ket = cursor;
+                        // literal, line 106
+                        if (!(eq_s_b(2, "ic")))
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // ], line 106
+                        bra = cursor;
+                        // call R2, line 106
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // delete, line 106
+                        slice_del();
+                    } while (false);
+                    break;
+                case 3:
+                    // (, line 110
+                    // call R2, line 111
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 111
+                    slice_from("log");
+                    break;
+                case 4:
+                    // (, line 114
+                    // call R2, line 115
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 115
+                    slice_from("u");
+                    break;
+                case 5:
+                    // (, line 118
+                    // call R2, line 119
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // <-, line 119
+                    slice_from("ente");
+                    break;
+                case 6:
+                    // (, line 122
+                    // call R1, line 123
+                    if (!r_R1())
+                    {
+                        return false;
+                    }
+                    // delete, line 123
+                    slice_del();
+                    // try, line 124
+                    v_2 = limit - cursor;
+                    lab1: do {
+                        // (, line 124
+                        // [, line 125
+                        ket = cursor;
+                        // substring, line 125
+                        among_var = find_among_b(a_3, 4);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_2;
+                            break lab1;
+                        }
+                        // ], line 125
+                        bra = cursor;
+                        // call R2, line 125
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_2;
+                            break lab1;
+                        }
+                        // delete, line 125
+                        slice_del();
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_2;
+                                break lab1;
+                            case 1:
+                                // (, line 126
+                                // [, line 126
+                                ket = cursor;
+                                // literal, line 126
+                                if (!(eq_s_b(2, "at")))
+                                {
+                                    cursor = limit - v_2;
+                                    break lab1;
+                                }
+                                // ], line 126
+                                bra = cursor;
+                                // call R2, line 126
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_2;
+                                    break lab1;
+                                }
+                                // delete, line 126
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 7:
+                    // (, line 134
+                    // call R2, line 135
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 135
+                    slice_del();
+                    // try, line 136
+                    v_3 = limit - cursor;
+                    lab2: do {
+                        // (, line 136
+                        // [, line 137
+                        ket = cursor;
+                        // substring, line 137
+                        among_var = find_among_b(a_4, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_3;
+                            break lab2;
+                        }
+                        // ], line 137
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_3;
+                                break lab2;
+                            case 1:
+                                // (, line 140
+                                // call R2, line 140
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_3;
+                                    break lab2;
+                                }
+                                // delete, line 140
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 8:
+                    // (, line 146
+                    // call R2, line 147
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 147
+                    slice_del();
+                    // try, line 148
+                    v_4 = limit - cursor;
+                    lab3: do {
+                        // (, line 148
+                        // [, line 149
+                        ket = cursor;
+                        // substring, line 149
+                        among_var = find_among_b(a_5, 3);
+                        if (among_var == 0)
+                        {
+                            cursor = limit - v_4;
+                            break lab3;
+                        }
+                        // ], line 149
+                        bra = cursor;
+                        switch(among_var) {
+                            case 0:
+                                cursor = limit - v_4;
+                                break lab3;
+                            case 1:
+                                // (, line 152
+                                // call R2, line 152
+                                if (!r_R2())
+                                {
+                                    cursor = limit - v_4;
+                                    break lab3;
+                                }
+                                // delete, line 152
+                                slice_del();
+                                break;
+                        }
+                    } while (false);
+                    break;
+                case 9:
+                    // (, line 158
+                    // call R2, line 159
+                    if (!r_R2())
+                    {
+                        return false;
+                    }
+                    // delete, line 159
+                    slice_del();
+                    // try, line 160
+                    v_5 = limit - cursor;
+                    lab4: do {
+                        // (, line 160
+                        // [, line 161
+                        ket = cursor;
+                        // literal, line 161
+                        if (!(eq_s_b(2, "at")))
+                        {
+                            cursor = limit - v_5;
+                            break lab4;
+                        }
+                        // ], line 161
+                        bra = cursor;
+                        // call R2, line 161
+                        if (!r_R2())
+                        {
+                            cursor = limit - v_5;
+                            break lab4;
+                        }
+                        // delete, line 161
+                        slice_del();
+                    } while (false);
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_y_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 167
+            // setlimit, line 168
+            v_1 = limit - cursor;
+            // tomark, line 168
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 168
+            // [, line 168
+            ket = cursor;
+            // substring, line 168
+            among_var = find_among_b(a_7, 12);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 168
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 171
+                    // literal, line 171
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        return false;
+                    }
+                    // delete, line 171
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_verb_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 175
+            // setlimit, line 176
+            v_1 = limit - cursor;
+            // tomark, line 176
+            if (cursor < I_pV)
+            {
+                return false;
+            }
+            cursor = I_pV;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 176
+            // [, line 176
+            ket = cursor;
+            // substring, line 176
+            among_var = find_among_b(a_8, 96);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 176
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 179
+                    // try, line 179
+                    v_3 = limit - cursor;
+                    lab0: do {
+                        // (, line 179
+                        // literal, line 179
+                        if (!(eq_s_b(1, "u")))
+                        {
+                            cursor = limit - v_3;
+                            break lab0;
+                        }
+                        // test, line 179
+                        v_4 = limit - cursor;
+                        // literal, line 179
+                        if (!(eq_s_b(1, "g")))
+                        {
+                            cursor = limit - v_3;
+                            break lab0;
+                        }
+                        cursor = limit - v_4;
+                    } while (false);
+                    // ], line 179
+                    bra = cursor;
+                    // delete, line 179
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 200
+                    // delete, line 200
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_residual_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 204
+            // [, line 205
+            ket = cursor;
+            // substring, line 205
+            among_var = find_among_b(a_9, 8);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 205
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 208
+                    // call RV, line 208
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 208
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 210
+                    // call RV, line 210
+                    if (!r_RV())
+                    {
+                        return false;
+                    }
+                    // delete, line 210
+                    slice_del();
+                    // try, line 210
+                    v_1 = limit - cursor;
+                    lab0: do {
+                        // (, line 210
+                        // [, line 210
+                        ket = cursor;
+                        // literal, line 210
+                        if (!(eq_s_b(1, "u")))
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // ], line 210
+                        bra = cursor;
+                        // test, line 210
+                        v_2 = limit - cursor;
+                        // literal, line 210
+                        if (!(eq_s_b(1, "g")))
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        cursor = limit - v_2;
+                        // call RV, line 210
+                        if (!r_RV())
+                        {
+                            cursor = limit - v_1;
+                            break lab0;
+                        }
+                        // delete, line 210
+                        slice_del();
+                    } while (false);
+                    break;
+            }
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            // (, line 215
+            // do, line 216
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 216
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 217
+            limit_backward = cursor; cursor = limit;
+            // (, line 217
+            // do, line 218
+            v_2 = limit - cursor;
+            lab1: do {
+                // call attached_pronoun, line 218
+                if (!r_attached_pronoun())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 219
+            v_3 = limit - cursor;
+            lab2: do {
+                // (, line 219
+                // or, line 219
+                lab3: do {
+                    v_4 = limit - cursor;
+                    lab4: do {
+                        // call standard_suffix, line 219
+                        if (!r_standard_suffix())
+                        {
+                            break lab4;
+                        }
+                        break lab3;
+                    } while (false);
+                    cursor = limit - v_4;
+                    lab5: do {
+                        // call y_verb_suffix, line 220
+                        if (!r_y_verb_suffix())
+                        {
+                            break lab5;
+                        }
+                        break lab3;
+                    } while (false);
+                    cursor = limit - v_4;
+                    // call verb_suffix, line 221
+                    if (!r_verb_suffix())
+                    {
+                        break lab2;
+                    }
+                } while (false);
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 223
+            v_5 = limit - cursor;
+            lab6: do {
+                // call residual_suffix, line 223
+                if (!r_residual_suffix())
+                {
+                    break lab6;
+                }
+            } while (false);
+            cursor = limit - v_5;
+            cursor = limit_backward;            // do, line 225
+            v_6 = cursor;
+            lab7: do {
+                // call postlude, line 225
+                if (!r_postlude())
+                {
+                    break lab7;
+                }
+            } while (false);
+            cursor = v_6;
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/SwedishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/SwedishStemmer.java
new file mode 100644
index 0000000..d1b33ec
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/SwedishStemmer.java
@@ -0,0 +1,349 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class SwedishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "a", -1, 1, "", this),
+            new Among ( "arna", 0, 1, "", this),
+            new Among ( "erna", 0, 1, "", this),
+            new Among ( "heterna", 2, 1, "", this),
+            new Among ( "orna", 0, 1, "", this),
+            new Among ( "ad", -1, 1, "", this),
+            new Among ( "e", -1, 1, "", this),
+            new Among ( "ade", 6, 1, "", this),
+            new Among ( "ande", 6, 1, "", this),
+            new Among ( "arne", 6, 1, "", this),
+            new Among ( "are", 6, 1, "", this),
+            new Among ( "aste", 6, 1, "", this),
+            new Among ( "en", -1, 1, "", this),
+            new Among ( "anden", 12, 1, "", this),
+            new Among ( "aren", 12, 1, "", this),
+            new Among ( "heten", 12, 1, "", this),
+            new Among ( "ern", -1, 1, "", this),
+            new Among ( "ar", -1, 1, "", this),
+            new Among ( "er", -1, 1, "", this),
+            new Among ( "heter", 18, 1, "", this),
+            new Among ( "or", -1, 1, "", this),
+            new Among ( "s", -1, 2, "", this),
+            new Among ( "as", 21, 1, "", this),
+            new Among ( "arnas", 22, 1, "", this),
+            new Among ( "ernas", 22, 1, "", this),
+            new Among ( "ornas", 22, 1, "", this),
+            new Among ( "es", 21, 1, "", this),
+            new Among ( "ades", 26, 1, "", this),
+            new Among ( "andes", 26, 1, "", this),
+            new Among ( "ens", 21, 1, "", this),
+            new Among ( "arens", 29, 1, "", this),
+            new Among ( "hetens", 29, 1, "", this),
+            new Among ( "erns", 21, 1, "", this),
+            new Among ( "at", -1, 1, "", this),
+            new Among ( "andet", -1, 1, "", this),
+            new Among ( "het", -1, 1, "", this),
+            new Among ( "ast", -1, 1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "dd", -1, -1, "", this),
+            new Among ( "gd", -1, -1, "", this),
+            new Among ( "nn", -1, -1, "", this),
+            new Among ( "dt", -1, -1, "", this),
+            new Among ( "gt", -1, -1, "", this),
+            new Among ( "kt", -1, -1, "", this),
+            new Among ( "tt", -1, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ig", -1, 1, "", this),
+            new Among ( "lig", 0, 1, "", this),
+            new Among ( "els", -1, 1, "", this),
+            new Among ( "fullt", -1, 3, "", this),
+            new Among ( "l\u00F6st", -1, 2, "", this)
+        };
+
+        private static final char g_v[] = {17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 32 };
+
+        private static final char g_s_ending[] = {119, 127, 149 };
+
+        private int I_x;
+        private int I_p1;
+
+        private void copy_from(SwedishStemmer other) {
+            I_x = other.I_x;
+            I_p1 = other.I_p1;
+            super.copy_from(other);
+        }
+
+        private boolean r_mark_regions() {
+            int v_1;
+            int v_2;
+            // (, line 26
+            I_p1 = limit;
+            // test, line 29
+            v_1 = cursor;
+            // (, line 29
+            // hop, line 29
+            {
+                int c = cursor + 3;
+                if (0 > c || c > limit)
+                {
+                    return false;
+                }
+                cursor = c;
+            }
+            // setmark x, line 29
+            I_x = cursor;
+            cursor = v_1;
+            // goto, line 30
+            golab0: while(true)
+            {
+                v_2 = cursor;
+                lab1: do {
+                    if (!(in_grouping(g_v, 97, 246)))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_2;
+                    break golab0;
+                } while (false);
+                cursor = v_2;
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // gopast, line 30
+            golab2: while(true)
+            {
+                lab3: do {
+                    if (!(out_grouping(g_v, 97, 246)))
+                    {
+                        break lab3;
+                    }
+                    break golab2;
+                } while (false);
+                if (cursor >= limit)
+                {
+                    return false;
+                }
+                cursor++;
+            }
+            // setmark p1, line 30
+            I_p1 = cursor;
+            // try, line 31
+            lab4: do {
+                // (, line 31
+                if (!(I_p1 < I_x))
+                {
+                    break lab4;
+                }
+                I_p1 = I_x;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_main_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // (, line 36
+            // setlimit, line 37
+            v_1 = limit - cursor;
+            // tomark, line 37
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 37
+            // [, line 37
+            ket = cursor;
+            // substring, line 37
+            among_var = find_among_b(a_0, 37);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 37
+            bra = cursor;
+            limit_backward = v_2;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 44
+                    // delete, line 44
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 46
+                    if (!(in_grouping_b(g_s_ending, 98, 121)))
+                    {
+                        return false;
+                    }
+                    // delete, line 46
+                    slice_del();
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_consonant_pair() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // setlimit, line 50
+            v_1 = limit - cursor;
+            // tomark, line 50
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 50
+            // and, line 52
+            v_3 = limit - cursor;
+            // among, line 51
+            if (find_among_b(a_1, 7) == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            cursor = limit - v_3;
+            // (, line 52
+            // [, line 52
+            ket = cursor;
+            // next, line 52
+            if (cursor <= limit_backward)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            cursor--;
+            // ], line 52
+            bra = cursor;
+            // delete, line 52
+            slice_del();
+            limit_backward = v_2;
+            return true;
+        }
+
+        private boolean r_other_suffix() {
+            int among_var;
+            int v_1;
+            int v_2;
+            // setlimit, line 55
+            v_1 = limit - cursor;
+            // tomark, line 55
+            if (cursor < I_p1)
+            {
+                return false;
+            }
+            cursor = I_p1;
+            v_2 = limit_backward;
+            limit_backward = cursor;
+            cursor = limit - v_1;
+            // (, line 55
+            // [, line 56
+            ket = cursor;
+            // substring, line 56
+            among_var = find_among_b(a_2, 5);
+            if (among_var == 0)
+            {
+                limit_backward = v_2;
+                return false;
+            }
+            // ], line 56
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    limit_backward = v_2;
+                    return false;
+                case 1:
+                    // (, line 57
+                    // delete, line 57
+                    slice_del();
+                    break;
+                case 2:
+                    // (, line 58
+                    // <-, line 58
+                    slice_from("l\u00F6s");
+                    break;
+                case 3:
+                    // (, line 59
+                    // <-, line 59
+                    slice_from("full");
+                    break;
+            }
+            limit_backward = v_2;
+            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            // (, line 64
+            // do, line 66
+            v_1 = cursor;
+            lab0: do {
+                // call mark_regions, line 66
+                if (!r_mark_regions())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = v_1;
+            // backwards, line 67
+            limit_backward = cursor; cursor = limit;
+            // (, line 67
+            // do, line 68
+            v_2 = limit - cursor;
+            lab1: do {
+                // call main_suffix, line 68
+                if (!r_main_suffix())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 69
+            v_3 = limit - cursor;
+            lab2: do {
+                // call consonant_pair, line 69
+                if (!r_consonant_pair())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            // do, line 70
+            v_4 = limit - cursor;
+            lab3: do {
+                // call other_suffix, line 70
+                if (!r_other_suffix())
+                {
+                    break lab3;
+                }
+            } while (false);
+            cursor = limit - v_4;
+            cursor = limit_backward;            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/org/tartarus/snowball/ext/TurkishStemmer.java b/contrib/snowball/src/java/org/tartarus/snowball/ext/TurkishStemmer.java
new file mode 100644
index 0000000..0e4c7b0
--- /dev/null
+++ b/contrib/snowball/src/java/org/tartarus/snowball/ext/TurkishStemmer.java
@@ -0,0 +1,3130 @@
+// This file was generated automatically by the Snowball to Java compiler
+
+package org.tartarus.snowball.ext;
+import org.tartarus.snowball.SnowballProgram;
+import org.tartarus.snowball.Among;
+
+/**
+ * Generated class implementing code defined by a snowball script.
+ */
+public class TurkishStemmer extends SnowballProgram {
+
+        private Among a_0[] = {
+            new Among ( "m", -1, -1, "", this),
+            new Among ( "n", -1, -1, "", this),
+            new Among ( "miz", -1, -1, "", this),
+            new Among ( "niz", -1, -1, "", this),
+            new Among ( "muz", -1, -1, "", this),
+            new Among ( "nuz", -1, -1, "", this),
+            new Among ( "m\u00FCz", -1, -1, "", this),
+            new Among ( "n\u00FCz", -1, -1, "", this),
+            new Among ( "m\u0131z", -1, -1, "", this),
+            new Among ( "n\u0131z", -1, -1, "", this)
+        };
+
+        private Among a_1[] = {
+            new Among ( "leri", -1, -1, "", this),
+            new Among ( "lar\u0131", -1, -1, "", this)
+        };
+
+        private Among a_2[] = {
+            new Among ( "ni", -1, -1, "", this),
+            new Among ( "nu", -1, -1, "", this),
+            new Among ( "n\u00FC", -1, -1, "", this),
+            new Among ( "n\u0131", -1, -1, "", this)
+        };
+
+        private Among a_3[] = {
+            new Among ( "in", -1, -1, "", this),
+            new Among ( "un", -1, -1, "", this),
+            new Among ( "\u00FCn", -1, -1, "", this),
+            new Among ( "\u0131n", -1, -1, "", this)
+        };
+
+        private Among a_4[] = {
+            new Among ( "a", -1, -1, "", this),
+            new Among ( "e", -1, -1, "", this)
+        };
+
+        private Among a_5[] = {
+            new Among ( "na", -1, -1, "", this),
+            new Among ( "ne", -1, -1, "", this)
+        };
+
+        private Among a_6[] = {
+            new Among ( "da", -1, -1, "", this),
+            new Among ( "ta", -1, -1, "", this),
+            new Among ( "de", -1, -1, "", this),
+            new Among ( "te", -1, -1, "", this)
+        };
+
+        private Among a_7[] = {
+            new Among ( "nda", -1, -1, "", this),
+            new Among ( "nde", -1, -1, "", this)
+        };
+
+        private Among a_8[] = {
+            new Among ( "dan", -1, -1, "", this),
+            new Among ( "tan", -1, -1, "", this),
+            new Among ( "den", -1, -1, "", this),
+            new Among ( "ten", -1, -1, "", this)
+        };
+
+        private Among a_9[] = {
+            new Among ( "ndan", -1, -1, "", this),
+            new Among ( "nden", -1, -1, "", this)
+        };
+
+        private Among a_10[] = {
+            new Among ( "la", -1, -1, "", this),
+            new Among ( "le", -1, -1, "", this)
+        };
+
+        private Among a_11[] = {
+            new Among ( "ca", -1, -1, "", this),
+            new Among ( "ce", -1, -1, "", this)
+        };
+
+        private Among a_12[] = {
+            new Among ( "im", -1, -1, "", this),
+            new Among ( "um", -1, -1, "", this),
+            new Among ( "\u00FCm", -1, -1, "", this),
+            new Among ( "\u0131m", -1, -1, "", this)
+        };
+
+        private Among a_13[] = {
+            new Among ( "sin", -1, -1, "", this),
+            new Among ( "sun", -1, -1, "", this),
+            new Among ( "s\u00FCn", -1, -1, "", this),
+            new Among ( "s\u0131n", -1, -1, "", this)
+        };
+
+        private Among a_14[] = {
+            new Among ( "iz", -1, -1, "", this),
+            new Among ( "uz", -1, -1, "", this),
+            new Among ( "\u00FCz", -1, -1, "", this),
+            new Among ( "\u0131z", -1, -1, "", this)
+        };
+
+        private Among a_15[] = {
+            new Among ( "siniz", -1, -1, "", this),
+            new Among ( "sunuz", -1, -1, "", this),
+            new Among ( "s\u00FCn\u00FCz", -1, -1, "", this),
+            new Among ( "s\u0131n\u0131z", -1, -1, "", this)
+        };
+
+        private Among a_16[] = {
+            new Among ( "lar", -1, -1, "", this),
+            new Among ( "ler", -1, -1, "", this)
+        };
+
+        private Among a_17[] = {
+            new Among ( "niz", -1, -1, "", this),
+            new Among ( "nuz", -1, -1, "", this),
+            new Among ( "n\u00FCz", -1, -1, "", this),
+            new Among ( "n\u0131z", -1, -1, "", this)
+        };
+
+        private Among a_18[] = {
+            new Among ( "dir", -1, -1, "", this),
+            new Among ( "tir", -1, -1, "", this),
+            new Among ( "dur", -1, -1, "", this),
+            new Among ( "tur", -1, -1, "", this),
+            new Among ( "d\u00FCr", -1, -1, "", this),
+            new Among ( "t\u00FCr", -1, -1, "", this),
+            new Among ( "d\u0131r", -1, -1, "", this),
+            new Among ( "t\u0131r", -1, -1, "", this)
+        };
+
+        private Among a_19[] = {
+            new Among ( "cas\u0131na", -1, -1, "", this),
+            new Among ( "cesine", -1, -1, "", this)
+        };
+
+        private Among a_20[] = {
+            new Among ( "di", -1, -1, "", this),
+            new Among ( "ti", -1, -1, "", this),
+            new Among ( "dik", -1, -1, "", this),
+            new Among ( "tik", -1, -1, "", this),
+            new Among ( "duk", -1, -1, "", this),
+            new Among ( "tuk", -1, -1, "", this),
+            new Among ( "d\u00FCk", -1, -1, "", this),
+            new Among ( "t\u00FCk", -1, -1, "", this),
+            new Among ( "d\u0131k", -1, -1, "", this),
+            new Among ( "t\u0131k", -1, -1, "", this),
+            new Among ( "dim", -1, -1, "", this),
+            new Among ( "tim", -1, -1, "", this),
+            new Among ( "dum", -1, -1, "", this),
+            new Among ( "tum", -1, -1, "", this),
+            new Among ( "d\u00FCm", -1, -1, "", this),
+            new Among ( "t\u00FCm", -1, -1, "", this),
+            new Among ( "d\u0131m", -1, -1, "", this),
+            new Among ( "t\u0131m", -1, -1, "", this),
+            new Among ( "din", -1, -1, "", this),
+            new Among ( "tin", -1, -1, "", this),
+            new Among ( "dun", -1, -1, "", this),
+            new Among ( "tun", -1, -1, "", this),
+            new Among ( "d\u00FCn", -1, -1, "", this),
+            new Among ( "t\u00FCn", -1, -1, "", this),
+            new Among ( "d\u0131n", -1, -1, "", this),
+            new Among ( "t\u0131n", -1, -1, "", this),
+            new Among ( "du", -1, -1, "", this),
+            new Among ( "tu", -1, -1, "", this),
+            new Among ( "d\u00FC", -1, -1, "", this),
+            new Among ( "t\u00FC", -1, -1, "", this),
+            new Among ( "d\u0131", -1, -1, "", this),
+            new Among ( "t\u0131", -1, -1, "", this)
+        };
+
+        private Among a_21[] = {
+            new Among ( "sa", -1, -1, "", this),
+            new Among ( "se", -1, -1, "", this),
+            new Among ( "sak", -1, -1, "", this),
+            new Among ( "sek", -1, -1, "", this),
+            new Among ( "sam", -1, -1, "", this),
+            new Among ( "sem", -1, -1, "", this),
+            new Among ( "san", -1, -1, "", this),
+            new Among ( "sen", -1, -1, "", this)
+        };
+
+        private Among a_22[] = {
+            new Among ( "mi\u015F", -1, -1, "", this),
+            new Among ( "mu\u015F", -1, -1, "", this),
+            new Among ( "m\u00FC\u015F", -1, -1, "", this),
+            new Among ( "m\u0131\u015F", -1, -1, "", this)
+        };
+
+        private Among a_23[] = {
+            new Among ( "b", -1, 1, "", this),
+            new Among ( "c", -1, 2, "", this),
+            new Among ( "d", -1, 3, "", this),
+            new Among ( "\u011F", -1, 4, "", this)
+        };
+
+        private static final char g_vowel[] = {17, 65, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 8, 0, 0, 0, 0, 0, 0, 1 };
+
+        private static final char g_U[] = {1, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 1 };
+
+        private static final char g_vowel1[] = {1, 64, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+        private static final char g_vowel2[] = {17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130 };
+
+        private static final char g_vowel3[] = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+        private static final char g_vowel4[] = {17 };
+
+        private static final char g_vowel5[] = {65 };
+
+        private static final char g_vowel6[] = {65 };
+
+        private boolean B_continue_stemming_noun_suffixes;
+        private int I_strlen;
+
+        private void copy_from(TurkishStemmer other) {
+            B_continue_stemming_noun_suffixes = other.B_continue_stemming_noun_suffixes;
+            I_strlen = other.I_strlen;
+            super.copy_from(other);
+        }
+
+        private boolean r_check_vowel_harmony() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            // (, line 111
+            // test, line 112
+            v_1 = limit - cursor;
+            // (, line 113
+            // (, line 114
+            // goto, line 114
+            golab0: while(true)
+            {
+                v_2 = limit - cursor;
+                lab1: do {
+                    if (!(in_grouping_b(g_vowel, 97, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_2;
+                    break golab0;
+                } while (false);
+                cursor = limit - v_2;
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+            }
+            // (, line 115
+            // or, line 116
+            lab2: do {
+                v_3 = limit - cursor;
+                lab3: do {
+                    // (, line 116
+                    // literal, line 116
+                    if (!(eq_s_b(1, "a")))
+                    {
+                        break lab3;
+                    }
+                    // goto, line 116
+                    golab4: while(true)
+                    {
+                        v_4 = limit - cursor;
+                        lab5: do {
+                            if (!(in_grouping_b(g_vowel1, 97, 305)))
+                            {
+                                break lab5;
+                            }
+                            cursor = limit - v_4;
+                            break golab4;
+                        } while (false);
+                        cursor = limit - v_4;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab3;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab6: do {
+                    // (, line 117
+                    // literal, line 117
+                    if (!(eq_s_b(1, "e")))
+                    {
+                        break lab6;
+                    }
+                    // goto, line 117
+                    golab7: while(true)
+                    {
+                        v_5 = limit - cursor;
+                        lab8: do {
+                            if (!(in_grouping_b(g_vowel2, 101, 252)))
+                            {
+                                break lab8;
+                            }
+                            cursor = limit - v_5;
+                            break golab7;
+                        } while (false);
+                        cursor = limit - v_5;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab6;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab9: do {
+                    // (, line 118
+                    // literal, line 118
+                    if (!(eq_s_b(1, "\u0131")))
+                    {
+                        break lab9;
+                    }
+                    // goto, line 118
+                    golab10: while(true)
+                    {
+                        v_6 = limit - cursor;
+                        lab11: do {
+                            if (!(in_grouping_b(g_vowel3, 97, 305)))
+                            {
+                                break lab11;
+                            }
+                            cursor = limit - v_6;
+                            break golab10;
+                        } while (false);
+                        cursor = limit - v_6;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab9;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab12: do {
+                    // (, line 119
+                    // literal, line 119
+                    if (!(eq_s_b(1, "i")))
+                    {
+                        break lab12;
+                    }
+                    // goto, line 119
+                    golab13: while(true)
+                    {
+                        v_7 = limit - cursor;
+                        lab14: do {
+                            if (!(in_grouping_b(g_vowel4, 101, 105)))
+                            {
+                                break lab14;
+                            }
+                            cursor = limit - v_7;
+                            break golab13;
+                        } while (false);
+                        cursor = limit - v_7;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab12;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab15: do {
+                    // (, line 120
+                    // literal, line 120
+                    if (!(eq_s_b(1, "o")))
+                    {
+                        break lab15;
+                    }
+                    // goto, line 120
+                    golab16: while(true)
+                    {
+                        v_8 = limit - cursor;
+                        lab17: do {
+                            if (!(in_grouping_b(g_vowel5, 111, 117)))
+                            {
+                                break lab17;
+                            }
+                            cursor = limit - v_8;
+                            break golab16;
+                        } while (false);
+                        cursor = limit - v_8;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab15;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab18: do {
+                    // (, line 121
+                    // literal, line 121
+                    if (!(eq_s_b(1, "\u00F6")))
+                    {
+                        break lab18;
+                    }
+                    // goto, line 121
+                    golab19: while(true)
+                    {
+                        v_9 = limit - cursor;
+                        lab20: do {
+                            if (!(in_grouping_b(g_vowel6, 246, 252)))
+                            {
+                                break lab20;
+                            }
+                            cursor = limit - v_9;
+                            break golab19;
+                        } while (false);
+                        cursor = limit - v_9;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab18;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab21: do {
+                    // (, line 122
+                    // literal, line 122
+                    if (!(eq_s_b(1, "u")))
+                    {
+                        break lab21;
+                    }
+                    // goto, line 122
+                    golab22: while(true)
+                    {
+                        v_10 = limit - cursor;
+                        lab23: do {
+                            if (!(in_grouping_b(g_vowel5, 111, 117)))
+                            {
+                                break lab23;
+                            }
+                            cursor = limit - v_10;
+                            break golab22;
+                        } while (false);
+                        cursor = limit - v_10;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab21;
+                        }
+                        cursor--;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                // (, line 123
+                // literal, line 123
+                if (!(eq_s_b(1, "\u00FC")))
+                {
+                    return false;
+                }
+                // goto, line 123
+                golab24: while(true)
+                {
+                    v_11 = limit - cursor;
+                    lab25: do {
+                        if (!(in_grouping_b(g_vowel6, 246, 252)))
+                        {
+                            break lab25;
+                        }
+                        cursor = limit - v_11;
+                        break golab24;
+                    } while (false);
+                    cursor = limit - v_11;
+                    if (cursor <= limit_backward)
+                    {
+                        return false;
+                    }
+                    cursor--;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            return true;
+        }
+
+        private boolean r_mark_suffix_with_optional_n_consonant() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            // (, line 132
+            // or, line 134
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 133
+                    // (, line 133
+                    // test, line 133
+                    v_2 = limit - cursor;
+                    // literal, line 133
+                    if (!(eq_s_b(1, "n")))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_2;
+                    // next, line 133
+                    if (cursor <= limit_backward)
+                    {
+                        break lab1;
+                    }
+                    cursor--;
+                    // (, line 133
+                    // test, line 133
+                    v_3 = limit - cursor;
+                    if (!(in_grouping_b(g_vowel, 97, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_3;
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 135
+                // (, line 135
+                // not, line 135
+                {
+                    v_4 = limit - cursor;
+                    lab2: do {
+                        // (, line 135
+                        // test, line 135
+                        v_5 = limit - cursor;
+                        // literal, line 135
+                        if (!(eq_s_b(1, "n")))
+                        {
+                            break lab2;
+                        }
+                        cursor = limit - v_5;
+                        return false;
+                    } while (false);
+                    cursor = limit - v_4;
+                }
+                // test, line 135
+                v_6 = limit - cursor;
+                // (, line 135
+                // next, line 135
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // (, line 135
+                // test, line 135
+                v_7 = limit - cursor;
+                if (!(in_grouping_b(g_vowel, 97, 305)))
+                {
+                    return false;
+                }
+                cursor = limit - v_7;
+                cursor = limit - v_6;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_mark_suffix_with_optional_s_consonant() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            // (, line 143
+            // or, line 145
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 144
+                    // (, line 144
+                    // test, line 144
+                    v_2 = limit - cursor;
+                    // literal, line 144
+                    if (!(eq_s_b(1, "s")))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_2;
+                    // next, line 144
+                    if (cursor <= limit_backward)
+                    {
+                        break lab1;
+                    }
+                    cursor--;
+                    // (, line 144
+                    // test, line 144
+                    v_3 = limit - cursor;
+                    if (!(in_grouping_b(g_vowel, 97, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_3;
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 146
+                // (, line 146
+                // not, line 146
+                {
+                    v_4 = limit - cursor;
+                    lab2: do {
+                        // (, line 146
+                        // test, line 146
+                        v_5 = limit - cursor;
+                        // literal, line 146
+                        if (!(eq_s_b(1, "s")))
+                        {
+                            break lab2;
+                        }
+                        cursor = limit - v_5;
+                        return false;
+                    } while (false);
+                    cursor = limit - v_4;
+                }
+                // test, line 146
+                v_6 = limit - cursor;
+                // (, line 146
+                // next, line 146
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // (, line 146
+                // test, line 146
+                v_7 = limit - cursor;
+                if (!(in_grouping_b(g_vowel, 97, 305)))
+                {
+                    return false;
+                }
+                cursor = limit - v_7;
+                cursor = limit - v_6;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_mark_suffix_with_optional_y_consonant() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            // (, line 153
+            // or, line 155
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 154
+                    // (, line 154
+                    // test, line 154
+                    v_2 = limit - cursor;
+                    // literal, line 154
+                    if (!(eq_s_b(1, "y")))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_2;
+                    // next, line 154
+                    if (cursor <= limit_backward)
+                    {
+                        break lab1;
+                    }
+                    cursor--;
+                    // (, line 154
+                    // test, line 154
+                    v_3 = limit - cursor;
+                    if (!(in_grouping_b(g_vowel, 97, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_3;
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 156
+                // (, line 156
+                // not, line 156
+                {
+                    v_4 = limit - cursor;
+                    lab2: do {
+                        // (, line 156
+                        // test, line 156
+                        v_5 = limit - cursor;
+                        // literal, line 156
+                        if (!(eq_s_b(1, "y")))
+                        {
+                            break lab2;
+                        }
+                        cursor = limit - v_5;
+                        return false;
+                    } while (false);
+                    cursor = limit - v_4;
+                }
+                // test, line 156
+                v_6 = limit - cursor;
+                // (, line 156
+                // next, line 156
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // (, line 156
+                // test, line 156
+                v_7 = limit - cursor;
+                if (!(in_grouping_b(g_vowel, 97, 305)))
+                {
+                    return false;
+                }
+                cursor = limit - v_7;
+                cursor = limit - v_6;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_mark_suffix_with_optional_U_vowel() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            // (, line 159
+            // or, line 161
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 160
+                    // (, line 160
+                    // test, line 160
+                    v_2 = limit - cursor;
+                    if (!(in_grouping_b(g_U, 105, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_2;
+                    // next, line 160
+                    if (cursor <= limit_backward)
+                    {
+                        break lab1;
+                    }
+                    cursor--;
+                    // (, line 160
+                    // test, line 160
+                    v_3 = limit - cursor;
+                    if (!(out_grouping_b(g_vowel, 97, 305)))
+                    {
+                        break lab1;
+                    }
+                    cursor = limit - v_3;
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 162
+                // (, line 162
+                // not, line 162
+                {
+                    v_4 = limit - cursor;
+                    lab2: do {
+                        // (, line 162
+                        // test, line 162
+                        v_5 = limit - cursor;
+                        if (!(in_grouping_b(g_U, 105, 305)))
+                        {
+                            break lab2;
+                        }
+                        cursor = limit - v_5;
+                        return false;
+                    } while (false);
+                    cursor = limit - v_4;
+                }
+                // test, line 162
+                v_6 = limit - cursor;
+                // (, line 162
+                // next, line 162
+                if (cursor <= limit_backward)
+                {
+                    return false;
+                }
+                cursor--;
+                // (, line 162
+                // test, line 162
+                v_7 = limit - cursor;
+                if (!(out_grouping_b(g_vowel, 97, 305)))
+                {
+                    return false;
+                }
+                cursor = limit - v_7;
+                cursor = limit - v_6;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_mark_possessives() {
+            // (, line 166
+            // among, line 167
+            if (find_among_b(a_0, 10) == 0)
+            {
+                return false;
+            }
+            // (, line 169
+            // call mark_suffix_with_optional_U_vowel, line 169
+            if (!r_mark_suffix_with_optional_U_vowel())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_sU() {
+            // (, line 172
+            // call check_vowel_harmony, line 173
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            if (!(in_grouping_b(g_U, 105, 305)))
+            {
+                return false;
+            }
+            // (, line 175
+            // call mark_suffix_with_optional_s_consonant, line 175
+            if (!r_mark_suffix_with_optional_s_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_lArI() {
+            // (, line 178
+            // among, line 179
+            if (find_among_b(a_1, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yU() {
+            // (, line 182
+            // call check_vowel_harmony, line 183
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            if (!(in_grouping_b(g_U, 105, 305)))
+            {
+                return false;
+            }
+            // (, line 185
+            // call mark_suffix_with_optional_y_consonant, line 185
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_nU() {
+            // (, line 188
+            // call check_vowel_harmony, line 189
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 190
+            if (find_among_b(a_2, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_nUn() {
+            // (, line 193
+            // call check_vowel_harmony, line 194
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 195
+            if (find_among_b(a_3, 4) == 0)
+            {
+                return false;
+            }
+            // (, line 196
+            // call mark_suffix_with_optional_n_consonant, line 196
+            if (!r_mark_suffix_with_optional_n_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yA() {
+            // (, line 199
+            // call check_vowel_harmony, line 200
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 201
+            if (find_among_b(a_4, 2) == 0)
+            {
+                return false;
+            }
+            // (, line 202
+            // call mark_suffix_with_optional_y_consonant, line 202
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_nA() {
+            // (, line 205
+            // call check_vowel_harmony, line 206
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 207
+            if (find_among_b(a_5, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_DA() {
+            // (, line 210
+            // call check_vowel_harmony, line 211
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 212
+            if (find_among_b(a_6, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ndA() {
+            // (, line 215
+            // call check_vowel_harmony, line 216
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 217
+            if (find_among_b(a_7, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_DAn() {
+            // (, line 220
+            // call check_vowel_harmony, line 221
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 222
+            if (find_among_b(a_8, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ndAn() {
+            // (, line 225
+            // call check_vowel_harmony, line 226
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 227
+            if (find_among_b(a_9, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ylA() {
+            // (, line 230
+            // call check_vowel_harmony, line 231
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 232
+            if (find_among_b(a_10, 2) == 0)
+            {
+                return false;
+            }
+            // (, line 233
+            // call mark_suffix_with_optional_y_consonant, line 233
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ki() {
+            // (, line 236
+            // literal, line 237
+            if (!(eq_s_b(2, "ki")))
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ncA() {
+            // (, line 240
+            // call check_vowel_harmony, line 241
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 242
+            if (find_among_b(a_11, 2) == 0)
+            {
+                return false;
+            }
+            // (, line 243
+            // call mark_suffix_with_optional_n_consonant, line 243
+            if (!r_mark_suffix_with_optional_n_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yUm() {
+            // (, line 246
+            // call check_vowel_harmony, line 247
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 248
+            if (find_among_b(a_12, 4) == 0)
+            {
+                return false;
+            }
+            // (, line 249
+            // call mark_suffix_with_optional_y_consonant, line 249
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_sUn() {
+            // (, line 252
+            // call check_vowel_harmony, line 253
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 254
+            if (find_among_b(a_13, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yUz() {
+            // (, line 257
+            // call check_vowel_harmony, line 258
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 259
+            if (find_among_b(a_14, 4) == 0)
+            {
+                return false;
+            }
+            // (, line 260
+            // call mark_suffix_with_optional_y_consonant, line 260
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_sUnUz() {
+            // (, line 263
+            // among, line 264
+            if (find_among_b(a_15, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_lAr() {
+            // (, line 267
+            // call check_vowel_harmony, line 268
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 269
+            if (find_among_b(a_16, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_nUz() {
+            // (, line 272
+            // call check_vowel_harmony, line 273
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 274
+            if (find_among_b(a_17, 4) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_DUr() {
+            // (, line 277
+            // call check_vowel_harmony, line 278
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 279
+            if (find_among_b(a_18, 8) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_cAsInA() {
+            // (, line 282
+            // among, line 283
+            if (find_among_b(a_19, 2) == 0)
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yDU() {
+            // (, line 286
+            // call check_vowel_harmony, line 287
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 288
+            if (find_among_b(a_20, 32) == 0)
+            {
+                return false;
+            }
+            // (, line 292
+            // call mark_suffix_with_optional_y_consonant, line 292
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ysA() {
+            // (, line 296
+            // among, line 297
+            if (find_among_b(a_21, 8) == 0)
+            {
+                return false;
+            }
+            // (, line 298
+            // call mark_suffix_with_optional_y_consonant, line 298
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_ymUs_() {
+            // (, line 301
+            // call check_vowel_harmony, line 302
+            if (!r_check_vowel_harmony())
+            {
+                return false;
+            }
+            // among, line 303
+            if (find_among_b(a_22, 4) == 0)
+            {
+                return false;
+            }
+            // (, line 304
+            // call mark_suffix_with_optional_y_consonant, line 304
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_mark_yken() {
+            // (, line 307
+            // literal, line 308
+            if (!(eq_s_b(3, "ken")))
+            {
+                return false;
+            }
+            // (, line 308
+            // call mark_suffix_with_optional_y_consonant, line 308
+            if (!r_mark_suffix_with_optional_y_consonant())
+            {
+                return false;
+            }
+            return true;
+        }
+
+        private boolean r_stem_nominal_verb_suffixes() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            // (, line 311
+            // [, line 312
+            ket = cursor;
+            // set continue_stemming_noun_suffixes, line 313
+            B_continue_stemming_noun_suffixes = true;
+            // or, line 315
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 314
+                    // or, line 314
+                    lab2: do {
+                        v_2 = limit - cursor;
+                        lab3: do {
+                            // call mark_ymUs_, line 314
+                            if (!r_mark_ymUs_())
+                            {
+                                break lab3;
+                            }
+                            break lab2;
+                        } while (false);
+                        cursor = limit - v_2;
+                        lab4: do {
+                            // call mark_yDU, line 314
+                            if (!r_mark_yDU())
+                            {
+                                break lab4;
+                            }
+                            break lab2;
+                        } while (false);
+                        cursor = limit - v_2;
+                        lab5: do {
+                            // call mark_ysA, line 314
+                            if (!r_mark_ysA())
+                            {
+                                break lab5;
+                            }
+                            break lab2;
+                        } while (false);
+                        cursor = limit - v_2;
+                        // call mark_yken, line 314
+                        if (!r_mark_yken())
+                        {
+                            break lab1;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab6: do {
+                    // (, line 316
+                    // call mark_cAsInA, line 316
+                    if (!r_mark_cAsInA())
+                    {
+                        break lab6;
+                    }
+                    // (, line 316
+                    // or, line 316
+                    lab7: do {
+                        v_3 = limit - cursor;
+                        lab8: do {
+                            // call mark_sUnUz, line 316
+                            if (!r_mark_sUnUz())
+                            {
+                                break lab8;
+                            }
+                            break lab7;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab9: do {
+                            // call mark_lAr, line 316
+                            if (!r_mark_lAr())
+                            {
+                                break lab9;
+                            }
+                            break lab7;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab10: do {
+                            // call mark_yUm, line 316
+                            if (!r_mark_yUm())
+                            {
+                                break lab10;
+                            }
+                            break lab7;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab11: do {
+                            // call mark_sUn, line 316
+                            if (!r_mark_sUn())
+                            {
+                                break lab11;
+                            }
+                            break lab7;
+                        } while (false);
+                        cursor = limit - v_3;
+                        lab12: do {
+                            // call mark_yUz, line 316
+                            if (!r_mark_yUz())
+                            {
+                                break lab12;
+                            }
+                            break lab7;
+                        } while (false);
+                        cursor = limit - v_3;
+                    } while (false);
+                    // call mark_ymUs_, line 316
+                    if (!r_mark_ymUs_())
+                    {
+                        break lab6;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab13: do {
+                    // (, line 318
+                    // call mark_lAr, line 319
+                    if (!r_mark_lAr())
+                    {
+                        break lab13;
+                    }
+                    // ], line 319
+                    bra = cursor;
+                    // delete, line 319
+                    slice_del();
+                    // try, line 319
+                    v_4 = limit - cursor;
+                    lab14: do {
+                        // (, line 319
+                        // [, line 319
+                        ket = cursor;
+                        // (, line 319
+                        // or, line 319
+                        lab15: do {
+                            v_5 = limit - cursor;
+                            lab16: do {
+                                // call mark_DUr, line 319
+                                if (!r_mark_DUr())
+                                {
+                                    break lab16;
+                                }
+                                break lab15;
+                            } while (false);
+                            cursor = limit - v_5;
+                            lab17: do {
+                                // call mark_yDU, line 319
+                                if (!r_mark_yDU())
+                                {
+                                    break lab17;
+                                }
+                                break lab15;
+                            } while (false);
+                            cursor = limit - v_5;
+                            lab18: do {
+                                // call mark_ysA, line 319
+                                if (!r_mark_ysA())
+                                {
+                                    break lab18;
+                                }
+                                break lab15;
+                            } while (false);
+                            cursor = limit - v_5;
+                            // call mark_ymUs_, line 319
+                            if (!r_mark_ymUs_())
+                            {
+                                cursor = limit - v_4;
+                                break lab14;
+                            }
+                        } while (false);
+                    } while (false);
+                    // unset continue_stemming_noun_suffixes, line 320
+                    B_continue_stemming_noun_suffixes = false;
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab19: do {
+                    // (, line 323
+                    // call mark_nUz, line 323
+                    if (!r_mark_nUz())
+                    {
+                        break lab19;
+                    }
+                    // (, line 323
+                    // or, line 323
+                    lab20: do {
+                        v_6 = limit - cursor;
+                        lab21: do {
+                            // call mark_yDU, line 323
+                            if (!r_mark_yDU())
+                            {
+                                break lab21;
+                            }
+                            break lab20;
+                        } while (false);
+                        cursor = limit - v_6;
+                        // call mark_ysA, line 323
+                        if (!r_mark_ysA())
+                        {
+                            break lab19;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab22: do {
+                    // (, line 325
+                    // (, line 325
+                    // or, line 325
+                    lab23: do {
+                        v_7 = limit - cursor;
+                        lab24: do {
+                            // call mark_sUnUz, line 325
+                            if (!r_mark_sUnUz())
+                            {
+                                break lab24;
+                            }
+                            break lab23;
+                        } while (false);
+                        cursor = limit - v_7;
+                        lab25: do {
+                            // call mark_yUz, line 325
+                            if (!r_mark_yUz())
+                            {
+                                break lab25;
+                            }
+                            break lab23;
+                        } while (false);
+                        cursor = limit - v_7;
+                        lab26: do {
+                            // call mark_sUn, line 325
+                            if (!r_mark_sUn())
+                            {
+                                break lab26;
+                            }
+                            break lab23;
+                        } while (false);
+                        cursor = limit - v_7;
+                        // call mark_yUm, line 325
+                        if (!r_mark_yUm())
+                        {
+                            break lab22;
+                        }
+                    } while (false);
+                    // ], line 325
+                    bra = cursor;
+                    // delete, line 325
+                    slice_del();
+                    // try, line 325
+                    v_8 = limit - cursor;
+                    lab27: do {
+                        // (, line 325
+                        // [, line 325
+                        ket = cursor;
+                        // call mark_ymUs_, line 325
+                        if (!r_mark_ymUs_())
+                        {
+                            cursor = limit - v_8;
+                            break lab27;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 327
+                // call mark_DUr, line 327
+                if (!r_mark_DUr())
+                {
+                    return false;
+                }
+                // ], line 327
+                bra = cursor;
+                // delete, line 327
+                slice_del();
+                // try, line 327
+                v_9 = limit - cursor;
+                lab28: do {
+                    // (, line 327
+                    // [, line 327
+                    ket = cursor;
+                    // (, line 327
+                    // or, line 327
+                    lab29: do {
+                        v_10 = limit - cursor;
+                        lab30: do {
+                            // call mark_sUnUz, line 327
+                            if (!r_mark_sUnUz())
+                            {
+                                break lab30;
+                            }
+                            break lab29;
+                        } while (false);
+                        cursor = limit - v_10;
+                        lab31: do {
+                            // call mark_lAr, line 327
+                            if (!r_mark_lAr())
+                            {
+                                break lab31;
+                            }
+                            break lab29;
+                        } while (false);
+                        cursor = limit - v_10;
+                        lab32: do {
+                            // call mark_yUm, line 327
+                            if (!r_mark_yUm())
+                            {
+                                break lab32;
+                            }
+                            break lab29;
+                        } while (false);
+                        cursor = limit - v_10;
+                        lab33: do {
+                            // call mark_sUn, line 327
+                            if (!r_mark_sUn())
+                            {
+                                break lab33;
+                            }
+                            break lab29;
+                        } while (false);
+                        cursor = limit - v_10;
+                        lab34: do {
+                            // call mark_yUz, line 327
+                            if (!r_mark_yUz())
+                            {
+                                break lab34;
+                            }
+                            break lab29;
+                        } while (false);
+                        cursor = limit - v_10;
+                    } while (false);
+                    // call mark_ymUs_, line 327
+                    if (!r_mark_ymUs_())
+                    {
+                        cursor = limit - v_9;
+                        break lab28;
+                    }
+                } while (false);
+            } while (false);
+            // ], line 328
+            bra = cursor;
+            // delete, line 328
+            slice_del();
+            return true;
+        }
+
+        private boolean r_stem_suffix_chain_before_ki() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            // (, line 332
+            // [, line 333
+            ket = cursor;
+            // call mark_ki, line 334
+            if (!r_mark_ki())
+            {
+                return false;
+            }
+            // (, line 335
+            // or, line 342
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 336
+                    // call mark_DA, line 336
+                    if (!r_mark_DA())
+                    {
+                        break lab1;
+                    }
+                    // ], line 336
+                    bra = cursor;
+                    // delete, line 336
+                    slice_del();
+                    // try, line 336
+                    v_2 = limit - cursor;
+                    lab2: do {
+                        // (, line 336
+                        // [, line 336
+                        ket = cursor;
+                        // or, line 338
+                        lab3: do {
+                            v_3 = limit - cursor;
+                            lab4: do {
+                                // (, line 337
+                                // call mark_lAr, line 337
+                                if (!r_mark_lAr())
+                                {
+                                    break lab4;
+                                }
+                                // ], line 337
+                                bra = cursor;
+                                // delete, line 337
+                                slice_del();
+                                // try, line 337
+                                v_4 = limit - cursor;
+                                lab5: do {
+                                    // (, line 337
+                                    // call stem_suffix_chain_before_ki, line 337
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_4;
+                                        break lab5;
+                                    }
+                                } while (false);
+                                break lab3;
+                            } while (false);
+                            cursor = limit - v_3;
+                            // (, line 339
+                            // call mark_possessives, line 339
+                            if (!r_mark_possessives())
+                            {
+                                cursor = limit - v_2;
+                                break lab2;
+                            }
+                            // ], line 339
+                            bra = cursor;
+                            // delete, line 339
+                            slice_del();
+                            // try, line 339
+                            v_5 = limit - cursor;
+                            lab6: do {
+                                // (, line 339
+                                // [, line 339
+                                ket = cursor;
+                                // call mark_lAr, line 339
+                                if (!r_mark_lAr())
+                                {
+                                    cursor = limit - v_5;
+                                    break lab6;
+                                }
+                                // ], line 339
+                                bra = cursor;
+                                // delete, line 339
+                                slice_del();
+                                // call stem_suffix_chain_before_ki, line 339
+                                if (!r_stem_suffix_chain_before_ki())
+                                {
+                                    cursor = limit - v_5;
+                                    break lab6;
+                                }
+                            } while (false);
+                        } while (false);
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab7: do {
+                    // (, line 343
+                    // call mark_nUn, line 343
+                    if (!r_mark_nUn())
+                    {
+                        break lab7;
+                    }
+                    // ], line 343
+                    bra = cursor;
+                    // delete, line 343
+                    slice_del();
+                    // try, line 343
+                    v_6 = limit - cursor;
+                    lab8: do {
+                        // (, line 343
+                        // [, line 343
+                        ket = cursor;
+                        // or, line 345
+                        lab9: do {
+                            v_7 = limit - cursor;
+                            lab10: do {
+                                // (, line 344
+                                // call mark_lArI, line 344
+                                if (!r_mark_lArI())
+                                {
+                                    break lab10;
+                                }
+                                // ], line 344
+                                bra = cursor;
+                                // delete, line 344
+                                slice_del();
+                                break lab9;
+                            } while (false);
+                            cursor = limit - v_7;
+                            lab11: do {
+                                // (, line 346
+                                // [, line 346
+                                ket = cursor;
+                                // or, line 346
+                                lab12: do {
+                                    v_8 = limit - cursor;
+                                    lab13: do {
+                                        // call mark_possessives, line 346
+                                        if (!r_mark_possessives())
+                                        {
+                                            break lab13;
+                                        }
+                                        break lab12;
+                                    } while (false);
+                                    cursor = limit - v_8;
+                                    // call mark_sU, line 346
+                                    if (!r_mark_sU())
+                                    {
+                                        break lab11;
+                                    }
+                                } while (false);
+                                // ], line 346
+                                bra = cursor;
+                                // delete, line 346
+                                slice_del();
+                                // try, line 346
+                                v_9 = limit - cursor;
+                                lab14: do {
+                                    // (, line 346
+                                    // [, line 346
+                                    ket = cursor;
+                                    // call mark_lAr, line 346
+                                    if (!r_mark_lAr())
+                                    {
+                                        cursor = limit - v_9;
+                                        break lab14;
+                                    }
+                                    // ], line 346
+                                    bra = cursor;
+                                    // delete, line 346
+                                    slice_del();
+                                    // call stem_suffix_chain_before_ki, line 346
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_9;
+                                        break lab14;
+                                    }
+                                } while (false);
+                                break lab9;
+                            } while (false);
+                            cursor = limit - v_7;
+                            // (, line 348
+                            // call stem_suffix_chain_before_ki, line 348
+                            if (!r_stem_suffix_chain_before_ki())
+                            {
+                                cursor = limit - v_6;
+                                break lab8;
+                            }
+                        } while (false);
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 351
+                // call mark_ndA, line 351
+                if (!r_mark_ndA())
+                {
+                    return false;
+                }
+                // (, line 351
+                // or, line 353
+                lab15: do {
+                    v_10 = limit - cursor;
+                    lab16: do {
+                        // (, line 352
+                        // call mark_lArI, line 352
+                        if (!r_mark_lArI())
+                        {
+                            break lab16;
+                        }
+                        // ], line 352
+                        bra = cursor;
+                        // delete, line 352
+                        slice_del();
+                        break lab15;
+                    } while (false);
+                    cursor = limit - v_10;
+                    lab17: do {
+                        // (, line 354
+                        // (, line 354
+                        // call mark_sU, line 354
+                        if (!r_mark_sU())
+                        {
+                            break lab17;
+                        }
+                        // ], line 354
+                        bra = cursor;
+                        // delete, line 354
+                        slice_del();
+                        // try, line 354
+                        v_11 = limit - cursor;
+                        lab18: do {
+                            // (, line 354
+                            // [, line 354
+                            ket = cursor;
+                            // call mark_lAr, line 354
+                            if (!r_mark_lAr())
+                            {
+                                cursor = limit - v_11;
+                                break lab18;
+                            }
+                            // ], line 354
+                            bra = cursor;
+                            // delete, line 354
+                            slice_del();
+                            // call stem_suffix_chain_before_ki, line 354
+                            if (!r_stem_suffix_chain_before_ki())
+                            {
+                                cursor = limit - v_11;
+                                break lab18;
+                            }
+                        } while (false);
+                        break lab15;
+                    } while (false);
+                    cursor = limit - v_10;
+                    // (, line 356
+                    // call stem_suffix_chain_before_ki, line 356
+                    if (!r_stem_suffix_chain_before_ki())
+                    {
+                        return false;
+                    }
+                } while (false);
+            } while (false);
+            return true;
+        }
+
+        private boolean r_stem_noun_suffixes() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            int v_12;
+            int v_13;
+            int v_14;
+            int v_15;
+            int v_16;
+            int v_17;
+            int v_18;
+            int v_19;
+            int v_20;
+            int v_21;
+            int v_22;
+            int v_23;
+            int v_24;
+            int v_25;
+            int v_26;
+            int v_27;
+            // (, line 361
+            // or, line 363
+            lab0: do {
+                v_1 = limit - cursor;
+                lab1: do {
+                    // (, line 362
+                    // [, line 362
+                    ket = cursor;
+                    // call mark_lAr, line 362
+                    if (!r_mark_lAr())
+                    {
+                        break lab1;
+                    }
+                    // ], line 362
+                    bra = cursor;
+                    // delete, line 362
+                    slice_del();
+                    // try, line 362
+                    v_2 = limit - cursor;
+                    lab2: do {
+                        // (, line 362
+                        // call stem_suffix_chain_before_ki, line 362
+                        if (!r_stem_suffix_chain_before_ki())
+                        {
+                            cursor = limit - v_2;
+                            break lab2;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab3: do {
+                    // (, line 364
+                    // [, line 364
+                    ket = cursor;
+                    // call mark_ncA, line 364
+                    if (!r_mark_ncA())
+                    {
+                        break lab3;
+                    }
+                    // ], line 364
+                    bra = cursor;
+                    // delete, line 364
+                    slice_del();
+                    // try, line 365
+                    v_3 = limit - cursor;
+                    lab4: do {
+                        // (, line 365
+                        // or, line 367
+                        lab5: do {
+                            v_4 = limit - cursor;
+                            lab6: do {
+                                // (, line 366
+                                // [, line 366
+                                ket = cursor;
+                                // call mark_lArI, line 366
+                                if (!r_mark_lArI())
+                                {
+                                    break lab6;
+                                }
+                                // ], line 366
+                                bra = cursor;
+                                // delete, line 366
+                                slice_del();
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_4;
+                            lab7: do {
+                                // (, line 368
+                                // [, line 368
+                                ket = cursor;
+                                // or, line 368
+                                lab8: do {
+                                    v_5 = limit - cursor;
+                                    lab9: do {
+                                        // call mark_possessives, line 368
+                                        if (!r_mark_possessives())
+                                        {
+                                            break lab9;
+                                        }
+                                        break lab8;
+                                    } while (false);
+                                    cursor = limit - v_5;
+                                    // call mark_sU, line 368
+                                    if (!r_mark_sU())
+                                    {
+                                        break lab7;
+                                    }
+                                } while (false);
+                                // ], line 368
+                                bra = cursor;
+                                // delete, line 368
+                                slice_del();
+                                // try, line 368
+                                v_6 = limit - cursor;
+                                lab10: do {
+                                    // (, line 368
+                                    // [, line 368
+                                    ket = cursor;
+                                    // call mark_lAr, line 368
+                                    if (!r_mark_lAr())
+                                    {
+                                        cursor = limit - v_6;
+                                        break lab10;
+                                    }
+                                    // ], line 368
+                                    bra = cursor;
+                                    // delete, line 368
+                                    slice_del();
+                                    // call stem_suffix_chain_before_ki, line 368
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_6;
+                                        break lab10;
+                                    }
+                                } while (false);
+                                break lab5;
+                            } while (false);
+                            cursor = limit - v_4;
+                            // (, line 370
+                            // [, line 370
+                            ket = cursor;
+                            // call mark_lAr, line 370
+                            if (!r_mark_lAr())
+                            {
+                                cursor = limit - v_3;
+                                break lab4;
+                            }
+                            // ], line 370
+                            bra = cursor;
+                            // delete, line 370
+                            slice_del();
+                            // call stem_suffix_chain_before_ki, line 370
+                            if (!r_stem_suffix_chain_before_ki())
+                            {
+                                cursor = limit - v_3;
+                                break lab4;
+                            }
+                        } while (false);
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab11: do {
+                    // (, line 374
+                    // [, line 374
+                    ket = cursor;
+                    // (, line 374
+                    // or, line 374
+                    lab12: do {
+                        v_7 = limit - cursor;
+                        lab13: do {
+                            // call mark_ndA, line 374
+                            if (!r_mark_ndA())
+                            {
+                                break lab13;
+                            }
+                            break lab12;
+                        } while (false);
+                        cursor = limit - v_7;
+                        // call mark_nA, line 374
+                        if (!r_mark_nA())
+                        {
+                            break lab11;
+                        }
+                    } while (false);
+                    // (, line 375
+                    // or, line 377
+                    lab14: do {
+                        v_8 = limit - cursor;
+                        lab15: do {
+                            // (, line 376
+                            // call mark_lArI, line 376
+                            if (!r_mark_lArI())
+                            {
+                                break lab15;
+                            }
+                            // ], line 376
+                            bra = cursor;
+                            // delete, line 376
+                            slice_del();
+                            break lab14;
+                        } while (false);
+                        cursor = limit - v_8;
+                        lab16: do {
+                            // (, line 378
+                            // call mark_sU, line 378
+                            if (!r_mark_sU())
+                            {
+                                break lab16;
+                            }
+                            // ], line 378
+                            bra = cursor;
+                            // delete, line 378
+                            slice_del();
+                            // try, line 378
+                            v_9 = limit - cursor;
+                            lab17: do {
+                                // (, line 378
+                                // [, line 378
+                                ket = cursor;
+                                // call mark_lAr, line 378
+                                if (!r_mark_lAr())
+                                {
+                                    cursor = limit - v_9;
+                                    break lab17;
+                                }
+                                // ], line 378
+                                bra = cursor;
+                                // delete, line 378
+                                slice_del();
+                                // call stem_suffix_chain_before_ki, line 378
+                                if (!r_stem_suffix_chain_before_ki())
+                                {
+                                    cursor = limit - v_9;
+                                    break lab17;
+                                }
+                            } while (false);
+                            break lab14;
+                        } while (false);
+                        cursor = limit - v_8;
+                        // (, line 380
+                        // call stem_suffix_chain_before_ki, line 380
+                        if (!r_stem_suffix_chain_before_ki())
+                        {
+                            break lab11;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab18: do {
+                    // (, line 384
+                    // [, line 384
+                    ket = cursor;
+                    // (, line 384
+                    // or, line 384
+                    lab19: do {
+                        v_10 = limit - cursor;
+                        lab20: do {
+                            // call mark_ndAn, line 384
+                            if (!r_mark_ndAn())
+                            {
+                                break lab20;
+                            }
+                            break lab19;
+                        } while (false);
+                        cursor = limit - v_10;
+                        // call mark_nU, line 384
+                        if (!r_mark_nU())
+                        {
+                            break lab18;
+                        }
+                    } while (false);
+                    // (, line 384
+                    // or, line 384
+                    lab21: do {
+                        v_11 = limit - cursor;
+                        lab22: do {
+                            // (, line 384
+                            // call mark_sU, line 384
+                            if (!r_mark_sU())
+                            {
+                                break lab22;
+                            }
+                            // ], line 384
+                            bra = cursor;
+                            // delete, line 384
+                            slice_del();
+                            // try, line 384
+                            v_12 = limit - cursor;
+                            lab23: do {
+                                // (, line 384
+                                // [, line 384
+                                ket = cursor;
+                                // call mark_lAr, line 384
+                                if (!r_mark_lAr())
+                                {
+                                    cursor = limit - v_12;
+                                    break lab23;
+                                }
+                                // ], line 384
+                                bra = cursor;
+                                // delete, line 384
+                                slice_del();
+                                // call stem_suffix_chain_before_ki, line 384
+                                if (!r_stem_suffix_chain_before_ki())
+                                {
+                                    cursor = limit - v_12;
+                                    break lab23;
+                                }
+                            } while (false);
+                            break lab21;
+                        } while (false);
+                        cursor = limit - v_11;
+                        // (, line 384
+                        // call mark_lArI, line 384
+                        if (!r_mark_lArI())
+                        {
+                            break lab18;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab24: do {
+                    // (, line 386
+                    // [, line 386
+                    ket = cursor;
+                    // call mark_DAn, line 386
+                    if (!r_mark_DAn())
+                    {
+                        break lab24;
+                    }
+                    // ], line 386
+                    bra = cursor;
+                    // delete, line 386
+                    slice_del();
+                    // try, line 386
+                    v_13 = limit - cursor;
+                    lab25: do {
+                        // (, line 386
+                        // [, line 386
+                        ket = cursor;
+                        // (, line 387
+                        // or, line 389
+                        lab26: do {
+                            v_14 = limit - cursor;
+                            lab27: do {
+                                // (, line 388
+                                // call mark_possessives, line 388
+                                if (!r_mark_possessives())
+                                {
+                                    break lab27;
+                                }
+                                // ], line 388
+                                bra = cursor;
+                                // delete, line 388
+                                slice_del();
+                                // try, line 388
+                                v_15 = limit - cursor;
+                                lab28: do {
+                                    // (, line 388
+                                    // [, line 388
+                                    ket = cursor;
+                                    // call mark_lAr, line 388
+                                    if (!r_mark_lAr())
+                                    {
+                                        cursor = limit - v_15;
+                                        break lab28;
+                                    }
+                                    // ], line 388
+                                    bra = cursor;
+                                    // delete, line 388
+                                    slice_del();
+                                    // call stem_suffix_chain_before_ki, line 388
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_15;
+                                        break lab28;
+                                    }
+                                } while (false);
+                                break lab26;
+                            } while (false);
+                            cursor = limit - v_14;
+                            lab29: do {
+                                // (, line 390
+                                // call mark_lAr, line 390
+                                if (!r_mark_lAr())
+                                {
+                                    break lab29;
+                                }
+                                // ], line 390
+                                bra = cursor;
+                                // delete, line 390
+                                slice_del();
+                                // try, line 390
+                                v_16 = limit - cursor;
+                                lab30: do {
+                                    // (, line 390
+                                    // call stem_suffix_chain_before_ki, line 390
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_16;
+                                        break lab30;
+                                    }
+                                } while (false);
+                                break lab26;
+                            } while (false);
+                            cursor = limit - v_14;
+                            // (, line 392
+                            // call stem_suffix_chain_before_ki, line 392
+                            if (!r_stem_suffix_chain_before_ki())
+                            {
+                                cursor = limit - v_13;
+                                break lab25;
+                            }
+                        } while (false);
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab31: do {
+                    // (, line 396
+                    // [, line 396
+                    ket = cursor;
+                    // or, line 396
+                    lab32: do {
+                        v_17 = limit - cursor;
+                        lab33: do {
+                            // call mark_nUn, line 396
+                            if (!r_mark_nUn())
+                            {
+                                break lab33;
+                            }
+                            break lab32;
+                        } while (false);
+                        cursor = limit - v_17;
+                        // call mark_ylA, line 396
+                        if (!r_mark_ylA())
+                        {
+                            break lab31;
+                        }
+                    } while (false);
+                    // ], line 396
+                    bra = cursor;
+                    // delete, line 396
+                    slice_del();
+                    // try, line 397
+                    v_18 = limit - cursor;
+                    lab34: do {
+                        // (, line 397
+                        // or, line 399
+                        lab35: do {
+                            v_19 = limit - cursor;
+                            lab36: do {
+                                // (, line 398
+                                // [, line 398
+                                ket = cursor;
+                                // call mark_lAr, line 398
+                                if (!r_mark_lAr())
+                                {
+                                    break lab36;
+                                }
+                                // ], line 398
+                                bra = cursor;
+                                // delete, line 398
+                                slice_del();
+                                // call stem_suffix_chain_before_ki, line 398
+                                if (!r_stem_suffix_chain_before_ki())
+                                {
+                                    break lab36;
+                                }
+                                break lab35;
+                            } while (false);
+                            cursor = limit - v_19;
+                            lab37: do {
+                                // (, line 400
+                                // [, line 400
+                                ket = cursor;
+                                // or, line 400
+                                lab38: do {
+                                    v_20 = limit - cursor;
+                                    lab39: do {
+                                        // call mark_possessives, line 400
+                                        if (!r_mark_possessives())
+                                        {
+                                            break lab39;
+                                        }
+                                        break lab38;
+                                    } while (false);
+                                    cursor = limit - v_20;
+                                    // call mark_sU, line 400
+                                    if (!r_mark_sU())
+                                    {
+                                        break lab37;
+                                    }
+                                } while (false);
+                                // ], line 400
+                                bra = cursor;
+                                // delete, line 400
+                                slice_del();
+                                // try, line 400
+                                v_21 = limit - cursor;
+                                lab40: do {
+                                    // (, line 400
+                                    // [, line 400
+                                    ket = cursor;
+                                    // call mark_lAr, line 400
+                                    if (!r_mark_lAr())
+                                    {
+                                        cursor = limit - v_21;
+                                        break lab40;
+                                    }
+                                    // ], line 400
+                                    bra = cursor;
+                                    // delete, line 400
+                                    slice_del();
+                                    // call stem_suffix_chain_before_ki, line 400
+                                    if (!r_stem_suffix_chain_before_ki())
+                                    {
+                                        cursor = limit - v_21;
+                                        break lab40;
+                                    }
+                                } while (false);
+                                break lab35;
+                            } while (false);
+                            cursor = limit - v_19;
+                            // call stem_suffix_chain_before_ki, line 402
+                            if (!r_stem_suffix_chain_before_ki())
+                            {
+                                cursor = limit - v_18;
+                                break lab34;
+                            }
+                        } while (false);
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab41: do {
+                    // (, line 406
+                    // [, line 406
+                    ket = cursor;
+                    // call mark_lArI, line 406
+                    if (!r_mark_lArI())
+                    {
+                        break lab41;
+                    }
+                    // ], line 406
+                    bra = cursor;
+                    // delete, line 406
+                    slice_del();
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab42: do {
+                    // (, line 408
+                    // call stem_suffix_chain_before_ki, line 408
+                    if (!r_stem_suffix_chain_before_ki())
+                    {
+                        break lab42;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                lab43: do {
+                    // (, line 410
+                    // [, line 410
+                    ket = cursor;
+                    // or, line 410
+                    lab44: do {
+                        v_22 = limit - cursor;
+                        lab45: do {
+                            // call mark_DA, line 410
+                            if (!r_mark_DA())
+                            {
+                                break lab45;
+                            }
+                            break lab44;
+                        } while (false);
+                        cursor = limit - v_22;
+                        lab46: do {
+                            // call mark_yU, line 410
+                            if (!r_mark_yU())
+                            {
+                                break lab46;
+                            }
+                            break lab44;
+                        } while (false);
+                        cursor = limit - v_22;
+                        // call mark_yA, line 410
+                        if (!r_mark_yA())
+                        {
+                            break lab43;
+                        }
+                    } while (false);
+                    // ], line 410
+                    bra = cursor;
+                    // delete, line 410
+                    slice_del();
+                    // try, line 410
+                    v_23 = limit - cursor;
+                    lab47: do {
+                        // (, line 410
+                        // [, line 410
+                        ket = cursor;
+                        // (, line 410
+                        // or, line 410
+                        lab48: do {
+                            v_24 = limit - cursor;
+                            lab49: do {
+                                // (, line 410
+                                // call mark_possessives, line 410
+                                if (!r_mark_possessives())
+                                {
+                                    break lab49;
+                                }
+                                // ], line 410
+                                bra = cursor;
+                                // delete, line 410
+                                slice_del();
+                                // try, line 410
+                                v_25 = limit - cursor;
+                                lab50: do {
+                                    // (, line 410
+                                    // [, line 410
+                                    ket = cursor;
+                                    // call mark_lAr, line 410
+                                    if (!r_mark_lAr())
+                                    {
+                                        cursor = limit - v_25;
+                                        break lab50;
+                                    }
+                                } while (false);
+                                break lab48;
+                            } while (false);
+                            cursor = limit - v_24;
+                            // call mark_lAr, line 410
+                            if (!r_mark_lAr())
+                            {
+                                cursor = limit - v_23;
+                                break lab47;
+                            }
+                        } while (false);
+                        // ], line 410
+                        bra = cursor;
+                        // delete, line 410
+                        slice_del();
+                        // [, line 410
+                        ket = cursor;
+                        // call stem_suffix_chain_before_ki, line 410
+                        if (!r_stem_suffix_chain_before_ki())
+                        {
+                            cursor = limit - v_23;
+                            break lab47;
+                        }
+                    } while (false);
+                    break lab0;
+                } while (false);
+                cursor = limit - v_1;
+                // (, line 412
+                // [, line 412
+                ket = cursor;
+                // or, line 412
+                lab51: do {
+                    v_26 = limit - cursor;
+                    lab52: do {
+                        // call mark_possessives, line 412
+                        if (!r_mark_possessives())
+                        {
+                            break lab52;
+                        }
+                        break lab51;
+                    } while (false);
+                    cursor = limit - v_26;
+                    // call mark_sU, line 412
+                    if (!r_mark_sU())
+                    {
+                        return false;
+                    }
+                } while (false);
+                // ], line 412
+                bra = cursor;
+                // delete, line 412
+                slice_del();
+                // try, line 412
+                v_27 = limit - cursor;
+                lab53: do {
+                    // (, line 412
+                    // [, line 412
+                    ket = cursor;
+                    // call mark_lAr, line 412
+                    if (!r_mark_lAr())
+                    {
+                        cursor = limit - v_27;
+                        break lab53;
+                    }
+                    // ], line 412
+                    bra = cursor;
+                    // delete, line 412
+                    slice_del();
+                    // call stem_suffix_chain_before_ki, line 412
+                    if (!r_stem_suffix_chain_before_ki())
+                    {
+                        cursor = limit - v_27;
+                        break lab53;
+                    }
+                } while (false);
+            } while (false);
+            return true;
+        }
+
+        private boolean r_post_process_last_consonants() {
+            int among_var;
+            // (, line 415
+            // [, line 416
+            ket = cursor;
+            // substring, line 416
+            among_var = find_among_b(a_23, 4);
+            if (among_var == 0)
+            {
+                return false;
+            }
+            // ], line 416
+            bra = cursor;
+            switch(among_var) {
+                case 0:
+                    return false;
+                case 1:
+                    // (, line 417
+                    // <-, line 417
+                    slice_from("p");
+                    break;
+                case 2:
+                    // (, line 418
+                    // <-, line 418
+                    slice_from("\u00E7");
+                    break;
+                case 3:
+                    // (, line 419
+                    // <-, line 419
+                    slice_from("t");
+                    break;
+                case 4:
+                    // (, line 420
+                    // <-, line 420
+                    slice_from("k");
+                    break;
+            }
+            return true;
+        }
+
+        private boolean r_append_U_to_stems_ending_with_d_or_g() {
+            int v_1;
+            int v_2;
+            int v_3;
+            int v_4;
+            int v_5;
+            int v_6;
+            int v_7;
+            int v_8;
+            int v_9;
+            int v_10;
+            int v_11;
+            int v_12;
+            int v_13;
+            int v_14;
+            int v_15;
+            // (, line 430
+            // test, line 431
+            v_1 = limit - cursor;
+            // (, line 431
+            // or, line 431
+            lab0: do {
+                v_2 = limit - cursor;
+                lab1: do {
+                    // literal, line 431
+                    if (!(eq_s_b(1, "d")))
+                    {
+                        break lab1;
+                    }
+                    break lab0;
+                } while (false);
+                cursor = limit - v_2;
+                // literal, line 431
+                if (!(eq_s_b(1, "g")))
+                {
+                    return false;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // or, line 433
+            lab2: do {
+                v_3 = limit - cursor;
+                lab3: do {
+                    // (, line 432
+                    // test, line 432
+                    v_4 = limit - cursor;
+                    // (, line 432
+                    // (, line 432
+                    // goto, line 432
+                    golab4: while(true)
+                    {
+                        v_5 = limit - cursor;
+                        lab5: do {
+                            if (!(in_grouping_b(g_vowel, 97, 305)))
+                            {
+                                break lab5;
+                            }
+                            cursor = limit - v_5;
+                            break golab4;
+                        } while (false);
+                        cursor = limit - v_5;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab3;
+                        }
+                        cursor--;
+                    }
+                    // or, line 432
+                    lab6: do {
+                        v_6 = limit - cursor;
+                        lab7: do {
+                            // literal, line 432
+                            if (!(eq_s_b(1, "a")))
+                            {
+                                break lab7;
+                            }
+                            break lab6;
+                        } while (false);
+                        cursor = limit - v_6;
+                        // literal, line 432
+                        if (!(eq_s_b(1, "\u0131")))
+                        {
+                            break lab3;
+                        }
+                    } while (false);
+                    cursor = limit - v_4;
+                    // <+, line 432
+                    {
+                        int c = cursor;
+                        insert(cursor, cursor, "\u0131");
+                        cursor = c;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab8: do {
+                    // (, line 434
+                    // test, line 434
+                    v_7 = limit - cursor;
+                    // (, line 434
+                    // (, line 434
+                    // goto, line 434
+                    golab9: while(true)
+                    {
+                        v_8 = limit - cursor;
+                        lab10: do {
+                            if (!(in_grouping_b(g_vowel, 97, 305)))
+                            {
+                                break lab10;
+                            }
+                            cursor = limit - v_8;
+                            break golab9;
+                        } while (false);
+                        cursor = limit - v_8;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab8;
+                        }
+                        cursor--;
+                    }
+                    // or, line 434
+                    lab11: do {
+                        v_9 = limit - cursor;
+                        lab12: do {
+                            // literal, line 434
+                            if (!(eq_s_b(1, "e")))
+                            {
+                                break lab12;
+                            }
+                            break lab11;
+                        } while (false);
+                        cursor = limit - v_9;
+                        // literal, line 434
+                        if (!(eq_s_b(1, "i")))
+                        {
+                            break lab8;
+                        }
+                    } while (false);
+                    cursor = limit - v_7;
+                    // <+, line 434
+                    {
+                        int c = cursor;
+                        insert(cursor, cursor, "i");
+                        cursor = c;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                lab13: do {
+                    // (, line 436
+                    // test, line 436
+                    v_10 = limit - cursor;
+                    // (, line 436
+                    // (, line 436
+                    // goto, line 436
+                    golab14: while(true)
+                    {
+                        v_11 = limit - cursor;
+                        lab15: do {
+                            if (!(in_grouping_b(g_vowel, 97, 305)))
+                            {
+                                break lab15;
+                            }
+                            cursor = limit - v_11;
+                            break golab14;
+                        } while (false);
+                        cursor = limit - v_11;
+                        if (cursor <= limit_backward)
+                        {
+                            break lab13;
+                        }
+                        cursor--;
+                    }
+                    // or, line 436
+                    lab16: do {
+                        v_12 = limit - cursor;
+                        lab17: do {
+                            // literal, line 436
+                            if (!(eq_s_b(1, "o")))
+                            {
+                                break lab17;
+                            }
+                            break lab16;
+                        } while (false);
+                        cursor = limit - v_12;
+                        // literal, line 436
+                        if (!(eq_s_b(1, "u")))
+                        {
+                            break lab13;
+                        }
+                    } while (false);
+                    cursor = limit - v_10;
+                    // <+, line 436
+                    {
+                        int c = cursor;
+                        insert(cursor, cursor, "u");
+                        cursor = c;
+                    }
+                    break lab2;
+                } while (false);
+                cursor = limit - v_3;
+                // (, line 438
+                // test, line 438
+                v_13 = limit - cursor;
+                // (, line 438
+                // (, line 438
+                // goto, line 438
+                golab18: while(true)
+                {
+                    v_14 = limit - cursor;
+                    lab19: do {
+                        if (!(in_grouping_b(g_vowel, 97, 305)))
+                        {
+                            break lab19;
+                        }
+                        cursor = limit - v_14;
+                        break golab18;
+                    } while (false);
+                    cursor = limit - v_14;
+                    if (cursor <= limit_backward)
+                    {
+                        return false;
+                    }
+                    cursor--;
+                }
+                // or, line 438
+                lab20: do {
+                    v_15 = limit - cursor;
+                    lab21: do {
+                        // literal, line 438
+                        if (!(eq_s_b(1, "\u00F6")))
+                        {
+                            break lab21;
+                        }
+                        break lab20;
+                    } while (false);
+                    cursor = limit - v_15;
+                    // literal, line 438
+                    if (!(eq_s_b(1, "\u00FC")))
+                    {
+                        return false;
+                    }
+                } while (false);
+                cursor = limit - v_13;
+                // <+, line 438
+                {
+                    int c = cursor;
+                    insert(cursor, cursor, "\u00FC");
+                    cursor = c;
+                }
+            } while (false);
+            return true;
+        }
+
+        private boolean r_more_than_one_syllable_word() {
+            int v_1;
+            int v_3;
+            // (, line 445
+            // test, line 446
+            v_1 = cursor;
+            // (, line 446
+            // atleast, line 446
+            {
+                int v_2 = 2;
+                // atleast, line 446
+                replab0: while(true)
+                {
+                    v_3 = cursor;
+                    lab1: do {
+                        // (, line 446
+                        // gopast, line 446
+                        golab2: while(true)
+                        {
+                            lab3: do {
+                                if (!(in_grouping(g_vowel, 97, 305)))
+                                {
+                                    break lab3;
+                                }
+                                break golab2;
+                            } while (false);
+                            if (cursor >= limit)
+                            {
+                                break lab1;
+                            }
+                            cursor++;
+                        }
+                        v_2--;
+                        continue replab0;
+                    } while (false);
+                    cursor = v_3;
+                    break replab0;
+                }
+                if (v_2 > 0)
+                {
+                    return false;
+                }
+            }
+            cursor = v_1;
+            return true;
+        }
+
+        private boolean r_is_reserved_word() {
+            int v_1;
+            int v_2;
+            int v_4;
+            // (, line 449
+            // or, line 451
+            lab0: do {
+                v_1 = cursor;
+                lab1: do {
+                    // test, line 450
+                    v_2 = cursor;
+                    // (, line 450
+                    // gopast, line 450
+                    golab2: while(true)
+                    {
+                        lab3: do {
+                            // literal, line 450
+                            if (!(eq_s(2, "ad")))
+                            {
+                                break lab3;
+                            }
+                            break golab2;
+                        } while (false);
+                        if (cursor >= limit)
+                        {
+                            break lab1;
+                        }
+                        cursor++;
+                    }
+                    // (, line 450
+                    I_strlen = 2;
+                    // (, line 450
+                    if (!(I_strlen == limit))
+                    {
+                        break lab1;
+                    }
+                    cursor = v_2;
+                    break lab0;
+                } while (false);
+                cursor = v_1;
+                // test, line 452
+                v_4 = cursor;
+                // (, line 452
+                // gopast, line 452
+                golab4: while(true)
+                {
+                    lab5: do {
+                        // literal, line 452
+                        if (!(eq_s(5, "soyad")))
+                        {
+                            break lab5;
+                        }
+                        break golab4;
+                    } while (false);
+                    if (cursor >= limit)
+                    {
+                        return false;
+                    }
+                    cursor++;
+                }
+                // (, line 452
+                I_strlen = 5;
+                // (, line 452
+                if (!(I_strlen == limit))
+                {
+                    return false;
+                }
+                cursor = v_4;
+            } while (false);
+            return true;
+        }
+
+        private boolean r_postlude() {
+            int v_1;
+            int v_2;
+            int v_3;
+            // (, line 455
+            // not, line 456
+            {
+                v_1 = cursor;
+                lab0: do {
+                    // (, line 456
+                    // call is_reserved_word, line 456
+                    if (!r_is_reserved_word())
+                    {
+                        break lab0;
+                    }
+                    return false;
+                } while (false);
+                cursor = v_1;
+            }
+            // backwards, line 457
+            limit_backward = cursor; cursor = limit;
+            // (, line 457
+            // do, line 458
+            v_2 = limit - cursor;
+            lab1: do {
+                // call append_U_to_stems_ending_with_d_or_g, line 458
+                if (!r_append_U_to_stems_ending_with_d_or_g())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            // do, line 459
+            v_3 = limit - cursor;
+            lab2: do {
+                // call post_process_last_consonants, line 459
+                if (!r_post_process_last_consonants())
+                {
+                    break lab2;
+                }
+            } while (false);
+            cursor = limit - v_3;
+            cursor = limit_backward;            return true;
+        }
+
+        public boolean stem() {
+            int v_1;
+            int v_2;
+            // (, line 464
+            // (, line 465
+            // call more_than_one_syllable_word, line 465
+            if (!r_more_than_one_syllable_word())
+            {
+                return false;
+            }
+            // (, line 466
+            // backwards, line 467
+            limit_backward = cursor; cursor = limit;
+            // (, line 467
+            // do, line 468
+            v_1 = limit - cursor;
+            lab0: do {
+                // call stem_nominal_verb_suffixes, line 468
+                if (!r_stem_nominal_verb_suffixes())
+                {
+                    break lab0;
+                }
+            } while (false);
+            cursor = limit - v_1;
+            // Boolean test continue_stemming_noun_suffixes, line 469
+            if (!(B_continue_stemming_noun_suffixes))
+            {
+                return false;
+            }
+            // do, line 470
+            v_2 = limit - cursor;
+            lab1: do {
+                // call stem_noun_suffixes, line 470
+                if (!r_stem_noun_suffixes())
+                {
+                    break lab1;
+                }
+            } while (false);
+            cursor = limit - v_2;
+            cursor = limit_backward;            // call postlude, line 473
+            if (!r_postlude())
+            {
+                return false;
+            }
+            return true;
+        }
+
+}
+
diff --git a/contrib/snowball/src/java/overview.html b/contrib/snowball/src/java/overview.html
new file mode 100644
index 0000000..2263638
--- /dev/null
+++ b/contrib/snowball/src/java/overview.html
@@ -0,0 +1,53 @@
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<body>
+<p>
+Lucene Snowball README file
+</p>
+
+<p>
+This project provides pre-compiled version of the Snowball stemmers
+based on revision 500 of the Tartarus Snowball repository,
+together with classes integrating them with the Lucene search engine.
+</p>
+<p>
+A few changes has been made to the static Snowball code and compiled stemmers:
+</p>
+<ul>
+  <li>Class SnowballProgram is made abstract and contains new abstract method stem() to avoid reflection in Lucene filter class SnowballFilter.</li>
+  <li>All use of StringBuffers has been refactored to StringBuilder for speed.</li>
+  <li>Snowball BSD license header has been added to the Java classes to avoid having RAT adding ASL headers.</li>
+</ul>
+<p>
+See the Snowball <a href ="http://snowball.tartarus.org/">home page</a> for more information about the algorithms.
+</p>
+
+<p>
+<b>IMPORTANT NOTICE ON BACKWARDS COMPATIBILITY!</b>
+</p>
+<p>
+An index created using the Snowball module in Lucene 2.3.2 and below
+might not be compatible with the Snowball module in Lucene 2.4 or greater.
+</p>
+<p>
+For more information about this issue see:
+https://issues.apache.org/jira/browse/LUCENE-1142
+</p>
+
+</body>
+</html>
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/danish_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/danish_stop.txt
new file mode 100644
index 0000000..a3ff5fe
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/danish_stop.txt
@@ -0,0 +1,108 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/danish/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Danish stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | This is a ranked list (commonest to rarest) of stopwords derived from
+ | a large text sample.
+
+
+og           | and
+i            | in
+jeg          | I
+det          | that (dem. pronoun)/it (pers. pronoun)
+at           | that (in front of a sentence)/to (with infinitive)
+en           | a/an
+den          | it (pers. pronoun)/that (dem. pronoun)
+til          | to/at/for/until/against/by/of/into, more
+er           | present tense of "to be"
+som          | who, as
+på           | on/upon/in/on/at/to/after/of/with/for, on
+de           | they
+med          | with/by/in, along
+han          | he
+af           | of/by/from/off/for/in/with/on, off
+for          | at/for/to/from/by/of/ago, in front/before, because
+ikke         | not
+der          | who/which, there/those
+var          | past tense of "to be"
+mig          | me/myself
+sig          | oneself/himself/herself/itself/themselves
+men          | but
+et           | a/an/one, one (number), someone/somebody/one
+har          | present tense of "to have"
+om           | round/about/for/in/a, about/around/down, if
+vi           | we
+min          | my
+havde        | past tense of "to have"
+ham          | him
+hun          | she
+nu           | now
+over         | over/above/across/by/beyond/past/on/about, over/past
+da           | then, when/as/since
+fra          | from/off/since, off, since
+du           | you
+ud           | out
+sin          | his/her/its/one's
+dem          | them
+os           | us/ourselves
+op           | up
+man          | you/one
+hans         | his
+hvor         | where
+eller        | or
+hvad         | what
+skal         | must/shall etc.
+selv         | myself/youself/herself/ourselves etc., even
+her          | here
+alle         | all/everyone/everybody etc.
+vil          | will (verb)
+blev         | past tense of "to stay/to remain/to get/to become"
+kunne        | could
+ind          | in
+når          | when
+være         | present tense of "to be"
+dog          | however/yet/after all
+noget        | something
+ville        | would
+jo           | you know/you see (adv), yes
+deres        | their/theirs
+efter        | after/behind/according to/for/by/from, later/afterwards
+ned          | down
+skulle       | should
+denne        | this
+end          | than
+dette        | this
+mit          | my/mine
+også         | also
+under        | under/beneath/below/during, below/underneath
+have         | have
+dig          | you
+anden        | other
+hende        | her
+mine         | my
+alt          | everything
+meget        | much/very, plenty of
+sit          | his, her, its, one's
+sine         | his, her, its, one's
+vor          | our
+mod          | against
+disse        | these
+hvis         | if
+din          | your/yours
+nogle        | some
+hos          | by/at
+blive        | be/become
+mange        | many
+ad           | by/through
+bliver       | present tense of "to be/to become"
+hendes       | her/hers
+været        | be
+thi          | for (conj)
+jer          | you
+sådan        | such, like this/like that
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/dutch_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/dutch_stop.txt
new file mode 100644
index 0000000..f4d61f5
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/dutch_stop.txt
@@ -0,0 +1,117 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/dutch/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Dutch stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | This is a ranked list (commonest to rarest) of stopwords derived from
+ | a large sample of Dutch text.
+
+ | Dutch stop words frequently exhibit homonym clashes. These are indicated
+ | clearly below.
+
+de             |  the
+en             |  and
+van            |  of, from
+ik             |  I, the ego
+te             |  (1) chez, at etc, (2) to, (3) too
+dat            |  that, which
+die            |  that, those, who, which
+in             |  in, inside
+een            |  a, an, one
+hij            |  he
+het            |  the, it
+niet           |  not, nothing, naught
+zijn           |  (1) to be, being, (2) his, one's, its
+is             |  is
+was            |  (1) was, past tense of all persons sing. of 'zijn' (to be) (2) wax, (3) the washing, (4) rise of river
+op             |  on, upon, at, in, up, used up
+aan            |  on, upon, to (as dative)
+met            |  with, by
+als            |  like, such as, when
+voor           |  (1) before, in front of, (2) furrow
+had            |  had, past tense all persons sing. of 'hebben' (have)
+er             |  there
+maar           |  but, only
+om             |  round, about, for etc
+hem            |  him
+dan            |  then
+zou            |  should/would, past tense all persons sing. of 'zullen'
+of             |  or, whether, if
+wat            |  what, something, anything
+mijn           |  possessive and noun 'mine'
+men            |  people, 'one'
+dit            |  this
+zo             |  so, thus, in this way
+door           |  through by
+over           |  over, across
+ze             |  she, her, they, them
+zich           |  oneself
+bij            |  (1) a bee, (2) by, near, at
+ook            |  also, too
+tot            |  till, until
+je             |  you
+mij            |  me
+uit            |  out of, from
+der            |  Old Dutch form of 'van der' still found in surnames
+daar           |  (1) there, (2) because
+haar           |  (1) her, their, them, (2) hair
+naar           |  (1) unpleasant, unwell etc, (2) towards, (3) as
+heb            |  present first person sing. of 'to have'
+hoe            |  how, why
+heeft          |  present third person sing. of 'to have'
+hebben         |  'to have' and various parts thereof
+deze           |  this
+u              |  you
+want           |  (1) for, (2) mitten, (3) rigging
+nog            |  yet, still
+zal            |  'shall', first and third person sing. of verb 'zullen' (will)
+me             |  me
+zij            |  she, they
+nu             |  now
+ge             |  'thou', still used in Belgium and south Netherlands
+geen           |  none
+omdat          |  because
+iets           |  something, somewhat
+worden         |  to become, grow, get
+toch           |  yet, still
+al             |  all, every, each
+waren          |  (1) 'were' (2) to wander, (3) wares, (3)
+veel           |  much, many
+meer           |  (1) more, (2) lake
+doen           |  to do, to make
+toen           |  then, when
+moet           |  noun 'spot/mote' and present form of 'to must'
+ben            |  (1) am, (2) 'are' in interrogative second person singular of 'to be'
+zonder         |  without
+kan            |  noun 'can' and present form of 'to be able'
+hun            |  their, them
+dus            |  so, consequently
+alles          |  all, everything, anything
+onder          |  under, beneath
+ja             |  yes, of course
+eens           |  once, one day
+hier           |  here
+wie            |  who
+werd           |  imperfect third person sing. of 'become'
+altijd         |  always
+doch           |  yet, but etc
+wordt          |  present third person sing. of 'become'
+wezen          |  (1) to be, (2) 'been' as in 'been fishing', (3) orphans
+kunnen         |  to be able
+ons            |  us/our
+zelf           |  self
+tegen          |  against, towards, at
+na             |  after, near
+reeds          |  already
+wil            |  (1) present tense of 'want', (2) 'will', noun, (3) fender
+kon            |  could; past tense of 'to be able'
+niets          |  nothing
+uw             |  your
+iemand         |  somebody
+geweest        |  been; past participle of 'be'
+andere         |  other
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/english_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/english_stop.txt
new file mode 100644
index 0000000..821c03e
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/english_stop.txt
@@ -0,0 +1,317 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/english/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+ 
+ | An English stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | Many of the forms below are quite rare (e.g. "yourselves") but included for
+ |  completeness.
+
+           | PRONOUNS FORMS
+             | 1st person sing
+
+i              | subject, always in upper case of course
+
+me             | object
+my             | possessive adjective
+               | the possessive pronoun `mine' is best suppressed, because of the
+               | sense of coal-mine etc.
+myself         | reflexive
+             | 1st person plural
+we             | subject
+
+| us           | object
+               | care is required here because US = United States. It is usually
+               | safe to remove it if it is in lower case.
+our            | possessive adjective
+ours           | possessive pronoun
+ourselves      | reflexive
+             | second person (archaic `thou' forms not included)
+you            | subject and object
+your           | possessive adjective
+yours          | possessive pronoun
+yourself       | reflexive (singular)
+yourselves     | reflexive (plural)
+             | third person singular
+he             | subject
+him            | object
+his            | possessive adjective and pronoun
+himself        | reflexive
+
+she            | subject
+her            | object and possessive adjective
+hers           | possessive pronoun
+herself        | reflexive
+
+it             | subject and object
+its            | possessive adjective
+itself         | reflexive
+             | third person plural
+they           | subject
+them           | object
+their          | possessive adjective
+theirs         | possessive pronoun
+themselves     | reflexive
+             | other forms (demonstratives, interrogatives)
+what
+which
+who
+whom
+this
+that
+these
+those
+
+           | VERB FORMS (using F.R. Palmer's nomenclature)
+             | BE
+am             | 1st person, present
+is             | -s form (3rd person, present)
+are            | present
+was            | 1st person, past
+were           | past
+be             | infinitive
+been           | past participle
+being          | -ing form
+             | HAVE
+have           | simple
+has            | -s form
+had            | past
+having         | -ing form
+             | DO
+do             | simple
+does           | -s form
+did            | past
+doing          | -ing form
+
+ | The forms below are, I believe, best omitted, because of the significant
+ | homonym forms:
+
+ |  He made a WILL
+ |  old tin CAN
+ |  merry month of MAY
+ |  a smell of MUST
+ |  fight the good fight with all thy MIGHT
+
+ | would, could, should, ought might however be included
+
+ |          | AUXILIARIES
+ |            | WILL
+ |will
+
+would
+
+ |            | SHALL
+ |shall
+
+should
+
+ |            | CAN
+ |can
+
+could
+
+ |            | MAY
+ |may
+ |might
+ |            | MUST
+ |must
+ |            | OUGHT
+
+ought
+
+           | COMPOUND FORMS, increasingly encountered nowadays in 'formal' writing
+              | pronoun + verb
+
+i'm
+you're
+he's
+she's
+it's
+we're
+they're
+i've
+you've
+we've
+they've
+i'd
+you'd
+he'd
+she'd
+we'd
+they'd
+i'll
+you'll
+he'll
+she'll
+we'll
+they'll
+
+              | verb + negation
+
+isn't
+aren't
+wasn't
+weren't
+hasn't
+haven't
+hadn't
+doesn't
+don't
+didn't
+
+              | auxiliary + negation
+
+won't
+wouldn't
+shan't
+shouldn't
+can't
+cannot
+couldn't
+mustn't
+
+             | miscellaneous forms
+
+let's
+that's
+who's
+what's
+here's
+there's
+when's
+where's
+why's
+how's
+
+              | rarer forms
+
+ | daren't needn't
+
+              | doubtful forms
+
+ | oughtn't mightn't
+
+           | ARTICLES
+a
+an
+the
+
+           | THE REST (Overlap among prepositions, conjunctions, adverbs etc is so
+           | high, that classification is pointless.)
+and
+but
+if
+or
+because
+as
+until
+while
+
+of
+at
+by
+for
+with
+about
+against
+between
+into
+through
+during
+before
+after
+above
+below
+to
+from
+up
+down
+in
+out
+on
+off
+over
+under
+
+again
+further
+then
+once
+
+here
+there
+when
+where
+why
+how
+
+all
+any
+both
+each
+few
+more
+most
+other
+some
+such
+
+no
+nor
+not
+only
+own
+same
+so
+than
+too
+very
+
+ | Just for the record, the following words are among the commonest in English
+
+    | one
+    | every
+    | least
+    | less
+    | many
+    | now
+    | ever
+    | never
+    | say
+    | says
+    | said
+    | also
+    | get
+    | go
+    | goes
+    | just
+    | made
+    | make
+    | put
+    | see
+    | seen
+    | whether
+    | like
+    | well
+    | back
+    | even
+    | still
+    | way
+    | take
+    | since
+    | another
+    | however
+    | two
+    | three
+    | four
+    | five
+    | first
+    | second
+    | new
+    | old
+    | high
+    | long
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/finnish_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/finnish_stop.txt
new file mode 100644
index 0000000..addad79
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/finnish_stop.txt
@@ -0,0 +1,95 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/finnish/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+ 
+| forms of BE
+
+olla
+olen
+olet
+on
+olemme
+olette
+ovat
+ole        | negative form
+
+oli
+olisi
+olisit
+olisin
+olisimme
+olisitte
+olisivat
+olit
+olin
+olimme
+olitte
+olivat
+ollut
+olleet
+
+en         | negation
+et
+ei
+emme
+ette
+eivät
+
+|Nom   Gen    Acc    Part   Iness   Elat    Illat  Adess   Ablat   Allat   Ess    Trans
+minä   minun  minut  minua  minussa minusta minuun minulla minulta minulle               | I
+sinä   sinun  sinut  sinua  sinussa sinusta sinuun sinulla sinulta sinulle               | you
+hän    hänen  hänet  häntä  hänessä hänestä häneen hänellä häneltä hänelle               | he she
+me     meidän meidät meitä  meissä  meistä  meihin meillä  meiltä  meille                | we
+te     teidän teidät teitä  teissä  teistä  teihin teillä  teiltä  teille                | you
+he     heidän heidät heitä  heissä  heistä  heihin heillä  heiltä  heille                | they
+
+tämä   tämän         tätä   tässä   tästä   tähän  tallä   tältä   tälle   tänä   täksi  | this
+tuo    tuon          tuotä  tuossa  tuosta  tuohon tuolla  tuolta  tuolle  tuona  tuoksi | that
+se     sen           sitä   siinä   siitä   siihen sillä   siltä   sille   sinä   siksi  | it
+nämä   näiden        näitä  näissä  näistä  näihin näillä  näiltä  näille  näinä  näiksi | these
+nuo    noiden        noita  noissa  noista  noihin noilla  noilta  noille  noina  noiksi | those
+ne     niiden        niitä  niissä  niistä  niihin niillä  niiltä  niille  niinä  niiksi | they
+
+kuka   kenen kenet   ketä   kenessä kenestä keneen kenellä keneltä kenelle kenenä keneksi| who
+ketkä  keiden ketkä  keitä  keissä  keistä  keihin keillä  keiltä  keille  keinä  keiksi | (pl)
+mikä   minkä minkä   mitä   missä   mistä   mihin  millä   miltä   mille   minä   miksi  | which what
+mitkä                                                                                    | (pl)
+
+joka   jonka         jota   jossa   josta   johon  jolla   jolta   jolle   jona   joksi  | who which
+jotka  joiden        joita  joissa  joista  joihin joilla  joilta  joille  joina  joiksi | (pl)
+
+| conjunctions
+
+että   | that
+ja     | and
+jos    | if
+koska  | because
+kuin   | than
+mutta  | but
+niin   | so
+sekä   | and
+sillä  | for
+tai    | or
+vaan   | but
+vai    | or
+vaikka | although
+
+
+| prepositions
+
+kanssa  | with
+mukaan  | according to
+noin    | about
+poikki  | across
+yli     | over, across
+
+| other
+
+kun    | when
+niin   | so
+nyt    | now
+itse   | self
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/french_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/french_stop.txt
new file mode 100644
index 0000000..c00837ea
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/french_stop.txt
@@ -0,0 +1,183 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/french/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A French stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+au             |  a + le
+aux            |  a + les
+avec           |  with
+ce             |  this
+ces            |  these
+dans           |  with
+de             |  of
+des            |  de + les
+du             |  de + le
+elle           |  she
+en             |  `of them' etc
+et             |  and
+eux            |  them
+il             |  he
+je             |  I
+la             |  the
+le             |  the
+leur           |  their
+lui            |  him
+ma             |  my (fem)
+mais           |  but
+me             |  me
+même           |  same; as in moi-même (myself) etc
+mes            |  me (pl)
+moi            |  me
+mon            |  my (masc)
+ne             |  not
+nos            |  our (pl)
+notre          |  our
+nous           |  we
+on             |  one
+ou             |  where
+par            |  by
+pas            |  not
+pour           |  for
+qu             |  que before vowel
+que            |  that
+qui            |  who
+sa             |  his, her (fem)
+se             |  oneself
+ses            |  his (pl)
+son            |  his, her (masc)
+sur            |  on
+ta             |  thy (fem)
+te             |  thee
+tes            |  thy (pl)
+toi            |  thee
+ton            |  thy (masc)
+tu             |  thou
+un             |  a
+une            |  a
+vos            |  your (pl)
+votre          |  your
+vous           |  you
+
+               |  single letter forms
+
+c              |  c'
+d              |  d'
+j              |  j'
+l              |  l'
+?              |  to, at
+m              |  m'
+n              |  n'
+s              |  s'
+t              |  t'
+y              |  there
+
+               | forms of être (not including the infinitive):
+été
+étée
+étées
+étés
+étant
+suis
+es
+est
+sommes
+êtes
+sont
+serai
+seras
+sera
+serons
+serez
+seront
+serais
+serait
+serions
+seriez
+seraient
+étais
+était
+étions
+étiez
+étaient
+fus
+fut
+fûmes
+fûtes
+furent
+sois
+soit
+soyons
+soyez
+soient
+fusse
+fusses
+fût
+fussions
+fussiez
+fussent
+
+               | forms of avoir (not including the infinitive):
+ayant
+eu
+eue
+eues
+eus
+ai
+as
+avons
+avez
+ont
+aurai
+auras
+aura
+aurons
+aurez
+auront
+aurais
+aurait
+aurions
+auriez
+auraient
+avais
+avait
+avions
+aviez
+avaient
+eut
+eûmes
+eûtes
+eurent
+aie
+aies
+ait
+ayons
+ayez
+aient
+eusse
+eusses
+eût
+eussions
+eussiez
+eussent
+
+               | Later additions (from Jean-Christophe Deschamps)
+ceci           |  this
+cel??          |  that
+cet            |  this
+cette          |  this
+ici            |  here
+ils            |  they
+les            |  the (pl)
+leurs          |  their (pl)
+quel           |  which
+quels          |  which
+quelle         |  which
+quelles        |  which
+sans           |  without
+soi            |  oneself
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/german_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/german_stop.txt
new file mode 100644
index 0000000..f770384
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/german_stop.txt
@@ -0,0 +1,292 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/german/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A German stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | The number of forms in this list is reduced significantly by passing it
+ | through the German stemmer.
+
+
+aber           |  but
+
+alle           |  all
+allem
+allen
+aller
+alles
+
+als            |  than, as
+also           |  so
+am             |  an + dem
+an             |  at
+
+ander          |  other
+andere
+anderem
+anderen
+anderer
+anderes
+anderm
+andern
+anderr
+anders
+
+auch           |  also
+auf            |  on
+aus            |  out of
+bei            |  by
+bin            |  am
+bis            |  until
+bist           |  art
+da             |  there
+damit          |  with it
+dann           |  then
+
+der            |  the
+den
+des
+dem
+die
+das
+
+da?            |  that
+
+derselbe       |  the same
+derselben
+denselben
+desselben
+demselben
+dieselbe
+dieselben
+dasselbe
+
+dazu           |  to that
+
+dein           |  thy
+deine
+deinem
+deinen
+deiner
+deines
+
+denn           |  because
+
+derer          |  of those
+dessen         |  of him
+
+dich           |  thee
+dir            |  to thee
+du             |  thou
+
+dies           |  this
+diese
+diesem
+diesen
+dieser
+dieses
+
+
+doch           |  (several meanings)
+dort           |  (over) there
+
+
+durch          |  through
+
+ein            |  a
+eine
+einem
+einen
+einer
+eines
+
+einig          |  some
+einige
+einigem
+einigen
+einiger
+einiges
+
+einmal         |  once
+
+er             |  he
+ihn            |  him
+ihm            |  to him
+
+es             |  it
+etwas          |  something
+
+euer           |  your
+eure
+eurem
+euren
+eurer
+eures
+
+für            |  for
+gegen          |  towards
+gewesen        |  p.p. of sein
+hab            |  have
+habe           |  have
+haben          |  have
+hat            |  has
+hatte          |  had
+hatten         |  had
+hier           |  here
+hin            |  there
+hinter         |  behind
+
+ich            |  I
+mich           |  me
+mir            |  to me
+
+
+ihr            |  you, to her
+ihre
+ihrem
+ihren
+ihrer
+ihres
+euch           |  to you
+
+im             |  in + dem
+in             |  in
+indem          |  while
+ins            |  in + das
+ist            |  is
+
+jede           |  each, every
+jedem
+jeden
+jeder
+jedes
+
+jene           |  that
+jenem
+jenen
+jener
+jenes
+
+jetzt          |  now
+kann           |  can
+
+kein           |  no
+keine
+keinem
+keinen
+keiner
+keines
+
+können         |  can
+könnte         |  could
+machen         |  do
+man            |  one
+
+manche         |  some, many a
+manchem
+manchen
+mancher
+manches
+
+mein           |  my
+meine
+meinem
+meinen
+meiner
+meines
+
+mit            |  with
+muss           |  must
+musste         |  had to
+nach           |  to(wards)
+nicht          |  not
+nichts         |  nothing
+noch           |  still, yet
+nun            |  now
+nur            |  only
+ob             |  whether
+oder           |  or
+ohne           |  without
+sehr           |  very
+
+sein           |  his
+seine
+seinem
+seinen
+seiner
+seines
+
+selbst         |  self
+sich           |  herself
+
+sie            |  they, she
+ihnen          |  to them
+
+sind           |  are
+so             |  so
+
+solche         |  such
+solchem
+solchen
+solcher
+solches
+
+soll           |  shall
+sollte         |  should
+sondern        |  but
+sonst          |  else
+über           |  over
+um             |  about, around
+und            |  and
+
+uns            |  us
+unse
+unsem
+unsen
+unser
+unses
+
+unter          |  under
+viel           |  much
+vom            |  von + dem
+von            |  from
+vor            |  before
+während        |  while
+war            |  was
+waren          |  were
+warst          |  wast
+was            |  what
+weg            |  away, off
+weil           |  because
+weiter         |  further
+
+welche         |  which
+welchem
+welchen
+welcher
+welches
+
+wenn           |  when
+werde          |  will
+werden         |  will
+wie            |  how
+wieder         |  again
+will           |  want
+wir            |  we
+wird           |  will
+wirst          |  willst
+wo             |  where
+wollen         |  want
+wollte         |  wanted
+würde          |  would
+würden         |  would
+zu             |  to
+zum            |  zu + dem
+zur            |  zu + der
+zwar           |  indeed
+zwischen       |  between
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/hungarian_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/hungarian_stop.txt
new file mode 100644
index 0000000..1a96f1d
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/hungarian_stop.txt
@@ -0,0 +1,209 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/hungarian/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+ 
+| Hungarian stop word list
+| prepared by Anna Tordai
+
+a
+ahogy
+ahol
+aki
+akik
+akkor
+alatt
+által
+általában
+amely
+amelyek
+amelyekben
+amelyeket
+amelyet
+amelynek
+ami
+amit
+amolyan
+amíg
+amikor
+át
+abban
+ahhoz
+annak
+arra
+arról
+az
+azok
+azon
+azt
+azzal
+azért
+aztán
+azután
+azonban
+bár
+be
+belül
+benne
+cikk
+cikkek
+cikkeket
+csak
+de
+e
+eddig
+egész
+egy
+egyes
+egyetlen
+egyéb
+egyik
+egyre
+ekkor
+el
+elég
+ellen
+el?
+el?ször
+el?tt
+els?
+én
+éppen
+ebben
+ehhez
+emilyen
+ennek
+erre
+ez
+ezt
+ezek
+ezen
+ezzel
+ezért
+és
+fel
+felé
+hanem
+hiszen
+hogy
+hogyan
+igen
+így
+illetve
+ill.
+ill
+ilyen
+ilyenkor
+ison
+ismét
+itt
+jó
+jól
+jobban
+kell
+kellett
+keresztül
+keressünk
+ki
+kívül
+között
+közül
+legalább
+lehet
+lehetett
+legyen
+lenne
+lenni
+lesz
+lett
+maga
+magát
+majd
+majd
+már
+más
+másik
+meg
+még
+mellett
+mert
+mely
+melyek
+mi
+mit
+míg
+miért
+milyen
+mikor
+minden
+mindent
+mindenki
+mindig
+mint
+mintha
+mivel
+most
+nagy
+nagyobb
+nagyon
+ne
+néha
+nekem
+neki
+nem
+néhány
+nélkül
+nincs
+olyan
+ott
+össze
+?
+?k
+?ket
+pedig
+persze
+rá
+s
+saját
+sem
+semmi
+sok
+sokat
+sokkal
+számára
+szemben
+szerint
+szinte
+talán
+tehát
+teljes
+tovább
+továbbá
+több
+úgy
+ugyanis
+új
+újabb
+újra
+után
+utána
+utolsó
+vagy
+vagyis
+valaki
+valami
+valamint
+való
+vagyok
+van
+vannak
+volt
+voltam
+voltak
+voltunk
+vissza
+vele
+viszont
+volna
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/italian_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/italian_stop.txt
new file mode 100644
index 0000000..4cb5b08
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/italian_stop.txt
@@ -0,0 +1,301 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/italian/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | An Italian stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ad             |  a (to) before vowel
+al             |  a + il
+allo           |  a + lo
+ai             |  a + i
+agli           |  a + gli
+all            |  a + l'
+agl            |  a + gl'
+alla           |  a + la
+alle           |  a + le
+con            |  with
+col            |  con + il
+coi            |  con + i (forms collo, cogli etc are now very rare)
+da             |  from
+dal            |  da + il
+dallo          |  da + lo
+dai            |  da + i
+dagli          |  da + gli
+dall           |  da + l'
+dagl           |  da + gll'
+dalla          |  da + la
+dalle          |  da + le
+di             |  of
+del            |  di + il
+dello          |  di + lo
+dei            |  di + i
+degli          |  di + gli
+dell           |  di + l'
+degl           |  di + gl'
+della          |  di + la
+delle          |  di + le
+in             |  in
+nel            |  in + el
+nello          |  in + lo
+nei            |  in + i
+negli          |  in + gli
+nell           |  in + l'
+negl           |  in + gl'
+nella          |  in + la
+nelle          |  in + le
+su             |  on
+sul            |  su + il
+sullo          |  su + lo
+sui            |  su + i
+sugli          |  su + gli
+sull           |  su + l'
+sugl           |  su + gl'
+sulla          |  su + la
+sulle          |  su + le
+per            |  through, by
+tra            |  among
+contro         |  against
+io             |  I
+tu             |  thou
+lui            |  he
+lei            |  she
+noi            |  we
+voi            |  you
+loro           |  they
+mio            |  my
+mia            |
+miei           |
+mie            |
+tuo            |
+tua            |
+tuoi           |  thy
+tue            |
+suo            |
+sua            |
+suoi           |  his, her
+sue            |
+nostro         |  our
+nostra         |
+nostri         |
+nostre         |
+vostro         |  your
+vostra         |
+vostri         |
+vostre         |
+mi             |  me
+ti             |  thee
+ci             |  us, there
+vi             |  you, there
+lo             |  him, the
+la             |  her, the
+li             |  them
+le             |  them, the
+gli            |  to him, the
+ne             |  from there etc
+il             |  the
+un             |  a
+uno            |  a
+una            |  a
+ma             |  but
+ed             |  and
+se             |  if
+perché         |  why, because
+anche          |  also
+come           |  how
+dov            |  where (as dov')
+dove           |  where
+che            |  who, that
+chi            |  who
+cui            |  whom
+non            |  not
+più            |  more
+quale          |  who, that
+quanto         |  how much
+quanti         |
+quanta         |
+quante         |
+quello         |  that
+quelli         |
+quella         |
+quelle         |
+questo         |  this
+questi         |
+questa         |
+queste         |
+si             |  yes
+tutto          |  all
+tutti          |  all
+
+               |  single letter forms:
+
+a              |  at
+c              |  as c' for ce or ci
+e              |  and
+i              |  the
+l              |  as l'
+o              |  or
+
+               | forms of avere, to have (not including the infinitive):
+
+ho
+hai
+ha
+abbiamo
+avete
+hanno
+abbia
+abbiate
+abbiano
+avrò
+avrai
+avr?
+avremo
+avrete
+avranno
+avrei
+avresti
+avrebbe
+avremmo
+avreste
+avrebbero
+avevo
+avevi
+aveva
+avevamo
+avevate
+avevano
+ebbi
+avesti
+ebbe
+avemmo
+aveste
+ebbero
+avessi
+avesse
+avessimo
+avessero
+avendo
+avuto
+avuta
+avuti
+avute
+
+               | forms of essere, to be (not including the infinitive):
+sono
+sei
+è
+siamo
+siete
+sia
+siate
+siano
+sarò
+sarai
+sar?
+saremo
+sarete
+saranno
+sarei
+saresti
+sarebbe
+saremmo
+sareste
+sarebbero
+ero
+eri
+era
+eravamo
+eravate
+erano
+fui
+fosti
+fu
+fummo
+foste
+furono
+fossi
+fosse
+fossimo
+fossero
+essendo
+
+               | forms of fare, to do (not including the infinitive, fa, fat-):
+faccio
+fai
+facciamo
+fanno
+faccia
+facciate
+facciano
+farò
+farai
+far?
+faremo
+farete
+faranno
+farei
+faresti
+farebbe
+faremmo
+fareste
+farebbero
+facevo
+facevi
+faceva
+facevamo
+facevate
+facevano
+feci
+facesti
+fece
+facemmo
+faceste
+fecero
+facessi
+facesse
+facessimo
+facessero
+facendo
+
+               | forms of stare, to be (not including the infinitive):
+sto
+stai
+sta
+stiamo
+stanno
+stia
+stiate
+stiano
+starò
+starai
+star?
+staremo
+starete
+staranno
+starei
+staresti
+starebbe
+staremmo
+stareste
+starebbero
+stavo
+stavi
+stava
+stavamo
+stavate
+stavano
+stetti
+stesti
+stette
+stemmo
+steste
+stettero
+stessi
+stesse
+stessimo
+stessero
+stando
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/norwegian_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/norwegian_stop.txt
new file mode 100644
index 0000000..e76f36e
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/norwegian_stop.txt
@@ -0,0 +1,192 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/norwegian/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Norwegian stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | This stop word list is for the dominant bokmål dialect. Words unique
+ | to nynorsk are marked *.
+
+ | Revised by Jan Bruusgaard <Jan.Bruusgaard@ssb.no>, Jan 2005
+
+og             | and
+i              | in
+jeg            | I
+det            | it/this/that
+at             | to (w. inf.)
+en             | a/an
+et             | a/an
+den            | it/this/that
+til            | to
+er             | is/am/are
+som            | who/that
+på             | on
+de             | they / you(formal)
+med            | with
+han            | he
+av             | of
+ikke           | not
+ikkje          | not *
+der            | there
+så             | so
+var            | was/were
+meg            | me
+seg            | you
+men            | but
+ett            | one
+har            | have
+om             | about
+vi             | we
+min            | my
+mitt           | my
+ha             | have
+hadde          | had
+hun            | she
+nå             | now
+over           | over
+da             | when/as
+ved            | by/know
+fra            | from
+du             | you
+ut             | out
+sin            | your
+dem            | them
+oss            | us
+opp            | up
+man            | you/one
+kan            | can
+hans           | his
+hvor           | where
+eller          | or
+hva            | what
+skal           | shall/must
+selv           | self (reflective)
+sjøl           | self (reflective)
+her            | here
+alle           | all
+vil            | will
+bli            | become
+ble            | became
+blei           | became *
+blitt          | have become
+kunne          | could
+inn            | in
+når            | when
+være           | be
+kom            | come
+noen           | some
+noe            | some
+ville          | would
+dere           | you
+som            | who/which/that
+deres          | their/theirs
+kun            | only/just
+ja             | yes
+etter          | after
+ned            | down
+skulle         | should
+denne          | this
+for            | for/because
+deg            | you
+si             | hers/his
+sine           | hers/his
+sitt           | hers/his
+mot            | against
+å              | to
+meget          | much
+hvorfor        | why
+dette          | this
+disse          | these/those
+uten           | without
+hvordan        | how
+ingen          | none
+din            | your
+ditt           | your
+blir           | become
+samme          | same
+hvilken        | which
+hvilke         | which (plural)
+sånn           | such a
+inni           | inside/within
+mellom         | between
+vår            | our
+hver           | each
+hvem           | who
+vors           | us/ours
+hvis           | whose
+både           | both
+bare           | only/just
+enn            | than
+fordi          | as/because
+før            | before
+mange          | many
+også           | also
+slik           | just
+vært           | been
+være           | to be
+båe            | both *
+begge          | both
+siden          | since
+dykk           | your *
+dykkar         | yours *
+dei            | they *
+deira          | them *
+deires         | theirs *
+deim           | them *
+di             | your (fem.) *
+då             | as/when *
+eg             | I *
+ein            | a/an *
+eit            | a/an *
+eitt           | a/an *
+elles          | or *
+honom          | he *
+hjå            | at *
+ho             | she *
+hoe            | she *
+henne          | her
+hennar         | her/hers
+hennes         | hers
+hoss           | how *
+hossen         | how *
+ikkje          | not *
+ingi           | noone *
+inkje          | noone *
+korleis        | how *
+korso          | how *
+kva            | what/which *
+kvar           | where *
+kvarhelst      | where *
+kven           | who/whom *
+kvi            | why *
+kvifor         | why *
+me             | we *
+medan          | while *
+mi             | my *
+mine           | my *
+mykje          | much *
+no             | now *
+nokon          | some (masc./neut.) *
+noka           | some (fem.) *
+nokor          | some *
+noko           | some *
+nokre          | some *
+si             | his/hers *
+sia            | since *
+sidan          | since *
+so             | so *
+somt           | some *
+somme          | some *
+um             | about*
+upp            | up *
+vere           | be *
+vore           | was *
+verte          | become *
+vort           | become *
+varte          | became *
+vart           | became *
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/portuguese_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/portuguese_stop.txt
new file mode 100644
index 0000000..276c1b4
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/portuguese_stop.txt
@@ -0,0 +1,251 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/portuguese/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Portuguese stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+
+ | The following is a ranked list (commonest to rarest) of stopwords
+ | deriving from a large sample of text.
+
+ | Extra words have been added at the end.
+
+de             |  of, from
+a              |  the; to, at; her
+o              |  the; him
+que            |  who, that
+e              |  and
+do             |  de + o
+da             |  de + a
+em             |  in
+um             |  a
+para           |  for
+  | é          from SER
+com            |  with
+não            |  not, no
+uma            |  a
+os             |  the; them
+no             |  em + o
+se             |  himself etc
+na             |  em + a
+por            |  for
+mais           |  more
+as             |  the; them
+dos            |  de + os
+como           |  as, like
+mas            |  but
+  | foi        from SER
+ao             |  a + o
+ele            |  he
+das            |  de + as
+  | tem        from TER
+?              |  a + a
+seu            |  his
+sua            |  her
+ou             |  or
+  | ser        from SER
+quando         |  when
+muito          |  much
+  | há         from HAV
+nos            |  em + os; us
+já             |  already, now
+  | está       from EST
+eu             |  I
+também         |  also
+só             |  only, just
+pelo           |  per + o
+pela           |  per + a
+até            |  up to
+isso           |  that
+ela            |  he
+entre          |  between
+  | era        from SER
+depois         |  after
+sem            |  without
+mesmo          |  same
+aos            |  a + os
+  | ter        from TER
+seus           |  his
+quem           |  whom
+nas            |  em + as
+me             |  me
+esse           |  that
+eles           |  they
+  | estão      from EST
+você           |  you
+  | tinha      from TER
+  | foram      from SER
+essa           |  that
+num            |  em + um
+nem            |  nor
+suas           |  her
+meu            |  my
+?s             |  a + as
+minha          |  my
+  | têm        from TER
+numa           |  em + uma
+pelos          |  per + os
+elas           |  they
+  | havia      from HAV
+  | seja       from SER
+qual           |  which
+  | será       from SER
+nós            |  we
+  | tenho      from TER
+lhe            |  to him, her
+deles          |  of them
+essas          |  those
+esses          |  those
+pelas          |  per + as
+este           |  this
+  | fosse      from SER
+dele           |  of him
+
+ | other words. There are many contractions such as naquele = em+aquele,
+ | mo = me+o, but they are rare.
+ | Indefinite article plural forms are also rare.
+
+tu             |  thou
+te             |  thee
+vocês          |  you (plural)
+vos            |  you
+lhes           |  to them
+meus           |  my
+minhas
+teu            |  thy
+tua
+teus
+tuas
+nosso          | our
+nossa
+nossos
+nossas
+
+dela           |  of her
+delas          |  of them
+
+esta           |  this
+estes          |  these
+estas          |  these
+aquele         |  that
+aquela         |  that
+aqueles        |  those
+aquelas        |  those
+isto           |  this
+aquilo         |  that
+
+               | forms of estar, to be (not including the infinitive):
+estou
+está
+estamos
+estão
+estive
+esteve
+estivemos
+estiveram
+estava
+estávamos
+estavam
+estivera
+estivéramos
+esteja
+estejamos
+estejam
+estivesse
+estivéssemos
+estivessem
+estiver
+estivermos
+estiverem
+
+               | forms of haver, to have (not including the infinitive):
+hei
+há
+havemos
+hão
+houve
+houvemos
+houveram
+houvera
+houvéramos
+haja
+hajamos
+hajam
+houvesse
+houvéssemos
+houvessem
+houver
+houvermos
+houverem
+houverei
+houverá
+houveremos
+houverão
+houveria
+houveríamos
+houveriam
+
+               | forms of ser, to be (not including the infinitive):
+sou
+somos
+são
+era
+éramos
+eram
+fui
+foi
+fomos
+foram
+fora
+fôramos
+seja
+sejamos
+sejam
+fosse
+fôssemos
+fossem
+for
+formos
+forem
+serei
+será
+seremos
+serão
+seria
+seríamos
+seriam
+
+               | forms of ter, to have (not including the infinitive):
+tenho
+tem
+temos
+tém
+tinha
+tínhamos
+tinham
+tive
+teve
+tivemos
+tiveram
+tivera
+tivéramos
+tenha
+tenhamos
+tenham
+tivesse
+tivéssemos
+tivessem
+tiver
+tivermos
+tiverem
+terei
+terá
+teremos
+terão
+teria
+teríamos
+teriam
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/russian_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/russian_stop.txt
new file mode 100644
index 0000000..6430769
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/russian_stop.txt
@@ -0,0 +1,241 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/russian/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | a russian stop word list. comments begin with vertical bar. each stop
+ | word is at the start of a line.
+
+ | this is a ranked list (commonest to rarest) of stopwords derived from
+ | a large text sample.
+
+ | letter `?' is translated to `е'.
+
+и              | and
+в              | in/into
+во             | alternative form
+не             | not
+??о            | what/that
+он             | he
+на             | on/onto
+?              | i
+?              | from
+?о             | alternative form
+как            | how
+а              | milder form of `no' (but)
+?о             | conjunction and form of `that'
+в?е            | all
+она            | she
+?ак            | so, thus
+его            | him
+но             | but
+да             | yes/and
+??             | thou
+к              | towards, by
+?              | around, chez
+же             | intensifier particle
+в?             | you
+за             | beyond, behind
+б?             | conditional/subj. particle
+по             | up to, along
+?ол?ко         | only
+ее             | her
+мне            | to me
+б?ло           | it was
+во?            | here is/are, particle
+о?             | away from
+мен?           | me
+е?е            | still, yet, more
+не?            | no, there isnt/arent
+о              | about
+из             | out of
+ем?            | to him
+?епе??         | now
+когда          | when
+даже           | even
+н?             | so, well
+вд??г          | suddenly
+ли             | interrogative particle
+е?ли           | if
+?же            | already, but homonym of `narrower'
+или            | or
+ни             | neither
+б???           | to be
+б?л            | he was
+него           | prepositional form of его
+до             | up to
+ва?            | you accusative
+ниб?д?         | indef. suffix preceded by hyphen
+оп???          | again
+?ж             | already, but homonym of `adder'
+вам            | to you
+?казал         | he said
+вед?           | particle `after all'
+?ам            | there
+по?ом          | then
+?еб?           | oneself
+ни?его         | nothing
+ей             | to her
+може?          | usually with `б???' as `maybe'
+они            | they
+???            | here
+где            | where
+е???           | there is/are
+надо           | got to, must
+ней            | prepositional form of  ей
+дл?            | for
+м?             | we
+?еб?           | thee
+и?             | them, their
+?ем            | than
+б?ла           | she was
+?ам            | self
+??об           | in order to
+без            | without
+б?д?о          | as if
+?еловек        | man, person, one
+?его           | genitive form of `what'
+?аз            | once
+?оже           | also
+?ебе           | to oneself
+под            | beneath
+жизн?          | life
+б?де?          | will be
+ж              | short form of intensifer particle `же'
+?огда          | then
+к?о            | who
+??о?           | this
+гово?ил        | was saying
+?ого           | genitive form of `that'
+по?ом?         | for that reason
+??ого          | genitive form of `this'
+какой          | which
+?ов?ем         | altogether
+ним            | prepositional form of `его', `они'
+зде??          | here
+??ом           | prepositional form of `??о?'
+один           | one
+по??и          | almost
+мой            | my
+?ем            | instrumental/dative plural of `?о?', `?о'
+??об?          | full form of `in order that'
+нее            | her (acc.)
+каже???        | it seems
+?ей?а?         | now
+б?ли           | they were
+к?да           | where to
+за?ем          | why
+?каза??        | to say
+в?е?           | all (acc., gen. preposn. plural)
+никогда        | never
+?егодн?        | today
+можно          | possible, one can
+п?и            | by
+наконе?        | finally
+два            | two
+об             | alternative form of `о', about
+д??гой         | another
+?о??           | even
+по?ле          | after
+над            | above
+бол??е         | more
+?о?            | that one (masc.)
+?е?ез          | across, in
+??и            | these
+на?            | us
+п?о            | about
+в?его          | in all, only, of all
+ни?            | prepositional form of `они' (they)
+кака?          | which, feminine
+много          | lots
+?азве          | interrogative particle
+?казала        | she said
+??и            | three
+???            | this, acc. fem. sing.
+мо?            | my, feminine
+вп?о?ем        | moreover, besides
+?о?о?о         | good
+?во?           | ones own, acc. fem. sing.
+??ой           | oblique form of `??а', fem. `this'
+пе?ед          | in front of
+иногда         | sometimes
+л???е          | better
+????           | a little
+?ом            | preposn. form of `that one'
+нел?з?         | one must not
+?акой          | such a one
+им             | to them
+более          | more
+в?егда         | always
+коне?но        | of course
+в??            | acc. fem. sing of `all'
+межд?          | between
+
+
+  | b: some paradigms
+  |
+  | personal pronouns
+  |
+  | ?  мен?  мне  мной  [мно?]
+  | ??  ?еб?  ?ебе  ?обой  [?обо?]
+  | он  его  ем?  им  [него, нем?, ним]
+  | она  ее  ?и  е?  [нее, н?и, не?]
+  | оно  его  ем?  им  [него, нем?, ним]
+  |
+  | м?  на?  нам  нами
+  | в?  ва?  вам  вами
+  | они  и?  им  ими  [ни?, ним, ними]
+  |
+  |   ?еб?  ?ебе  ?обой   [?обо?]
+  |
+  | demonstrative pronouns: ??о? (this), ?о? (that)
+  |
+  | ??о?  ??а  ??о  ??и
+  | ??ого  ???  ??о  ??и
+  | ??ого  ??ой  ??ого  ??и?
+  | ??ом?  ??ой  ??ом?  ??им
+  | ??им  ??ой  ??им  [??о?]  ??ими
+  | ??ом  ??ой  ??ом  ??и?
+  |
+  | ?о?  ?а  ?о  ?е
+  | ?ого  ??  ?о  ?е
+  | ?ого  ?ой  ?ого  ?е?
+  | ?ом?  ?ой  ?ом?  ?ем
+  | ?ем  ?ой  ?ем  [?о?]  ?еми
+  | ?ом  ?ой  ?ом  ?е?
+  |
+  | determinative pronouns
+  |
+  | (a) ве?? (all)
+  |
+  | ве??  в??  в?е  в?е
+  | в?его  в??  в?е  в?е
+  | в?его  в?ей  в?его  в?е?
+  | в?ем?  в?ей  в?ем?  в?ем
+  | в?ем  в?ей  в?ем  [в?е?]  в?еми
+  | в?ем  в?ей  в?ем  в?е?
+  |
+  | (b) ?ам (himself etc)
+  |
+  | ?ам  ?ама  ?амо  ?ами
+  | ?амого ?ам?  ?амо  ?ами?
+  | ?амого ?амой ?амого  ?ами?
+  | ?амом? ?амой ?амом?  ?амим
+  | ?амим  ?амой  ?амим  [?амо?]  ?амими
+  | ?амом ?амой ?амом  ?ами?
+  |
+  | stems of verbs `to be', `to have', `to do' and modal
+  |
+  | б???  б?  б?д  б?в  е???  ????
+  | име
+  | дел
+  | мог   мож  мо??
+  | ?ме
+  | ?о?  ?о?
+  | долж
+  | можн
+  | н?жн
+  | нел?з?
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/spanish_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/spanish_stop.txt
new file mode 100644
index 0000000..2db1476
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/spanish_stop.txt
@@ -0,0 +1,354 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/spanish/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Spanish stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+
+ | The following is a ranked list (commonest to rarest) of stopwords
+ | deriving from a large sample of text.
+
+ | Extra words have been added at the end.
+
+de             |  from, of
+la             |  the, her
+que            |  who, that
+el             |  the
+en             |  in
+y              |  and
+a              |  to
+los            |  the, them
+del            |  de + el
+se             |  himself, from him etc
+las            |  the, them
+por            |  for, by, etc
+un             |  a
+para           |  for
+con            |  with
+no             |  no
+una            |  a
+su             |  his, her
+al             |  a + el
+  | es         from SER
+lo             |  him
+como           |  how
+más            |  more
+pero           |  pero
+sus            |  su plural
+le             |  to him, her
+ya             |  already
+o              |  or
+  | fue        from SER
+este           |  this
+  | ha         from HABER
+sí             |  himself etc
+porque         |  because
+esta           |  this
+  | son        from SER
+entre          |  between
+  | está     from ESTAR
+cuando         |  when
+muy            |  very
+sin            |  without
+sobre          |  on
+  | ser        from SER
+  | tiene      from TENER
+también        |  also
+me             |  me
+hasta          |  until
+hay            |  there is/are
+donde          |  where
+  | han        from HABER
+quien          |  whom, that
+  | están      from ESTAR
+  | estado     from ESTAR
+desde          |  from
+todo           |  all
+nos            |  us
+durante        |  during
+  | estados    from ESTAR
+todos          |  all
+uno            |  a
+les            |  to them
+ni             |  nor
+contra         |  against
+otros          |  other
+  | fueron     from SER
+ese            |  that
+eso            |  that
+  | había      from HABER
+ante           |  before
+ellos          |  they
+e              |  and (variant of y)
+esto           |  this
+mí             |  me
+antes          |  before
+algunos        |  some
+qué            |  what?
+unos           |  a
+yo             |  I
+otro           |  other
+otras          |  other
+otra           |  other
+él             |  he
+tanto          |  so much, many
+esa            |  that
+estos          |  these
+mucho          |  much, many
+quienes        |  who
+nada           |  nothing
+muchos         |  many
+cual           |  who
+  | sea        from SER
+poco           |  few
+ella           |  she
+estar          |  to be
+  | haber      from HABER
+estas          |  these
+  | estaba     from ESTAR
+  | estamos    from ESTAR
+algunas        |  some
+algo           |  something
+nosotros       |  we
+
+      | other forms
+
+mi             |  me
+mis            |  mi plural
+tú             |  thou
+te             |  thee
+ti             |  thee
+tu             |  thy
+tus            |  tu plural
+ellas          |  they
+nosotras       |  we
+vosotros       |  you
+vosotras       |  you
+os             |  you
+mío            |  mine
+mía            |
+míos           |
+mías           |
+tuyo           |  thine
+tuya           |
+tuyos          |
+tuyas          |
+suyo           |  his, hers, theirs
+suya           |
+suyos          |
+suyas          |
+nuestro        |  ours
+nuestra        |
+nuestros       |
+nuestras       |
+vuestro        |  yours
+vuestra        |
+vuestros       |
+vuestras       |
+esos           |  those
+esas           |  those
+
+               | forms of estar, to be (not including the infinitive):
+estoy
+estás
+está
+estamos
+estáis
+están
+esté
+estés
+estemos
+estéis
+estén
+estaré
+estarás
+estará
+estaremos
+estaréis
+estarán
+estaría
+estarías
+estaríamos
+estaríais
+estarían
+estaba
+estabas
+estábamos
+estabais
+estaban
+estuve
+estuviste
+estuvo
+estuvimos
+estuvisteis
+estuvieron
+estuviera
+estuvieras
+estuviéramos
+estuvierais
+estuvieran
+estuviese
+estuvieses
+estuviésemos
+estuvieseis
+estuviesen
+estando
+estado
+estada
+estados
+estadas
+estad
+
+               | forms of haber, to have (not including the infinitive):
+he
+has
+ha
+hemos
+habéis
+han
+haya
+hayas
+hayamos
+hayáis
+hayan
+habré
+habrás
+habrá
+habremos
+habréis
+habrán
+habría
+habrías
+habríamos
+habríais
+habrían
+había
+habías
+habíamos
+habíais
+habían
+hube
+hubiste
+hubo
+hubimos
+hubisteis
+hubieron
+hubiera
+hubieras
+hubiéramos
+hubierais
+hubieran
+hubiese
+hubieses
+hubiésemos
+hubieseis
+hubiesen
+habiendo
+habido
+habida
+habidos
+habidas
+
+               | forms of ser, to be (not including the infinitive):
+soy
+eres
+es
+somos
+sois
+son
+sea
+seas
+seamos
+seáis
+sean
+seré
+serás
+será
+seremos
+seréis
+serán
+sería
+serías
+seríamos
+seríais
+serían
+era
+eras
+éramos
+erais
+eran
+fui
+fuiste
+fue
+fuimos
+fuisteis
+fueron
+fuera
+fueras
+fuéramos
+fuerais
+fueran
+fuese
+fueses
+fuésemos
+fueseis
+fuesen
+siendo
+sido
+  |  sed also means 'thirst'
+
+               | forms of tener, to have (not including the infinitive):
+tengo
+tienes
+tiene
+tenemos
+tenéis
+tienen
+tenga
+tengas
+tengamos
+tengáis
+tengan
+tendré
+tendrás
+tendrá
+tendremos
+tendréis
+tendrán
+tendría
+tendrías
+tendríamos
+tendríais
+tendrían
+tenía
+tenías
+teníamos
+teníais
+tenían
+tuve
+tuviste
+tuvo
+tuvimos
+tuvisteis
+tuvieron
+tuviera
+tuvieras
+tuviéramos
+tuvierais
+tuvieran
+tuviese
+tuvieses
+tuviésemos
+tuvieseis
+tuviesen
+teniendo
+tenido
+tenida
+tenidos
+tenidas
+tened
+
diff --git a/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/swedish_stop.txt b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/swedish_stop.txt
new file mode 100644
index 0000000..22bddfd
--- /dev/null
+++ b/contrib/snowball/src/resources/org/apache/lucene/analysis/snowball/swedish_stop.txt
@@ -0,0 +1,131 @@
+ | From svn.tartarus.org/snowball/trunk/website/algorithms/swedish/stop.txt
+ | This file is distributed under the BSD License.
+ | See http://snowball.tartarus.org/license.php
+ | Also see http://www.opensource.org/licenses/bsd-license.html
+ |  - Encoding was converted to UTF-8.
+ |  - This notice was added.
+
+ | A Swedish stop word list. Comments begin with vertical bar. Each stop
+ | word is at the start of a line.
+
+ | This is a ranked list (commonest to rarest) of stopwords derived from
+ | a large text sample.
+
+ | Swedish stop words occasionally exhibit homonym clashes. For example
+ |  så = so, but also seed. These are indicated clearly below.
+
+och            | and
+det            | it, this/that
+att            | to (with infinitive)
+i              | in, at
+en             | a
+jag            | I
+hon            | she
+som            | who, that
+han            | he
+på             | on
+den            | it, this/that
+med            | with
+var            | where, each
+sig            | him(self) etc
+för            | for
+så             | so (also: seed)
+till           | to
+är             | is
+men            | but
+ett            | a
+om             | if; around, about
+hade           | had
+de             | they, these/those
+av             | of
+icke           | not, no
+mig            | me
+du             | you
+henne          | her
+då             | then, when
+sin            | his
+nu             | now
+har            | have
+inte           | inte någon = no one
+hans           | his
+honom          | him
+skulle         | 'sake'
+hennes         | her
+där            | there
+min            | my
+man            | one (pronoun)
+ej             | nor
+vid            | at, by, on (also: vast)
+kunde          | could
+något          | some etc
+från           | from, off
+ut             | out
+när            | when
+efter          | after, behind
+upp            | up
+vi             | we
+dem            | them
+vara           | be
+vad            | what
+över           | over
+än             | than
+dig            | you
+kan            | can
+sina           | his
+här            | here
+ha             | have
+mot            | towards
+alla           | all
+under          | under (also: wonder)
+någon          | some etc
+eller          | or (else)
+allt           | all
+mycket         | much
+sedan          | since
+ju             | why
+denna          | this/that
+själv          | myself, yourself etc
+detta          | this/that
+åt             | to
+utan           | without
+varit          | was
+hur            | how
+ingen          | no
+mitt           | my
+ni             | you
+bli            | to be, become
+blev           | from bli
+oss            | us
+din            | thy
+dessa          | these/those
+några          | some etc
+deras          | their
+blir           | from bli
+mina           | my
+samma          | (the) same
+vilken         | who, that
+er             | you, your
+sådan          | such a
+vår            | our
+blivit         | from bli
+dess           | its
+inom           | within
+mellan         | between
+sådant         | such a
+varför         | why
+varje          | each
+vilka          | who, that
+ditt           | thy
+vem            | who
+vilket         | who, that
+sitta          | his
+sådana         | such a
+vart           | each
+dina           | thy
+vars           | whose
+vårt           | our
+våra           | our
+ert            | your
+era            | your
+vilkas         | whose
+
diff --git a/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowball.java b/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowball.java
new file mode 100644
index 0000000..d5c5f86
--- /dev/null
+++ b/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowball.java
@@ -0,0 +1,144 @@
+package org.apache.lucene.analysis.snowball;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.Payload;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.analysis.tokenattributes.FlagsAttribute;
+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
+import org.apache.lucene.util.Version;
+
+public class TestSnowball extends BaseTokenStreamTestCase {
+
+  public void testEnglish() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_CURRENT, "English");
+    assertAnalyzesTo(a, "he abhorred accents",
+        new String[]{"he", "abhor", "accent"});
+  }
+  
+  public void testStopwords() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_CURRENT, "English",
+        StandardAnalyzer.STOP_WORDS_SET);
+    assertAnalyzesTo(a, "the quick brown fox jumped",
+        new String[]{"quick", "brown", "fox", "jump"});
+  }
+
+  /**
+   * Test english lowercasing. Test both cases (pre-3.1 and post-3.1) to ensure
+   * we lowercase I correct for non-Turkish languages in either case.
+   */
+  public void testEnglishLowerCase() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_CURRENT, "English");
+    assertAnalyzesTo(a, "cryogenic", new String[] { "cryogen" });
+    assertAnalyzesTo(a, "CRYOGENIC", new String[] { "cryogen" });
+    
+    Analyzer b = new SnowballAnalyzer(Version.LUCENE_30, "English");
+    assertAnalyzesTo(b, "cryogenic", new String[] { "cryogen" });
+    assertAnalyzesTo(b, "CRYOGENIC", new String[] { "cryogen" });
+  }
+  
+  /**
+   * Test turkish lowercasing
+   */
+  public void testTurkish() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_CURRENT, "Turkish");
+
+    assertAnalyzesTo(a, "a?acı", new String[] { "a?aç" });
+    assertAnalyzesTo(a, "A?ACI", new String[] { "a?aç" });
+  }
+  
+  /**
+   * Test turkish lowercasing (old buggy behavior)
+   * @deprecated Remove this when support for 3.0 indexes is no longer required
+   */
+  public void testTurkishBWComp() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_30, "Turkish");
+    // A?ACI in turkish lowercases to a?acı, but with lowercase filter a?aci.
+    // this fails due to wrong casing, because the stemmer
+    // will only remove -ı, not -i
+    assertAnalyzesTo(a, "a?acı", new String[] { "a?aç" });
+    assertAnalyzesTo(a, "A?ACI", new String[] { "a?aci" });
+  }
+
+  
+  public void testReusableTokenStream() throws Exception {
+    Analyzer a = new SnowballAnalyzer(Version.LUCENE_CURRENT, "English");
+    assertAnalyzesToReuse(a, "he abhorred accents",
+        new String[]{"he", "abhor", "accent"});
+    assertAnalyzesToReuse(a, "she abhorred him",
+        new String[]{"she", "abhor", "him"});
+  }
+  
+  public void testFilterTokens() throws Exception {
+    SnowballFilter filter = new SnowballFilter(new TestTokenStream(), "English");
+    TermAttribute termAtt = filter.getAttribute(TermAttribute.class);
+    OffsetAttribute offsetAtt = filter.getAttribute(OffsetAttribute.class);
+    TypeAttribute typeAtt = filter.getAttribute(TypeAttribute.class);
+    PayloadAttribute payloadAtt = filter.getAttribute(PayloadAttribute.class);
+    PositionIncrementAttribute posIncAtt = filter.getAttribute(PositionIncrementAttribute.class);
+    FlagsAttribute flagsAtt = filter.getAttribute(FlagsAttribute.class);
+    
+    filter.incrementToken();
+
+    assertEquals("accent", termAtt.term());
+    assertEquals(2, offsetAtt.startOffset());
+    assertEquals(7, offsetAtt.endOffset());
+    assertEquals("wrd", typeAtt.type());
+    assertEquals(3, posIncAtt.getPositionIncrement());
+    assertEquals(77, flagsAtt.getFlags());
+    assertEquals(new Payload(new byte[]{0,1,2,3}), payloadAtt.getPayload());
+  }
+  
+  private final class TestTokenStream extends TokenStream {
+    private TermAttribute termAtt;
+    private OffsetAttribute offsetAtt;
+    private TypeAttribute typeAtt;
+    private PayloadAttribute payloadAtt;
+    private PositionIncrementAttribute posIncAtt;
+    private FlagsAttribute flagsAtt;
+    
+    TestTokenStream() {
+      super();
+      termAtt = addAttribute(TermAttribute.class);
+      offsetAtt = addAttribute(OffsetAttribute.class);
+      typeAtt = addAttribute(TypeAttribute.class);
+      payloadAtt = addAttribute(PayloadAttribute.class);
+      posIncAtt = addAttribute(PositionIncrementAttribute.class);
+      flagsAtt = addAttribute(FlagsAttribute.class);
+    }
+    
+    @Override
+    public boolean incrementToken() {
+      clearAttributes();
+      termAtt.setTermBuffer("accents");
+      offsetAtt.setOffset(2, 7);
+      typeAtt.setType("wrd");
+      posIncAtt.setPositionIncrement(3);
+      payloadAtt.setPayload(new Payload(new byte[]{0,1,2,3}));
+      flagsAtt.setFlags(77);
+      return true;
+    }
+  }
+}
\ No newline at end of file
diff --git a/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowballVocab.java b/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowballVocab.java
new file mode 100644
index 0000000..b349e77
--- /dev/null
+++ b/contrib/snowball/src/test/org/apache/lucene/analysis/snowball/TestSnowballVocab.java
@@ -0,0 +1,102 @@
+package org.apache.lucene.analysis.snowball;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringReader;
+
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.analysis.KeywordTokenizer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+
+/**
+ * Test the snowball filters against the snowball data tests
+ */
+public class TestSnowballVocab extends BaseTokenStreamTestCase {
+  private Tokenizer tokenizer = new KeywordTokenizer(new StringReader(""));
+  static final File dataDir = new File(System.getProperty("dataDir", "./bin"));
+  static final File dataRoot = new File(dataDir, 
+      "org/apache/lucene/analysis/snowball/data");
+  
+  /**
+   * Run all languages against their snowball vocabulary tests.
+   */
+  public void testStemmers() throws IOException {
+    if (!dataRoot.exists()) {
+      System.err.println("WARN: This test was disabled, as the svn checkout of snowball test files is not supported on your system!");
+      return;
+    }
+    assertCorrectOutput("Danish", "danish");
+    assertCorrectOutput("Dutch", "dutch");
+    assertCorrectOutput("English", "english");
+    // disabled due to snowball java code generation bug: 
+    // see http://article.gmane.org/gmane.comp.search.snowball/1139
+    // assertCorrectOutput("Finnish", "finnish");
+    assertCorrectOutput("French", "french");
+    assertCorrectOutput("German", "german");
+    assertCorrectOutput("German2", "german2");
+    assertCorrectOutput("Hungarian", "hungarian");
+    assertCorrectOutput("Italian", "italian");
+    assertCorrectOutput("Kp", "kraaij_pohlmann");
+    // disabled due to snowball java code generation bug: 
+    // see http://article.gmane.org/gmane.comp.search.snowball/1139
+    // assertCorrectOutput("Lovins", "lovins");
+    assertCorrectOutput("Norwegian", "norwegian");
+    assertCorrectOutput("Porter", "porter");
+    assertCorrectOutput("Portuguese", "portuguese");
+    assertCorrectOutput("Romanian", "romanian");
+    assertCorrectOutput("Russian", "russian");
+    assertCorrectOutput("Spanish", "spanish");
+    assertCorrectOutput("Swedish", "swedish");
+    assertCorrectOutput("Turkish", "turkish");
+  }
+    
+  /**
+   * For the supplied language, run the stemmer against all strings in voc.txt
+   * The output should be the same as the string in output.txt
+   */
+  private void assertCorrectOutput(String snowballLanguage, String dataDirectory)
+      throws IOException {
+    System.err.println("checking snowball language: " + snowballLanguage);
+    TokenStream filter = new SnowballFilter(tokenizer, snowballLanguage);
+    InputStream vocFile = new FileInputStream(new File(dataRoot, 
+        dataDirectory + "/voc.txt"));
+    InputStream outputFile = new FileInputStream(new File(dataRoot, 
+        dataDirectory + "/output.txt"));
+    BufferedReader vocReader = new BufferedReader(new InputStreamReader(
+        vocFile, "UTF-8"));
+    BufferedReader outputReader = new BufferedReader(new InputStreamReader(
+        outputFile, "UTF-8"));
+    String inputWord = null;
+    while ((inputWord = vocReader.readLine()) != null) {
+      String expectedWord = outputReader.readLine();
+      assertNotNull(expectedWord);
+      tokenizer.reset(new StringReader(inputWord));
+      filter.reset();
+      assertTokenStreamContents(filter, new String[] {expectedWord});
+    }
+    vocReader.close();
+    outputReader.close();
+  }
+}
diff --git a/contrib/snowball/xdocs/index.xml b/contrib/snowball/xdocs/index.xml
new file mode 100644
index 0000000..42bede1
--- /dev/null
+++ b/contrib/snowball/xdocs/index.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0"?>
+<document>
+<properties>
+<title>Overview - Snowball Stemmers for Lucene</title>
+</properties>
+<body>
+
+<section name="Snowball Stemmers for Lucene">
+<p>
+This project provides pre-compiled version of the Snowball stemmers
+together with classes integrating them with the Lucene search engine.
+</p>
+</section>
+
+</body>
+</document>
+
diff --git a/contrib/snowball/xdocs/stylesheets/project.xml b/contrib/snowball/xdocs/stylesheets/project.xml
new file mode 100644
index 0000000..d55ef7c
--- /dev/null
+++ b/contrib/snowball/xdocs/stylesheets/project.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<project name="Snowball Stemers for Lucene"
+         href="http://jakarta.apache.org/lucene-sandbox/snowball/">
+
+    <title>Snowball Stemmers for Lucene</title>
+
+    <body>
+    <menu name="Documentation">
+        <item name="Javadoc"           href="/api/index.html"/>
+    </menu>
+
+    <menu name="Download">
+        <item name="Releases"
+              href="http://jakarta.apache.org/builds/jakarta-lucene-sandbox/snowball/"/>
+        <item name="CVS Repository"   href="/site/cvsindex.html"/>
+    </menu>
+
+    <menu name="Links">
+        <item name="Snowball Home" href="http://snowball.tartarus.org/"/>
+        <item name="Lucene Home" href="http://jakarta.apache.org/lucene/"/>
+        <item name="Lucene Sandbox"
+              href="http://jakarta.apache.org/lucene/docs/lucene-sandbox/"/>
+    </menu>
+
+    <menu name="Jakarta">
+        <item name="Get Involved"          href="/site/getinvolved.html"/>
+        <item name="Acknowledgements"      href="/site/acknowledgements.html"/>
+        <item name="Contact"               href="/site/contact.html"/>
+        <item name="Legal"                 href="/site/legal.html"/>
+    </menu>
+    </body>
+</project>
diff --git a/src/java/org/apache/lucene/analysis/ASCIIFoldingFilter.java b/src/java/org/apache/lucene/analysis/ASCIIFoldingFilter.java
index d3201af..abacbe4 100644
--- a/src/java/org/apache/lucene/analysis/ASCIIFoldingFilter.java
+++ b/src/java/org/apache/lucene/analysis/ASCIIFoldingFilter.java
@@ -1,10 +1,5 @@
 package org.apache.lucene.analysis;
 
-import java.io.IOException;
-
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
-import org.apache.lucene.util.ArrayUtil;
-
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -22,6 +17,12 @@ import org.apache.lucene.util.ArrayUtil;
  * limitations under the License.
  */
 
+import java.io.IOException;
+
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
+
 /**
  * This class converts alphabetic, numeric, and symbolic Unicode characters
  * which are not in the first 127 ASCII characters (the "Basic Latin" Unicode
@@ -101,7 +102,7 @@ public final class ASCIIFoldingFilter extends TokenFilter {
     // Worst-case length required:
     final int maxSizeNeeded = 4 * length;
     if (output.length < maxSizeNeeded) {
-      output = new char[ArrayUtil.getNextSize(maxSizeNeeded)];
+      output = new char[ArrayUtil.oversize(maxSizeNeeded, RamUsageEstimator.NUM_BYTES_CHAR)];
     }
 
     outputPos = 0;
diff --git a/src/java/org/apache/lucene/analysis/Token.java b/src/java/org/apache/lucene/analysis/Token.java
index f1888de..d51fdd8 100644
--- a/src/java/org/apache/lucene/analysis/Token.java
+++ b/src/java/org/apache/lucene/analysis/Token.java
@@ -29,6 +29,7 @@ import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Attribute;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /** 
   A Token is an occurrence of a term from the text of a field.  It consists of
@@ -347,12 +348,12 @@ public class Token extends AttributeImpl
   public char[] resizeTermBuffer(int newSize) {
     if (termBuffer == null) {
       // The buffer is always at least MIN_BUFFER_SIZE
-      termBuffer = new char[ArrayUtil.getNextSize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize)]; 
+      termBuffer = new char[ArrayUtil.oversize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize, RamUsageEstimator.NUM_BYTES_CHAR)]; 
     } else {
       if(termBuffer.length < newSize){
         // Not big enough; create a new array with slight
         // over allocation and preserve content
-        final char[] newCharBuffer = new char[ArrayUtil.getNextSize(newSize)];
+        final char[] newCharBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];
         System.arraycopy(termBuffer, 0, newCharBuffer, 0, termBuffer.length);
         termBuffer = newCharBuffer;
       }
@@ -367,19 +368,19 @@ public class Token extends AttributeImpl
   private void growTermBuffer(int newSize) {
     if (termBuffer == null) {
       // The buffer is always at least MIN_BUFFER_SIZE    
-      termBuffer = new char[ArrayUtil.getNextSize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize)];   
+      termBuffer = new char[ArrayUtil.oversize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize, RamUsageEstimator.NUM_BYTES_CHAR)];
     } else {
       if(termBuffer.length < newSize){
         // Not big enough; create a new array with slight
         // over allocation:
-        termBuffer = new char[ArrayUtil.getNextSize(newSize)];
+        termBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];
       }
     } 
   }
   
   private void initTermBuffer() {
     if (termBuffer == null) {
-      termBuffer = new char[ArrayUtil.getNextSize(MIN_BUFFER_SIZE)];
+      termBuffer = new char[ArrayUtil.oversize(MIN_BUFFER_SIZE, RamUsageEstimator.NUM_BYTES_CHAR)];
       termLength = 0;
     }
   }
diff --git a/src/java/org/apache/lucene/analysis/tokenattributes/TermAttributeImpl.java b/src/java/org/apache/lucene/analysis/tokenattributes/TermAttributeImpl.java
index 5720ecb..ec24be7 100644
--- a/src/java/org/apache/lucene/analysis/tokenattributes/TermAttributeImpl.java
+++ b/src/java/org/apache/lucene/analysis/tokenattributes/TermAttributeImpl.java
@@ -21,6 +21,7 @@ import java.io.Serializable;
 
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * The term text of a Token.
@@ -106,12 +107,12 @@ public class TermAttributeImpl extends AttributeImpl implements TermAttribute, C
   public char[] resizeTermBuffer(int newSize) {
     if (termBuffer == null) {
       // The buffer is always at least MIN_BUFFER_SIZE
-      termBuffer = new char[ArrayUtil.getNextSize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize)]; 
+      termBuffer = new char[ArrayUtil.oversize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize, RamUsageEstimator.NUM_BYTES_CHAR)]; 
     } else {
       if(termBuffer.length < newSize){
         // Not big enough; create a new array with slight
         // over allocation and preserve content
-        final char[] newCharBuffer = new char[ArrayUtil.getNextSize(newSize)];
+        final char[] newCharBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];
         System.arraycopy(termBuffer, 0, newCharBuffer, 0, termBuffer.length);
         termBuffer = newCharBuffer;
       }
@@ -127,19 +128,19 @@ public class TermAttributeImpl extends AttributeImpl implements TermAttribute, C
   private void growTermBuffer(int newSize) {
     if (termBuffer == null) {
       // The buffer is always at least MIN_BUFFER_SIZE
-      termBuffer = new char[ArrayUtil.getNextSize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize)];   
+      termBuffer = new char[ArrayUtil.oversize(newSize < MIN_BUFFER_SIZE ? MIN_BUFFER_SIZE : newSize, RamUsageEstimator.NUM_BYTES_CHAR)];   
     } else {
       if(termBuffer.length < newSize){
         // Not big enough; create a new array with slight
         // over allocation:
-        termBuffer = new char[ArrayUtil.getNextSize(newSize)];
+        termBuffer = new char[ArrayUtil.oversize(newSize, RamUsageEstimator.NUM_BYTES_CHAR)];
       }
     } 
   }
   
   private void initTermBuffer() {
     if (termBuffer == null) {
-      termBuffer = new char[ArrayUtil.getNextSize(MIN_BUFFER_SIZE)];
+      termBuffer = new char[ArrayUtil.oversize(MIN_BUFFER_SIZE, RamUsageEstimator.NUM_BYTES_CHAR)];
       termLength = 0;
     }
   }
diff --git a/src/java/org/apache/lucene/index/DocFieldConsumers.java b/src/java/org/apache/lucene/index/DocFieldConsumers.java
index 95b03b3..bccbf2c 100644
--- a/src/java/org/apache/lucene/index/DocFieldConsumers.java
+++ b/src/java/org/apache/lucene/index/DocFieldConsumers.java
@@ -25,6 +25,7 @@ import java.util.HashSet;
 import java.io.IOException;
 
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /** This is just a "splitter" class: it lets you wrap two
  *  DocFieldConsumer instances as a single consumer. */
@@ -117,7 +118,7 @@ final class DocFieldConsumers extends DocFieldConsumer {
         // enough space to recycle all outstanding PerDoc
         // instances
         assert allocCount == 1+docFreeList.length;
-        docFreeList = new PerDoc[ArrayUtil.getNextSize(allocCount)];
+        docFreeList = new PerDoc[ArrayUtil.oversize(allocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
       }
       return new PerDoc();
     } else
diff --git a/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java b/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java
index 31e2ae1..7f372a8 100644
--- a/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java
+++ b/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java
@@ -24,6 +24,7 @@ import java.io.IOException;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * Gathers all Fieldables for a document under the same
@@ -340,7 +341,7 @@ final class DocFieldProcessorPerThread extends DocConsumerPerThread {
         // enough space to recycle all outstanding PerDoc
         // instances
         assert allocCount == 1+docFreeList.length;
-        docFreeList = new PerDoc[ArrayUtil.getNextSize(allocCount)];
+        docFreeList = new PerDoc[ArrayUtil.oversize(allocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
       }
       return new PerDoc();
     } else
diff --git a/src/java/org/apache/lucene/index/DocumentsWriter.java b/src/java/org/apache/lucene/index/DocumentsWriter.java
index 8a7525c..660105a 100644
--- a/src/java/org/apache/lucene/index/DocumentsWriter.java
+++ b/src/java/org/apache/lucene/index/DocumentsWriter.java
@@ -40,6 +40,7 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.ThreadInterruptedException;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * This class accepts multiple added documents and directly
@@ -1503,7 +1504,7 @@ final class DocumentsWriter {
         int gap = doc.docID - nextWriteDocID;
         if (gap >= waiting.length) {
           // Grow queue
-          DocWriter[] newArray = new DocWriter[ArrayUtil.getNextSize(gap)];
+          DocWriter[] newArray = new DocWriter[ArrayUtil.oversize(gap, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
           assert nextWriteLoc >= 0;
           System.arraycopy(waiting, nextWriteLoc, newArray, 0, waiting.length-nextWriteLoc);
           System.arraycopy(waiting, 0, newArray, waiting.length-nextWriteLoc, nextWriteLoc);
diff --git a/src/java/org/apache/lucene/index/FormatPostingsTermsConsumer.java b/src/java/org/apache/lucene/index/FormatPostingsTermsConsumer.java
index 705b63f..d220e15 100644
--- a/src/java/org/apache/lucene/index/FormatPostingsTermsConsumer.java
+++ b/src/java/org/apache/lucene/index/FormatPostingsTermsConsumer.java
@@ -20,6 +20,7 @@ package org.apache.lucene.index;
 import java.io.IOException;
 
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * NOTE: this API is experimental and will likely change
@@ -35,7 +36,7 @@ abstract class FormatPostingsTermsConsumer {
   FormatPostingsDocsConsumer addTerm(String text) throws IOException {
     final int len = text.length();
     if (termBuffer == null || termBuffer.length < 1+len)
-      termBuffer = new char[ArrayUtil.getNextSize(1+len)];
+      termBuffer = new char[ArrayUtil.oversize(1+len, RamUsageEstimator.NUM_BYTES_CHAR)];
     text.getChars(0, len, termBuffer, 0);
     termBuffer[len] = 0xffff;
     return addTerm(termBuffer, 0);
diff --git a/src/java/org/apache/lucene/index/NormsWriterPerField.java b/src/java/org/apache/lucene/index/NormsWriterPerField.java
index 959e727..c2b331d 100644
--- a/src/java/org/apache/lucene/index/NormsWriterPerField.java
+++ b/src/java/org/apache/lucene/index/NormsWriterPerField.java
@@ -63,11 +63,13 @@ final class NormsWriterPerField extends InvertedDocEndConsumerPerField implement
   
   @Override
   void finish() {
-    assert docIDs.length == norms.length;
     if (fieldInfo.isIndexed && !fieldInfo.omitNorms) {
       if (docIDs.length <= upto) {
         assert docIDs.length == upto;
         docIDs = ArrayUtil.grow(docIDs, 1+upto);
+      }
+      if (norms.length <= upto) {
+        assert norms.length == upto;
         norms = ArrayUtil.grow(norms, 1+upto);
       }
       final float norm = docState.similarity.computeNorm(fieldInfo.name, fieldState);
diff --git a/src/java/org/apache/lucene/index/StoredFieldsWriter.java b/src/java/org/apache/lucene/index/StoredFieldsWriter.java
index a79659e..e817e2e 100644
--- a/src/java/org/apache/lucene/index/StoredFieldsWriter.java
+++ b/src/java/org/apache/lucene/index/StoredFieldsWriter.java
@@ -20,6 +20,7 @@ package org.apache.lucene.index;
 import java.io.IOException;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /** This is a DocFieldConsumer that writes stored fields. */
 final class StoredFieldsWriter {
@@ -108,7 +109,7 @@ final class StoredFieldsWriter {
         // enough space to recycle all outstanding PerDoc
         // instances
         assert allocCount == 1+docFreeList.length;
-        docFreeList = new PerDoc[ArrayUtil.getNextSize(allocCount)];
+        docFreeList = new PerDoc[ArrayUtil.oversize(allocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
       }
       return new PerDoc();
     } else
diff --git a/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java b/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java
index e5981e0..ea38788 100644
--- a/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java
+++ b/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java
@@ -20,6 +20,7 @@ package org.apache.lucene.index;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 import java.io.IOException;
 import java.util.Collection;
@@ -117,7 +118,7 @@ final class TermVectorsTermsWriter extends TermsHashConsumer {
         // enough space to recycle all outstanding PerDoc
         // instances
         assert allocCount == 1+docFreeList.length;
-        docFreeList = new PerDoc[ArrayUtil.getNextSize(allocCount)];
+        docFreeList = new PerDoc[ArrayUtil.oversize(allocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
       }
       return new PerDoc();
     } else
@@ -266,6 +267,8 @@ final class TermVectorsTermsWriter extends TermsHashConsumer {
     void addField(final int fieldNumber) {
       if (numVectorFields == fieldNumbers.length) {
         fieldNumbers = ArrayUtil.grow(fieldNumbers);
+      }
+      if (numVectorFields == fieldPointers.length) {
         fieldPointers = ArrayUtil.grow(fieldPointers);
       }
       fieldNumbers[numVectorFields] = fieldNumber;
diff --git a/src/java/org/apache/lucene/index/TermsHash.java b/src/java/org/apache/lucene/index/TermsHash.java
index bec1474..74fc2d0 100644
--- a/src/java/org/apache/lucene/index/TermsHash.java
+++ b/src/java/org/apache/lucene/index/TermsHash.java
@@ -26,6 +26,7 @@ import java.util.Arrays;
 import java.io.IOException;
 
 import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /** This class implements {@link InvertedDocConsumer}, which
  *  is passed each token produced by the analyzer on each
@@ -89,7 +90,7 @@ final class TermsHash extends InvertedDocConsumer {
 
     assert postingsFreeCount == postingsAllocCount: Thread.currentThread().getName() + ": postingsFreeCount=" + postingsFreeCount + " postingsAllocCount=" + postingsAllocCount + " consumer=" + consumer;
 
-    final int newSize = ArrayUtil.getShrinkSize(postingsFreeList.length, postingsAllocCount);
+    final int newSize = ArrayUtil.getShrinkSize(postingsFreeList.length, postingsAllocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
     if (newSize != postingsFreeList.length) {
       RawPostingList[] newArray = new RawPostingList[newSize];
       System.arraycopy(postingsFreeList, 0, newArray, 0, postingsFreeCount);
@@ -222,7 +223,7 @@ final class TermsHash extends InvertedDocConsumer {
       if (newPostingsAllocCount > postingsFreeList.length)
         // Pre-allocate the postingsFreeList so it's large
         // enough to hold all postings we've given out
-        postingsFreeList = new RawPostingList[ArrayUtil.getNextSize(newPostingsAllocCount)];
+        postingsFreeList = new RawPostingList[ArrayUtil.oversize(newPostingsAllocCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
     }
 
     postingsFreeCount -= numToCopy;
diff --git a/src/java/org/apache/lucene/util/ArrayUtil.java b/src/java/org/apache/lucene/util/ArrayUtil.java
index 191973e..086c31a 100644
--- a/src/java/org/apache/lucene/util/ArrayUtil.java
+++ b/src/java/org/apache/lucene/util/ArrayUtil.java
@@ -7,9 +7,9 @@ package org.apache.lucene.util;
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * <p/>
- * http://www.apache.org/licenses/LICENSE-2.0
- * <p/>
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -122,20 +122,95 @@ public final class ArrayUtil {
  END APACHE HARMONY CODE
   */
 
+  /** Returns an array size >= minTargetSize, generally
+   *  over-allocating exponentially to achieve amortized
+   *  linear-time cost as the array grows.
+   *
+   *  NOTE: this was originally borrowed from Python 2.4.2
+   *  listobject.c sources (attribution in LICENSE.txt), but
+   *  has now been substantially changed based on
+   *  discussions from java-dev thread with subject "Dynamic
+   *  array reallocation algorithms", started on Jan 12
+   *  2010.
+   *
+   * @param minTargetSize Minimum required value to be returned.
+   * @param bytesPerElement Bytes used by each element of
+   * the array.  See constants in {@link RamUsageEstimator}.
+   *
+   * @lucene.internal
+   */
+
+  public static int oversize(int minTargetSize, int bytesPerElement) {
+
+    if (minTargetSize < 0) {
+      // catch usage that accidentally overflows int
+      throw new IllegalArgumentException("invalid array size " + minTargetSize);
+    }
+
+    if (minTargetSize == 0) {
+      // wait until at least one element is requested
+      return 0;
+    }
 
-  public static int getNextSize(int targetSize) {
-    /* This over-allocates proportional to the list size, making room
-     * for additional growth.  The over-allocation is mild, but is
-     * enough to give linear-time amortized behavior over a long
-     * sequence of appends() in the presence of a poorly-performing
-     * system realloc().
-     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
-     */
-    return (targetSize >> 3) + (targetSize < 9 ? 3 : 6) + targetSize;
+    // asymptotic exponential growth by 1/8th, favors
+    // spending a bit more CPU to not tye up too much wasted
+    // RAM:
+    int extra = minTargetSize >> 3;
+
+    if (extra < 3) {
+      // for very small arrays, where constant overhead of
+      // realloc is presumably relatively high, we grow
+      // faster
+      extra = 3;
+    }
+
+    int newSize = minTargetSize + extra;
+
+    // add 7 to allow for worst case byte alignment addition below:
+    if (newSize+7 < 0) {
+      // int overflowed -- return max allowed array size
+      return Integer.MAX_VALUE;
+    }
+
+    if (Constants.JRE_IS_64BIT) {
+      // round up to 8 byte alignment in 64bit env
+      switch(bytesPerElement) {
+      case 4:
+        // round up to multiple of 2
+        return (newSize + 1) & 0x7ffffffe;
+      case 2:
+        // round up to multiple of 4
+        return (newSize + 3) & 0x7ffffffc;
+      case 1:
+        // round up to multiple of 8
+        return (newSize + 7) & 0x7ffffff8;
+      case 8:
+        // no rounding
+      default:
+        // odd (invalid?) size
+        return newSize;
+      }
+    } else {
+      // round up to 4 byte alignment in 64bit env
+      switch(bytesPerElement) {
+      case 2:
+        // round up to multiple of 2
+        return (newSize + 1) & 0x7ffffffe;
+      case 1:
+        // round up to multiple of 4
+        return (newSize + 3) & 0x7ffffffc;
+      case 4:
+      case 8:
+        // no rounding
+      default:
+        // odd (invalid?) size
+        return newSize;
+      }
+    }
   }
 
-  public static int getShrinkSize(int currentSize, int targetSize) {
-    final int newSize = getNextSize(targetSize);
+  public static int getShrinkSize(int currentSize, int targetSize, int bytesPerElement) {
+    final int newSize = oversize(targetSize, bytesPerElement);
     // Only reallocate if we are "substantially" smaller.
     // This saves us from "running hot" (constantly making a
     // bit bigger then a bit smaller, over and over):
@@ -147,7 +222,7 @@ public final class ArrayUtil {
 
   public static int[] grow(int[] array, int minSize) {
     if (array.length < minSize) {
-      int[] newArray = new int[getNextSize(minSize)];
+      int[] newArray = new int[oversize(minSize, RamUsageEstimator.NUM_BYTES_INT)];
       System.arraycopy(array, 0, newArray, 0, array.length);
       return newArray;
     } else
@@ -159,7 +234,7 @@ public final class ArrayUtil {
   }
 
   public static int[] shrink(int[] array, int targetSize) {
-    final int newSize = getShrinkSize(array.length, targetSize);
+    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_INT);
     if (newSize != array.length) {
       int[] newArray = new int[newSize];
       System.arraycopy(array, 0, newArray, 0, newSize);
@@ -170,7 +245,7 @@ public final class ArrayUtil {
 
   public static long[] grow(long[] array, int minSize) {
     if (array.length < minSize) {
-      long[] newArray = new long[getNextSize(minSize)];
+      long[] newArray = new long[oversize(minSize, RamUsageEstimator.NUM_BYTES_LONG)];
       System.arraycopy(array, 0, newArray, 0, array.length);
       return newArray;
     } else
@@ -182,7 +257,7 @@ public final class ArrayUtil {
   }
 
   public static long[] shrink(long[] array, int targetSize) {
-    final int newSize = getShrinkSize(array.length, targetSize);
+    final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_LONG);
     if (newSize != array.length) {
       long[] newArray = new long[newSize];
       System.arraycopy(array, 0, newArray, 0, newSize);
@@ -193,7 +268,7 @@ public final class ArrayUtil {
 
   public static byte[] grow(byte[] array, int minSize) {
     if (array.length < minSize) {
-      byte[] newArray = new byte[getNextSize(minSize)];
+      byte[] newArray = new byte[oversize(minSize, 1)];
       System.arraycopy(array, 0, newArray, 0, array.length);
       return newArray;
     } else
@@ -205,7 +280,7 @@ public final class ArrayUtil {
   }
 
   public static byte[] shrink(byte[] array, int targetSize) {
-    final int newSize = getShrinkSize(array.length, targetSize);
+    final int newSize = getShrinkSize(array.length, targetSize, 1);
     if (newSize != array.length) {
       byte[] newArray = new byte[newSize];
       System.arraycopy(array, 0, newArray, 0, newSize);
diff --git a/src/java/org/apache/lucene/util/RamUsageEstimator.java b/src/java/org/apache/lucene/util/RamUsageEstimator.java
index c3e254a..a0e2c79 100644
--- a/src/java/org/apache/lucene/util/RamUsageEstimator.java
+++ b/src/java/org/apache/lucene/util/RamUsageEstimator.java
@@ -43,6 +43,14 @@ public final class RamUsageEstimator {
   private int arraySize;
   private int classSize;
 
+  public final static int NUM_BYTES_OBJECT_REF = Constants.JRE_IS_64BIT ? 8 : 4;
+  public final static int NUM_BYTES_CHAR = 2;
+  public final static int NUM_BYTES_SHORT = 2;
+  public final static int NUM_BYTES_INT = 4;
+  public final static int NUM_BYTES_LONG = 8;
+  public final static int NUM_BYTES_FLOAT = 4;
+  public final static int NUM_BYTES_DOUBLE = 8;
+
   private boolean checkInterned;
 
   /**
diff --git a/src/test/org/apache/lucene/analysis/TestToken.java b/src/test/org/apache/lucene/analysis/TestToken.java
index 6aad728..1552f70 100644
--- a/src/test/org/apache/lucene/analysis/TestToken.java
+++ b/src/test/org/apache/lucene/analysis/TestToken.java
@@ -85,7 +85,6 @@ public class TestToken extends LuceneTestCase {
       buf.append(buf.toString());
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, first variant
     t = new Token();
@@ -99,7 +98,6 @@ public class TestToken extends LuceneTestCase {
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, second variant
     t = new Token();
@@ -113,7 +111,6 @@ public class TestToken extends LuceneTestCase {
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new Token();
@@ -127,7 +124,6 @@ public class TestToken extends LuceneTestCase {
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new Token();
@@ -141,7 +137,6 @@ public class TestToken extends LuceneTestCase {
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
   }
 
   public void testToString() throws Exception {
diff --git a/src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java b/src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java
index e787f6e..678a5ca 100644
--- a/src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java
+++ b/src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java
@@ -49,7 +49,6 @@ public class TestTermAttributeImpl extends LuceneTestCase {
       buf.append(buf.toString());
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, first variant
     t = new TermAttributeImpl();
@@ -63,7 +62,6 @@ public class TestTermAttributeImpl extends LuceneTestCase {
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, second variant
     t = new TermAttributeImpl();
@@ -77,7 +75,6 @@ public class TestTermAttributeImpl extends LuceneTestCase {
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new TermAttributeImpl();
@@ -91,7 +88,6 @@ public class TestTermAttributeImpl extends LuceneTestCase {
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new TermAttributeImpl();
@@ -105,7 +101,6 @@ public class TestTermAttributeImpl extends LuceneTestCase {
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
   }
 
   public void testToString() throws Exception {
diff --git a/src/test/org/apache/lucene/util/TestArrayUtil.java b/src/test/org/apache/lucene/util/TestArrayUtil.java
new file mode 100644
index 0000000..abae54a
--- /dev/null
+++ b/src/test/org/apache/lucene/util/TestArrayUtil.java
@@ -0,0 +1,59 @@
+package org.apache.lucene.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Random;
+
+public class TestArrayUtil extends LuceneTestCase {
+
+  // Ensure ArrayUtil.getNextSize gives linear amortized cost of realloc/copy
+  public void testGrowth() {
+    int currentSize = 0;
+    long copyCost = 0;
+
+    // Make sure ArrayUtil hits Integer.MAX_VALUE, if we insist:
+    while(currentSize != Integer.MAX_VALUE) {
+      int nextSize = ArrayUtil.oversize(1+currentSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
+      assertTrue(nextSize > currentSize);
+      if (currentSize > 0) {
+        copyCost += currentSize;
+        double copyCostPerElement = ((double) copyCost)/currentSize;
+        assertTrue("cost " + copyCostPerElement, copyCostPerElement < 10.0);
+      }
+      currentSize = nextSize;
+    }
+  }
+
+  public void testMaxSize() {
+    // intentionally pass invalid elemSizes:
+    for(int elemSize=0;elemSize<10;elemSize++) {
+      assertEquals(Integer.MAX_VALUE, ArrayUtil.oversize(Integer.MAX_VALUE, elemSize));
+      assertEquals(Integer.MAX_VALUE, ArrayUtil.oversize(Integer.MAX_VALUE-1, elemSize));
+    }
+  }
+
+  public void testInvalidElementSizes() {
+    final Random r = newRandom();
+    for(int iter=0;iter<10000;iter++) {
+      final int minTargetSize = r.nextInt(Integer.MAX_VALUE);
+      final int elemSize = r.nextInt(11);
+      final int v = ArrayUtil.oversize(minTargetSize, elemSize);
+      assertTrue(v >= minTargetSize);
+    }
+  }
+}
diff --git a/src/test/org/apache/lucene/util/TestIndexableBinaryStringTools.java b/src/test/org/apache/lucene/util/TestIndexableBinaryStringTools.java
index e1eaed2..37c19a7 100644
--- a/src/test/org/apache/lucene/util/TestIndexableBinaryStringTools.java
+++ b/src/test/org/apache/lucene/util/TestIndexableBinaryStringTools.java
@@ -164,14 +164,14 @@ public class TestIndexableBinaryStringTools extends LuceneTestCase {
       int encodedLen1 = IndexableBinaryStringTools.getEncodedLength(
           originalArray1, 0, numBytes1);
       if (encodedLen1 > encoded1.length)
-        encoded1 = new char[ArrayUtil.getNextSize(encodedLen1)];
+        encoded1 = new char[ArrayUtil.oversize(encodedLen1, RamUsageEstimator.NUM_BYTES_CHAR)];
       IndexableBinaryStringTools.encode(originalArray1, 0, numBytes1, encoded1,
           0, encodedLen1);
 
       int encodedLen2 = IndexableBinaryStringTools.getEncodedLength(original2,
           0, numBytes2);
       if (encodedLen2 > encoded2.length)
-        encoded2 = new char[ArrayUtil.getNextSize(encodedLen2)];
+        encoded2 = new char[ArrayUtil.oversize(encodedLen2, RamUsageEstimator.NUM_BYTES_CHAR)];
       IndexableBinaryStringTools.encode(original2, 0, numBytes2, encoded2, 0,
           encodedLen2);
 
@@ -308,7 +308,7 @@ public class TestIndexableBinaryStringTools extends LuceneTestCase {
       int encodedLen = IndexableBinaryStringTools.getEncodedLength(binary, 0,
           numBytes);
       if (encoded.length < encodedLen)
-        encoded = new char[ArrayUtil.getNextSize(encodedLen)];
+        encoded = new char[ArrayUtil.oversize(encodedLen, RamUsageEstimator.NUM_BYTES_CHAR)];
       IndexableBinaryStringTools.encode(binary, 0, numBytes, encoded, 0,
           encodedLen);
 

