GitDiffStart: c2c2b23e9d69acbada3fff4621944fa2fdd36390 | Fri Mar 2 05:26:00 2012 +0000
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/SimpleSpatialFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/SimpleSpatialFieldInfo.java
new file mode 100644
index 0000000..04255ac
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/SimpleSpatialFieldInfo.java
@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial;
+
+
+public class SimpleSpatialFieldInfo implements SpatialFieldInfo {
+
+  private final String fieldName;
+
+  public SimpleSpatialFieldInfo(String fieldName) {
+    this.fieldName = fieldName;
+  }
+
+  public String getFieldName() {
+    return fieldName;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/SpatialFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/SpatialFieldInfo.java
new file mode 100644
index 0000000..3370f00
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/SpatialFieldInfo.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial;
+
+/**
+ * Information the strategy needs for the lucene fields
+ */
+public interface SpatialFieldInfo {
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java
new file mode 100644
index 0000000..26816116
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.Query;
+
+/**
+ * must be thread safe
+ */
+public abstract class SpatialStrategy<T extends SpatialFieldInfo> {
+
+  protected boolean ignoreIncompatibleGeometry = false;
+  protected final SpatialContext ctx;
+
+  public SpatialStrategy(SpatialContext ctx) {
+    this.ctx = ctx;
+  }
+
+  public SpatialContext getSpatialContext() {
+    return ctx;
+  }
+
+  /** Corresponds with Solr's  FieldType.isPolyField(). */
+  public boolean isPolyField() {
+    return false;
+  }
+
+  /**
+   * Corresponds with Solr's FieldType.createField().
+   *
+   * This may return a null field if it does not want to make anything.
+   * This is reasonable behavior if 'ignoreIncompatibleGeometry=true' and the
+   * geometry is incompatible
+   */
+  public abstract IndexableField createField(T fieldInfo, Shape shape, boolean index, boolean store);
+
+  /** Corresponds with Solr's FieldType.createFields(). */
+  public IndexableField[] createFields(T fieldInfo, Shape shape, boolean index, boolean store) {
+    return new IndexableField[] { createField(fieldInfo, shape, index, store) };
+  }
+
+  public abstract ValueSource makeValueSource(SpatialArgs args, T fieldInfo);
+
+  /**
+   * Make a query
+   */
+  public abstract Query makeQuery(SpatialArgs args, T fieldInfo);
+
+  /**
+   * Make a Filter
+   */
+  public abstract Filter makeFilter(SpatialArgs args, T fieldInfo);
+
+  public boolean isIgnoreIncompatibleGeometry() {
+    return ignoreIncompatibleGeometry;
+  }
+
+  public void setIgnoreIncompatibleGeometry(boolean ignoreIncompatibleGeometry) {
+    this.ignoreIncompatibleGeometry = ignoreIncompatibleGeometry;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/package-info.java
new file mode 100644
index 0000000..618e5af
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/package-info.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * Lucene spatial search
+ *
+ * Check:
+ * http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
+ */
+package org.apache.lucene.spatial;
+
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PointPrefixTreeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PointPrefixTreeFieldCacheProvider.java
new file mode 100644
index 0000000..3088d3d
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PointPrefixTreeFieldCacheProvider.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.shape.Point;
+import org.apache.lucene.spatial.prefix.tree.Node;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+import org.apache.lucene.spatial.util.ShapeFieldCacheProvider;
+import org.apache.lucene.util.BytesRef;
+
+public class PointPrefixTreeFieldCacheProvider extends ShapeFieldCacheProvider<Point> {
+
+  final SpatialPrefixTree grid; //
+
+  public PointPrefixTreeFieldCacheProvider(SpatialPrefixTree grid, String shapeField, int defaultSize) {
+    super( shapeField, defaultSize );
+    this.grid = grid;
+  }
+
+  //A kluge that this is a field
+  private Node scanCell = null;
+
+  @Override
+  protected Point readShape(BytesRef term) {
+    scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);
+    return scanCell.isLeaf() ? scanCell.getShape().getCenter() : null;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixCellsTokenizer.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixCellsTokenizer.java
new file mode 100644
index 0000000..a552804
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixCellsTokenizer.java
@@ -0,0 +1,89 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+
+import java.io.IOException;
+import java.io.Reader;
+
+
+/**
+ *
+ */
+class PrefixCellsTokenizer extends Tokenizer {
+  public PrefixCellsTokenizer(Reader input) {
+    super(input);
+  }
+
+  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+  @Override
+  public final boolean incrementToken() throws IOException {
+    clearAttributes();
+    int length = 0;
+    char[] buffer = termAtt.buffer();
+    while (true) {
+      char c = (char) input.read();
+      if (c < 0) break;
+      if (c == 'a' || c == 'A') {
+        buffer[length++] = 'A';
+        continue;
+      }
+      if (c == 'b' || c == 'B') {
+        buffer[length++] = 'B';
+        continue;
+      }
+      if (c == 'c' || c == 'C') {
+        buffer[length++] = 'C';
+        continue;
+      }
+      if (c == 'd' || c == 'D') {
+        buffer[length++] = 'D';
+        continue;
+      }
+      if (c == '*') {
+        buffer[length++] = '*';
+        continue;
+      }
+      if (c == '+') {
+        buffer[length++] = '+';
+        continue;
+      }
+
+      if (length > 0) {
+        // Skip any other character
+        break;
+      }
+    }
+
+    termAtt.setLength(length);
+    return length > 0; // should only happen at the end
+  }
+
+  @Override
+  public final void end() {
+
+  }
+
+  @Override
+  public void reset(Reader input) throws IOException {
+    super.reset(input);
+  }
+}
\ No newline at end of file
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java
new file mode 100644
index 0000000..f854a07
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java
@@ -0,0 +1,174 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.StoredField;
+import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.spatial.SimpleSpatialFieldInfo;
+import org.apache.lucene.spatial.SpatialStrategy;
+import org.apache.lucene.spatial.prefix.tree.Node;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+import org.apache.lucene.spatial.util.CachedDistanceValueSource;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public abstract class PrefixTreeStrategy extends SpatialStrategy<SimpleSpatialFieldInfo> {
+  protected final SpatialPrefixTree grid;
+  private final Map<String, PointPrefixTreeFieldCacheProvider> provider = new ConcurrentHashMap<String, PointPrefixTreeFieldCacheProvider>();
+  protected int defaultFieldValuesArrayLen = 2;
+  protected double distErrPct = SpatialArgs.DEFAULT_DIST_PRECISION;
+
+  public PrefixTreeStrategy(SpatialPrefixTree grid) {
+    super(grid.getSpatialContext());
+    this.grid = grid;
+  }
+
+  /** Used in the in-memory ValueSource as a default ArrayList length for this field's array of values, per doc. */
+  public void setDefaultFieldValuesArrayLen(int defaultFieldValuesArrayLen) {
+    this.defaultFieldValuesArrayLen = defaultFieldValuesArrayLen;
+  }
+
+  /** See {@link SpatialPrefixTree#getMaxLevelForPrecision(com.spatial4j.core.shape.Shape, double)}. */
+  public void setDistErrPct(double distErrPct) {
+    this.distErrPct = distErrPct;
+  }
+
+  @Override
+  public IndexableField createField(SimpleSpatialFieldInfo fieldInfo, Shape shape, boolean index, boolean store) {
+    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);
+    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells
+    //If shape isn't a point, add a full-resolution center-point so that
+    // PrefixFieldCacheProvider has the center-points.
+    // TODO index each center of a multi-point? Yes/no?
+    if (!(shape instanceof Point)) {
+      Point ctr = shape.getCenter();
+      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.
+      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));
+    }
+
+    String fname = fieldInfo.getFieldName();
+    if( store ) {
+      //TODO figure out how to re-use original string instead of reconstituting it.
+      String wkt = grid.getSpatialContext().toString(shape);
+      if( index ) {
+        Field f = new Field(fname,wkt,TYPE_STORED);
+        f.setTokenStream(new CellTokenStream(cells.iterator()));
+        return f;
+      }
+      return new StoredField(fname,wkt);
+    }
+    
+    if( index ) {
+      return new Field(fname,new CellTokenStream(cells.iterator()),TYPE_UNSTORED);
+    }
+    
+    throw new UnsupportedOperationException("Fields need to be indexed or store ["+fname+"]");
+  }
+
+  /* Indexed, tokenized, not stored. */
+  public static final FieldType TYPE_UNSTORED = new FieldType();
+
+  /* Indexed, tokenized, stored. */
+  public static final FieldType TYPE_STORED = new FieldType();
+
+  static {
+    TYPE_UNSTORED.setIndexed(true);
+    TYPE_UNSTORED.setTokenized(true);
+    TYPE_UNSTORED.setOmitNorms(true);
+    TYPE_UNSTORED.freeze();
+
+    TYPE_STORED.setStored(true);
+    TYPE_STORED.setIndexed(true);
+    TYPE_STORED.setTokenized(true);
+    TYPE_STORED.setOmitNorms(true);
+    TYPE_STORED.freeze();
+  }
+
+  /** Outputs the tokenString of a cell, and if its a leaf, outputs it again with the leaf byte. */
+  final static class CellTokenStream extends TokenStream {
+
+    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+    private Iterator<Node> iter = null;
+
+    public CellTokenStream(Iterator<Node> tokens) {
+      this.iter = tokens;
+    }
+
+    CharSequence nextTokenStringNeedingLeaf = null;
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      clearAttributes();
+      if (nextTokenStringNeedingLeaf != null) {
+        termAtt.append(nextTokenStringNeedingLeaf);
+        termAtt.append((char) Node.LEAF_BYTE);
+        nextTokenStringNeedingLeaf = null;
+        return true;
+      }
+      if (iter.hasNext()) {
+        Node cell = iter.next();
+        CharSequence token = cell.getTokenString();
+        termAtt.append(token);
+        if (cell.isLeaf())
+          nextTokenStringNeedingLeaf = token;
+        return true;
+      }
+      return false;
+    }
+
+  }
+
+  @Override
+  public ValueSource makeValueSource(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
+    DistanceCalculator calc = grid.getSpatialContext().getDistCalc();
+    return makeValueSource(args, fieldInfo, calc);
+  }
+  
+  public ValueSource makeValueSource(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo, DistanceCalculator calc) {
+    PointPrefixTreeFieldCacheProvider p = provider.get( fieldInfo.getFieldName() );
+    if( p == null ) {
+      synchronized (this) {//double checked locking idiom is okay since provider is threadsafe
+        p = provider.get( fieldInfo.getFieldName() );
+        if (p == null) {
+          p = new PointPrefixTreeFieldCacheProvider(grid, fieldInfo.getFieldName(), defaultFieldValuesArrayLen);
+          provider.put(fieldInfo.getFieldName(),p);
+        }
+      }
+    }
+    Point point = args.getShape().getCenter();
+    return new CachedDistanceValueSource(point, calc, p);
+  }
+
+  public SpatialPrefixTree getGrid() {
+    return grid;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter.java
new file mode 100644
index 0000000..dbdfc63
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeFilter.java
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+import org.apache.lucene.index.*;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.spatial.prefix.tree.Node;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.lucene.util.StringHelper;
+
+import java.io.IOException;
+import java.util.LinkedList;
+
+/**
+ * Performs a spatial intersection filter against a field indexed with {@link SpatialPrefixTree}, a Trie.
+ * SPT yields terms (grids) at length 1 and at greater lengths corresponding to greater precisions.
+ * This filter recursively traverses each grid length and uses methods on {@link Shape} to efficiently know
+ * that all points at a prefix fit in the shape or not to either short-circuit unnecessary traversals or to efficiently
+ * load all enclosed points.
+ */
+public class RecursivePrefixTreeFilter extends Filter {
+
+  /* TODOs for future:
+
+Can a polygon query shape be optimized / made-simpler at recursive depths (e.g. intersection of shape + cell box)
+
+RE "scan" threshold:
+  // IF configured to do so, we could use term.freq() as an estimate on the number of places at this depth.  OR, perhaps
+  //  make estimates based on the total known term count at this level?
+  if (!scan) {
+    //Make some estimations on how many points there are at this level and how few there would need to be to set
+    // !scan to false.
+    long termsThreshold = (long) estimateNumberIndexedTerms(cell.length(),queryShape.getDocFreqExpenseThreshold(cell));
+    long thisOrd = termsEnum.ord();
+    scan = (termsEnum.seek(thisOrd+termsThreshold+1) == TermsEnum.SeekStatus.END
+            || !cell.contains(termsEnum.term()));
+    termsEnum.seek(thisOrd);//return to last position
+  }
+
+  */
+
+  private final String fieldName;
+  private final SpatialPrefixTree grid;
+  private final Shape queryShape;
+  private final int prefixGridScanLevel;//at least one less than grid.getMaxLevels()
+  private final int detailLevel;
+
+  public RecursivePrefixTreeFilter(String fieldName, SpatialPrefixTree grid, Shape queryShape, int prefixGridScanLevel,
+                             int detailLevel) {
+    this.fieldName = fieldName;
+    this.grid = grid;
+    this.queryShape = queryShape;
+    this.prefixGridScanLevel = Math.max(1,Math.min(prefixGridScanLevel,grid.getMaxLevels()-1));
+    this.detailLevel = detailLevel;
+    assert detailLevel <= grid.getMaxLevels();
+  }
+
+  @Override
+  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {
+    AtomicReader reader = ctx.reader();
+    OpenBitSet bits = new OpenBitSet(reader.maxDoc());
+    Terms terms = reader.terms(fieldName);
+    if (terms == null)
+      return null;
+    TermsEnum termsEnum = terms.iterator(null);
+    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls
+    Node scanCell = null;
+
+    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we
+    //  always advance forward through the termsEnum index.
+    LinkedList<Node> cells = new LinkedList<Node>(
+        grid.getWorldNode().getSubCells(queryShape) );
+
+    //This is a recursive algorithm that starts with one or more "big" cells, and then recursively dives down into the
+    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto
+    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given
+    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and
+    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either
+    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't
+    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),
+    // seeing which ones are within the query shape.
+    while(!cells.isEmpty()) {
+      final Node cell = cells.removeFirst();
+      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());
+      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);
+      if (seekStat == TermsEnum.SeekStatus.END)
+        break;
+      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)
+        continue;
+      if (cell.getLevel() == detailLevel || cell.isLeaf()) {
+        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
+        addDocs(docsEnum,bits);
+      } else {//any other intersection
+        //If the next indexed term is the leaf marker, then add all of them
+        BytesRef nextCellTerm = termsEnum.next();
+        assert StringHelper.startsWith(nextCellTerm, cellTerm);
+        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);
+        if (scanCell.isLeaf()) {
+          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
+          addDocs(docsEnum,bits);
+          termsEnum.next();//move pointer to avoid potential redundant addDocs() below
+        }
+
+        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.
+        // Scanning is a performance optimization trade-off.
+        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic
+
+        if (!scan) {
+          //Divide & conquer
+          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning
+        } else {
+          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.
+          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {
+            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);
+            int termLevel = scanCell.getLevel();
+            if (termLevel > detailLevel)
+              continue;
+            if (termLevel == detailLevel || scanCell.isLeaf()) {
+              //TODO should put more thought into implications of box vs point
+              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();
+              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)
+                continue;
+
+              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
+              addDocs(docsEnum,bits);
+            }
+          }//term loop
+        }
+      }
+    }//cell loop
+
+    return bits;
+  }
+
+  private void addDocs(DocsEnum docsEnum, OpenBitSet bits) throws IOException {
+    int docid;
+    while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+      bits.fastSet(docid);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "GeoFilter{fieldName='" + fieldName + '\'' + ", shape=" + queryShape + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    RecursivePrefixTreeFilter that = (RecursivePrefixTreeFilter) o;
+
+    if (!fieldName.equals(that.fieldName)) return false;
+    //note that we don't need to look at grid since for the same field it should be the same
+    if (prefixGridScanLevel != that.prefixGridScanLevel) return false;
+    if (detailLevel != that.detailLevel) return false;
+    if (!queryShape.equals(that.queryShape)) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = fieldName.hashCode();
+    result = 31 * result + queryShape.hashCode();
+    result = 31 * result + detailLevel;
+    return result;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java
new file mode 100644
index 0000000..76b684e
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.FilteredQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.spatial.SimpleSpatialFieldInfo;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+
+
+public class RecursivePrefixTreeStrategy extends PrefixTreeStrategy {
+
+  private int prefixGridScanLevel;//TODO how is this customized?
+
+  public RecursivePrefixTreeStrategy(SpatialPrefixTree grid) {
+    super(grid);
+    prefixGridScanLevel = grid.getMaxLevels() - 4;//TODO this default constant is dependent on the prefix grid size
+  }
+
+  public void setPrefixGridScanLevel(int prefixGridScanLevel) {
+    this.prefixGridScanLevel = prefixGridScanLevel;
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName()+"(prefixGridScanLevel:"+prefixGridScanLevel+",SPG:("+ grid +"))";
+  }
+
+  @Override
+  public Query makeQuery(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
+    Filter f = makeFilter(args, fieldInfo);
+
+    ValueSource vs = makeValueSource(args, fieldInfo);
+    return new FilteredQuery( new FunctionQuery(vs), f );
+  }
+
+  @Override
+  public Filter makeFilter(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
+    final SpatialOperation op = args.getOperation();
+    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin))
+      throw new UnsupportedSpatialOperation(op);
+
+    Shape qshape = args.getShape();
+
+    int detailLevel = grid.getMaxLevelForPrecision(qshape,args.getDistPrecision());
+
+    return new RecursivePrefixTreeFilter(
+        fieldInfo.getFieldName(), grid,qshape, prefixGridScanLevel, detailLevel);
+  }
+}
+
+
+
+
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java
new file mode 100644
index 0000000..fbe0325
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/TermQueryPrefixTreeStrategy.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.*;
+import org.apache.lucene.spatial.SimpleSpatialFieldInfo;
+import org.apache.lucene.spatial.prefix.tree.Node;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+
+import java.util.List;
+
+public class TermQueryPrefixTreeStrategy extends PrefixTreeStrategy {
+
+  public TermQueryPrefixTreeStrategy(SpatialPrefixTree grid) {
+    super(grid);
+  }
+
+  @Override
+  public Filter makeFilter(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
+    return new QueryWrapperFilter( makeQuery(args, fieldInfo) );
+  }
+
+  @Override
+  public Query makeQuery(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
+    if (args.getOperation() != SpatialOperation.Intersects &&
+        args.getOperation() != SpatialOperation.IsWithin &&
+        args.getOperation() != SpatialOperation.Overlaps ){
+      // TODO -- can translate these other query types
+      throw new UnsupportedSpatialOperation(args.getOperation());
+    }
+    Shape qshape = args.getShape();
+    int detailLevel = grid.getMaxLevelForPrecision(qshape, args.getDistPrecision());
+    List<Node> cells = grid.getNodes(qshape, detailLevel, false);
+
+    BooleanQuery booleanQuery = new BooleanQuery();
+    for (Node cell : cells) {
+      booleanQuery.add(new TermQuery(new Term(fieldInfo.getFieldName(), cell.getTokenString())), BooleanClause.Occur.SHOULD);
+    }
+    return booleanQuery;
+  }
+
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/package-info.java
new file mode 100644
index 0000000..67c4e7f
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Prefix Tree Strategy
+ */
+package org.apache.lucene.spatial.prefix;
+
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java
new file mode 100644
index 0000000..2c576c0
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java
@@ -0,0 +1,149 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.util.GeohashUtils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+
+/**
+ * A SpatialPrefixGrid based on Geohashes.  Uses {@link GeohashUtils} to do all the geohash work.
+ */
+public class GeohashPrefixTree extends SpatialPrefixTree {
+
+  public static class Factory extends SpatialPrefixTreeFactory {
+
+    @Override
+    protected int getLevelForDistance(double degrees) {
+      GeohashPrefixTree grid = new GeohashPrefixTree(ctx, GeohashPrefixTree.getMaxLevelsPossible());
+      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
+    }
+
+    @Override
+    protected SpatialPrefixTree newSPT() {
+      return new GeohashPrefixTree(ctx,
+          maxLevels != null ? maxLevels : GeohashPrefixTree.getMaxLevelsPossible());
+    }
+  }
+
+  public GeohashPrefixTree(SpatialContext ctx, int maxLevels) {
+    super(ctx, maxLevels);
+    Rectangle bounds = ctx.getWorldBounds();
+    if (bounds.getMinX() != -180)
+      throw new IllegalArgumentException("Geohash only supports lat-lon world bounds. Got "+bounds);
+    int MAXP = getMaxLevelsPossible();
+    if (maxLevels <= 0 || maxLevels > MAXP)
+      throw new IllegalArgumentException("maxLen must be [1-"+MAXP+"] but got "+ maxLevels);
+  }
+
+  /** Any more than this and there's no point (double lat & lon are the same). */
+  public static int getMaxLevelsPossible() {
+    return GeohashUtils.MAX_PRECISION;
+  }
+
+  @Override
+  public int getLevelForDistance(double dist) {
+    final int level = GeohashUtils.lookupHashLenForWidthHeight(dist, dist);
+    return Math.max(Math.min(level, maxLevels), 1);
+  }
+
+  @Override
+  public Node getNode(Point p, int level) {
+    return new GhCell(GeohashUtils.encodeLatLon(p.getY(), p.getX(), level));//args are lat,lon (y,x)
+  }
+
+  @Override
+  public Node getNode(String token) {
+    return new GhCell(token);
+  }
+
+  @Override
+  public Node getNode(byte[] bytes, int offset, int len) {
+    return new GhCell(bytes, offset, len);
+  }
+
+  @Override
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    return shape instanceof Point ? super.getNodesAltPoint((Point) shape, detailLevel, inclParents) :
+        super.getNodes(shape, detailLevel, inclParents);
+  }
+
+  class GhCell extends Node {
+    GhCell(String token) {
+      super(GeohashPrefixTree.this, token);
+    }
+
+    GhCell(byte[] bytes, int off, int len) {
+      super(GeohashPrefixTree.this, bytes, off, len);
+    }
+
+    @Override
+    public void reset(byte[] bytes, int off, int len) {
+      super.reset(bytes, off, len);
+      shape = null;
+    }
+
+    @Override
+    public Collection<Node> getSubCells() {
+      String[] hashes = GeohashUtils.getSubGeohashes(getGeohash());//sorted
+      List<Node> cells = new ArrayList<Node>(hashes.length);
+      for (String hash : hashes) {
+        cells.add(new GhCell(hash));
+      }
+      return cells;
+    }
+
+    @Override
+    public int getSubCellsSize() {
+      return 32;//8x4
+    }
+
+    @Override
+    public Node getSubCell(Point p) {
+      return GeohashPrefixTree.this.getNode(p,getLevel()+1);//not performant!
+    }
+
+    private Shape shape;//cache
+
+    @Override
+    public Shape getShape() {
+      if (shape == null) {
+        shape = GeohashUtils.decodeBoundary(getGeohash(), ctx);
+      }
+      return shape;
+    }
+
+    @Override
+    public Point getCenter() {
+      return GeohashUtils.decode(getGeohash(), ctx);
+    }
+
+    private String getGeohash() {
+      return getTokenString();
+    }
+
+  }//class GhCell
+
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Node.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Node.java
new file mode 100644
index 0000000..62c7616
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Node.java
@@ -0,0 +1,212 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Represents a grid cell. These are not necessarily threadsafe, although new Cell("") (world cell) must be.
+ */
+public abstract class Node implements Comparable<Node> {
+  public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
+
+  /*
+  Holds a byte[] and/or String representation of the cell. Both are lazy constructed from the other.
+  Neither contains the trailing leaf byte.
+   */
+  private byte[] bytes;
+  private int b_off;
+  private int b_len;
+
+  private String token;//this is the only part of equality
+
+  protected SpatialRelation shapeRel;//set in getSubCells(filter), and via setLeaf().
+  private SpatialPrefixTree spatialPrefixTree;
+
+  protected Node(SpatialPrefixTree spatialPrefixTree, String token) {
+    this.spatialPrefixTree = spatialPrefixTree;
+    this.token = token;
+    if (token.length() > 0 && token.charAt(token.length() - 1) == (char) LEAF_BYTE) {
+      this.token = token.substring(0, token.length() - 1);
+      setLeaf();
+    }
+
+    if (getLevel() == 0)
+      getShape();//ensure any lazy instantiation completes to make this threadsafe
+  }
+
+  protected Node(SpatialPrefixTree spatialPrefixTree, byte[] bytes, int off, int len) {
+    this.spatialPrefixTree = spatialPrefixTree;
+    this.bytes = bytes;
+    this.b_off = off;
+    this.b_len = len;
+    b_fixLeaf();
+  }
+
+  public void reset(byte[] bytes, int off, int len) {
+    assert getLevel() != 0;
+    token = null;
+    shapeRel = null;
+    this.bytes = bytes;
+    this.b_off = off;
+    this.b_len = len;
+    b_fixLeaf();
+  }
+
+  private void b_fixLeaf() {
+    if (bytes[b_off + b_len - 1] == LEAF_BYTE) {
+      b_len--;
+      setLeaf();
+    } else if (getLevel() == spatialPrefixTree.getMaxLevels()) {
+      setLeaf();
+    }
+  }
+
+  public SpatialRelation getShapeRel() {
+    return shapeRel;
+  }
+
+  public boolean isLeaf() {
+    return shapeRel == SpatialRelation.WITHIN;
+  }
+
+  public void setLeaf() {
+    assert getLevel() != 0;
+    shapeRel = SpatialRelation.WITHIN;
+  }
+
+  /**
+   * Note: doesn't contain a trailing leaf byte.
+   */
+  public String getTokenString() {
+    if (token == null) {
+      token = new String(bytes, b_off, b_len, SpatialPrefixTree.UTF8);
+    }
+    return token;
+  }
+
+  /**
+   * Note: doesn't contain a trailing leaf byte.
+   */
+  public byte[] getTokenBytes() {
+    if (bytes != null) {
+      if (b_off != 0 || b_len != bytes.length) {
+        throw new IllegalStateException("Not supported if byte[] needs to be recreated.");
+      }
+    } else {
+      bytes = token.getBytes(SpatialPrefixTree.UTF8);
+      b_off = 0;
+      b_len = bytes.length;
+    }
+    return bytes;
+  }
+
+  public int getLevel() {
+    return token != null ? token.length() : b_len;
+  }
+
+  //TODO add getParent() and update some algorithms to use this?
+  //public Cell getParent();
+
+  /**
+   * Like {@link #getSubCells()} but with the results filtered by a shape. If that shape is a {@link com.spatial4j.core.shape.Point} then it
+   * must call {@link #getSubCell(com.spatial4j.core.shape.Point)};
+   * Precondition: Never called when getLevel() == maxLevel.
+   *
+   * @param shapeFilter an optional filter for the returned cells.
+   * @return A set of cells (no dups), sorted. Not Modifiable.
+   */
+  public Collection<Node> getSubCells(Shape shapeFilter) {
+    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
+    if (shapeFilter instanceof Point) {
+      return Collections.singleton(getSubCell((Point) shapeFilter));
+    }
+    Collection<Node> cells = getSubCells();
+
+    if (shapeFilter == null) {
+      return cells;
+    }
+    List<Node> copy = new ArrayList<Node>(cells.size());//copy since cells contractually isn't modifiable
+    for (Node cell : cells) {
+      SpatialRelation rel = cell.getShape().relate(shapeFilter, spatialPrefixTree.ctx);
+      if (rel == SpatialRelation.DISJOINT)
+        continue;
+      cell.shapeRel = rel;
+      copy.add(cell);
+    }
+    cells = copy;
+    return cells;
+  }
+
+  /**
+   * Performant implementations are expected to implement this efficiently by considering the current
+   * cell's boundary.
+   * Precondition: Never called when getLevel() == maxLevel.
+   * Precondition: this.getShape().relate(p) != DISJOINT.
+   */
+  public abstract Node getSubCell(Point p);
+
+  //TODO Cell getSubCell(byte b)
+
+  /**
+   * Gets the cells at the next grid cell level that cover this cell.
+   * Precondition: Never called when getLevel() == maxLevel.
+   *
+   * @return A set of cells (no dups), sorted. Not Modifiable.
+   */
+  protected abstract Collection<Node> getSubCells();
+
+  /**
+   * {@link #getSubCells()}.size() -- usually a constant. Should be >=2
+   */
+  public abstract int getSubCellsSize();
+
+  public abstract Shape getShape();
+
+  public Point getCenter() {
+    return getShape().getCenter();
+  }
+
+  @Override
+  public int compareTo(Node o) {
+    return getTokenString().compareTo(o.getTokenString());
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return !(obj == null || !(obj instanceof Node)) && getTokenString().equals(((Node) obj).getTokenString());
+  }
+
+  @Override
+  public int hashCode() {
+    return getTokenString().hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return getTokenString() + (isLeaf() ? (char) LEAF_BYTE : "");
+  }
+
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
new file mode 100644
index 0000000..e203b4a
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
@@ -0,0 +1,299 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+import com.spatial4j.core.shape.simple.PointImpl;
+
+import java.text.NumberFormat;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+
+public class QuadPrefixTree extends SpatialPrefixTree {
+
+  public static class Factory extends SpatialPrefixTreeFactory {
+
+    @Override
+    protected int getLevelForDistance(double degrees) {
+      QuadPrefixTree grid = new QuadPrefixTree(ctx, MAX_LEVELS_POSSIBLE);
+      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
+    }
+
+    @Override
+    protected SpatialPrefixTree newSPT() {
+      return new QuadPrefixTree(ctx,
+          maxLevels != null ? maxLevels : MAX_LEVELS_POSSIBLE);
+    }
+  }
+
+  public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
+
+  public static final int DEFAULT_MAX_LEVELS = 12;
+  private final double xmin;
+  private final double xmax;
+  private final double ymin;
+  private final double ymax;
+  private final double xmid;
+  private final double ymid;
+
+  private final double gridW;
+  public final double gridH;
+
+  final double[] levelW;
+  final double[] levelH;
+  final int[]    levelS; // side
+  final int[]    levelN; // number
+
+  public QuadPrefixTree(
+      SpatialContext ctx, Rectangle bounds, int maxLevels) {
+    super(ctx, maxLevels);
+    this.xmin = bounds.getMinX();
+    this.xmax = bounds.getMaxX();
+    this.ymin = bounds.getMinY();
+    this.ymax = bounds.getMaxY();
+
+    levelW = new double[maxLevels];
+    levelH = new double[maxLevels];
+    levelS = new int[maxLevels];
+    levelN = new int[maxLevels];
+
+    gridW = xmax - xmin;
+    gridH = ymax - ymin;
+    this.xmid = xmin + gridW/2.0;
+    this.ymid = ymin + gridH/2.0;
+    levelW[0] = gridW/2.0;
+    levelH[0] = gridH/2.0;
+    levelS[0] = 2;
+    levelN[0] = 4;
+
+    for (int i = 1; i < levelW.length; i++) {
+      levelW[i] = levelW[i - 1] / 2.0;
+      levelH[i] = levelH[i - 1] / 2.0;
+      levelS[i] = levelS[i - 1] * 2;
+      levelN[i] = levelN[i - 1] * 4;
+    }
+  }
+
+  public QuadPrefixTree(SpatialContext ctx) {
+    this(ctx, DEFAULT_MAX_LEVELS);
+  }
+
+  public QuadPrefixTree(
+      SpatialContext ctx, int maxLevels) {
+    this(ctx, ctx.getWorldBounds(), maxLevels);
+  }
+
+  public void printInfo() {
+    NumberFormat nf = NumberFormat.getNumberInstance();
+    nf.setMaximumFractionDigits(5);
+    nf.setMinimumFractionDigits(5);
+    nf.setMinimumIntegerDigits(3);
+
+    for (int i = 0; i < maxLevels; i++) {
+      System.out.println(i + "]\t" + nf.format(levelW[i]) + "\t" + nf.format(levelH[i]) + "\t" +
+          levelS[i] + "\t" + (levelS[i] * levelS[i]));
+    }
+  }
+
+  @Override
+  public int getLevelForDistance(double dist) {
+    for (int i = 1; i < maxLevels; i++) {
+      //note: level[i] is actually a lookup for level i+1
+      if(dist > levelW[i] || dist > levelH[i]) {
+        return i;
+      }
+    }
+    return maxLevels;
+  }
+
+  @Override
+  public Node getNode(Point p, int level) {
+    List<Node> cells = new ArrayList<Node>(1);
+    build(xmid, ymid, 0, cells, new StringBuilder(), new PointImpl(p.getX(),p.getY()), level);
+    return cells.get(0);//note cells could be longer if p on edge
+  }
+
+  @Override
+  public Node getNode(String token) {
+    return new QuadCell(token);
+  }
+
+  @Override
+  public Node getNode(byte[] bytes, int offset, int len) {
+    return new QuadCell(bytes, offset, len);
+  }
+
+  @Override //for performance
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    if (shape instanceof Point)
+      return super.getNodesAltPoint((Point) shape, detailLevel, inclParents);
+    else
+      return super.getNodes(shape, detailLevel, inclParents);
+  }
+
+  private void build(
+      double x,
+      double y,
+      int level,
+      List<Node> matches,
+      StringBuilder str,
+      Shape shape,
+      int maxLevel) {
+    assert str.length() == level;
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    // Z-Order
+    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
+    checkBattenberg('A', x - w, y + h, level, matches, str, shape, maxLevel);
+    checkBattenberg('B', x + w, y + h, level, matches, str, shape, maxLevel);
+    checkBattenberg('C', x - w, y - h, level, matches, str, shape, maxLevel);
+    checkBattenberg('D', x + w, y - h, level, matches, str, shape, maxLevel);
+
+    // possibly consider hilbert curve
+    // http://en.wikipedia.org/wiki/Hilbert_curve
+    // http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
+    // if we actually use the range property in the query, this could be useful
+  }
+
+  private void checkBattenberg(
+      char c,
+      double cx,
+      double cy,
+      int level,
+      List<Node> matches,
+      StringBuilder str,
+      Shape shape,
+      int maxLevel) {
+    assert str.length() == level;
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    int strlen = str.length();
+    Rectangle rectangle = ctx.makeRect(cx - w, cx + w, cy - h, cy + h);
+    SpatialRelation v = shape.relate(rectangle, ctx);
+    if (SpatialRelation.CONTAINS == v) {
+      str.append(c);
+      //str.append(SpatialPrefixGrid.COVER);
+      matches.add(new QuadCell(str.toString(),v.transpose()));
+    } else if (SpatialRelation.DISJOINT == v) {
+      // nothing
+    } else { // SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
+      str.append(c);
+
+      int nextLevel = level+1;
+      if (nextLevel >= maxLevel) {
+        //str.append(SpatialPrefixGrid.INTERSECTS);
+        matches.add(new QuadCell(str.toString(),v.transpose()));
+      } else {
+        build(cx, cy, nextLevel, matches, str, shape, maxLevel);
+      }
+    }
+    str.setLength(strlen);
+  }
+
+  class QuadCell extends Node {
+
+    public QuadCell(String token) {
+      super(QuadPrefixTree.this, token);
+    }
+
+    public QuadCell(String token, SpatialRelation shapeRel) {
+      super(QuadPrefixTree.this, token);
+      this.shapeRel = shapeRel;
+    }
+
+    QuadCell(byte[] bytes, int off, int len) {
+      super(QuadPrefixTree.this, bytes, off, len);
+    }
+
+    @Override
+    public void reset(byte[] bytes, int off, int len) {
+      super.reset(bytes, off, len);
+      shape = null;
+    }
+
+    @Override
+    public Collection<Node> getSubCells() {
+      List<Node> cells = new ArrayList<Node>(4);
+      cells.add(new QuadCell(getTokenString()+"A"));
+      cells.add(new QuadCell(getTokenString()+"B"));
+      cells.add(new QuadCell(getTokenString()+"C"));
+      cells.add(new QuadCell(getTokenString()+"D"));
+      return cells;
+    }
+
+    @Override
+    public int getSubCellsSize() {
+      return 4;
+    }
+
+    @Override
+    public Node getSubCell(Point p) {
+      return QuadPrefixTree.this.getNode(p,getLevel()+1);//not performant!
+    }
+
+    private Shape shape;//cache
+
+    @Override
+    public Shape getShape() {
+      if (shape == null)
+        shape = makeShape();
+      return shape;
+    }
+
+    private Rectangle makeShape() {
+      String token = getTokenString();
+      double xmin = QuadPrefixTree.this.xmin;
+      double ymin = QuadPrefixTree.this.ymin;
+
+      for (int i = 0; i < token.length(); i++) {
+        char c = token.charAt(i);
+        if ('A' == c || 'a' == c) {
+          ymin += levelH[i];
+        } else if ('B' == c || 'b' == c) {
+          xmin += levelW[i];
+          ymin += levelH[i];
+        } else if ('C' == c || 'c' == c) {
+          // nothing really
+        }
+        else if('D' == c || 'd' == c) {
+          xmin += levelW[i];
+        } else {
+          throw new RuntimeException("unexpected char: " + c);
+        }
+      }
+      int len = token.length();
+      double width, height;
+      if (len > 0) {
+        width = levelW[len-1];
+        height = levelH[len-1];
+      } else {
+        width = gridW;
+        height = gridH;
+      }
+      return ctx.makeRect(xmin, xmin + width, ymin, ymin + height);
+    }
+  }//QuadCell
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java
new file mode 100644
index 0000000..11699e5
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java
@@ -0,0 +1,246 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to
+ * variable precision.  Each string corresponds to a spatial region.
+ *
+ * Implementations of this class should be thread-safe and immutable once initialized.
+ */
+public abstract class SpatialPrefixTree {
+
+  protected static final Charset UTF8 = Charset.forName("UTF-8");
+
+  protected final int maxLevels;
+
+  protected final SpatialContext ctx;
+
+  public SpatialPrefixTree(SpatialContext ctx, int maxLevels) {
+    assert maxLevels > 0;
+    this.ctx = ctx;
+    this.maxLevels = maxLevels;
+  }
+
+  public SpatialContext getSpatialContext() {
+    return ctx;
+  }
+
+  public int getMaxLevels() {
+    return maxLevels;
+  }
+
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "(maxLevels:" + maxLevels + ",ctx:" + ctx + ")";
+  }
+
+  /**
+   * See {@link com.spatial4j.core.query.SpatialArgs#getDistPrecision()}.
+   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.
+   *
+   * @param shape
+   * @param precision 0-0.5
+   * @return 1-maxLevels
+   */
+  public int getMaxLevelForPrecision(Shape shape, double precision) {
+    if (precision < 0 || precision > 0.5) {
+      throw new IllegalArgumentException("Precision " + precision + " must be between [0-0.5]");
+    }
+    if (precision == 0 || shape instanceof Point) {
+      return maxLevels;
+    }
+    double bboxArea = shape.getBoundingBox().getArea();
+    if (bboxArea == 0) {
+      return maxLevels;
+    }
+    double avgSideLenFromCenter = Math.sqrt(bboxArea) / 2;
+    return getLevelForDistance(avgSideLenFromCenter * precision);
+  }
+
+  /**
+   * Returns the level of the smallest grid size with a side length that is greater or equal to the provided
+   * distance.
+   *
+   * @param dist >= 0
+   * @return level [1-maxLevels]
+   */
+  public abstract int getLevelForDistance(double dist);
+
+  //TODO double getDistanceForLevel(int level)
+
+  private transient Node worldNode;//cached
+
+  /**
+   * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".
+   * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't
+   * generally threadsafe.
+   * TODO rename to getTopCell or is this fine?
+   */
+  public Node getWorldNode() {
+    if (worldNode == null) {
+      worldNode = getNode("");
+    }
+    return worldNode;
+  }
+
+  /**
+   * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.
+   * Precondition: Never called when token length > maxLevel.
+   */
+  public abstract Node getNode(String token);
+
+  public abstract Node getNode(byte[] bytes, int offset, int len);
+
+  public final Node getNode(byte[] bytes, int offset, int len, Node target) {
+    if (target == null) {
+      return getNode(bytes, offset, len);
+    }
+
+    target.reset(bytes, offset, len);
+    return target;
+  }
+
+  protected Node getNode(Point p, int level) {
+    return getNodes(p, level, false).get(0);
+  }
+
+  /**
+   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
+   * The result is a set of cells (no dups), sorted. Unmodifiable.
+   * <p/>
+   * This implementation checks if shape is a Point and if so uses an implementation that
+   * recursively calls {@link Node#getSubCell(com.spatial4j.core.shape.Point)}. Cell subclasses
+   * ideally implement that method with a quick implementation, otherwise, subclasses should
+   * override this method to invoke {@link #getNodesAltPoint(com.spatial4j.core.shape.Point, int, boolean)}.
+   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
+   */
+  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
+    if (detailLevel > maxLevels) {
+      throw new IllegalArgumentException("detailLevel > maxLevels");
+    }
+
+    List<Node> cells;
+    if (shape instanceof Point) {
+      //optimized point algorithm
+      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
+      cells = new ArrayList<Node>(initialCapacity);
+      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
+      assert cells.size() == initialCapacity;
+    } else {
+      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
+      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
+    }
+    if (inclParents) {
+      Node c = cells.remove(0);//remove getWorldNode()
+      assert c.getLevel() == 0;
+    }
+    return cells;
+  }
+
+  private void recursiveGetNodes(Node node, Shape shape, int detailLevel, boolean inclParents,
+                                 Collection<Node> result) {
+    if (node.isLeaf()) {//cell is within shape
+      result.add(node);
+      return;
+    }
+    final Collection<Node> subCells = node.getSubCells(shape);
+    if (node.getLevel() == detailLevel - 1) {
+      if (subCells.size() < node.getSubCellsSize()) {
+        if (inclParents)
+          result.add(node);
+        for (Node subCell : subCells) {
+          subCell.setLeaf();
+        }
+        result.addAll(subCells);
+      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
+        node.setLeaf();
+        result.add(node);
+      }
+    } else {
+      if (inclParents) {
+        result.add(node);
+      }
+      for (Node subCell : subCells) {
+        recursiveGetNodes(subCell, shape, detailLevel, inclParents, result);//tail call
+      }
+    }
+  }
+
+  private void recursiveGetNodes(Node node, Point point, int detailLevel, boolean inclParents,
+                                 Collection<Node> result) {
+    if (inclParents) {
+      result.add(node);
+    }
+    final Node pCell = node.getSubCell(point);
+    if (node.getLevel() == detailLevel - 1) {
+      pCell.setLeaf();
+      result.add(pCell);
+    } else {
+      recursiveGetNodes(pCell, point, detailLevel, inclParents, result);//tail call
+    }
+  }
+
+  /**
+   * Subclasses might override {@link #getNodes(com.spatial4j.core.shape.Shape, int, boolean)}
+   * and check if the argument is a shape and if so, delegate
+   * to this implementation, which calls {@link #getNode(com.spatial4j.core.shape.Point, int)} and
+   * then calls {@link #getNode(String)} repeatedly if inclParents is true.
+   */
+  protected final List<Node> getNodesAltPoint(Point p, int detailLevel, boolean inclParents) {
+    Node cell = getNode(p, detailLevel);
+    if (!inclParents) {
+      return Collections.singletonList(cell);
+    }
+
+    String endToken = cell.getTokenString();
+    assert endToken.length() == detailLevel;
+    List<Node> cells = new ArrayList<Node>(detailLevel);
+    for (int i = 1; i < detailLevel; i++) {
+      cells.add(getNode(endToken.substring(0, i)));
+    }
+    cells.add(cell);
+    return cells;
+  }
+
+  /**
+   * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
+   */
+  public static List<String> nodesToTokenStrings(Collection<Node> nodes) {
+    List<String> tokens = new ArrayList<String>((nodes.size()));
+    for (Node node : nodes) {
+      final String token = node.getTokenString();
+      if (node.isLeaf()) {
+        tokens.add(token + (char) Node.LEAF_BYTE);
+      } else {
+        tokens.add(token);
+      }
+    }
+    return tokens;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java
new file mode 100644
index 0000000..47a970f
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.distance.DistanceUnits;
+import com.spatial4j.core.distance.DistanceUtils;
+
+import java.util.Map;
+
+/**
+ * @author dsmiley
+ */
+public abstract class SpatialPrefixTreeFactory {
+
+  private static final double DEFAULT_GEO_MAX_DETAIL_KM = 0.001;//1m
+
+  protected Map<String, String> args;
+  protected SpatialContext ctx;
+  protected Integer maxLevels;
+
+  /**
+   * The factory  is looked up via "prefixTree" in args, expecting "geohash" or "quad".
+   * If its neither of these, then "geohash" is chosen for a geo context, otherwise "quad" is chosen.
+   */
+  public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {
+    SpatialPrefixTreeFactory instance;
+    String cname = args.get("prefixTree");
+    if (cname == null)
+      cname = ctx.isGeo() ? "geohash" : "quad";
+    if ("geohash".equalsIgnoreCase(cname))
+      instance = new GeohashPrefixTree.Factory();
+    else if ("quad".equalsIgnoreCase(cname))
+      instance = new QuadPrefixTree.Factory();
+    else {
+      try {
+        Class c = classLoader.loadClass(cname);
+        instance = (SpatialPrefixTreeFactory) c.newInstance();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+    instance.init(args,ctx);
+    return instance.newSPT();
+  }
+
+  protected void init(Map<String, String> args, SpatialContext ctx) {
+    this.args = args;
+    this.ctx = ctx;
+    initMaxLevels();
+  }
+
+  protected void initMaxLevels() {
+    String mlStr = args.get("maxLevels");
+    if (mlStr != null) {
+      maxLevels = Integer.valueOf(mlStr);
+      return;
+    }
+
+    double degrees;
+    String maxDetailDistStr = args.get("maxDetailDist");
+    if (maxDetailDistStr == null) {
+      if (!ctx.isGeo()) {
+        return;//let default to max
+      }
+      degrees = DistanceUtils.dist2Degrees(DEFAULT_GEO_MAX_DETAIL_KM, DistanceUnits.KILOMETERS.earthRadius());
+    } else {
+      degrees = DistanceUtils.dist2Degrees(Double.parseDouble(maxDetailDistStr), ctx.getUnits().earthRadius());
+    }
+    maxLevels = getLevelForDistance(degrees) + 1;//returns 1 greater
+  }
+
+  /** Calls {@link SpatialPrefixTree#getLevelForDistance(double)}. */
+  protected abstract int getLevelForDistance(double degrees);
+
+  protected abstract SpatialPrefixTree newSPT();
+
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/package-info.java
new file mode 100644
index 0000000..5635018
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/prefix/tree/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * The Spatial Prefix package supports spatial indexing by index-time tokens
+ * where adding characters to a string gives greater resolution.
+ *
+ * Potential Implementations include:
+ *  * http://en.wikipedia.org/wiki/Quadtree
+ *  * http://en.wikipedia.org/wiki/Geohash
+ *  * http://healpix.jpl.nasa.gov/
+ */
+package org.apache.lucene.spatial.prefix.tree;
+
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SimpleSpatialFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SimpleSpatialFieldInfo.java
deleted file mode 100644
index 5d856d6..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SimpleSpatialFieldInfo.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy;
-
-
-public class SimpleSpatialFieldInfo implements SpatialFieldInfo {
-
-  private final String fieldName;
-
-  public SimpleSpatialFieldInfo(String fieldName) {
-    this.fieldName = fieldName;
-  }
-
-  public String getFieldName() {
-    return fieldName;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialFieldInfo.java
deleted file mode 100644
index a97e55b..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialFieldInfo.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy;
-
-/**
- * Information the strategy needs for the lucene fields
- */
-public interface SpatialFieldInfo {
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java
deleted file mode 100644
index e186df4..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/SpatialStrategy.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy;
-
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.Query;
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.query.SpatialArgs;
-import com.spatial4j.core.shape.Shape;
-
-/**
- * must be thread safe
- */
-public abstract class SpatialStrategy<T extends SpatialFieldInfo> {
-
-  protected boolean ignoreIncompatibleGeometry = false;
-  protected final SpatialContext ctx;
-
-  public SpatialStrategy(SpatialContext ctx) {
-    this.ctx = ctx;
-  }
-
-  public SpatialContext getSpatialContext() {
-    return ctx;
-  }
-
-  /** Corresponds with Solr's  FieldType.isPolyField(). */
-  public boolean isPolyField() {
-    return false;
-  }
-
-  /**
-   * Corresponds with Solr's FieldType.createField().
-   *
-   * This may return a null field if it does not want to make anything.
-   * This is reasonable behavior if 'ignoreIncompatibleGeometry=true' and the
-   * geometry is incompatible
-   */
-  public abstract IndexableField createField(T fieldInfo, Shape shape, boolean index, boolean store);
-
-  /** Corresponds with Solr's FieldType.createFields(). */
-  public IndexableField[] createFields(T fieldInfo, Shape shape, boolean index, boolean store) {
-    return new IndexableField[] { createField(fieldInfo, shape, index, store) };
-  }
-
-  public abstract ValueSource makeValueSource(SpatialArgs args, T fieldInfo);
-
-  /**
-   * Make a query
-   */
-  public abstract Query makeQuery(SpatialArgs args, T fieldInfo);
-
-  /**
-   * Make a Filter
-   */
-  public abstract Filter makeFilter(SpatialArgs args, T fieldInfo);
-
-  public boolean isIgnoreIncompatibleGeometry() {
-    return ignoreIncompatibleGeometry;
-  }
-
-  public void setIgnoreIncompatibleGeometry(boolean ignoreIncompatibleGeometry) {
-    this.ignoreIncompatibleGeometry = ignoreIncompatibleGeometry;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/package-info.java
deleted file mode 100644
index c51f984..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/package-info.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * Lucene spatial search
- *
- * Check:
- * http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
- */
-package org.apache.lucene.spatial.strategy;
-
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java
deleted file mode 100644
index 191b62b..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PointPrefixTreeFieldCacheProvider.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import com.spatial4j.core.shape.Point;
-
-import org.apache.lucene.spatial.strategy.prefix.tree.Node;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-import org.apache.lucene.spatial.strategy.util.ShapeFieldCacheProvider;
-import org.apache.lucene.util.BytesRef;
-
-public class PointPrefixTreeFieldCacheProvider extends ShapeFieldCacheProvider<Point> {
-
-  final SpatialPrefixTree grid; //
-
-  public PointPrefixTreeFieldCacheProvider(SpatialPrefixTree grid, String shapeField, int defaultSize) {
-    super( shapeField, defaultSize );
-    this.grid = grid;
-  }
-
-  //A kluge that this is a field
-  private Node scanCell = null;
-
-  @Override
-  protected Point readShape(BytesRef term) {
-    scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);
-    return scanCell.isLeaf() ? scanCell.getShape().getCenter() : null;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixCellsTokenizer.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixCellsTokenizer.java
deleted file mode 100644
index 01d0eff..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixCellsTokenizer.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import java.io.IOException;
-import java.io.Reader;
-
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-
-
-/**
- *
- */
-class PrefixCellsTokenizer extends Tokenizer {
-  public PrefixCellsTokenizer(Reader input) {
-    super(input);
-  }
-
-  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-  @Override
-  public final boolean incrementToken() throws IOException {
-    clearAttributes();
-    int length = 0;
-    char[] buffer = termAtt.buffer();
-    while (true) {
-      char c = (char) input.read();
-      if (c < 0) break;
-      if (c == 'a' || c == 'A') {
-        buffer[length++] = 'A';
-        continue;
-      }
-      if (c == 'b' || c == 'B') {
-        buffer[length++] = 'B';
-        continue;
-      }
-      if (c == 'c' || c == 'C') {
-        buffer[length++] = 'C';
-        continue;
-      }
-      if (c == 'd' || c == 'D') {
-        buffer[length++] = 'D';
-        continue;
-      }
-      if (c == '*') {
-        buffer[length++] = '*';
-        continue;
-      }
-      if (c == '+') {
-        buffer[length++] = '+';
-        continue;
-      }
-
-      if (length > 0) {
-        // Skip any other character
-        break;
-      }
-    }
-
-    termAtt.setLength(length);
-    return length > 0; // should only happen at the end
-  }
-
-  @Override
-  public final void end() {
-
-  }
-
-  @Override
-  public void reset(Reader input) throws IOException {
-    super.reset(input);
-  }
-}
\ No newline at end of file
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java
deleted file mode 100644
index 3bd7d7f..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/PrefixTreeStrategy.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.StoredField;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.queries.function.ValueSource;
-import com.spatial4j.core.distance.DistanceCalculator;
-import com.spatial4j.core.query.SpatialArgs;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.SpatialStrategy;
-import org.apache.lucene.spatial.strategy.prefix.tree.Node;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-import org.apache.lucene.spatial.strategy.util.CachedDistanceValueSource;
-
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-public abstract class PrefixTreeStrategy extends SpatialStrategy<SimpleSpatialFieldInfo> {
-  protected final SpatialPrefixTree grid;
-  private final Map<String, PointPrefixTreeFieldCacheProvider> provider = new ConcurrentHashMap<String, PointPrefixTreeFieldCacheProvider>();
-  protected int defaultFieldValuesArrayLen = 2;
-  protected double distErrPct = SpatialArgs.DEFAULT_DIST_PRECISION;
-
-  public PrefixTreeStrategy(SpatialPrefixTree grid) {
-    super(grid.getSpatialContext());
-    this.grid = grid;
-  }
-
-  /** Used in the in-memory ValueSource as a default ArrayList length for this field's array of values, per doc. */
-  public void setDefaultFieldValuesArrayLen(int defaultFieldValuesArrayLen) {
-    this.defaultFieldValuesArrayLen = defaultFieldValuesArrayLen;
-  }
-
-  /** See {@link SpatialPrefixTree#getMaxLevelForPrecision(com.spatial4j.core.shape.Shape, double)}. */
-  public void setDistErrPct(double distErrPct) {
-    this.distErrPct = distErrPct;
-  }
-
-  @Override
-  public IndexableField createField(SimpleSpatialFieldInfo fieldInfo, Shape shape, boolean index, boolean store) {
-    int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);
-    List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells
-    //If shape isn't a point, add a full-resolution center-point so that
-    // PrefixFieldCacheProvider has the center-points.
-    // TODO index each center of a multi-point? Yes/no?
-    if (!(shape instanceof Point)) {
-      Point ctr = shape.getCenter();
-      //TODO should be smarter; don't index 2 tokens for this in CellTokenizer. Harmless though.
-      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));
-    }
-
-    String fname = fieldInfo.getFieldName();
-    if( store ) {
-      //TODO figure out how to re-use original string instead of reconstituting it.
-      String wkt = grid.getSpatialContext().toString(shape);
-      if( index ) {
-        Field f = new Field(fname,wkt,TYPE_STORED);
-        f.setTokenStream(new CellTokenStream(cells.iterator()));
-        return f;
-      }
-      return new StoredField(fname,wkt);
-    }
-    
-    if( index ) {
-      return new Field(fname,new CellTokenStream(cells.iterator()),TYPE_UNSTORED);
-    }
-    
-    throw new UnsupportedOperationException("Fields need to be indexed or store ["+fname+"]");
-  }
-
-  /* Indexed, tokenized, not stored. */
-  public static final FieldType TYPE_UNSTORED = new FieldType();
-
-  /* Indexed, tokenized, stored. */
-  public static final FieldType TYPE_STORED = new FieldType();
-
-  static {
-    TYPE_UNSTORED.setIndexed(true);
-    TYPE_UNSTORED.setTokenized(true);
-    TYPE_UNSTORED.setOmitNorms(true);
-    TYPE_UNSTORED.freeze();
-
-    TYPE_STORED.setStored(true);
-    TYPE_STORED.setIndexed(true);
-    TYPE_STORED.setTokenized(true);
-    TYPE_STORED.setOmitNorms(true);
-    TYPE_STORED.freeze();
-  }
-
-  /** Outputs the tokenString of a cell, and if its a leaf, outputs it again with the leaf byte. */
-  final static class CellTokenStream extends TokenStream {
-
-    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-    private Iterator<Node> iter = null;
-
-    public CellTokenStream(Iterator<Node> tokens) {
-      this.iter = tokens;
-    }
-
-    CharSequence nextTokenStringNeedingLeaf = null;
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      clearAttributes();
-      if (nextTokenStringNeedingLeaf != null) {
-        termAtt.append(nextTokenStringNeedingLeaf);
-        termAtt.append((char) Node.LEAF_BYTE);
-        nextTokenStringNeedingLeaf = null;
-        return true;
-      }
-      if (iter.hasNext()) {
-        Node cell = iter.next();
-        CharSequence token = cell.getTokenString();
-        termAtt.append(token);
-        if (cell.isLeaf())
-          nextTokenStringNeedingLeaf = token;
-        return true;
-      }
-      return false;
-    }
-
-  }
-
-  @Override
-  public ValueSource makeValueSource(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
-    DistanceCalculator calc = grid.getSpatialContext().getDistCalc();
-    return makeValueSource(args, fieldInfo, calc);
-  }
-  
-  public ValueSource makeValueSource(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo, DistanceCalculator calc) {
-    PointPrefixTreeFieldCacheProvider p = provider.get( fieldInfo.getFieldName() );
-    if( p == null ) {
-      synchronized (this) {//double checked locking idiom is okay since provider is threadsafe
-        p = provider.get( fieldInfo.getFieldName() );
-        if (p == null) {
-          p = new PointPrefixTreeFieldCacheProvider(grid, fieldInfo.getFieldName(), defaultFieldValuesArrayLen);
-          provider.put(fieldInfo.getFieldName(),p);
-        }
-      }
-    }
-    Point point = args.getShape().getCenter();
-    return new CachedDistanceValueSource(point, calc, p);
-  }
-
-  public SpatialPrefixTree getGrid() {
-    return grid;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java
deleted file mode 100644
index d3841ac..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeFilter.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import org.apache.lucene.index.*;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.strategy.prefix.tree.Node;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-
-import com.spatial4j.core.shape.SpatialRelation;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.OpenBitSet;
-import org.apache.lucene.util.StringHelper;
-
-import java.io.IOException;
-import java.util.LinkedList;
-
-/**
- * Performs a spatial intersection filter against a field indexed with {@link SpatialPrefixTree}, a Trie.
- * SPT yields terms (grids) at length 1 and at greater lengths corresponding to greater precisions.
- * This filter recursively traverses each grid length and uses methods on {@link Shape} to efficiently know
- * that all points at a prefix fit in the shape or not to either short-circuit unnecessary traversals or to efficiently
- * load all enclosed points.
- */
-public class RecursivePrefixTreeFilter extends Filter {
-
-  /* TODOs for future:
-
-Can a polygon query shape be optimized / made-simpler at recursive depths (e.g. intersection of shape + cell box)
-
-RE "scan" threshold:
-  // IF configured to do so, we could use term.freq() as an estimate on the number of places at this depth.  OR, perhaps
-  //  make estimates based on the total known term count at this level?
-  if (!scan) {
-    //Make some estimations on how many points there are at this level and how few there would need to be to set
-    // !scan to false.
-    long termsThreshold = (long) estimateNumberIndexedTerms(cell.length(),queryShape.getDocFreqExpenseThreshold(cell));
-    long thisOrd = termsEnum.ord();
-    scan = (termsEnum.seek(thisOrd+termsThreshold+1) == TermsEnum.SeekStatus.END
-            || !cell.contains(termsEnum.term()));
-    termsEnum.seek(thisOrd);//return to last position
-  }
-
-  */
-
-  private final String fieldName;
-  private final SpatialPrefixTree grid;
-  private final Shape queryShape;
-  private final int prefixGridScanLevel;//at least one less than grid.getMaxLevels()
-  private final int detailLevel;
-
-  public RecursivePrefixTreeFilter(String fieldName, SpatialPrefixTree grid, Shape queryShape, int prefixGridScanLevel,
-                             int detailLevel) {
-    this.fieldName = fieldName;
-    this.grid = grid;
-    this.queryShape = queryShape;
-    this.prefixGridScanLevel = Math.max(1,Math.min(prefixGridScanLevel,grid.getMaxLevels()-1));
-    this.detailLevel = detailLevel;
-    assert detailLevel <= grid.getMaxLevels();
-  }
-
-  @Override
-  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {
-    AtomicReader reader = ctx.reader();
-    OpenBitSet bits = new OpenBitSet(reader.maxDoc());
-    Terms terms = reader.terms(fieldName);
-    if (terms == null)
-      return null;
-    TermsEnum termsEnum = terms.iterator(null);
-    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls
-    Node scanCell = null;
-
-    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we
-    //  always advance forward through the termsEnum index.
-    LinkedList<Node> cells = new LinkedList<Node>(
-        grid.getWorldNode().getSubCells(queryShape) );
-
-    //This is a recursive algorithm that starts with one or more "big" cells, and then recursively dives down into the
-    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto
-    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given
-    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and
-    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either
-    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't
-    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),
-    // seeing which ones are within the query shape.
-    while(!cells.isEmpty()) {
-      final Node cell = cells.removeFirst();
-      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());
-      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);
-      if (seekStat == TermsEnum.SeekStatus.END)
-        break;
-      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)
-        continue;
-      if (cell.getLevel() == detailLevel || cell.isLeaf()) {
-        docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
-        addDocs(docsEnum,bits);
-      } else {//any other intersection
-        //If the next indexed term is the leaf marker, then add all of them
-        BytesRef nextCellTerm = termsEnum.next();
-        assert StringHelper.startsWith(nextCellTerm, cellTerm);
-        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);
-        if (scanCell.isLeaf()) {
-          docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
-          addDocs(docsEnum,bits);
-          termsEnum.next();//move pointer to avoid potential redundant addDocs() below
-        }
-
-        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.
-        // Scanning is a performance optimization trade-off.
-        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic
-
-        if (!scan) {
-          //Divide & conquer
-          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning
-        } else {
-          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.
-          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {
-            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);
-            int termLevel = scanCell.getLevel();
-            if (termLevel > detailLevel)
-              continue;
-            if (termLevel == detailLevel || scanCell.isLeaf()) {
-              //TODO should put more thought into implications of box vs point
-              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();
-              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)
-                continue;
-
-              docsEnum = termsEnum.docs(acceptDocs, docsEnum, false);
-              addDocs(docsEnum,bits);
-            }
-          }//term loop
-        }
-      }
-    }//cell loop
-
-    return bits;
-  }
-
-  private void addDocs(DocsEnum docsEnum, OpenBitSet bits) throws IOException {
-    int docid;
-    while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
-      bits.fastSet(docid);
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "GeoFilter{fieldName='" + fieldName + '\'' + ", shape=" + queryShape + '}';
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    RecursivePrefixTreeFilter that = (RecursivePrefixTreeFilter) o;
-
-    if (!fieldName.equals(that.fieldName)) return false;
-    //note that we don't need to look at grid since for the same field it should be the same
-    if (prefixGridScanLevel != that.prefixGridScanLevel) return false;
-    if (detailLevel != that.detailLevel) return false;
-    if (!queryShape.equals(that.queryShape)) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = fieldName.hashCode();
-    result = 31 * result + queryShape.hashCode();
-    result = 31 * result + detailLevel;
-    return result;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java
deleted file mode 100644
index 594bb85..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategy.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.FilteredQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.queries.function.FunctionQuery;
-import com.spatial4j.core.exception.UnsupportedSpatialOperation;
-import com.spatial4j.core.query.SpatialArgs;
-import com.spatial4j.core.query.SpatialOperation;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-
-
-public class RecursivePrefixTreeStrategy extends PrefixTreeStrategy {
-
-  private int prefixGridScanLevel;//TODO how is this customized?
-
-  public RecursivePrefixTreeStrategy(SpatialPrefixTree grid) {
-    super(grid);
-    prefixGridScanLevel = grid.getMaxLevels() - 4;//TODO this default constant is dependent on the prefix grid size
-  }
-
-  public void setPrefixGridScanLevel(int prefixGridScanLevel) {
-    this.prefixGridScanLevel = prefixGridScanLevel;
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName()+"(prefixGridScanLevel:"+prefixGridScanLevel+",SPG:("+ grid +"))";
-  }
-
-  @Override
-  public Query makeQuery(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
-    Filter f = makeFilter(args, fieldInfo);
-
-    ValueSource vs = makeValueSource(args, fieldInfo);
-    return new FilteredQuery( new FunctionQuery(vs), f );
-  }
-
-  @Override
-  public Filter makeFilter(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
-    final SpatialOperation op = args.getOperation();
-    if (! SpatialOperation.is(op, SpatialOperation.IsWithin, SpatialOperation.Intersects, SpatialOperation.BBoxWithin))
-      throw new UnsupportedSpatialOperation(op);
-
-    Shape qshape = args.getShape();
-
-    int detailLevel = grid.getMaxLevelForPrecision(qshape,args.getDistPrecision());
-
-    return new RecursivePrefixTreeFilter(
-        fieldInfo.getFieldName(), grid,qshape, prefixGridScanLevel, detailLevel);
-  }
-}
-
-
-
-
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java
deleted file mode 100644
index e6978a8..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/TermQueryPrefixTreeStrategy.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.*;
-import com.spatial4j.core.exception.UnsupportedSpatialOperation;
-import com.spatial4j.core.query.SpatialArgs;
-import com.spatial4j.core.query.SpatialOperation;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.prefix.tree.Node;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-
-import java.util.List;
-
-public class TermQueryPrefixTreeStrategy extends PrefixTreeStrategy {
-
-  public TermQueryPrefixTreeStrategy(SpatialPrefixTree grid) {
-    super(grid);
-  }
-
-  @Override
-  public Filter makeFilter(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
-    return new QueryWrapperFilter( makeQuery(args, fieldInfo) );
-  }
-
-  @Override
-  public Query makeQuery(SpatialArgs args, SimpleSpatialFieldInfo fieldInfo) {
-    if (args.getOperation() != SpatialOperation.Intersects &&
-        args.getOperation() != SpatialOperation.IsWithin &&
-        args.getOperation() != SpatialOperation.Overlaps ){
-      // TODO -- can translate these other query types
-      throw new UnsupportedSpatialOperation(args.getOperation());
-    }
-    Shape qshape = args.getShape();
-    int detailLevel = grid.getMaxLevelForPrecision(qshape, args.getDistPrecision());
-    List<Node> cells = grid.getNodes(qshape, detailLevel, false);
-
-    BooleanQuery booleanQuery = new BooleanQuery();
-    for (Node cell : cells) {
-      booleanQuery.add(new TermQuery(new Term(fieldInfo.getFieldName(), cell.getTokenString())), BooleanClause.Occur.SHOULD);
-    }
-    return booleanQuery;
-  }
-
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/package-info.java
deleted file mode 100644
index f470d83..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/package-info.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Prefix Tree Strategy
- */
-package org.apache.lucene.spatial.strategy.prefix;
-
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/GeohashPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/GeohashPrefixTree.java
deleted file mode 100644
index 7a4011c..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/GeohashPrefixTree.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Rectangle;
-import com.spatial4j.core.shape.Shape;
-import com.spatial4j.core.util.GeohashUtils;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-
-/**
- * A SpatialPrefixGrid based on Geohashes.  Uses {@link GeohashUtils} to do all the geohash work.
- */
-public class GeohashPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      GeohashPrefixTree grid = new GeohashPrefixTree(ctx, GeohashPrefixTree.getMaxLevelsPossible());
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new GeohashPrefixTree(ctx,
-          maxLevels != null ? maxLevels : GeohashPrefixTree.getMaxLevelsPossible());
-    }
-  }
-
-  public GeohashPrefixTree(SpatialContext ctx, int maxLevels) {
-    super(ctx, maxLevels);
-    Rectangle bounds = ctx.getWorldBounds();
-    if (bounds.getMinX() != -180)
-      throw new IllegalArgumentException("Geohash only supports lat-lon world bounds. Got "+bounds);
-    int MAXP = getMaxLevelsPossible();
-    if (maxLevels <= 0 || maxLevels > MAXP)
-      throw new IllegalArgumentException("maxLen must be [1-"+MAXP+"] but got "+ maxLevels);
-  }
-
-  /** Any more than this and there's no point (double lat & lon are the same). */
-  public static int getMaxLevelsPossible() {
-    return GeohashUtils.MAX_PRECISION;
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    final int level = GeohashUtils.lookupHashLenForWidthHeight(dist, dist);
-    return Math.max(Math.min(level, maxLevels), 1);
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    return new GhCell(GeohashUtils.encodeLatLon(p.getY(), p.getX(), level));//args are lat,lon (y,x)
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new GhCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new GhCell(bytes, offset, len);
-  }
-
-  @Override
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    return shape instanceof Point ? super.getNodesAltPoint((Point) shape, detailLevel, inclParents) :
-        super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  class GhCell extends Node {
-    GhCell(String token) {
-      super(GeohashPrefixTree.this, token);
-    }
-
-    GhCell(byte[] bytes, int off, int len) {
-      super(GeohashPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      String[] hashes = GeohashUtils.getSubGeohashes(getGeohash());//sorted
-      List<Node> cells = new ArrayList<Node>(hashes.length);
-      for (String hash : hashes) {
-        cells.add(new GhCell(hash));
-      }
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 32;//8x4
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return GeohashPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null) {
-        shape = GeohashUtils.decodeBoundary(getGeohash(), ctx);
-      }
-      return shape;
-    }
-
-    @Override
-    public Point getCenter() {
-      return GeohashUtils.decode(getGeohash(), ctx);
-    }
-
-    private String getGeohash() {
-      return getTokenString();
-    }
-
-  }//class GhCell
-
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/Node.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/Node.java
deleted file mode 100644
index 033e03a..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/Node.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.shape.SpatialRelation;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Shape;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Represents a grid cell. These are not necessarily threadsafe, although new Cell("") (world cell) must be.
- */
-public abstract class Node implements Comparable<Node> {
-  public static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
-
-  /*
-  Holds a byte[] and/or String representation of the cell. Both are lazy constructed from the other.
-  Neither contains the trailing leaf byte.
-   */
-  private byte[] bytes;
-  private int b_off;
-  private int b_len;
-
-  private String token;//this is the only part of equality
-
-  protected SpatialRelation shapeRel;//set in getSubCells(filter), and via setLeaf().
-  private SpatialPrefixTree spatialPrefixTree;
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, String token) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.token = token;
-    if (token.length() > 0 && token.charAt(token.length() - 1) == (char) LEAF_BYTE) {
-      this.token = token.substring(0, token.length() - 1);
-      setLeaf();
-    }
-
-    if (getLevel() == 0)
-      getShape();//ensure any lazy instantiation completes to make this threadsafe
-  }
-
-  protected Node(SpatialPrefixTree spatialPrefixTree, byte[] bytes, int off, int len) {
-    this.spatialPrefixTree = spatialPrefixTree;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  public void reset(byte[] bytes, int off, int len) {
-    assert getLevel() != 0;
-    token = null;
-    shapeRel = null;
-    this.bytes = bytes;
-    this.b_off = off;
-    this.b_len = len;
-    b_fixLeaf();
-  }
-
-  private void b_fixLeaf() {
-    if (bytes[b_off + b_len - 1] == LEAF_BYTE) {
-      b_len--;
-      setLeaf();
-    } else if (getLevel() == spatialPrefixTree.getMaxLevels()) {
-      setLeaf();
-    }
-  }
-
-  public SpatialRelation getShapeRel() {
-    return shapeRel;
-  }
-
-  public boolean isLeaf() {
-    return shapeRel == SpatialRelation.WITHIN;
-  }
-
-  public void setLeaf() {
-    assert getLevel() != 0;
-    shapeRel = SpatialRelation.WITHIN;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public String getTokenString() {
-    if (token == null) {
-      token = new String(bytes, b_off, b_len, SpatialPrefixTree.UTF8);
-    }
-    return token;
-  }
-
-  /**
-   * Note: doesn't contain a trailing leaf byte.
-   */
-  public byte[] getTokenBytes() {
-    if (bytes != null) {
-      if (b_off != 0 || b_len != bytes.length) {
-        throw new IllegalStateException("Not supported if byte[] needs to be recreated.");
-      }
-    } else {
-      bytes = token.getBytes(SpatialPrefixTree.UTF8);
-      b_off = 0;
-      b_len = bytes.length;
-    }
-    return bytes;
-  }
-
-  public int getLevel() {
-    return token != null ? token.length() : b_len;
-  }
-
-  //TODO add getParent() and update some algorithms to use this?
-  //public Cell getParent();
-
-  /**
-   * Like {@link #getSubCells()} but with the results filtered by a shape. If that shape is a {@link com.spatial4j.core.shape.Point} then it
-   * must call {@link #getSubCell(com.spatial4j.core.shape.Point)};
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @param shapeFilter an optional filter for the returned cells.
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  public Collection<Node> getSubCells(Shape shapeFilter) {
-    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
-    if (shapeFilter instanceof Point) {
-      return Collections.singleton(getSubCell((Point) shapeFilter));
-    }
-    Collection<Node> cells = getSubCells();
-
-    if (shapeFilter == null) {
-      return cells;
-    }
-    List<Node> copy = new ArrayList<Node>(cells.size());//copy since cells contractually isn't modifiable
-    for (Node cell : cells) {
-      SpatialRelation rel = cell.getShape().relate(shapeFilter, spatialPrefixTree.ctx);
-      if (rel == SpatialRelation.DISJOINT)
-        continue;
-      cell.shapeRel = rel;
-      copy.add(cell);
-    }
-    cells = copy;
-    return cells;
-  }
-
-  /**
-   * Performant implementations are expected to implement this efficiently by considering the current
-   * cell's boundary.
-   * Precondition: Never called when getLevel() == maxLevel.
-   * Precondition: this.getShape().relate(p) != DISJOINT.
-   */
-  public abstract Node getSubCell(Point p);
-
-  //TODO Cell getSubCell(byte b)
-
-  /**
-   * Gets the cells at the next grid cell level that cover this cell.
-   * Precondition: Never called when getLevel() == maxLevel.
-   *
-   * @return A set of cells (no dups), sorted. Not Modifiable.
-   */
-  protected abstract Collection<Node> getSubCells();
-
-  /**
-   * {@link #getSubCells()}.size() -- usually a constant. Should be >=2
-   */
-  public abstract int getSubCellsSize();
-
-  public abstract Shape getShape();
-
-  public Point getCenter() {
-    return getShape().getCenter();
-  }
-
-  @Override
-  public int compareTo(Node o) {
-    return getTokenString().compareTo(o.getTokenString());
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return !(obj == null || !(obj instanceof Node)) && getTokenString().equals(((Node) obj).getTokenString());
-  }
-
-  @Override
-  public int hashCode() {
-    return getTokenString().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return getTokenString() + (isLeaf() ? (char) LEAF_BYTE : "");
-  }
-
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/QuadPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/QuadPrefixTree.java
deleted file mode 100644
index 4eb7a78..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/QuadPrefixTree.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.shape.SpatialRelation;
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Rectangle;
-import com.spatial4j.core.shape.Shape;
-import com.spatial4j.core.shape.simple.PointImpl;
-
-import java.text.NumberFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-
-public class QuadPrefixTree extends SpatialPrefixTree {
-
-  public static class Factory extends SpatialPrefixTreeFactory {
-
-    @Override
-    protected int getLevelForDistance(double degrees) {
-      QuadPrefixTree grid = new QuadPrefixTree(ctx, MAX_LEVELS_POSSIBLE);
-      return grid.getLevelForDistance(degrees) + 1;//returns 1 greater
-    }
-
-    @Override
-    protected SpatialPrefixTree newSPT() {
-      return new QuadPrefixTree(ctx,
-          maxLevels != null ? maxLevels : MAX_LEVELS_POSSIBLE);
-    }
-  }
-
-  public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
-
-  public static final int DEFAULT_MAX_LEVELS = 12;
-  private final double xmin;
-  private final double xmax;
-  private final double ymin;
-  private final double ymax;
-  private final double xmid;
-  private final double ymid;
-
-  private final double gridW;
-  public final double gridH;
-
-  final double[] levelW;
-  final double[] levelH;
-  final int[]    levelS; // side
-  final int[]    levelN; // number
-
-  public QuadPrefixTree(
-      SpatialContext ctx, Rectangle bounds, int maxLevels) {
-    super(ctx, maxLevels);
-    this.xmin = bounds.getMinX();
-    this.xmax = bounds.getMaxX();
-    this.ymin = bounds.getMinY();
-    this.ymax = bounds.getMaxY();
-
-    levelW = new double[maxLevels];
-    levelH = new double[maxLevels];
-    levelS = new int[maxLevels];
-    levelN = new int[maxLevels];
-
-    gridW = xmax - xmin;
-    gridH = ymax - ymin;
-    this.xmid = xmin + gridW/2.0;
-    this.ymid = ymin + gridH/2.0;
-    levelW[0] = gridW/2.0;
-    levelH[0] = gridH/2.0;
-    levelS[0] = 2;
-    levelN[0] = 4;
-
-    for (int i = 1; i < levelW.length; i++) {
-      levelW[i] = levelW[i - 1] / 2.0;
-      levelH[i] = levelH[i - 1] / 2.0;
-      levelS[i] = levelS[i - 1] * 2;
-      levelN[i] = levelN[i - 1] * 4;
-    }
-  }
-
-  public QuadPrefixTree(SpatialContext ctx) {
-    this(ctx, DEFAULT_MAX_LEVELS);
-  }
-
-  public QuadPrefixTree(
-      SpatialContext ctx, int maxLevels) {
-    this(ctx, ctx.getWorldBounds(), maxLevels);
-  }
-
-  public void printInfo() {
-    NumberFormat nf = NumberFormat.getNumberInstance();
-    nf.setMaximumFractionDigits(5);
-    nf.setMinimumFractionDigits(5);
-    nf.setMinimumIntegerDigits(3);
-
-    for (int i = 0; i < maxLevels; i++) {
-      System.out.println(i + "]\t" + nf.format(levelW[i]) + "\t" + nf.format(levelH[i]) + "\t" +
-          levelS[i] + "\t" + (levelS[i] * levelS[i]));
-    }
-  }
-
-  @Override
-  public int getLevelForDistance(double dist) {
-    for (int i = 1; i < maxLevels; i++) {
-      //note: level[i] is actually a lookup for level i+1
-      if(dist > levelW[i] || dist > levelH[i]) {
-        return i;
-      }
-    }
-    return maxLevels;
-  }
-
-  @Override
-  public Node getNode(Point p, int level) {
-    List<Node> cells = new ArrayList<Node>(1);
-    build(xmid, ymid, 0, cells, new StringBuilder(), new PointImpl(p.getX(),p.getY()), level);
-    return cells.get(0);//note cells could be longer if p on edge
-  }
-
-  @Override
-  public Node getNode(String token) {
-    return new QuadCell(token);
-  }
-
-  @Override
-  public Node getNode(byte[] bytes, int offset, int len) {
-    return new QuadCell(bytes, offset, len);
-  }
-
-  @Override //for performance
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (shape instanceof Point)
-      return super.getNodesAltPoint((Point) shape, detailLevel, inclParents);
-    else
-      return super.getNodes(shape, detailLevel, inclParents);
-  }
-
-  private void build(
-      double x,
-      double y,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    // Z-Order
-    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
-    checkBattenberg('A', x - w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('B', x + w, y + h, level, matches, str, shape, maxLevel);
-    checkBattenberg('C', x - w, y - h, level, matches, str, shape, maxLevel);
-    checkBattenberg('D', x + w, y - h, level, matches, str, shape, maxLevel);
-
-    // possibly consider hilbert curve
-    // http://en.wikipedia.org/wiki/Hilbert_curve
-    // http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves
-    // if we actually use the range property in the query, this could be useful
-  }
-
-  private void checkBattenberg(
-      char c,
-      double cx,
-      double cy,
-      int level,
-      List<Node> matches,
-      StringBuilder str,
-      Shape shape,
-      int maxLevel) {
-    assert str.length() == level;
-    double w = levelW[level] / 2;
-    double h = levelH[level] / 2;
-
-    int strlen = str.length();
-    Rectangle rectangle = ctx.makeRect(cx - w, cx + w, cy - h, cy + h);
-    SpatialRelation v = shape.relate(rectangle, ctx);
-    if (SpatialRelation.CONTAINS == v) {
-      str.append(c);
-      //str.append(SpatialPrefixGrid.COVER);
-      matches.add(new QuadCell(str.toString(),v.transpose()));
-    } else if (SpatialRelation.DISJOINT == v) {
-      // nothing
-    } else { // SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
-      str.append(c);
-
-      int nextLevel = level+1;
-      if (nextLevel >= maxLevel) {
-        //str.append(SpatialPrefixGrid.INTERSECTS);
-        matches.add(new QuadCell(str.toString(),v.transpose()));
-      } else {
-        build(cx, cy, nextLevel, matches, str, shape, maxLevel);
-      }
-    }
-    str.setLength(strlen);
-  }
-
-  class QuadCell extends Node {
-
-    public QuadCell(String token) {
-      super(QuadPrefixTree.this, token);
-    }
-
-    public QuadCell(String token, SpatialRelation shapeRel) {
-      super(QuadPrefixTree.this, token);
-      this.shapeRel = shapeRel;
-    }
-
-    QuadCell(byte[] bytes, int off, int len) {
-      super(QuadPrefixTree.this, bytes, off, len);
-    }
-
-    @Override
-    public void reset(byte[] bytes, int off, int len) {
-      super.reset(bytes, off, len);
-      shape = null;
-    }
-
-    @Override
-    public Collection<Node> getSubCells() {
-      List<Node> cells = new ArrayList<Node>(4);
-      cells.add(new QuadCell(getTokenString()+"A"));
-      cells.add(new QuadCell(getTokenString()+"B"));
-      cells.add(new QuadCell(getTokenString()+"C"));
-      cells.add(new QuadCell(getTokenString()+"D"));
-      return cells;
-    }
-
-    @Override
-    public int getSubCellsSize() {
-      return 4;
-    }
-
-    @Override
-    public Node getSubCell(Point p) {
-      return QuadPrefixTree.this.getNode(p,getLevel()+1);//not performant!
-    }
-
-    private Shape shape;//cache
-
-    @Override
-    public Shape getShape() {
-      if (shape == null)
-        shape = makeShape();
-      return shape;
-    }
-
-    private Rectangle makeShape() {
-      String token = getTokenString();
-      double xmin = QuadPrefixTree.this.xmin;
-      double ymin = QuadPrefixTree.this.ymin;
-
-      for (int i = 0; i < token.length(); i++) {
-        char c = token.charAt(i);
-        if ('A' == c || 'a' == c) {
-          ymin += levelH[i];
-        } else if ('B' == c || 'b' == c) {
-          xmin += levelW[i];
-          ymin += levelH[i];
-        } else if ('C' == c || 'c' == c) {
-          // nothing really
-        }
-        else if('D' == c || 'd' == c) {
-          xmin += levelW[i];
-        } else {
-          throw new RuntimeException("unexpected char: " + c);
-        }
-      }
-      int len = token.length();
-      double width, height;
-      if (len > 0) {
-        width = levelW[len-1];
-        height = levelH[len-1];
-      } else {
-        width = gridW;
-        height = gridH;
-      }
-      return ctx.makeRect(xmin, xmin + width, ymin, ymin + height);
-    }
-  }//QuadCell
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTree.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTree.java
deleted file mode 100644
index 3d355f3..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTree.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Shape;
-
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A Spatial Prefix Tree, or Trie, which decomposes shapes into prefixed strings at variable lengths corresponding to
- * variable precision.  Each string corresponds to a spatial region.
- *
- * Implementations of this class should be thread-safe and immutable once initialized.
- */
-public abstract class SpatialPrefixTree {
-
-  protected static final Charset UTF8 = Charset.forName("UTF-8");
-
-  protected final int maxLevels;
-
-  protected final SpatialContext ctx;
-
-  public SpatialPrefixTree(SpatialContext ctx, int maxLevels) {
-    assert maxLevels > 0;
-    this.ctx = ctx;
-    this.maxLevels = maxLevels;
-  }
-
-  public SpatialContext getSpatialContext() {
-    return ctx;
-  }
-
-  public int getMaxLevels() {
-    return maxLevels;
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName() + "(maxLevels:" + maxLevels + ",ctx:" + ctx + ")";
-  }
-
-  /**
-   * See {@link com.spatial4j.core.query.SpatialArgs#getDistPrecision()}.
-   * A grid level looked up via {@link #getLevelForDistance(double)} is returned.
-   *
-   * @param shape
-   * @param precision 0-0.5
-   * @return 1-maxLevels
-   */
-  public int getMaxLevelForPrecision(Shape shape, double precision) {
-    if (precision < 0 || precision > 0.5) {
-      throw new IllegalArgumentException("Precision " + precision + " must be between [0-0.5]");
-    }
-    if (precision == 0 || shape instanceof Point) {
-      return maxLevels;
-    }
-    double bboxArea = shape.getBoundingBox().getArea();
-    if (bboxArea == 0) {
-      return maxLevels;
-    }
-    double avgSideLenFromCenter = Math.sqrt(bboxArea) / 2;
-    return getLevelForDistance(avgSideLenFromCenter * precision);
-  }
-
-  /**
-   * Returns the level of the smallest grid size with a side length that is greater or equal to the provided
-   * distance.
-   *
-   * @param dist >= 0
-   * @return level [1-maxLevels]
-   */
-  public abstract int getLevelForDistance(double dist);
-
-  //TODO double getDistanceForLevel(int level)
-
-  private transient Node worldNode;//cached
-
-  /**
-   * Returns the level 0 cell which encompasses all spatial data. Equivalent to {@link #getNode(String)} with "".
-   * This cell is threadsafe, just like a spatial prefix grid is, although cells aren't
-   * generally threadsafe.
-   * TODO rename to getTopCell or is this fine?
-   */
-  public Node getWorldNode() {
-    if (worldNode == null) {
-      worldNode = getNode("");
-    }
-    return worldNode;
-  }
-
-  /**
-   * The cell for the specified token. The empty string should be equal to {@link #getWorldNode()}.
-   * Precondition: Never called when token length > maxLevel.
-   */
-  public abstract Node getNode(String token);
-
-  public abstract Node getNode(byte[] bytes, int offset, int len);
-
-  public final Node getNode(byte[] bytes, int offset, int len, Node target) {
-    if (target == null) {
-      return getNode(bytes, offset, len);
-    }
-
-    target.reset(bytes, offset, len);
-    return target;
-  }
-
-  protected Node getNode(Point p, int level) {
-    return getNodes(p, level, false).get(0);
-  }
-
-  /**
-   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
-   * The result is a set of cells (no dups), sorted. Unmodifiable.
-   * <p/>
-   * This implementation checks if shape is a Point and if so uses an implementation that
-   * recursively calls {@link Node#getSubCell(com.spatial4j.core.shape.Point)}. Cell subclasses
-   * ideally implement that method with a quick implementation, otherwise, subclasses should
-   * override this method to invoke {@link #getNodesAltPoint(com.spatial4j.core.shape.Point, int, boolean)}.
-   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
-   */
-  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
-    if (detailLevel > maxLevels) {
-      throw new IllegalArgumentException("detailLevel > maxLevels");
-    }
-
-    List<Node> cells;
-    if (shape instanceof Point) {
-      //optimized point algorithm
-      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
-      cells = new ArrayList<Node>(initialCapacity);
-      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
-      assert cells.size() == initialCapacity;
-    } else {
-      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
-      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
-    }
-    if (inclParents) {
-      Node c = cells.remove(0);//remove getWorldNode()
-      assert c.getLevel() == 0;
-    }
-    return cells;
-  }
-
-  private void recursiveGetNodes(Node node, Shape shape, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (node.isLeaf()) {//cell is within shape
-      result.add(node);
-      return;
-    }
-    final Collection<Node> subCells = node.getSubCells(shape);
-    if (node.getLevel() == detailLevel - 1) {
-      if (subCells.size() < node.getSubCellsSize()) {
-        if (inclParents)
-          result.add(node);
-        for (Node subCell : subCells) {
-          subCell.setLeaf();
-        }
-        result.addAll(subCells);
-      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
-        node.setLeaf();
-        result.add(node);
-      }
-    } else {
-      if (inclParents) {
-        result.add(node);
-      }
-      for (Node subCell : subCells) {
-        recursiveGetNodes(subCell, shape, detailLevel, inclParents, result);//tail call
-      }
-    }
-  }
-
-  private void recursiveGetNodes(Node node, Point point, int detailLevel, boolean inclParents,
-                                 Collection<Node> result) {
-    if (inclParents) {
-      result.add(node);
-    }
-    final Node pCell = node.getSubCell(point);
-    if (node.getLevel() == detailLevel - 1) {
-      pCell.setLeaf();
-      result.add(pCell);
-    } else {
-      recursiveGetNodes(pCell, point, detailLevel, inclParents, result);//tail call
-    }
-  }
-
-  /**
-   * Subclasses might override {@link #getNodes(com.spatial4j.core.shape.Shape, int, boolean)}
-   * and check if the argument is a shape and if so, delegate
-   * to this implementation, which calls {@link #getNode(com.spatial4j.core.shape.Point, int)} and
-   * then calls {@link #getNode(String)} repeatedly if inclParents is true.
-   */
-  protected final List<Node> getNodesAltPoint(Point p, int detailLevel, boolean inclParents) {
-    Node cell = getNode(p, detailLevel);
-    if (!inclParents) {
-      return Collections.singletonList(cell);
-    }
-
-    String endToken = cell.getTokenString();
-    assert endToken.length() == detailLevel;
-    List<Node> cells = new ArrayList<Node>(detailLevel);
-    for (int i = 1; i < detailLevel; i++) {
-      cells.add(getNode(endToken.substring(0, i)));
-    }
-    cells.add(cell);
-    return cells;
-  }
-
-  /**
-   * Will add the trailing leaf byte for leaves. This isn't particularly efficient.
-   */
-  public static List<String> nodesToTokenStrings(Collection<Node> nodes) {
-    List<String> tokens = new ArrayList<String>((nodes.size()));
-    for (Node node : nodes) {
-      final String token = node.getTokenString();
-      if (node.isLeaf()) {
-        tokens.add(token + (char) Node.LEAF_BYTE);
-      } else {
-        tokens.add(token);
-      }
-    }
-    return tokens;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeFactory.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeFactory.java
deleted file mode 100644
index 1e058a4..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeFactory.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.distance.DistanceUnits;
-import com.spatial4j.core.distance.DistanceUtils;
-
-import java.util.Map;
-
-/**
- * @author dsmiley
- */
-public abstract class SpatialPrefixTreeFactory {
-
-  private static final double DEFAULT_GEO_MAX_DETAIL_KM = 0.001;//1m
-
-  protected Map<String, String> args;
-  protected SpatialContext ctx;
-  protected Integer maxLevels;
-
-  /**
-   * The factory  is looked up via "prefixTree" in args, expecting "geohash" or "quad".
-   * If its neither of these, then "geohash" is chosen for a geo context, otherwise "quad" is chosen.
-   */
-  public static SpatialPrefixTree makeSPT(Map<String,String> args, ClassLoader classLoader, SpatialContext ctx) {
-    SpatialPrefixTreeFactory instance;
-    String cname = args.get("prefixTree");
-    if (cname == null)
-      cname = ctx.isGeo() ? "geohash" : "quad";
-    if ("geohash".equalsIgnoreCase(cname))
-      instance = new GeohashPrefixTree.Factory();
-    else if ("quad".equalsIgnoreCase(cname))
-      instance = new QuadPrefixTree.Factory();
-    else {
-      try {
-        Class c = classLoader.loadClass(cname);
-        instance = (SpatialPrefixTreeFactory) c.newInstance();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-    instance.init(args,ctx);
-    return instance.newSPT();
-  }
-
-  protected void init(Map<String, String> args, SpatialContext ctx) {
-    this.args = args;
-    this.ctx = ctx;
-    initMaxLevels();
-  }
-
-  protected void initMaxLevels() {
-    String mlStr = args.get("maxLevels");
-    if (mlStr != null) {
-      maxLevels = Integer.valueOf(mlStr);
-      return;
-    }
-
-    double degrees;
-    String maxDetailDistStr = args.get("maxDetailDist");
-    if (maxDetailDistStr == null) {
-      if (!ctx.isGeo()) {
-        return;//let default to max
-      }
-      degrees = DistanceUtils.dist2Degrees(DEFAULT_GEO_MAX_DETAIL_KM, DistanceUnits.KILOMETERS.earthRadius());
-    } else {
-      degrees = DistanceUtils.dist2Degrees(Double.parseDouble(maxDetailDistStr), ctx.getUnits().earthRadius());
-    }
-    maxLevels = getLevelForDistance(degrees) + 1;//returns 1 greater
-  }
-
-  /** Calls {@link SpatialPrefixTree#getLevelForDistance(double)}. */
-  protected abstract int getLevelForDistance(double degrees);
-
-  protected abstract SpatialPrefixTree newSPT();
-
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/package-info.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/package-info.java
deleted file mode 100644
index aaa5713..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/prefix/tree/package-info.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * The Spatial Prefix package supports spatial indexing by index-time tokens
- * where adding characters to a string gives greater resolution.
- *
- * Potential Implementations include:
- *  * http://en.wikipedia.org/wiki/Quadtree
- *  * http://en.wikipedia.org/wiki/Geohash
- *  * http://healpix.jpl.nasa.gov/
- */
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java
deleted file mode 100644
index ceb8259..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachedDistanceValueSource.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import com.spatial4j.core.distance.DistanceCalculator;
-import com.spatial4j.core.shape.Point;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
-/**
- *
- * An implementation of the Lucene ValueSource model to support spatial relevance ranking.
- *
- */
-public class CachedDistanceValueSource extends ValueSource {
-
-  private final ShapeFieldCacheProvider<Point> provider;
-  private final DistanceCalculator calculator;
-  private final Point from;
-
-  public CachedDistanceValueSource(Point from, DistanceCalculator calc, ShapeFieldCacheProvider<Point> provider) {
-    this.from = from;
-    this.provider = provider;
-    this.calculator = calc;
-  }
-
-  @Override
-  public String description() {
-    return "DistanceValueSource("+calculator+")";
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final ShapeFieldCache<Point> cache =
-      provider.getCache(readerContext.reader());
-
-    return new FunctionValues() {
-      @Override
-      public float floatVal(int doc) {
-        return (float) doubleVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        List<Point> vals = cache.getShapes( doc );
-        if( vals != null ) {
-          double v = calculator.distance(from, vals.get(0));
-          for( int i=1; i<vals.size(); i++ ) {
-            v = Math.min(v, calculator.distance(from, vals.get(i)));
-          }
-          return v;
-        }
-        return Double.NaN; // ?? maybe max?
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + "=" + floatVal(doc);
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    CachedDistanceValueSource rhs = (CachedDistanceValueSource) obj;
-    return new EqualsBuilder()
-                  .append(calculator, rhs.calculator)
-                  .append(from, rhs.from)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(31, 97).
-        append(calculator).
-        append(from).
-        toHashCode();
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachingDoubleValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachingDoubleValueSource.java
deleted file mode 100644
index 0a0b764..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/CachingDoubleValueSource.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-public class CachingDoubleValueSource extends ValueSource {
-
-  final ValueSource source;
-  final Map<Integer, Double> cache;
-
-  public CachingDoubleValueSource( ValueSource source )
-  {
-    this.source = source;
-    cache = new HashMap<Integer, Double>();
-  }
-
-  @Override
-  public String description() {
-    return "Cached["+source.description()+"]";
-  }
-
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    final int base = readerContext.docBase;
-    final FunctionValues vals = source.getValues(context,readerContext);
-    return new FunctionValues() {
-
-      @Override
-      public double doubleVal(int doc) {
-        Integer key = Integer.valueOf( base+doc );
-        Double v = cache.get( key );
-        if( v == null ) {
-          v = Double.valueOf( vals.doubleVal(doc) );
-          cache.put( key, v );
-        }
-        return v.doubleValue();
-      }
-
-      @Override
-      public float floatVal(int doc) {
-        return (float)doubleVal(doc);
-      }
-
-      @Override
-      public String toString(int doc) {
-        return doubleVal(doc)+"";
-      }
-    };
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    CachingDoubleValueSource rhs = (CachingDoubleValueSource) obj;
-    return source.equals( rhs.source );
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(61, 23).
-      append(source).
-      toHashCode();
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/NumericFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/NumericFieldInfo.java
deleted file mode 100644
index 6991b9a..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/NumericFieldInfo.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import org.apache.lucene.document.DoubleField;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.IndexableField;
-
-/**
- * Hold some of the parameters used by solr...
- */
-public class NumericFieldInfo {
-  public int precisionStep = 8; // same as solr default
-  public boolean store = true;
-  public boolean index = true;
-
-  public void setPrecisionStep( int p ) {
-    precisionStep = p;
-    if (precisionStep<=0 || precisionStep>=64)
-      precisionStep=Integer.MAX_VALUE;
-  }
-
-  public IndexableField createDouble( String name, double v ) {
-    if (!store && !index)
-      throw new IllegalArgumentException("field must be indexed or stored");
-
-    FieldType fieldType = new FieldType(DoubleField.TYPE);
-    fieldType.setStored(store);
-    fieldType.setIndexed(index);
-    fieldType.setNumericPrecisionStep(precisionStep);
-    return new DoubleField(name,v,fieldType);
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java
deleted file mode 100644
index c105eea..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCache.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.spatial4j.core.shape.Shape;
-
-public class ShapeFieldCache<T extends Shape> {
-  private List<T>[] cache;
-  public int defaultLength;
-
-  @SuppressWarnings({"unchecked"})
-  public ShapeFieldCache( int length, int defaultLength ) {
-    cache = new List[length];
-    this.defaultLength= defaultLength;
-  }
-
-  public void add( int docid, T s ) {
-    List<T> list = cache[docid];
-    if( list == null ) {
-      list = cache[docid] = new ArrayList<T>(defaultLength);
-    }
-    list.add( s );
-  }
-
-  public List<T> getShapes( int docid ) {
-    return cache[docid];
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java
deleted file mode 100644
index 4282132..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ShapeFieldCacheProvider.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import org.apache.lucene.index.*;
-import org.apache.lucene.search.DocIdSetIterator;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.util.BytesRef;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.util.WeakHashMap;
-
-
-public abstract class ShapeFieldCacheProvider<T extends Shape> {
-  static final Logger log = LoggerFactory.getLogger(ShapeFieldCacheProvider.class);
-
-  // it may be a List<T> or T
-  WeakHashMap<IndexReader, ShapeFieldCache<T>> sidx = new WeakHashMap<IndexReader, ShapeFieldCache<T>>();
-
-  protected final int defaultSize;
-  protected final String shapeField;
-
-  public ShapeFieldCacheProvider(String shapeField, int defaultSize) {
-    this.shapeField = shapeField;
-    this.defaultSize = defaultSize;
-  }
-
-  protected abstract T readShape( BytesRef term );
-
-  public synchronized ShapeFieldCache<T> getCache(AtomicReader reader) throws IOException {
-    ShapeFieldCache<T> idx = sidx.get(reader);
-    if (idx != null) {
-      return idx;
-    }
-    long startTime = System.currentTimeMillis();
-
-    log.info("Building Cache [" + reader.maxDoc() + "]");
-    idx = new ShapeFieldCache<T>(reader.maxDoc(),defaultSize);
-    int count = 0;
-    DocsEnum docs = null;
-    Terms terms = reader.terms(shapeField);
-    TermsEnum te = null;
-    if (terms != null) {
-      te = terms.iterator(te);
-      BytesRef term = te.next();
-      while (term != null) {
-        T shape = readShape(term);
-        if( shape != null ) {
-          docs = te.docs(null, docs, false);
-          Integer docid = docs.nextDoc();
-          while (docid != DocIdSetIterator.NO_MORE_DOCS) {
-            idx.add( docid, shape );
-            docid = docs.nextDoc();
-            count++;
-          }
-        }
-        term = te.next();
-      }
-    }
-    sidx.put(reader, idx);
-    long elapsed = System.currentTimeMillis() - startTime;
-    log.info("Cached: [" + count + " in " + elapsed + "ms] " + idx);
-    return idx;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/StringListTokenizer.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/StringListTokenizer.java
deleted file mode 100644
index 6fb4c1b..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/StringListTokenizer.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Iterator;
-
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-
-/**
- * Put a list of strings directly into the token stream
- */
-public final class StringListTokenizer extends TokenStream {
-
-  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-  private final Iterable<String> tokens;
-  private Iterator<String> iter = null;
-
-  public StringListTokenizer(Iterable<String> tokens) {
-    this.tokens = tokens;
-  }
-
-  @Override
-  public boolean incrementToken() {
-    if (iter.hasNext()) {
-      clearAttributes();
-      String t = iter.next();
-      termAtt.append(t);
-      return true;
-    }
-    return false;
-  }
-
-  @Override
-  public void reset() throws IOException {
-    super.reset();
-    iter = tokens.iterator();
-  }
-}
\ No newline at end of file
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/TruncateFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/TruncateFilter.java
deleted file mode 100644
index dd8cd96..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/TruncateFilter.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-
-public class TruncateFilter extends TokenFilter {
-
-  private final int maxTokenLength;
-
-  private final CharTermAttribute termAttr = addAttribute(CharTermAttribute.class);
-
-  public TruncateFilter(TokenStream in, int maxTokenLength) {
-    super(in);
-    this.maxTokenLength = maxTokenLength;
-  }
-
-  @Override
-  public final boolean incrementToken() throws IOException {
-    if (!input.incrementToken()) {
-      return false;
-    }
-
-    if (termAttr.length() > maxTokenLength) {
-      termAttr.setLength(maxTokenLength);
-    }
-    return true;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ValueSourceFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ValueSourceFilter.java
deleted file mode 100644
index 5242cbc..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/util/ValueSourceFilter.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.util;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.FilteredDocIdSet;
-import org.apache.lucene.util.Bits;
-
-import java.io.IOException;
-
-public class ValueSourceFilter extends Filter {
-
-  final Filter startingFilter;
-  final ValueSource source;
-  final double min;
-  final double max;
-
-  public ValueSourceFilter( Filter startingFilter, ValueSource source, double min, double max )
-  {
-    if (startingFilter == null) {
-      throw new IllegalArgumentException("please provide a non-null startingFilter; you can use QueryWrapperFilter(MatchAllDocsQuery) as a no-op filter");
-    }
-    this.startingFilter = startingFilter;
-    this.source = source;
-    this.min = min;
-    this.max = max;
-  }
-
-  @Override
-  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {
-    final FunctionValues values = source.getValues( null, context );
-    return new FilteredDocIdSet(startingFilter.getDocIdSet(context, acceptDocs)) {
-      @Override
-      public boolean match(int doc) {
-        double val = values.doubleVal( doc );
-        return val > min && val < max;
-      }
-    };
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java
deleted file mode 100644
index 26af994..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/DistanceValueSource.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.vector;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-import org.apache.lucene.index.AtomicReader;
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.queries.function.FunctionValues;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.FieldCache.DoubleParser;
-import com.spatial4j.core.distance.DistanceCalculator;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.simple.PointImpl;
-import org.apache.lucene.util.Bits;
-
-import java.io.IOException;
-import java.util.Map;
-
-/**
- *
- * An implementation of the Lucene ValueSource model to support spatial relevance ranking.
- *
- */
-public class DistanceValueSource extends ValueSource {
-
-  private final TwoDoublesFieldInfo fields;
-  private final DistanceCalculator calculator;
-  private final Point from;
-  private final DoubleParser parser;
-
-  /**
-   * Constructor.
-   */
-  public DistanceValueSource(Point from, DistanceCalculator calc, TwoDoublesFieldInfo fields, DoubleParser parser) {
-    this.from = from;
-    this.fields = fields;
-    this.calculator = calc;
-    this.parser = parser;
-  }
-
-  /**
-   * Returns the ValueSource description.
-   */
-  @Override
-  public String description() {
-    return "DistanceValueSource("+calculator+")";
-  }
-
-
-  /**
-   * Returns the FunctionValues used by the function query.
-   */
-  @Override
-  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    AtomicReader reader = readerContext.reader();
-
-    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);
-    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);
-    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());
-    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());
-
-    return new FunctionValues() {
-      @Override
-      public float floatVal(int doc) {
-        return (float) doubleVal(doc);
-      }
-
-      @Override
-      public double doubleVal(int doc) {
-        // make sure it has minX and area
-        if (validX.get(doc) && validY.get(doc)) {
-          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );
-          return calculator.distance(from, pt);
-        }
-        return 0;
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + "=" + floatVal(doc);
-      }
-    };
-  }
-
-  /**
-   * Determines if this ValueSource is equal to another.
-   * @param obj the ValueSource to compare
-   * @return <code>true</code> if the two objects are based upon the same query envelope
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (obj == null) { return false; }
-    if (obj == this) { return true; }
-    if (obj.getClass() != getClass()) {
-      return false;
-    }
-    DistanceValueSource rhs = (DistanceValueSource) obj;
-    return new EqualsBuilder()
-                  .append(calculator, rhs.calculator)
-                  .append(from, rhs.from)
-                  .append(fields, rhs.fields)
-                  .isEquals();
-  }
-
-  @Override
-  public int hashCode() {
-    return new HashCodeBuilder(59, 7).
-        append(calculator).
-        append(from).
-        append(fields).
-        toHashCode();
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesFieldInfo.java
deleted file mode 100644
index 3ae1881..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesFieldInfo.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.vector;
-
-import org.apache.lucene.spatial.strategy.SpatialFieldInfo;
-
-public class TwoDoublesFieldInfo implements SpatialFieldInfo {
-
-  public static final String SUFFIX_X = "__x";
-  public static final String SUFFIX_Y = "__y";
-
-  private final String fieldName;
-  private final String fieldNameX;
-  private final String fieldNameY;
-
-  public TwoDoublesFieldInfo(String fieldNamePrefix) {
-    fieldName = fieldNamePrefix;
-    fieldNameX = fieldNamePrefix + SUFFIX_X;
-    fieldNameY = fieldNamePrefix + SUFFIX_Y;
-  }
-
-  public String getFieldName() {
-    return fieldName;
-  }
-
-  public String getFieldNameX() {
-    return fieldNameX;
-  }
-
-  public String getFieldNameY() {
-    return fieldNameY;
-  }
-}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java
deleted file mode 100644
index 9d6ad18..0000000
--- a/modules/spatial/src/java/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategy.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.vector;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.queries.function.FunctionQuery;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.*;
-import org.apache.lucene.search.FieldCache.DoubleParser;
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.exception.InvalidShapeException;
-import com.spatial4j.core.exception.UnsupportedSpatialOperation;
-import com.spatial4j.core.query.SpatialArgs;
-import com.spatial4j.core.query.SpatialOperation;
-import com.spatial4j.core.shape.Circle;
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Rectangle;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.strategy.SpatialStrategy;
-import org.apache.lucene.spatial.strategy.util.CachingDoubleValueSource;
-import org.apache.lucene.spatial.strategy.util.NumericFieldInfo;
-import org.apache.lucene.spatial.strategy.util.ValueSourceFilter;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-
-public class TwoDoublesStrategy extends SpatialStrategy<TwoDoublesFieldInfo> {
-
-  static final Logger log = LoggerFactory.getLogger(TwoDoublesStrategy.class);
-
-  private final NumericFieldInfo finfo;
-  private final DoubleParser parser;
-
-  public TwoDoublesStrategy(SpatialContext ctx, NumericFieldInfo finfo, DoubleParser parser) {
-    super(ctx);
-    this.finfo = finfo;
-    this.parser = parser;
-  }
-
-  @Override
-  public boolean isPolyField() {
-    return true;
-  }
-
-  @Override
-  public IndexableField[] createFields(TwoDoublesFieldInfo fieldInfo,
-      Shape shape, boolean index, boolean store) {
-    if( shape instanceof Point ) {
-      Point point = (Point)shape;
-
-      IndexableField[] f = new IndexableField[(index ? 2 : 0) + (store ? 1 : 0)];
-      if (index) {
-        f[0] = finfo.createDouble( fieldInfo.getFieldNameX(), point.getX() );
-        f[1] = finfo.createDouble( fieldInfo.getFieldNameY(), point.getY() );
-      }
-      if(store) {
-        FieldType customType = new FieldType();
-        customType.setStored(true);
-        f[f.length-1] = new Field( fieldInfo.getFieldName(), ctx.toString( shape ), customType );
-      }
-      return f;
-    }
-    if( !ignoreIncompatibleGeometry ) {
-      throw new IllegalArgumentException( "TwoDoublesStrategy can not index: "+shape );
-    }
-    return null;
-  }
-
-  @Override
-  public IndexableField createField(TwoDoublesFieldInfo indexInfo, Shape shape,
-      boolean index, boolean store) {
-    throw new UnsupportedOperationException("Point is poly field");
-  }
-
-  @Override
-  public ValueSource makeValueSource(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
-    Point p = args.getShape().getCenter();
-    return new DistanceValueSource(p, ctx.getDistCalc(), fieldInfo, parser);
-  }
-
-  @Override
-  public Filter makeFilter(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
-    if( args.getShape() instanceof Circle) {
-      if( SpatialOperation.is( args.getOperation(),
-          SpatialOperation.Intersects,
-          SpatialOperation.IsWithin )) {
-        Circle circle = (Circle)args.getShape();
-        Query bbox = makeWithin(circle.getBoundingBox(), fieldInfo);
-
-        // Make the ValueSource
-        ValueSource valueSource = makeValueSource(args, fieldInfo);
-
-        return new ValueSourceFilter(
-            new QueryWrapperFilter( bbox ), valueSource, 0, circle.getDistance() );
-      }
-    }
-    return new QueryWrapperFilter( makeQuery(args, fieldInfo) );
-  }
-
-  @Override
-  public Query makeQuery(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
-    // For starters, just limit the bbox
-    Shape shape = args.getShape();
-    if (!(shape instanceof Rectangle)) {
-      throw new InvalidShapeException("A rectangle is the only supported at this time, not "+shape.getClass());//TODO
-    }
-    Rectangle bbox = (Rectangle) shape;
-    if (bbox.getCrossesDateLine()) {
-      throw new UnsupportedOperationException( "Crossing dateline not yet supported" );
-    }
-
-    ValueSource valueSource = null;
-
-    Query spatial = null;
-    SpatialOperation op = args.getOperation();
-
-    if( SpatialOperation.is( op,
-        SpatialOperation.BBoxWithin,
-        SpatialOperation.BBoxIntersects ) ) {
-        spatial = makeWithin(bbox, fieldInfo);
-    }
-    else if( SpatialOperation.is( op,
-      SpatialOperation.Intersects,
-      SpatialOperation.IsWithin ) ) {
-      spatial = makeWithin(bbox, fieldInfo);
-      if( args.getShape() instanceof Circle) {
-        Circle circle = (Circle)args.getShape();
-
-        // Make the ValueSource
-        valueSource = makeValueSource(args, fieldInfo);
-
-        ValueSourceFilter vsf = new ValueSourceFilter(
-            new QueryWrapperFilter( spatial ), valueSource, 0, circle.getDistance() );
-
-        spatial = new FilteredQuery( new MatchAllDocsQuery(), vsf );
-      }
-    }
-    else if( op == SpatialOperation.IsDisjointTo ) {
-      spatial =  makeDisjoint(bbox, fieldInfo);
-    }
-
-    if( spatial == null ) {
-      throw new UnsupportedSpatialOperation(args.getOperation());
-    }
-
-    try {
-      if( valueSource != null ) {
-        valueSource = new CachingDoubleValueSource(valueSource);
-      }
-      else {
-        valueSource = makeValueSource(args, fieldInfo);
-      }
-      Query spatialRankingQuery = new FunctionQuery(valueSource);
-      BooleanQuery bq = new BooleanQuery();
-      bq.add(spatial,BooleanClause.Occur.MUST);
-      bq.add(spatialRankingQuery,BooleanClause.Occur.MUST);
-      return bq;
-    } catch(Exception ex) {
-      log.warn("error making score", ex);
-    }
-    return spatial;
-  }
-
-  /**
-   * Constructs a query to retrieve documents that fully contain the input envelope.
-   * @return the spatial query
-   */
-  private Query makeWithin(Rectangle bbox, TwoDoublesFieldInfo fieldInfo) {
-    Query qX = NumericRangeQuery.newDoubleRange(
-      fieldInfo.getFieldNameX(),
-      finfo.precisionStep,
-      bbox.getMinX(),
-      bbox.getMaxX(),
-      true,
-      true);
-    Query qY = NumericRangeQuery.newDoubleRange(
-      fieldInfo.getFieldNameY(),
-      finfo.precisionStep,
-      bbox.getMinY(),
-      bbox.getMaxY(),
-      true,
-      true);
-
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(qX,BooleanClause.Occur.MUST);
-    bq.add(qY,BooleanClause.Occur.MUST);
-    return bq;
-  }
-
-  /**
-   * Constructs a query to retrieve documents that fully contain the input envelope.
-   * @return the spatial query
-   */
-  Query makeDisjoint(Rectangle bbox, TwoDoublesFieldInfo fieldInfo) {
-    Query qX = NumericRangeQuery.newDoubleRange(
-      fieldInfo.getFieldNameX(),
-      finfo.precisionStep,
-      bbox.getMinX(),
-      bbox.getMaxX(),
-      true,
-      true);
-    Query qY = NumericRangeQuery.newDoubleRange(
-      fieldInfo.getFieldNameY(),
-      finfo.precisionStep,
-      bbox.getMinY(),
-      bbox.getMaxY(),
-      true,
-      true);
-
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(qX,BooleanClause.Occur.MUST_NOT);
-    bq.add(qY,BooleanClause.Occur.MUST_NOT);
-    return bq;
-  }
-}
-
-
-
-
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/CachedDistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/CachedDistanceValueSource.java
new file mode 100644
index 0000000..af72598
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/CachedDistanceValueSource.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.shape.Point;
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/**
+ *
+ * An implementation of the Lucene ValueSource model to support spatial relevance ranking.
+ *
+ */
+public class CachedDistanceValueSource extends ValueSource {
+
+  private final ShapeFieldCacheProvider<Point> provider;
+  private final DistanceCalculator calculator;
+  private final Point from;
+
+  public CachedDistanceValueSource(Point from, DistanceCalculator calc, ShapeFieldCacheProvider<Point> provider) {
+    this.from = from;
+    this.provider = provider;
+    this.calculator = calc;
+  }
+
+  @Override
+  public String description() {
+    return "DistanceValueSource("+calculator+")";
+  }
+
+  @Override
+  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final ShapeFieldCache<Point> cache =
+      provider.getCache(readerContext.reader());
+
+    return new FunctionValues() {
+      @Override
+      public float floatVal(int doc) {
+        return (float) doubleVal(doc);
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        List<Point> vals = cache.getShapes( doc );
+        if( vals != null ) {
+          double v = calculator.distance(from, vals.get(0));
+          for( int i=1; i<vals.size(); i++ ) {
+            v = Math.min(v, calculator.distance(from, vals.get(i)));
+          }
+          return v;
+        }
+        return Double.NaN; // ?? maybe max?
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + "=" + floatVal(doc);
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    CachedDistanceValueSource rhs = (CachedDistanceValueSource) obj;
+    return new EqualsBuilder()
+                  .append(calculator, rhs.calculator)
+                  .append(from, rhs.from)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(31, 97).
+        append(calculator).
+        append(from).
+        toHashCode();
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/CachingDoubleValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/CachingDoubleValueSource.java
new file mode 100644
index 0000000..0318901
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/CachingDoubleValueSource.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class CachingDoubleValueSource extends ValueSource {
+
+  final ValueSource source;
+  final Map<Integer, Double> cache;
+
+  public CachingDoubleValueSource( ValueSource source )
+  {
+    this.source = source;
+    cache = new HashMap<Integer, Double>();
+  }
+
+  @Override
+  public String description() {
+    return "Cached["+source.description()+"]";
+  }
+
+  @Override
+  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final int base = readerContext.docBase;
+    final FunctionValues vals = source.getValues(context,readerContext);
+    return new FunctionValues() {
+
+      @Override
+      public double doubleVal(int doc) {
+        Integer key = Integer.valueOf( base+doc );
+        Double v = cache.get( key );
+        if( v == null ) {
+          v = Double.valueOf( vals.doubleVal(doc) );
+          cache.put( key, v );
+        }
+        return v.doubleValue();
+      }
+
+      @Override
+      public float floatVal(int doc) {
+        return (float)doubleVal(doc);
+      }
+
+      @Override
+      public String toString(int doc) {
+        return doubleVal(doc)+"";
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    CachingDoubleValueSource rhs = (CachingDoubleValueSource) obj;
+    return source.equals( rhs.source );
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(61, 23).
+      append(source).
+      toHashCode();
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/NumericFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/NumericFieldInfo.java
new file mode 100644
index 0000000..1300aaf
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/NumericFieldInfo.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import org.apache.lucene.document.DoubleField;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.IndexableField;
+
+/**
+ * Hold some of the parameters used by solr...
+ */
+public class NumericFieldInfo {
+  public int precisionStep = 8; // same as solr default
+  public boolean store = true;
+  public boolean index = true;
+
+  public void setPrecisionStep( int p ) {
+    precisionStep = p;
+    if (precisionStep<=0 || precisionStep>=64)
+      precisionStep=Integer.MAX_VALUE;
+  }
+
+  public IndexableField createDouble( String name, double v ) {
+    if (!store && !index)
+      throw new IllegalArgumentException("field must be indexed or stored");
+
+    FieldType fieldType = new FieldType(DoubleField.TYPE);
+    fieldType.setStored(store);
+    fieldType.setIndexed(index);
+    fieldType.setNumericPrecisionStep(precisionStep);
+    return new DoubleField(name,v,fieldType);
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCache.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCache.java
new file mode 100644
index 0000000..45b21ec
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCache.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import com.spatial4j.core.shape.Shape;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ShapeFieldCache<T extends Shape> {
+  private List<T>[] cache;
+  public int defaultLength;
+
+  @SuppressWarnings({"unchecked"})
+  public ShapeFieldCache( int length, int defaultLength ) {
+    cache = new List[length];
+    this.defaultLength= defaultLength;
+  }
+
+  public void add( int docid, T s ) {
+    List<T> list = cache[docid];
+    if( list == null ) {
+      list = cache[docid] = new ArrayList<T>(defaultLength);
+    }
+    list.add( s );
+  }
+
+  public List<T> getShapes( int docid ) {
+    return cache[docid];
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCacheProvider.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCacheProvider.java
new file mode 100644
index 0000000..7f0c4e1
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/ShapeFieldCacheProvider.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.index.*;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.BytesRef;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.util.WeakHashMap;
+
+
+public abstract class ShapeFieldCacheProvider<T extends Shape> {
+  static final Logger log = LoggerFactory.getLogger(ShapeFieldCacheProvider.class);
+
+  // it may be a List<T> or T
+  WeakHashMap<IndexReader, ShapeFieldCache<T>> sidx = new WeakHashMap<IndexReader, ShapeFieldCache<T>>();
+
+  protected final int defaultSize;
+  protected final String shapeField;
+
+  public ShapeFieldCacheProvider(String shapeField, int defaultSize) {
+    this.shapeField = shapeField;
+    this.defaultSize = defaultSize;
+  }
+
+  protected abstract T readShape( BytesRef term );
+
+  public synchronized ShapeFieldCache<T> getCache(AtomicReader reader) throws IOException {
+    ShapeFieldCache<T> idx = sidx.get(reader);
+    if (idx != null) {
+      return idx;
+    }
+    long startTime = System.currentTimeMillis();
+
+    log.info("Building Cache [" + reader.maxDoc() + "]");
+    idx = new ShapeFieldCache<T>(reader.maxDoc(),defaultSize);
+    int count = 0;
+    DocsEnum docs = null;
+    Terms terms = reader.terms(shapeField);
+    TermsEnum te = null;
+    if (terms != null) {
+      te = terms.iterator(te);
+      BytesRef term = te.next();
+      while (term != null) {
+        T shape = readShape(term);
+        if( shape != null ) {
+          docs = te.docs(null, docs, false);
+          Integer docid = docs.nextDoc();
+          while (docid != DocIdSetIterator.NO_MORE_DOCS) {
+            idx.add( docid, shape );
+            docid = docs.nextDoc();
+            count++;
+          }
+        }
+        term = te.next();
+      }
+    }
+    sidx.put(reader, idx);
+    long elapsed = System.currentTimeMillis() - startTime;
+    log.info("Cached: [" + count + " in " + elapsed + "ms] " + idx);
+    return idx;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/StringListTokenizer.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/StringListTokenizer.java
new file mode 100644
index 0000000..6c2ab43
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/StringListTokenizer.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+/**
+ * Put a list of strings directly into the token stream
+ */
+public final class StringListTokenizer extends TokenStream {
+
+  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+  private final Iterable<String> tokens;
+  private Iterator<String> iter = null;
+
+  public StringListTokenizer(Iterable<String> tokens) {
+    this.tokens = tokens;
+  }
+
+  @Override
+  public boolean incrementToken() {
+    if (iter.hasNext()) {
+      clearAttributes();
+      String t = iter.next();
+      termAtt.append(t);
+      return true;
+    }
+    return false;
+  }
+
+  @Override
+  public void reset() throws IOException {
+    super.reset();
+    iter = tokens.iterator();
+  }
+}
\ No newline at end of file
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/TruncateFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/TruncateFilter.java
new file mode 100644
index 0000000..bc01443
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/TruncateFilter.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+
+import java.io.IOException;
+
+public class TruncateFilter extends TokenFilter {
+
+  private final int maxTokenLength;
+
+  private final CharTermAttribute termAttr = addAttribute(CharTermAttribute.class);
+
+  public TruncateFilter(TokenStream in, int maxTokenLength) {
+    super(in);
+    this.maxTokenLength = maxTokenLength;
+  }
+
+  @Override
+  public final boolean incrementToken() throws IOException {
+    if (!input.incrementToken()) {
+      return false;
+    }
+
+    if (termAttr.length() > maxTokenLength) {
+      termAttr.setLength(maxTokenLength);
+    }
+    return true;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java b/modules/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java
new file mode 100644
index 0000000..57130de
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.util;
+
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.search.FilteredDocIdSet;
+import org.apache.lucene.util.Bits;
+
+import java.io.IOException;
+
+public class ValueSourceFilter extends Filter {
+
+  final Filter startingFilter;
+  final ValueSource source;
+  final double min;
+  final double max;
+
+  public ValueSourceFilter( Filter startingFilter, ValueSource source, double min, double max )
+  {
+    if (startingFilter == null) {
+      throw new IllegalArgumentException("please provide a non-null startingFilter; you can use QueryWrapperFilter(MatchAllDocsQuery) as a no-op filter");
+    }
+    this.startingFilter = startingFilter;
+    this.source = source;
+    this.min = min;
+    this.max = max;
+  }
+
+  @Override
+  public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) throws IOException {
+    final FunctionValues values = source.getValues( null, context );
+    return new FilteredDocIdSet(startingFilter.getDocIdSet(context, acceptDocs)) {
+      @Override
+      public boolean match(int doc) {
+        double val = values.doubleVal( doc );
+        return val > min && val < max;
+      }
+    };
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java b/modules/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java
new file mode 100644
index 0000000..f50e0bb
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.vector;
+
+import com.spatial4j.core.distance.DistanceCalculator;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.simple.PointImpl;
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+import org.apache.lucene.index.AtomicReader;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.search.FieldCache.DoubleParser;
+import org.apache.lucene.util.Bits;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ *
+ * An implementation of the Lucene ValueSource model to support spatial relevance ranking.
+ *
+ */
+public class DistanceValueSource extends ValueSource {
+
+  private final TwoDoublesFieldInfo fields;
+  private final DistanceCalculator calculator;
+  private final Point from;
+  private final DoubleParser parser;
+
+  /**
+   * Constructor.
+   */
+  public DistanceValueSource(Point from, DistanceCalculator calc, TwoDoublesFieldInfo fields, DoubleParser parser) {
+    this.from = from;
+    this.fields = fields;
+    this.calculator = calc;
+    this.parser = parser;
+  }
+
+  /**
+   * Returns the ValueSource description.
+   */
+  @Override
+  public String description() {
+    return "DistanceValueSource("+calculator+")";
+  }
+
+
+  /**
+   * Returns the FunctionValues used by the function query.
+   */
+  @Override
+  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    AtomicReader reader = readerContext.reader();
+
+    final double[] ptX = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameX(), true);
+    final double[] ptY = FieldCache.DEFAULT.getDoubles(reader, fields.getFieldNameY(), true);
+    final Bits validX =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameX());
+    final Bits validY =  FieldCache.DEFAULT.getDocsWithField(reader, fields.getFieldNameY());
+
+    return new FunctionValues() {
+      @Override
+      public float floatVal(int doc) {
+        return (float) doubleVal(doc);
+      }
+
+      @Override
+      public double doubleVal(int doc) {
+        // make sure it has minX and area
+        if (validX.get(doc) && validY.get(doc)) {
+          PointImpl pt = new PointImpl( ptX[doc],  ptY[doc] );
+          return calculator.distance(from, pt);
+        }
+        return 0;
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + "=" + floatVal(doc);
+      }
+    };
+  }
+
+  /**
+   * Determines if this ValueSource is equal to another.
+   * @param obj the ValueSource to compare
+   * @return <code>true</code> if the two objects are based upon the same query envelope
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == null) { return false; }
+    if (obj == this) { return true; }
+    if (obj.getClass() != getClass()) {
+      return false;
+    }
+    DistanceValueSource rhs = (DistanceValueSource) obj;
+    return new EqualsBuilder()
+                  .append(calculator, rhs.calculator)
+                  .append(from, rhs.from)
+                  .append(fields, rhs.fields)
+                  .isEquals();
+  }
+
+  @Override
+  public int hashCode() {
+    return new HashCodeBuilder(59, 7).
+        append(calculator).
+        append(from).
+        append(fields).
+        toHashCode();
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesFieldInfo.java b/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesFieldInfo.java
new file mode 100644
index 0000000..7801d5a
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesFieldInfo.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.vector;
+
+import org.apache.lucene.spatial.SpatialFieldInfo;
+
+public class TwoDoublesFieldInfo implements SpatialFieldInfo {
+
+  public static final String SUFFIX_X = "__x";
+  public static final String SUFFIX_Y = "__y";
+
+  private final String fieldName;
+  private final String fieldNameX;
+  private final String fieldNameY;
+
+  public TwoDoublesFieldInfo(String fieldNamePrefix) {
+    fieldName = fieldNamePrefix;
+    fieldNameX = fieldNamePrefix + SUFFIX_X;
+    fieldNameY = fieldNamePrefix + SUFFIX_Y;
+  }
+
+  public String getFieldName() {
+    return fieldName;
+  }
+
+  public String getFieldNameX() {
+    return fieldNameX;
+  }
+
+  public String getFieldNameY() {
+    return fieldNameY;
+  }
+}
diff --git a/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java b/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java
new file mode 100644
index 0000000..1880a0c
--- /dev/null
+++ b/modules/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java
@@ -0,0 +1,236 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.vector;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.exception.InvalidShapeException;
+import com.spatial4j.core.exception.UnsupportedSpatialOperation;
+import com.spatial4j.core.query.SpatialArgs;
+import com.spatial4j.core.query.SpatialOperation;
+import com.spatial4j.core.shape.Circle;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.*;
+import org.apache.lucene.search.FieldCache.DoubleParser;
+import org.apache.lucene.spatial.SpatialStrategy;
+import org.apache.lucene.spatial.util.CachingDoubleValueSource;
+import org.apache.lucene.spatial.util.NumericFieldInfo;
+import org.apache.lucene.spatial.util.ValueSourceFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+public class TwoDoublesStrategy extends SpatialStrategy<TwoDoublesFieldInfo> {
+
+  static final Logger log = LoggerFactory.getLogger(TwoDoublesStrategy.class);
+
+  private final NumericFieldInfo finfo;
+  private final DoubleParser parser;
+
+  public TwoDoublesStrategy(SpatialContext ctx, NumericFieldInfo finfo, DoubleParser parser) {
+    super(ctx);
+    this.finfo = finfo;
+    this.parser = parser;
+  }
+
+  @Override
+  public boolean isPolyField() {
+    return true;
+  }
+
+  @Override
+  public IndexableField[] createFields(TwoDoublesFieldInfo fieldInfo,
+      Shape shape, boolean index, boolean store) {
+    if( shape instanceof Point ) {
+      Point point = (Point)shape;
+
+      IndexableField[] f = new IndexableField[(index ? 2 : 0) + (store ? 1 : 0)];
+      if (index) {
+        f[0] = finfo.createDouble( fieldInfo.getFieldNameX(), point.getX() );
+        f[1] = finfo.createDouble( fieldInfo.getFieldNameY(), point.getY() );
+      }
+      if(store) {
+        FieldType customType = new FieldType();
+        customType.setStored(true);
+        f[f.length-1] = new Field( fieldInfo.getFieldName(), ctx.toString( shape ), customType );
+      }
+      return f;
+    }
+    if( !ignoreIncompatibleGeometry ) {
+      throw new IllegalArgumentException( "TwoDoublesStrategy can not index: "+shape );
+    }
+    return null;
+  }
+
+  @Override
+  public IndexableField createField(TwoDoublesFieldInfo indexInfo, Shape shape,
+      boolean index, boolean store) {
+    throw new UnsupportedOperationException("Point is poly field");
+  }
+
+  @Override
+  public ValueSource makeValueSource(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
+    Point p = args.getShape().getCenter();
+    return new DistanceValueSource(p, ctx.getDistCalc(), fieldInfo, parser);
+  }
+
+  @Override
+  public Filter makeFilter(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
+    if( args.getShape() instanceof Circle) {
+      if( SpatialOperation.is( args.getOperation(),
+          SpatialOperation.Intersects,
+          SpatialOperation.IsWithin )) {
+        Circle circle = (Circle)args.getShape();
+        Query bbox = makeWithin(circle.getBoundingBox(), fieldInfo);
+
+        // Make the ValueSource
+        ValueSource valueSource = makeValueSource(args, fieldInfo);
+
+        return new ValueSourceFilter(
+            new QueryWrapperFilter( bbox ), valueSource, 0, circle.getDistance() );
+      }
+    }
+    return new QueryWrapperFilter( makeQuery(args, fieldInfo) );
+  }
+
+  @Override
+  public Query makeQuery(SpatialArgs args, TwoDoublesFieldInfo fieldInfo) {
+    // For starters, just limit the bbox
+    Shape shape = args.getShape();
+    if (!(shape instanceof Rectangle)) {
+      throw new InvalidShapeException("A rectangle is the only supported at this time, not "+shape.getClass());//TODO
+    }
+    Rectangle bbox = (Rectangle) shape;
+    if (bbox.getCrossesDateLine()) {
+      throw new UnsupportedOperationException( "Crossing dateline not yet supported" );
+    }
+
+    ValueSource valueSource = null;
+
+    Query spatial = null;
+    SpatialOperation op = args.getOperation();
+
+    if( SpatialOperation.is( op,
+        SpatialOperation.BBoxWithin,
+        SpatialOperation.BBoxIntersects ) ) {
+        spatial = makeWithin(bbox, fieldInfo);
+    }
+    else if( SpatialOperation.is( op,
+      SpatialOperation.Intersects,
+      SpatialOperation.IsWithin ) ) {
+      spatial = makeWithin(bbox, fieldInfo);
+      if( args.getShape() instanceof Circle) {
+        Circle circle = (Circle)args.getShape();
+
+        // Make the ValueSource
+        valueSource = makeValueSource(args, fieldInfo);
+
+        ValueSourceFilter vsf = new ValueSourceFilter(
+            new QueryWrapperFilter( spatial ), valueSource, 0, circle.getDistance() );
+
+        spatial = new FilteredQuery( new MatchAllDocsQuery(), vsf );
+      }
+    }
+    else if( op == SpatialOperation.IsDisjointTo ) {
+      spatial =  makeDisjoint(bbox, fieldInfo);
+    }
+
+    if( spatial == null ) {
+      throw new UnsupportedSpatialOperation(args.getOperation());
+    }
+
+    try {
+      if( valueSource != null ) {
+        valueSource = new CachingDoubleValueSource(valueSource);
+      }
+      else {
+        valueSource = makeValueSource(args, fieldInfo);
+      }
+      Query spatialRankingQuery = new FunctionQuery(valueSource);
+      BooleanQuery bq = new BooleanQuery();
+      bq.add(spatial,BooleanClause.Occur.MUST);
+      bq.add(spatialRankingQuery,BooleanClause.Occur.MUST);
+      return bq;
+    } catch(Exception ex) {
+      log.warn("error making score", ex);
+    }
+    return spatial;
+  }
+
+  /**
+   * Constructs a query to retrieve documents that fully contain the input envelope.
+   * @return the spatial query
+   */
+  private Query makeWithin(Rectangle bbox, TwoDoublesFieldInfo fieldInfo) {
+    Query qX = NumericRangeQuery.newDoubleRange(
+      fieldInfo.getFieldNameX(),
+      finfo.precisionStep,
+      bbox.getMinX(),
+      bbox.getMaxX(),
+      true,
+      true);
+    Query qY = NumericRangeQuery.newDoubleRange(
+      fieldInfo.getFieldNameY(),
+      finfo.precisionStep,
+      bbox.getMinY(),
+      bbox.getMaxY(),
+      true,
+      true);
+
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(qX,BooleanClause.Occur.MUST);
+    bq.add(qY,BooleanClause.Occur.MUST);
+    return bq;
+  }
+
+  /**
+   * Constructs a query to retrieve documents that fully contain the input envelope.
+   * @return the spatial query
+   */
+  Query makeDisjoint(Rectangle bbox, TwoDoublesFieldInfo fieldInfo) {
+    Query qX = NumericRangeQuery.newDoubleRange(
+      fieldInfo.getFieldNameX(),
+      finfo.precisionStep,
+      bbox.getMinX(),
+      bbox.getMaxX(),
+      true,
+      true);
+    Query qY = NumericRangeQuery.newDoubleRange(
+      fieldInfo.getFieldNameY(),
+      finfo.precisionStep,
+      bbox.getMinY(),
+      bbox.getMaxY(),
+      true,
+      true);
+
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(qX,BooleanClause.Occur.MUST_NOT);
+    bq.add(qY,BooleanClause.Occur.MUST_NOT);
+    return bq;
+  }
+}
+
+
+
+
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
index 816001c..9c7d73b 100644
--- a/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
@@ -18,18 +18,16 @@
 package org.apache.lucene.spatial;
 
 
-import junit.framework.Assert;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexableField;
 import com.spatial4j.core.context.SpatialContext;
 import com.spatial4j.core.io.sample.SampleData;
 import com.spatial4j.core.io.sample.SampleDataReader;
 import com.spatial4j.core.query.SpatialArgsParser;
 import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.strategy.SpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.SpatialStrategy;
+import junit.framework.Assert;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexableField;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/prefix/BaseRecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
new file mode 100644
index 0000000..bf989e6
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.context.SpatialContext;
+import org.apache.lucene.spatial.SimpleSpatialFieldInfo;
+import org.apache.lucene.spatial.SpatialMatchConcern;
+import org.apache.lucene.spatial.StrategyTestCase;
+import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
+import org.junit.Test;
+
+import java.io.IOException;
+
+
+public abstract class BaseRecursivePrefixTreeStrategyTestCase extends StrategyTestCase<SimpleSpatialFieldInfo> {
+
+  private int maxLength;
+
+  protected abstract SpatialContext getSpatialContext();
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    maxLength = GeohashPrefixTree.getMaxLevelsPossible();
+    // SimpleIO
+    this.ctx = getSpatialContext();
+    this.strategy = new RecursivePrefixTreeStrategy(new GeohashPrefixTree(
+        ctx, maxLength ));
+    this.fieldInfo = new SimpleSpatialFieldInfo( getClass().getSimpleName() );
+  }
+
+  @Test
+  public void testFilterWithVariableScanLevel() throws IOException {
+    getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
+
+    //execute queries for each prefix grid scan level
+    for(int i = 0; i <= maxLength; i++) {
+      ((RecursivePrefixTreeStrategy)strategy).setPrefixGridScanLevel(i);
+      executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_IsWithin_BBox);
+    }
+  }
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategyTestCase.java
new file mode 100644
index 0000000..b67a44e
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategyTestCase.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import org.junit.Before;
+
+
+public class RecursivePrefixTreeStrategyTestCase extends BaseRecursivePrefixTreeStrategyTestCase {
+
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+  }
+
+  @Override
+  protected SpatialContext getSpatialContext() {
+    return SimpleSpatialContext.GEO_KM;
+  }
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestSpatialPrefixField.java b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestSpatialPrefixField.java
new file mode 100644
index 0000000..1829c92
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestSpatialPrefixField.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.List;
+
+
+/**
+ * This is just a quick idea for *simple* tests
+ */
+public class TestSpatialPrefixField {
+
+  @Test
+  public void testRawTokens() {
+    // Ignoring geometry for now, and focus on what tokens need to match
+
+    List<String> docA = Arrays.asList(
+        "AAAAAA*",
+        "AAAAAB+"
+    );
+
+    List<String> docB = Arrays.asList(
+        "A*",
+        "BB*"
+    );
+
+    // Assumptions:
+    checkQuery("AAAAA", "docA", "docB");
+    checkQuery("AAAAA*", "docA", "docB"); // for now * and + are essentially identical
+    checkQuery("AAAAA+", "docA", "docB"); // down the road, there may be a difference between 'covers' and an edge
+
+    checkQuery("AA*", "docB", "docA"); // Bigger input query
+
+    checkQuery("AAAAAAAAAAAA*", "docA", "docB"); // small
+
+    checkQuery("BC"); // nothing
+    checkQuery("XX"); // nothing
+
+    // match only B
+    checkQuery("B", "docB");
+    checkQuery("BBBB", "docB");
+    checkQuery("B*", "docB");
+    checkQuery("BBBB*", "docB");
+  }
+
+  void checkQuery(String query, String... expect) {
+    // TODO, check that the query returns the docs in order
+  }
+
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java
new file mode 100644
index 0000000..b9363f3
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.query.SpatialArgsParser;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.simple.PointImpl;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.spatial.SimpleSpatialFieldInfo;
+import org.apache.lucene.spatial.SpatialTestCase;
+import org.apache.lucene.spatial.prefix.tree.QuadPrefixTree;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+
+public class TestTermQueryPrefixGridStrategy extends SpatialTestCase {
+
+  @Test
+  public void testNGramPrefixGridLosAngeles() throws IOException {
+    SimpleSpatialFieldInfo fieldInfo = new SimpleSpatialFieldInfo("geo");
+    SpatialContext ctx = SimpleSpatialContext.GEO_KM;
+    TermQueryPrefixTreeStrategy prefixGridStrategy = new TermQueryPrefixTreeStrategy(new QuadPrefixTree(ctx));
+
+    Shape point = new PointImpl(-118.243680, 34.052230);
+
+    Document losAngeles = new Document();
+    losAngeles.add(new Field("name", "Los Angeles", StringField.TYPE_STORED));
+    losAngeles.add(prefixGridStrategy.createField(fieldInfo, point, true, true));
+
+    addDocumentsAndCommit(Arrays.asList(losAngeles));
+
+    // This won't work with simple spatial context...
+    SpatialArgsParser spatialArgsParser = new SpatialArgsParser();
+    // TODO... use a non polygon query
+//    SpatialArgs spatialArgs = spatialArgsParser.parse(
+//        "IsWithin(POLYGON((-127.00390625 39.8125,-112.765625 39.98828125,-111.53515625 31.375,-125.94921875 30.14453125,-127.00390625 39.8125)))",
+//        new SimpleSpatialContext());
+
+//    Query query = prefixGridStrategy.makeQuery(spatialArgs, fieldInfo);
+//    SearchResults searchResults = executeQuery(query, 1);
+//    assertEquals(1, searchResults.numFound);
+  }
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java
new file mode 100644
index 0000000..96b46c1
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.prefix.tree;
+
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+
+public class SpatialPrefixTreeTest {
+
+  //TODO plug in others and test them
+  private SimpleSpatialContext ctx;
+  private SpatialPrefixTree trie;
+
+  @Before
+  public void setUp() throws Exception {
+    ctx = SimpleSpatialContext.GEO_KM;
+    trie = new GeohashPrefixTree(ctx,4);
+  }
+
+  @Test
+  public void testNodeTraverse() {
+    Node prevN = null;
+    Node n = trie.getWorldNode();
+    assertEquals(0,n.getLevel());
+    assertEquals(ctx.getWorldBounds(),n.getShape());
+    while(n.getLevel() < trie.getMaxLevels()) {
+      prevN = n;
+      n = n.getSubCells().iterator().next();//TODO random which one?
+      
+      assertEquals(prevN.getLevel()+1,n.getLevel());
+      Rectangle prevNShape = (Rectangle) prevN.getShape();
+      Shape s = n.getShape();
+      Rectangle sbox = s.getBoundingBox();
+      assertTrue(prevNShape.getWidth() > sbox.getWidth());
+      assertTrue(prevNShape.getHeight() > sbox.getHeight());
+    }
+  }
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
deleted file mode 100644
index d958b14..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/BaseRecursivePrefixTreeStrategyTestCase.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import com.spatial4j.core.context.SpatialContext;
-import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.prefix.tree.GeohashPrefixTree;
-import org.apache.lucene.spatial.SpatialMatchConcern;
-import org.apache.lucene.spatial.StrategyTestCase;
-import org.junit.Test;
-
-import java.io.IOException;
-
-
-public abstract class BaseRecursivePrefixTreeStrategyTestCase extends StrategyTestCase<SimpleSpatialFieldInfo> {
-
-  private int maxLength;
-
-  protected abstract SpatialContext getSpatialContext();
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    maxLength = GeohashPrefixTree.getMaxLevelsPossible();
-    // SimpleIO
-    this.ctx = getSpatialContext();
-    this.strategy = new RecursivePrefixTreeStrategy(new GeohashPrefixTree(
-        ctx, maxLength ));
-    this.fieldInfo = new SimpleSpatialFieldInfo( getClass().getSimpleName() );
-  }
-
-  @Test
-  public void testFilterWithVariableScanLevel() throws IOException {
-    getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
-
-    //execute queries for each prefix grid scan level
-    for(int i = 0; i <= maxLength; i++) {
-      ((RecursivePrefixTreeStrategy)strategy).setPrefixGridScanLevel(i);
-      executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_IsWithin_BBox);
-    }
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java
deleted file mode 100644
index 87c881b..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/RecursivePrefixTreeStrategyTestCase.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.context.simple.SimpleSpatialContext;
-import org.junit.Before;
-
-
-public class RecursivePrefixTreeStrategyTestCase extends BaseRecursivePrefixTreeStrategyTestCase {
-
-  @Before
-  public void setUp() throws Exception {
-    super.setUp();
-  }
-
-  @Override
-  protected SpatialContext getSpatialContext() {
-    return SimpleSpatialContext.GEO_KM;
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestSpatialPrefixField.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestSpatialPrefixField.java
deleted file mode 100644
index 2726370..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestSpatialPrefixField.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.junit.Test;
-
-
-/**
- * This is just a quick idea for *simple* tests
- */
-public class TestSpatialPrefixField {
-
-  @Test
-  public void testRawTokens() {
-    // Ignoring geometry for now, and focus on what tokens need to match
-
-    List<String> docA = Arrays.asList(
-        "AAAAAA*",
-        "AAAAAB+"
-    );
-
-    List<String> docB = Arrays.asList(
-        "A*",
-        "BB*"
-    );
-
-    // Assumptions:
-    checkQuery("AAAAA", "docA", "docB");
-    checkQuery("AAAAA*", "docA", "docB"); // for now * and + are essentially identical
-    checkQuery("AAAAA+", "docA", "docB"); // down the road, there may be a difference between 'covers' and an edge
-
-    checkQuery("AA*", "docB", "docA"); // Bigger input query
-
-    checkQuery("AAAAAAAAAAAA*", "docA", "docB"); // small
-
-    checkQuery("BC"); // nothing
-    checkQuery("XX"); // nothing
-
-    // match only B
-    checkQuery("B", "docB");
-    checkQuery("BBBB", "docB");
-    checkQuery("B*", "docB");
-    checkQuery("BBBB*", "docB");
-  }
-
-  void checkQuery(String query, String... expect) {
-    // TODO, check that the query returns the docs in order
-  }
-
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java
deleted file mode 100644
index f326435..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/TestTermQueryPrefixGridStrategy.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.StringField;
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.context.simple.SimpleSpatialContext;
-import com.spatial4j.core.query.SpatialArgsParser;
-import com.spatial4j.core.shape.Shape;
-import com.spatial4j.core.shape.simple.PointImpl;
-import org.apache.lucene.spatial.strategy.SimpleSpatialFieldInfo;
-import org.apache.lucene.spatial.strategy.prefix.tree.QuadPrefixTree;
-import org.apache.lucene.spatial.SpatialTestCase;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-
-public class TestTermQueryPrefixGridStrategy extends SpatialTestCase {
-
-  @Test
-  public void testNGramPrefixGridLosAngeles() throws IOException {
-    SimpleSpatialFieldInfo fieldInfo = new SimpleSpatialFieldInfo("geo");
-    SpatialContext ctx = SimpleSpatialContext.GEO_KM;
-    TermQueryPrefixTreeStrategy prefixGridStrategy = new TermQueryPrefixTreeStrategy(new QuadPrefixTree(ctx));
-
-    Shape point = new PointImpl(-118.243680, 34.052230);
-
-    Document losAngeles = new Document();
-    losAngeles.add(new Field("name", "Los Angeles", StringField.TYPE_STORED));
-    losAngeles.add(prefixGridStrategy.createField(fieldInfo, point, true, true));
-
-    addDocumentsAndCommit(Arrays.asList(losAngeles));
-
-    // This won't work with simple spatial context...
-    SpatialArgsParser spatialArgsParser = new SpatialArgsParser();
-    // TODO... use a non polygon query
-//    SpatialArgs spatialArgs = spatialArgsParser.parse(
-//        "IsWithin(POLYGON((-127.00390625 39.8125,-112.765625 39.98828125,-111.53515625 31.375,-125.94921875 30.14453125,-127.00390625 39.8125)))",
-//        new SimpleSpatialContext());
-
-//    Query query = prefixGridStrategy.makeQuery(spatialArgs, fieldInfo);
-//    SearchResults searchResults = executeQuery(query, 1);
-//    assertEquals(1, searchResults.numFound);
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeTest.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeTest.java
deleted file mode 100644
index 18a6816..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/prefix/tree/SpatialPrefixTreeTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.prefix.tree;
-
-import com.spatial4j.core.context.simple.SimpleSpatialContext;
-import com.spatial4j.core.shape.Rectangle;
-import com.spatial4j.core.shape.Shape;
-
-import org.apache.lucene.spatial.strategy.prefix.tree.GeohashPrefixTree;
-import org.apache.lucene.spatial.strategy.prefix.tree.Node;
-import org.apache.lucene.spatial.strategy.prefix.tree.SpatialPrefixTree;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-
-public class SpatialPrefixTreeTest {
-
-  //TODO plug in others and test them
-  private SimpleSpatialContext ctx;
-  private SpatialPrefixTree trie;
-
-  @Before
-  public void setUp() throws Exception {
-    ctx = SimpleSpatialContext.GEO_KM;
-    trie = new GeohashPrefixTree(ctx,4);
-  }
-
-  @Test
-  public void testNodeTraverse() {
-    Node prevN = null;
-    Node n = trie.getWorldNode();
-    assertEquals(0,n.getLevel());
-    assertEquals(ctx.getWorldBounds(),n.getShape());
-    while(n.getLevel() < trie.getMaxLevels()) {
-      prevN = n;
-      n = n.getSubCells().iterator().next();//TODO random which one?
-      
-      assertEquals(prevN.getLevel()+1,n.getLevel());
-      Rectangle prevNShape = (Rectangle) prevN.getShape();
-      Shape s = n.getShape();
-      Rectangle sbox = s.getBoundingBox();
-      assertTrue(prevNShape.getWidth() > sbox.getWidth());
-      assertTrue(prevNShape.getHeight() > sbox.getHeight());
-    }
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java
deleted file mode 100644
index 10d678a..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/BaseTwoDoublesStrategyTestCase.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.vector;
-
-import org.apache.lucene.search.FieldCache;
-import com.spatial4j.core.context.SpatialContext;
-import org.apache.lucene.spatial.strategy.util.NumericFieldInfo;
-import org.apache.lucene.spatial.SpatialMatchConcern;
-import org.apache.lucene.spatial.StrategyTestCase;
-import org.junit.Test;
-
-import java.io.IOException;
-
-
-public abstract class BaseTwoDoublesStrategyTestCase extends StrategyTestCase<TwoDoublesFieldInfo> {
-
-  protected abstract SpatialContext getSpatialContext();
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    this.ctx = getSpatialContext();
-    this.strategy = new TwoDoublesStrategy(ctx,
-        new NumericFieldInfo(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER);
-    this.fieldInfo = new TwoDoublesFieldInfo(getClass().getSimpleName());
-  }
-
-  @Test
-  public void testCitiesWithinBBox() throws IOException {
-    getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
-    executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_IsWithin_BBox);
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java
deleted file mode 100644
index 14bc89d..0000000
--- a/modules/spatial/src/test/org/apache/lucene/spatial/strategy/vector/TwoDoublesStrategyTestCase.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.strategy.vector;
-
-import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.context.simple.SimpleSpatialContext;
-
-public class TwoDoublesStrategyTestCase extends BaseTwoDoublesStrategyTestCase {
-
-  @Override
-  protected SpatialContext getSpatialContext() {
-    return SimpleSpatialContext.GEO_KM;
-  }
-}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/vector/BaseTwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/vector/BaseTwoDoublesStrategyTestCase.java
new file mode 100644
index 0000000..9c15d2e
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/vector/BaseTwoDoublesStrategyTestCase.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.vector;
+
+import com.spatial4j.core.context.SpatialContext;
+import org.apache.lucene.search.FieldCache;
+import org.apache.lucene.spatial.SpatialMatchConcern;
+import org.apache.lucene.spatial.StrategyTestCase;
+import org.apache.lucene.spatial.util.NumericFieldInfo;
+import org.junit.Test;
+
+import java.io.IOException;
+
+
+public abstract class BaseTwoDoublesStrategyTestCase extends StrategyTestCase<TwoDoublesFieldInfo> {
+
+  protected abstract SpatialContext getSpatialContext();
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    this.ctx = getSpatialContext();
+    this.strategy = new TwoDoublesStrategy(ctx,
+        new NumericFieldInfo(), FieldCache.NUMERIC_UTILS_DOUBLE_PARSER);
+    this.fieldInfo = new TwoDoublesFieldInfo(getClass().getSimpleName());
+  }
+
+  @Test
+  public void testCitiesWithinBBox() throws IOException {
+    getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
+    executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_IsWithin_BBox);
+  }
+}
diff --git a/modules/spatial/src/test/org/apache/lucene/spatial/vector/TwoDoublesStrategyTestCase.java b/modules/spatial/src/test/org/apache/lucene/spatial/vector/TwoDoublesStrategyTestCase.java
new file mode 100644
index 0000000..25edee7
--- /dev/null
+++ b/modules/spatial/src/test/org/apache/lucene/spatial/vector/TwoDoublesStrategyTestCase.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.vector;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.simple.SimpleSpatialContext;
+
+public class TwoDoublesStrategyTestCase extends BaseTwoDoublesStrategyTestCase {
+
+  @Override
+  protected SpatialContext getSpatialContext() {
+    return SimpleSpatialContext.GEO_KM;
+  }
+}

