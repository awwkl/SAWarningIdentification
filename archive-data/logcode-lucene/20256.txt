GitDiffStart: af550281cb4bf35c136dba3eabefdced01c99370 | Sat May 16 14:08:38 2009 +0000
diff --git a/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfBigramDictionary.java b/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfBigramDictionary.java
deleted file mode 100644
index 3d5305f..0000000
--- a/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfBigramDictionary.java
+++ /dev/null
@@ -1,303 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.analysis.cn.smart.hhmm;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.RandomAccessFile;
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
-import org.apache.lucene.analysis.cn.smart.AnalyzerProfile;
-
-public class CopyOfBigramDictionary extends AbstractDictionary {
-
-  private CopyOfBigramDictionary() {
-  }
-
-  public static final char WORD_SEGMENT_CHAR = '@';
-
-  private static CopyOfBigramDictionary singleInstance;
-
-  public static final int PRIME_BIGRAM_LENGTH = 402137;
-
-  /**
-   * bigramTable ?¥å??¨è?ä¸??ä¹????·³è½????? bigramHashTable ?? frequencyTable
-   * å°±æ??¨æ?å­??è¿??é¢???????????? ä¸ºä?????¥è???º¦??????å­?? ??? hash ?¼æ?ä»£æ??³è?è¯??ä¸ºæ?è¯????? ?³è?è¯?°±??
-   * (formWord+'@'+toWord) ï¼? ?©ç? FNV1 hash ç®???¥è?ç®???????ash?? ï¼?¹¶ä¿???? bigramHashTable
-   * ä¸???©ç? hash ?¼æ?ä»£æ??³è?è¯?????ä¼?º§???å°??????²ç?ï¼? ä½?? long ç±»å?
-   * (64bit)??ash?¼æ????å°??æ¦??????????igramHashTable[i]ä¸?requencyTable[i]ä¸?ä¸?å¯¹å?
-   */
-  private long[] bigramHashTable;
-
-  private int[] frequencyTable;
-
-  private int max = 0;
-
-  private int repeat = 0;
-
-  // static Logger log = Logger.getLogger(BigramDictionary.class);
-
-  public synchronized static CopyOfBigramDictionary getInstance() {
-    if (singleInstance == null) {
-      String dictRoot = AnalyzerProfile.ANALYSIS_DATA_DIR;
-      singleInstance = new CopyOfBigramDictionary();
-      singleInstance.load(dictRoot);
-    }
-    return singleInstance;
-  }
-
-  private boolean loadFromObj(File serialObj) {
-    boolean loadFromObject = false;
-    try {
-      ObjectInputStream input = new ObjectInputStream(new FileInputStream(
-          serialObj));
-      bigramHashTable = (long[]) input.readObject();
-      frequencyTable = (int[]) input.readObject();
-      // log.info("load bigram dict from serialization.");
-      loadFromObject = true;
-      input.close();
-    } catch (Exception e) {
-      // log.warn(e.getMessage());
-    }
-    return loadFromObject;
-  }
-
-  private void saveToObj(File serialObj) {
-    try {
-      ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(
-          serialObj));
-      output.writeObject(bigramHashTable);
-      output.writeObject(frequencyTable);
-      output.close();
-      // log.info("serialize bigram dict.");
-    } catch (Exception e) {
-      // log.warn(e.getMessage());
-    }
-  }
-
-  private void load(String dictRoot) {
-    String bigramDictPath = dictRoot + "/bigramdict.dct";
-
-    File serialObj = new File(dictRoot + "/bigramdict.mem");
-
-    if (serialObj.exists() && loadFromObj(serialObj)) {
-
-    } else {
-      try {
-        bigramHashTable = new long[PRIME_BIGRAM_LENGTH];
-        frequencyTable = new int[PRIME_BIGRAM_LENGTH];
-        for (int i = 0; i < PRIME_BIGRAM_LENGTH; i++) {
-          // å®??ä¸??0ä½?¸º????¼æ?ä¸??¹é?é¢????¸º??¸ªå­??ä¸²å???ash?¼ä¸º0ï¼????????å¸¸å?ï¼??æ­¤å½±???å¤?
-          bigramHashTable[i] = 0;
-          frequencyTable[i] = 0;
-        }
-        loadFromFile(bigramDictPath);
-      } catch (IOException e) {
-        throw new RuntimeException(e.getMessage());
-      }
-      saveToObj(serialObj);
-    }
-  }
-
-  /**
-   * å°??åº??ä»¶å?è½½å?WordDictionary????³æ??????¸­ï¼?????è½½ï?æ²¡æ?è¿????¹¶??¿®?¹æ?ä½?
-   * 
-   * @param dctFilePath
-   * @return
-   * @throws FileNotFoundException
-   * @throws IOException
-   * @throws UnsupportedEncodingException
-   */
-  public void loadFromFile(String dctFilePath) throws FileNotFoundException,
-      IOException, UnsupportedEncodingException {
-
-    int i, cnt, length, total = 0;
-    // ??»¶ä¸??ç»??äº?6763ä¸??å­??5ä¸?©ºæ±??ç¬?3756~3760ï¼??ä¸??3756ä¸???¥å??¨ç??·ä¿¡????
-    int[] buffer = new int[3];
-    byte[] intBuffer = new byte[4];
-    String tmpword;
-    RandomAccessFile dctFile = new RandomAccessFile(dctFilePath, "r");
-
-    // å­????»¶ä¸??ä¸?ä¸??å­???°ç?ä½?½®??0ï¼?????ä¸??6768
-    for (i = GB2312_FIRST_CHAR; i < GB2312_FIRST_CHAR + CHAR_NUM_IN_FILE; i++) {
-      String currentStr = getCCByGB2312Id(i);
-      // if (i == 5231)
-      // System.out.println(i);
-
-      dctFile.read(intBuffer);// ???åº??ä»¶å?cä¸???????ä»¥å??¥ç???»¶ä¸?ittle
-      // endianç¼??ï¼???avaä¸?ig endianï¼??é¡»è½¬?¢è???
-      cnt = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN).getInt();
-      if (cnt <= 0) {
-        continue;
-      }
-      total += cnt;
-      int j = 0;
-      while (j < cnt) {
-        dctFile.read(intBuffer);
-        buffer[0] = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN)
-            .getInt();// frequency
-        dctFile.read(intBuffer);
-        buffer[1] = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN)
-            .getInt();// length
-        dctFile.read(intBuffer);
-        // buffer[2] = ByteBuffer.wrap(intBuffer).order(
-        // ByteOrder.LITTLE_ENDIAN).getInt();// handle
-
-        length = buffer[1];
-        if (length > 0) {
-          byte[] lchBuffer = new byte[length];
-          dctFile.read(lchBuffer);
-          tmpword = new String(lchBuffer, "GB2312");
-          if (i != 3755 + GB2312_FIRST_CHAR) {
-            tmpword = currentStr + tmpword;
-          }
-          char carray[] = tmpword.toCharArray();
-          long hashId = hash1(carray);
-          int index = getAvaliableIndex(hashId, carray);
-          if (index != -1) {
-            if (bigramHashTable[index] == 0) {
-              bigramHashTable[index] = hashId;
-              // bigramStringTable[index] = tmpword;
-            }
-            frequencyTable[index] += buffer[0];
-          }
-        }
-        j++;
-      }
-    }
-    dctFile.close();
-    // log.info("load dictionary done! " + dctFilePath + " total:" + total);
-  }
-
-  /*
-   * public void test(String dctFilePath) throws IOException { int i, cnt,
-   * length, total = 0; int corrupt = 0, notFound = 0; //
-   * ??»¶ä¸??ç»??äº?6763ä¸??å­??5ä¸?©ºæ±??ç¬?3756~3760ï¼??ä¸??3756ä¸???¥å??¨ç??·ä¿¡???? int[] buffer = new int[3];
-   * byte[] intBuffer = new byte[4]; String tmpword; RandomAccessFile dctFile =
-   * new RandomAccessFile(dctFilePath, "r");
-   * 
-   * // å­????»¶ä¸??ä¸?ä¸??å­???°ç?ä½?½®??0ï¼?????ä¸??6768 for (i = GB2312_FIRST_CHAR; i <
-   * GB2312_FIRST_CHAR + CHAR_NUM_IN_FILE; i++) { String currentStr =
-   * getCCByGB2312Id(i); // if (i == 5231) // System.out.println(i);
-   * 
-   * dctFile.read(intBuffer);// ???åº??ä»¶å?cä¸???????ä»¥å??¥ç???»¶ä¸?ittle // endianç¼??ï¼???avaä¸?ig
-   * endianï¼??é¡»è½¬?¢è??? cnt =
-   * ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN) .getInt(); if
-   * (cnt <= 0) { continue; } total += cnt; int j = 0; while (j < cnt) {
-   * dctFile.read(intBuffer); buffer[0] = ByteBuffer.wrap(intBuffer).order(
-   * ByteOrder.LITTLE_ENDIAN).getInt();// frequency dctFile.read(intBuffer);
-   * buffer[1] = ByteBuffer.wrap(intBuffer).order(
-   * ByteOrder.LITTLE_ENDIAN).getInt();// length dctFile.read(intBuffer); //
-   * buffer[2] = ByteBuffer.wrap(intBuffer).order( //
-   * ByteOrder.LITTLE_ENDIAN).getInt();// handle
-   * 
-   * length = buffer[1]; if (length > 0) { byte[] lchBuffer = new byte[length];
-   * dctFile.read(lchBuffer); tmpword = new String(lchBuffer, "GB2312"); if (i
-   * != 3755 + GB2312_FIRST_CHAR) { tmpword = currentStr + tmpword; } char
-   * carray[] = tmpword.toCharArray(); int index = getBigramItemIndex(carray);
-   * if (index != -1) { // if (!bigramStringTable[index].equals(tmpword)) { //
-   * System.out.println("corrupt: " + tmpword + "<->" // +
-   * bigramStringTable[index]); // corrupt++; // } } else {
-   * System.out.println("not found: " + tmpword); notFound++; } } j++; } }
-   * dctFile.close(); System.out.println("num not found:" + notFound);
-   * System.out.println("num corrupt:" + corrupt);
-   * 
-   * log.info("test dictionary done! " + dctFilePath + " total:" + total); cnt =
-   * 0; for (int j = 0; j < PRIME_BIGRAM_LENGTH; j++) { if (bigramHashTable[j]
-   * != 0) { cnt++; } } System.out.println("total num in bigramTable: " + cnt);
-   * }
-   */
-
-  private int getAvaliableIndex(long hashId, char carray[]) {
-    int hash1 = (int) (hashId % PRIME_BIGRAM_LENGTH);
-    int hash2 = hash2(carray) % PRIME_BIGRAM_LENGTH;
-    if (hash1 < 0)
-      hash1 = PRIME_BIGRAM_LENGTH + hash1;
-    if (hash2 < 0)
-      hash2 = PRIME_BIGRAM_LENGTH + hash2;
-    int index = hash1;
-    int i = 1;
-    while (bigramHashTable[index] != 0 && bigramHashTable[index] != hashId
-        && i < PRIME_BIGRAM_LENGTH) {
-      index = (hash1 + i * hash2) % PRIME_BIGRAM_LENGTH;
-      i++;
-    }
-    // System.out.println(i - 1);
-
-    if (i < PRIME_BIGRAM_LENGTH
-        && (bigramHashTable[index] == 0 || bigramHashTable[index] == hashId)) {
-      return index;
-    } else
-      return -1;
-  }
-
-  /**
-   * @param c
-   * @return
-   */
-  private int getBigramItemIndex(char carray[]) {
-    long hashId = hash1(carray);
-    int hash1 = (int) (hashId % PRIME_BIGRAM_LENGTH);
-    int hash2 = hash2(carray) % PRIME_BIGRAM_LENGTH;
-    if (hash1 < 0)
-      hash1 = PRIME_BIGRAM_LENGTH + hash1;
-    if (hash2 < 0)
-      hash2 = PRIME_BIGRAM_LENGTH + hash2;
-    int index = hash1;
-    int i = 1;
-    repeat++;
-    while (bigramHashTable[index] != 0 && bigramHashTable[index] != hashId
-        && i < PRIME_BIGRAM_LENGTH) {
-      index = (hash1 + i * hash2) % PRIME_BIGRAM_LENGTH;
-      i++;
-      repeat++;
-      if (i > max)
-        max = i;
-    }
-    // System.out.println(i - 1);
-
-    if (i < PRIME_BIGRAM_LENGTH && bigramHashTable[index] == hashId) {
-      return index;
-    } else
-      return -1;
-  }
-
-  public int getFrequency(char[] carray) {
-    int index = getBigramItemIndex(carray);
-    if (index != -1)
-      return frequencyTable[index];
-    return 0;
-  }
-
-  public static void main(String[] args) throws FileNotFoundException,
-      UnsupportedEncodingException, IOException {
-    CopyOfBigramDictionary dic = new CopyOfBigramDictionary();
-    dic.load("D:/analysis-data");
-    // dic.test("D:/analysis-data/BigramDict.dct");
-    System.out.println("max:" + dic.max);
-    System.out.println("average repeat:" + (double) dic.repeat / 328856);
-    System.out.println("end");
-  }
-}
diff --git a/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfWordDictionary.java b/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfWordDictionary.java
deleted file mode 100644
index 06c1bc2..0000000
--- a/contrib/analyzers/src/java/org/apache/lucene/analysis/cn/smart/hhmm/CopyOfWordDictionary.java
+++ /dev/null
@@ -1,542 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.analysis.cn.smart.hhmm;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.RandomAccessFile;
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-
-import org.apache.lucene.analysis.cn.smart.AnalyzerProfile;
-import org.apache.lucene.analysis.cn.smart.Utility;
-
-public class CopyOfWordDictionary extends AbstractDictionary {
-
-  private CopyOfWordDictionary() {
-  }
-
-  private static CopyOfWordDictionary singleInstance;
-
-  /**
-   * ä¸?ä¸??å¤§ç?ç´??ï¼??è¯?ash?¥æ??½å?????????ç½?
-   */
-  public static final int PRIME_INDEX_LENGTH = 12071;
-
-  /**
-   * wordIndexTableä¿??å°?nicodeä¸???????å­????ash??RIME_INDEX_LENGTH?¿åº¦???ç»?¸­ï¼?
-   * å½??ä¼???²ç?ï¼??å®??ä¸??ç¨???????B2312å­???¨å?ï¼?6768ä¸??ç¬??ä¸??äº?SCIIå­??ï¼?
-   * ???å¯¹è?äº??ç¬????????ä¸ºä?ä¿??æ¯?????ç¡??§ï?ä¿????????ç¬??charIndexTableä¸?»¥ç¡???¥æ????ç¡???
-   */
-  private short[] wordIndexTable;
-
-  private char[] charIndexTable;
-
-  /**
-   * å­???????åº??????°æ?ç»??ï¼?¸ºäº??????¨ç©º?´å¤ªå¤???¨ä?ä¸¤ä¸ª??????ç»´æ?ç»??å­??è¯?????????
-   * æ¯?¸ªè¯???¨ä?ä¸?har[]ä¸??æ¯?¸ªcharå¯¹å?ä¸?ä¸??å­???¶ä?å­??ï¼??ä¸??????¨ä?ä¸?ntä¸??
-   * è¿?¸¤ä¸??ç»????¸¤ä¸??è¡¨æ?ä¸?ä¸?å¯¹å??????æ­¤å?ä»¥å???ordItem_charArrayTable[i][j]?¥æ?è¯??
-   * ??ordItem_frequencyTable[i][j]?¥æ?è¯¢å?åº??é¢??
-   */
-  private char[][][] wordItem_charArrayTable;
-
-  private int[][] wordItem_frequencyTable;
-
-  // static Logger log = Logger.getLogger(WordDictionary.class);
-
-  public synchronized static CopyOfWordDictionary getInstance() {
-    if (singleInstance == null) {
-      singleInstance = new CopyOfWordDictionary();
-      String wordDictRoot = AnalyzerProfile.ANALYSIS_DATA_DIR;
-      singleInstance.load(wordDictRoot);
-    }
-    return singleInstance;
-  }
-
-  /**
-   * ???è¯??åº??ä»¶ï?
-   * 
-   * @param dctFileName è¯??åº??ä»¶ç?è·??
-   */
-  public void load(String dctFileRoot) {
-    String dctFilePath = dctFileRoot + "/coredict.dct";
-    File serialObj = new File(dctFileRoot + "/coredict.mem");
-
-    if (serialObj.exists() && loadFromObj(serialObj)) {
-
-    } else {
-      try {
-        wordIndexTable = new short[PRIME_INDEX_LENGTH];
-        charIndexTable = new char[PRIME_INDEX_LENGTH];
-        for (int i = 0; i < PRIME_INDEX_LENGTH; i++) {
-          charIndexTable[i] = 0;
-          wordIndexTable[i] = -1;
-        }
-        wordItem_charArrayTable = new char[GB2312_CHAR_NUM][][];
-        wordItem_frequencyTable = new int[GB2312_CHAR_NUM][];
-        // int total =
-        loadMainDataFromFile(dctFilePath);
-        expandDelimiterData();
-        mergeSameWords();
-        sortEachItems();
-        // log.info("load dictionary: " + dctFilePath + " total:" + total);
-      } catch (IOException e) {
-        throw new RuntimeException(e.getMessage());
-      }
-
-      saveToObj(serialObj);
-    }
-
-  }
-
-  private boolean loadFromObj(File serialObj) {
-    boolean loadFromObject = false;
-    try {
-      ObjectInputStream input = new ObjectInputStream(new FileInputStream(
-          serialObj));
-      wordIndexTable = (short[]) input.readObject();
-      charIndexTable = (char[]) input.readObject();
-      wordItem_charArrayTable = (char[][][]) input.readObject();
-      wordItem_frequencyTable = (int[][]) input.readObject();
-      // log.info("load core dict from serialization.");
-      input.close();
-      loadFromObject = true;
-    } catch (Exception e) {
-      // log.warn(e.getMessage());
-    }
-    return loadFromObject;
-  }
-
-  private void saveToObj(File serialObj) {
-    try {
-      ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(
-          serialObj));
-      output.writeObject(wordIndexTable);
-      output.writeObject(charIndexTable);
-      output.writeObject(wordItem_charArrayTable);
-      output.writeObject(wordItem_frequencyTable);
-      output.close();
-      // log.info("serialize core dict.");
-    } catch (Exception e) {
-      // log.warn(e.getMessage());
-    }
-  }
-
-  /**
-   * å°??åº??ä»¶å?è½½å?WordDictionary????³æ??????¸­ï¼?????è½½ï?æ²¡æ?è¿????¹¶??¿®?¹æ?ä½?
-   * 
-   * @param dctFilePath
-   * @return
-   * @throws FileNotFoundException
-   * @throws IOException
-   * @throws UnsupportedEncodingException
-   */
-  private int loadMainDataFromFile(String dctFilePath)
-      throws FileNotFoundException, IOException, UnsupportedEncodingException {
-    int i, cnt, length, total = 0;
-    // ??»¶ä¸??ç»??äº?6763ä¸??å­??5ä¸?©ºæ±??ç¬?3756~3760ï¼??ä¸??3756ä¸???¥å??¨ç??·ä¿¡????
-    int[] buffer = new int[3];
-    byte[] intBuffer = new byte[4];
-    String tmpword;
-    RandomAccessFile dctFile = new RandomAccessFile(dctFilePath, "r");
-
-    // å­????»¶ä¸??ä¸?ä¸??å­???°ç?ä½?½®??0ï¼?????ä¸??6768
-    for (i = GB2312_FIRST_CHAR; i < GB2312_FIRST_CHAR + CHAR_NUM_IN_FILE; i++) {
-      // if (i == 5231)
-      // System.out.println(i);
-
-      dctFile.read(intBuffer);// ???åº??ä»¶å?cä¸???????ä»¥å??¥ç???»¶ä¸?ittle
-      // endianç¼??ï¼???avaä¸?ig endianï¼??é¡»è½¬?¢è???
-      cnt = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN).getInt();
-      if (cnt <= 0) {
-        wordItem_charArrayTable[i] = null;
-        wordItem_frequencyTable[i] = null;
-        continue;
-      }
-      wordItem_charArrayTable[i] = new char[cnt][];
-      wordItem_frequencyTable[i] = new int[cnt];
-      total += cnt;
-      int j = 0;
-      while (j < cnt) {
-        // wordItemTable[i][j] = new WordItem();
-        dctFile.read(intBuffer);
-        buffer[0] = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN)
-            .getInt();// frequency
-        dctFile.read(intBuffer);
-        buffer[1] = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN)
-            .getInt();// length
-        dctFile.read(intBuffer);
-        buffer[2] = ByteBuffer.wrap(intBuffer).order(ByteOrder.LITTLE_ENDIAN)
-            .getInt();// handle
-
-        // wordItemTable[i][j].frequency = buffer[0];
-        wordItem_frequencyTable[i][j] = buffer[0];
-
-        length = buffer[1];
-        if (length > 0) {
-          byte[] lchBuffer = new byte[length];
-          dctFile.read(lchBuffer);
-          tmpword = new String(lchBuffer, "GB2312");
-          // indexTable[i].wordItems[j].word = tmpword;
-          // wordItemTable[i][j].charArray = tmpword.toCharArray();
-          wordItem_charArrayTable[i][j] = tmpword.toCharArray();
-        } else {
-          // wordItemTable[i][j].charArray = null;
-          wordItem_charArrayTable[i][j] = null;
-        }
-        // System.out.println(indexTable[i].wordItems[j]);
-        j++;
-      }
-
-      String str = getCCByGB2312Id(i);
-      setTableIndex(str.charAt(0), i);
-    }
-    dctFile.close();
-    return total;
-  }
-
-  /**
-   * ???åº????????¹ç??·ç?ä¿¡æ???¹¶?°ä?ä¸??è¡¨é?(ä»?1å¼?å§??3755å¤?)???????¶å?å¼?ï¼??????°å?ä¸???·å?åº????¡¨ä¸?
-   */
-  private void expandDelimiterData() {
-    int i;
-    int cnt;
-    // ???ç¬???¨ä?1å¼?å§??3755å¤??å°??å§?????ç¬??å¯¹å?????¸å????å¯¹å?????¹ç??·ä¸­
-    int delimiterIndex = 3755 + GB2312_FIRST_CHAR;
-    i = 0;
-    while (i < wordItem_charArrayTable[delimiterIndex].length) {
-      char c = wordItem_charArrayTable[delimiterIndex][i][0];
-      int j = getGB2312Id(c);// è¯¥æ??¹ç??·å?è¯¥æ??¨ç?index??
-      if (wordItem_charArrayTable[j] == null) {
-
-        int k = i;
-        // ä»?å¼?å§???°å???»¥jå¼?å¤´ç?ç¬????orditem??¸ª??
-        while (k < wordItem_charArrayTable[delimiterIndex].length
-            && wordItem_charArrayTable[delimiterIndex][k][0] == c) {
-          k++;
-        }
-        // æ­¤æ?k-iä¸?dä¸?????¹ç??·å?åº??wordItem??¸ª??
-        cnt = k - i;
-        if (cnt != 0) {
-          wordItem_charArrayTable[j] = new char[cnt][];
-          wordItem_frequencyTable[j] = new int[cnt];
-        }
-
-        // ä¸ºæ?ä¸?ä¸?ordItemèµ???
-        for (k = 0; k < cnt; k++, i++) {
-          // wordItemTable[j][k] = new WordItem();
-          wordItem_frequencyTable[j][k] = wordItem_frequencyTable[delimiterIndex][i];
-          wordItem_charArrayTable[j][k] = new char[wordItem_charArrayTable[delimiterIndex][i].length - 1];
-          System.arraycopy(wordItem_charArrayTable[delimiterIndex][i], 1,
-              wordItem_charArrayTable[j][k], 0,
-              wordItem_charArrayTable[j][k].length);
-        }
-        setTableIndex(c, j);
-      }
-    }
-    // å°??ç¬??å¯¹å????ç»????
-    wordItem_charArrayTable[delimiterIndex] = null;
-    wordItem_frequencyTable[delimiterIndex] = null;
-  }
-
-  /**
-   * ???åº??????§æ?æ³?????å°?????ä¸??è¯??§ç?é¢????¹¶?°å?ä¸?ä¸??ä¸??ä»¥å?å°???¨ç©º?´ï???¿«??´¢??º¦
-   */
-  private void mergeSameWords() {
-    int i;
-    for (i = 0; i < GB2312_FIRST_CHAR + CHAR_NUM_IN_FILE; i++) {
-      if (wordItem_charArrayTable[i] == null)
-        continue;
-      int len = 1;
-      for (int j = 1; j < wordItem_charArrayTable[i].length; j++) {
-        if (Utility.compareArray(wordItem_charArrayTable[i][j], 0,
-            wordItem_charArrayTable[i][j - 1], 0) != 0)
-          len++;
-
-      }
-      if (len < wordItem_charArrayTable[i].length) {
-        char[][] tempArray = new char[len][];
-        int[] tempFreq = new int[len];
-        int k = 0;
-        tempArray[0] = wordItem_charArrayTable[i][0];
-        tempFreq[0] = wordItem_frequencyTable[i][0];
-        for (int j = 1; j < wordItem_charArrayTable[i].length; j++) {
-          if (Utility.compareArray(wordItem_charArrayTable[i][j], 0,
-              tempArray[k], 0) != 0) {
-            k++;
-            // temp[k] = wordItemTable[i][j];
-            tempArray[k] = wordItem_charArrayTable[i][j];
-            tempFreq[k] = wordItem_frequencyTable[i][j];
-          } else {
-            // temp[k].frequency += wordItemTable[i][j].frequency;
-            tempFreq[k] += wordItem_frequencyTable[i][j];
-          }
-        }
-        // wordItemTable[i] = temp;
-        wordItem_charArrayTable[i] = tempArray;
-        wordItem_frequencyTable[i] = tempFreq;
-      }
-    }
-  }
-
-  private void sortEachItems() {
-    char[] tmpArray;
-    int tmpFreq;
-    for (int i = 0; i < wordItem_charArrayTable.length; i++) {
-      if (wordItem_charArrayTable[i] != null
-          && wordItem_charArrayTable[i].length > 1) {
-        for (int j = 0; j < wordItem_charArrayTable[i].length - 1; j++) {
-          for (int j2 = j + 1; j2 < wordItem_charArrayTable[i].length; j2++) {
-            if (Utility.compareArray(wordItem_charArrayTable[i][j], 0,
-                wordItem_charArrayTable[i][j2], 0) > 0) {
-              tmpArray = wordItem_charArrayTable[i][j];
-              tmpFreq = wordItem_frequencyTable[i][j];
-              wordItem_charArrayTable[i][j] = wordItem_charArrayTable[i][j2];
-              wordItem_frequencyTable[i][j] = wordItem_frequencyTable[i][j2];
-              wordItem_charArrayTable[i][j2] = tmpArray;
-              wordItem_frequencyTable[i][j2] = tmpFreq;
-            }
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * è®¡ç?å­??c?¨å?å¸?¡¨ä¸??è¯¥å????ç½???¶å?å°??????¡¨ä¸??ä½?½®???¼å?å§??
-   * 
-   * @param c
-   * @param j
-   * @return
-   */
-  private boolean setTableIndex(char c, int j) {
-    int index = getAvaliableTableIndex(c);
-    if (index != -1) {
-      charIndexTable[index] = c;
-      wordIndexTable[index] = (short) j;
-      return true;
-    } else
-      return false;
-  }
-
-  private short getAvaliableTableIndex(char c) {
-    int hash1 = (int) (hash1(c) % PRIME_INDEX_LENGTH);
-    int hash2 = hash2(c) % PRIME_INDEX_LENGTH;
-    if (hash1 < 0)
-      hash1 = PRIME_INDEX_LENGTH + hash1;
-    if (hash2 < 0)
-      hash2 = PRIME_INDEX_LENGTH + hash2;
-    int index = hash1;
-    int i = 1;
-    while (charIndexTable[index] != 0 && charIndexTable[index] != c
-        && i < PRIME_INDEX_LENGTH) {
-      index = (hash1 + i * hash2) % PRIME_INDEX_LENGTH;
-      i++;
-    }
-    // System.out.println(i - 1);
-
-    if (i < PRIME_INDEX_LENGTH
-        && (charIndexTable[index] == 0 || charIndexTable[index] == c)) {
-      return (short) index;
-    } else
-      return -1;
-  }
-
-  /**
-   * @param c
-   * @return
-   */
-  private short getWordItemTableIndex(char c) {
-    int hash1 = (int) (hash1(c) % PRIME_INDEX_LENGTH);
-    int hash2 = hash2(c) % PRIME_INDEX_LENGTH;
-    if (hash1 < 0)
-      hash1 = PRIME_INDEX_LENGTH + hash1;
-    if (hash2 < 0)
-      hash2 = PRIME_INDEX_LENGTH + hash2;
-    int index = hash1;
-    int i = 1;
-    while (charIndexTable[index] != 0 && charIndexTable[index] != c
-        && i < PRIME_INDEX_LENGTH) {
-      index = (hash1 + i * hash2) % PRIME_INDEX_LENGTH;
-      i++;
-    }
-
-    if (i < PRIME_INDEX_LENGTH && charIndexTable[index] == c) {
-      return (short) index;
-    } else
-      return -1;
-  }
-
-  /**
-   * ?¨å??¸å?ä¸???¾å?è¯??åº??char?°ç?ä¸?harArray???ç¬?¸²??????????¨å?è¯????¸­???ç½?
-   * 
-   * @param charArray ?¥æ????å¯¹å???har?°ç?
-   * @return ????¨å?è¯??ç»?¸­???ç½??å¦??æ²¡æ??°å?è¿??-1
-   */
-  private int findInTable(char[] charArray) {
-    if (charArray == null || charArray.length == 0)
-      return -1;
-    short index = getWordItemTableIndex(charArray[0]);
-    if (index == -1)
-      return -1;
-
-    return findInTable(index, charArray);
-
-  }
-
-  /**
-   * ?¨å??¸å?ä¸???¾å?è¯??åº??char?°ç?ä¸?harArray???ç¬?¸²??????????¨å?è¯????¸­???ç½?
-   * 
-   * @param knownHashIndex å·²ç????ç¬??ä¸??ç¬?harArray[0]??ashè¡¨ä¸­???ç½??å¦?????ç®????»¥?¨å???nt
-   *        findInTable(char[] charArray) ä»£æ?
-   * @param charArray ?¥æ????å¯¹å???har?°ç?
-   * @return ????¨å?è¯??ç»?¸­???ç½??å¦??æ²¡æ??°å?è¿??-1
-   */
-  private int findInTable(short knownHashIndex, char[] charArray) {
-    if (charArray == null || charArray.length == 0)
-      return -1;
-
-    char[][] items = wordItem_charArrayTable[wordIndexTable[knownHashIndex]];
-    int start = 0, end = items.length - 1;
-    int mid = (start + end) / 2, cmpResult;
-
-    // Binary search for the index of idArray
-    while (start <= end) {
-      cmpResult = Utility.compareArray(items[mid], 0, charArray, 1);
-
-      if (cmpResult == 0)
-        return mid;// find it
-      else if (cmpResult < 0)
-        start = mid + 1;
-      else if (cmpResult > 0)
-        end = mid - 1;
-
-      mid = (start + end) / 2;
-    }
-    return -1;
-  }
-
-  /**
-   * charArrayè¿?¸ª???å¯¹å????ç»??ä¸??WordDictionaryä¸????
-   * 
-   * @param charArray
-   * @return trueè¡¨ç¤ºå­??ï¼?alseè¡¨ç¤ºä¸????
-   */
-  public boolean isExist(char[] charArray) {
-    return findInTable(charArray) != -1;
-  }
-
-  /**
-   * @see{getPrefixMatch(char[] charArray, int knownStart)}
-   * @param charArray
-   * @return
-   */
-  public int getPrefixMatch(char[] charArray) {
-    return getPrefixMatch(charArray, 0);
-  }
-
-  /**
-   * ä»???¸ä¸­?¥æ?ä»?harArrayå¯¹å????è¯?¸º???(prefix)???è¯??ä½?½®, å¹¶è????ä¸?ä¸?»¡è¶³æ?ä»¶ç?ä½?½®??¸ºäº??å°??ç´?»£ä»?,
-   * ??»¥?¹æ?å·²æ??¥è?è®¾ç½®èµ·å???´¢ä½?½®, å¦??ä¸????µ·å§??ç½??é»????0
-   * 
-   * @see{getPrefixMatch(char[] charArray)}
-   * @param charArray ??????
-   * @param knownStart å·²ç???µ·å§??ç½?
-   * @return æ»¡è¶³????¡ä»¶???ä¸?ä¸??è¯??ä½?½®
-   */
-  public int getPrefixMatch(char[] charArray, int knownStart) {
-    short index = getWordItemTableIndex(charArray[0]);
-    if (index == -1)
-      return -1;
-    char[][] items = wordItem_charArrayTable[wordIndexTable[index]];
-    int start = knownStart, end = items.length - 1;
-
-    int mid = (start + end) / 2, cmpResult;
-
-    // Binary search for the index of idArray
-    while (start <= end) {
-      cmpResult = Utility.compareArrayByPrefix(charArray, 1, items[mid], 0);
-      if (cmpResult == 0) {
-        // Get the first item which match the current word
-        while (mid >= 0
-            && Utility.compareArrayByPrefix(charArray, 1, items[mid], 0) == 0)
-          mid--;
-        mid++;
-        return mid;// ?¾å?ç¬??ä¸?»¥charArrayä¸ºå?ç¼????è¯?
-      } else if (cmpResult < 0)
-        end = mid - 1;
-      else
-        start = mid + 1;
-      mid = (start + end) / 2;
-    }
-    return -1;
-  }
-
-  /**
-   * ?·å?idArrayå¯¹å???????é¢????osä¸?-1??????????§ç?è¯??
-   * 
-   * @param charArray è¾?????è¯??åº??charArray
-   * @param pos è¯??§ï?-1è¡¨ç¤ºè¦??æ±???????è¯??§ç?è¯??
-   * @return idArrayå¯¹å????é¢?
-   */
-  public int getFrequency(char[] charArray) {
-    short hashIndex = getWordItemTableIndex(charArray[0]);
-    if (hashIndex == -1)
-      return 0;
-    int itemIndex = findInTable(hashIndex, charArray);
-    if (itemIndex != -1)
-      return wordItem_frequencyTable[wordIndexTable[hashIndex]][itemIndex];
-    return 0;
-
-  }
-
-  /**
-   * ?¤æ?charArrayå¯¹å????ç¬?¸²???è·???¸ä¸­charArray[0]å¯¹å???ordIndex??harArray?¸ç?,
-   * ä¹?°±???charArray???ç½???¾ç????ä¸??å°±æ?wordIndex
-   * 
-   * @param charArray è¾????harArrayè¯??ï¼??ä¸?ä¸??è¡¨ç¤ºè¯??ä¸??ç´¢å???
-   * @param itemIndex ä½?½®ç¼??
-   * @return ????¸ç?
-   */
-  public boolean isEqual(char[] charArray, int itemIndex) {
-    short hashIndex = getWordItemTableIndex(charArray[0]);
-    return Utility.compareArray(charArray, 1,
-        wordItem_charArrayTable[wordIndexTable[hashIndex]][itemIndex], 0) == 0;
-  }
-
-  public static void main(String[] args) throws FileNotFoundException,
-      IOException {
-    CopyOfWordDictionary dic = new CopyOfWordDictionary();
-    dic.load("D:/analysis-data");
-    Utility.getCharType('??');
-    Utility.getCharType('æ±?');
-    Utility.getCharType(' ');// 0020
-    Utility.getCharType('??');// 3000
-    Utility.getCharType('??');// E095
-    Utility.getCharType(' ');// 3000
-    Utility.getCharType('\r');// 000D
-    Utility.getCharType('\n');// 000A
-    Utility.getCharType('\t');// 0009
-  }
-}

