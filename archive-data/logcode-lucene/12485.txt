GitDiffStart: 91522c32a1e457497d13f808099dfe55adaf428c | Wed May 16 02:45:55 2012 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFieldInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFieldInfosReader.java
index fcad39c..7fd028c 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFieldInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFieldInfosReader.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.IndexFormatTooNewException;
 import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.index.ReadOnlyFieldInfos;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.Directory;
@@ -113,7 +114,7 @@ class Lucene3xFieldInfosReader extends FieldInfosReader {
       if (input.getFilePointer() != input.length()) {
         throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read " + input.getFilePointer() + " vs size " + input.length() + " (resource: " + input + ")");
       }
-      return new FieldInfos(infos, hasFreq, hasProx, hasVectors);
+      return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
     } finally {
       input.close();
     }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
index 9feaff9..0832b13 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
@@ -10,6 +10,7 @@ import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.IndexFormatTooNewException;
 import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.index.ReadOnlyFieldInfos;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.DocValues;
@@ -106,7 +107,7 @@ public class Lucene40FieldInfosReader extends FieldInfosReader {
         throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read " + input.getFilePointer() + " vs size " + input.length() + " (resource: " + input + ")");
       }
       
-      return new FieldInfos(infos, hasFreq, hasProx, hasVectors);
+      return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
     } finally {
       input.close();
     }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java
index 21bb7b3..cad3c11 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java
@@ -25,6 +25,7 @@ import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.ReadOnlyFieldInfos;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.DocValues;
@@ -115,7 +116,7 @@ public class SimpleTextFieldInfosReader extends FieldInfosReader {
         throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read " + input.getFilePointer() + " vs size " + input.length() + " (resource: " + input + ")");
       }
       
-      return new FieldInfos(infos, hasFreq, hasProx, hasVectors);
+      return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
     } finally {
       input.close();
     }
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocConsumer.java b/lucene/core/src/java/org/apache/lucene/index/DocConsumer.java
index c227964..62a93bc 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocConsumer.java
@@ -20,7 +20,7 @@ package org.apache.lucene.index;
 import java.io.IOException;
 
 abstract class DocConsumer {
-  abstract void processDocument(FieldInfos fieldInfos) throws IOException;
+  abstract void processDocument(MutableFieldInfos fieldInfos) throws IOException;
   abstract void finishDocument() throws IOException;
   abstract void flush(final SegmentWriteState state) throws IOException;
   abstract void abort();
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java b/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
index ae36b8f..9f8d47b 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocFieldProcessor.java
@@ -203,7 +203,7 @@ final class DocFieldProcessor extends DocConsumer {
   }
 
   @Override
-  public void processDocument(FieldInfos fieldInfos) throws IOException {
+  public void processDocument(MutableFieldInfos fieldInfos) throws IOException {
 
     consumer.startDocument();
     fieldsWriter.startDocument();
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
index 9d444bb..652bb8d 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
@@ -28,7 +28,7 @@ import org.apache.lucene.index.DocumentsWriterFlushQueue.SegmentFlushTicket;
 import org.apache.lucene.index.DocumentsWriterPerThread.FlushedSegment;
 import org.apache.lucene.index.DocumentsWriterPerThread.IndexingChain;
 import org.apache.lucene.index.DocumentsWriterPerThreadPool.ThreadState;
-import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
+import org.apache.lucene.index.MutableFieldInfos.FieldNumberBiMap;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.AlreadyClosedException;
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
index e34642b..cfca621 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
@@ -169,7 +169,7 @@ class DocumentsWriterPerThread {
   boolean aborting = false;   // True if an abort is pending
   boolean hasAborted = false; // True if the last exception throws by #updateDocument was aborting
 
-  private FieldInfos fieldInfos;
+  private MutableFieldInfos fieldInfos;
   private final InfoStream infoStream;
   private int numDocsInRAM;
   private int flushedDocCount;
@@ -180,7 +180,7 @@ class DocumentsWriterPerThread {
 
   
   public DocumentsWriterPerThread(Directory directory, DocumentsWriter parent,
-      FieldInfos fieldInfos, IndexingChain indexingChain) {
+      MutableFieldInfos fieldInfos, IndexingChain indexingChain) {
     this.directory = directory;
     this.parent = parent;
     this.fieldInfos = fieldInfos;
@@ -196,7 +196,7 @@ class DocumentsWriterPerThread {
     initialize();
   }
   
-  public DocumentsWriterPerThread(DocumentsWriterPerThread other, FieldInfos fieldInfos) {
+  public DocumentsWriterPerThread(DocumentsWriterPerThread other, MutableFieldInfos fieldInfos) {
     this(other.directory, other.parent, fieldInfos, other.parent.chain);
   }
   
@@ -413,7 +413,7 @@ class DocumentsWriterPerThread {
   private void doAfterFlush() throws IOException {
     segment = null;
     consumer.doAfterFlush();
-    fieldInfos = FieldInfos.from(fieldInfos);
+    fieldInfos = MutableFieldInfos.from(fieldInfos);
     parent.subtractFlushedNumDocs(numDocsInRAM);
     numDocsInRAM = 0;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java
index a0fe9ec..f52a609 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java
@@ -18,7 +18,7 @@ package org.apache.lucene.index;
 
 import java.util.concurrent.locks.ReentrantLock;
 
-import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
+import org.apache.lucene.index.MutableFieldInfos.FieldNumberBiMap;
 import org.apache.lucene.util.SetOnce;
 
 /**
@@ -139,7 +139,7 @@ abstract class DocumentsWriterPerThreadPool {
     this.documentsWriter.set(documentsWriter); // thread pool is bound to DW
     this.globalFieldMap.set(globalFieldMap);
     for (int i = 0; i < threadStates.length; i++) {
-      final FieldInfos infos = new FieldInfos(globalFieldMap);
+      final MutableFieldInfos infos = new MutableFieldInfos(globalFieldMap);
       threadStates[i] = new ThreadState(new DocumentsWriterPerThread(documentsWriter.directory, documentsWriter, infos, documentsWriter.chain));
     }
   }
@@ -228,7 +228,7 @@ abstract class DocumentsWriterPerThreadPool {
     assert globalFieldMap.get() != null;
     final DocumentsWriterPerThread dwpt = threadState.dwpt;
     if (!closed) {
-      final FieldInfos infos = new FieldInfos(globalFieldMap.get());
+      final MutableFieldInfos infos = new MutableFieldInfos(globalFieldMap.get());
       final DocumentsWriterPerThread newDwpt = new DocumentsWriterPerThread(dwpt, infos);
       newDwpt.initialize();
       threadState.resetWriter(newDwpt);
diff --git a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
index eb5b778..4a07857 100644
--- a/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
@@ -17,326 +17,21 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
-import java.util.Collection;
-import java.util.HashMap;
 import java.util.Iterator;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
-
-import org.apache.lucene.index.FieldInfo.IndexOptions;
 
 /** 
  * Collection of {@link FieldInfo}s (accessible by number or by name).
  *  @lucene.experimental
  */
-public final class FieldInfos implements Iterable<FieldInfo> {
-  static final class FieldNumberBiMap {
-    
-    private final Map<Integer,String> numberToName;
-    private final Map<String,Integer> nameToNumber;
-    private int lowestUnassignedFieldNumber = -1;
-    
-    FieldNumberBiMap() {
-      this.nameToNumber = new HashMap<String, Integer>();
-      this.numberToName = new HashMap<Integer, String>();
-    }
-    
-    /**
-     * Returns the global field number for the given field name. If the name
-     * does not exist yet it tries to add it with the given preferred field
-     * number assigned if possible otherwise the first unassigned field number
-     * is used as the field number.
-     */
-    synchronized int addOrGet(String fieldName, int preferredFieldNumber) {
-      Integer fieldNumber = nameToNumber.get(fieldName);
-      if (fieldNumber == null) {
-        final Integer preferredBoxed = Integer.valueOf(preferredFieldNumber);
-
-        if (preferredFieldNumber != -1 && !numberToName.containsKey(preferredBoxed)) {
-            // cool - we can use this number globally
-            fieldNumber = preferredBoxed;
-        } else {
-          // find a new FieldNumber
-          while (numberToName.containsKey(++lowestUnassignedFieldNumber)) {
-            // might not be up to date - lets do the work once needed
-          }
-          fieldNumber = lowestUnassignedFieldNumber;
-        }
-        
-        numberToName.put(fieldNumber, fieldName);
-        nameToNumber.put(fieldName, fieldNumber);
-        
-      }
-
-      return fieldNumber.intValue();
-    }
-
-    /**
-     * Sets the given field number and name if not yet set. 
-     */
-    synchronized void setIfNotSet(int fieldNumber, String fieldName) {
-      final Integer boxedFieldNumber = Integer.valueOf(fieldNumber);
-      if (!numberToName.containsKey(boxedFieldNumber)
-          && !nameToNumber.containsKey(fieldName)) {
-        numberToName.put(boxedFieldNumber, fieldName);
-        nameToNumber.put(fieldName, boxedFieldNumber);
-      } else {
-        assert containsConsistent(boxedFieldNumber, fieldName);
-      }
-    }
-    
-    // used by assert
-    synchronized boolean containsConsistent(Integer number, String name) {
-      return name.equals(numberToName.get(number))
-          && number.equals(nameToNumber.get(name));
-    }
-  }
-  
-  private final SortedMap<Integer,FieldInfo> byNumber = new TreeMap<Integer,FieldInfo>();
-  private final HashMap<String,FieldInfo> byName = new HashMap<String,FieldInfo>();
-  private final FieldNumberBiMap globalFieldNumbers;
-  
-  private boolean hasFreq; // only set if readonly
-  private boolean hasProx; // only set if readonly
-  private boolean hasVectors; // only set if readonly
-  private long version; // internal use to track changes
-
-  /**
-   * Creates a new read-only FieldInfos: only public to be accessible
-   * from the codecs package
-   * 
-   * @lucene.internal
-   */
-  public FieldInfos(FieldInfo[] infos, boolean hasFreq, boolean hasProx, boolean hasVectors) {
-    this(null);
-    this.hasFreq = hasFreq;
-    this.hasProx = hasProx;
-    this.hasVectors = hasVectors;
-    for (FieldInfo info : infos) {
-      putInternal(info);
-    }
-  }
-
-  public FieldInfos() {
-    this(new FieldNumberBiMap());
-  }
-
-  public void add(FieldInfos other) {
-    for(FieldInfo fieldInfo : other){ 
-      add(fieldInfo);
-    }
-  }
-
-  /**
-   * Creates a new FieldInfos instance with the given {@link FieldNumberBiMap}. 
-   * If the {@link FieldNumberBiMap} is <code>null</code> this instance will be read-only.
-   * @see #isReadOnly()
-   */
-  FieldInfos(FieldNumberBiMap globalFieldNumbers) {
-    this.globalFieldNumbers = globalFieldNumbers;
-  }
-  
-  /**
-   * adds the given field to this FieldInfos name / number mapping. The given FI
-   * must be present in the global field number mapping before this method it
-   * called
-   */
-  private void putInternal(FieldInfo fi) {
-    assert !byNumber.containsKey(fi.number);
-    assert !byName.containsKey(fi.name);
-    assert globalFieldNumbers == null || globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name);
-    byNumber.put(fi.number, fi);
-    byName.put(fi.name, fi);
-  }
-  
-  private int nextFieldNumber(String name, int preferredFieldNumber) {
-    // get a global number for this field
-    final int fieldNumber = globalFieldNumbers.addOrGet(name,
-        preferredFieldNumber);
-    assert byNumber.get(fieldNumber) == null : "field number " + fieldNumber
-        + " already taken";
-    return fieldNumber;
-  }
-
+public abstract class FieldInfos implements Cloneable,Iterable<FieldInfo> {
+ 
   /**
    * Returns a deep clone of this FieldInfos instance.
    */
   @Override
-  synchronized public FieldInfos clone() {
-    FieldInfos fis = new FieldInfos(globalFieldNumbers);
-    fis.hasFreq = hasFreq;
-    fis.hasProx = hasProx;
-    fis.hasVectors = hasVectors;
-    for (FieldInfo fi : this) {
-      FieldInfo clone = fi.clone();
-      fis.putInternal(clone);
-    }
-    return fis;
-  }
+  public abstract FieldInfos clone();
 
-  /** Returns true if any fields have positions */
-  public boolean hasProx() {
-    if (isReadOnly()) {
-      return hasProx;
-    }
-    // mutable FIs must check!
-    for (FieldInfo fi : this) {
-      if (fi.isIndexed && fi.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
-        return true;
-      }
-    }
-    return false;
-  }
-  
-  /** Returns true if any fields have freqs */
-  public boolean hasFreq() {
-    if (isReadOnly()) {
-      return hasFreq;
-    }
-    // mutable FIs must check!
-    for (FieldInfo fi : this) {
-      if (fi.isIndexed && fi.indexOptions != IndexOptions.DOCS_ONLY) {
-        return true;
-      }
-    }
-    return false;
-  }
-  
-  /**
-   * Assumes the fields are not storing term vectors.
-   * 
-   * @param names The names of the fields
-   * @param isIndexed Whether the fields are indexed or not
-   * 
-   * @see #addOrUpdate(String, boolean)
-   */
-  synchronized public void addOrUpdate(Collection<String> names, boolean isIndexed) {
-    for (String name : names) {
-      addOrUpdate(name, isIndexed);
-    }
-  }
-
-  /**
-   * Calls 5 parameter add with false for all TermVector parameters.
-   * 
-   * @param name The name of the IndexableField
-   * @param isIndexed true if the field is indexed
-   * @see #addOrUpdate(String, boolean, boolean)
-   */
-  synchronized public void addOrUpdate(String name, boolean isIndexed) {
-    addOrUpdate(name, isIndexed, false, false);
-  }
-
-  /** If the field is not yet known, adds it. If it is known, checks to make
-   *  sure that the isIndexed flag is the same as was given previously for this
-   *  field. If not - marks it as being indexed.  Same goes for the TermVector
-   * parameters.
-   * 
-   * @param name The name of the field
-   * @param isIndexed true if the field is indexed
-   * @param storeTermVector true if the term vector should be stored
-   */
-  synchronized public void addOrUpdate(String name, boolean isIndexed, boolean storeTermVector) {
-    addOrUpdate(name, isIndexed, storeTermVector, false);
-  }
-
-    /** If the field is not yet known, adds it. If it is known, checks to make
-   *  sure that the isIndexed flag is the same as was given previously for this
-   *  field. If not - marks it as being indexed.  Same goes for the TermVector
-   * parameters.
-   *
-   * @param name The name of the field
-   * @param isIndexed true if the field is indexed
-   * @param storeTermVector true if the term vector should be stored
-   * @param omitNorms true if the norms for the indexed field should be omitted
-   */
-  synchronized public void addOrUpdate(String name, boolean isIndexed, boolean storeTermVector,
-                  boolean omitNorms) {
-    addOrUpdate(name, isIndexed, storeTermVector, omitNorms, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, null, null);
-  }
-  
-  /** If the field is not yet known, adds it. If it is known, checks to make
-   *  sure that the isIndexed flag is the same as was given previously for this
-   *  field. If not - marks it as being indexed.  Same goes for the TermVector
-   * parameters.
-   *
-   * @param name The name of the field
-   * @param isIndexed true if the field is indexed
-   * @param storeTermVector true if the term vector should be stored
-   * @param omitNorms true if the norms for the indexed field should be omitted
-   * @param storePayloads true if payloads should be stored for this field
-   * @param indexOptions if term freqs should be omitted for this field
-   */
-  synchronized public FieldInfo addOrUpdate(String name, boolean isIndexed, boolean storeTermVector,
-                       boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValues.Type docValues, DocValues.Type normType) {
-    return addOrUpdateInternal(name, -1, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);
-  }
-
-  // NOTE: this method does not carry over termVector
-  // booleans nor docValuesType; the indexer chain
-  // (TermVectorsConsumerPerField, DocFieldProcessor) must
-  // set these fields when they succeed in consuming
-  // the document:
-  public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {
-    // TODO: really, indexer shouldn't even call this
-    // method (it's only called from DocFieldProcessor);
-    // rather, each component in the chain should update
-    // what it "owns".  EG fieldType.indexOptions() should
-    // be updated by maybe FreqProxTermsWriterPerField:
-    return addOrUpdateInternal(name, -1, fieldType.indexed(), false,
-                               fieldType.omitNorms(), false,
-                               fieldType.indexOptions(), null, null);
-  }
-
-  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,
-      boolean storeTermVector,
-      boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValues.Type docValues, DocValues.Type normType) {
-    if (globalFieldNumbers == null) {
-      throw new IllegalStateException("FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos");
-    }
-    FieldInfo fi = fieldInfo(name);
-    if (fi == null) {
-      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);
-      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);
-    } else {
-      fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);
-      if (docValues != null) {
-        fi.setDocValuesType(docValues, true);
-      }
-      if (normType != null) {
-        fi.setNormValueType(normType, true);
-      }
-    }
-    version++;
-    return fi;
-  }
-  
-  synchronized public FieldInfo add(FieldInfo fi) {
-    // IMPORTANT - reuse the field number if possible for consistent field numbers across segments
-    return addOrUpdateInternal(fi.name, fi.number, fi.isIndexed, fi.storeTermVector,
-               fi.omitNorms, fi.storePayloads,
-               fi.indexOptions, fi.getDocValuesType(), fi.getNormType());
-  }
-  
-  /*
-   * NOTE: if you call this method from a public method make sure you check if we are modifiable and throw an exception otherwise
-   */
-  private FieldInfo addInternal(String name, int fieldNumber, boolean isIndexed,
-                                boolean storeTermVector, boolean omitNorms, boolean storePayloads,
-                                IndexOptions indexOptions, DocValues.Type docValuesType, DocValues.Type normType) {
-    // don't check modifiable here since we use that to initially build up FIs
-    if (globalFieldNumbers != null) {
-      globalFieldNumbers.setIfNotSet(fieldNumber, name);
-    } 
-    final FieldInfo fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValuesType, normType);
-    putInternal(fi);
-    return fi;
-  }
-
-  public FieldInfo fieldInfo(String fieldName) {
-    return byName.get(fieldName);
-  }
+  public abstract FieldInfo fieldInfo(String fieldName);
 
   /**
    * Return the fieldinfo object referenced by the fieldNumber.
@@ -344,100 +39,38 @@ public final class FieldInfos implements Iterable<FieldInfo> {
    * @return the FieldInfo object or null when the given fieldNumber
    * doesn't exist.
    */  
-  public FieldInfo fieldInfo(int fieldNumber) {
-    return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
-  }
+  public abstract FieldInfo fieldInfo(int fieldNumber);
 
-  public Iterator<FieldInfo> iterator() {
-    return byNumber.values().iterator();
-  }
+  public abstract Iterator<FieldInfo> iterator();
 
   /**
    * @return number of fields
    */
-  public int size() {
-    assert byNumber.size() == byName.size();
-    return byNumber.size();
-  }
+  public abstract int size();
 
+  /** Returns true if any fields have positions */
+  // nocommit
+  public abstract boolean hasProx();
+  
+  /** Returns true if any fields have freqs */
+  // nocommit
+  public abstract boolean hasFreq();
+  
   /**
    * @return true if at least one field has any vectors
    */
-  public boolean hasVectors() {
-    if (isReadOnly()) {
-      return hasVectors;
-    }
-    // mutable FIs must check
-    for (FieldInfo fi : this) {
-      if (fi.storeTermVector) {
-        return true;
-      }
-    }
-    return false;
-  }
-
+  // nocommit
+  public abstract boolean hasVectors();
+  
   /**
    * @return true if at least one field has any norms
    */
-  public boolean hasNorms() {
-    for (FieldInfo fi : this) {
-      if (fi.hasNorms()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /**
-   * Returns <code>true</code> iff this instance is not backed by a
-   * {@link org.apache.lucene.index.FieldInfos.FieldNumberBiMap}. Instances read from a directory via
-   * {@link FieldInfos#FieldInfos(FieldInfo[], boolean, boolean, boolean)} will always be read-only
-   * since no {@link org.apache.lucene.index.FieldInfos.FieldNumberBiMap} is supplied, otherwise 
-   * <code>false</code>.
-   */
-  public final boolean isReadOnly() {
-    return globalFieldNumbers == null;
-  }
-  
-  synchronized final long getVersion() {
-    return version;
-  }
-  
-  final FieldInfos asReadOnly() {
-    if (isReadOnly()) {
-      return this;
-    }
-    final FieldInfos roFis = new FieldInfos((FieldNumberBiMap)null);
-    for (FieldInfo fieldInfo : this) {
-      FieldInfo clone = fieldInfo.clone();
-      roFis.putInternal(clone);
-      roFis.hasVectors |= clone.storeTermVector;
-      roFis.hasProx |= clone.isIndexed && clone.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
-      roFis.hasFreq |= clone.isIndexed && clone.indexOptions != IndexOptions.DOCS_ONLY;
-    }
-    return roFis;
-  }
+  // nocommit
+  public abstract boolean hasNorms();
 
   /**
    * @return true if at least one field has docValues
    */
-  public boolean hasDocValues() {
-    for (FieldInfo fi : this) {
-      if (fi.hasDocValues()) { 
-        return true;
-      }
-    }
-
-    return false;
-  }
-  
-  /**
-   * Creates a new {@link FieldInfo} instance from the given instance. If the given instance is
-   * read-only this instance will be read-only too.
-   * 
-   * @see #isReadOnly()
-   */
-  static FieldInfos from(FieldInfos other) {
-    return new FieldInfos(other.globalFieldNumbers);
-  }
+  // nocommit
+  public abstract boolean hasDocValues();
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 06b5e77..f02d4fe 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -34,7 +34,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.index.DocumentsWriterPerThread.FlushedSegment;
-import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
+import org.apache.lucene.index.MutableFieldInfos.FieldNumberBiMap;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.MergeState.CheckAbort;
 import org.apache.lucene.search.Query;
@@ -2231,7 +2231,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {
       // abortable so that IW.close(false) is able to stop it
       SegmentMerger merger = new SegmentMerger(infoStream, directory, config.getTermIndexInterval(),
                                                mergedName, MergeState.CheckAbort.NONE, payloadProcessorProvider,
-                                               new FieldInfos(globalFieldNumberMap), codec, context);
+                                               new MutableFieldInfos(globalFieldNumberMap), codec, context);
 
       for (IndexReader reader : readers)      // add new indexes
         merger.add(reader);
@@ -3157,7 +3157,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {
     // Bind a new segment name here so even with
     // ConcurrentMergePolicy we keep deterministic segment
     // names.
-    merge.info = new SegmentInfo(newSegmentName(), 0, directory, false, null, new FieldInfos(globalFieldNumberMap));
+    merge.info = new SegmentInfo(newSegmentName(), 0, directory, false, null, new MutableFieldInfos(globalFieldNumberMap));
 
     // TODO: in the non-pool'd case this is somewhat
     // wasteful, because we open these readers, close them,
@@ -3320,7 +3320,8 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {
 
     final MergeState.CheckAbort checkAbort = new MergeState.CheckAbort(merge, directory);
     SegmentMerger merger = new SegmentMerger(infoStream, directory, config.getTermIndexInterval(), mergedName, checkAbort,
-                                             payloadProcessorProvider, merge.info.getFieldInfos(), codec, context);
+        // nocommit
+                                             payloadProcessorProvider, (MutableFieldInfos)merge.info.getFieldInfos(), codec, context);
 
     if (infoStream.isEnabled("IW")) {
       infoStream.message("IW", "merging " + segString(merge.segments) + " mergeVectors=" + merge.info.getFieldInfos().hasVectors());
diff --git a/lucene/core/src/java/org/apache/lucene/index/MergeState.java b/lucene/core/src/java/org/apache/lucene/index/MergeState.java
index b42661b..b0839f5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MergeState.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MergeState.java
@@ -40,7 +40,8 @@ public class MergeState {
     }
   }
 
-  public FieldInfos fieldInfos;
+  // nocommit...
+  public MutableFieldInfos fieldInfos;
   public List<IndexReaderAndLiveDocs> readers;        // Readers & liveDocs being merged
   public int[][] docMaps;                             // Maps docIDs around deletions
   public int[] docBase;                               // New docID base per reader
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiFields.java b/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
index 9bd226c..7ad496d 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiFields.java
@@ -248,7 +248,8 @@ public final class MultiFields extends Fields {
   public static FieldInfos getMergedFieldInfos(IndexReader reader) {
     final List<AtomicReader> subReaders = new ArrayList<AtomicReader>();
     ReaderUtil.gatherSubReaders(subReaders, reader);
-    final FieldInfos fieldInfos = new FieldInfos();
+    // nocommit: this should be read-only
+    final MutableFieldInfos fieldInfos = new MutableFieldInfos();
     for(AtomicReader subReader : subReaders) {
       fieldInfos.add(subReader.getFieldInfos());
     }
diff --git a/lucene/core/src/java/org/apache/lucene/index/MutableFieldInfos.java b/lucene/core/src/java/org/apache/lucene/index/MutableFieldInfos.java
new file mode 100644
index 0000000..508d283
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/MutableFieldInfos.java
@@ -0,0 +1,442 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+
+// nocommit: only public temporarily for FieldsConsumer (until we fix SegmentMerger)
+public final class MutableFieldInfos extends FieldInfos {
+  static final class FieldNumberBiMap {
+    
+    private final Map<Integer,String> numberToName;
+    private final Map<String,Integer> nameToNumber;
+    private int lowestUnassignedFieldNumber = -1;
+    
+    FieldNumberBiMap() {
+      this.nameToNumber = new HashMap<String, Integer>();
+      this.numberToName = new HashMap<Integer, String>();
+    }
+    
+    /**
+     * Returns the global field number for the given field name. If the name
+     * does not exist yet it tries to add it with the given preferred field
+     * number assigned if possible otherwise the first unassigned field number
+     * is used as the field number.
+     */
+    synchronized int addOrGet(String fieldName, int preferredFieldNumber) {
+      Integer fieldNumber = nameToNumber.get(fieldName);
+      if (fieldNumber == null) {
+        final Integer preferredBoxed = Integer.valueOf(preferredFieldNumber);
+
+        if (preferredFieldNumber != -1 && !numberToName.containsKey(preferredBoxed)) {
+            // cool - we can use this number globally
+            fieldNumber = preferredBoxed;
+        } else {
+          // find a new FieldNumber
+          while (numberToName.containsKey(++lowestUnassignedFieldNumber)) {
+            // might not be up to date - lets do the work once needed
+          }
+          fieldNumber = lowestUnassignedFieldNumber;
+        }
+        
+        numberToName.put(fieldNumber, fieldName);
+        nameToNumber.put(fieldName, fieldNumber);
+        
+      }
+
+      return fieldNumber.intValue();
+    }
+
+    /**
+     * Sets the given field number and name if not yet set. 
+     */
+    synchronized void setIfNotSet(int fieldNumber, String fieldName) {
+      final Integer boxedFieldNumber = Integer.valueOf(fieldNumber);
+      if (!numberToName.containsKey(boxedFieldNumber)
+          && !nameToNumber.containsKey(fieldName)) {
+        numberToName.put(boxedFieldNumber, fieldName);
+        nameToNumber.put(fieldName, boxedFieldNumber);
+      } else {
+        assert containsConsistent(boxedFieldNumber, fieldName);
+      }
+    }
+    
+    // used by assert
+    synchronized boolean containsConsistent(Integer number, String name) {
+      return name.equals(numberToName.get(number))
+          && number.equals(nameToNumber.get(name));
+    }
+  }
+  
+  private final SortedMap<Integer,FieldInfo> byNumber = new TreeMap<Integer,FieldInfo>();
+  private final HashMap<String,FieldInfo> byName = new HashMap<String,FieldInfo>();
+  private final FieldNumberBiMap globalFieldNumbers;
+  
+  private boolean hasFreq; // only set if readonly
+  private boolean hasProx; // only set if readonly
+  private boolean hasVectors; // only set if readonly
+  private long version; // internal use to track changes
+
+  /**
+   * Creates a new read-only FieldInfos: only public to be accessible
+   * from the codecs package
+   * 
+   * @lucene.internal
+   */
+  public MutableFieldInfos(FieldInfo[] infos, boolean hasFreq, boolean hasProx, boolean hasVectors) {
+    this(null);
+    this.hasFreq = hasFreq;
+    this.hasProx = hasProx;
+    this.hasVectors = hasVectors;
+    for (FieldInfo info : infos) {
+      putInternal(info);
+    }
+  }
+
+  public MutableFieldInfos() {
+    this(new FieldNumberBiMap());
+  }
+
+  public void add(FieldInfos other) {
+    for(FieldInfo fieldInfo : other){ 
+      add(fieldInfo);
+    }
+  }
+
+  /**
+   * Creates a new FieldInfos instance with the given {@link FieldNumberBiMap}. 
+   * If the {@link FieldNumberBiMap} is <code>null</code> this instance will be read-only.
+   * @see #isReadOnly()
+   */
+  MutableFieldInfos(FieldNumberBiMap globalFieldNumbers) {
+    this.globalFieldNumbers = globalFieldNumbers;
+  }
+  
+  /**
+   * adds the given field to this FieldInfos name / number mapping. The given FI
+   * must be present in the global field number mapping before this method it
+   * called
+   */
+  private void putInternal(FieldInfo fi) {
+    assert !byNumber.containsKey(fi.number);
+    assert !byName.containsKey(fi.name);
+    assert globalFieldNumbers == null || globalFieldNumbers.containsConsistent(Integer.valueOf(fi.number), fi.name);
+    byNumber.put(fi.number, fi);
+    byName.put(fi.name, fi);
+  }
+  
+  private int nextFieldNumber(String name, int preferredFieldNumber) {
+    // get a global number for this field
+    final int fieldNumber = globalFieldNumbers.addOrGet(name,
+        preferredFieldNumber);
+    assert byNumber.get(fieldNumber) == null : "field number " + fieldNumber
+        + " already taken";
+    return fieldNumber;
+  }
+
+  /**
+   * Returns a deep clone of this FieldInfos instance.
+   */
+  @Override
+  synchronized public MutableFieldInfos clone() {
+    MutableFieldInfos fis = new MutableFieldInfos(globalFieldNumbers);
+    fis.hasFreq = hasFreq;
+    fis.hasProx = hasProx;
+    fis.hasVectors = hasVectors;
+    for (FieldInfo fi : this) {
+      FieldInfo clone = fi.clone();
+      fis.putInternal(clone);
+    }
+    return fis;
+  }
+
+  /** Returns true if any fields have positions */
+  public boolean hasProx() {
+    if (isReadOnly()) {
+      return hasProx;
+    }
+    // mutable FIs must check!
+    for (FieldInfo fi : this) {
+      if (fi.isIndexed && fi.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0) {
+        return true;
+      }
+    }
+    return false;
+  }
+  
+  /** Returns true if any fields have freqs */
+  public boolean hasFreq() {
+    if (isReadOnly()) {
+      return hasFreq;
+    }
+    // mutable FIs must check!
+    for (FieldInfo fi : this) {
+      if (fi.isIndexed && fi.indexOptions != IndexOptions.DOCS_ONLY) {
+        return true;
+      }
+    }
+    return false;
+  }
+  
+  /**
+   * Assumes the fields are not storing term vectors.
+   * 
+   * @param names The names of the fields
+   * @param isIndexed Whether the fields are indexed or not
+   * 
+   * @see #addOrUpdate(String, boolean)
+   */
+  synchronized public void addOrUpdate(Collection<String> names, boolean isIndexed) {
+    for (String name : names) {
+      addOrUpdate(name, isIndexed);
+    }
+  }
+
+  /**
+   * Calls 5 parameter add with false for all TermVector parameters.
+   * 
+   * @param name The name of the IndexableField
+   * @param isIndexed true if the field is indexed
+   * @see #addOrUpdate(String, boolean, boolean)
+   */
+  synchronized public void addOrUpdate(String name, boolean isIndexed) {
+    addOrUpdate(name, isIndexed, false, false);
+  }
+
+  /** If the field is not yet known, adds it. If it is known, checks to make
+   *  sure that the isIndexed flag is the same as was given previously for this
+   *  field. If not - marks it as being indexed.  Same goes for the TermVector
+   * parameters.
+   * 
+   * @param name The name of the field
+   * @param isIndexed true if the field is indexed
+   * @param storeTermVector true if the term vector should be stored
+   */
+  synchronized public void addOrUpdate(String name, boolean isIndexed, boolean storeTermVector) {
+    addOrUpdate(name, isIndexed, storeTermVector, false);
+  }
+
+    /** If the field is not yet known, adds it. If it is known, checks to make
+   *  sure that the isIndexed flag is the same as was given previously for this
+   *  field. If not - marks it as being indexed.  Same goes for the TermVector
+   * parameters.
+   *
+   * @param name The name of the field
+   * @param isIndexed true if the field is indexed
+   * @param storeTermVector true if the term vector should be stored
+   * @param omitNorms true if the norms for the indexed field should be omitted
+   */
+  synchronized public void addOrUpdate(String name, boolean isIndexed, boolean storeTermVector,
+                  boolean omitNorms) {
+    addOrUpdate(name, isIndexed, storeTermVector, omitNorms, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, null, null);
+  }
+  
+  /** If the field is not yet known, adds it. If it is known, checks to make
+   *  sure that the isIndexed flag is the same as was given previously for this
+   *  field. If not - marks it as being indexed.  Same goes for the TermVector
+   * parameters.
+   *
+   * @param name The name of the field
+   * @param isIndexed true if the field is indexed
+   * @param storeTermVector true if the term vector should be stored
+   * @param omitNorms true if the norms for the indexed field should be omitted
+   * @param storePayloads true if payloads should be stored for this field
+   * @param indexOptions if term freqs should be omitted for this field
+   */
+  synchronized public FieldInfo addOrUpdate(String name, boolean isIndexed, boolean storeTermVector,
+                       boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValues.Type docValues, DocValues.Type normType) {
+    return addOrUpdateInternal(name, -1, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);
+  }
+
+  // NOTE: this method does not carry over termVector
+  // booleans nor docValuesType; the indexer chain
+  // (TermVectorsConsumerPerField, DocFieldProcessor) must
+  // set these fields when they succeed in consuming
+  // the document:
+  public FieldInfo addOrUpdate(String name, IndexableFieldType fieldType) {
+    // TODO: really, indexer shouldn't even call this
+    // method (it's only called from DocFieldProcessor);
+    // rather, each component in the chain should update
+    // what it "owns".  EG fieldType.indexOptions() should
+    // be updated by maybe FreqProxTermsWriterPerField:
+    return addOrUpdateInternal(name, -1, fieldType.indexed(), false,
+                               fieldType.omitNorms(), false,
+                               fieldType.indexOptions(), null, null);
+  }
+
+  synchronized private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber, boolean isIndexed,
+      boolean storeTermVector,
+      boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValues.Type docValues, DocValues.Type normType) {
+    if (globalFieldNumbers == null) {
+      throw new IllegalStateException("FieldInfos are read-only, create a new instance with a global field map to make modifications to FieldInfos");
+    }
+    FieldInfo fi = fieldInfo(name);
+    if (fi == null) {
+      final int fieldNumber = nextFieldNumber(name, preferredFieldNumber);
+      fi = addInternal(name, fieldNumber, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, normType);
+    } else {
+      fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);
+      if (docValues != null) {
+        fi.setDocValuesType(docValues, true);
+      }
+      if (normType != null) {
+        fi.setNormValueType(normType, true);
+      }
+    }
+    version++;
+    return fi;
+  }
+  
+  synchronized public FieldInfo add(FieldInfo fi) {
+    // IMPORTANT - reuse the field number if possible for consistent field numbers across segments
+    return addOrUpdateInternal(fi.name, fi.number, fi.isIndexed, fi.storeTermVector,
+               fi.omitNorms, fi.storePayloads,
+               fi.indexOptions, fi.getDocValuesType(), fi.getNormType());
+  }
+  
+  /*
+   * NOTE: if you call this method from a public method make sure you check if we are modifiable and throw an exception otherwise
+   */
+  private FieldInfo addInternal(String name, int fieldNumber, boolean isIndexed,
+                                boolean storeTermVector, boolean omitNorms, boolean storePayloads,
+                                IndexOptions indexOptions, DocValues.Type docValuesType, DocValues.Type normType) {
+    // don't check modifiable here since we use that to initially build up FIs
+    if (globalFieldNumbers != null) {
+      globalFieldNumbers.setIfNotSet(fieldNumber, name);
+    } 
+    final FieldInfo fi = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValuesType, normType);
+    putInternal(fi);
+    return fi;
+  }
+
+  public FieldInfo fieldInfo(String fieldName) {
+    return byName.get(fieldName);
+  }
+
+  /**
+   * Return the fieldinfo object referenced by the fieldNumber.
+   * @param fieldNumber
+   * @return the FieldInfo object or null when the given fieldNumber
+   * doesn't exist.
+   */  
+  public FieldInfo fieldInfo(int fieldNumber) {
+    return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
+  }
+
+  public Iterator<FieldInfo> iterator() {
+    return byNumber.values().iterator();
+  }
+
+  /**
+   * @return number of fields
+   */
+  public int size() {
+    assert byNumber.size() == byName.size();
+    return byNumber.size();
+  }
+
+  /**
+   * @return true if at least one field has any vectors
+   */
+  public boolean hasVectors() {
+    if (isReadOnly()) {
+      return hasVectors;
+    }
+    // mutable FIs must check
+    for (FieldInfo fi : this) {
+      if (fi.storeTermVector) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * @return true if at least one field has any norms
+   */
+  public boolean hasNorms() {
+    for (FieldInfo fi : this) {
+      if (fi.hasNorms()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns <code>true</code> iff this instance is not backed by a
+   * {@link org.apache.lucene.index.FieldInfos.FieldNumberBiMap}. Instances read from a directory via
+   * {@link FieldInfos#FieldInfos(FieldInfo[], boolean, boolean, boolean)} will always be read-only
+   * since no {@link org.apache.lucene.index.FieldInfos.FieldNumberBiMap} is supplied, otherwise 
+   * <code>false</code>.
+   */
+  public final boolean isReadOnly() {
+    return globalFieldNumbers == null;
+  }
+  
+  synchronized final long getVersion() {
+    return version;
+  }
+  
+  // nocommit
+  final ReadOnlyFieldInfos asReadOnly() {
+    FieldInfo infos[] = new FieldInfo[size()];
+    int upto = 0;
+    boolean hasVectors = false;
+    boolean hasProx = false;
+    boolean hasFreq = false;
+    for (FieldInfo info : this) {
+      infos[upto++] = info.clone();
+      hasVectors |= info.storeTermVector;
+      hasProx |= info.isIndexed && info.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
+      hasFreq |= info.isIndexed && info.indexOptions != IndexOptions.DOCS_ONLY;
+    }
+    return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
+  }
+
+  /**
+   * @return true if at least one field has docValues
+   */
+  public boolean hasDocValues() {
+    for (FieldInfo fi : this) {
+      if (fi.hasDocValues()) { 
+        return true;
+      }
+    }
+
+    return false;
+  }
+  
+  /**
+   * Creates a new {@link FieldInfo} instance from the given instance. If the given instance is
+   * read-only this instance will be read-only too.
+   * 
+   * @see #isReadOnly()
+   */
+  // nocommit
+  static MutableFieldInfos from(MutableFieldInfos other) {
+    return new MutableFieldInfos(other.globalFieldNumbers);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader.java b/lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader.java
index 8e76d37..82d06f1 100644
--- a/lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/ParallelAtomicReader.java
@@ -48,7 +48,8 @@ import org.apache.lucene.util.Bits;
  * undefined behavior</em>.
  */
 public final class ParallelAtomicReader extends AtomicReader {
-  private final FieldInfos fieldInfos = new FieldInfos();
+  // nocommit: make this read-only.
+  private final MutableFieldInfos fieldInfos = new MutableFieldInfos();
   private final ParallelFields fields = new ParallelFields();
   private final AtomicReader[] parallelReaders, storedFieldsReaders;
   private final Set<AtomicReader> completeReaderSet =
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReadOnlyFieldInfos.java b/lucene/core/src/java/org/apache/lucene/index/ReadOnlyFieldInfos.java
new file mode 100644
index 0000000..a8b2d9f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/index/ReadOnlyFieldInfos.java
@@ -0,0 +1,109 @@
+package org.apache.lucene.index;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// nocommit: temporary
+public final class ReadOnlyFieldInfos extends FieldInfos {
+  // nocommit
+  private final boolean hasFreq;
+  private final boolean hasProx;
+  private final boolean hasVectors;
+  private final boolean hasNorms;
+  private final boolean hasDocValues;
+  
+  private final SortedMap<Integer,FieldInfo> byNumber = new TreeMap<Integer,FieldInfo>();
+  private final HashMap<String,FieldInfo> byName = new HashMap<String,FieldInfo>();
+  
+  public ReadOnlyFieldInfos(FieldInfo[] infos, boolean hasFreq, boolean hasProx, boolean hasVectors) {
+    this.hasFreq = hasFreq;
+    this.hasProx = hasProx;
+    this.hasVectors = hasVectors;
+    
+    boolean hasNorms = false;
+    boolean hasDocValues = false;
+    
+    for (FieldInfo info : infos) {
+      assert !byNumber.containsKey(info.number);
+      byNumber.put(info.number, info);
+      assert !byName.containsKey(info.name);
+      byName.put(info.name, info);
+      
+      hasNorms |= info.hasNorms();
+      hasDocValues |= info.hasDocValues();
+    }
+    
+    this.hasNorms = hasNorms;
+    this.hasDocValues = hasDocValues;
+  }
+  
+  public boolean hasFreq() {
+    return hasFreq;
+  }
+  
+  public boolean hasProx() {
+    return hasProx;
+  }
+  
+  public boolean hasVectors() {
+    return hasVectors;
+  }
+  
+  public boolean hasNorms() {
+    return hasNorms;
+  }
+  
+  public boolean hasDocValues() {
+    return hasDocValues;
+  }
+  
+  public int size() {
+    assert byNumber.size() == byName.size();
+    return byNumber.size();
+  }
+  
+  public Iterator<FieldInfo> iterator() {
+    return byNumber.values().iterator();
+  }
+
+  @Override
+  public FieldInfo fieldInfo(String fieldName) {
+    return byName.get(fieldName);
+  }
+
+  @Override
+  public FieldInfo fieldInfo(int fieldNumber) {
+    return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
+  }
+
+  // nocommit: probably unnecessary
+  @Override
+  public ReadOnlyFieldInfos clone() {
+    FieldInfo infos[] = new FieldInfo[size()];
+    int upto = 0;
+    for (FieldInfo info : this) {
+      infos[upto++] = info.clone();
+    }
+    return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
index 8b3cea5..4f45d03 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
@@ -383,7 +383,8 @@ public final class SegmentInfo implements Cloneable {
 
   public List<String> files() throws IOException {
     final long fisVersion = fieldInfosVersion;
-    if (fisVersion != (fieldInfosVersion = getFieldInfos().getVersion())) {
+    // nocommit: fix this once we detangle
+    if (true /* fisVersion != (fieldInfosVersion = getFieldInfos().getVersion()) */) {
       clearFilesCache(); // FIS has modifications - need to recompute
     } else if (files != null) {
       // Already cached:
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
index f07d350..55aee19 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
@@ -34,7 +34,7 @@ import java.util.Set;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.SegmentInfosReader;
 import org.apache.lucene.codecs.SegmentInfosWriter;
-import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
+import org.apache.lucene.index.MutableFieldInfos.FieldNumberBiMap;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java b/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
index d205afd..ad5fc1d 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
@@ -55,7 +55,7 @@ final class SegmentMerger {
   
   private final MergeState mergeState = new MergeState();
 
-  SegmentMerger(InfoStream infoStream, Directory dir, int termIndexInterval, String name, MergeState.CheckAbort checkAbort, PayloadProcessorProvider payloadProcessorProvider, FieldInfos fieldInfos, Codec codec, IOContext context) {
+  SegmentMerger(InfoStream infoStream, Directory dir, int termIndexInterval, String name, MergeState.CheckAbort checkAbort, PayloadProcessorProvider payloadProcessorProvider, MutableFieldInfos fieldInfos, Codec codec, IOContext context) {
     mergeState.infoStream = infoStream;
     mergeState.readers = new ArrayList<MergeState.IndexReaderAndLiveDocs>();
     mergeState.fieldInfos = fieldInfos;
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java b/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
index 19246d4..82e8d25 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
@@ -87,7 +87,7 @@ public class TestCodecs extends LuceneTestCase {
     final boolean omitTF;
     final boolean storePayloads;
 
-    public FieldData(final String name, final FieldInfos fieldInfos, final TermData[] terms, final boolean omitTF, final boolean storePayloads) {
+    public FieldData(final String name, final MutableFieldInfos fieldInfos, final TermData[] terms, final boolean omitTF, final boolean storePayloads) {
       this.omitTF = omitTF;
       this.storePayloads = storePayloads;
       fieldInfos.addOrUpdate(name, true);
@@ -249,7 +249,7 @@ public class TestCodecs extends LuceneTestCase {
       terms[i] = new TermData(text, docs, null);
     }
 
-    final FieldInfos fieldInfos = new FieldInfos(new FieldInfos.FieldNumberBiMap());
+    final MutableFieldInfos fieldInfos = new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap());
 
     final FieldData field = new FieldData("field", fieldInfos, terms, true, false);
     final FieldData[] fields = new FieldData[] {field};
@@ -296,7 +296,7 @@ public class TestCodecs extends LuceneTestCase {
   }
 
   public void testRandomPostings() throws Throwable {
-    final FieldInfos fieldInfos = new FieldInfos(new FieldInfos.FieldNumberBiMap());
+    final MutableFieldInfos fieldInfos = new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap());
 
     final FieldData[] fields = new FieldData[NUM_FIELDS];
     for(int i=0;i<NUM_FIELDS;i++) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDoc.java b/lucene/core/src/test/org/apache/lucene/index/TestDoc.java
index 65fcc04..7212aa0 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDoc.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDoc.java
@@ -194,7 +194,7 @@ public class TestDoc extends LuceneTestCase {
       SegmentReader r2 = new SegmentReader(si2, DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR, context);
 
       final Codec codec = Codec.getDefault();
-      SegmentMerger merger = new SegmentMerger(InfoStream.getDefault(), si1.dir, IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL, merged, MergeState.CheckAbort.NONE, null, new FieldInfos(new FieldInfos.FieldNumberBiMap()), codec, context);
+      SegmentMerger merger = new SegmentMerger(InfoStream.getDefault(), si1.dir, IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL, merged, MergeState.CheckAbort.NONE, null, new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap()), codec, context);
 
       merger.add(r1);
       merger.add(r2);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java b/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java
index 83cfa24..6a36c15 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java
@@ -46,7 +46,7 @@ public class TestFieldInfos extends LuceneTestCase {
   public FieldInfos createAndWriteFieldInfos(Directory dir, String filename) throws IOException{
   //Positive test of FieldInfos
     assertTrue(testDoc != null);
-    FieldInfos fieldInfos = new FieldInfos(new FieldInfos.FieldNumberBiMap());
+    MutableFieldInfos fieldInfos = new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap());
     _TestUtil.add(testDoc, fieldInfos);
     //Since the complement is stored as well in the fields map
     assertTrue(fieldInfos.size() == DocHelper.all.size()); //this is all b/c we are using the no-arg constructor
@@ -109,57 +109,11 @@ public class TestFieldInfos extends LuceneTestCase {
     dir.close();
   }
   
-  private void assertReadOnly(FieldInfos readOnly, FieldInfos modifiable) {
-    assertTrue(readOnly.isReadOnly());
-    assertFalse(modifiable.isReadOnly());
-    try {
-      readOnly.add(modifiable.fieldInfo(0));
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    
-    try {
-      readOnly.addOrUpdate("bogus", random().nextBoolean());
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    try {
-      readOnly.addOrUpdate("bogus", random().nextBoolean(), random().nextBoolean());
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    try {
-      readOnly.addOrUpdate("bogus", random().nextBoolean(), random().nextBoolean(),
-          random().nextBoolean());
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    try {
-      readOnly.addOrUpdate("bogus", random().nextBoolean(), random().nextBoolean(),
-          random().nextBoolean(),
-          random().nextBoolean(), random().nextBoolean() ? IndexOptions.DOCS_ONLY : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, null, null);
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    try {
-      readOnly.addOrUpdate(Arrays.asList("a", "b", "c"), random().nextBoolean());
-      fail("instance should be read only");
-    } catch (IllegalStateException e) {
-      // expected
-    }
-    
+  private void assertReadOnly(FieldInfos readOnly, FieldInfos modifiable) {    
     assertEquals(modifiable.size(), readOnly.size());
     // assert we can iterate
     for (FieldInfo fi : readOnly) {
       assertEquals(fi.name, modifiable.fieldInfo(fi.number).name);
     }
-    
   }
-  
-  
 }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java b/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
index 44727d5..5703e82 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
@@ -49,11 +49,11 @@ import org.junit.BeforeClass;
 public class TestFieldsReader extends LuceneTestCase {
   private static Directory dir;
   private static Document testDoc = new Document();
-  private static FieldInfos fieldInfos = null;
+  private static MutableFieldInfos fieldInfos = null;
 
   @BeforeClass
   public static void beforeClass() throws Exception {
-    fieldInfos = new FieldInfos(new FieldInfos.FieldNumberBiMap());
+    fieldInfos = new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap());
     DocHelper.setupDoc(testDoc);
     _TestUtil.add(testDoc, fieldInfos);
     dir = newDirectory();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java b/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
index 88f61aa..f9915ac 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
@@ -76,7 +76,7 @@ public class TestSegmentMerger extends LuceneTestCase {
 
   public void testMerge() throws IOException {
     final Codec codec = Codec.getDefault();
-    SegmentMerger merger = new SegmentMerger(InfoStream.getDefault(), mergedDir, IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL, mergedSegment, MergeState.CheckAbort.NONE, null, new FieldInfos(new FieldInfos.FieldNumberBiMap()), codec, newIOContext(random()));
+    SegmentMerger merger = new SegmentMerger(InfoStream.getDefault(), mergedDir, IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL, mergedSegment, MergeState.CheckAbort.NONE, null, new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap()), codec, newIOContext(random()));
     merger.add(reader1);
     merger.add(reader2);
     MergeState mergeState = merger.merge();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTermVectorsReader.java b/lucene/core/src/test/org/apache/lucene/index/TestTermVectorsReader.java
index 1b21528..a34cc8b 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTermVectorsReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTermVectorsReader.java
@@ -48,7 +48,8 @@ public class TestTermVectorsReader extends LuceneTestCase {
   private int[][] positions = new int[testTerms.length][];
   private Directory dir;
   private SegmentInfo seg;
-  private FieldInfos fieldInfos = new FieldInfos(new FieldInfos.FieldNumberBiMap());
+  // nocommit: make a fieldInfos.empty for stuff like this?
+  private FieldInfos fieldInfos = new MutableFieldInfos(new MutableFieldInfos.FieldNumberBiMap());
   private static int TERM_FREQ = 3;
 
   private class TestToken implements Comparable<TestToken> {
diff --git a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index d6615bc..4384889 100644
--- a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
+++ b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -35,6 +35,7 @@ import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.MutableFieldInfos;
 import org.apache.lucene.index.Norm;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocsAndPositionsEnum;
@@ -199,7 +200,7 @@ public class MemoryIndex {
 
   private static final boolean DEBUG = false;
 
-  private final FieldInfos fieldInfos;
+  private final MutableFieldInfos fieldInfos;
   
   /**
    * Sorts term entries into ascending order; also works for
@@ -235,7 +236,8 @@ public class MemoryIndex {
    */
   protected MemoryIndex(boolean storeOffsets) {
     this.stride = storeOffsets ? 3 : 1;
-    fieldInfos = new FieldInfos();
+    // nocommit: this can probably have a much simpler implementation
+    fieldInfos = new MutableFieldInfos();
   }
   
   /**
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWFieldInfosReader.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWFieldInfosReader.java
index ff149ac..9d8b56e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWFieldInfosReader.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWFieldInfosReader.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.IndexFormatTooNewException;
 import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.index.ReadOnlyFieldInfos;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.Directory;
@@ -105,7 +106,7 @@ class PreFlexRWFieldInfosReader extends FieldInfosReader {
       if (input.getFilePointer() != input.length()) {
         throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read " + input.getFilePointer() + " vs size " + input.length() + " (resource: " + input + ")");
       }
-      return new FieldInfos(infos, hasFreq, hasProx, hasVectors);
+      return new ReadOnlyFieldInfos(infos, hasFreq, hasProx, hasVectors);
     } finally {
       input.close();
     }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/FieldFilterAtomicReader.java b/lucene/test-framework/src/java/org/apache/lucene/index/FieldFilterAtomicReader.java
index 972f8ae..da0f452 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/FieldFilterAtomicReader.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/FieldFilterAtomicReader.java
@@ -26,13 +26,14 @@ public final class FieldFilterAtomicReader extends FilterAtomicReader {
   
   private final Set<String> fields;
   private final boolean negate;
-  private final FieldInfos fieldInfos;
+  // nocommit: make read only
+  private final MutableFieldInfos fieldInfos;
 
   public FieldFilterAtomicReader(AtomicReader in, Set<String> fields, boolean negate) {
     super(in);
     this.fields = fields;
     this.negate = negate;
-    this.fieldInfos = new FieldInfos();
+    this.fieldInfos = new MutableFieldInfos();
     for (FieldInfo fi : in.getFieldInfos()) {
       if (hasField(fi.name)) {
         fieldInfos.add(fi);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
index a3ea569..e967ef4 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
@@ -62,6 +62,7 @@ import org.apache.lucene.index.LogMergePolicy;
 import org.apache.lucene.index.MergePolicy;
 import org.apache.lucene.index.MergeScheduler;
 import org.apache.lucene.index.MultiFields;
+import org.apache.lucene.index.MutableFieldInfos;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.TieredMergePolicy;
@@ -679,7 +680,8 @@ public class _TestUtil {
   }
   
   /** Adds field info for a Document. */
-  public static void add(Document doc, FieldInfos fieldInfos) {
+  // nocommit: what uses this?
+  public static void add(Document doc, MutableFieldInfos fieldInfos) {
     for (IndexableField field : doc) {
       fieldInfos.addOrUpdate(field.name(), field.fieldType());
     }
diff --git a/solr/core/src/test/org/apache/solr/search/TestDocSet.java b/solr/core/src/test/org/apache/solr/search/TestDocSet.java
index c599c1c..d951ddc 100644
--- a/solr/core/src/test/org/apache/solr/search/TestDocSet.java
+++ b/solr/core/src/test/org/apache/solr/search/TestDocSet.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.Random;
 
+import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.StoredFieldVisitor;
@@ -30,6 +31,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.ReadOnlyFieldInfos;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Filter;
@@ -365,7 +367,8 @@ public class TestDocSet extends LuceneTestCase {
 
       @Override
       public FieldInfos getFieldInfos() {
-        return new FieldInfos();
+        // nocommit
+        return new ReadOnlyFieldInfos(new FieldInfo[0], false, false, false);
       }
 
       @Override

