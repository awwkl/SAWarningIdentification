GitDiffStart: 550a4ef1afd7651dc20110c0b079fb03665ca9da | Wed Dec 9 12:08:06 2009 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 0442a3e..da617db 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -83,6 +83,10 @@ Optimizations
 
 Build
 
+ * LUCENE-2124: Moved the JDK-based collation support from contrib/collation 
+   into core, and moved the ICU-based collation support into contrib/icu.  
+   (Robert Muir)
+
 Test Cases
 
 * LUCENE-2037 Allow Junit4 tests in our envrionment (Erick Erickson
diff --git a/NOTICE.txt b/NOTICE.txt
index 8eeeb61..593f25c 100644
--- a/NOTICE.txt
+++ b/NOTICE.txt
@@ -30,6 +30,6 @@ Includes lib/servlet-api-2.4.jar from  Apache Tomcat
 The SmartChineseAnalyzer source code (under contrib/analyzers) was
 provided by Xiaoping Gao and copyright 2009 by www.imdict.net.
 
-ICU4J, (under contrib/collation) is licensed under an MIT styles license
-(contrib/collation/lib/ICU-LICENSE.txt) and Copyright (c) 1995-2008 
+ICU4J, (under contrib/icu) is licensed under an MIT styles license
+(contrib/icu/lib/ICU-LICENSE.txt) and Copyright (c) 1995-2008 
 International Business Machines Corporation and others
diff --git a/build.xml b/build.xml
index 15a4c76..05d1246 100644
--- a/build.xml
+++ b/build.xml
@@ -300,7 +300,7 @@
           <packageset dir="contrib/analyzers/smartcn/src/java"/>
           <packageset dir="contrib/ant/src/java"/>
           <packageset dir="contrib/benchmark/src/java"/>
-          <packageset dir="contrib/collation/src/java"/>
+          <packageset dir="contrib/icu/src/java"/>
           <packageset dir="contrib/db/bdb-je/src/java"/>
           <packageset dir="contrib/db/bdb/src/java"/>
           <packageset dir="contrib/fast-vector-highlighter/src/java"/>
@@ -334,7 +334,7 @@
           <group title="contrib: Analysis" packages="org.apache.lucene.analysis.*"/>
           <group title="contrib: Ant" packages="org.apache.lucene.ant*"/>
           <group title="contrib: Benchmark" packages="org.apache.lucene.benchmark*"/>
-          <group title="contrib: Collation" packages="org.apache.lucene.collation*"/>
+          <group title="contrib: ICU" packages="org.apache.lucene.collation*"/>
           <group title="contrib: DB" packages="org.apache.lucene.store.db*:org.apache.lucene.store.je*:com.sleepycat*"/>
           <group title="contrib: Fast Vector Highlighter" packages="org.apache.lucene.search.vectorhighlight*"/>
           <group title="contrib: Highlighter" packages="org.apache.lucene.search.highlight*"/>
diff --git a/contrib/CHANGES.txt b/contrib/CHANGES.txt
index 30719c1..f3b2997 100644
--- a/contrib/CHANGES.txt
+++ b/contrib/CHANGES.txt
@@ -37,6 +37,12 @@ New features
    
  * LUCENE-2062: Add a Bulgarian analyzer.  (Robert Muir, Simon Willnauer)
 
+Build
+
+ * LUCENE-2124: Moved the JDK-based collation support from contrib/collation 
+   into core, and moved the ICU-based collation support into contrib/icu.  
+   (Robert Muir)
+
 Test Cases
 
  * LUCENE-2115: Cutover contrib tests to use Java5 generics.  (Kay Kay
diff --git a/contrib/collation/build.xml b/contrib/collation/build.xml
deleted file mode 100644
index 5f03c20..0000000
--- a/contrib/collation/build.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0"?>
-
-<!--
-    Licensed to the Apache Software Foundation (ASF) under one or more
-    contributor license agreements.  See the NOTICE file distributed with
-    this work for additional information regarding copyright ownership.
-    The ASF licenses this file to You under the Apache License, Version 2.0
-    the "License"); you may not use this file except in compliance with
-    the License.  You may obtain a copy of the License at
- 
-        http://www.apache.org/licenses/LICENSE-2.0
- 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
- -->
-
-<project name="collation" default="default">
-
-  <description>
-    CollationKeyFilter, ICUCollationKeyFilter, CollationKeyAnalyzer, and
-    ICUCollationKeyAnalyzer - converts tokens into indexable collation keys
-  </description>
-
-
-  <path id="additional.dependencies">
-    <fileset dir="lib" includes="icu4j-*.jar"/>
-    <pathelement location="../../build/contrib/misc/classes/java"/>
-  </path>
-
-  <pathconvert property="project.classpath"
-               targetos="unix"
-               refid="additional.dependencies"
-  />
-
-  <import file="../contrib-build.xml"/>
-
-  <target name="compile-misc">
-    <subant target="compile">
-       <fileset dir="${common.dir}/contrib/misc" includes="build.xml"/>
-    </subant>
-  </target>
-
-  <target name="init" depends="common.init,compile-misc"/>
-
-  <target name="compile" depends="init">
-    <antcall target="common.compile" inheritRefs="true" />
-  </target>
-
-</project>
diff --git a/contrib/collation/lib/ICU-LICENSE.txt b/contrib/collation/lib/ICU-LICENSE.txt
deleted file mode 100644
index 6eab042..0000000
--- a/contrib/collation/lib/ICU-LICENSE.txt
+++ /dev/null
@@ -1,33 +0,0 @@
-ICU License - ICU 1.8.1 and later
-
-COPYRIGHT AND PERMISSION NOTICE
-
-Copyright (c) 1995-2008 International Business Machines Corporation and others
-
-All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, and/or sell copies of the
-Software, and to permit persons to whom the Software is furnished to do so,
-provided that the above copyright notice(s) and this permission notice appear
-in all copies of the Software and that both the above copyright notice(s) and
-this permission notice appear in supporting documentation.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
-IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE
-LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
-IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-Except as contained in this notice, the name of a copyright holder shall not
-be used in advertising or otherwise to promote the sale, use or other
-dealings in this Software without prior written authorization of the
-copyright holder.
-
-All trademarks and registered trademarks mentioned herein are the property of
-their respective owners.
diff --git a/contrib/collation/lib/icu4j-collation-4.0.jar b/contrib/collation/lib/icu4j-collation-4.0.jar
deleted file mode 100644
index 4f1cb40..0000000
--- a/contrib/collation/lib/icu4j-collation-4.0.jar
+++ /dev/null
@@ -1,2 +0,0 @@
-AnyObjectId[1159f04caacfda235b66d73dc65198fa40153812] was removed in git history.
-Apache SVN contains full history.
\ No newline at end of file
diff --git a/contrib/collation/pom.xml.template b/contrib/collation/pom.xml.template
deleted file mode 100644
index 5f1b662..0000000
--- a/contrib/collation/pom.xml.template
+++ /dev/null
@@ -1,47 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-    
-    http://www.apache.org/licenses/LICENSE-2.0
-    
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-  -->
-  <modelVersion>4.0.0</modelVersion>
-  <parent>
-    <groupId>org.apache.lucene</groupId>
-    <artifactId>lucene-contrib</artifactId>
-    <version>@version@</version>
-  </parent>
-  <groupId>org.apache.lucene</groupId>
-  <artifactId>lucene-collation</artifactId>
-  <name>
-    Lucene CollationKeyFilter/Analyzer &amp; ICUCollationKeyFilter/Analyzer
-  </name>
-  <version>@version@</version>
-  <description>    
-    CollationKeyFilter, ICUCollationKeyFilter, CollationKeyAnalyzer, and
-    ICUCollationKeyAnalyzer - converts tokens into indexable collation keys
-  </description>
-  <packaging>jar</packaging>
-  <dependencies>
-    <dependency>
-      <groupId>com.ibm.icu</groupId>
-      <artifactId>icu4j</artifactId>
-      <version>${icu-version}</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java b/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
deleted file mode 100644
index 397a06b..0000000
--- a/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.KeywordTokenizer;
-import org.apache.lucene.analysis.Tokenizer;
-
-import java.text.Collator;
-import java.io.Reader;
-import java.io.IOException;
-
-/**
- * <p>
- *   Filters {@link KeywordTokenizer} with {@link CollationKeyFilter}.
- * </p>
- * <p>
- *   Converts the token into its {@link java.text.CollationKey}, and then
- *   encodes the CollationKey with 
- *   {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow 
- *   it to be stored as an index term.
- * </p>
- * <p>
- *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
- *   index and query time -- CollationKeys are only comparable when produced by
- *   the same Collator.  Since {@link java.text.RuleBasedCollator}s are not
- *   independently versioned, it is unsafe to search against stored
- *   CollationKeys unless the following are exactly the same (best practice is
- *   to store this information with the index and check that they remain the
- *   same at query time):
- * </p>
- * <ol>
- *   <li>JVM vendor</li>
- *   <li>JVM version, including patch version</li>
- *   <li>
- *     The language (and country and variant, if specified) of the Locale
- *     used when constructing the collator via
- *     {@link Collator#getInstance(java.util.Locale)}.
- *   </li>
- *   <li>
- *     The collation strength used - see {@link Collator#setStrength(int)}
- *   </li>
- * </ol> 
- * <p>
- *   {@link ICUCollationKeyAnalyzer} uses ICU4J's Collator, which makes 
- *   its version available, thus allowing collation to be versioned
- *   independently from the JVM.  ICUCollationKeyAnalyzer is also significantly
- *   faster and generates significantly shorter keys than CollationKeyAnalyzer.
- *   See <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
- *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
- *   generation timing and key length comparisons between ICU4J and
- *   java.text.Collator over several languages.
- * </p>
- * <p>
- *   CollationKeys generated by java.text.Collators are not compatible
- *   with those those generated by ICU Collators.  Specifically, if you use 
- *   CollationKeyAnalyzer to generate index terms, do not use
- *   ICUCollationKeyAnalyzer on the query side, or vice versa.
- * </p>
- */
-public class CollationKeyAnalyzer extends Analyzer {
-  private Collator collator;
-
-  public CollationKeyAnalyzer(Collator collator) {
-    this.collator = collator;
-  }
-
-  @Override
-  public TokenStream tokenStream(String fieldName, Reader reader) {
-    TokenStream result = new KeywordTokenizer(reader);
-    result = new CollationKeyFilter(result, collator);
-    return result;
-  }
-  
-  private class SavedStreams {
-    Tokenizer source;
-    TokenStream result;
-  }
-  
-  @Override
-  public TokenStream reusableTokenStream(String fieldName, Reader reader) 
-    throws IOException {
-    
-    SavedStreams streams = (SavedStreams)getPreviousTokenStream();
-    if (streams == null) {
-      streams = new SavedStreams();
-      streams.source = new KeywordTokenizer(reader);
-      streams.result = new CollationKeyFilter(streams.source, collator);
-      setPreviousTokenStream(streams);
-    } else {
-      streams.source.reset(reader);
-    }
-    return streams.result;
-  }
-}
diff --git a/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyFilter.java b/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyFilter.java
deleted file mode 100644
index 96d5ef1..0000000
--- a/contrib/collation/src/java/org/apache/lucene/collation/CollationKeyFilter.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Token;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
-import org.apache.lucene.util.IndexableBinaryStringTools;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.text.Collator;
-
-
-/**
- * <p>
- *   Converts each token into its {@link java.text.CollationKey}, and then
- *   encodes the CollationKey with {@link IndexableBinaryStringTools}, to allow 
- *   it to be stored as an index term.
- * </p>
- * <p>
- *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
- *   index and query time -- CollationKeys are only comparable when produced by
- *   the same Collator.  Since {@link java.text.RuleBasedCollator}s are not
- *   independently versioned, it is unsafe to search against stored
- *   CollationKeys unless the following are exactly the same (best practice is
- *   to store this information with the index and check that they remain the
- *   same at query time):
- * </p>
- * <ol>
- *   <li>JVM vendor</li>
- *   <li>JVM version, including patch version</li>
- *   <li>
- *     The language (and country and variant, if specified) of the Locale
- *     used when constructing the collator via
- *     {@link Collator#getInstance(java.util.Locale)}.
- *   </li>
- *   <li>
- *     The collation strength used - see {@link Collator#setStrength(int)}
- *   </li>
- * </ol> 
- * <p>
- *   {@link ICUCollationKeyFilter} uses ICU4J's Collator, which makes its
- *   version available, thus allowing collation to be versioned independently
- *   from the JVM.  ICUCollationKeyFilter is also significantly faster and
- *   generates significantly shorter keys than CollationKeyFilter.  See
- *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
- *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
- *   generation timing and key length comparisons between ICU4J and
- *   java.text.Collator over several languages.
- * </p>
- * <p>
- *   CollationKeys generated by java.text.Collators are not compatible
- *   with those those generated by ICU Collators.  Specifically, if you use 
- *   CollationKeyFilter to generate index terms, do not use
- *   {@link ICUCollationKeyFilter} on the query side, or vice versa.
- * </p>
- */
-public final class CollationKeyFilter extends TokenFilter {
-  private Collator collator = null;
-  private TermAttribute termAtt;
-
-  /**
-   * @param input Source token stream
-   * @param collator CollationKey generator
-   */
-  public CollationKeyFilter(TokenStream input, Collator collator) {
-    super(input);
-    this.collator = collator;
-    termAtt = addAttribute(TermAttribute.class);
-  }
-
-  @Override
-  public boolean incrementToken() throws IOException {
-    if (input.incrementToken()) {
-      char[] termBuffer = termAtt.termBuffer();
-      String termText = new String(termBuffer, 0, termAtt.termLength());
-      byte[] collationKey = collator.getCollationKey(termText).toByteArray();
-      ByteBuffer collationKeyBuf = ByteBuffer.wrap(collationKey);
-      int encodedLength
-        = IndexableBinaryStringTools.getEncodedLength(collationKeyBuf);
-      if (encodedLength > termBuffer.length) {
-        termAtt.resizeTermBuffer(encodedLength);
-      }
-      termAtt.setTermLength(encodedLength);
-      CharBuffer wrappedTermBuffer = CharBuffer.wrap(termAtt.termBuffer());
-      IndexableBinaryStringTools.encode(collationKeyBuf, wrappedTermBuffer);
-      return true;
-    } else {
-      return false;
-    }
-  }
-}
diff --git a/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java b/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java
deleted file mode 100644
index 387288a..0000000
--- a/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import com.ibm.icu.text.Collator;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.KeywordTokenizer;
-import org.apache.lucene.analysis.Tokenizer;
-
-import java.io.Reader;
-import java.io.IOException;
-
-
-/**
- * <p>
- *   Filters {@link KeywordTokenizer} with {@link ICUCollationKeyFilter}.
- * <p>
- *   Converts the token into its {@link com.ibm.icu.text.CollationKey}, and
- *   then encodes the CollationKey with 
- *   {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow it to
- *   be stored as an index term.
- * </p>
- * <p>
- *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
- *   index and query time -- CollationKeys are only comparable when produced by
- *   the same Collator.  {@link com.ibm.icu.text.RuleBasedCollator}s are 
- *   independently versioned, so it is safe to search against stored
- *   CollationKeys if the following are exactly the same (best practice is
- *   to store this information with the index and check that they remain the
- *   same at query time):
- * </p>
- * <ol>
- *   <li>
- *     Collator version - see {@link Collator#getVersion()}
- *   </li>
- *   <li>
- *     The collation strength used - see {@link Collator#setStrength(int)}
- *   </li>
- * </ol> 
- * <p>
- *   CollationKeys generated by ICU Collators are not compatible with those
- *   generated by java.text.Collators.  Specifically, if you use 
- *   ICUCollationKeyAnalyzer to generate index terms, do not use 
- *   {@link CollationKeyAnalyzer} on the query side, or vice versa.
- * </p>
- * <p>
- *   ICUCollationKeyAnalyzer is significantly faster and generates significantly
- *   shorter keys than CollationKeyAnalyzer.  See
- *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
- *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
- *   generation timing and key length comparisons between ICU4J and
- *   java.text.Collator over several languages.
- * </p>
- */
-public class ICUCollationKeyAnalyzer extends Analyzer {
-  private Collator collator;
-
-  public ICUCollationKeyAnalyzer(Collator collator) {
-    this.collator = collator;
-  }
-
-  @Override
-  public TokenStream tokenStream(String fieldName, Reader reader) {
-    TokenStream result = new KeywordTokenizer(reader);
-    result = new ICUCollationKeyFilter(result, collator);
-    return result;
-  }
-  
-  private class SavedStreams {
-    Tokenizer source;
-    TokenStream result;
-  }
-  
-  @Override
-  public TokenStream reusableTokenStream(String fieldName, Reader reader) 
-    throws IOException {
-    
-    SavedStreams streams = (SavedStreams)getPreviousTokenStream();
-    if (streams == null) {
-      streams = new SavedStreams();
-      streams.source = new KeywordTokenizer(reader);
-      streams.result = new ICUCollationKeyFilter(streams.source, collator);
-      setPreviousTokenStream(streams);
-    } else {
-      streams.source.reset(reader);
-    }
-    return streams.result;
-  }
-}
diff --git a/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java b/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java
deleted file mode 100644
index a008814..0000000
--- a/contrib/collation/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import com.ibm.icu.text.Collator;
-import com.ibm.icu.text.RawCollationKey;
-
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Token;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
-import org.apache.lucene.util.IndexableBinaryStringTools;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-
-
-/**
- * <p>
- *   Converts each token into its {@link com.ibm.icu.text.CollationKey}, and
- *   then encodes the CollationKey with {@link IndexableBinaryStringTools}, to
- *   allow it to be stored as an index term.
- * </p>
- * <p>
- *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
- *   index and query time -- CollationKeys are only comparable when produced by
- *   the same Collator.  {@link com.ibm.icu.text.RuleBasedCollator}s are 
- *   independently versioned, so it is safe to search against stored
- *   CollationKeys if the following are exactly the same (best practice is
- *   to store this information with the index and check that they remain the
- *   same at query time):
- * </p>
- * <ol>
- *   <li>
- *     Collator version - see {@link Collator#getVersion()}
- *   </li>
- *   <li>
- *     The collation strength used - see {@link Collator#setStrength(int)}
- *   </li>
- * </ol> 
- * <p>
- *   CollationKeys generated by ICU Collators are not compatible with those
- *   generated by java.text.Collators.  Specifically, if you use 
- *   ICUCollationKeyFilter to generate index terms, do not use 
- *   {@link CollationKeyFilter} on the query side, or vice versa.
- * </p>
- * <p>
- *   ICUCollationKeyFilter is significantly faster and generates significantly
- *   shorter keys than CollationKeyFilter.  See
- *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
- *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
- *   generation timing and key length comparisons between ICU4J and
- *   java.text.Collator over several languages.
- * </p>
- */
-public final class ICUCollationKeyFilter extends TokenFilter {
-  private Collator collator = null;
-  private RawCollationKey reusableKey = new RawCollationKey();
-  private TermAttribute termAtt;
-
-  /**
-   * 
-   * @param input Source token stream
-   * @param collator CollationKey generator
-   */
-  public ICUCollationKeyFilter(TokenStream input, Collator collator) {
-    super(input);
-    this.collator = collator;
-    termAtt = addAttribute(TermAttribute.class);
-  }
-
-  @Override
-  public boolean incrementToken() throws IOException {
-    if (input.incrementToken()) {
-      char[] termBuffer = termAtt.termBuffer();
-      String termText = new String(termBuffer, 0, termAtt.termLength());
-      collator.getRawCollationKey(termText, reusableKey);
-      ByteBuffer collationKeyBuf = ByteBuffer.wrap(reusableKey.bytes, 0, reusableKey.size);
-      int encodedLength
-        = IndexableBinaryStringTools.getEncodedLength(collationKeyBuf);
-      if (encodedLength > termBuffer.length) {
-        termAtt.resizeTermBuffer(encodedLength);
-      }
-      termAtt.setTermLength(encodedLength);
-      CharBuffer wrappedTermBuffer = CharBuffer.wrap(termAtt.termBuffer());
-      IndexableBinaryStringTools.encode(collationKeyBuf, wrappedTermBuffer);
-      return true;
-    } else {
-      return false;
-    }
-  }
-}
diff --git a/contrib/collation/src/java/org/apache/lucene/collation/package.html b/contrib/collation/src/java/org/apache/lucene/collation/package.html
deleted file mode 100644
index 25d69e4..0000000
--- a/contrib/collation/src/java/org/apache/lucene/collation/package.html
+++ /dev/null
@@ -1,182 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-  <title>Lucene Collation Package</title>
-</head>
-<body>
-<p>
-  <code>CollationKeyFilter</code> and <code>ICUCollationKeyFilter</code>
-  convert each token into its binary <code>CollationKey</code> using the 
-  provided <code>Collator</code>, and then encode the <code>CollationKey</code>
-  as a String using
-  {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow it to be 
-  stored as an index term.
-</p>
-<p>
-  <code>ICUCollationKeyFilter</code> depends on ICU4J 4.0 to produce the 
-  <code>CollationKey</code>s.  <code>icu4j-collation-4.0.jar</code>, 
-  a trimmed-down version of <code>icu4j-4.0.jar</code> that contains only the 
-  code and data needed to support collation, is included in Lucene's Subversion 
-  repository at <code>contrib/collation/lib/</code>.
-</p>
-
-<h2>Use Cases</h2>
-
-<ul>
-  <li>
-    Efficient sorting of terms in languages that use non-Unicode character 
-    orderings.  (Lucene Sort using a Locale can be very slow.) 
-  </li>
-  <li>
-    Efficient range queries over fields that contain terms in languages that 
-    use non-Unicode character orderings.  (Range queries using a Locale can be
-    very slow.)
-  </li>
-  <li>
-    Effective Locale-specific normalization (case differences, diacritics, etc.).
-    ({@link org.apache.lucene.analysis.LowerCaseFilter} and 
-    {@link org.apache.lucene.analysis.ASCIIFoldingFilter} provide these services
-    in a generic way that doesn't take into account locale-specific needs.)
-  </li>
-</ul>
-
-<h2>Example Usages</h2>
-
-<h3>Farsi Range Queries</h3>
-<code><pre>
-  // "fa" Locale is not supported by Sun JDK 1.4 or 1.5
-  Collator collator = Collator.getInstance(new Locale("ar"));
-  CollationKeyAnalyzer analyzer = new CollationKeyAnalyzer(collator);
-  RAMDirectory ramDir = new RAMDirectory();
-  IndexWriter writer = new IndexWriter
-    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-  Document doc = new Document();
-  doc.add(new Field("content", "\u0633\u0627\u0628", 
-                    Field.Store.YES, Field.Index.ANALYZED));
-  writer.addDocument(doc);
-  writer.close();
-  IndexSearcher is = new IndexSearcher(ramDir, true);
-
-  // The AnalyzingQueryParser in Lucene's contrib allows terms in range queries
-  // to be passed through an analyzer - Lucene's standard QueryParser does not
-  // allow this.
-  AnalyzingQueryParser aqp = new AnalyzingQueryParser("content", analyzer);
-  aqp.setLowercaseExpandedTerms(false);
-  
-  // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-  // orders the U+0698 character before the U+0633 character, so the single
-  // indexed Term above should NOT be returned by a ConstantScoreRangeQuery
-  // with a Farsi Collator (or an Arabic one for the case when Farsi is not
-  // supported).
-  ScoreDoc[] result
-    = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
-  assertEquals("The index Term should not be included.", 0, result.length);
-</pre></code>
-
-<h3>Danish Sorting</h3>
-<code><pre>
-  Analyzer analyzer 
-    = new CollationKeyAnalyzer(Collator.getInstance(new Locale("da", "dk")));
-  RAMDirectory indexStore = new RAMDirectory();
-  IndexWriter writer = new IndexWriter 
-    (indexStore, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-  String[] tracer = new String[] { "A", "B", "C", "D", "E" };
-  String[] data = new String[] { "HAT", "HUT", "H\u00C5T", "H\u00D8T", "HOT" };
-  String[] sortedTracerOrder = new String[] { "A", "E", "B", "D", "C" };
-  for (int i = 0 ; i < data.length ; ++i) {
-    Document doc = new Document();
-    doc.add(new Field("tracer", tracer[i], Field.Store.YES, Field.Index.NO));
-    doc.add(new Field("contents", data[i], Field.Store.NO, Field.Index.ANALYZED));
-    writer.addDocument(doc);
-  }
-  writer.close();
-  Searcher searcher = new IndexSearcher(indexStore, true);
-  Sort sort = new Sort();
-  sort.setSort(new SortField("contents", SortField.STRING));
-  Query query = new MatchAllDocsQuery();
-  ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;
-  for (int i = 0 ; i < result.length ; ++i) {
-    Document doc = searcher.doc(result[i].doc);
-    assertEquals(sortedTracerOrder[i], doc.getValues("tracer")[0]);
-  }
-</pre></code>
-
-<h3>Turkish Case Normalization</h3>
-<code><pre>
-  Collator collator = Collator.getInstance(new Locale("tr", "TR"));
-  collator.setStrength(Collator.PRIMARY);
-  Analyzer analyzer = new CollationKeyAnalyzer(collator);
-  RAMDirectory ramDir = new RAMDirectory();
-  IndexWriter writer = new IndexWriter
-    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-  Document doc = new Document();
-  doc.add(new Field("contents", "DIGY", Field.Store.NO, Field.Index.ANALYZED));
-  writer.addDocument(doc);
-  writer.close();
-  IndexSearcher is = new IndexSearcher(ramDir, true);
-  QueryParser parser = new QueryParser("contents", analyzer);
-  Query query = parser.parse("d\u0131gy");   // U+0131: dotless i
-  ScoreDoc[] result = is.search(query, null, 1000).scoreDocs;
-  assertEquals("The index Term should be included.", 1, result.length);
-</pre></code>
-
-<h2>Caveats and Comparisons</h2>
-<p>
-  <strong>WARNING:</strong> Make sure you use exactly the same 
-  <code>Collator</code> at index and query time -- <code>CollationKey</code>s
-  are only comparable when produced by
-  the same <code>Collator</code>.  Since {@link java.text.RuleBasedCollator}s
-  are not independently versioned, it is unsafe to search against stored
-  <code>CollationKey</code>s unless the following are exactly the same (best 
-  practice is to store this information with the index and check that they
-  remain the same at query time):
-</p>
-<ol>
-  <li>JVM vendor</li>
-  <li>JVM version, including patch version</li>
-  <li>
-    The language (and country and variant, if specified) of the Locale
-    used when constructing the collator via
-    {@link java.text.Collator#getInstance(java.util.Locale)}.
-  </li>
-  <li>
-    The collation strength used - see {@link java.text.Collator#setStrength(int)}
-  </li>
-</ol> 
-<p>
-  <code>ICUCollationKeyFilter</code> uses ICU4J's <code>Collator</code>, which 
-  makes its version available, thus allowing collation to be versioned
-  independently from the JVM.  <code>ICUCollationKeyFilter</code> is also 
-  significantly faster and generates significantly shorter keys than 
-  <code>CollationKeyFilter</code>.  See
-  <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
-    >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
-  generation timing and key length comparisons between ICU4J and
-  <code>java.text.Collator</code> over several languages.
-</p>
-<p>
-  <code>CollationKey</code>s generated by <code>java.text.Collator</code>s are 
-  not compatible with those those generated by ICU Collators.  Specifically, if
-  you use <code>CollationKeyFilter</code> to generate index terms, do not use
-  <code>ICUCollationKeyFilter</code> on the query side, or vice versa.
-</p>
-<pre>
-</pre>
-</body>
-</html>
diff --git a/contrib/collation/src/java/overview.html b/contrib/collation/src/java/overview.html
deleted file mode 100644
index cd090a9..0000000
--- a/contrib/collation/src/java/overview.html
+++ /dev/null
@@ -1,26 +0,0 @@
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-  <head>
-    <title>
-      Apache Lucene CollationKeyFilter/Analyzer and 
-      ICUCollationKeyFilter/Analyzer
-    </title>
-  </head>
-  <body>
-  </body>
-</html>
\ No newline at end of file
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java b/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
deleted file mode 100644
index 581f20a..0000000
--- a/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
+++ /dev/null
@@ -1,297 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import junit.framework.TestCase;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermRangeFilter;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.Searcher;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.util.IndexableBinaryStringTools;
-import org.apache.lucene.queryParser.analyzing.AnalyzingQueryParser;
-import org.apache.lucene.util.Version;
-
-import java.io.IOException;
-import java.nio.CharBuffer;
-import java.nio.ByteBuffer;
-
-
-public class CollationTestBase extends TestCase {
-
-  protected String firstRangeBeginningOriginal = "\u062F";
-  protected String firstRangeEndOriginal = "\u0698";
-  
-  protected String secondRangeBeginningOriginal = "\u0633";
-  protected String secondRangeEndOriginal = "\u0638";
-  
-  /**
-   * Convenience method to perform the same function as CollationKeyFilter.
-   *  
-   * @param keyBits the result from 
-   *  collator.getCollationKey(original).toByteArray()
-   * @return The encoded collation key for the original String
-   */
-  protected String encodeCollationKey(byte[] keyBits) {
-    ByteBuffer begBuf = ByteBuffer.wrap(keyBits);
-    // Ensure that the backing char[] array is large enough to hold the encoded
-    // Binary String
-    char[] encodedBegArray 
-      = new char[IndexableBinaryStringTools.getEncodedLength(begBuf)];
-    CharBuffer encodedBegBuf = CharBuffer.wrap(encodedBegArray); 
-    IndexableBinaryStringTools.encode(begBuf, encodedBegBuf);
-    return new String(encodedBegArray);
-  }
-  
-  public void testFarsiQueryParserCollating(Analyzer analyzer) throws Exception {
-
-    RAMDirectory ramDir = new RAMDirectory();
-    IndexWriter writer = new IndexWriter
-      (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    Document doc = new Document();
-    doc.add(new Field("content", "\u0633\u0627\u0628", 
-                      Field.Store.YES, Field.Index.ANALYZED));
-    writer.addDocument(doc);
-    writer.close();
-    IndexSearcher is = new IndexSearcher(ramDir, true);
-
-    AnalyzingQueryParser aqp = new AnalyzingQueryParser(Version.LUCENE_CURRENT, "content", analyzer);
-    aqp.setLowercaseExpandedTerms(false);
-
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a TermRangeQuery
-    // with a Farsi Collator (or an Arabic one for the case when Farsi is not
-    // supported).
-      
-    // Test TermRangeQuery
-    ScoreDoc[] result
-      = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, result.length);
-
-    result = is.search(aqp.parse("[ \u0633 TO \u0638 ]"), null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, result.length);
-
-    is.close();
-  }
-  
-  
-  public void testFarsiRangeFilterCollating(Analyzer analyzer, String firstBeg, 
-                                            String firstEnd, String secondBeg,
-                                            String secondEnd) throws Exception {
-    RAMDirectory ramDir = new RAMDirectory();
-    IndexWriter writer = new IndexWriter
-      (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    Document doc = new Document();
-    doc.add(new Field("content", "\u0633\u0627\u0628", 
-                      Field.Store.YES, Field.Index.ANALYZED));
-    doc.add(new Field("body", "body",
-                      Field.Store.YES, Field.Index.NOT_ANALYZED));
-    writer.addDocument(doc);
-    writer.close();
-    IndexSearcher searcher = new IndexSearcher(ramDir, true);
-    Query query = new TermQuery(new Term("body","body"));
-
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a TermRangeFilter with a Farsi
-    // Collator (or an Arabic one for the case when Farsi searcher not
-    // supported).
-    ScoreDoc[] result = searcher.search
-      (query, new TermRangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, result.length);
-
-    result = searcher.search
-      (query, new TermRangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
-    assertEquals("The index Term should be included.", 1, result.length);
-
-    searcher.close();
-  }
- 
-  public void testFarsiRangeQueryCollating(Analyzer analyzer, String firstBeg, 
-                                            String firstEnd, String secondBeg,
-                                            String secondEnd) throws Exception {
-    RAMDirectory ramDir = new RAMDirectory();
-    IndexWriter writer = new IndexWriter
-      (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    Document doc = new Document();
-
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
-    // Collator (or an Arabic one for the case when Farsi is not supported).
-    doc.add(new Field("content", "\u0633\u0627\u0628", 
-                      Field.Store.YES, Field.Index.ANALYZED));
-    writer.addDocument(doc);
-    writer.close();
-    IndexSearcher searcher = new IndexSearcher(ramDir, true);
-
-    Query query = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, hits.length);
-
-    query = new TermRangeQuery("content", secondBeg, secondEnd, true, true);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, hits.length);
-    searcher.close();
-  }
-
-  public void testFarsiTermRangeQuery
-    (Analyzer analyzer, String firstBeg, String firstEnd, 
-     String secondBeg, String secondEnd) throws Exception {
-
-    RAMDirectory farsiIndex = new RAMDirectory();
-    IndexWriter writer = new IndexWriter
-      (farsiIndex, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    Document doc = new Document();
-    doc.add(new Field("content", "\u0633\u0627\u0628", 
-                      Field.Store.YES, Field.Index.ANALYZED));
-    doc.add(new Field("body", "body",
-                      Field.Store.YES, Field.Index.NOT_ANALYZED));
-    writer.addDocument(doc);
-    writer.close();
-
-    IndexReader reader = IndexReader.open(farsiIndex, true);
-    IndexSearcher search = new IndexSearcher(reader);
-        
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a TermRangeQuery
-    // with a Farsi Collator (or an Arabic one for the case when Farsi is 
-    // not supported).
-    Query csrq 
-      = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
-    ScoreDoc[] result = search.search(csrq, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, result.length);
-
-    csrq = new TermRangeQuery
-      ("content", secondBeg, secondEnd, true, true);
-    result = search.search(csrq, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, result.length);
-    search.close();
-  }
-  
-  // Test using various international locales with accented characters (which
-  // sort differently depending on locale)
-  //
-  // Copied (and slightly modified) from 
-  // org.apache.lucene.search.TestSort.testInternationalSort()
-  //  
-  public void testCollationKeySort(Analyzer usAnalyzer,
-                                   Analyzer franceAnalyzer,
-                                   Analyzer swedenAnalyzer,
-                                   Analyzer denmarkAnalyzer,
-                                   String usResult) throws Exception {
-    RAMDirectory indexStore = new RAMDirectory();
-    PerFieldAnalyzerWrapper analyzer
-      = new PerFieldAnalyzerWrapper(new WhitespaceAnalyzer());
-    analyzer.addAnalyzer("US", usAnalyzer);
-    analyzer.addAnalyzer("France", franceAnalyzer);
-    analyzer.addAnalyzer("Sweden", swedenAnalyzer);
-    analyzer.addAnalyzer("Denmark", denmarkAnalyzer);
-    IndexWriter writer = new IndexWriter 
-      (indexStore, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-
-    // document data:
-    // the tracer field is used to determine which document was hit
-    String[][] sortData = new String[][] {
-      // tracer contents US                 France             Sweden (sv_SE)     Denmark (da_DK)
-      {  "A",   "x",     "p\u00EAche",      "p\u00EAche",      "p\u00EAche",      "p\u00EAche"      },
-      {  "B",   "y",     "HAT",             "HAT",             "HAT",             "HAT"             },
-      {  "C",   "x",     "p\u00E9ch\u00E9", "p\u00E9ch\u00E9", "p\u00E9ch\u00E9", "p\u00E9ch\u00E9" },
-      {  "D",   "y",     "HUT",             "HUT",             "HUT",             "HUT"             },
-      {  "E",   "x",     "peach",           "peach",           "peach",           "peach"           },
-      {  "F",   "y",     "H\u00C5T",        "H\u00C5T",        "H\u00C5T",        "H\u00C5T"        },
-      {  "G",   "x",     "sin",             "sin",             "sin",             "sin"             },
-      {  "H",   "y",     "H\u00D8T",        "H\u00D8T",        "H\u00D8T",        "H\u00D8T"        },
-      {  "I",   "x",     "s\u00EDn",        "s\u00EDn",        "s\u00EDn",        "s\u00EDn"        },
-      {  "J",   "y",     "HOT",             "HOT",             "HOT",             "HOT"             },
-    };
-
-    for (int i = 0 ; i < sortData.length ; ++i) {
-      Document doc = new Document();
-      doc.add(new Field("tracer", sortData[i][0], 
-                        Field.Store.YES, Field.Index.NO));
-      doc.add(new Field("contents", sortData[i][1], 
-                        Field.Store.NO, Field.Index.ANALYZED));
-      if (sortData[i][2] != null) 
-        doc.add(new Field("US", sortData[i][2], 
-                          Field.Store.NO, Field.Index.ANALYZED));
-      if (sortData[i][3] != null) 
-        doc.add(new Field("France", sortData[i][3], 
-                          Field.Store.NO, Field.Index.ANALYZED));
-      if (sortData[i][4] != null)
-        doc.add(new Field("Sweden", sortData[i][4], 
-                          Field.Store.NO, Field.Index.ANALYZED));
-      if (sortData[i][5] != null) 
-        doc.add(new Field("Denmark", sortData[i][5], 
-                          Field.Store.NO, Field.Index.ANALYZED));
-      writer.addDocument(doc);
-    }
-    writer.optimize();
-    writer.close();
-    Searcher searcher = new IndexSearcher(indexStore, true);
-
-    Sort sort = new Sort();
-    Query queryX = new TermQuery(new Term ("contents", "x"));
-    Query queryY = new TermQuery(new Term ("contents", "y"));
-    
-    sort.setSort(new SortField("US", SortField.STRING));
-    assertMatches(searcher, queryY, sort, usResult);
-
-    sort.setSort(new SortField("France", SortField.STRING));
-    assertMatches(searcher, queryX, sort, "EACGI");
-
-    sort.setSort(new SortField("Sweden", SortField.STRING));
-    assertMatches(searcher, queryY, sort, "BJDFH");
-
-    sort.setSort(new SortField("Denmark", SortField.STRING));
-    assertMatches(searcher, queryY, sort, "BJDHF");
-  }
-    
-  // Make sure the documents returned by the search match the expected list
-  // Copied from TestSort.java
-  private void assertMatches(Searcher searcher, Query query, Sort sort, 
-                             String expectedResult) throws IOException {
-    ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;
-    StringBuilder buff = new StringBuilder(10);
-    int n = result.length;
-    for (int i = 0 ; i < n ; ++i) {
-      Document doc = searcher.doc(result[i].doc);
-      String[] v = doc.getValues("tracer");
-      for (int j = 0 ; j < v.length ; ++j) {
-        buff.append(v[j]);
-      }
-    }
-    assertEquals(expectedResult, buff.toString());
-  }
-}
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java b/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java
deleted file mode 100644
index 4f6563c..0000000
--- a/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.analysis.Analyzer;
-
-import java.text.Collator;
-import java.util.Locale;
-
-
-public class TestCollationKeyAnalyzer extends CollationTestBase {
-
-  // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-  // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-  // characters properly.
-  private Collator collator = Collator.getInstance(new Locale("ar"));
-  private Analyzer analyzer = new CollationKeyAnalyzer(collator);
-
-  private String firstRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
-  private String firstRangeEnd = encodeCollationKey
-    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
-  private String secondRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
-  private String secondRangeEnd = encodeCollationKey
-    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
-  
-
-  public void testFarsiQueryParserCollating() throws Exception {
-    testFarsiQueryParserCollating(analyzer);
-  }
-  
-  public void testFarsiRangeFilterCollating() throws Exception {
-    testFarsiRangeFilterCollating
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
- 
-  public void testFarsiRangeQueryCollating() throws Exception {
-    testFarsiRangeQueryCollating
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-
-  public void testFarsiTermRangeQuery() throws Exception {
-    testFarsiTermRangeQuery
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-  
-  public void testCollationKeySort() throws Exception {
-    Analyzer usAnalyzer 
-      = new CollationKeyAnalyzer(Collator.getInstance(Locale.US));
-    Analyzer franceAnalyzer 
-      = new CollationKeyAnalyzer(Collator.getInstance(Locale.FRANCE));
-    Analyzer swedenAnalyzer 
-      = new CollationKeyAnalyzer(Collator.getInstance(new Locale("sv", "se")));
-    Analyzer denmarkAnalyzer 
-      = new CollationKeyAnalyzer(Collator.getInstance(new Locale("da", "dk")));
-    
-    // The ICU Collator and java.text.Collator implementations differ in their
-    // orderings - "BFJDH" is the ordering for java.text.Collator for Locale.US.
-    testCollationKeySort
-      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJDH");
-  }
-}
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java b/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java
deleted file mode 100644
index 3ffd5ac..0000000
--- a/contrib/collation/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java
+++ /dev/null
@@ -1,100 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.KeywordTokenizer;
-
-import java.text.Collator;
-import java.util.Locale;
-import java.io.Reader;
-
-
-public class TestCollationKeyFilter extends CollationTestBase {
-
-  // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-  // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-  // characters properly.
-  private Collator collator = Collator.getInstance(new Locale("ar"));
-  private Analyzer analyzer = new TestAnalyzer(collator);
-
-  private String firstRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
-  private String firstRangeEnd = encodeCollationKey
-    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
-  private String secondRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
-  private String secondRangeEnd = encodeCollationKey
-    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
-
-  
-  public class TestAnalyzer extends Analyzer {
-    private Collator collator;
-
-    TestAnalyzer(Collator collator) {
-      this.collator = collator;
-    }
-
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      TokenStream result = new KeywordTokenizer(reader);
-      result = new CollationKeyFilter(result, collator);
-      return result;
-    }
-  }
-
-  public void testFarsiQueryParserCollating() throws Exception {
-    testFarsiQueryParserCollating(analyzer);
-  }
-  
-  
-  public void testFarsiRangeFilterCollating() throws Exception {
-    testFarsiRangeFilterCollating
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
- 
-  public void testFarsiRangeQueryCollating() throws Exception {
-    testFarsiRangeQueryCollating
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-
-  public void testFarsiTermRangeQuery() throws Exception {
-    testFarsiTermRangeQuery
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-  
-  public void testCollationKeySort() throws Exception {
-    Analyzer usAnalyzer = new TestAnalyzer(Collator.getInstance(Locale.US));
-    Analyzer franceAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(Locale.FRANCE));
-    Analyzer swedenAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(new Locale("sv", "se")));
-    Analyzer denmarkAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(new Locale("da", "dk")));
-    
-    // The ICU Collator and java.text.Collator implementations differ in their
-    // orderings - "BFJDH" is the ordering for java.text.Collator for Locale.US.
-    testCollationKeySort
-      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJDH");
-  }
-}
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java b/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java
deleted file mode 100644
index 19a8359e..0000000
--- a/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import com.ibm.icu.text.Collator;
-import org.apache.lucene.analysis.Analyzer;
-
-import java.util.Locale;
-
-
-public class TestICUCollationKeyAnalyzer extends CollationTestBase {
-
-  private Collator collator = Collator.getInstance(new Locale("fa"));
-  private Analyzer analyzer = new ICUCollationKeyAnalyzer(collator);
-
-  private String firstRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
-  private String firstRangeEnd = encodeCollationKey
-    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
-  private String secondRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
-  private String secondRangeEnd = encodeCollationKey
-    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
-
-  
-  public void testFarsiQueryParserCollating() throws Exception {
-    testFarsiQueryParserCollating(analyzer);
-  }
-  
-  public void testFarsiRangeFilterCollating() throws Exception {
-    testFarsiRangeFilterCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
-                                  secondRangeBeginning, secondRangeEnd);
-  }
- 
-  public void testFarsiRangeQueryCollating() throws Exception {
-    testFarsiRangeQueryCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
-                                 secondRangeBeginning, secondRangeEnd);
-  }
-
-  public void testFarsiTermRangeQuery() throws Exception {
-    testFarsiTermRangeQuery
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-
-  // Test using various international locales with accented characters (which
-  // sort differently depending on locale)
-  //
-  // Copied (and slightly modified) from 
-  // org.apache.lucene.search.TestSort.testInternationalSort()
-  //  
-  public void testCollationKeySort() throws Exception {
-    Analyzer usAnalyzer = new ICUCollationKeyAnalyzer
-      (Collator.getInstance(Locale.US));
-    Analyzer franceAnalyzer = new ICUCollationKeyAnalyzer
-      (Collator.getInstance(Locale.FRANCE));
-    Analyzer swedenAnalyzer = new ICUCollationKeyAnalyzer
-      (Collator.getInstance(new Locale("sv", "se")));
-    Analyzer denmarkAnalyzer = new ICUCollationKeyAnalyzer
-      (Collator.getInstance(new Locale("da", "dk")));
-
-    // The ICU Collator and java.text.Collator implementations differ in their
-    // orderings - "BFJHD" is the ordering for the ICU Collator for Locale.US.
-    testCollationKeySort
-      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJHD");
-  }
-}
diff --git a/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java b/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java
deleted file mode 100644
index b7e7c82..0000000
--- a/contrib/collation/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package org.apache.lucene.collation;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import com.ibm.icu.text.Collator;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.KeywordTokenizer;
-
-import java.io.Reader;
-import java.util.Locale;
-
-
-public class TestICUCollationKeyFilter extends CollationTestBase {
-
-  private Collator collator = Collator.getInstance(new Locale("fa"));
-  private Analyzer analyzer = new TestAnalyzer(collator);
-
-  private String firstRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
-  private String firstRangeEnd = encodeCollationKey
-    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
-  private String secondRangeBeginning = encodeCollationKey
-    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
-  private String secondRangeEnd = encodeCollationKey
-    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
-
-  
-  public class TestAnalyzer extends Analyzer {
-    private Collator collator;
-
-    TestAnalyzer(Collator collator) {
-      this.collator = collator;
-    }
-
-    @Override
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      TokenStream result = new KeywordTokenizer(reader);
-      result = new ICUCollationKeyFilter(result, collator);
-      return result;
-    }
-  }
-
-  public void testFarsiQueryParserCollating() throws Exception {
-    testFarsiQueryParserCollating(analyzer);
-  }
-  
-  
-  public void testFarsiRangeFilterCollating() throws Exception {
-    testFarsiRangeFilterCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
-                                  secondRangeBeginning, secondRangeEnd);
-  }
- 
-  public void testFarsiRangeQueryCollating() throws Exception {
-    testFarsiRangeQueryCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
-                                 secondRangeBeginning, secondRangeEnd);
-  }
-
-  public void testFarsiTermRangeQuery() throws Exception {
-    testFarsiTermRangeQuery
-      (analyzer, firstRangeBeginning, firstRangeEnd, 
-       secondRangeBeginning, secondRangeEnd);
-  }
-
-  // Test using various international locales with accented characters (which
-  // sort differently depending on locale)
-  //
-  // Copied (and slightly modified) from 
-  // org.apache.lucene.search.TestSort.testInternationalSort()
-  //  
-  public void testCollationKeySort() throws Exception {
-    Analyzer usAnalyzer = new TestAnalyzer(Collator.getInstance(Locale.US));
-    Analyzer franceAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(Locale.FRANCE));
-    Analyzer swedenAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(new Locale("sv", "se")));
-    Analyzer denmarkAnalyzer 
-      = new TestAnalyzer(Collator.getInstance(new Locale("da", "dk")));
-
-    // The ICU Collator and java.text.Collator implementations differ in their
-    // orderings - "BFJHD" is the ordering for the ICU Collator for Locale.US.
-    testCollationKeySort
-      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJHD");
-  }
-}
diff --git a/contrib/icu/build.xml b/contrib/icu/build.xml
new file mode 100644
index 0000000..f8fbd24
--- /dev/null
+++ b/contrib/icu/build.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+ 
+        http://www.apache.org/licenses/LICENSE-2.0
+ 
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="icu" default="default">
+
+  <description>
+  	Provides integration with ICU (International Components for Unicode) for
+  	stronger Unicode and internationalization support. 
+  </description>
+
+
+  <path id="additional.dependencies">
+    <fileset dir="lib" includes="icu4j-*.jar"/>
+  </path>
+
+  <pathconvert property="project.classpath"
+               targetos="unix"
+               refid="additional.dependencies"
+  />
+
+  <import file="../contrib-build.xml"/>
+
+</project>
diff --git a/contrib/icu/lib/ICU-LICENSE.txt b/contrib/icu/lib/ICU-LICENSE.txt
new file mode 100644
index 0000000..6eab042
--- /dev/null
+++ b/contrib/icu/lib/ICU-LICENSE.txt
@@ -0,0 +1,33 @@
+ICU License - ICU 1.8.1 and later
+
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1995-2008 International Business Machines Corporation and others
+
+All rights reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, and/or sell copies of the
+Software, and to permit persons to whom the Software is furnished to do so,
+provided that the above copyright notice(s) and this permission notice appear
+in all copies of the Software and that both the above copyright notice(s) and
+this permission notice appear in supporting documentation.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE
+LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other
+dealings in this Software without prior written authorization of the
+copyright holder.
+
+All trademarks and registered trademarks mentioned herein are the property of
+their respective owners.
diff --git a/contrib/icu/lib/icu4j-collation-4.0.jar b/contrib/icu/lib/icu4j-collation-4.0.jar
new file mode 100644
index 0000000..4f1cb40
--- /dev/null
+++ b/contrib/icu/lib/icu4j-collation-4.0.jar
@@ -0,0 +1,2 @@
+AnyObjectId[1159f04caacfda235b66d73dc65198fa40153812] was removed in git history.
+Apache SVN contains full history.
\ No newline at end of file
diff --git a/contrib/icu/pom.xml.template b/contrib/icu/pom.xml.template
new file mode 100644
index 0000000..bc3ad8d
--- /dev/null
+++ b/contrib/icu/pom.xml.template
@@ -0,0 +1,47 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <!--
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+    
+    http://www.apache.org/licenses/LICENSE-2.0
+    
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+  -->
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>org.apache.lucene</groupId>
+    <artifactId>lucene-contrib</artifactId>
+    <version>@version@</version>
+  </parent>
+  <groupId>org.apache.lucene</groupId>
+  <artifactId>lucene-icu</artifactId>
+  <name>
+    Lucene ICUCollationKeyFilter/Analyzer
+  </name>
+  <version>@version@</version>
+  <description>    
+  	Provides integration with ICU (International Components for Unicode) for
+  	stronger Unicode and internationalization support.
+  </description>
+  <packaging>jar</packaging>
+  <dependencies>
+    <dependency>
+      <groupId>com.ibm.icu</groupId>
+      <artifactId>icu4j</artifactId>
+      <version>${icu-version}</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java b/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java
new file mode 100644
index 0000000..387288a
--- /dev/null
+++ b/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyAnalyzer.java
@@ -0,0 +1,106 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import com.ibm.icu.text.Collator;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.KeywordTokenizer;
+import org.apache.lucene.analysis.Tokenizer;
+
+import java.io.Reader;
+import java.io.IOException;
+
+
+/**
+ * <p>
+ *   Filters {@link KeywordTokenizer} with {@link ICUCollationKeyFilter}.
+ * <p>
+ *   Converts the token into its {@link com.ibm.icu.text.CollationKey}, and
+ *   then encodes the CollationKey with 
+ *   {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow it to
+ *   be stored as an index term.
+ * </p>
+ * <p>
+ *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
+ *   index and query time -- CollationKeys are only comparable when produced by
+ *   the same Collator.  {@link com.ibm.icu.text.RuleBasedCollator}s are 
+ *   independently versioned, so it is safe to search against stored
+ *   CollationKeys if the following are exactly the same (best practice is
+ *   to store this information with the index and check that they remain the
+ *   same at query time):
+ * </p>
+ * <ol>
+ *   <li>
+ *     Collator version - see {@link Collator#getVersion()}
+ *   </li>
+ *   <li>
+ *     The collation strength used - see {@link Collator#setStrength(int)}
+ *   </li>
+ * </ol> 
+ * <p>
+ *   CollationKeys generated by ICU Collators are not compatible with those
+ *   generated by java.text.Collators.  Specifically, if you use 
+ *   ICUCollationKeyAnalyzer to generate index terms, do not use 
+ *   {@link CollationKeyAnalyzer} on the query side, or vice versa.
+ * </p>
+ * <p>
+ *   ICUCollationKeyAnalyzer is significantly faster and generates significantly
+ *   shorter keys than CollationKeyAnalyzer.  See
+ *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+ *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+ *   generation timing and key length comparisons between ICU4J and
+ *   java.text.Collator over several languages.
+ * </p>
+ */
+public class ICUCollationKeyAnalyzer extends Analyzer {
+  private Collator collator;
+
+  public ICUCollationKeyAnalyzer(Collator collator) {
+    this.collator = collator;
+  }
+
+  @Override
+  public TokenStream tokenStream(String fieldName, Reader reader) {
+    TokenStream result = new KeywordTokenizer(reader);
+    result = new ICUCollationKeyFilter(result, collator);
+    return result;
+  }
+  
+  private class SavedStreams {
+    Tokenizer source;
+    TokenStream result;
+  }
+  
+  @Override
+  public TokenStream reusableTokenStream(String fieldName, Reader reader) 
+    throws IOException {
+    
+    SavedStreams streams = (SavedStreams)getPreviousTokenStream();
+    if (streams == null) {
+      streams = new SavedStreams();
+      streams.source = new KeywordTokenizer(reader);
+      streams.result = new ICUCollationKeyFilter(streams.source, collator);
+      setPreviousTokenStream(streams);
+    } else {
+      streams.source.reset(reader);
+    }
+    return streams.result;
+  }
+}
diff --git a/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java b/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java
new file mode 100644
index 0000000..a008814
--- /dev/null
+++ b/contrib/icu/src/java/org/apache/lucene/collation/ICUCollationKeyFilter.java
@@ -0,0 +1,109 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import com.ibm.icu.text.Collator;
+import com.ibm.icu.text.RawCollationKey;
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Token;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.util.IndexableBinaryStringTools;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+
+
+/**
+ * <p>
+ *   Converts each token into its {@link com.ibm.icu.text.CollationKey}, and
+ *   then encodes the CollationKey with {@link IndexableBinaryStringTools}, to
+ *   allow it to be stored as an index term.
+ * </p>
+ * <p>
+ *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
+ *   index and query time -- CollationKeys are only comparable when produced by
+ *   the same Collator.  {@link com.ibm.icu.text.RuleBasedCollator}s are 
+ *   independently versioned, so it is safe to search against stored
+ *   CollationKeys if the following are exactly the same (best practice is
+ *   to store this information with the index and check that they remain the
+ *   same at query time):
+ * </p>
+ * <ol>
+ *   <li>
+ *     Collator version - see {@link Collator#getVersion()}
+ *   </li>
+ *   <li>
+ *     The collation strength used - see {@link Collator#setStrength(int)}
+ *   </li>
+ * </ol> 
+ * <p>
+ *   CollationKeys generated by ICU Collators are not compatible with those
+ *   generated by java.text.Collators.  Specifically, if you use 
+ *   ICUCollationKeyFilter to generate index terms, do not use 
+ *   {@link CollationKeyFilter} on the query side, or vice versa.
+ * </p>
+ * <p>
+ *   ICUCollationKeyFilter is significantly faster and generates significantly
+ *   shorter keys than CollationKeyFilter.  See
+ *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+ *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+ *   generation timing and key length comparisons between ICU4J and
+ *   java.text.Collator over several languages.
+ * </p>
+ */
+public final class ICUCollationKeyFilter extends TokenFilter {
+  private Collator collator = null;
+  private RawCollationKey reusableKey = new RawCollationKey();
+  private TermAttribute termAtt;
+
+  /**
+   * 
+   * @param input Source token stream
+   * @param collator CollationKey generator
+   */
+  public ICUCollationKeyFilter(TokenStream input, Collator collator) {
+    super(input);
+    this.collator = collator;
+    termAtt = addAttribute(TermAttribute.class);
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char[] termBuffer = termAtt.termBuffer();
+      String termText = new String(termBuffer, 0, termAtt.termLength());
+      collator.getRawCollationKey(termText, reusableKey);
+      ByteBuffer collationKeyBuf = ByteBuffer.wrap(reusableKey.bytes, 0, reusableKey.size);
+      int encodedLength
+        = IndexableBinaryStringTools.getEncodedLength(collationKeyBuf);
+      if (encodedLength > termBuffer.length) {
+        termAtt.resizeTermBuffer(encodedLength);
+      }
+      termAtt.setTermLength(encodedLength);
+      CharBuffer wrappedTermBuffer = CharBuffer.wrap(termAtt.termBuffer());
+      IndexableBinaryStringTools.encode(collationKeyBuf, wrappedTermBuffer);
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
diff --git a/contrib/icu/src/java/org/apache/lucene/collation/package.html b/contrib/icu/src/java/org/apache/lucene/collation/package.html
new file mode 100644
index 0000000..4e2882cc
--- /dev/null
+++ b/contrib/icu/src/java/org/apache/lucene/collation/package.html
@@ -0,0 +1,181 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+  <title>Lucene Collation Package</title>
+</head>
+<body>
+<p>
+  <code>ICUCollationKeyFilter</code>
+  converts each token into its binary <code>CollationKey</code> using the 
+  provided <code>Collator</code>, and then encode the <code>CollationKey</code>
+  as a String using
+  {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow it to be 
+  stored as an index term.
+</p>
+<p>
+  <code>ICUCollationKeyFilter</code> depends on ICU4J 4.0 to produce the 
+  <code>CollationKey</code>s.  <code>icu4j-collation-4.0.jar</code>, 
+  a trimmed-down version of <code>icu4j-4.0.jar</code> that contains only the 
+  code and data needed to support collation, is included in Lucene's Subversion 
+  repository at <code>contrib/collation/lib/</code>.
+</p>
+
+<h2>Use Cases</h2>
+
+<ul>
+  <li>
+    Efficient sorting of terms in languages that use non-Unicode character 
+    orderings.  (Lucene Sort using a Locale can be very slow.) 
+  </li>
+  <li>
+    Efficient range queries over fields that contain terms in languages that 
+    use non-Unicode character orderings.  (Range queries using a Locale can be
+    very slow.)
+  </li>
+  <li>
+    Effective Locale-specific normalization (case differences, diacritics, etc.).
+    ({@link org.apache.lucene.analysis.LowerCaseFilter} and 
+    {@link org.apache.lucene.analysis.ASCIIFoldingFilter} provide these services
+    in a generic way that doesn't take into account locale-specific needs.)
+  </li>
+</ul>
+
+<h2>Example Usages</h2>
+
+<h3>Farsi Range Queries</h3>
+<code><pre>
+  Collator collator = Collator.getInstance(new Locale("ar"));
+  ICUCollationKeyAnalyzer analyzer = new ICUCollationKeyAnalyzer(collator);
+  RAMDirectory ramDir = new RAMDirectory();
+  IndexWriter writer = new IndexWriter
+    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  Document doc = new Document();
+  doc.add(new Field("content", "\u0633\u0627\u0628", 
+                    Field.Store.YES, Field.Index.ANALYZED));
+  writer.addDocument(doc);
+  writer.close();
+  IndexSearcher is = new IndexSearcher(ramDir, true);
+
+  // The AnalyzingQueryParser in Lucene's contrib allows terms in range queries
+  // to be passed through an analyzer - Lucene's standard QueryParser does not
+  // allow this.
+  AnalyzingQueryParser aqp = new AnalyzingQueryParser("content", analyzer);
+  aqp.setLowercaseExpandedTerms(false);
+  
+  // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+  // orders the U+0698 character before the U+0633 character, so the single
+  // indexed Term above should NOT be returned by a ConstantScoreRangeQuery
+  // with a Farsi Collator (or an Arabic one for the case when Farsi is not
+  // supported).
+  ScoreDoc[] result
+    = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
+  assertEquals("The index Term should not be included.", 0, result.length);
+</pre></code>
+
+<h3>Danish Sorting</h3>
+<code><pre>
+  Analyzer analyzer 
+    = new ICUCollationKeyAnalyzer(Collator.getInstance(new Locale("da", "dk")));
+  RAMDirectory indexStore = new RAMDirectory();
+  IndexWriter writer = new IndexWriter 
+    (indexStore, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  String[] tracer = new String[] { "A", "B", "C", "D", "E" };
+  String[] data = new String[] { "HAT", "HUT", "H\u00C5T", "H\u00D8T", "HOT" };
+  String[] sortedTracerOrder = new String[] { "A", "E", "B", "D", "C" };
+  for (int i = 0 ; i < data.length ; ++i) {
+    Document doc = new Document();
+    doc.add(new Field("tracer", tracer[i], Field.Store.YES, Field.Index.NO));
+    doc.add(new Field("contents", data[i], Field.Store.NO, Field.Index.ANALYZED));
+    writer.addDocument(doc);
+  }
+  writer.close();
+  Searcher searcher = new IndexSearcher(indexStore, true);
+  Sort sort = new Sort();
+  sort.setSort(new SortField("contents", SortField.STRING));
+  Query query = new MatchAllDocsQuery();
+  ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;
+  for (int i = 0 ; i < result.length ; ++i) {
+    Document doc = searcher.doc(result[i].doc);
+    assertEquals(sortedTracerOrder[i], doc.getValues("tracer")[0]);
+  }
+</pre></code>
+
+<h3>Turkish Case Normalization</h3>
+<code><pre>
+  Collator collator = Collator.getInstance(new Locale("tr", "TR"));
+  collator.setStrength(Collator.PRIMARY);
+  Analyzer analyzer = new ICUCollationKeyAnalyzer(collator);
+  RAMDirectory ramDir = new RAMDirectory();
+  IndexWriter writer = new IndexWriter
+    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  Document doc = new Document();
+  doc.add(new Field("contents", "DIGY", Field.Store.NO, Field.Index.ANALYZED));
+  writer.addDocument(doc);
+  writer.close();
+  IndexSearcher is = new IndexSearcher(ramDir, true);
+  QueryParser parser = new QueryParser("contents", analyzer);
+  Query query = parser.parse("d\u0131gy");   // U+0131: dotless i
+  ScoreDoc[] result = is.search(query, null, 1000).scoreDocs;
+  assertEquals("The index Term should be included.", 1, result.length);
+</pre></code>
+
+<h2>Caveats and Comparisons</h2>
+<p>
+  <strong>WARNING:</strong> Make sure you use exactly the same 
+  <code>Collator</code> at index and query time -- <code>CollationKey</code>s
+  are only comparable when produced by
+  the same <code>Collator</code>.  Since {@link java.text.RuleBasedCollator}s
+  are not independently versioned, it is unsafe to search against stored
+  <code>CollationKey</code>s unless the following are exactly the same (best 
+  practice is to store this information with the index and check that they
+  remain the same at query time):
+</p>
+<ol>
+  <li>JVM vendor</li>
+  <li>JVM version, including patch version</li>
+  <li>
+    The language (and country and variant, if specified) of the Locale
+    used when constructing the collator via
+    {@link java.text.Collator#getInstance(java.util.Locale)}.
+  </li>
+  <li>
+    The collation strength used - see {@link java.text.Collator#setStrength(int)}
+  </li>
+</ol> 
+<p>
+  <code>ICUCollationKeyFilter</code> uses ICU4J's <code>Collator</code>, which 
+  makes its version available, thus allowing collation to be versioned
+  independently from the JVM.  <code>ICUCollationKeyFilter</code> is also 
+  significantly faster and generates significantly shorter keys than 
+  <code>CollationKeyFilter</code>.  See
+  <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+    >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+  generation timing and key length comparisons between ICU4J and
+  <code>java.text.Collator</code> over several languages.
+</p>
+<p>
+  <code>CollationKey</code>s generated by <code>java.text.Collator</code>s are 
+  not compatible with those those generated by ICU Collators.  Specifically, if
+  you use <code>CollationKeyFilter</code> to generate index terms, do not use
+  <code>ICUCollationKeyFilter</code> on the query side, or vice versa.
+</p>
+<pre>
+</pre>
+</body>
+</html>
diff --git a/contrib/icu/src/java/overview.html b/contrib/icu/src/java/overview.html
new file mode 100644
index 0000000..b9d26c1
--- /dev/null
+++ b/contrib/icu/src/java/overview.html
@@ -0,0 +1,25 @@
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+  <head>
+    <title>
+      Apache Lucene ICUCollationKeyFilter/Analyzer
+    </title>
+  </head>
+  <body>
+  </body>
+</html>
\ No newline at end of file
diff --git a/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java b/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java
new file mode 100644
index 0000000..b018ffc
--- /dev/null
+++ b/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyAnalyzer.java
@@ -0,0 +1,78 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import com.ibm.icu.text.Collator;
+import org.apache.lucene.analysis.Analyzer;
+
+import java.util.Locale;
+
+
+public class TestICUCollationKeyAnalyzer extends CollationTestBase {
+
+  private Collator collator = Collator.getInstance(new Locale("fa"));
+  private Analyzer analyzer = new ICUCollationKeyAnalyzer(collator);
+
+  private String firstRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
+  private String firstRangeEnd = encodeCollationKey
+    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
+  private String secondRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
+  private String secondRangeEnd = encodeCollationKey
+    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
+  
+  public void testFarsiRangeFilterCollating() throws Exception {
+    testFarsiRangeFilterCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
+                                  secondRangeBeginning, secondRangeEnd);
+  }
+ 
+  public void testFarsiRangeQueryCollating() throws Exception {
+    testFarsiRangeQueryCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
+                                 secondRangeBeginning, secondRangeEnd);
+  }
+
+  public void testFarsiTermRangeQuery() throws Exception {
+    testFarsiTermRangeQuery
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+
+  // Test using various international locales with accented characters (which
+  // sort differently depending on locale)
+  //
+  // Copied (and slightly modified) from 
+  // org.apache.lucene.search.TestSort.testInternationalSort()
+  //  
+  public void testCollationKeySort() throws Exception {
+    Analyzer usAnalyzer = new ICUCollationKeyAnalyzer
+      (Collator.getInstance(Locale.US));
+    Analyzer franceAnalyzer = new ICUCollationKeyAnalyzer
+      (Collator.getInstance(Locale.FRANCE));
+    Analyzer swedenAnalyzer = new ICUCollationKeyAnalyzer
+      (Collator.getInstance(new Locale("sv", "se")));
+    Analyzer denmarkAnalyzer = new ICUCollationKeyAnalyzer
+      (Collator.getInstance(new Locale("da", "dk")));
+
+    // The ICU Collator and java.text.Collator implementations differ in their
+    // orderings - "BFJHD" is the ordering for the ICU Collator for Locale.US.
+    testCollationKeySort
+      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJHD");
+  }
+}
diff --git a/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java b/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java
new file mode 100644
index 0000000..e0a6c99
--- /dev/null
+++ b/contrib/icu/src/test/org/apache/lucene/collation/TestICUCollationKeyFilter.java
@@ -0,0 +1,96 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import com.ibm.icu.text.Collator;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.KeywordTokenizer;
+
+import java.io.Reader;
+import java.util.Locale;
+
+
+public class TestICUCollationKeyFilter extends CollationTestBase {
+
+  private Collator collator = Collator.getInstance(new Locale("fa"));
+  private Analyzer analyzer = new TestAnalyzer(collator);
+
+  private String firstRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
+  private String firstRangeEnd = encodeCollationKey
+    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
+  private String secondRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
+  private String secondRangeEnd = encodeCollationKey
+    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
+
+  
+  public class TestAnalyzer extends Analyzer {
+    private Collator collator;
+
+    TestAnalyzer(Collator collator) {
+      this.collator = collator;
+    }
+
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      TokenStream result = new KeywordTokenizer(reader);
+      result = new ICUCollationKeyFilter(result, collator);
+      return result;
+    }
+  }
+
+  public void testFarsiRangeFilterCollating() throws Exception {
+    testFarsiRangeFilterCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
+                                  secondRangeBeginning, secondRangeEnd);
+  }
+ 
+  public void testFarsiRangeQueryCollating() throws Exception {
+    testFarsiRangeQueryCollating(analyzer, firstRangeBeginning, firstRangeEnd, 
+                                 secondRangeBeginning, secondRangeEnd);
+  }
+
+  public void testFarsiTermRangeQuery() throws Exception {
+    testFarsiTermRangeQuery
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+
+  // Test using various international locales with accented characters (which
+  // sort differently depending on locale)
+  //
+  // Copied (and slightly modified) from 
+  // org.apache.lucene.search.TestSort.testInternationalSort()
+  //  
+  public void testCollationKeySort() throws Exception {
+    Analyzer usAnalyzer = new TestAnalyzer(Collator.getInstance(Locale.US));
+    Analyzer franceAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(Locale.FRANCE));
+    Analyzer swedenAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(new Locale("sv", "se")));
+    Analyzer denmarkAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(new Locale("da", "dk")));
+
+    // The ICU Collator and java.text.Collator implementations differ in their
+    // orderings - "BFJHD" is the ordering for the ICU Collator for Locale.US.
+    testCollationKeySort
+      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJHD");
+  }
+}
diff --git a/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java b/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
new file mode 100644
index 0000000..081624a
--- /dev/null
+++ b/src/java/org/apache/lucene/collation/CollationKeyAnalyzer.java
@@ -0,0 +1,113 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.KeywordTokenizer;
+import org.apache.lucene.analysis.Tokenizer;
+
+import java.text.Collator;
+import java.io.Reader;
+import java.io.IOException;
+
+/**
+ * <p>
+ *   Filters {@link KeywordTokenizer} with {@link CollationKeyFilter}.
+ * </p>
+ * <p>
+ *   Converts the token into its {@link java.text.CollationKey}, and then
+ *   encodes the CollationKey with 
+ *   {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow 
+ *   it to be stored as an index term.
+ * </p>
+ * <p>
+ *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
+ *   index and query time -- CollationKeys are only comparable when produced by
+ *   the same Collator.  Since {@link java.text.RuleBasedCollator}s are not
+ *   independently versioned, it is unsafe to search against stored
+ *   CollationKeys unless the following are exactly the same (best practice is
+ *   to store this information with the index and check that they remain the
+ *   same at query time):
+ * </p>
+ * <ol>
+ *   <li>JVM vendor</li>
+ *   <li>JVM version, including patch version</li>
+ *   <li>
+ *     The language (and country and variant, if specified) of the Locale
+ *     used when constructing the collator via
+ *     {@link Collator#getInstance(java.util.Locale)}.
+ *   </li>
+ *   <li>
+ *     The collation strength used - see {@link Collator#setStrength(int)}
+ *   </li>
+ * </ol> 
+ * <p>
+ *   The <code>ICUCollationKeyAnalyzer</code> in the icu package of Lucene's
+ *   contrib area uses ICU4J's Collator, which makes its
+ *   its version available, thus allowing collation to be versioned
+ *   independently from the JVM.  ICUCollationKeyAnalyzer is also significantly
+ *   faster and generates significantly shorter keys than CollationKeyAnalyzer.
+ *   See <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+ *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+ *   generation timing and key length comparisons between ICU4J and
+ *   java.text.Collator over several languages.
+ * </p>
+ * <p>
+ *   CollationKeys generated by java.text.Collators are not compatible
+ *   with those those generated by ICU Collators.  Specifically, if you use 
+ *   CollationKeyAnalyzer to generate index terms, do not use
+ *   ICUCollationKeyAnalyzer on the query side, or vice versa.
+ * </p>
+ */
+public class CollationKeyAnalyzer extends Analyzer {
+  private Collator collator;
+
+  public CollationKeyAnalyzer(Collator collator) {
+    this.collator = collator;
+  }
+
+  @Override
+  public TokenStream tokenStream(String fieldName, Reader reader) {
+    TokenStream result = new KeywordTokenizer(reader);
+    result = new CollationKeyFilter(result, collator);
+    return result;
+  }
+  
+  private class SavedStreams {
+    Tokenizer source;
+    TokenStream result;
+  }
+  
+  @Override
+  public TokenStream reusableTokenStream(String fieldName, Reader reader) 
+    throws IOException {
+    
+    SavedStreams streams = (SavedStreams)getPreviousTokenStream();
+    if (streams == null) {
+      streams = new SavedStreams();
+      streams.source = new KeywordTokenizer(reader);
+      streams.result = new CollationKeyFilter(streams.source, collator);
+      setPreviousTokenStream(streams);
+    } else {
+      streams.source.reset(reader);
+    }
+    return streams.result;
+  }
+}
diff --git a/src/java/org/apache/lucene/collation/CollationKeyFilter.java b/src/java/org/apache/lucene/collation/CollationKeyFilter.java
new file mode 100644
index 0000000..6f0ea05
--- /dev/null
+++ b/src/java/org/apache/lucene/collation/CollationKeyFilter.java
@@ -0,0 +1,111 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.util.IndexableBinaryStringTools;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.text.Collator;
+
+
+/**
+ * <p>
+ *   Converts each token into its {@link java.text.CollationKey}, and then
+ *   encodes the CollationKey with {@link IndexableBinaryStringTools}, to allow 
+ *   it to be stored as an index term.
+ * </p>
+ * <p>
+ *   <strong>WARNING:</strong> Make sure you use exactly the same Collator at
+ *   index and query time -- CollationKeys are only comparable when produced by
+ *   the same Collator.  Since {@link java.text.RuleBasedCollator}s are not
+ *   independently versioned, it is unsafe to search against stored
+ *   CollationKeys unless the following are exactly the same (best practice is
+ *   to store this information with the index and check that they remain the
+ *   same at query time):
+ * </p>
+ * <ol>
+ *   <li>JVM vendor</li>
+ *   <li>JVM version, including patch version</li>
+ *   <li>
+ *     The language (and country and variant, if specified) of the Locale
+ *     used when constructing the collator via
+ *     {@link Collator#getInstance(java.util.Locale)}.
+ *   </li>
+ *   <li>
+ *     The collation strength used - see {@link Collator#setStrength(int)}
+ *   </li>
+ * </ol> 
+ * <p>
+ *   The <code>ICUCollationKeyFilter</code> in the icu package of Lucene's
+ *   contrib area uses ICU4J's Collator, which makes its
+ *   version available, thus allowing collation to be versioned independently
+ *   from the JVM.  ICUCollationKeyFilter is also significantly faster and
+ *   generates significantly shorter keys than CollationKeyFilter.  See
+ *   <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+ *   >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+ *   generation timing and key length comparisons between ICU4J and
+ *   java.text.Collator over several languages.
+ * </p>
+ * <p>
+ *   CollationKeys generated by java.text.Collators are not compatible
+ *   with those those generated by ICU Collators.  Specifically, if you use 
+ *   CollationKeyFilter to generate index terms, do not use
+ *   ICUCollationKeyFilter on the query side, or vice versa.
+ * </p>
+ */
+public final class CollationKeyFilter extends TokenFilter {
+  private Collator collator = null;
+  private TermAttribute termAtt;
+
+  /**
+   * @param input Source token stream
+   * @param collator CollationKey generator
+   */
+  public CollationKeyFilter(TokenStream input, Collator collator) {
+    super(input);
+    this.collator = collator;
+    termAtt = addAttribute(TermAttribute.class);
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char[] termBuffer = termAtt.termBuffer();
+      String termText = new String(termBuffer, 0, termAtt.termLength());
+      byte[] collationKey = collator.getCollationKey(termText).toByteArray();
+      ByteBuffer collationKeyBuf = ByteBuffer.wrap(collationKey);
+      int encodedLength
+        = IndexableBinaryStringTools.getEncodedLength(collationKeyBuf);
+      if (encodedLength > termBuffer.length) {
+        termAtt.resizeTermBuffer(encodedLength);
+      }
+      termAtt.setTermLength(encodedLength);
+      CharBuffer wrappedTermBuffer = CharBuffer.wrap(termAtt.termBuffer());
+      IndexableBinaryStringTools.encode(collationKeyBuf, wrappedTermBuffer);
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
diff --git a/src/java/org/apache/lucene/collation/package.html b/src/java/org/apache/lucene/collation/package.html
new file mode 100644
index 0000000..b0c6f80
--- /dev/null
+++ b/src/java/org/apache/lucene/collation/package.html
@@ -0,0 +1,176 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+  <title>Lucene Collation Package</title>
+</head>
+<body>
+<p>
+  <code>CollationKeyFilter</code>
+  converts each token into its binary <code>CollationKey</code> using the 
+  provided <code>Collator</code>, and then encode the <code>CollationKey</code>
+  as a String using
+  {@link org.apache.lucene.util.IndexableBinaryStringTools}, to allow it to be 
+  stored as an index term.
+</p>
+
+<h2>Use Cases</h2>
+
+<ul>
+  <li>
+    Efficient sorting of terms in languages that use non-Unicode character 
+    orderings.  (Lucene Sort using a Locale can be very slow.) 
+  </li>
+  <li>
+    Efficient range queries over fields that contain terms in languages that 
+    use non-Unicode character orderings.  (Range queries using a Locale can be
+    very slow.)
+  </li>
+  <li>
+    Effective Locale-specific normalization (case differences, diacritics, etc.).
+    ({@link org.apache.lucene.analysis.LowerCaseFilter} and 
+    {@link org.apache.lucene.analysis.ASCIIFoldingFilter} provide these services
+    in a generic way that doesn't take into account locale-specific needs.)
+  </li>
+</ul>
+
+<h2>Example Usages</h2>
+
+<h3>Farsi Range Queries</h3>
+<code><pre>
+  // "fa" Locale is not supported by Sun JDK 1.4 or 1.5
+  Collator collator = Collator.getInstance(new Locale("ar"));
+  CollationKeyAnalyzer analyzer = new CollationKeyAnalyzer(collator);
+  RAMDirectory ramDir = new RAMDirectory();
+  IndexWriter writer = new IndexWriter
+    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  Document doc = new Document();
+  doc.add(new Field("content", "\u0633\u0627\u0628", 
+                    Field.Store.YES, Field.Index.ANALYZED));
+  writer.addDocument(doc);
+  writer.close();
+  IndexSearcher is = new IndexSearcher(ramDir, true);
+
+  // The AnalyzingQueryParser in Lucene's contrib allows terms in range queries
+  // to be passed through an analyzer - Lucene's standard QueryParser does not
+  // allow this.
+  AnalyzingQueryParser aqp = new AnalyzingQueryParser("content", analyzer);
+  aqp.setLowercaseExpandedTerms(false);
+  
+  // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+  // orders the U+0698 character before the U+0633 character, so the single
+  // indexed Term above should NOT be returned by a ConstantScoreRangeQuery
+  // with a Farsi Collator (or an Arabic one for the case when Farsi is not
+  // supported).
+  ScoreDoc[] result
+    = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
+  assertEquals("The index Term should not be included.", 0, result.length);
+</pre></code>
+
+<h3>Danish Sorting</h3>
+<code><pre>
+  Analyzer analyzer 
+    = new CollationKeyAnalyzer(Collator.getInstance(new Locale("da", "dk")));
+  RAMDirectory indexStore = new RAMDirectory();
+  IndexWriter writer = new IndexWriter 
+    (indexStore, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  String[] tracer = new String[] { "A", "B", "C", "D", "E" };
+  String[] data = new String[] { "HAT", "HUT", "H\u00C5T", "H\u00D8T", "HOT" };
+  String[] sortedTracerOrder = new String[] { "A", "E", "B", "D", "C" };
+  for (int i = 0 ; i < data.length ; ++i) {
+    Document doc = new Document();
+    doc.add(new Field("tracer", tracer[i], Field.Store.YES, Field.Index.NO));
+    doc.add(new Field("contents", data[i], Field.Store.NO, Field.Index.ANALYZED));
+    writer.addDocument(doc);
+  }
+  writer.close();
+  Searcher searcher = new IndexSearcher(indexStore, true);
+  Sort sort = new Sort();
+  sort.setSort(new SortField("contents", SortField.STRING));
+  Query query = new MatchAllDocsQuery();
+  ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;
+  for (int i = 0 ; i < result.length ; ++i) {
+    Document doc = searcher.doc(result[i].doc);
+    assertEquals(sortedTracerOrder[i], doc.getValues("tracer")[0]);
+  }
+</pre></code>
+
+<h3>Turkish Case Normalization</h3>
+<code><pre>
+  Collator collator = Collator.getInstance(new Locale("tr", "TR"));
+  collator.setStrength(Collator.PRIMARY);
+  Analyzer analyzer = new CollationKeyAnalyzer(collator);
+  RAMDirectory ramDir = new RAMDirectory();
+  IndexWriter writer = new IndexWriter
+    (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+  Document doc = new Document();
+  doc.add(new Field("contents", "DIGY", Field.Store.NO, Field.Index.ANALYZED));
+  writer.addDocument(doc);
+  writer.close();
+  IndexSearcher is = new IndexSearcher(ramDir, true);
+  QueryParser parser = new QueryParser("contents", analyzer);
+  Query query = parser.parse("d\u0131gy");   // U+0131: dotless i
+  ScoreDoc[] result = is.search(query, null, 1000).scoreDocs;
+  assertEquals("The index Term should be included.", 1, result.length);
+</pre></code>
+
+<h2>Caveats and Comparisons</h2>
+<p>
+  <strong>WARNING:</strong> Make sure you use exactly the same 
+  <code>Collator</code> at index and query time -- <code>CollationKey</code>s
+  are only comparable when produced by
+  the same <code>Collator</code>.  Since {@link java.text.RuleBasedCollator}s
+  are not independently versioned, it is unsafe to search against stored
+  <code>CollationKey</code>s unless the following are exactly the same (best 
+  practice is to store this information with the index and check that they
+  remain the same at query time):
+</p>
+<ol>
+  <li>JVM vendor</li>
+  <li>JVM version, including patch version</li>
+  <li>
+    The language (and country and variant, if specified) of the Locale
+    used when constructing the collator via
+    {@link java.text.Collator#getInstance(java.util.Locale)}.
+  </li>
+  <li>
+    The collation strength used - see {@link java.text.Collator#setStrength(int)}
+  </li>
+</ol> 
+<p>
+  <code>ICUCollationKeyFilter</code>, available in the icu package in Lucene's contrib area,
+  uses ICU4J's <code>Collator</code>, which 
+  makes its version available, thus allowing collation to be versioned
+  independently from the JVM.  <code>ICUCollationKeyFilter</code> is also 
+  significantly faster and generates significantly shorter keys than 
+  <code>CollationKeyFilter</code>.  See
+  <a href="http://site.icu-project.org/charts/collation-icu4j-sun"
+    >http://site.icu-project.org/charts/collation-icu4j-sun</a> for key
+  generation timing and key length comparisons between ICU4J and
+  <code>java.text.Collator</code> over several languages.
+</p>
+<p>
+  <code>CollationKey</code>s generated by <code>java.text.Collator</code>s are 
+  not compatible with those those generated by ICU Collators.  Specifically, if
+  you use <code>CollationKeyFilter</code> to generate index terms, do not use
+  <code>ICUCollationKeyFilter</code> on the query side, or vice versa.
+</p>
+<pre>
+</pre>
+</body>
+</html>
diff --git a/src/test/org/apache/lucene/collation/CollationTestBase.java b/src/test/org/apache/lucene/collation/CollationTestBase.java
new file mode 100644
index 0000000..f5c8fe7
--- /dev/null
+++ b/src/test/org/apache/lucene/collation/CollationTestBase.java
@@ -0,0 +1,263 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import junit.framework.TestCase;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.PerFieldAnalyzerWrapper;
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermRangeFilter;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.util.IndexableBinaryStringTools;
+import org.apache.lucene.util.Version;
+
+import java.io.IOException;
+import java.nio.CharBuffer;
+import java.nio.ByteBuffer;
+
+
+public class CollationTestBase extends TestCase {
+
+  protected String firstRangeBeginningOriginal = "\u062F";
+  protected String firstRangeEndOriginal = "\u0698";
+  
+  protected String secondRangeBeginningOriginal = "\u0633";
+  protected String secondRangeEndOriginal = "\u0638";
+  
+  /**
+   * Convenience method to perform the same function as CollationKeyFilter.
+   *  
+   * @param keyBits the result from 
+   *  collator.getCollationKey(original).toByteArray()
+   * @return The encoded collation key for the original String
+   */
+  protected String encodeCollationKey(byte[] keyBits) {
+    ByteBuffer begBuf = ByteBuffer.wrap(keyBits);
+    // Ensure that the backing char[] array is large enough to hold the encoded
+    // Binary String
+    char[] encodedBegArray 
+      = new char[IndexableBinaryStringTools.getEncodedLength(begBuf)];
+    CharBuffer encodedBegBuf = CharBuffer.wrap(encodedBegArray); 
+    IndexableBinaryStringTools.encode(begBuf, encodedBegBuf);
+    return new String(encodedBegArray);
+  }
+    
+  public void testFarsiRangeFilterCollating(Analyzer analyzer, String firstBeg, 
+                                            String firstEnd, String secondBeg,
+                                            String secondEnd) throws Exception {
+    RAMDirectory ramDir = new RAMDirectory();
+    IndexWriter writer = new IndexWriter
+      (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+    Document doc = new Document();
+    doc.add(new Field("content", "\u0633\u0627\u0628", 
+                      Field.Store.YES, Field.Index.ANALYZED));
+    doc.add(new Field("body", "body",
+                      Field.Store.YES, Field.Index.NOT_ANALYZED));
+    writer.addDocument(doc);
+    writer.close();
+    IndexSearcher searcher = new IndexSearcher(ramDir, true);
+    Query query = new TermQuery(new Term("body","body"));
+
+    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+    // orders the U+0698 character before the U+0633 character, so the single
+    // index Term below should NOT be returned by a TermRangeFilter with a Farsi
+    // Collator (or an Arabic one for the case when Farsi searcher not
+    // supported).
+    ScoreDoc[] result = searcher.search
+      (query, new TermRangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
+    assertEquals("The index Term should not be included.", 0, result.length);
+
+    result = searcher.search
+      (query, new TermRangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
+    assertEquals("The index Term should be included.", 1, result.length);
+
+    searcher.close();
+  }
+ 
+  public void testFarsiRangeQueryCollating(Analyzer analyzer, String firstBeg, 
+                                            String firstEnd, String secondBeg,
+                                            String secondEnd) throws Exception {
+    RAMDirectory ramDir = new RAMDirectory();
+    IndexWriter writer = new IndexWriter
+      (ramDir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+    Document doc = new Document();
+
+    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+    // orders the U+0698 character before the U+0633 character, so the single
+    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
+    // Collator (or an Arabic one for the case when Farsi is not supported).
+    doc.add(new Field("content", "\u0633\u0627\u0628", 
+                      Field.Store.YES, Field.Index.ANALYZED));
+    writer.addDocument(doc);
+    writer.close();
+    IndexSearcher searcher = new IndexSearcher(ramDir, true);
+
+    Query query = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
+    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should not be included.", 0, hits.length);
+
+    query = new TermRangeQuery("content", secondBeg, secondEnd, true, true);
+    hits = searcher.search(query, null, 1000).scoreDocs;
+    assertEquals("The index Term should be included.", 1, hits.length);
+    searcher.close();
+  }
+
+  public void testFarsiTermRangeQuery
+    (Analyzer analyzer, String firstBeg, String firstEnd, 
+     String secondBeg, String secondEnd) throws Exception {
+
+    RAMDirectory farsiIndex = new RAMDirectory();
+    IndexWriter writer = new IndexWriter
+      (farsiIndex, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+    Document doc = new Document();
+    doc.add(new Field("content", "\u0633\u0627\u0628", 
+                      Field.Store.YES, Field.Index.ANALYZED));
+    doc.add(new Field("body", "body",
+                      Field.Store.YES, Field.Index.NOT_ANALYZED));
+    writer.addDocument(doc);
+    writer.close();
+
+    IndexReader reader = IndexReader.open(farsiIndex, true);
+    IndexSearcher search = new IndexSearcher(reader);
+        
+    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
+    // orders the U+0698 character before the U+0633 character, so the single
+    // index Term below should NOT be returned by a TermRangeQuery
+    // with a Farsi Collator (or an Arabic one for the case when Farsi is 
+    // not supported).
+    Query csrq 
+      = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
+    ScoreDoc[] result = search.search(csrq, null, 1000).scoreDocs;
+    assertEquals("The index Term should not be included.", 0, result.length);
+
+    csrq = new TermRangeQuery
+      ("content", secondBeg, secondEnd, true, true);
+    result = search.search(csrq, null, 1000).scoreDocs;
+    assertEquals("The index Term should be included.", 1, result.length);
+    search.close();
+  }
+  
+  // Test using various international locales with accented characters (which
+  // sort differently depending on locale)
+  //
+  // Copied (and slightly modified) from 
+  // org.apache.lucene.search.TestSort.testInternationalSort()
+  //  
+  public void testCollationKeySort(Analyzer usAnalyzer,
+                                   Analyzer franceAnalyzer,
+                                   Analyzer swedenAnalyzer,
+                                   Analyzer denmarkAnalyzer,
+                                   String usResult) throws Exception {
+    RAMDirectory indexStore = new RAMDirectory();
+    PerFieldAnalyzerWrapper analyzer
+      = new PerFieldAnalyzerWrapper(new WhitespaceAnalyzer());
+    analyzer.addAnalyzer("US", usAnalyzer);
+    analyzer.addAnalyzer("France", franceAnalyzer);
+    analyzer.addAnalyzer("Sweden", swedenAnalyzer);
+    analyzer.addAnalyzer("Denmark", denmarkAnalyzer);
+    IndexWriter writer = new IndexWriter 
+      (indexStore, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
+
+    // document data:
+    // the tracer field is used to determine which document was hit
+    String[][] sortData = new String[][] {
+      // tracer contents US                 France             Sweden (sv_SE)     Denmark (da_DK)
+      {  "A",   "x",     "p\u00EAche",      "p\u00EAche",      "p\u00EAche",      "p\u00EAche"      },
+      {  "B",   "y",     "HAT",             "HAT",             "HAT",             "HAT"             },
+      {  "C",   "x",     "p\u00E9ch\u00E9", "p\u00E9ch\u00E9", "p\u00E9ch\u00E9", "p\u00E9ch\u00E9" },
+      {  "D",   "y",     "HUT",             "HUT",             "HUT",             "HUT"             },
+      {  "E",   "x",     "peach",           "peach",           "peach",           "peach"           },
+      {  "F",   "y",     "H\u00C5T",        "H\u00C5T",        "H\u00C5T",        "H\u00C5T"        },
+      {  "G",   "x",     "sin",             "sin",             "sin",             "sin"             },
+      {  "H",   "y",     "H\u00D8T",        "H\u00D8T",        "H\u00D8T",        "H\u00D8T"        },
+      {  "I",   "x",     "s\u00EDn",        "s\u00EDn",        "s\u00EDn",        "s\u00EDn"        },
+      {  "J",   "y",     "HOT",             "HOT",             "HOT",             "HOT"             },
+    };
+
+    for (int i = 0 ; i < sortData.length ; ++i) {
+      Document doc = new Document();
+      doc.add(new Field("tracer", sortData[i][0], 
+                        Field.Store.YES, Field.Index.NO));
+      doc.add(new Field("contents", sortData[i][1], 
+                        Field.Store.NO, Field.Index.ANALYZED));
+      if (sortData[i][2] != null) 
+        doc.add(new Field("US", sortData[i][2], 
+                          Field.Store.NO, Field.Index.ANALYZED));
+      if (sortData[i][3] != null) 
+        doc.add(new Field("France", sortData[i][3], 
+                          Field.Store.NO, Field.Index.ANALYZED));
+      if (sortData[i][4] != null)
+        doc.add(new Field("Sweden", sortData[i][4], 
+                          Field.Store.NO, Field.Index.ANALYZED));
+      if (sortData[i][5] != null) 
+        doc.add(new Field("Denmark", sortData[i][5], 
+                          Field.Store.NO, Field.Index.ANALYZED));
+      writer.addDocument(doc);
+    }
+    writer.optimize();
+    writer.close();
+    Searcher searcher = new IndexSearcher(indexStore, true);
+
+    Sort sort = new Sort();
+    Query queryX = new TermQuery(new Term ("contents", "x"));
+    Query queryY = new TermQuery(new Term ("contents", "y"));
+    
+    sort.setSort(new SortField("US", SortField.STRING));
+    assertMatches(searcher, queryY, sort, usResult);
+
+    sort.setSort(new SortField("France", SortField.STRING));
+    assertMatches(searcher, queryX, sort, "EACGI");
+
+    sort.setSort(new SortField("Sweden", SortField.STRING));
+    assertMatches(searcher, queryY, sort, "BJDFH");
+
+    sort.setSort(new SortField("Denmark", SortField.STRING));
+    assertMatches(searcher, queryY, sort, "BJDHF");
+  }
+    
+  // Make sure the documents returned by the search match the expected list
+  // Copied from TestSort.java
+  private void assertMatches(Searcher searcher, Query query, Sort sort, 
+                             String expectedResult) throws IOException {
+    ScoreDoc[] result = searcher.search(query, null, 1000, sort).scoreDocs;
+    StringBuilder buff = new StringBuilder(10);
+    int n = result.length;
+    for (int i = 0 ; i < n ; ++i) {
+      Document doc = searcher.doc(result[i].doc);
+      String[] v = doc.getValues("tracer");
+      for (int j = 0 ; j < v.length ; ++j) {
+        buff.append(v[j]);
+      }
+    }
+    assertEquals(expectedResult, buff.toString());
+  }
+}
diff --git a/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java b/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java
new file mode 100644
index 0000000..06c6d07
--- /dev/null
+++ b/src/test/org/apache/lucene/collation/TestCollationKeyAnalyzer.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.analysis.Analyzer;
+
+import java.text.Collator;
+import java.util.Locale;
+
+
+public class TestCollationKeyAnalyzer extends CollationTestBase {
+
+  // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
+  // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
+  // characters properly.
+  private Collator collator = Collator.getInstance(new Locale("ar"));
+  private Analyzer analyzer = new CollationKeyAnalyzer(collator);
+
+  private String firstRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
+  private String firstRangeEnd = encodeCollationKey
+    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
+  private String secondRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
+  private String secondRangeEnd = encodeCollationKey
+    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
+  
+  public void testFarsiRangeFilterCollating() throws Exception {
+    testFarsiRangeFilterCollating
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+ 
+  public void testFarsiRangeQueryCollating() throws Exception {
+    testFarsiRangeQueryCollating
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+
+  public void testFarsiTermRangeQuery() throws Exception {
+    testFarsiTermRangeQuery
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+  
+  public void testCollationKeySort() throws Exception {
+    Analyzer usAnalyzer 
+      = new CollationKeyAnalyzer(Collator.getInstance(Locale.US));
+    Analyzer franceAnalyzer 
+      = new CollationKeyAnalyzer(Collator.getInstance(Locale.FRANCE));
+    Analyzer swedenAnalyzer 
+      = new CollationKeyAnalyzer(Collator.getInstance(new Locale("sv", "se")));
+    Analyzer denmarkAnalyzer 
+      = new CollationKeyAnalyzer(Collator.getInstance(new Locale("da", "dk")));
+    
+    // The ICU Collator and java.text.Collator implementations differ in their
+    // orderings - "BFJDH" is the ordering for java.text.Collator for Locale.US.
+    testCollationKeySort
+      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJDH");
+  }
+}
diff --git a/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java b/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java
new file mode 100644
index 0000000..401591e
--- /dev/null
+++ b/src/test/org/apache/lucene/collation/TestCollationKeyFilter.java
@@ -0,0 +1,95 @@
+package org.apache.lucene.collation;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.KeywordTokenizer;
+
+import java.text.Collator;
+import java.util.Locale;
+import java.io.Reader;
+
+
+public class TestCollationKeyFilter extends CollationTestBase {
+
+  // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
+  // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
+  // characters properly.
+  private Collator collator = Collator.getInstance(new Locale("ar"));
+  private Analyzer analyzer = new TestAnalyzer(collator);
+
+  private String firstRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(firstRangeBeginningOriginal).toByteArray());
+  private String firstRangeEnd = encodeCollationKey
+    (collator.getCollationKey(firstRangeEndOriginal).toByteArray());
+  private String secondRangeBeginning = encodeCollationKey
+    (collator.getCollationKey(secondRangeBeginningOriginal).toByteArray());
+  private String secondRangeEnd = encodeCollationKey
+    (collator.getCollationKey(secondRangeEndOriginal).toByteArray());
+
+  
+  public class TestAnalyzer extends Analyzer {
+    private Collator collator;
+
+    TestAnalyzer(Collator collator) {
+      this.collator = collator;
+    }
+
+    @Override
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      TokenStream result = new KeywordTokenizer(reader);
+      result = new CollationKeyFilter(result, collator);
+      return result;
+    }
+  }
+
+  public void testFarsiRangeFilterCollating() throws Exception {
+    testFarsiRangeFilterCollating
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+ 
+  public void testFarsiRangeQueryCollating() throws Exception {
+    testFarsiRangeQueryCollating
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+
+  public void testFarsiTermRangeQuery() throws Exception {
+    testFarsiTermRangeQuery
+      (analyzer, firstRangeBeginning, firstRangeEnd, 
+       secondRangeBeginning, secondRangeEnd);
+  }
+  
+  public void testCollationKeySort() throws Exception {
+    Analyzer usAnalyzer = new TestAnalyzer(Collator.getInstance(Locale.US));
+    Analyzer franceAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(Locale.FRANCE));
+    Analyzer swedenAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(new Locale("sv", "se")));
+    Analyzer denmarkAnalyzer 
+      = new TestAnalyzer(Collator.getInstance(new Locale("da", "dk")));
+    
+    // The ICU Collator and java.text.Collator implementations differ in their
+    // orderings - "BFJDH" is the ordering for java.text.Collator for Locale.US.
+    testCollationKeySort
+      (usAnalyzer, franceAnalyzer, swedenAnalyzer, denmarkAnalyzer, "BFJDH");
+  }
+}

