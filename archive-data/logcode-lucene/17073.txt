GitDiffStart: c8c9ee2cb20c1497a28ae1adb80dcc57a1fa5ac9 | Fri Oct 22 20:40:08 2010 +0000
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index dc9e76a3..51f1e5f 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -270,6 +270,11 @@ New features
 * LUCENE-2690: MultiTermQuery boolean rewrites per segment.
   (Uwe Schindler, Robert Muir, Mike McCandless, Simon Willnauer)
 
+* LUCENE-996: The QueryParser now accepts mixed inclusive and exclusive
+  bounds for range queries.  Example: "{3 TO 5]"
+  QueryParser subclasses that overrode getRangeQuery will need to be changed
+  to use the new getRangeQuery method.  (Andrew Schurman, Mark Miller, yonik)
+
 Optimizations
 
 * LUCENE-2410: ~20% speedup on exact (slop=0) PhraseQuery matching.
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
index 7d9f2f3..5f1d166 100644
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
+++ b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
@@ -269,7 +269,7 @@ public class AnalyzingQueryParser extends org.apache.lucene.queryParser.QueryPar
    * @exception ParseException
    */
   @Override
-  protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive)
+  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive)
       throws ParseException {
     // get Analyzer from superclass and tokenize the terms
     TokenStream source = getAnalyzer().tokenStream(field, new StringReader(part1));
@@ -316,7 +316,7 @@ public class AnalyzingQueryParser extends org.apache.lucene.queryParser.QueryPar
       throw new ParseException("Cannot build RangeQuery with analyzer " + getAnalyzer().getClass()
           + " - tokens were added to part2");
     }
-    return super.getRangeQuery(field, part1, part2, inclusive);
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
 }
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java
index 6359faf..acff75f 100644
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java
+++ b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java
@@ -161,25 +161,25 @@ public class ComplexPhraseQueryParser extends QueryParser {
 
   @Override
   protected Query getRangeQuery(String field, String part1, String part2,
-      boolean inclusive) throws ParseException {
+      boolean startInclusive, boolean endInclusive) throws ParseException {
     if (isPass2ResolvingPhrases) {
       checkPhraseClauseIsForSameField(field);
     }
-    return super.getRangeQuery(field, part1, part2, inclusive);
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
   @Override
   protected Query newRangeQuery(String field, String part1, String part2,
-      boolean inclusive) {
+      boolean startInclusive, boolean endInclusive) {
     if (isPass2ResolvingPhrases) {
       // Must use old-style RangeQuery in order to produce a BooleanQuery
       // that can be turned into SpanOr clause
-      TermRangeQuery rangeQuery = new TermRangeQuery(field, part1, part2, inclusive, inclusive,
+      TermRangeQuery rangeQuery = new TermRangeQuery(field, part1, part2, startInclusive, endInclusive,
           getRangeCollator());
       rangeQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
       return rangeQuery;
     }
-    return super.newRangeQuery(field, part1, part2, inclusive);
+    return super.newRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
   @Override
diff --git a/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java b/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
index 284e35c..b2f865e 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
+++ b/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
@@ -203,16 +203,16 @@ public class MultiFieldQueryParser extends QueryParser
 
  
   @Override
-  protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
+  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) throws ParseException {
     if (field == null) {
       List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, inclusive),
+        clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, startInclusive, endInclusive),
             BooleanClause.Occur.SHOULD));
       }
       return getBooleanQuery(clauses, true);
     }
-    return super.getRangeQuery(field, part1, part2, inclusive);
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
   /**
diff --git a/lucene/src/java/org/apache/lucene/queryParser/QueryParser.java b/lucene/src/java/org/apache/lucene/queryParser/QueryParser.java
index 57119b4..ad9af2e 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/QueryParser.java
+++ b/lucene/src/java/org/apache/lucene/queryParser/QueryParser.java
@@ -312,6 +312,8 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
   boolean wildcard = false;
   boolean fuzzy = false;
   boolean regexp = false;
+  boolean startInc=false;
+  boolean endInc=false;
   Query q;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case STAR:
@@ -378,13 +380,14 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
        q = handleBareTokenQuery(field, term, fuzzySlop, prefix, wildcard, fuzzy, regexp);
       break;
     case RANGEIN_START:
-      jj_consume_token(RANGEIN_START);
+    case RANGEEX_START:
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop1 = jj_consume_token(RANGEIN_GOOP);
+      case RANGEIN_START:
+        jj_consume_token(RANGEIN_START);
+                            startInc=true;
         break;
-      case RANGEIN_QUOTED:
-        goop1 = jj_consume_token(RANGEIN_QUOTED);
+      case RANGEEX_START:
+        jj_consume_token(RANGEEX_START);
         break;
       default:
         jj_la1[12] = jj_gen;
@@ -392,95 +395,66 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_TO:
-        jj_consume_token(RANGEIN_TO);
+      case RANGE_GOOP:
+        goop1 = jj_consume_token(RANGE_GOOP);
         break;
-      default:
-        jj_la1[13] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop2 = jj_consume_token(RANGEIN_GOOP);
-        break;
-      case RANGEIN_QUOTED:
-        goop2 = jj_consume_token(RANGEIN_QUOTED);
+      case RANGE_QUOTED:
+        goop1 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
-        jj_la1[14] = jj_gen;
+        jj_la1[13] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-      jj_consume_token(RANGEIN_END);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        jj_consume_token(CARAT);
-        boost = jj_consume_token(NUMBER);
+      case RANGE_TO:
+        jj_consume_token(RANGE_TO);
         break;
       default:
-        jj_la1[15] = jj_gen;
+        jj_la1[14] = jj_gen;
         ;
       }
-          if (goop1.kind == RANGEIN_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEIN_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
-      break;
-    case RANGEEX_START:
-      jj_consume_token(RANGEEX_START);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop1 = jj_consume_token(RANGEEX_GOOP);
+      case RANGE_GOOP:
+        goop2 = jj_consume_token(RANGE_GOOP);
         break;
-      case RANGEEX_QUOTED:
-        goop1 = jj_consume_token(RANGEEX_QUOTED);
+      case RANGE_QUOTED:
+        goop2 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[15] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_TO:
-        jj_consume_token(RANGEEX_TO);
+      case RANGEIN_END:
+        jj_consume_token(RANGEIN_END);
+                          endInc=true;
         break;
-      default:
-        jj_la1[17] = jj_gen;
-        ;
-      }
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop2 = jj_consume_token(RANGEEX_GOOP);
-        break;
-      case RANGEEX_QUOTED:
-        goop2 = jj_consume_token(RANGEEX_QUOTED);
+      case RANGEEX_END:
+        jj_consume_token(RANGEEX_END);
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[16] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-      jj_consume_token(RANGEEX_END);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CARAT:
         jj_consume_token(CARAT);
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[17] = jj_gen;
         ;
       }
-          if (goop1.kind == RANGEEX_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEEX_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
-
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
+          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), startInc, endInc);
       break;
     case QUOTED:
       term = jj_consume_token(QUOTED);
@@ -489,7 +463,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
         fuzzySlop = jj_consume_token(FUZZY_SLOP);
         break;
       default:
-        jj_la1[20] = jj_gen;
+        jj_la1[18] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -498,13 +472,13 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[21] = jj_gen;
+        jj_la1[19] = jj_gen;
         ;
       }
          q = handleQuotedTerm(field, term, fuzzySlop);
       break;
     default:
-      jj_la1[22] = jj_gen;
+      jj_la1[20] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -519,6 +493,12 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     finally { jj_save(0, xla); }
   }
 
+  private boolean jj_3R_3() {
+    if (jj_scan_token(STAR)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
   private boolean jj_3R_2() {
     if (jj_scan_token(TERM)) return true;
     if (jj_scan_token(COLON)) return true;
@@ -535,12 +515,6 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     return false;
   }
 
-  private boolean jj_3R_3() {
-    if (jj_scan_token(STAR)) return true;
-    if (jj_scan_token(COLON)) return true;
-    return false;
-  }
-
   /** Generated Token Manager. */
   public QueryParserTokenManager token_source;
   /** Current token. */
@@ -551,18 +525,13 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   private int jj_gen;
-  final private int[] jj_la1 = new int[23];
+  final private int[] jj_la1 = new int[21];
   static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
   static {
       jj_la1_init_0();
-      jj_la1_init_1();
    }
    private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x7ed3f00,0x90000,0x20000,0x7ed2000,0x4e90000,0x100000,0x100000,0x20000,0x60000000,0x8000000,0x60000000,0x20000,0x0,0x80000000,0x0,0x20000,0x100000,0x20000,0x7ed0000,};
-   }
-   private static void jj_la1_init_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x0,0x6,0x0,0x0,0x0,0x0,};
+      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x7ed3f00,0x90000,0x20000,0x7ed2000,0x4e90000,0x100000,0x100000,0x20000,0x3000000,0xc0000000,0x8000000,0xc0000000,0x30000000,0x20000,0x100000,0x20000,0x7ed0000,};
    }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
@@ -574,7 +543,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -584,7 +553,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -594,7 +563,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -604,7 +573,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 21; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -716,24 +685,21 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
   /** Generate ParseException. */
   public ParseException generateParseException() {
     jj_expentries.clear();
-    boolean[] la1tokens = new boolean[35];
+    boolean[] la1tokens = new boolean[32];
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 23; i++) {
+    for (int i = 0; i < 21; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
         }
       }
     }
-    for (int i = 0; i < 35; i++) {
+    for (int i = 0; i < 32; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
diff --git a/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj b/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj
index 7ac4c97..b08d588 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj
+++ b/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj
@@ -173,7 +173,7 @@ PARSER_END(QueryParser)
 | <#_QUOTED_CHAR: ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
 }
 
-<DEFAULT, RangeIn, RangeEx> SKIP : {
+<DEFAULT, Range> SKIP : {
   < <_WHITESPACE>>
 }
 
@@ -194,26 +194,20 @@ PARSER_END(QueryParser)
 | <PREFIXTERM:  ("*") | ( <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" ) >
 | <WILDTERM:  (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
 | <REGEXPTERM: "/" (~[ "/" ] | "\\/" )* "/" >
-| <RANGEIN_START: "[" > : RangeIn
-| <RANGEEX_START: "{" > : RangeEx
+| <RANGEIN_START: "[" > : Range
+| <RANGEEX_START: "{" > : Range
 }
 
 <Boost> TOKEN : {
 <NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
 }
 
-<RangeIn> TOKEN : {
-<RANGEIN_TO: "TO">
+<Range> TOKEN : {
+<RANGE_TO: "TO">
 | <RANGEIN_END: "]"> : DEFAULT
-| <RANGEIN_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
-}
-
-<RangeEx> TOKEN : {
-<RANGEEX_TO: "TO">
 | <RANGEEX_END: "}"> : DEFAULT
-| <RANGEEX_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
+| <RANGE_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGE_GOOP: (~[ " ", "]", "}" ])+ >
 }
 
 // *   Query  ::= ( Clause )*
@@ -308,6 +302,8 @@ Query Term(String field) : {
   boolean wildcard = false;
   boolean fuzzy = false;
   boolean regexp = false;
+  boolean startInc=false;
+  boolean endInc=false;
   Query q;
 }
 {
@@ -325,32 +321,20 @@ Query Term(String field) : {
      {
        q = handleBareTokenQuery(field, term, fuzzySlop, prefix, wildcard, fuzzy, regexp);
      }
-     | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
-         [ <RANGEIN_TO> ] ( goop2=<RANGEIN_GOOP>|goop2=<RANGEIN_QUOTED> )
-         <RANGEIN_END> )
-       [ <CARAT> boost=<NUMBER> ]
-        {
-          if (goop1.kind == RANGEIN_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
-          }
-          if (goop2.kind == RANGEIN_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
-          }
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
-        }
-     | ( <RANGEEX_START> ( goop1=<RANGEEX_GOOP>|goop1=<RANGEEX_QUOTED> )
-         [ <RANGEEX_TO> ] ( goop2=<RANGEEX_GOOP>|goop2=<RANGEEX_QUOTED> )
-         <RANGEEX_END> )
+     | ( ( <RANGEIN_START> {startInc=true;} | <RANGEEX_START> )
+         ( goop1=<RANGE_GOOP>|goop1=<RANGE_QUOTED> )
+         [ <RANGE_TO> ]
+         ( goop2=<RANGE_GOOP>|goop2=<RANGE_QUOTED> )
+         ( <RANGEIN_END> {endInc=true;} | <RANGEEX_END>))
        [ <CARAT> boost=<NUMBER> ]
         {
-          if (goop1.kind == RANGEEX_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEEX_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
-
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
+          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), startInc, endInc);
         }
      | term=<QUOTED>
        [ fuzzySlop=<FUZZY_SLOP> ]
diff --git a/lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java b/lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java
index 5eada5b..a12797b 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java
+++ b/lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java
@@ -42,6 +42,9 @@ import java.util.*;
  */
 public abstract class QueryParserBase {
 
+  /** Do not catch this exception in your code, it means you are using methods that you should no longer use. */
+  public static class MethodRemovedUseAnother extends Throwable {}
+
   static final int CONJ_NONE   = 0;
   static final int CONJ_AND    = 1;
   static final int CONJ_OR     = 2;
@@ -694,13 +697,18 @@ public abstract class QueryParserBase {
   }
 
 
+  @Deprecated
+  protected final Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws MethodRemovedUseAnother {return null;}
+
+
   /**
    * @exception org.apache.lucene.queryParser.ParseException throw in overridden method to disallow
    */
   protected Query getRangeQuery(String field,
                                 String part1,
                                 String part2,
-                                boolean inclusive) throws ParseException
+                                boolean startInclusive,
+                                boolean endInclusive) throws ParseException
   {
     if (lowercaseExpandedTerms) {
       part1 = part1.toLowerCase();
@@ -711,7 +719,7 @@ public abstract class QueryParserBase {
       df.setLenient(true);
       Date d1 = df.parse(part1);
       Date d2 = df.parse(part2);
-      if (inclusive) {
+      if (endInclusive) {
         // The user can only specify the date, not the time, so make sure
         // the time is set to the latest possible time of that date to really
         // include all documents:
@@ -737,7 +745,7 @@ public abstract class QueryParserBase {
     }
     catch (Exception e) { }
 
-    return newRangeQuery(field, part1, part2, inclusive);
+    return newRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
  /**
@@ -818,16 +826,21 @@ public abstract class QueryParserBase {
     return new FuzzyQuery(term,minimumSimilarity,prefixLength);
   }
 
+  @Deprecated
+  protected final Query newRangeQuery(String field, String part1, String part2, boolean inclusive) throws MethodRemovedUseAnother {return null;}
+
+
   /**
    * Builds a new TermRangeQuery instance
    * @param field Field
    * @param part1 min
    * @param part2 max
-   * @param inclusive true if range is inclusive
+   * @param startInclusive true if the start of the range is inclusive
+   * @param endInclusive true if the end of the range is inclusive
    * @return new TermRangeQuery instance
    */
-  protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
-    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
+  protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) {
+    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, startInclusive, endInclusive, rangeCollator);
     query.setRewriteMethod(multiTermRewriteMethod);
     return query;
   }
diff --git a/lucene/src/java/org/apache/lucene/queryParser/QueryParserConstants.java b/lucene/src/java/org/apache/lucene/queryParser/QueryParserConstants.java
index 5bf9a46..df4ae5d 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/QueryParserConstants.java
+++ b/lucene/src/java/org/apache/lucene/queryParser/QueryParserConstants.java
@@ -61,30 +61,22 @@ public interface QueryParserConstants {
   /** RegularExpression Id. */
   int NUMBER = 26;
   /** RegularExpression Id. */
-  int RANGEIN_TO = 27;
+  int RANGE_TO = 27;
   /** RegularExpression Id. */
   int RANGEIN_END = 28;
   /** RegularExpression Id. */
-  int RANGEIN_QUOTED = 29;
+  int RANGEEX_END = 29;
   /** RegularExpression Id. */
-  int RANGEIN_GOOP = 30;
+  int RANGE_QUOTED = 30;
   /** RegularExpression Id. */
-  int RANGEEX_TO = 31;
-  /** RegularExpression Id. */
-  int RANGEEX_END = 32;
-  /** RegularExpression Id. */
-  int RANGEEX_QUOTED = 33;
-  /** RegularExpression Id. */
-  int RANGEEX_GOOP = 34;
+  int RANGE_GOOP = 31;
 
   /** Lexical state. */
   int Boost = 0;
   /** Lexical state. */
-  int RangeEx = 1;
+  int Range = 1;
   /** Lexical state. */
-  int RangeIn = 2;
-  /** Lexical state. */
-  int DEFAULT = 3;
+  int DEFAULT = 2;
 
   /** Literal token values. */
   String[] tokenImage = {
@@ -117,12 +109,9 @@ public interface QueryParserConstants {
     "<NUMBER>",
     "\"TO\"",
     "\"]\"",
-    "<RANGEIN_QUOTED>",
-    "<RANGEIN_GOOP>",
-    "\"TO\"",
     "\"}\"",
-    "<RANGEEX_QUOTED>",
-    "<RANGEEX_GOOP>",
+    "<RANGE_QUOTED>",
+    "<RANGE_GOOP>",
   };
 
 }
diff --git a/lucene/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java b/lucene/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
index 2e1a6d4..f0bb11d 100644
--- a/lucene/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
+++ b/lucene/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
@@ -44,7 +44,7 @@ public class QueryParserTokenManager implements QueryParserConstants
   public  java.io.PrintStream debugStream = System.out;
   /** Set debug output. */
   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_3(int pos, long active0)
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
 {
    switch (pos)
    {
@@ -52,9 +52,9 @@ private final int jjStopStringLiteralDfa_3(int pos, long active0)
          return -1;
    }
 }
-private final int jjStartNfa_3(int pos, long active0)
+private final int jjStartNfa_2(int pos, long active0)
 {
-   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
 }
 private int jjStopAtPos(int pos, int kind)
 {
@@ -62,7 +62,7 @@ private int jjStopAtPos(int pos, int kind)
    jjmatchedPos = pos;
    return pos + 1;
 }
-private int jjMoveStringLiteralDfa0_3()
+private int jjMoveStringLiteralDfa0_2()
 {
    switch(curChar)
    {
@@ -71,7 +71,7 @@ private int jjMoveStringLiteralDfa0_3()
       case 41:
          return jjStopAtPos(0, 14);
       case 42:
-         return jjStartNfaWithStates_3(0, 16, 41);
+         return jjStartNfaWithStates_2(0, 16, 41);
       case 43:
          return jjStopAtPos(0, 11);
       case 45:
@@ -85,16 +85,16 @@ private int jjMoveStringLiteralDfa0_3()
       case 123:
          return jjStopAtPos(0, 25);
       default :
-         return jjMoveNfa_3(0, 0);
+         return jjMoveNfa_2(0, 0);
    }
 }
-private int jjStartNfaWithStates_3(int pos, int kind, int state)
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
+   return jjMoveNfa_2(state, pos + 1);
 }
 static final long[] jjbitVec0 = {
    0x1L, 0x0L, 0x0L, 0x0L
@@ -108,7 +108,7 @@ static final long[] jjbitVec3 = {
 static final long[] jjbitVec4 = {
    0xfffefffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-private int jjMoveNfa_3(int startState, int curPos)
+private int jjMoveNfa_2(int startState, int curPos)
 {
    int startsAt = 0;
    jjnewStateCnt = 41;
@@ -557,201 +557,6 @@ private int jjMoveNfa_3(int startState, int curPos)
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_1(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x80000000L) != 0L)
-         {
-            jjmatchedKind = 34;
-            return 6;
-         }
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_1(int pos, long active0)
-{
-   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
-}
-private int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 84:
-         return jjMoveStringLiteralDfa1_1(0x80000000L);
-      case 125:
-         return jjStopAtPos(0, 32);
-      default :
-         return jjMoveNfa_1(0, 0);
-   }
-}
-private int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_1(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 79:
-         if ((active0 & 0x80000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 31, 6);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_1(0, active0);
-}
-private int jjStartNfaWithStates_1(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_1(state, pos + 1);
-}
-private int jjMoveNfa_1(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 7;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xfffffffeffffffffL & l) != 0L)
-                  {
-                     if (kind > 34)
-                        kind = 34;
-                     jjCheckNAdd(6);
-                  }
-                  if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 1:
-                  if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 2:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(19, 21);
-                  break;
-               case 3:
-                  if (curChar == 34)
-                     jjCheckNAddStates(19, 21);
-                  break;
-               case 5:
-                  if (curChar == 34 && kind > 33)
-                     kind = 33;
-                  break;
-               case 6:
-                  if ((0xfffffffeffffffffL & l) == 0L)
-                     break;
-                  if (kind > 34)
-                     kind = 34;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 6:
-                  if ((0xdfffffffffffffffL & l) == 0L)
-                     break;
-                  if (kind > 34)
-                     kind = 34;
-                  jjCheckNAdd(6);
-                  break;
-               case 2:
-                  jjAddStates(19, 21);
-                  break;
-               case 4:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                  {
-                     if (kind > 34)
-                        kind = 34;
-                     jjCheckNAdd(6);
-                  }
-                  break;
-               case 2:
-                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(19, 21);
-                  break;
-               case 6:
-                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 34)
-                     kind = 34;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
 private int jjMoveStringLiteralDfa0_0()
 {
    return jjMoveNfa_0(0, 0);
@@ -779,7 +584,7 @@ private int jjMoveNfa_0(int startState, int curPos)
                      break;
                   if (kind > 26)
                      kind = 26;
-                  jjAddStates(22, 23);
+                  jjAddStates(19, 20);
                   break;
                case 1:
                   if (curChar == 46)
@@ -835,14 +640,14 @@ private int jjMoveNfa_0(int startState, int curPos)
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_2(int pos, long active0)
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
 {
    switch (pos)
    {
       case 0:
          if ((active0 & 0x8000000L) != 0L)
          {
-            jjmatchedKind = 30;
+            jjmatchedKind = 31;
             return 6;
          }
          return -1;
@@ -850,49 +655,51 @@ private final int jjStopStringLiteralDfa_2(int pos, long active0)
          return -1;
    }
 }
-private final int jjStartNfa_2(int pos, long active0)
+private final int jjStartNfa_1(int pos, long active0)
 {
-   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
 }
-private int jjMoveStringLiteralDfa0_2()
+private int jjMoveStringLiteralDfa0_1()
 {
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_2(0x8000000L);
+         return jjMoveStringLiteralDfa1_1(0x8000000L);
       case 93:
          return jjStopAtPos(0, 28);
+      case 125:
+         return jjStopAtPos(0, 29);
       default :
-         return jjMoveNfa_2(0, 0);
+         return jjMoveNfa_1(0, 0);
    }
 }
-private int jjMoveStringLiteralDfa1_2(long active0)
+private int jjMoveStringLiteralDfa1_1(long active0)
 {
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_2(0, active0);
+      jjStopStringLiteralDfa_1(0, active0);
       return 1;
    }
    switch(curChar)
    {
       case 79:
          if ((active0 & 0x8000000L) != 0L)
-            return jjStartNfaWithStates_2(1, 27, 6);
+            return jjStartNfaWithStates_1(1, 27, 6);
          break;
       default :
          break;
    }
-   return jjStartNfa_2(0, active0);
+   return jjStartNfa_1(0, active0);
 }
-private int jjStartNfaWithStates_2(int pos, int kind, int state)
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_2(state, pos + 1);
+   return jjMoveNfa_1(state, pos + 1);
 }
-private int jjMoveNfa_2(int startState, int curPos)
+private int jjMoveNfa_1(int startState, int curPos)
 {
    int startsAt = 0;
    jjnewStateCnt = 7;
@@ -913,8 +720,8 @@ private int jjMoveNfa_2(int startState, int curPos)
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 30)
-                        kind = 30;
+                     if (kind > 31)
+                        kind = 31;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -931,21 +738,21 @@ private int jjMoveNfa_2(int startState, int curPos)
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(19, 21);
+                     jjCheckNAddStates(21, 23);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(19, 21);
+                     jjCheckNAddStates(21, 23);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 29)
-                     kind = 29;
+                  if (curChar == 34 && kind > 30)
+                     kind = 30;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 30)
-                     kind = 30;
+                  if (kind > 31)
+                     kind = 31;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -961,14 +768,14 @@ private int jjMoveNfa_2(int startState, int curPos)
             {
                case 0:
                case 6:
-                  if ((0xffffffffdfffffffL & l) == 0L)
+                  if ((0xdfffffffdfffffffL & l) == 0L)
                      break;
-                  if (kind > 30)
-                     kind = 30;
+                  if (kind > 31)
+                     kind = 31;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(19, 21);
+                  jjAddStates(21, 23);
                   break;
                case 4:
                   if (curChar == 92)
@@ -997,20 +804,20 @@ private int jjMoveNfa_2(int startState, int curPos)
                   }
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                   {
-                     if (kind > 30)
-                        kind = 30;
+                     if (kind > 31)
+                        kind = 31;
                      jjCheckNAdd(6);
                   }
                   break;
                case 2:
                   if (jjCanMove_1(hiByte, i1, i2, l1, l2))
-                     jjAddStates(19, 21);
+                     jjAddStates(21, 23);
                   break;
                case 6:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 30)
-                     kind = 30;
+                  if (kind > 31)
+                     kind = 31;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -1032,7 +839,7 @@ private int jjMoveNfa_2(int startState, int curPos)
 }
 static final int[] jjnextStates = {
    15, 16, 18, 34, 37, 23, 38, 35, 29, 31, 32, 20, 21, 37, 23, 38, 
-   36, 39, 27, 2, 4, 5, 0, 1, 
+   36, 39, 27, 0, 1, 2, 4, 5, 
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -1075,23 +882,22 @@ private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, lo
 public static final String[] jjstrLiteralImages = {
 "", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
 "\50", "\51", "\72", "\52", "\136", null, null, null, null, null, null, "\133", 
-"\173", null, "\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+"\173", null, "\124\117", "\135", "\175", null, null, };
 
 /** Lexer state names. */
 public static final String[] lexStateNames = {
    "Boost",
-   "RangeEx",
-   "RangeIn",
+   "Range",
    "DEFAULT",
 };
 
 /** Lex State array. */
 public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, 2, 
-   1, 3, -1, 3, -1, -1, -1, 3, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, 1, 
+   1, 2, -1, 2, 2, -1, -1, 
 };
 static final long[] jjtoToken = {
-   0x7ffffff01L, 
+   0xffffff01L, 
 };
 static final long[] jjtoSkip = {
    0x80L, 
@@ -1137,7 +943,7 @@ public void ReInit(CharStream stream, int lexState)
 /** Switch to specified lex state. */
 public void SwitchTo(int lexState)
 {
-   if (lexState >= 4 || lexState < 0)
+   if (lexState >= 3 || lexState < 0)
       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    else
       curLexState = lexState;
@@ -1167,8 +973,8 @@ protected Token jjFillToken()
    return t;
 }
 
-int curLexState = 3;
-int defaultLexState = 3;
+int curLexState = 2;
+int defaultLexState = 2;
 int jjnewStateCnt;
 int jjround;
 int jjmatchedPos;
@@ -1211,11 +1017,6 @@ public Token getNextToken()
        jjmatchedPos = 0;
        curPos = jjMoveStringLiteralDfa0_2();
        break;
-     case 3:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_3();
-       break;
    }
      if (jjmatchedKind != 0x7fffffff)
      {
diff --git a/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java b/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java
index d637caf..b4edb39 100644
--- a/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java
+++ b/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java
@@ -541,7 +541,10 @@ public class TestQueryParser extends LuceneTestCase {
 
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
+    assertQueryEquals("[ a TO z}", null, "[a TO z}");
+    assertQueryEquals("{ a TO z]", null, "{a TO z]"); 
+
+     assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
 
     QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, "field", new MockAnalyzer(MockTokenizer.SIMPLE, true));
     qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
@@ -555,7 +558,7 @@ public class TestQueryParser extends LuceneTestCase {
     assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null, "gack (bar blar {a TO z})");
-  }
+ }
     
   public void testFarsiRangeCollating() throws Exception {
     Directory ramDir = newDirectory();
diff --git a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
index 6f546ff..00cc64c 100755
--- a/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
+++ b/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java
@@ -866,6 +866,7 @@ class ExtendedDismaxQParser extends QParser {
     String val;
     String val2;
     boolean bool;
+    boolean bool2;
     float flt;
     int slop;
 
@@ -904,14 +905,15 @@ class ExtendedDismaxQParser extends QParser {
     }
 
     @Override
-    protected Query getRangeQuery(String field, String a, String b, boolean inclusive) throws ParseException {
+     protected Query getRangeQuery(String field, String a, String b, boolean startInclusive, boolean endInclusive) throws ParseException {
 //System.out.println("getRangeQuery:");
 
       this.type = QType.RANGE;
       this.field = field;
       this.val = a;
       this.val2 = b;
-      this.bool = inclusive;
+      this.bool = startInclusive;
+      this.bool2 = endInclusive;
       return getAliasedQuery();
     }
 
@@ -1022,7 +1024,7 @@ class ExtendedDismaxQParser extends QParser {
           case PREFIX: return super.getPrefixQuery(field, val);
           case WILDCARD: return super.getWildcardQuery(field, val);
           case FUZZY: return super.getFuzzyQuery(field, val, flt);
-          case RANGE: return super.getRangeQuery(field, val, val2, bool);
+          case RANGE: return super.getRangeQuery(field, val, val2, bool, bool2);
         }
         return null;
 
diff --git a/solr/src/java/org/apache/solr/search/SolrQueryParser.java b/solr/src/java/org/apache/solr/search/SolrQueryParser.java
index 7f92bd4..eef0af6 100644
--- a/solr/src/java/org/apache/solr/search/SolrQueryParser.java
+++ b/solr/src/java/org/apache/solr/search/SolrQueryParser.java
@@ -130,6 +130,7 @@ public class SolrQueryParser extends QueryParser {
     }
   }
 
+  @Override
   protected Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {
     checkNullField(field);
     // intercept magic field name of "_" to use as a hook for our
@@ -161,15 +162,17 @@ public class SolrQueryParser extends QueryParser {
     return super.getFieldQuery(field, queryText, quoted);
   }
 
-  protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
+  @Override
+  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) throws ParseException {
     checkNullField(field);
     SchemaField sf = schema.getField(field);
     return sf.getType().getRangeQuery(parser, sf,
             "*".equals(part1) ? null : part1,
             "*".equals(part2) ? null : part2,
-            inclusive, inclusive);
+            startInclusive, endInclusive);
   }
 
+  @Override
   protected Query getPrefixQuery(String field, String termStr) throws ParseException {
     checkNullField(field);
     if (getLowercaseExpandedTerms()) {
@@ -191,6 +194,7 @@ public class SolrQueryParser extends QueryParser {
     return prefixQuery;
   }
 
+  @Override
   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
     // *:* -> MatchAllDocsQuery
     if ("*".equals(field) && "*".equals(termStr)) {

