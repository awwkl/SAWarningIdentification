GitDiffStart: 932923ee4bed393b5f74fc56650cd3e08e001abf | Mon Apr 1 22:04:32 2013 +0000
diff --git a/lucene/tools/junit4/cached-timehints.txt b/lucene/tools/junit4/cached-timehints.txt
index 80b9d66..b892b2d 100644
--- a/lucene/tools/junit4/cached-timehints.txt
+++ b/lucene/tools/junit4/cached-timehints.txt
@@ -929,7 +929,7 @@ org.apache.solr.core.TestQuerySenderListener=404,823,424,422,360,411,431
 org.apache.solr.core.TestQuerySenderNoQuery=392,616,406,406,413,413,356
 org.apache.solr.core.TestSolrDeletionPolicy1=636,736,868,732,627,1449,788
 org.apache.solr.core.TestSolrDeletionPolicy2=377,450,376,388,413,459,373
-org.apache.solr.core.TestSolrDiscoveryProperties=1183,1243,5175,1041,1490,2090,1181
+org.apache.solr.core.TestCoreDiscovery=1183,1243,5175,1041,1490,2090,1181
 org.apache.solr.core.TestSolrIndexConfig=491,411,360,426,407,414,369
 org.apache.solr.core.TestSolrXMLSerializer=29,24,33,39,164,65,46
 org.apache.solr.core.TestXIncludeConfig=158,139,147,115,1494,112,318
diff --git a/solr/core/src/java/org/apache/solr/cloud/ZkCLI.java b/solr/core/src/java/org/apache/solr/cloud/ZkCLI.java
index cd7fd75..9e31681 100644
--- a/solr/core/src/java/org/apache/solr/cloud/ZkCLI.java
+++ b/solr/core/src/java/org/apache/solr/cloud/ZkCLI.java
@@ -21,8 +21,7 @@ import org.apache.commons.io.IOUtils;
 import org.apache.solr.common.cloud.OnReconnect;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.core.ConfigSolr;
-import org.apache.solr.core.ConfigSolrXmlBackCompat;
-import org.apache.solr.core.SolrProperties;
+import org.apache.solr.core.ConfigSolrXml;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.zookeeper.KeeperException;
 import org.xml.sax.SAXException;
@@ -177,21 +176,12 @@ public class ZkCLI {
           solrHome = loader.getInstanceDir();
 
           File configFile = new File(solrHome, SOLR_XML);
-          boolean isXml = true;
-          if (! configFile.exists()) {
-            configFile = new File(solrHome, SolrProperties.SOLR_PROPERTIES_FILE);
-            isXml = false;
-          }
           InputStream is = new FileInputStream(configFile);
 
           ConfigSolr cfg;
 
           try {
-            if (isXml) {
-              cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);
-            } else {
-              cfg = new SolrProperties(null, loader, is, null);
-            }
+            cfg = new ConfigSolrXml(loader, null, is, null, false, null);
           } finally {
             IOUtils.closeQuietly(is);
           }
diff --git a/solr/core/src/java/org/apache/solr/core/Config.java b/solr/core/src/java/org/apache/solr/core/Config.java
index c3e7541..d31ef7c 100644
--- a/solr/core/src/java/org/apache/solr/core/Config.java
+++ b/solr/core/src/java/org/apache/solr/core/Config.java
@@ -84,7 +84,7 @@ public class Config {
    */
   @Deprecated
   public Config(SolrResourceLoader loader, Config cfg) throws TransformerException {
-    this(loader, null, ConfigSolrXmlBackCompat.copyDoc(cfg.getDocument()));
+    this(loader, null, ConfigSolrXml.copyDoc(cfg.getDocument()));
   }
 
   public Config(SolrResourceLoader loader, String name, InputSource is, String prefix) throws ParserConfigurationException, IOException, SAXException 
diff --git a/solr/core/src/java/org/apache/solr/core/ConfigSolr.java b/solr/core/src/java/org/apache/solr/core/ConfigSolr.java
index eadb42b..ce68c7f 100644
--- a/solr/core/src/java/org/apache/solr/core/ConfigSolr.java
+++ b/solr/core/src/java/org/apache/solr/core/ConfigSolr.java
@@ -33,16 +33,16 @@ import java.util.Properties;
  * This is already deprecated, it's only intended to exist for while transitioning to properties-based replacement for
  * solr.xml
  *
- * @since solr 4.2
+ * @since solr 4.3
  */
-@Deprecated
 public interface ConfigSolr {
 
   public static enum ConfLevel {
     SOLR, SOLR_CORES, SOLR_CORES_CORE, SOLR_LOGGING, SOLR_LOGGING_WATCHER
-  }
+  };
 
-  ;
+  public final static String CORE_PROP_FILE = "core.properties";
+  public final static String SOLR_XML_FILE = "solr.xml";
 
   public int getInt(ConfLevel level, String tag, int def);
 
diff --git a/solr/core/src/java/org/apache/solr/core/ConfigSolrXml.java b/solr/core/src/java/org/apache/solr/core/ConfigSolrXml.java
new file mode 100644
index 0000000..da755a9
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/core/ConfigSolrXml.java
@@ -0,0 +1,527 @@
+package org.apache.solr.core;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.commons.io.IOUtils;
+import org.apache.solr.cloud.ZkController;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.handler.component.HttpShardHandlerFactory;
+import org.apache.solr.handler.component.ShardHandlerFactory;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.util.DOMUtil;
+import org.apache.solr.util.PropertiesUtil;
+import org.apache.solr.util.SystemIdResolver;
+import org.apache.solr.util.plugin.PluginInfoInitialized;
+import org.apache.zookeeper.KeeperException;
+import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMResult;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+/**
+ * ConfigSolrXml
+ * <p/>
+ * This class is entirely to localize the backwards compatibility for dealing with specific issues when transitioning
+ * from solr.xml to a solr.properties-based, enumeration/discovery of defined cores. See SOLR-4196 for background.
+ * <p/>
+ * @since solr 4.3
+ *
+ * It's a bit twisted, but we decided to NOT do the solr.properties switch. But since there's already an interface
+ * it makes sense to leave it in so we can use other methods of providing the Solr information that is contained
+ * in solr.xml. Perhapse something form SolrCloud in the future?
+ *
+ */
+
+public class ConfigSolrXml extends Config implements ConfigSolr {
+
+  private static Map<ConfLevel, String> prefixes;
+  private boolean isAutoDiscover = false;
+
+  private final Map<String, CoreDescriptorPlus> coreDescriptorPlusMap = new HashMap<String, CoreDescriptorPlus>();
+  private NodeList coreNodes = null;
+
+  static {
+    prefixes = new HashMap<ConfLevel, String>();
+
+    prefixes.put(ConfLevel.SOLR, "solr/@");
+    prefixes.put(ConfLevel.SOLR_CORES, "solr/cores/@");
+    prefixes.put(ConfLevel.SOLR_CORES_CORE, "solr/cores/core/@");
+    prefixes.put(ConfLevel.SOLR_LOGGING, "solr/logging/@");
+    prefixes.put(ConfLevel.SOLR_LOGGING_WATCHER, "solr/logging/watcher/@");
+  }
+
+  public ConfigSolrXml(SolrResourceLoader loader, String name, InputStream is, String prefix,
+                       boolean subProps, CoreContainer container) throws ParserConfigurationException, IOException, SAXException {
+    super(loader, name, new InputSource(is), prefix, subProps);
+    initCoreList(container);
+  }
+
+
+  public ConfigSolrXml(SolrResourceLoader loader, Config cfg, CoreContainer container) throws TransformerException, IOException {
+    super(loader, null, copyDoc(cfg.getDocument())); // Mimics a call from CoreContainer.
+    initCoreList(container);
+  }
+
+  public void initCoreList(CoreContainer container) throws IOException {
+    isAutoDiscover = getBool(ConfigSolr.ConfLevel.SOLR_CORES, "autoDiscoverCores", false);
+    if (isAutoDiscover) {
+      synchronized (coreDescriptorPlusMap) {
+        walkFromHere(new File(container.getSolrHome()), container);
+      }
+
+    } else {
+      coreNodes = (NodeList) evaluate("solr/cores/core",
+          XPathConstants.NODESET);
+    }
+
+  }
+  public static Document copyDoc(Document doc) throws TransformerException {
+    TransformerFactory tfactory = TransformerFactory.newInstance();
+    Transformer tx = tfactory.newTransformer();
+    DOMSource source = new DOMSource(doc);
+    DOMResult result = new DOMResult();
+    tx.transform(source, result);
+    return (Document) result.getNode();
+  }
+
+  @Override
+  public int getInt(ConfLevel level, String tag, int def) {
+    return getInt(prefixes.get(level) + tag, def);
+  }
+
+  @Override
+  public boolean getBool(ConfLevel level, String tag, boolean defValue) {
+    return getBool(prefixes.get(level) + tag, defValue);
+  }
+
+  @Override
+  public String get(ConfLevel level, String tag, String def) {
+    return get(prefixes.get(level) + tag, def);
+  }
+
+  public ShardHandlerFactory initShardHandler() {
+    PluginInfo info = null;
+    Node shfn = getNode("solr/cores/shardHandlerFactory", false);
+
+    if (shfn != null) {
+      info = new PluginInfo(shfn, "shardHandlerFactory", false, true);
+    } else {
+      Map m = new HashMap();
+      m.put("class", HttpShardHandlerFactory.class.getName());
+      info = new PluginInfo("shardHandlerFactory", m, null, Collections.<PluginInfo>emptyList());
+    }
+
+    ShardHandlerFactory fac;
+    try {
+       fac = getResourceLoader().findClass(info.className, ShardHandlerFactory.class).newInstance();
+    } catch (Exception e) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
+                              "Error instantiating shardHandlerFactory class " + info.className);
+    }
+    if (fac instanceof PluginInfoInitialized) {
+      ((PluginInfoInitialized) fac).init(info);
+    }
+    return fac;
+  }
+
+  @Override
+  public Properties getSolrProperties(ConfigSolr cfg, String context) {
+    try {
+      return readProperties(((NodeList) evaluate(
+          context, XPathConstants.NODESET)).item(0));
+    } catch (Throwable e) {
+      SolrException.log(log, null, e);
+    }
+    return null;
+
+  }
+
+  Properties readProperties(Node node) throws XPathExpressionException {
+    XPath xpath = getXPath();
+    NodeList props = (NodeList) xpath.evaluate("property", node, XPathConstants.NODESET);
+    Properties properties = new Properties();
+    for (int i = 0; i < props.getLength(); i++) {
+      Node prop = props.item(i);
+      properties.setProperty(DOMUtil.getAttr(prop, "name"), DOMUtil.getAttr(prop, "value"));
+    }
+    return properties;
+  }
+
+  @Override
+  public Map<String, String> readCoreAttributes(String coreName) {
+    Map<String, String> attrs = new HashMap<String, String>();
+
+    if (isAutoDiscover) {
+      return attrs; // this is a no-op.... intentionally
+    }
+    synchronized (coreNodes) {
+      for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
+        Node node = coreNodes.item(idx);
+        if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
+          NamedNodeMap attributes = node.getAttributes();
+          for (int i = 0; i < attributes.getLength(); i++) {
+            Node attribute = attributes.item(i);
+            String val = attribute.getNodeValue();
+            if (CoreDescriptor.CORE_DATADIR.equals(attribute.getNodeName()) ||
+                CoreDescriptor.CORE_INSTDIR.equals(attribute.getNodeName())) {
+              if (val.indexOf('$') == -1) {
+                val = (val != null && !val.endsWith("/")) ? val + '/' : val;
+              }
+            }
+            attrs.put(attribute.getNodeName(), val);
+          }
+          return attrs;
+        }
+      }
+    }
+    return attrs;
+  }
+
+  // Basic recursive tree walking, looking for "core.properties" files. Once one is found, we'll stop going any
+  // deeper in the tree.
+  //
+  // @param file - the directory we're to either read the properties file from or recurse into.
+  private void walkFromHere(File file, CoreContainer container) throws IOException {
+    log.info("Looking for cores in " + file.getAbsolutePath());
+    for (File childFile : file.listFiles()) {
+      // This is a little tricky, we are asking if core.properties exists in a child directory of the directory passed
+      // in. In other words we're looking for core.properties in the grandchild directories of the parameter passed
+      // in. That allows us to gracefully top recursing deep but continue looking wide.
+      File propFile = new File(childFile, CORE_PROP_FILE);
+      if (propFile.exists()) { // Stop looking after processing this file!
+        log.info("Discovered properties file {}, adding to cores", propFile.getAbsolutePath());
+        Properties propsOrig = new Properties();
+        InputStream is = new FileInputStream(propFile);
+        try {
+          propsOrig.load(is);
+        } finally {
+          IOUtils.closeQuietly(is);
+        }
+
+        Properties props = new Properties();
+        for (String prop : propsOrig.stringPropertyNames()) {
+          props.put(prop, PropertiesUtil.substituteProperty(propsOrig.getProperty(prop), null));
+        }
+
+        if (props.getProperty(CoreDescriptor.CORE_INSTDIR) == null) {
+          props.setProperty(CoreDescriptor.CORE_INSTDIR, childFile.getPath());
+        }
+
+        if (props.getProperty(CoreDescriptor.CORE_NAME) == null) {
+          // Should default to this directory
+          props.setProperty(CoreDescriptor.CORE_NAME, childFile.getName());
+        }
+        CoreDescriptor desc = new CoreDescriptor(container, props);
+        CoreDescriptorPlus plus = new CoreDescriptorPlus(propFile.getAbsolutePath(), desc, propsOrig);
+        coreDescriptorPlusMap.put(desc.getName(), plus);
+        continue; // Go on to the sibling directory
+      }
+      if (childFile.isDirectory()) {
+        walkFromHere(childFile, container);
+      }
+    }
+  }
+
+  public IndexSchema getSchemaFromZk(ZkController zkController, String zkConfigName, String schemaName,
+                                     SolrConfig config)
+      throws KeeperException, InterruptedException {
+    byte[] configBytes = zkController.getConfigFileData(zkConfigName, schemaName);
+    InputSource is = new InputSource(new ByteArrayInputStream(configBytes));
+    is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(schemaName));
+    IndexSchema schema = new IndexSchema(config, schemaName, is);
+    return schema;
+  }
+
+  @Override
+  public SolrConfig getSolrConfigFromZk(ZkController zkController, String zkConfigName, String solrConfigFileName,
+                                        SolrResourceLoader resourceLoader) {
+    SolrConfig cfg = null;
+    try {
+      byte[] config = zkController.getConfigFileData(zkConfigName, solrConfigFileName);
+      InputSource is = new InputSource(new ByteArrayInputStream(config));
+      is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(solrConfigFileName));
+      cfg = solrConfigFileName == null ? new SolrConfig(
+          resourceLoader, SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(
+          resourceLoader, solrConfigFileName, is);
+    } catch (Exception e) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
+          "getSolrConfigFromZK failed for " + zkConfigName + " " + solrConfigFileName, e);
+    }
+    return cfg;
+  }
+
+  static List<SolrXMLSerializer.SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrXMLSerializer.SolrCoreXMLDef>();
+  // Do this when re-using a ConfigSolrXml.
+
+  // These two methods are part of SOLR-4196 and are awkward, should go away with 5.0
+  @Override
+  public void initPersist() {
+    initPersistStatic();
+  }
+
+  public static void initPersistStatic() {
+    solrCoreXMLDefs = new ArrayList<SolrXMLSerializer.SolrCoreXMLDef>();
+    solrXMLSerializer = new SolrXMLSerializer();
+  }
+
+  @Override
+  public void addPersistCore(String coreName, Properties attribs, Map<String, String> props) {
+    addPersistCore(attribs, props);
+  }
+
+  static void addPersistCore(Properties props, Map<String, String> attribs) {
+    SolrXMLSerializer.SolrCoreXMLDef solrCoreXMLDef = new SolrXMLSerializer.SolrCoreXMLDef();
+    solrCoreXMLDef.coreAttribs = attribs;
+    solrCoreXMLDef.coreProperties = props;
+    solrCoreXMLDefs.add(solrCoreXMLDef);
+  }
+
+  private static SolrXMLSerializer solrXMLSerializer = new SolrXMLSerializer();
+
+  @Override
+  public void addPersistAllCores(Properties containerProperties, Map<String, String> rootSolrAttribs, Map<String, String> coresAttribs,
+                                 File file) {
+    addPersistAllCoresStatic(containerProperties, rootSolrAttribs, coresAttribs, file);
+  }
+
+  // Fortunately, we don't iterate over these too often, so the waste is probably tolerable.
+
+  @Override
+  public String getCoreNameFromOrig(String origCoreName, SolrResourceLoader loader, String coreName) {
+
+    if (isAutoDiscover) {
+      // first look for an exact match
+      for (Map.Entry<String, CoreDescriptorPlus> ent : coreDescriptorPlusMap.entrySet()) {
+
+        String name = ent.getValue().getCoreDescriptor().getProperty(CoreDescriptor.CORE_NAME, null);
+        if (origCoreName.equals(name)) {
+          if (coreName.equals(origCoreName)) {
+            return name;
+          }
+          return coreName;
+        }
+      }
+
+      for (Map.Entry<String, CoreDescriptorPlus> ent : coreDescriptorPlusMap.entrySet()) {
+        String name = ent.getValue().getCoreDescriptor().getProperty(CoreDescriptor.CORE_NAME, null);
+        // see if we match with substitution
+        if (origCoreName.equals(PropertiesUtil.substituteProperty(name, loader.getCoreProperties()))) {
+          if (coreName.equals(origCoreName)) {
+            return name;
+          }
+          return coreName;
+        }
+      }
+    } else {
+      // look for an existing node
+      synchronized (coreNodes) {
+        // first look for an exact match
+        Node coreNode = null;
+        for (int i = 0; i < coreNodes.getLength(); i++) {
+          Node node = coreNodes.item(i);
+
+          String name = DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null);
+          if (origCoreName.equals(name)) {
+            if (coreName.equals(origCoreName)) {
+              return name;
+            }
+            return coreName;
+          }
+        }
+
+        if (coreNode == null) {
+          // see if we match with substitution
+          for (int i = 0; i < coreNodes.getLength(); i++) {
+            Node node = coreNodes.item(i);
+            String name = DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null);
+            if (origCoreName.equals(PropertiesUtil.substituteProperty(name,
+                loader.getCoreProperties()))) {
+              if (coreName.equals(origCoreName)) {
+                return name;
+              }
+              return coreName;
+            }
+          }
+        }
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public List<String> getAllCoreNames() {
+    List<String> ret = new ArrayList<String>();
+    if (isAutoDiscover) {
+      ret = new ArrayList<String>(coreDescriptorPlusMap.keySet());
+    } else {
+      synchronized (coreNodes) {
+        for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
+          Node node = coreNodes.item(idx);
+          ret.add(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null));
+        }
+      }
+    }
+    return ret;
+  }
+
+  @Override
+  public String getProperty(String coreName, String property, String defaultVal) {
+    if (isAutoDiscover) {
+      CoreDescriptorPlus plus = coreDescriptorPlusMap.get(coreName);
+      if (plus == null) return defaultVal;
+      CoreDescriptor desc = plus.getCoreDescriptor();
+      if (desc == null) return defaultVal;
+      return desc.getProperty(property, defaultVal);
+    } else {
+      synchronized (coreNodes) {
+        for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
+          Node node = coreNodes.item(idx);
+          if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
+            return DOMUtil.getAttr(node, property, defaultVal);
+          }
+        }
+      }
+      return defaultVal;
+    }
+  }
+
+  @Override
+  public Properties readCoreProperties(String coreName) {
+    if (isAutoDiscover) {
+      CoreDescriptorPlus plus = coreDescriptorPlusMap.get(coreName);
+      if (plus == null) return null;
+      return new Properties(plus.getCoreDescriptor().getCoreProperties());
+    } else {
+      synchronized (coreNodes) {
+        for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
+          Node node = coreNodes.item(idx);
+          if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
+            try {
+              return readProperties(node);
+            } catch (XPathExpressionException e) {
+              return null;
+            }
+          }
+        }
+      }
+    }
+    return null;
+  }
+
+  static Properties getCoreProperties(String instanceDir, CoreDescriptor dcore) {
+    String file = dcore.getPropertiesName();
+    if (file == null) file = "conf" + File.separator + "solrcore.properties";
+    File corePropsFile = new File(file);
+    if (!corePropsFile.isAbsolute()) {
+      corePropsFile = new File(instanceDir, file);
+    }
+    Properties p = dcore.getCoreProperties();
+    if (corePropsFile.exists() && corePropsFile.isFile()) {
+      p = new Properties(dcore.getCoreProperties());
+      InputStream is = null;
+      try {
+        is = new FileInputStream(corePropsFile);
+        p.load(is);
+      } catch (IOException e) {
+        log.warn("Error loading properties ", e);
+      } finally {
+        IOUtils.closeQuietly(is);
+      }
+    }
+    return p;
+  }
+
+
+  static void addPersistAllCoresStatic(Properties containerProperties, Map<String, String> rootSolrAttribs, Map<String, String> coresAttribs,
+                                       File file) {
+    SolrXMLSerializer.SolrXMLDef solrXMLDef = new SolrXMLSerializer.SolrXMLDef();
+    solrXMLDef.coresDefs = solrCoreXMLDefs;
+    solrXMLDef.containerProperties = containerProperties;
+    solrXMLDef.solrAttribs = rootSolrAttribs;
+    solrXMLDef.coresAttribs = coresAttribs;
+    solrXMLSerializer.persistFile(file, solrXMLDef);
+
+  }
+
+  static final String DEF_SOLR_XML = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
+      + "<solr persistent=\"false\">\n"
+      + "  <cores adminPath=\"/admin/cores\" defaultCoreName=\""
+      + CoreContainer.DEFAULT_DEFAULT_CORE_NAME
+      + "\""
+      + " host=\"${host:}\" hostPort=\"${hostPort:}\" hostContext=\"${hostContext:}\" zkClientTimeout=\"${zkClientTimeout:15000}\""
+      + ">\n"
+      + "    <core name=\""
+      + CoreContainer.DEFAULT_DEFAULT_CORE_NAME
+      + "\" shard=\"${shard:}\" collection=\"${collection:}\" instanceDir=\"collection1\" />\n"
+      + "  </cores>\n" + "</solr>";
+
+}
+
+// It's mightily convenient to have all of the original path names and property values when persisting cores, so
+// this little convenience class is just for that.
+// Also, let's keep track of anything we added here, especially the instance dir for persistence purposes. We don't
+// want, for instance, to persist instanceDir if it was not specified originally.
+//
+// I suspect that for persistence purposes, we may want to expand this idea to record, say, ${blah}
+class CoreDescriptorPlus {
+  private CoreDescriptor coreDescriptor;
+  private String filePath;
+  private Properties propsOrig;
+
+  CoreDescriptorPlus(String filePath, CoreDescriptor descriptor, Properties propsOrig) {
+    coreDescriptor = descriptor;
+    this.filePath = filePath;
+    this.propsOrig = propsOrig;
+  }
+
+  CoreDescriptor getCoreDescriptor() {
+    return coreDescriptor;
+  }
+
+  String getFilePath() {
+    return filePath;
+  }
+
+  Properties getPropsOrig() {
+    return propsOrig;
+  }
+}
+
diff --git a/solr/core/src/java/org/apache/solr/core/ConfigSolrXmlBackCompat.java b/solr/core/src/java/org/apache/solr/core/ConfigSolrXmlBackCompat.java
deleted file mode 100644
index daef1d4..0000000
--- a/solr/core/src/java/org/apache/solr/core/ConfigSolrXmlBackCompat.java
+++ /dev/null
@@ -1,354 +0,0 @@
-package org.apache.solr.core;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.solr.cloud.ZkController;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.handler.component.HttpShardHandlerFactory;
-import org.apache.solr.handler.component.ShardHandlerFactory;
-import org.apache.solr.util.DOMUtil;
-import org.apache.solr.util.PropertiesUtil;
-import org.apache.solr.util.SystemIdResolver;
-import org.apache.solr.util.plugin.PluginInfoInitialized;
-import org.w3c.dom.Document;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.InputSource;
-import org.xml.sax.SAXException;
-
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMResult;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-/**
- * ConfigSolrXmlBackCompat
- * <p/>
- * This class is entirely to localize the backwards compatibility for dealing with specific issues when transitioning
- * from solr.xml to a solr.properties-based, enumeration/discovery of defined cores. See SOLR-4196 for background.
- * <p/>
- * As of Solr 5.0, solr.xml will be deprecated, use SolrProperties.
- *
- * @since solr 4.2
- * @deprecated use {@link org.apache.solr.core.SolrProperties} instead
- */
-@Deprecated
-
-public class ConfigSolrXmlBackCompat extends Config implements ConfigSolr {
-
-  private static Map<ConfLevel, String> prefixes;
-  private NodeList coreNodes = null;
-
-  static {
-    prefixes = new HashMap<ConfLevel, String>();
-
-    prefixes.put(ConfLevel.SOLR, "solr/@");
-    prefixes.put(ConfLevel.SOLR_CORES, "solr/cores/@");
-    prefixes.put(ConfLevel.SOLR_CORES_CORE, "solr/cores/core/@");
-    prefixes.put(ConfLevel.SOLR_LOGGING, "solr/logging/@");
-    prefixes.put(ConfLevel.SOLR_LOGGING_WATCHER, "solr/logging/watcher/@");
-  }
-
-  public ConfigSolrXmlBackCompat(SolrResourceLoader loader, String name, InputStream is, String prefix,
-                                 boolean subProps) throws ParserConfigurationException, IOException, SAXException {
-    super(loader, name, new InputSource(is), prefix, subProps);
-    coreNodes = (NodeList) evaluate("solr/cores/core",
-        XPathConstants.NODESET);
-
-  }
-
-
-  public ConfigSolrXmlBackCompat(SolrResourceLoader loader, Config cfg) throws TransformerException {
-    super(loader, null, copyDoc(cfg.getDocument())); // Mimics a call from CoreContainer.
-    coreNodes = (NodeList) evaluate("solr/cores/core",
-        XPathConstants.NODESET);
-
-  }
-
-  public static Document copyDoc(Document doc) throws TransformerException {
-    TransformerFactory tfactory = TransformerFactory.newInstance();
-    Transformer tx = tfactory.newTransformer();
-    DOMSource source = new DOMSource(doc);
-    DOMResult result = new DOMResult();
-    tx.transform(source, result);
-    return (Document) result.getNode();
-  }
-
-  @Override
-  public int getInt(ConfLevel level, String tag, int def) {
-    return getInt(prefixes.get(level) + tag, def);
-  }
-
-  @Override
-  public boolean getBool(ConfLevel level, String tag, boolean defValue) {
-    return getBool(prefixes.get(level) + tag, defValue);
-  }
-
-  @Override
-  public String get(ConfLevel level, String tag, String def) {
-    return get(prefixes.get(level) + tag, def);
-  }
-
-  public ShardHandlerFactory initShardHandler() {
-    PluginInfo info = null;
-    Node shfn = getNode("solr/cores/shardHandlerFactory", false);
-
-    if (shfn != null) {
-      info = new PluginInfo(shfn, "shardHandlerFactory", false, true);
-    } else {
-      Map m = new HashMap();
-      m.put("class", HttpShardHandlerFactory.class.getName());
-      info = new PluginInfo("shardHandlerFactory", m, null, Collections.<PluginInfo>emptyList());
-    }
-
-    ShardHandlerFactory fac;
-    try {
-       fac = getResourceLoader().findClass(info.className, ShardHandlerFactory.class).newInstance();
-    } catch (Exception e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-                              "Error instantiating shardHandlerFactory class " + info.className);
-    }
-    if (fac instanceof PluginInfoInitialized) {
-      ((PluginInfoInitialized) fac).init(info);
-    }
-    return fac;
-  }
-
-  @Override
-  public Properties getSolrProperties(ConfigSolr cfg, String context) {
-    try {
-      return readProperties(((NodeList) evaluate(
-          context, XPathConstants.NODESET)).item(0));
-    } catch (Throwable e) {
-      SolrException.log(log, null, e);
-    }
-    return null;
-
-  }
-
-  Properties readProperties(Node node) throws XPathExpressionException {
-    XPath xpath = getXPath();
-    NodeList props = (NodeList) xpath.evaluate("property", node, XPathConstants.NODESET);
-    Properties properties = new Properties();
-    for (int i = 0; i < props.getLength(); i++) {
-      Node prop = props.item(i);
-      properties.setProperty(DOMUtil.getAttr(prop, "name"), DOMUtil.getAttr(prop, "value"));
-    }
-    return properties;
-  }
-
-  @Override
-  public Map<String, String> readCoreAttributes(String coreName) {
-    Map<String, String> attrs = new HashMap<String, String>();
-
-    synchronized (coreNodes) {
-      for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
-        Node node = coreNodes.item(idx);
-        if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
-          NamedNodeMap attributes = node.getAttributes();
-          for (int i = 0; i < attributes.getLength(); i++) {
-            Node attribute = attributes.item(i);
-            String val = attribute.getNodeValue();
-            if (CoreDescriptor.CORE_DATADIR.equals(attribute.getNodeName()) ||
-                CoreDescriptor.CORE_INSTDIR.equals(attribute.getNodeName())) {
-              if (val.indexOf('$') == -1) {
-                val = (val != null && !val.endsWith("/"))? val + '/' : val;
-              }
-            }
-            attrs.put(attribute.getNodeName(), val);
-          }
-          return attrs;
-        }
-      }
-    }
-    return attrs;
-  }
-
-  @Override
-  public SolrConfig getSolrConfigFromZk(ZkController zkController, String zkConfigName, String solrConfigFileName,
-                                        SolrResourceLoader resourceLoader) {
-    SolrConfig cfg = null;
-    try {
-      byte[] config = zkController.getConfigFileData(zkConfigName, solrConfigFileName);
-      InputSource is = new InputSource(new ByteArrayInputStream(config));
-      is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(solrConfigFileName));
-      cfg = solrConfigFileName == null ? new SolrConfig(
-          resourceLoader, SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(
-          resourceLoader, solrConfigFileName, is);
-    } catch (Exception e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-          "getSolrConfigFromZK failed for " + zkConfigName + " " + solrConfigFileName, e);
-    }
-    return cfg;
-  }
-
-  static List<SolrXMLSerializer.SolrCoreXMLDef> solrCoreXMLDefs = new ArrayList<SolrXMLSerializer.SolrCoreXMLDef>();
-  // Do this when re-using a ConfigSolrXmlBackCompat.
-
-  // These two methods are part of SOLR-4196 and are awkward, should go away with 5.0
-  @Override
-  public void initPersist() {
-    initPersistStatic();
-  }
-
-  public static void initPersistStatic() {
-    solrCoreXMLDefs = new ArrayList<SolrXMLSerializer.SolrCoreXMLDef>();
-    solrXMLSerializer = new SolrXMLSerializer();
-  }
-
-  @Override
-  public void addPersistCore(String coreName, Properties attribs, Map<String, String> props) {
-    addPersistCore(attribs, props);
-  }
-
-  static void addPersistCore(Properties props, Map<String, String> attribs) {
-    SolrXMLSerializer.SolrCoreXMLDef solrCoreXMLDef = new SolrXMLSerializer.SolrCoreXMLDef();
-    solrCoreXMLDef.coreAttribs = attribs;
-    solrCoreXMLDef.coreProperties = props;
-    solrCoreXMLDefs.add(solrCoreXMLDef);
-  }
-
-  private static SolrXMLSerializer solrXMLSerializer = new SolrXMLSerializer();
-
-  @Override
-  public void addPersistAllCores(Properties containerProperties, Map<String, String> rootSolrAttribs, Map<String, String> coresAttribs,
-                                 File file) {
-    addPersistAllCoresStatic(containerProperties, rootSolrAttribs, coresAttribs, file);
-  }
-
-  // Fortunately, we don't iterate over these too often, so the waste is probably tolerable.
-
-  @Override
-  public String getCoreNameFromOrig(String origCoreName, SolrResourceLoader loader, String coreName) {
-
-    // look for an existing node
-    synchronized (coreNodes) {
-      // first look for an exact match
-      Node coreNode = null;
-      for (int i = 0; i < coreNodes.getLength(); i++) {
-        Node node = coreNodes.item(i);
-
-        String name = DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null);
-        if (origCoreName.equals(name)) {
-          if (coreName.equals(origCoreName)) {
-            return name;
-          }
-          return coreName;
-        }
-      }
-
-      if (coreNode == null) {
-        // see if we match with substitution
-        for (int i = 0; i < coreNodes.getLength(); i++) {
-          Node node = coreNodes.item(i);
-          String name = DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null);
-          if (origCoreName.equals(PropertiesUtil.substituteProperty(name,
-              loader.getCoreProperties()))) {
-            if (coreName.equals(origCoreName)) {
-              return name;
-            }
-            return coreName;
-          }
-        }
-      }
-    }
-    return null;
-  }
-
-  @Override
-  public List<String> getAllCoreNames() {
-    List<String> ret = new ArrayList<String>();
-    synchronized (coreNodes) {
-      for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
-        Node node = coreNodes.item(idx);
-        ret.add(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null));
-      }
-    }
-    return ret;
-  }
-
-  @Override
-  public String getProperty(String coreName, String property, String defaultVal) {
-    synchronized (coreNodes) {
-      for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
-        Node node = coreNodes.item(idx);
-        if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
-          return DOMUtil.getAttr(node, property, defaultVal);
-        }
-      }
-    }
-    return defaultVal;
-  }
-
-  @Override
-  public Properties readCoreProperties(String coreName) {
-    synchronized (coreNodes) {
-      for (int idx = 0; idx < coreNodes.getLength(); ++idx) {
-        Node node = coreNodes.item(idx);
-        if (coreName.equals(DOMUtil.getAttr(node, CoreDescriptor.CORE_NAME, null))) {
-          try {
-            return readProperties(node);
-          } catch (XPathExpressionException e) {
-            return null;
-          }
-        }
-      }
-    }
-    return null;
-  }
-
-  static void addPersistAllCoresStatic(Properties containerProperties, Map<String, String> rootSolrAttribs, Map<String, String> coresAttribs,
-                                       File file) {
-    SolrXMLSerializer.SolrXMLDef solrXMLDef = new SolrXMLSerializer.SolrXMLDef();
-    solrXMLDef.coresDefs = solrCoreXMLDefs;
-    solrXMLDef.containerProperties = containerProperties;
-    solrXMLDef.solrAttribs = rootSolrAttribs;
-    solrXMLDef.coresAttribs = coresAttribs;
-    solrXMLSerializer.persistFile(file, solrXMLDef);
-
-  }
-
-  static final String DEF_SOLR_XML = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
-      + "<solr persistent=\"false\">\n"
-      + "  <cores adminPath=\"/admin/cores\" defaultCoreName=\""
-      + CoreContainer.DEFAULT_DEFAULT_CORE_NAME
-      + "\""
-      + " host=\"${host:}\" hostPort=\"${hostPort:}\" hostContext=\"${hostContext:}\" zkClientTimeout=\"${zkClientTimeout:15000}\""
-      + ">\n"
-      + "    <core name=\""
-      + CoreContainer.DEFAULT_DEFAULT_CORE_NAME
-      + "\" shard=\"${shard:}\" collection=\"${collection:}\" instanceDir=\"collection1\" />\n"
-      + "  </cores>\n" + "</solr>";
-
-}
diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
index 3feb6c4..6fbd760 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java
@@ -131,11 +131,11 @@ public class CoreContainer
   private ShardHandlerFactory shardHandlerFactory;
   protected LogWatcher logging = null;
   private String zkHost;
+  private int transientCacheSize = Integer.MAX_VALUE;
 
   private String leaderVoteWait = LEADER_VOTE_WAIT;
   private int distribUpdateConnTimeout = 0;
   private int distribUpdateSoTimeout = 0;
-  protected int transientCacheSize = Integer.MAX_VALUE; // Use as a flag too, if transientCacheSize set in solr.xml this will be changed
   private int coreLoadThreads;
   private CloserThread backgroundCloser = null;
   
@@ -145,7 +145,7 @@ public class CoreContainer
 
   /**
    * Deprecated
-   * @deprecated use the single arg constructure with locateSolrHome()
+   * @deprecated use the single arg constructor with locateSolrHome()
    * @see SolrResourceLoader#locateSolrHome
    */
   @Deprecated
@@ -321,19 +321,14 @@ public class CoreContainer
       log.info("looking for solr config file: " + fconf.getAbsolutePath());
       cores = new CoreContainer(solrHome);
 
-      if (! fconf.exists()) {
-        if (StringUtils.isBlank(containerConfigFilename) || containerConfigFilename.endsWith(".xml")) {
-          fconf = new File(solrHome, SolrProperties.SOLR_PROPERTIES_FILE);
-        }
-      }
-      // Either we have a config file or not. If it ends in .properties, assume new-style.
+      // Either we have a config file or not.
       
       if (fconf.exists()) {
         cores.load(solrHome, fconf);
       } else {
-        log.info("no solr.xml or solr.properties file found - using default old-style solr.xml");
+        log.info("no solr.xml found. using default old-style solr.xml");
         try {
-          cores.load(solrHome, new ByteArrayInputStream(ConfigSolrXmlBackCompat.DEF_SOLR_XML.getBytes("UTF-8")), true, null);
+          cores.load(solrHome, new ByteArrayInputStream(ConfigSolrXml.DEF_SOLR_XML.getBytes("UTF-8")), null);
         } catch (Exception e) {
           throw new SolrException(ErrorCode.SERVER_ERROR,
               "CoreContainer.Initialize failed when trying to load default solr.xml file", e);
@@ -361,7 +356,7 @@ public class CoreContainer
     this.configFile = configFile;
     InputStream in = new FileInputStream(configFile);
     try {
-      this.load(dir, in, configFile.getName().endsWith(".xml"),  configFile.getName());
+      this.load(dir, in,  configFile.getName());
     } finally {
       IOUtils.closeQuietly(in);
     }
@@ -375,7 +370,7 @@ public class CoreContainer
    */
 
   // Let's keep this ugly boolean out of public circulation.
-  protected void load(String dir, InputStream is, boolean isXmlFile, String fileName)  {
+  protected void load(String dir, InputStream is, String fileName)  {
     ThreadPoolExecutor coreLoadExecutor = null;
     if (null == dir) {
       // don't rely on SolrResourceLoader(), determine explicitly first
@@ -389,16 +384,9 @@ public class CoreContainer
     ConfigSolr cfg;
     
     // keep orig config for persist to consult
-    //TODO 5.0: Remove this confusing junk, the properties file is so fast to read that there's no good reason
-    //          to add this stuff. Furthermore, it would be good to persist comments when saving.....
     try {
-      if (isXmlFile) {
-        cfg = new ConfigSolrXmlBackCompat(loader, null, is, null, false);
-        this.cfg = new ConfigSolrXmlBackCompat(loader, (ConfigSolrXmlBackCompat)cfg);
-      } else {
-        cfg = new SolrProperties(this, loader, is, fileName);
-        this.cfg = new SolrProperties(this, loader, (SolrProperties)cfg);
-      }
+      cfg = new ConfigSolrXml(loader, null, is, null, false, this);
+      this.cfg = new ConfigSolrXml(loader, (ConfigSolrXml) cfg, this);
     } catch (Exception e) {
       throw new SolrException(ErrorCode.SERVER_ERROR, "", e);
     }
@@ -479,13 +467,15 @@ public class CoreContainer
     host = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, "host", null);
     
     leaderVoteWait = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, "leaderVoteWait", LEADER_VOTE_WAIT);
-    
+
     if (shareSchema) {
       indexSchemaCache = new ConcurrentHashMap<String,IndexSchema>();
     }
     adminHandler = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, "adminHandler", null);
     managementPath = cfg.get(ConfigSolr.ConfLevel.SOLR_CORES, "managementPath", null);
-    
+
+    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, "transientCacheSize", Integer.MAX_VALUE);
+
     zkClientTimeout = Integer.parseInt(System.getProperty("zkClientTimeout",
         Integer.toString(zkClientTimeout)));
     initZooKeeper(zkHost, zkClientTimeout);
@@ -886,7 +876,8 @@ public class CoreContainer
         throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
             "Could not find config name for collection:" + collection);
       }
-      solrLoader = new ZkSolrResourceLoader(instanceDir, zkConfigName, libLoader, SolrProperties.getCoreProperties(instanceDir, dcore), zkController);
+      solrLoader = new ZkSolrResourceLoader(instanceDir, zkConfigName, libLoader,
+          ConfigSolrXml.getCoreProperties(instanceDir, dcore), zkController);
       config = getSolrConfigFromZk(zkConfigName, dcore.getConfigName(), solrLoader);
       schema = IndexSchemaFactory.buildIndexSchema(dcore.getSchemaName(), config);
       return new SolrCore(dcore.getName(), null, config, schema, dcore);
@@ -909,7 +900,7 @@ public class CoreContainer
     SolrResourceLoader solrLoader = null;
 
     SolrConfig config = null;
-    solrLoader = new SolrResourceLoader(instanceDir, libLoader, SolrProperties.getCoreProperties(instanceDir, dcore));
+    solrLoader = new SolrResourceLoader(instanceDir, libLoader, ConfigSolrXml.getCoreProperties(instanceDir, dcore));
     try {
       config = new SolrConfig(solrLoader, dcore.getConfigName(), null);
     } catch (Exception e) {
@@ -1066,7 +1057,7 @@ public class CoreContainer
                  cd.getName(), instanceDir.getAbsolutePath());
         SolrResourceLoader solrLoader;
         if(zkController == null) {
-          solrLoader = new SolrResourceLoader(instanceDir.getAbsolutePath(), libLoader, SolrProperties.getCoreProperties(instanceDir.getAbsolutePath(), cd));
+          solrLoader = new SolrResourceLoader(instanceDir.getAbsolutePath(), libLoader, ConfigSolrXml.getCoreProperties(instanceDir.getAbsolutePath(), cd));
         } else {
           try {
             String collection = cd.getCloudDescriptor().getCollectionName();
@@ -1079,7 +1070,7 @@ public class CoreContainer
                                            "Could not find config name for collection:" + collection);
             }
             solrLoader = new ZkSolrResourceLoader(instanceDir.getAbsolutePath(), zkConfigName, libLoader,
-                SolrProperties.getCoreProperties(instanceDir.getAbsolutePath(), cd), zkController);
+                ConfigSolrXml.getCoreProperties(instanceDir.getAbsolutePath(), cd), zkController);
           } catch (KeeperException e) {
             log.error("", e);
             throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
@@ -1229,7 +1220,24 @@ public class CoreContainer
   public String getAdminPath() {
     return adminPath;
   }
-  
+
+  public String getHostPort() {
+    return hostPort;
+  }
+
+  public String getHostContext() {
+    return hostContext;
+  }
+
+  public String getHost() {
+    return host;
+  }
+
+  public int getZkClientTimeout() {
+    return zkClientTimeout;
+  }
+
+
   public void setAdminPath(String adminPath) {
       this.adminPath = adminPath;
   }
@@ -1308,10 +1316,6 @@ public class CoreContainer
       coresAttribs.put("defaultCoreName", defaultCoreName);
     }
 
-    if (transientCacheSize != Integer.MAX_VALUE) {
-      coresAttribs.put("transientCacheSize", Integer.toString(transientCacheSize));
-    }
-    
     addCoresAttrib(coresAttribs, "hostPort", this.hostPort, DEFAULT_HOST_PORT);
     addCoresAttrib(coresAttribs, "zkClientTimeout",
         intToString(this.zkClientTimeout),
@@ -1319,6 +1323,10 @@ public class CoreContainer
     addCoresAttrib(coresAttribs, "hostContext", this.hostContext, DEFAULT_HOST_CONTEXT);
     addCoresAttrib(coresAttribs, "leaderVoteWait", this.leaderVoteWait, LEADER_VOTE_WAIT);
     addCoresAttrib(coresAttribs, "coreLoadThreads", Integer.toString(this.coreLoadThreads), Integer.toString(CORE_LOAD_THREADS));
+    if (transientCacheSize != Integer.MAX_VALUE) { // This test
+    // is a consequence of testing. I really hate it.
+      addCoresAttrib(coresAttribs, "transientCacheSize", Integer.toString(this.transientCacheSize), Integer.toString(Integer.MAX_VALUE));
+    }
 
     coreMaps.persistCores(cfg, containerProperties, rootSolrAttribs, coresAttribs, file, configFile, loader);
 
@@ -1402,8 +1410,6 @@ class CoreMaps {
 
   private final Map<String, CoreDescriptor> dynamicDescriptors = new LinkedHashMap<String, CoreDescriptor>();
 
-  private int transientCacheSize = Integer.MAX_VALUE;
-
   private Map<SolrCore, String> coreToOrigName = new ConcurrentHashMap<SolrCore, String>();
 
   private final CoreContainer container;
@@ -1423,7 +1429,7 @@ class CoreMaps {
   // Trivial helper method for load, note it implements LRU on transient cores. Also note, if
   // there is no setting for max size, nothing is done and all cores go in the regular "cores" list
   protected void allocateLazyCores(final ConfigSolr cfg, final SolrResourceLoader loader) {
-    transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, "transientCacheSize", Integer.MAX_VALUE);
+    final int transientCacheSize = cfg.getInt(ConfigSolr.ConfLevel.SOLR_CORES, "transientCacheSize", Integer.MAX_VALUE);
     if (transientCacheSize != Integer.MAX_VALUE) {
       CoreContainer.log.info("Allocating transient cache for {} transient cores", transientCacheSize);
       transientCores = new LinkedHashMap<String, SolrCore>(transientCacheSize, 0.75f, true) {
@@ -1535,7 +1541,7 @@ class CoreMaps {
     CoreContainer.log.info("Opening transient core {}", name);
     synchronized (locker) {
       retCore = transientCores.put(name, core);
-  }
+    }
     return retCore;
   }
 
@@ -1745,10 +1751,10 @@ class CoreMaps {
     //
     synchronized (locker) {
       if (cfg == null) {
-        ConfigSolrXmlBackCompat.initPersistStatic();
+        ConfigSolrXml.initPersistStatic();
         persistCores(cfg, cores, loader);
         persistCores(cfg, transientCores, loader);
-        ConfigSolrXmlBackCompat.addPersistAllCoresStatic(containerProperties, rootSolrAttribs, coresAttribs,
+        ConfigSolrXml.addPersistAllCoresStatic(containerProperties, rootSolrAttribs, coresAttribs,
             (file == null ? configFile : file));
       } else {
         cfg.initPersist();
@@ -1907,7 +1913,7 @@ class CoreMaps {
       cfg.addPersistCore(coreName, persistProps, coreAttribs);
     } else {
       // Another awkward bit for back-compat for SOLR-4196
-      ConfigSolrXmlBackCompat.addPersistCore(persistProps, coreAttribs);
+      ConfigSolrXml.addPersistCore(persistProps, coreAttribs);
     }
   }
 
diff --git a/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java b/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
index f2648d2..0ded722 100644
--- a/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
+++ b/solr/core/src/java/org/apache/solr/core/CoreDescriptor.java
@@ -134,7 +134,11 @@ public class CoreDescriptor {
   }
 
   public Properties initImplicitProperties() {
-    Properties implicitProperties = new Properties(coreContainer.getContainerProperties());
+
+    Properties implicitProperties = new Properties();
+    if (coreContainer != null && coreContainer.getContainerProperties() != null){
+      implicitProperties.putAll(coreContainer.getContainerProperties());
+    }
     implicitProperties.setProperty("solr.core.name", getName());
     implicitProperties.setProperty("solr.core.instanceDir", getInstanceDir());
     implicitProperties.setProperty("solr.core.dataDir", getDataDir());
@@ -203,6 +207,9 @@ public class CoreDescriptor {
       return SolrResourceLoader.normalizeDir(
           SolrResourceLoader.normalizeDir(instDir));
     }
+
+    if (coreContainer == null) return null;
+
     return SolrResourceLoader.normalizeDir(coreContainer.getSolrHome() +
         SolrResourceLoader.normalizeDir(instDir));
   }
diff --git a/solr/core/src/java/org/apache/solr/core/SolrProperties.java b/solr/core/src/java/org/apache/solr/core/SolrProperties.java
deleted file mode 100644
index aef86f4..0000000
--- a/solr/core/src/java/org/apache/solr/core/SolrProperties.java
+++ /dev/null
@@ -1,587 +0,0 @@
-package org.apache.solr.core;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang.StringUtils;
-import org.apache.solr.cloud.ZkController;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.handler.component.HttpShardHandlerFactory;
-import org.apache.solr.handler.component.ShardHandlerFactory;
-import org.apache.solr.util.PropertiesUtil;
-import org.apache.solr.util.SystemIdResolver;
-import org.apache.solr.util.plugin.PluginInfoInitialized;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.xml.sax.InputSource;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-/**
- * This is the new way of dealing with solr properties replacing solr.xml. This is simply a high-level set of
- * properties. Cores are no longer defined in the solr.xml file, they are discovered by enumerating all of the
- * directories under the base path and creating cores as necessary.
- *
- * @since Solr 4.2
- */
-public class SolrProperties implements ConfigSolr {
-  public final static String SOLR_PROPERTIES_FILE = "solr.properties";
-  public final static String SOLR_XML_FILE = "solr.xml";
-  final static String CORE_PROP_FILE = "core.properties";
-
-  private final static String SHARD_HANDLER_FACTORY = "shardHandlerFactory";
-  private final static String SHARD_HANDLER_NAME = SHARD_HANDLER_FACTORY + ".name";
-  private final static String SHARD_HANDLER_CLASS = SHARD_HANDLER_FACTORY + ".class";
-
-  public static final Logger log = LoggerFactory.getLogger(SolrProperties.class);
-
-  protected final CoreContainer container;
-  protected Properties solrProperties = new Properties();
-  protected final Properties origsolrprops = new Properties();
-  protected String name;
-  protected SolrResourceLoader loader;
-
-  private final Map<String, CoreDescriptorPlus> coreDescriptorPlusMap = new HashMap<String, CoreDescriptorPlus>();
-
-  private static Map<ConfLevel, String> prefixesprefixes;
-
-  static {
-    prefixesprefixes = new HashMap<ConfLevel, String>();
-
-    prefixesprefixes.put(ConfLevel.SOLR_CORES, "cores.");
-    prefixesprefixes.put(ConfLevel.SOLR_LOGGING, "logging.");
-    prefixesprefixes.put(ConfLevel.SOLR_LOGGING_WATCHER, "logging.watcher.");
-
-  }
-
-
-  /**
-   * Create a SolrProperties object given just the resource loader
-   *
-   * @param container - the container for this Solr instance. There should be one and only one...
-   * @param loader    - Solr resource loader
-   * @param solrCfg   - a config file whose values will be transferred to the properties object that can be changed
-   * @throws IOException - It's possible to walk a very deep tree, if that process goes awry, or if reading any
-   *                     of the files found doesn't work, you'll get an IO exception
-   */
-  SolrProperties(CoreContainer container, SolrResourceLoader loader, SolrProperties solrCfg) throws IOException {
-    origsolrprops.putAll(solrCfg.getOriginalProperties());
-    this.loader = loader;
-    this.container = container;
-    init(solrCfg.name);
-  }
-
-  /**
-   * Create a SolrProperties object from an opened input stream, useful for creating defaults
-   *
-   * @param container - the container for this Solr instance. There should be one and only one...
-   * @param loader    - Solr resource loader
-   * @param is        - Input stream for loading properties.
-   * @param fileName  - the name for this properties object.
-   * @throws IOException - It's possible to walk a very deep tree, if that process goes awry, or if reading any
-   *                     of the files found doesn't work, you'll get an IO exception
-   */
-  public SolrProperties(CoreContainer container, SolrResourceLoader loader, InputStream is, String fileName) throws IOException {
-    origsolrprops.load(is);
-    this.loader = loader;
-    this.container = container;
-    init(fileName);
-  }
-
-  //Just localize the common constructor operations
-  private void init(String name) throws IOException {
-    this.name = name;
-    for (String s : origsolrprops.stringPropertyNames()) {
-      solrProperties.put(s, System.getProperty(s, origsolrprops.getProperty(s)));
-    }
-    synchronized (coreDescriptorPlusMap) {
-      walkFromHere(new File(container.getSolrHome()), container);
-    }
-  }
-
-  // Just localizes default substitution and the ability to log an error if the value isn't present.
-  private String getVal(String path, boolean errIfMissing, String defVal) {
-    String val = solrProperties.getProperty(path, defVal);
-
-    if (StringUtils.isNotBlank(val)) {
-      log.debug(name + ' ' + path + val);
-      return val;
-    }
-
-    if (!errIfMissing) {
-      log.debug(name + "missing optional " + path);
-      return null;
-    }
-
-    throw new RuntimeException(name + " missing " + path);
-  }
-
-  /**
-   * Get a property and convert it to a boolean value. Does not log a message if the value is absent
-   *
-   * @param prop     - name of the property to fetch
-   * @param defValue - value to return if the property is absent
-   * @return property value or default if property is not present.
-   */
-  public boolean getBool(String prop, boolean defValue) {
-    String def = defValue ? "true" : "false";
-    String val = getVal(prop, false, def);
-    return (StringUtils.equalsIgnoreCase(val, "true"));
-  }
-
-  /**
-   * Fetch a string value, for the given property. Does not log a message if the valued is absent.
-   *
-   * @param prop - the property name to fetch
-   * @param def  - the default value to return if not present
-   * @return - the fetched property or the default value if the property is absent
-   */
-  public String get(String prop, String def) {
-    String val = getVal(prop, false, def);
-    if (val == null || val.length() == 0) {
-      return def;
-    }
-    return val;
-  }
-
-  /**
-   * Fetch the string value of the property. May log a message and returns null if absent
-   *
-   * @param prop         - the name of the property to fetch
-   * @param errIfMissing - if true, log a message that the property is not present
-   * @return - the property value or null if absent
-   */
-  public String getVal(String prop, boolean errIfMissing) {
-    return getVal(prop, errIfMissing, null);
-  }
-
-  /**
-   * Returns a property as an integer
-   *
-   * @param prop   - the name of the property to fetch
-   * @param defVal - the value to return if the property is missing
-   * @return - the fetch property as an int or the def value if absent
-   */
-  public int getInt(String prop, int defVal) {
-    String val = getVal(prop, false, Integer.toString(defVal));
-    return Integer.parseInt(val);
-  }
-
-  @Override
-  public int getInt(ConfLevel level, String tag, int def) {
-    return getInt(prefixesprefixes.get(level) + tag, def);
-  }
-
-  @Override
-  public boolean getBool(ConfLevel level, String tag, boolean defValue) {
-    return getBool(prefixesprefixes.get(level) + tag, defValue);
-  }
-
-  @Override
-  public String get(ConfLevel level, String tag, String def) {
-    return get(prefixesprefixes.get(level) + tag, def);
-  }
-
-  /**
-   * For all values in the properties structure, find if any system properties are defined and substitute them.
-   */
-  public void substituteProperties() {
-    for (String prop : solrProperties.stringPropertyNames()) {
-      String subProp = PropertiesUtil.substituteProperty(solrProperties.getProperty(prop), solrProperties);
-      if (subProp != null && !subProp.equals(solrProperties.getProperty(prop))) {
-        solrProperties.put(prop, subProp);
-      }
-    }
-  }
-
-  /**
-   * Fetches the properties as originally read from the properties file without any system variable substitution
-   *
-   * @return - a copy of the original properties.
-   */
-  public Properties getOriginalProperties() {
-    Properties ret = new Properties();
-    ret.putAll(origsolrprops);
-    return ret;
-  }
-
-  @Override
-  public ShardHandlerFactory initShardHandler(/*boolean isTest*/) {
-
-    PluginInfo info = null;
-    Map<String, String> attrs = new HashMap<String, String>();
-    NamedList args = new NamedList();
-    boolean haveHandler = false;
-    for (String s : solrProperties.stringPropertyNames()) {
-      String val = solrProperties.getProperty(s);
-      int index = s.indexOf(SHARD_HANDLER_FACTORY);
-      if (index != -1) {
-        haveHandler = true;
-        if (SHARD_HANDLER_NAME.equals(s) || SHARD_HANDLER_CLASS.equals(s)) {
-          // remove shardHandlerFactory. prefix
-          attrs.put(s.substring(SHARD_HANDLER_FACTORY.length()+1), val);
-        } else {
-          // remove shardHandlerFactory. prefix
-          args.add(s.substring(SHARD_HANDLER_FACTORY.length()+1), val);
-        }
-      }
-    }
-
-    if (haveHandler) {
-      info = new PluginInfo(SHARD_HANDLER_FACTORY, attrs, args, null);
-    } else {
-      Map m = new HashMap();
-      m.put("class", HttpShardHandlerFactory.class.getName());
-      info = new PluginInfo("shardHandlerFactory", m, null, Collections.<PluginInfo>emptyList());
-    }
-
-    assert loader != null;
-    ShardHandlerFactory fac;
-    try {
-      fac = loader.findClass(info.className, ShardHandlerFactory.class).newInstance();
-    } catch (Exception e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
-    }
-    if (fac instanceof PluginInfoInitialized) {
-      ((PluginInfoInitialized) fac).init(info);
-    }
-
-    return fac;
-  }
-
-  // Strictly for compatibility with i'face. TODO: remove for 5.0
-  @Override
-  public Properties getSolrProperties(ConfigSolr cfg, String context) {
-    return getSolrProperties();
-  }
-
-  /**
-   * Return the original properties that were defined, without substitutions from solr.properties
-   *
-   * @return - the Properties as originally defined.
-   */
-  public Properties getSolrProperties() {
-    return solrProperties;
-  }
-
-  /**
-   * given a core and attributes, find the core.properties file from whence it came and update it with the current
-   * <p/>
-   * Note, when the cores were discovered, we stored away the path that it came from for reference later. Remember
-   * that these cores aren't necessarily loaded all the time, they may be transient.
-   * It's not clear what the magic is that the calling methods (see CoreContainer) are doing, but they seem to be
-   * "doing the right thing" so that the attribs properties are the ones that contain the correct data. All the
-   * tests pass, but it's magic at this point.
-   *
-   * @param coreName - the core whose attributes we are to change
-   * @param attribs  - the attribs to change to, see note above.
-   * @param props    - ignored, here to make the i'face work in combination with ConfigSolrXmlBackCompat
-   */
-
-  @Override
-  public void addPersistCore(String coreName, Properties attribs, Map<String, String> props) {
-    String val = container.getContainerProperties().getProperty("solr.persistent", "false");
-    if (!Boolean.parseBoolean(val)) return;
-
-    CoreDescriptorPlus plus;
-    plus = coreDescriptorPlusMap.get(coreName);
-    if (plus == null) {
-      log.error("Expected to find core for persisting, but we did not. Core: " + coreName);
-      return;
-    }
-
-    Properties outProps = new Properties();
-    // I don't quite get this, but somehow the attribs passed in are the originals (plus any newly-added ones). Never
-    // one to look a gift horse in the mouth I'll just use that.
-
-    // Take care NOT to write out properties like ${blah blah blah}
-    outProps.putAll(attribs);
-    Properties corePropsOrig = plus.getPropsOrig();
-    for (String prop : corePropsOrig.stringPropertyNames()) {
-      val = corePropsOrig.getProperty(prop);
-      if (val.indexOf("$") != -1) { // it was originally a system property, keep it so
-        outProps.put(prop, val);
-        continue;
-      }
-      // Make sure anything that used to be in the properties file still is.
-      if (outProps.getProperty(prop) == null) {
-        outProps.put(prop, val);
-      }
-    }
-    // Any of our standard properties that weren't in the original properties file should NOT be persisted, I think
-    for (String prop : CoreDescriptor.standardPropNames) {
-      if (corePropsOrig.getProperty(prop) == null) {
-        outProps.remove(prop);
-      }
-    }
-
-    OutputStream os = null;
-    try {
-      os = new FileOutputStream(plus.getFilePath());
-      outProps.store(os, null);
-    } catch (IOException e) {
-      log.error("Failed to persist core {}, filepath {}", coreName, plus.getFilePath());
-    } finally {
-      IOUtils.closeQuietly(os);
-    }
-
-  }
-
-  /**
-   * PersistSolrProperties persists the Solr.properties file only,
-   * <p/>
-   * The old version (i.e. using solr.xml) persisted _everything_ in a single file. This version will just
-   * persist the solr.properties file for an individual core.
-   * The individual cores were persisted in addPersistCore calls above.
-   */
-  // It seems like a lot of this could be done by using the Properties defaults
-
-  /**
-   * PersistSolrProperties persists the Solr.properties file only,
-   * <p/>
-   * The old version (i.e. using solr.xml) persisted _everything_ in a single file. This version will just
-   * persist the solr.properties file for an individual core.
-   * The individual cores were persisted in addPersistCore calls above.
-   * <p/>
-   * TODO: Remove all parameters for 5.0 when we obsolete ConfigSolrXmlBackCompat
-   *
-   * @param containerProperties - ignored, here for back compat.
-   * @param rootSolrAttribs     - ignored, here for back compat.
-   * @param coresAttribs        - ignored, here for back compat.
-   * @param file                - ignored, here for back compat.
-   */
-
-  @Override
-  public void addPersistAllCores(Properties containerProperties, Map<String, String> rootSolrAttribs,
-                                 Map<String, String> coresAttribs, File file) {
-    String val = container.getContainerProperties().getProperty("solr.persistent", "false");
-    if (!Boolean.parseBoolean(val)) return;
-
-    // First persist solr.properties
-    File parent = new File(container.getSolrHome());
-    File props = new File(parent, SOLR_PROPERTIES_FILE);
-    Properties propsOut = new Properties();
-    propsOut.putAll(container.getContainerProperties());
-    for (String prop : origsolrprops.stringPropertyNames()) {
-      String toTest = origsolrprops.getProperty(prop);
-      if (toTest.indexOf("$") != -1) { // Don't store away things that should be system properties
-        propsOut.put(prop, toTest);
-      }
-    }
-    OutputStream os = null;
-    try {
-      os = new FileOutputStream(props);
-      propsOut.store(os, null);
-    } catch (IOException e) {
-      log.error("Failed to persist file " + props.getAbsolutePath(), e);
-    } finally {
-      IOUtils.closeQuietly(os);
-    }
-  }
-
-
-  // Copied verbatim from the old code, presumably this will be tested when we eliminate solr.xml
-  @Override
-  public SolrConfig getSolrConfigFromZk(ZkController zkController, String zkConfigName, String solrConfigFileName,
-                                        SolrResourceLoader resourceLoader) {
-    SolrConfig cfg = null;
-    try {
-      byte[] config = zkController.getConfigFileData(zkConfigName, solrConfigFileName);
-      InputSource is = new InputSource(new ByteArrayInputStream(config));
-      is.setSystemId(SystemIdResolver.createSystemIdFromResourceName(solrConfigFileName));
-      cfg = solrConfigFileName == null ? new SolrConfig(
-          resourceLoader, SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(
-          resourceLoader, solrConfigFileName, is);
-    } catch (Exception e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-          "getSolrConfigFromZK failed for " + zkConfigName + " " + solrConfigFileName, e);
-    }
-    return cfg;
-  }
-
-  @Override
-  public void initPersist() {
-    //NOOP
-  }
-
-  // Basic recursive tree walking, looking for "core.properties" files. Once one is found, we'll stop going any
-  // deeper in the tree.
-  //
-  // @param file - the directory we're to either read the properties file from or recurse into.
-  private void walkFromHere(File file, CoreContainer container) throws IOException {
-    log.info("Looking for cores in " + file.getAbsolutePath());
-    for (File childFile : file.listFiles()) {
-      // This is a little tricky, we are asking if core.properties exists in a child directory of the directory passed
-      // in. In other words we're looking for core.properties in the grandchild directories of the parameter passed
-      // in. That allows us to gracefully top recursing deep but continue looking wide.
-      File propFile = new File(childFile, CORE_PROP_FILE);
-      if (propFile.exists()) { // Stop looking after processing this file!
-        log.info("Discovered properties file {}, adding to cores", propFile.getAbsolutePath());
-        Properties propsOrig = new Properties();
-        InputStream is = new FileInputStream(propFile);
-        try {
-          propsOrig.load(is);
-        } finally {
-          IOUtils.closeQuietly(is);
-        }
-
-        Properties props = new Properties();
-        for (String prop : propsOrig.stringPropertyNames()) {
-          props.put(prop, PropertiesUtil.substituteProperty(propsOrig.getProperty(prop), null));
-        }
-
-        if (props.getProperty(CoreDescriptor.CORE_INSTDIR) == null) {
-          props.setProperty(CoreDescriptor.CORE_INSTDIR, childFile.getPath());
-        }
-
-        if (props.getProperty(CoreDescriptor.CORE_NAME) == null) {
-          // Should default to this directory
-          props.setProperty(CoreDescriptor.CORE_NAME, childFile.getName());
-        }
-        CoreDescriptor desc = new CoreDescriptor(container, props);
-        CoreDescriptorPlus plus = new CoreDescriptorPlus(propFile.getAbsolutePath(), desc, propsOrig);
-        coreDescriptorPlusMap.put(desc.getName(), plus);
-        continue; // Go on to the sibling directory
-      }
-      if (childFile.isDirectory()) {
-        walkFromHere(childFile, container);
-      }
-    }
-  }
-
-  static Properties getCoreProperties(String instanceDir, CoreDescriptor dcore) {
-    String file = dcore.getPropertiesName();
-    if (file == null) file = "conf" + File.separator + "solrcore.properties";
-    File corePropsFile = new File(file);
-    if (!corePropsFile.isAbsolute()) {
-      corePropsFile = new File(instanceDir, file);
-    }
-    Properties p = dcore.getCoreProperties();
-    if (corePropsFile.exists() && corePropsFile.isFile()) {
-      p = new Properties(dcore.getCoreProperties());
-      InputStream is = null;
-      try {
-        is = new FileInputStream(corePropsFile);
-        p.load(is);
-      } catch (IOException e) {
-        log.warn("Error loading properties ", e);
-      } finally {
-        IOUtils.closeQuietly(is);
-      }
-    }
-    return p;
-  }
-
-  @Override
-  public String getCoreNameFromOrig(String origCoreName, SolrResourceLoader loader, String coreName) {
-    // first look for an exact match
-    for (Map.Entry<String, CoreDescriptorPlus> ent : coreDescriptorPlusMap.entrySet()) {
-
-      String name = ent.getValue().getCoreDescriptor().getProperty(CoreDescriptor.CORE_NAME, null);
-      if (origCoreName.equals(name)) {
-        if (coreName.equals(origCoreName)) {
-          return name;
-        }
-        return coreName;
-      }
-    }
-
-    for (Map.Entry<String, CoreDescriptorPlus> ent : coreDescriptorPlusMap.entrySet()) {
-      String name = ent.getValue().getCoreDescriptor().getProperty(CoreDescriptor.CORE_NAME, null);
-      // see if we match with substitution
-      if (origCoreName.equals(PropertiesUtil.substituteProperty(name, loader.getCoreProperties()))) {
-        if (coreName.equals(origCoreName)) {
-          return name;
-        }
-        return coreName;
-      }
-    }
-    return null;
-  }
-
-  @Override
-  public List<String> getAllCoreNames() {
-    List<String> ret;
-    ret = new ArrayList<String>(coreDescriptorPlusMap.keySet());
-    return ret;
-  }
-
-  @Override
-  public String getProperty(String coreName, String property, String defaultVal) {
-    CoreDescriptorPlus plus = coreDescriptorPlusMap.get(coreName);
-    if (plus == null) return defaultVal;
-    CoreDescriptor desc = plus.getCoreDescriptor();
-    if (desc == null) return defaultVal;
-    return desc.getProperty(property, defaultVal);
-  }
-
-  @Override
-  public Properties readCoreProperties(String coreName) {
-    CoreDescriptorPlus plus = coreDescriptorPlusMap.get(coreName);
-    if (plus == null) return null;
-    return new Properties(plus.getCoreDescriptor().getCoreProperties());
-  }
-
-  @Override
-  public Map<String, String> readCoreAttributes(String coreName) {
-    return new HashMap<String, String>();  // Should be a no-op.
-  }
-}
-
-// It's mightily convenient to have all of the original path names and property values when persisting cores, so
-// this little convenience class is just for that.
-// Also, let's keep track of anything we added here, especially the instance dir for persistence purposes. We don't
-// want, for instance, to persist instanceDir if it was not specified originally.
-//
-// I suspect that for persistence purposes, we may want to expand this idea to record, say, ${blah}
-class CoreDescriptorPlus {
-  private CoreDescriptor coreDescriptor;
-  private String filePath;
-  private Properties propsOrig;
-
-  CoreDescriptorPlus(String filePath, CoreDescriptor descriptor, Properties propsOrig) {
-    coreDescriptor = descriptor;
-    this.filePath = filePath;
-    this.propsOrig = propsOrig;
-  }
-
-  CoreDescriptor getCoreDescriptor() {
-    return coreDescriptor;
-  }
-
-  String getFilePath() {
-    return filePath;
-  }
-
-  Properties getPropsOrig() {
-    return propsOrig;
-  }
-}
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java b/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
index 8fd16ad..6d26a0a 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
@@ -438,6 +438,18 @@ public class CoreAdminHandler extends RequestHandlerBase {
       if (opts != null)
         dcore.setUlogDir(opts);
 
+      opts = params.get(CoreAdminParams.LOAD_ON_STARTUP);
+      if (opts != null){
+        Boolean value = Boolean.valueOf(opts);
+        dcore.setLoadOnStartup(value);
+      }
+      
+      opts = params.get(CoreAdminParams.TRANSIENT);
+      if (opts != null){
+        Boolean value = Boolean.valueOf(opts);
+        dcore.setTransient(value);
+      }
+      
       CloudDescriptor cd = dcore.getCloudDescriptor();
       if (cd != null) {
         cd.setParams(req.getParams());
@@ -457,7 +469,7 @@ public class CoreAdminHandler extends RequestHandlerBase {
         opts = params.get(CoreAdminParams.CORE_NODE_NAME);
         if (opts != null)
           cd.setCoreNodeName(opts);
-        
+                        
         Integer numShards = params.getInt(ZkStateReader.NUM_SHARDS_PROP);
         if (numShards != null)
           cd.setNumShards(numShards);
diff --git a/solr/core/src/test-files/solr/solr-shardhandler.properties b/solr/core/src/test-files/solr/solr-shardhandler.properties
deleted file mode 100644
index 664a79a..0000000
--- a/solr/core/src/test-files/solr/solr-shardhandler.properties
+++ /dev/null
@@ -1,18 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-# solr.properties specifying a custom shard handler factory
-shardHandlerFactory.name=shardHandlerFactory
-shardHandlerFactory.class=org.apache.solr.core.MockShardHandlerFactory
-shardHandlerFactory.myMagicRequiredParameter=myMagicRequiredValue
diff --git a/solr/core/src/test-files/solr/solr-stress-new.xml b/solr/core/src/test-files/solr/solr-stress-new.xml
new file mode 100644
index 0000000..69a6700
--- /dev/null
+++ b/solr/core/src/test-files/solr/solr-stress-new.xml
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+ All (relative) paths are relative to the installation path
+
+  persistent: Save changes made via the API to this file
+  sharedLib: path to a lib directory that will be shared across all cores
+-->
+<solr persistent="${solr.xml.persist:true}">
+
+  <!--
+  adminPath: RequestHandler path to manage cores.
+    If 'null' (or absent), cores will not be manageable via request handler
+  -->
+  <cores adminPath="/admin/cores" defaultCoreName="collection1" host="127.0.0.1" hostPort="${hostPort:8983}"
+         hostContext="${hostContext:solr}" autoDiscoverCores="true" >
+    <shardHandlerFactory name="shardHandlerFactory" class="HttpShardHandlerFactory">
+      <int name="socketTimeout">${socketTimeout:120000}</int>
+      <int name="connTimeout">${connTimeout:15000}</int>
+    </shardHandlerFactory>
+  </cores>
+
+</solr>
diff --git a/solr/core/src/test-files/solr/solr-stress-old.xml b/solr/core/src/test-files/solr/solr-stress-old.xml
new file mode 100644
index 0000000..6bc1c35
--- /dev/null
+++ b/solr/core/src/test-files/solr/solr-stress-old.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+ All (relative) paths are relative to the installation path
+
+  persistent: Save changes made via the API to this file
+  sharedLib: path to a lib directory that will be shared across all cores
+-->
+<solr persistent="${solr.xml.persist:true}">
+
+  <!--
+  adminPath: RequestHandler path to manage cores.
+    If 'null' (or absent), cores will not be manageable via request handler
+  -->
+  <cores adminPath="/admin/cores" defaultCoreName="collection1" host="127.0.0.1" hostPort="${hostPort:8983}"
+         hostContext="${hostContext:solr}">
+    <core name="00000_core" instanceDir="00000_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="false" loadOnStartup="true" />
+    <core name="00001_core" instanceDir="00001_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00002_core" instanceDir="00002_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00003_core" instanceDir="00003_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00004_core" instanceDir="00004_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00005_core" instanceDir="00005_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00006_core" instanceDir="00006_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00007_core" instanceDir="00007_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00008_core" instanceDir="00008_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00009_core" instanceDir="00009_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00010_core" instanceDir="00010_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00011_core" instanceDir="00011_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00012_core" instanceDir="00012_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00013_core" instanceDir="00013_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00014_core" instanceDir="00014_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00015_core" instanceDir="00015_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00016_core" instanceDir="00016_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00017_core" instanceDir="00017_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00018_core" instanceDir="00018_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <core name="00019_core" instanceDir="00019_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
+    <shardHandlerFactory name="shardHandlerFactory" class="HttpShardHandlerFactory">
+      <int name="socketTimeout">${socketTimeout:120000}</int>
+      <int name="connTimeout">${connTimeout:15000}</int>
+    </shardHandlerFactory>
+  </cores>
+
+</solr>
diff --git a/solr/core/src/test-files/solr/solr-stress.xml b/solr/core/src/test-files/solr/solr-stress.xml
deleted file mode 100644
index 6bc1c35..0000000
--- a/solr/core/src/test-files/solr/solr-stress.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" ?>
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-
-<!--
- All (relative) paths are relative to the installation path
-
-  persistent: Save changes made via the API to this file
-  sharedLib: path to a lib directory that will be shared across all cores
--->
-<solr persistent="${solr.xml.persist:true}">
-
-  <!--
-  adminPath: RequestHandler path to manage cores.
-    If 'null' (or absent), cores will not be manageable via request handler
-  -->
-  <cores adminPath="/admin/cores" defaultCoreName="collection1" host="127.0.0.1" hostPort="${hostPort:8983}"
-         hostContext="${hostContext:solr}">
-    <core name="00000_core" instanceDir="00000_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="false" loadOnStartup="true" />
-    <core name="00001_core" instanceDir="00001_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00002_core" instanceDir="00002_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00003_core" instanceDir="00003_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00004_core" instanceDir="00004_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00005_core" instanceDir="00005_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00006_core" instanceDir="00006_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00007_core" instanceDir="00007_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00008_core" instanceDir="00008_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00009_core" instanceDir="00009_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00010_core" instanceDir="00010_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00011_core" instanceDir="00011_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00012_core" instanceDir="00012_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00013_core" instanceDir="00013_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00014_core" instanceDir="00014_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00015_core" instanceDir="00015_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00016_core" instanceDir="00016_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00017_core" instanceDir="00017_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00018_core" instanceDir="00018_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <core name="00019_core" instanceDir="00019_core" schema="schema-tiny.xml" config="solrconfig-minimal.xml" transient="true" loadOnStartup="false" />
-    <shardHandlerFactory name="shardHandlerFactory" class="HttpShardHandlerFactory">
-      <int name="socketTimeout">${socketTimeout:120000}</int>
-      <int name="connTimeout">${connTimeout:15000}</int>
-    </shardHandlerFactory>
-  </cores>
-
-</solr>
diff --git a/solr/core/src/test/org/apache/solr/core/OpenCloseCoreStressTest.java b/solr/core/src/test/org/apache/solr/core/OpenCloseCoreStressTest.java
index 082ab00..4ff58d3 100644
--- a/solr/core/src/test/org/apache/solr/core/OpenCloseCoreStressTest.java
+++ b/solr/core/src/test/org/apache/solr/core/OpenCloseCoreStressTest.java
@@ -215,11 +215,12 @@ public class OpenCloseCoreStressTest extends SolrTestCaseJ4 {
 
   private void makeCores(File home, boolean oldStyle) throws Exception {
     File testSrcRoot = new File(SolrTestCaseJ4.TEST_HOME());
+    String srcSolrXml = "solr-stress-new.xml";
+
     if (oldStyle) {
-      FileUtils.copyFile(new File(testSrcRoot, "solr-stress.xml"), new File(home, "solr.xml"));
-    } else {
-      FileUtils.copyFile(new File(testSrcRoot, "solr-stress.properties"), new File(home, "solr.properties"));
+      srcSolrXml = "solr-stress-old.xml";
     }
+    FileUtils.copyFile(new File(testSrcRoot, srcSolrXml), new File(home, "solr.xml"));
 
     // create directories in groups of 100 until you have enough.
     for (int idx = 0; idx < numCores; ++idx) {
diff --git a/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java b/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
index 6ad2a41..5858c85 100644
--- a/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
+++ b/solr/core/src/test/org/apache/solr/core/TestCoreContainer.java
@@ -193,12 +193,11 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
       assertEquals("cores not added?", 3, cores.getCoreNames().size());
       
       final File twoXml = new File(workDir, "2.solr.xml");
-      cores.transientCacheSize = 32;
 
       cores.persistFile(twoXml);
 
       assertXmlFile(twoXml, "/solr[@persistent='true']",
-          "/solr/cores[@defaultCoreName='collection1' and @transientCacheSize='32']",
+          "/solr/cores[@defaultCoreName='collection1']",
           "/solr/cores/core[@name='collection1' and @instanceDir='" + instDir
               + "']", "/solr/cores/core[@name='X' and @instanceDir='" + instDir
               + "' and @dataDir='" + dataX + "']",
@@ -271,7 +270,7 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
       FileUtils.deleteDirectory(solrHomeDirectory);
       throw e;
     }
-    
+
     //init
     System.setProperty("solr.solr.home", solrHomeDirectory.getAbsolutePath());
     CoreContainer.Initializer init = new CoreContainer.Initializer();
@@ -293,8 +292,13 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
       cores.register(newCore, false);
       
       //assert one registered core
+
       assertEquals("There core registered", 1, cores.getCores().size());
-      
+
+
+      assertXmlFile(new File(solrHomeDirectory, "solr.xml"),
+          "/solr/cores[@transientCacheSize='32']");
+
       newCore.close();
       cores.remove("core1");
       //assert cero cores
@@ -308,7 +312,7 @@ public class TestCoreContainer extends SolrTestCaseJ4 {
   
   private static final String EMPTY_SOLR_XML ="<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" +
       "<solr persistent=\"false\">\n" +
-      "  <cores adminPath=\"/admin/cores\">\n" +
+      "  <cores adminPath=\"/admin/cores\" transientCacheSize=\"32\" >\n" +
       "  </cores>\n" +
       "</solr>";
   
diff --git a/solr/core/src/test/org/apache/solr/core/TestCoreDiscovery.java b/solr/core/src/test/org/apache/solr/core/TestCoreDiscovery.java
new file mode 100644
index 0000000..9d11185
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/core/TestCoreDiscovery.java
@@ -0,0 +1,323 @@
+package org.apache.solr.core;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.commons.io.FileUtils;
+import org.apache.lucene.util.IOUtils;
+import org.apache.solr.SolrTestCaseJ4;
+import org.junit.After;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.StringReader;
+import java.util.Properties;
+import java.util.Set;
+
+public class TestCoreDiscovery extends SolrTestCaseJ4 {
+  private static String NEW_LINE = System.getProperty("line.separator");
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore();
+  }
+
+  private final File solrHomeDirectory = new File(TEMP_DIR, "org.apache.solr.core.TestCoreDiscovery" + File.separator + "solrHome");
+
+  private void setMeUp() throws Exception {
+    if (solrHomeDirectory.exists()) {
+      FileUtils.deleteDirectory(solrHomeDirectory);
+    }
+    assertTrue("Failed to mkdirs workDir", solrHomeDirectory.mkdirs());
+    System.setProperty("solr.solr.home", solrHomeDirectory.getAbsolutePath());
+  }
+
+  private void addSolrXml() throws Exception {
+    File tmpFile = new File(solrHomeDirectory, ConfigSolr.SOLR_XML_FILE);
+    FileUtils.write(tmpFile, SOLR_XML, IOUtils.CHARSET_UTF_8.toString());
+  }
+
+  private Properties makeCorePropFile(String name, boolean isLazy, boolean loadOnStartup, String... extraProps) {
+    Properties props = new Properties();
+    props.put(CoreDescriptor.CORE_NAME, name);
+    props.put(CoreDescriptor.CORE_SCHEMA, "schema-tiny.xml");
+    props.put(CoreDescriptor.CORE_CONFIG, "solrconfig-minimal.xml");
+    props.put(CoreDescriptor.CORE_TRANSIENT, Boolean.toString(isLazy));
+    props.put(CoreDescriptor.CORE_LOADONSTARTUP, Boolean.toString(loadOnStartup));
+    props.put(CoreDescriptor.CORE_DATADIR, "${core.dataDir:stuffandnonsense}");
+
+    for (String extra : extraProps) {
+      String[] parts = extra.split("=");
+      props.put(parts[0], parts[1]);
+    }
+
+    return props;
+  }
+
+  private void addCoreWithProps(Properties stockProps) throws Exception {
+
+    File propFile = new File(solrHomeDirectory,
+        stockProps.getProperty(CoreDescriptor.CORE_NAME) + File.separator + ConfigSolr.CORE_PROP_FILE);
+    File parent = propFile.getParentFile();
+    assertTrue("Failed to mkdirs for " + parent.getAbsolutePath(), parent.mkdirs());
+
+    FileOutputStream out = new FileOutputStream(propFile);
+    try {
+      stockProps.store(out, null);
+    } finally {
+      out.close();
+    }
+
+    addConfFiles(new File(parent, "conf"));
+  }
+
+  private void addConfFiles(File confDir) throws Exception {
+    String top = SolrTestCaseJ4.TEST_HOME() + "/collection1/conf";
+    assertTrue("Failed to mkdirs for " + confDir.getAbsolutePath(), confDir.mkdirs());
+    FileUtils.copyFile(new File(top, "schema-tiny.xml"), new File(confDir, "schema-tiny.xml"));
+    FileUtils.copyFile(new File(top, "solrconfig-minimal.xml"), new File(confDir, "solrconfig-minimal.xml"));
+  }
+
+  private void addConfigsForBackCompat() throws Exception {
+    addConfFiles(new File(solrHomeDirectory, "collection1" + File.separator + "conf"));
+  }
+
+  private CoreContainer init() throws Exception {
+
+    CoreContainer.Initializer init = new CoreContainer.Initializer();
+
+    final CoreContainer cores = init.initialize();
+
+    cores.setPersistent(false);
+    return cores;
+  }
+
+  @After
+  public void after() throws Exception {
+    if (solrHomeDirectory.exists()) {
+      FileUtils.deleteDirectory(solrHomeDirectory);
+    }
+  }
+
+  // Test the basic setup, create some dirs with core.properties files in them, but solr.xml has discoverCores
+  // set and insure that we find all the cores and can load them.
+  @Test
+  public void testPropertiesFile() throws Exception {
+    setMeUp();
+    addSolrXml();
+    // name, isLazy, loadOnStartup
+    addCoreWithProps(makeCorePropFile("core1", false, true));
+    addCoreWithProps(makeCorePropFile("core2", false, false));
+
+    // I suspect what we're adding in here is a "configset" rather than a schema or solrconfig.
+    //
+    addCoreWithProps(makeCorePropFile("lazy1", true, false));
+
+    CoreContainer cc = init();
+    try {
+      Properties props = cc.containerProperties;
+
+      assertEquals("/admin/cores", cc.getAdminPath());
+      assertEquals("defcore", cc.getDefaultCoreName());
+      assertEquals("222.333.444.555", cc.getHost());
+      assertEquals("6000", cc.getHostPort());
+      assertEquals("solrprop", cc.getHostContext());
+      assertEquals(20, cc.getZkClientTimeout());
+
+      TestLazyCores.checkInCores(cc, "core1");
+      TestLazyCores.checkNotInCores(cc, "lazy1", "core2", "collection1");
+
+      SolrCore core1 = cc.getCore("core1");
+
+      // Let's assert we did the right thing for implicit properties too.
+      CoreDescriptor desc = core1.getCoreDescriptor();
+      assertEquals("core1", desc.getProperty("solr.core.name"));
+
+      // This is too long and ugly to put in. Besides, it varies.
+      assertNotNull(desc.getProperty("solr.core.instanceDir"));
+
+      assertEquals("stuffandnonsense", desc.getProperty("solr.core.dataDir"));
+      assertEquals("solrconfig-minimal.xml", desc.getProperty("solr.core.configName"));
+      assertEquals("schema-tiny.xml", desc.getProperty("solr.core.schemaName"));
+
+      SolrCore core2 = cc.getCore("core2");
+      SolrCore lazy1 = cc.getCore("lazy1");
+      TestLazyCores.checkInCores(cc, "core1", "core2", "lazy1");
+      core1.close();
+      core2.close();
+      lazy1.close();
+
+    } finally {
+      cc.shutdown();
+    }
+  }
+
+
+  // Check that the various flavors of persistence work, including saving the state of a core when it's being swapped
+  // out. Added a test in here to insure that files that have config variables are saved with the config vars not the
+  // substitutions.
+  @Test
+  public void testPersistTrue() throws Exception {
+    setMeUp();
+    addSolrXml();
+    System.setProperty("solr.persistent", "true");
+
+    Properties special = makeCorePropFile("core1", false, true);
+    special.put(CoreDescriptor.CORE_INSTDIR, "${core1inst:anothersillypath}");
+    addCoreWithProps(special);
+    addCoreWithProps(makeCorePropFile("core2", false, false));
+    addCoreWithProps(makeCorePropFile("lazy1", true, true));
+    addCoreWithProps(makeCorePropFile("lazy2", true, true));
+    addCoreWithProps(makeCorePropFile("lazy3", true, false));
+
+    System.setProperty("core1inst", "core1");
+    CoreContainer cc = init();
+    SolrCore coreC1 = cc.getCore("core1");
+    addCoreProps(coreC1, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
+
+    SolrCore coreC2 = cc.getCore("core2");
+    addCoreProps(coreC2, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
+
+    SolrCore coreL1 = cc.getCore("lazy1");
+    addCoreProps(coreL1, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
+
+    SolrCore coreL2 = cc.getCore("lazy2");
+    addCoreProps(coreL2, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
+
+    SolrCore coreL3 = cc.getCore("lazy3");
+    addCoreProps(coreL3, "addedPropL3=addedL3", "addedPropL3B=foo", "addedPropL3C=bar");
+
+    try {
+      cc.persist();
+
+      // Insure that one of the loaded cores was swapped out, with a cache size of 2 lazy1 should be gone.
+      TestLazyCores.checkInCores(cc, "core1", "core2", "lazy2", "lazy3");
+      TestLazyCores.checkNotInCores(cc, "lazy1");
+
+      Properties orig = makeCorePropFile("core1", false, true);
+      orig.put(CoreDescriptor.CORE_INSTDIR, "${core1inst:anothersillypath}");
+      checkCoreProps(orig, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
+
+      orig = makeCorePropFile("core2", false, false);
+      checkCoreProps(orig, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
+
+      // This test insures that a core that was swapped out has its properties file persisted. Currently this happens
+      // as the file is removed from the cache.
+      orig = makeCorePropFile("lazy1", true, true);
+      checkCoreProps(orig, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
+
+      orig = makeCorePropFile("lazy2", true, true);
+      checkCoreProps(orig, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
+
+      orig = makeCorePropFile("lazy3", true, false);
+      checkCoreProps(orig, "addedPropL3=addedL3", "addedPropL3B=foo", "addedPropL3C=bar");
+
+      coreC1.close();
+      coreC2.close();
+      coreL1.close();
+      coreL2.close();
+      coreL3.close();
+
+    } finally {
+      cc.shutdown();
+    }
+  }
+
+  // Make sure that, even if we do call persist, nothing's saved unless the flag is set in solr.properties.
+  @Test
+  public void testPersistFalse() throws Exception {
+    setMeUp();
+    addSolrXml();
+
+    addCoreWithProps(makeCorePropFile("core1", false, true));
+    addCoreWithProps(makeCorePropFile("core2", false, false));
+    addCoreWithProps(makeCorePropFile("lazy1", true, true));
+    addCoreWithProps(makeCorePropFile("lazy2", false, true));
+
+    CoreContainer cc = init();
+    SolrCore coreC1 = cc.getCore("core1");
+    addCoreProps(coreC1, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
+
+    SolrCore coreC2 = cc.getCore("core2");
+    addCoreProps(coreC2, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
+
+    SolrCore coreL1 = cc.getCore("lazy1");
+    addCoreProps(coreL1, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
+
+    SolrCore coreL2 = cc.getCore("lazy2");
+    addCoreProps(coreL2, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
+
+
+    try {
+      cc.persist();
+//      checkSolrProperties(cc);
+
+      checkCoreProps(makeCorePropFile("core1", false, true));
+      checkCoreProps(makeCorePropFile("core2", false, false));
+      checkCoreProps(makeCorePropFile("lazy1", true, true));
+      checkCoreProps(makeCorePropFile("lazy2", false, true));
+
+      coreC1.close();
+      coreC2.close();
+      coreL1.close();
+      coreL2.close();
+    } finally {
+      cc.shutdown();
+    }
+  }
+
+  void addCoreProps(SolrCore core, String... propPairs) {
+    for (String keyval : propPairs) {
+      String[] pair = keyval.split("=");
+      core.getCoreDescriptor().putProperty(pair[0], pair[1]);
+    }
+  }
+
+  // Insure that the properties in the core passed in are exactly what's in the default core.properties below plus
+  // whatever extra is passed in.
+  void checkCoreProps(Properties orig, String... extraProps) throws Exception {
+    // Read the persisted file.
+    Properties props = new Properties();
+    File propParent = new File(solrHomeDirectory, orig.getProperty(CoreDescriptor.CORE_NAME));
+    FileInputStream in = new FileInputStream(new File(propParent, ConfigSolr.CORE_PROP_FILE));
+    try {
+      props.load(in);
+    } finally {
+      in.close();
+    }
+    Set<String> propSet = props.stringPropertyNames();
+
+    assertEquals("Persisted properties should NOT contain extra properties", propSet.size(), orig.size());
+
+    for (String prop : orig.stringPropertyNames()) {
+      assertEquals("Original and new properties should be equal for " + prop, props.getProperty(prop), orig.getProperty(prop));
+    }
+    for (String prop : extraProps) {
+      String[] pair = prop.split("=");
+      assertNull("Modified parameters should not be present for " + prop, props.getProperty(pair[0]));
+    }
+  }
+
+  // For testing whether finding a solr.xml overrides looking at solr.properties
+  private final static String SOLR_XML = " <solr persistent=\"${persistent:false}\"> " +
+      "<cores autoDiscoverCores=\"true\" adminPath=\"/admin/cores\" defaultCoreName=\"defcore\" transientCacheSize=\"2\" " +
+       " hostContext=\"solrprop\" zkClientTimeout=\"20\" host=\"222.333.444.555\" hostPort=\"6000\" />  " +
+      "</solr>";
+}
diff --git a/solr/core/src/test/org/apache/solr/core/TestShardHandlerFactory.java b/solr/core/src/test/org/apache/solr/core/TestShardHandlerFactory.java
index 3f5865f..d2e0332 100644
--- a/solr/core/src/test/org/apache/solr/core/TestShardHandlerFactory.java
+++ b/solr/core/src/test/org/apache/solr/core/TestShardHandlerFactory.java
@@ -38,15 +38,4 @@ public class TestShardHandlerFactory extends SolrTestCaseJ4 {
     factory.close();
     cc.shutdown();
   }
-  
-  public void testProperties() throws Exception {
-    CoreContainer cc = new CoreContainer(TEST_HOME());
-    cc.load(TEST_HOME(), new File(TEST_HOME(), "solr-shardhandler.properties"));
-    ShardHandlerFactory factory = cc.getShardHandlerFactory();
-    assertTrue(factory instanceof MockShardHandlerFactory);
-    NamedList args = ((MockShardHandlerFactory)factory).args;
-    assertEquals("myMagicRequiredValue", args.get("myMagicRequiredParameter"));
-    factory.close();
-    cc.shutdown();
-  }
 }
diff --git a/solr/core/src/test/org/apache/solr/core/TestSolrDiscoveryProperties.java b/solr/core/src/test/org/apache/solr/core/TestSolrDiscoveryProperties.java
deleted file mode 100644
index 280ecf5..0000000
--- a/solr/core/src/test/org/apache/solr/core/TestSolrDiscoveryProperties.java
+++ /dev/null
@@ -1,436 +0,0 @@
-package org.apache.solr.core;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.commons.io.FileUtils;
-import org.apache.lucene.util.IOUtils;
-import org.apache.solr.SolrTestCaseJ4;
-import org.junit.After;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.StringReader;
-import java.util.Properties;
-import java.util.Set;
-
-public class TestSolrDiscoveryProperties extends SolrTestCaseJ4 {
-  private static String NEW_LINE = System.getProperty("line.separator");
-
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    initCore();
-  }
-
-  private final File solrHomeDirectory = new File(TEMP_DIR, "org.apache.solr.core.TestSolrDiscoveryProperties" + File.separator + "solrHome");
-
-  private void setMeUp() throws Exception {
-    if (solrHomeDirectory.exists()) {
-      FileUtils.deleteDirectory(solrHomeDirectory);
-    }
-    assertTrue("Failed to mkdirs workDir", solrHomeDirectory.mkdirs());
-    System.setProperty("solr.solr.home", solrHomeDirectory.getAbsolutePath());
-  }
-
-  private void addSolrPropertiesFile(String... extras) throws Exception {
-    File solrProps = new File(solrHomeDirectory, SolrProperties.SOLR_PROPERTIES_FILE);
-    Properties props = new Properties();
-    props.load(new StringReader(SOLR_PROPERTIES));
-    for (String extra : extras) {
-      String[] parts = extra.split("=");
-      props.put(parts[0], parts[1]);
-    }
-    FileOutputStream out = new FileOutputStream(solrProps.getAbsolutePath());
-    try {
-      props.store(out, null);
-    } finally {
-      out.close();
-    }
-  }
-
-  private void addSolrXml() throws Exception {
-    File tmpFile = new File(solrHomeDirectory, SolrProperties.SOLR_XML_FILE);
-    FileUtils.write(tmpFile, SOLR_XML, IOUtils.CHARSET_UTF_8.toString());
-  }
-
-  private Properties makeCorePropFile(String name, boolean isLazy, boolean loadOnStartup, String... extraProps) {
-    Properties props = new Properties();
-    props.put(CoreDescriptor.CORE_NAME, name);
-    props.put(CoreDescriptor.CORE_SCHEMA, "schema-tiny.xml");
-    props.put(CoreDescriptor.CORE_CONFIG, "solrconfig-minimal.xml");
-    props.put(CoreDescriptor.CORE_TRANSIENT, Boolean.toString(isLazy));
-    props.put(CoreDescriptor.CORE_LOADONSTARTUP, Boolean.toString(loadOnStartup));
-    props.put(CoreDescriptor.CORE_DATADIR, "${core.dataDir:stuffandnonsense}");
-
-    for (String extra : extraProps) {
-      String[] parts = extra.split("=");
-      props.put(parts[0], parts[1]);
-    }
-
-    return props;
-  }
-
-  private void addCoreWithProps(Properties stockProps) throws Exception {
-
-    File propFile = new File(solrHomeDirectory,
-        stockProps.getProperty(CoreDescriptor.CORE_NAME) + File.separator + SolrProperties.CORE_PROP_FILE);
-    File parent = propFile.getParentFile();
-    assertTrue("Failed to mkdirs for " + parent.getAbsolutePath(), parent.mkdirs());
-
-    FileOutputStream out = new FileOutputStream(propFile);
-    try {
-      stockProps.store(out, null);
-    } finally {
-      out.close();
-    }
-
-    addConfFiles(new File(parent, "conf"));
-  }
-
-  private void addConfFiles(File confDir) throws Exception {
-    String top = SolrTestCaseJ4.TEST_HOME() + "/collection1/conf";
-    assertTrue("Failed to mkdirs for " + confDir.getAbsolutePath(), confDir.mkdirs());
-    FileUtils.copyFile(new File(top, "schema-tiny.xml"), new File(confDir, "schema-tiny.xml"));
-    FileUtils.copyFile(new File(top, "solrconfig-minimal.xml"), new File(confDir, "solrconfig-minimal.xml"));
-  }
-
-  private void addConfigsForBackCompat() throws Exception {
-    addConfFiles(new File(solrHomeDirectory, "collection1" + File.separator + "conf"));
-  }
-
-  private CoreContainer init() throws Exception {
-
-    CoreContainer.Initializer init = new CoreContainer.Initializer();
-
-    final CoreContainer cores = init.initialize();
-
-    cores.setPersistent(false);
-    return cores;
-  }
-
-  @After
-  public void after() throws Exception {
-    if (solrHomeDirectory.exists()) {
-      FileUtils.deleteDirectory(solrHomeDirectory);
-    }
-  }
-
-  // Test the basic setup, create some dirs with core.properties files in them, but no solr.xml (a solr.properties
-  // instead) and insure that we find all the cores and can load them.
-  @Test
-  public void testPropertiesFile() throws Exception {
-    setMeUp();
-    addSolrPropertiesFile();
-    // name, isLazy, loadOnStartup
-    addCoreWithProps(makeCorePropFile("core1", false, true));
-    addCoreWithProps(makeCorePropFile("core2", false, false));
-
-    // I suspect what we're adding in here is a "configset" rather than a schema or solrconfig.
-    //
-    addCoreWithProps(makeCorePropFile("lazy1", true, false));
-
-    CoreContainer cc = init();
-    try {
-      Properties props = cc.containerProperties;
-
-      assertEquals("/admin/cores/props", props.getProperty("cores.adminPath"));
-      assertEquals("/admin/cores/props", cc.getAdminPath());
-      assertEquals("defcore", props.getProperty("cores.defaultCoreName"));
-      assertEquals("defcore", cc.getDefaultCoreName());
-      assertEquals("222.333.444.555", props.getProperty("host"));
-      assertEquals("6000", props.getProperty("port")); // getProperty actually looks at original props.
-      assertEquals("/solrprop", props.getProperty("cores.hostContext"));
-      assertEquals("20", props.getProperty("cores.zkClientTimeout"));
-
-      TestLazyCores.checkInCores(cc, "core1");
-      TestLazyCores.checkNotInCores(cc, "lazy1", "core2", "collection1");
-
-      SolrCore core1 = cc.getCore("core1");
-
-      // Let's assert we did the right thing for implicit properties too.
-      CoreDescriptor desc = core1.getCoreDescriptor();
-      assertEquals("core1", desc.getProperty("solr.core.name"));
-
-      // This is too long and ugly to put in. Besides, it varies.
-      assertNotNull(desc.getProperty("solr.core.instanceDir"));
-
-      assertEquals("stuffandnonsense", desc.getProperty("solr.core.dataDir"));
-      assertEquals("solrconfig-minimal.xml", desc.getProperty("solr.core.configName"));
-      assertEquals("schema-tiny.xml", desc.getProperty("solr.core.schemaName"));
-
-      SolrCore core2 = cc.getCore("core2");
-      SolrCore lazy1 = cc.getCore("lazy1");
-      TestLazyCores.checkInCores(cc, "core1", "core2", "lazy1");
-      core1.close();
-      core2.close();
-      lazy1.close();
-
-    } finally {
-      cc.shutdown();
-    }
-  }
-
-
-  // Check that the various flavors of persistence work, including saving the state of a core when it's being swapped
-  // out. Added a test in here to insure that files that have config variables are saved with the config vars not the
-  // substitutions.
-  @Test
-  public void testPersistTrue() throws Exception {
-    setMeUp();
-    addSolrPropertiesFile();
-    System.setProperty("solr.persistent", "true");
-
-    Properties special = makeCorePropFile("core1", false, true);
-    special.put(CoreDescriptor.CORE_INSTDIR, "${core1inst:anothersillypath}");
-    addCoreWithProps(special);
-    addCoreWithProps(makeCorePropFile("core2", false, false));
-    addCoreWithProps(makeCorePropFile("lazy1", true, true));
-    addCoreWithProps(makeCorePropFile("lazy2", true, true));
-    addCoreWithProps(makeCorePropFile("lazy3", true, false));
-
-    System.setProperty("core1inst", "core1");
-    CoreContainer cc = init();
-    SolrCore coreC1 = cc.getCore("core1");
-    addCoreProps(coreC1, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
-
-    SolrCore coreC2 = cc.getCore("core2");
-    addCoreProps(coreC2, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
-
-    SolrCore coreL1 = cc.getCore("lazy1");
-    addCoreProps(coreL1, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
-
-    SolrCore coreL2 = cc.getCore("lazy2");
-    addCoreProps(coreL2, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
-
-    SolrCore coreL3 = cc.getCore("lazy3");
-    addCoreProps(coreL3, "addedPropL3=addedL3", "addedPropL3B=foo", "addedPropL3C=bar");
-
-    try {
-      cc.persist();
-
-      // Insure that one of the loaded cores was swapped out, with a cache size of 2 lazy1 should be gone.
-      TestLazyCores.checkInCores(cc, "core1", "core2", "lazy2", "lazy3");
-      TestLazyCores.checkNotInCores(cc, "lazy1");
-
-      checkSolrProperties(cc);
-
-      File xmlFile = new File(solrHomeDirectory, "solr.xml");
-      assertFalse("Solr.xml should NOT exist", xmlFile.exists());
-
-      Properties orig = makeCorePropFile("core1", false, true);
-      orig.put(CoreDescriptor.CORE_INSTDIR, "${core1inst:anothersillypath}");
-      checkCoreProps(orig, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
-
-      orig = makeCorePropFile("core2", false, false);
-      checkCoreProps(orig, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
-
-      // This test insures that a core that was swapped out has its properties file persisted. Currently this happens
-      // as the file is removed from the cache.
-      orig = makeCorePropFile("lazy1", true, true);
-      checkCoreProps(orig, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
-
-      orig = makeCorePropFile("lazy2", true, true);
-      checkCoreProps(orig, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
-
-      orig = makeCorePropFile("lazy3", true, false);
-      checkCoreProps(orig, "addedPropL3=addedL3", "addedPropL3B=foo", "addedPropL3C=bar");
-
-      coreC1.close();
-      coreC2.close();
-      coreL1.close();
-      coreL2.close();
-      coreL3.close();
-
-    } finally {
-      cc.shutdown();
-    }
-  }
-
-  // Make sure that, even if we do call persist, nothing's saved unless the flag is set in solr.properties.
-  @Test
-  public void testPersistFalse() throws Exception {
-    setMeUp();
-    addSolrPropertiesFile();
-
-    addCoreWithProps(makeCorePropFile("core1", false, true));
-    addCoreWithProps(makeCorePropFile("core2", false, false));
-    addCoreWithProps(makeCorePropFile("lazy1", true, true));
-    addCoreWithProps(makeCorePropFile("lazy2", false, true));
-
-    CoreContainer cc = init();
-    SolrCore coreC1 = cc.getCore("core1");
-    addCoreProps(coreC1, "addedPropC1=addedC1", "addedPropC1B=foo", "addedPropC1C=bar");
-
-    SolrCore coreC2 = cc.getCore("core2");
-    addCoreProps(coreC2, "addedPropC2=addedC2", "addedPropC2B=foo", "addedPropC2C=bar");
-
-    SolrCore coreL1 = cc.getCore("lazy1");
-    addCoreProps(coreL1, "addedPropL1=addedL1", "addedPropL1B=foo", "addedPropL1C=bar");
-
-    SolrCore coreL2 = cc.getCore("lazy2");
-    addCoreProps(coreL2, "addedPropL2=addedL2", "addedPropL2B=foo", "addedPropL2C=bar");
-
-
-    try {
-      cc.persist();
-      checkSolrProperties(cc);
-
-      checkCoreProps(makeCorePropFile("core1", false, true));
-      checkCoreProps(makeCorePropFile("core2", false, false));
-      checkCoreProps(makeCorePropFile("lazy1", true, true));
-      checkCoreProps(makeCorePropFile("lazy2", false, true));
-
-      coreC1.close();
-      coreC2.close();
-      coreL1.close();
-      coreL2.close();
-    } finally {
-      cc.shutdown();
-    }
-  }
-
-  void addCoreProps(SolrCore core, String... propPairs) {
-    for (String keyval : propPairs) {
-      String[] pair = keyval.split("=");
-      core.getCoreDescriptor().putProperty(pair[0], pair[1]);
-    }
-  }
-
-  // Insure that the solr.properties is as it should be after persisting _and_, in some cases, different than
-  // what's in memory
-  void checkSolrProperties(CoreContainer cc, String... checkMemPairs) throws Exception {
-    Properties orig = new Properties();
-    orig.load(new StringReader(SOLR_PROPERTIES));
-
-    Properties curr = cc.getContainerProperties();
-
-    Properties persisted = new Properties();
-    FileInputStream in = new FileInputStream(new File(solrHomeDirectory, SolrProperties.SOLR_PROPERTIES_FILE));
-    try {
-      persisted.load(in);
-    } finally {
-      in.close();
-    }
-
-    assertEquals("Persisted and original should be the same size", orig.size(), persisted.size());
-
-    for (String prop : orig.stringPropertyNames()) {
-      assertEquals("Values of original should match current", orig.getProperty(prop), persisted.getProperty(prop));
-    }
-
-    Properties specialProps = new Properties();
-    for (String special : checkMemPairs) {
-      String[] pair = special.split("=");
-      specialProps.put(pair[0], pair[1]);
-    }
-    // OK, current should match original except if the property is "special"
-    for (String prop : curr.stringPropertyNames()) {
-      String val = specialProps.getProperty(prop);
-      if (val != null) { // Compare curr and val
-        assertEquals("Modified property should be in current container properties", val, curr.getProperty(prop));
-      }
-    }
-  }
-
-  // Insure that the properties in the core passed in are exactly what's in the default core.properties below plus
-  // whatever extra is passed in.
-  void checkCoreProps(Properties orig, String... extraProps) throws Exception {
-    // Read the persisted file.
-    Properties props = new Properties();
-    File propParent = new File(solrHomeDirectory, orig.getProperty(CoreDescriptor.CORE_NAME));
-    FileInputStream in = new FileInputStream(new File(propParent, SolrProperties.CORE_PROP_FILE));
-    try {
-      props.load(in);
-    } finally {
-      in.close();
-    }
-    Set<String> propSet = props.stringPropertyNames();
-
-    assertEquals("Persisted properties should NOT contain extra properties", propSet.size(), orig.size());
-
-    for (String prop : orig.stringPropertyNames()) {
-      assertEquals("Original and new properties should be equal for " + prop, props.getProperty(prop), orig.getProperty(prop));
-    }
-    for (String prop : extraProps) {
-      String[] pair = prop.split("=");
-      assertNull("Modified parameters should not be present for " + prop, props.getProperty(pair[0]));
-    }
-  }
-
-  // If there's a solr.xml AND a properties file, make sure that the xml file is loaded and the properties file
-  // is ignored.
-
-  @Test
-  public void testBackCompatXml() throws Exception {
-    setMeUp();
-    addSolrPropertiesFile();
-    addSolrXml();
-    addConfigsForBackCompat();
-
-    CoreContainer cc = init();
-    try {
-      Properties props = cc.getContainerProperties();
-
-      assertEquals("/admin/cores", cc.getAdminPath());
-      assertEquals("collectionLazy2", cc.getDefaultCoreName());
-
-      // Shouldn't get these in properties at this point
-      assertNull(props.getProperty("cores.adminPath"));
-      assertNull(props.getProperty("cores.defaultCoreName"));
-      assertNull(props.getProperty("host"));
-      assertNull(props.getProperty("port")); // getProperty actually looks at original props.
-      assertNull(props.getProperty("cores.hostContext"));
-      assertNull(props.getProperty("cores.zkClientTimeout"));
-
-      SolrCore core1 = cc.getCore("collection1");
-      CoreDescriptor desc = core1.getCoreDescriptor();
-
-      assertEquals("collection1", desc.getProperty("solr.core.name"));
-
-      // This is too long and ugly to put in. Besides, it varies.
-      assertNotNull(desc.getProperty("solr.core.instanceDir"));
-
-      assertEquals("data" + File.separator, desc.getProperty("solr.core.dataDir"));
-      assertEquals("solrconfig-minimal.xml", desc.getProperty("solr.core.configName"));
-      assertEquals("schema-tiny.xml", desc.getProperty("solr.core.schemaName"));
-      core1.close();
-    } finally {
-      cc.shutdown();
-    }
-  }
-
-  // For this test I want some of these to be different than what would be in solr.xml by default.
-  private final static String SOLR_PROPERTIES =
-      "persistent=${persistent:false}" + NEW_LINE +
-          "cores.adminPath=/admin/cores/props" + NEW_LINE +
-          "cores.defaultCoreName=defcore" + NEW_LINE +
-          "host=222.333.444.555" + NEW_LINE +
-          "port=6000" + NEW_LINE +
-          "cores.hostContext=/solrprop" + NEW_LINE +
-          "cores.zkClientTimeout=20" + NEW_LINE +
-          "cores.transientCacheSize=2";
-
-  // For testing whether finding a solr.xml overrides looking at solr.properties
-  private final static String SOLR_XML = " <solr persistent=\"false\"> " +
-      "<cores adminPath=\"/admin/cores\" defaultCoreName=\"collectionLazy2\" transientCacheSize=\"4\">  " +
-      "<core name=\"collection1\" instanceDir=\"collection1\" config=\"solrconfig-minimal.xml\" schema=\"schema-tiny.xml\" /> " +
-      "</cores> " +
-      "</solr>";
-}
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/CoreAdminRequest.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/CoreAdminRequest.java
index 2c6d5ce..1d387ce 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/CoreAdminRequest.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/CoreAdminRequest.java
@@ -57,6 +57,8 @@ public class CoreAdminRequest extends SolrRequest
     private String shardId;
     private String roles;
     private String coreNodeName;
+    private Boolean loadOnStartup;
+    private Boolean isTransient;
 
     public Create() {
       action = CoreAdminAction.CREATE;
@@ -72,7 +74,9 @@ public class CoreAdminRequest extends SolrRequest
     public void setShardId(String shardId) {this.shardId = shardId;}
     public void setRoles(String roles) {this.roles = roles;}
     public void setCoreNodeName(String coreNodeName) {this.coreNodeName = coreNodeName;}
-    
+    public void setIsTransient(Boolean isTransient) { this.isTransient = isTransient; }
+    public void setIsLoadOnStartup(Boolean loadOnStartup) { this.loadOnStartup = loadOnStartup;}
+
     public String getInstanceDir() { return instanceDir; }
     public String getSchemaName()  { return schemaName; }
     public String getConfigName()  { return configName; }
@@ -82,7 +86,9 @@ public class CoreAdminRequest extends SolrRequest
     public String getShardId() { return shardId; }
     public String getRoles() { return roles; }
     public String getCoreNodeName() { return coreNodeName; }
-    
+    public Boolean getIsLoadOnStartup() { return loadOnStartup; }
+    public Boolean getIsTransient() { return isTransient; }
+
     @Override
     public SolrParams getParams() {
       if( action == null ) {
@@ -123,6 +129,14 @@ public class CoreAdminRequest extends SolrRequest
       if (coreNodeName != null) {
         params.set( CoreAdminParams.CORE_NODE_NAME, coreNodeName);
       }
+
+      if (isTransient != null) {
+        params.set(CoreAdminParams.TRANSIENT, isTransient);
+      }
+
+      if (loadOnStartup != null) {
+        params.set(CoreAdminParams.LOAD_ON_STARTUP, loadOnStartup);
+      }
       return params;
     }
 
@@ -151,11 +165,11 @@ public class CoreAdminRequest extends SolrRequest
     public String getCoreNodeName() {
       return coreNodeName;
     }
-    
+
     public void setCoreNodeName(String coreNodeName) {
       this.coreNodeName = coreNodeName;
     }
-    
+
     public String getState() {
       return state;
     }
diff --git a/solr/solrj/src/java/org/apache/solr/common/params/CoreAdminParams.java b/solr/solrj/src/java/org/apache/solr/common/params/CoreAdminParams.java
index f465ccc..87d077d 100644
--- a/solr/solrj/src/java/org/apache/solr/common/params/CoreAdminParams.java
+++ b/solr/solrj/src/java/org/apache/solr/common/params/CoreAdminParams.java
@@ -88,6 +88,9 @@ public interface CoreAdminParams
 
   public static final String DELETE_INSTANCE_DIR = "deleteInstanceDir";
 
+  public static final String LOAD_ON_STARTUP = "loadOnStartup";
+  
+  public static final String TRANSIENT = "transient";
 
   public enum CoreAdminAction {
     STATUS,  
@@ -104,7 +107,9 @@ public interface CoreAdminParams
     REQUESTRECOVERY, 
     REQUESTSYNCSHARD,
     CREATEALIAS,
-    DELETEALIAS;
+    DELETEALIAS,
+    LOAD_ON_STARTUP,
+    TRANSIENT;
     
     public static CoreAdminAction get( String p )
     {
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestCoreAdmin.java b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestCoreAdmin.java
index 9be4972..e432bdc 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestCoreAdmin.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/request/TestCoreAdmin.java
@@ -83,13 +83,29 @@ public class TestCoreAdmin extends AbstractEmbeddedSolrServerTestCase {
     req.setInstanceDir(newCoreInstanceDir.getAbsolutePath() + File.separator + "newcore");
     req.setDataDir(dataDir.getAbsolutePath());
     req.setUlogDir(new File(dataDir, "ulog").getAbsolutePath());
+
+    // These should be the inverse of defaults.
+    req.setIsLoadOnStartup(false);
+    req.setIsTransient(true);
     req.process(server);
-    
+
+    // Show that the newly-created core has values for load on startup and transient different than defaults due to the
+    // above.
+
+    SolrCore coreProveIt = cores.getCore("collection1");
     SolrCore core = cores.getCore("newcore");
+
+    assertTrue(core.getCoreDescriptor().isTransient());
+    assertFalse(coreProveIt.getCoreDescriptor().isTransient());
+
+    assertFalse(core.getCoreDescriptor().isLoadOnStartup());
+    assertTrue(coreProveIt.getCoreDescriptor().isLoadOnStartup());
+
     File logDir;
     try {
       logDir = core.getUpdateHandler().getUpdateLog().getLogDir();
     } finally {
+      coreProveIt.close();
       core.close();
     }
     assertEquals(new File(dataDir, "ulog" + File.separator + "tlog").getAbsolutePath(), logDir.getAbsolutePath());

