GitDiffStart: 854c9ac45223b64acf3e7e4c0a77383a9441268f | Fri Feb 17 14:46:35 2012 +0000
diff --git a/lucene/contrib/demo/src/java/org/apache/lucene/demo/IndexFiles.java b/lucene/contrib/demo/src/java/org/apache/lucene/demo/IndexFiles.java
index 173976f..e0b7edb 100644
--- a/lucene/contrib/demo/src/java/org/apache/lucene/demo/IndexFiles.java
+++ b/lucene/contrib/demo/src/java/org/apache/lucene/demo/IndexFiles.java
@@ -21,7 +21,7 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexWriter;
@@ -178,13 +178,13 @@ public class IndexFiles {
           doc.add(pathField);
 
           // Add the last modified date of the file a field named "modified".
-          // Use a NumericField that is indexed (i.e. efficiently filterable with
+          // Use a LongField that is indexed (i.e. efficiently filterable with
           // NumericRangeFilter).  This indexes to milli-second resolution, which
           // is often too fine.  You could instead create a number based on
           // year/month/day/hour/minutes/seconds, down the resolution you require.
           // For example the long value 2011021714 would mean
           // February 17, 2011, 2-3 PM.
-          doc.add(new NumericField("modified", file.lastModified()));
+          doc.add(new LongField("modified", file.lastModified()));
 
           // Add the contents of the file to a field named "contents".  Specify a Reader,
           // so that the text of the file is tokenized and indexed, but not stored.
diff --git a/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index d8278da..00818d5 100644
--- a/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -27,23 +27,23 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.StringTokenizer;
-
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 
 import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.highlight.SynonymTokenizer.TestHighlightRunner;
@@ -1738,19 +1738,23 @@ public class HighlighterTest extends BaseTokenStreamTestCase implements Formatte
       addDoc(writer, text);
     }
     Document doc = new Document();
-    doc.add(new NumericField(NUMERIC_FIELD_NAME, 1, NumericField.getFieldType(NumericField.DataType.INT, true)));
+    doc.add(new IntField(NUMERIC_FIELD_NAME, 1));
+    doc.add(new StoredField(NUMERIC_FIELD_NAME, 1));
     writer.addDocument(doc, analyzer);
 
     doc = new Document();
-    doc.add(new NumericField(NUMERIC_FIELD_NAME, 3, NumericField.getFieldType(NumericField.DataType.INT, true)));
+    doc.add(new IntField(NUMERIC_FIELD_NAME, 3));
+    doc.add(new StoredField(NUMERIC_FIELD_NAME, 3));
     writer.addDocument(doc, analyzer);
 
     doc = new Document();
-    doc.add(new NumericField(NUMERIC_FIELD_NAME, 5, NumericField.getFieldType(NumericField.DataType.INT, true)));
+    doc.add(new IntField(NUMERIC_FIELD_NAME, 5));
+    doc.add(new StoredField(NUMERIC_FIELD_NAME, 5));
     writer.addDocument(doc, analyzer);
 
     doc = new Document();
-    doc.add(new NumericField(NUMERIC_FIELD_NAME, 7, NumericField.getFieldType(NumericField.DataType.INT, true)));
+    doc.add(new IntField(NUMERIC_FIELD_NAME, 7));
+    doc.add(new StoredField(NUMERIC_FIELD_NAME, 7));
     writer.addDocument(doc, analyzer);
 
     writer.forceMerge(1);
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
index 735ed98..0250549 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
@@ -24,7 +24,8 @@ import java.util.Map;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FieldType.NumericType;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -100,7 +101,7 @@ public class TestCartesian extends LuceneTestCase {
     latLongType.setTokenized(true);
     latLongType.setOmitNorms(true);
     latLongType.setIndexOptions(IndexOptions.DOCS_ONLY);
-    latLongType.setNumericType(NumericField.DataType.DOUBLE);
+    latLongType.setNumericType(NumericType.DOUBLE);
     latLongType.setNumericPrecisionStep(Integer.MAX_VALUE);
     latLongType.freeze();
   }
@@ -112,8 +113,8 @@ public class TestCartesian extends LuceneTestCase {
     doc.add(newField("name", name, TextField.TYPE_STORED));
     
     // convert the lat / long to lucene fields
-    doc.add(new NumericField(latField, lat, latLongType));
-    doc.add(new NumericField(lngField, lng, latLongType));
+    doc.add(new DoubleField(latField, lat, latLongType));
+    doc.add(new DoubleField(lngField, lng, latLongType));
     
     // add a default meta field to make searching all documents easy 
     doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
@@ -121,7 +122,7 @@ public class TestCartesian extends LuceneTestCase {
     int ctpsize = ctps.size();
     for (int i =0; i < ctpsize; i++){
       CartesianTierPlotter ctp = ctps.get(i);
-      doc.add(new NumericField(ctp.getTierFieldName(), ctp.getTierBoxId(lat, lng), latLongType));
+      doc.add(new DoubleField(ctp.getTierFieldName(), ctp.getTierBoxId(lat, lng), latLongType));
       
       doc.add(newField(geoHashPrefix, GeoHashUtils.encode(lat,lng), StringField.TYPE_STORED));
     }
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
index c2b912f..cc30bf7 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
@@ -21,7 +21,8 @@ import java.io.IOException;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FieldType.NumericType;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -67,7 +68,7 @@ public class TestDistance extends LuceneTestCase {
     latLongType.setTokenized(true);
     latLongType.setOmitNorms(true);
     latLongType.setIndexOptions(IndexOptions.DOCS_ONLY);
-    latLongType.setNumericType(NumericField.DataType.DOUBLE);
+    latLongType.setNumericType(NumericType.DOUBLE);
     latLongType.setNumericPrecisionStep(Integer.MAX_VALUE);
     latLongType.freeze();
   }
@@ -79,8 +80,8 @@ public class TestDistance extends LuceneTestCase {
     doc.add(newField("name", name, TextField.TYPE_STORED));
     
     // convert the lat / long to lucene fields
-    doc.add(new NumericField(latField, lat, latLongType));
-    doc.add(new NumericField(lngField, lng, latLongType));
+    doc.add(new DoubleField(latField, lat, latLongType));
+    doc.add(new DoubleField(lngField, lng, latLongType));
     
     // add a default meta field to make searching all documents easy 
     doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
diff --git a/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java b/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
index 14e857c..069d5ce 100644
--- a/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
+++ b/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
@@ -17,33 +17,34 @@ package org.apache.lucene.analysis;
  * limitations under the License.
  */
 
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
+import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
+import org.apache.lucene.document.DoubleField; // for javadocs
+import org.apache.lucene.document.FloatField; // for javadocs
+import org.apache.lucene.document.IntField; // for javadocs
+import org.apache.lucene.document.LongField; // for javadocs
+import org.apache.lucene.search.NumericRangeFilter; // for javadocs
+import org.apache.lucene.search.NumericRangeQuery;
 import org.apache.lucene.util.Attribute;
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
-import org.apache.lucene.document.NumericField; // for javadocs
-import org.apache.lucene.search.NumericRangeQuery; // for javadocs
-import org.apache.lucene.search.NumericRangeFilter; // for javadocs
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
-import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
-import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 
 /**
  * <b>Expert:</b> This class provides a {@link TokenStream}
  * for indexing numeric values that can be used by {@link
  * NumericRangeQuery} or {@link NumericRangeFilter}.
  *
- * <p>Note that for simple usage, {@link NumericField} is
- * recommended.  {@link NumericField} disables norms and
+ * <p>Note that for simple usage, {@link IntField}, {@link
+ * LongField}, {@link FloatField} or {@link DoubleField} is
+ * recommended.  These fields disable norms and
  * term freqs, as they are not usually needed during
  * searching.  If you need to change these settings, you
  * should use this class.
  *
- * <p>See {@link NumericField} for capabilities of fields
- * indexed numerically.</p>
- *
  * <p>Here's an example usage, for an <code>int</code> field:
  *
  * <pre>
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
index b0b4770..e59ffbb 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
@@ -167,18 +167,18 @@ public abstract class DocValuesConsumer {
     case BYTES_VAR_DEREF:
     case BYTES_VAR_SORTED:
     case BYTES_VAR_STRAIGHT:
-      scratchField.setValue(source.getBytes(sourceDoc, spare));
+      scratchField.setBytesValue(source.getBytes(sourceDoc, spare));
       break;
     case FIXED_INTS_16:
     case FIXED_INTS_32:
     case FIXED_INTS_64:
     case FIXED_INTS_8:
     case VAR_INTS:
-      scratchField.setValue(source.getInt(sourceDoc));
+      scratchField.setLongValue(source.getInt(sourceDoc));
       break;
     case FLOAT_32:
     case FLOAT_64:
-      scratchField.setValue(source.getFloat(sourceDoc));
+      scratchField.setDoubleValue(source.getFloat(sourceDoc));
       break;
     }
     add(docID, scratchField);
diff --git a/lucene/core/src/java/org/apache/lucene/document/DateTools.java b/lucene/core/src/java/org/apache/lucene/document/DateTools.java
index 63424ee..9603443 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DateTools.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DateTools.java
@@ -43,7 +43,7 @@ import java.util.TimeZone;
  * date/time are.
  * For indexing a {@link Date} or {@link Calendar}, just get the unix timestamp as
  * <code>long</code> using {@link Date#getTime} or {@link Calendar#getTimeInMillis} and
- * index this as a numeric value with {@link NumericField}
+ * index this as a numeric value with {@link LongField}
  * and use {@link NumericRangeQuery} to query it.
  */
 public class DateTools {
diff --git a/lucene/core/src/java/org/apache/lucene/document/Document.java b/lucene/core/src/java/org/apache/lucene/document/Document.java
index c8d2a33..f3322f4 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Document.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Document.java
@@ -197,8 +197,9 @@ public final class Document implements Iterable<IndexableField> {
    * Returns an array of values of the field specified as the method parameter.
    * This method returns an empty array when there are no
    * matching fields.  It never returns null.
-   * For {@link NumericField}s it returns the string value of the number. If you want
-   * the actual {@code NumericField} instances back, use {@link #getFields}.
+   * For {@link IntField}, {@link LongField}, {@link
+   * FloatField} and {@link DoubleField} it returns the string value of the number. If you want
+   * the actual numeric field instances back, use {@link #getFields}.
    * @param name the name of the field
    * @return a <code>String[]</code> of field values
    */
@@ -221,8 +222,9 @@ public final class Document implements Iterable<IndexableField> {
    * this document, or null.  If multiple fields exist with this name, this
    * method returns the first value added. If only binary fields with this name
    * exist, returns null.
-   * For {@link NumericField} it returns the string value of the number. If you want
-   * the actual {@code NumericField} instance back, use {@link #getField}.
+   * For {@link IntField}, {@link LongField}, {@link
+   * FloatField} and {@link DoubleField} it returns the string value of the number. If you want
+   * the actual numeric field instance back, use {@link #getField}.
    */
   public final String get(String name) {
     for (IndexableField field : fields) {
diff --git a/lucene/core/src/java/org/apache/lucene/document/DoubleField.java b/lucene/core/src/java/org/apache/lucene/document/DoubleField.java
new file mode 100644
index 0000000..98720bb
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/DoubleField.java
@@ -0,0 +1,148 @@
+package org.apache.lucene.document;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.NumericTokenStream; // javadocs
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.search.FieldCache; // javadocs
+import org.apache.lucene.search.NumericRangeFilter; // javadocs
+import org.apache.lucene.search.NumericRangeQuery; // javadocs
+import org.apache.lucene.util.NumericUtils;
+
+/**
+ * <p>
+ * This class provides a {@link Field} that enables indexing of double values
+ * for efficient range filtering and sorting. Here's an example usage:
+ * 
+ * <pre>
+ * document.add(new DoubleField(name, 6.0));
+ * </pre>
+ * 
+ * For optimal performance, re-use the <code>DoubleField</code> and
+ * {@link Document} instance for more than one document:
+ * 
+ * <pre>
+ *  DoubleField field = new DoubleField(name, 0.0);
+ *  Document document = new Document();
+ *  document.add(field);
+ * 
+ *  for(all documents) {
+ *    ...
+ *    field.setDoubleValue(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ *
+ * See also {@link IntField}, {@link LongField}, {@link
+ * FloatField}.
+ *
+ * <p>To perform range querying or filtering against a
+ * <code>DoubleField</code>, use {@link NumericRangeQuery} or {@link
+ * NumericRangeFilter}.  To sort according to a
+ * <code>DoubleField</code>, use the normal numeric sort types, eg
+ * {@link org.apache.lucene.search.SortField.Type#DOUBLE}. <code>DoubleField</code> 
+ * values can also be loaded directly from {@link FieldCache}.</p>
+ *
+ * <p>By default, a <code>DoubleField</code>'s value is not stored but
+ * is indexed for range filtering and sorting.  You can use
+ * {@link StoredField} to also store the value.
+ *
+ * <p>You may add the same field name as an <code>DoubleField</code> to
+ * the same document more than once.  Range querying and
+ * filtering will be the logical OR of all values; so a range query
+ * will hit all documents that have at least one value in
+ * the range. However sort behavior is not defined.  If you need to sort,
+ * you should separately index a single-valued <code>DoubleField</code>.</p>
+ *
+ * <p>A <code>DoubleField</code> will consume somewhat more disk space
+ * in the index than an ordinary single-valued field.
+ * However, for a typical index that includes substantial
+ * textual content per document, this increase will likely
+ * be in the noise. </p>
+ *
+ * <p>Within Lucene, each numeric value is indexed as a
+ * <em>trie</em> structure, where each term is logically
+ * assigned to larger and larger pre-defined brackets (which
+ * are simply lower-precision representations of the value).
+ * The step size between each successive bracket is called the
+ * <code>precisionStep</code>, measured in bits.  Smaller
+ * <code>precisionStep</code> values result in larger number
+ * of brackets, which consumes more disk space in the index
+ * but may result in faster range search performance.  The
+ * default value, 4, was selected for a reasonable tradeoff
+ * of disk space consumption versus performance.  You can
+ * create a custom {@link FieldType} and invoke the {@link
+ * FieldType#setNumericPrecisionStep} method if you'd
+ * like to change the value.  Note that you must also
+ * specify a congruent value when creating {@link
+ * NumericRangeQuery} or {@link NumericRangeFilter}.
+ * For low cardinality fields larger precision steps are good.
+ * If the cardinality is &lt; 100, it is fair
+ * to use {@link Integer#MAX_VALUE}, which produces one
+ * term per value.
+ *
+ * <p>For more information on the internals of numeric trie
+ * indexing, including the <a
+ * href="../search/NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>
+ * configuration, see {@link NumericRangeQuery}. The format of
+ * indexed values is described in {@link NumericUtils}.
+ *
+ * <p>If you only need to sort by numeric value, and never
+ * run range querying/filtering, you can index using a
+ * <code>precisionStep</code> of {@link Integer#MAX_VALUE}.
+ * This will minimize disk space consumed. </p>
+ *
+ * <p>More advanced users can instead use {@link
+ * NumericTokenStream} directly, when indexing numbers. This
+ * class is a wrapper around this token stream type for
+ * easier, more intuitive usage.</p>
+ *
+ * @since 2.9
+ */
+
+public final class DoubleField extends Field {
+  
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setIndexed(true);
+    TYPE.setTokenized(true);
+    TYPE.setOmitNorms(true);
+    TYPE.setIndexOptions(IndexOptions.DOCS_ONLY);
+    TYPE.setNumericType(FieldType.NumericType.DOUBLE);
+    TYPE.freeze();
+  }
+
+  /** Creates an LongField with the provided value
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
+  public DoubleField(String name, double value) {
+    super(name, TYPE);
+    fieldsData = Double.valueOf(value);
+  }
+  
+  /** Expert: allows you to customize the {@link
+   *  FieldType}. */
+  public DoubleField(String name, double value, FieldType type) {
+    super(name, type);
+    if (type.numericType() != FieldType.NumericType.DOUBLE) {
+      throw new IllegalArgumentException("type.numericType() must be DOUBLE but got " + type.numericType());
+    }
+    fieldsData = Double.valueOf(value);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/Field.java b/lucene/core/src/java/org/apache/lucene/document/Field.java
index e20e035..0e39759 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Field.java
@@ -26,6 +26,7 @@ import org.apache.lucene.analysis.NumericTokenStream;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.index.IndexWriter; // javadocs
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.IndexableFieldType;
@@ -35,7 +36,8 @@ import org.apache.lucene.util.BytesRef;
 /**
  * Expert: directly creata a field for a document.  Most
  * users should use one of the sugar subclasses: {@link
- * NumericField}, {@link DocValuesField}, {@link
+ * IntField}, {@link LongField}, {@link FloatField}, {@link
+ * DoubleField}, {@link DocValuesField}, {@link
  * StringField}, {@link TextField}, {@link StoredField}.
  *
  * <p/> A field is a section of a Document. Each field has three
@@ -159,6 +161,8 @@ public class Field implements IndexableField {
     this.name = name;
   }
 
+  // TODO: allow direct construction of int, long, float, double value too..?
+
   /**
    * Create field with String value.
    */
@@ -184,54 +188,6 @@ public class Field implements IndexableField {
   }
 
   /**
-   * Create field with an int value.
-   */
-  public Field(String name, int value, FieldType type) {
-    if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
-    }
-    this.type = type;
-    this.name = name;
-    this.fieldsData = Integer.valueOf(value);
-  }
-
-  /**
-   * Create field with an long value.
-   */
-  public Field(String name, long value, FieldType type) {
-    if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
-    }
-    this.type = type;
-    this.name = name;
-    this.fieldsData = Long.valueOf(value);
-  }
-
-  /**
-   * Create field with a float value.
-   */
-  public Field(String name, float value, FieldType type) {
-    if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
-    }
-    this.type = type;
-    this.name = name;
-    this.fieldsData = Float.valueOf(value);
-  }
-
-  /**
-   * Create field with a double value.
-   */
-  public Field(String name, double value, FieldType type) {
-    if (name == null) {
-      throw new IllegalArgumentException("name cannot be null");
-    }
-    this.type = type;
-    this.name = name;
-    this.fieldsData = Double.valueOf(value);
-  }
-
-  /**
    * The value of the field as a String, or null. If null, the Reader value or
    * binary value is used. Exactly one of stringValue(), readerValue(), and
    * getBinaryValue() must be set.
@@ -273,7 +229,7 @@ public class Field implements IndexableField {
    * >ImproveIndexingSpeed</a> for details.
    * </p>
    */
-  public void setValue(String value) {
+  public void setStringValue(String value) {
     if (!(fieldsData instanceof String)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to String");
     }
@@ -284,7 +240,7 @@ public class Field implements IndexableField {
    * Expert: change the value of this field. See <a
    * href="#setValue(java.lang.String)">setValue(String)</a>.
    */
-  public void setValue(Reader value) {
+  public void setReaderValue(Reader value) {
     if (!(fieldsData instanceof Reader)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Reader");
     }
@@ -295,8 +251,8 @@ public class Field implements IndexableField {
    * Expert: change the value of this field. See <a
    * href="#setValue(java.lang.String)">setValue(String)</a>.
    */
-  public void setValue(byte[] value) {
-    setValue(new BytesRef(value));
+  public void setBytesValue(byte[] value) {
+    setBytesValue(new BytesRef(value));
   }
 
   /**
@@ -306,7 +262,7 @@ public class Field implements IndexableField {
    * <p>NOTE: the provided BytesRef is not copied so be sure
    * not to change it until you're done with this field.
    */
-  public void setValue(BytesRef value) {
+  public void setBytesValue(BytesRef value) {
     if (!(fieldsData instanceof BytesRef)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to BytesRef");
     }
@@ -316,7 +272,7 @@ public class Field implements IndexableField {
     fieldsData = value;
   }
 
-  public void setValue(int value) {
+  public void setIntValue(int value) {
     if (!(fieldsData instanceof Integer)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Integer");
     }
@@ -326,7 +282,7 @@ public class Field implements IndexableField {
     fieldsData = Integer.valueOf(value);
   }
 
-  public void setValue(long value) {
+  public void setLongValue(long value) {
     if (!(fieldsData instanceof Long)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Long");
     }
@@ -336,7 +292,7 @@ public class Field implements IndexableField {
     fieldsData = Long.valueOf(value);
   }
 
-  public void setValue(float value) {
+  public void setFloatValue(float value) {
     if (!(fieldsData instanceof Float)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Float");
     }
@@ -346,7 +302,7 @@ public class Field implements IndexableField {
     fieldsData = Float.valueOf(value);
   }
 
-  public void setValue(double value) {
+  public void setDoubleValue(double value) {
     if (!(fieldsData instanceof Double)) {
       throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Double");
     }
@@ -443,7 +399,7 @@ public class Field implements IndexableField {
       return null;
     }
 
-    final NumericField.DataType numericType = fieldType().numericType();
+    final NumericType numericType = fieldType().numericType();
     if (numericType != null) {
       if (numericTokenStream == null) {
         // lazy init the TokenStream as it is heavy to instantiate
diff --git a/lucene/core/src/java/org/apache/lucene/document/FieldType.java b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
index 319b65f..28e7c75 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FieldType.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FieldType.java
@@ -25,6 +25,11 @@ import org.apache.lucene.util.NumericUtils;
 
 public class FieldType implements IndexableFieldType {
 
+  /** Data type of the numeric value
+   * @since 3.2
+   */
+  public static enum NumericType {INT, LONG, FLOAT, DOUBLE}
+
   private boolean indexed;
   private boolean stored;
   private boolean tokenized;
@@ -34,7 +39,7 @@ public class FieldType implements IndexableFieldType {
   private boolean omitNorms;
   private IndexOptions indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
   private DocValues.Type docValueType;
-  private NumericField.DataType numericType;
+  private NumericType numericType;
   private boolean frozen;
   private int numericPrecisionStep = NumericUtils.PRECISION_STEP_DEFAULT;
 
@@ -152,16 +157,16 @@ public class FieldType implements IndexableFieldType {
     return docValueType;
   }
 
-  public void setNumericType(NumericField.DataType type) {
+  public void setNumericType(NumericType type) {
     checkIfFrozen();
     numericType = type;
   }
 
-  /** Numeric {@link NumericField.DataType}; if
+  /** NumericDataType; if
    *  non-null then the field's value will be indexed
    *  numerically so that {@link NumericRangeQuery} can be
    *  used at search time. */
-  public NumericField.DataType numericType() {
+  public NumericType numericType() {
     return numericType;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatField.java b/lucene/core/src/java/org/apache/lucene/document/FloatField.java
new file mode 100644
index 0000000..8a3dbf7
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatField.java
@@ -0,0 +1,148 @@
+package org.apache.lucene.document;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.NumericTokenStream; // javadocs
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.search.FieldCache; // javadocs
+import org.apache.lucene.search.NumericRangeFilter; // javadocs
+import org.apache.lucene.search.NumericRangeQuery; // javadocs
+import org.apache.lucene.util.NumericUtils;
+
+/**
+ * <p>
+ * This class provides a {@link Field} that enables indexing of float values
+ * for efficient range filtering and sorting. Here's an example usage:
+ * 
+ * <pre>
+ * document.add(new FloatField(name, 6.0F));
+ * </pre>
+ * 
+ * For optimal performance, re-use the <code>FloatField</code> and
+ * {@link Document} instance for more than one document:
+ * 
+ * <pre>
+ *  FloatField field = new FloatField(name, 0.0F);
+ *  Document document = new Document();
+ *  document.add(field);
+ * 
+ *  for(all documents) {
+ *    ...
+ *    field.setFloatValue(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ *
+ * See also {@link IntField}, {@link LongField}, {@link
+ * DoubleField}.
+ *
+ * <p>To perform range querying or filtering against a
+ * <code>FloatField</code>, use {@link NumericRangeQuery} or {@link
+ * NumericRangeFilter}.  To sort according to a
+ * <code>FloatField</code>, use the normal numeric sort types, eg
+ * {@link org.apache.lucene.search.SortField.Type#FLOAT}. <code>FloatField</code> 
+ * values can also be loaded directly from {@link FieldCache}.</p>
+ *
+ * <p>By default, a <code>FloatField</code>'s value is not stored but
+ * is indexed for range filtering and sorting.  You can use
+ * {@link StoredField} to also store the value.
+ *
+ * <p>You may add the same field name as an <code>FloatField</code> to
+ * the same document more than once.  Range querying and
+ * filtering will be the logical OR of all values; so a range query
+ * will hit all documents that have at least one value in
+ * the range. However sort behavior is not defined.  If you need to sort,
+ * you should separately index a single-valued <code>FloatField</code>.</p>
+ *
+ * <p>A <code>FloatField</code> will consume somewhat more disk space
+ * in the index than an ordinary single-valued field.
+ * However, for a typical index that includes substantial
+ * textual content per document, this increase will likely
+ * be in the noise. </p>
+ *
+ * <p>Within Lucene, each numeric value is indexed as a
+ * <em>trie</em> structure, where each term is logically
+ * assigned to larger and larger pre-defined brackets (which
+ * are simply lower-precision representations of the value).
+ * The step size between each successive bracket is called the
+ * <code>precisionStep</code>, measured in bits.  Smaller
+ * <code>precisionStep</code> values result in larger number
+ * of brackets, which consumes more disk space in the index
+ * but may result in faster range search performance.  The
+ * default value, 4, was selected for a reasonable tradeoff
+ * of disk space consumption versus performance.  You can
+ * create a custom {@link FieldType} and invoke the {@link
+ * FieldType#setNumericPrecisionStep} method if you'd
+ * like to change the value.  Note that you must also
+ * specify a congruent value when creating {@link
+ * NumericRangeQuery} or {@link NumericRangeFilter}.
+ * For low cardinality fields larger precision steps are good.
+ * If the cardinality is &lt; 100, it is fair
+ * to use {@link Integer#MAX_VALUE}, which produces one
+ * term per value.
+ *
+ * <p>For more information on the internals of numeric trie
+ * indexing, including the <a
+ * href="../search/NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>
+ * configuration, see {@link NumericRangeQuery}. The format of
+ * indexed values is described in {@link NumericUtils}.
+ *
+ * <p>If you only need to sort by numeric value, and never
+ * run range querying/filtering, you can index using a
+ * <code>precisionStep</code> of {@link Integer#MAX_VALUE}.
+ * This will minimize disk space consumed. </p>
+ *
+ * <p>More advanced users can instead use {@link
+ * NumericTokenStream} directly, when indexing numbers. This
+ * class is a wrapper around this token stream type for
+ * easier, more intuitive usage.</p>
+ *
+ * @since 2.9
+ */
+
+public final class FloatField extends Field {
+  
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setIndexed(true);
+    TYPE.setTokenized(true);
+    TYPE.setOmitNorms(true);
+    TYPE.setIndexOptions(IndexOptions.DOCS_ONLY);
+    TYPE.setNumericType(FieldType.NumericType.FLOAT);
+    TYPE.freeze();
+  }
+
+  /** Creates an LongField with the provided value
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
+  public FloatField(String name, float value) {
+    super(name, TYPE);
+    fieldsData = Float.valueOf(value);
+  }
+  
+  /** Expert: allows you to customize the {@link
+   *  FieldType}. */
+  public FloatField(String name, float value, FieldType type) {
+    super(name, type);
+    if (type.numericType() != FieldType.NumericType.FLOAT) {
+      throw new IllegalArgumentException("type.numericType() must be FLOAT but got " + type.numericType());
+    }
+    fieldsData = Float.valueOf(value);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntField.java b/lucene/core/src/java/org/apache/lucene/document/IntField.java
new file mode 100644
index 0000000..27c3358
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/IntField.java
@@ -0,0 +1,148 @@
+package org.apache.lucene.document;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.NumericTokenStream; // javadocs
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.search.FieldCache; // javadocs
+import org.apache.lucene.search.NumericRangeFilter; // javadocs
+import org.apache.lucene.search.NumericRangeQuery; // javadocs
+import org.apache.lucene.util.NumericUtils;
+
+/**
+ * <p>
+ * This class provides a {@link Field} that enables indexing of integer values
+ * for efficient range filtering and sorting. Here's an example usage:
+ * 
+ * <pre>
+ * document.add(new IntField(name, 6));
+ * </pre>
+ * 
+ * For optimal performance, re-use the <code>IntField</code> and
+ * {@link Document} instance for more than one document:
+ * 
+ * <pre>
+ *  IntField field = new IntField(name, 6);
+ *  Document document = new Document();
+ *  document.add(field);
+ * 
+ *  for(all documents) {
+ *    ...
+ *    field.setIntValue(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ *
+ * See also {@link LongField}, {@link FloatField}, {@link
+ * DoubleField}.
+ *
+ * <p>To perform range querying or filtering against a
+ * <code>IntField</code>, use {@link NumericRangeQuery} or {@link
+ * NumericRangeFilter}.  To sort according to a
+ * <code>IntField</code>, use the normal numeric sort types, eg
+ * {@link org.apache.lucene.search.SortField.Type#INT}. <code>IntField</code> 
+ * values can also be loaded directly from {@link FieldCache}.</p>
+ *
+ * <p>By default, a <code>IntField</code>'s value is not stored but
+ * is indexed for range filtering and sorting.  You can use
+ * {@link StoredField} to also store the value.
+ *
+ * <p>You may add the same field name as an <code>IntField</code> to
+ * the same document more than once.  Range querying and
+ * filtering will be the logical OR of all values; so a range query
+ * will hit all documents that have at least one value in
+ * the range. However sort behavior is not defined.  If you need to sort,
+ * you should separately index a single-valued <code>IntField</code>.</p>
+ *
+ * <p>An <code>IntField</code> will consume somewhat more disk space
+ * in the index than an ordinary single-valued field.
+ * However, for a typical index that includes substantial
+ * textual content per document, this increase will likely
+ * be in the noise. </p>
+ *
+ * <p>Within Lucene, each numeric value is indexed as a
+ * <em>trie</em> structure, where each term is logically
+ * assigned to larger and larger pre-defined brackets (which
+ * are simply lower-precision representations of the value).
+ * The step size between each successive bracket is called the
+ * <code>precisionStep</code>, measured in bits.  Smaller
+ * <code>precisionStep</code> values result in larger number
+ * of brackets, which consumes more disk space in the index
+ * but may result in faster range search performance.  The
+ * default value, 4, was selected for a reasonable tradeoff
+ * of disk space consumption versus performance.  You can
+ * create a custom {@link FieldType} and invoke the {@link
+ * FieldType#setNumericPrecisionStep} method if you'd
+ * like to change the value.  Note that you must also
+ * specify a congruent value when creating {@link
+ * NumericRangeQuery} or {@link NumericRangeFilter}.
+ * For low cardinality fields larger precision steps are good.
+ * If the cardinality is &lt; 100, it is fair
+ * to use {@link Integer#MAX_VALUE}, which produces one
+ * term per value.
+ *
+ * <p>For more information on the internals of numeric trie
+ * indexing, including the <a
+ * href="../search/NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>
+ * configuration, see {@link NumericRangeQuery}. The format of
+ * indexed values is described in {@link NumericUtils}.
+ *
+ * <p>If you only need to sort by numeric value, and never
+ * run range querying/filtering, you can index using a
+ * <code>precisionStep</code> of {@link Integer#MAX_VALUE}.
+ * This will minimize disk space consumed. </p>
+ *
+ * <p>More advanced users can instead use {@link
+ * NumericTokenStream} directly, when indexing numbers. This
+ * class is a wrapper around this token stream type for
+ * easier, more intuitive usage.</p>
+ *
+ * @since 2.9
+ */
+
+public final class IntField extends Field {
+  
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setIndexed(true);
+    TYPE.setTokenized(true);
+    TYPE.setOmitNorms(true);
+    TYPE.setIndexOptions(IndexOptions.DOCS_ONLY);
+    TYPE.setNumericType(FieldType.NumericType.INT);
+    TYPE.freeze();
+  }
+
+  /** Creates an IntField with the provided value
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
+  public IntField(String name, int value) {
+    super(name, TYPE);
+    fieldsData = Integer.valueOf(value);
+  }
+  
+  /** Expert: allows you to customize the {@link
+   *  FieldType}. */
+  public IntField(String name, int value, FieldType type) {
+    super(name, type);
+    if (type.numericType() != FieldType.NumericType.INT) {
+      throw new IllegalArgumentException("type.numericType() must be INT but got " + type.numericType());
+    }
+    fieldsData = Integer.valueOf(value);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongField.java b/lucene/core/src/java/org/apache/lucene/document/LongField.java
new file mode 100644
index 0000000..b673a64
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/LongField.java
@@ -0,0 +1,158 @@
+package org.apache.lucene.document;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.NumericTokenStream; // javadocs
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.search.FieldCache; // javadocs
+import org.apache.lucene.search.NumericRangeFilter; // javadocs
+import org.apache.lucene.search.NumericRangeQuery; // javadocs
+import org.apache.lucene.util.NumericUtils;
+
+/**
+ * <p>
+ * This class provides a {@link Field} that enables indexing of long values
+ * for efficient range filtering and sorting. Here's an example usage:
+ * 
+ * <pre>
+ * document.add(new LongField(name, 6L));
+ * </pre>
+ * 
+ * For optimal performance, re-use the <code>LongField</code> and
+ * {@link Document} instance for more than one document:
+ * 
+ * <pre>
+ *  LongField field = new LongField(name, 0L);
+ *  Document document = new Document();
+ *  document.add(field);
+ * 
+ *  for(all documents) {
+ *    ...
+ *    field.setLongValue(value)
+ *    writer.addDocument(document);
+ *    ...
+ *  }
+ * </pre>
+ *
+ * See also {@link IntField}, {@link FloatField}, {@link
+ * DoubleField}.
+ *
+ * Any type that can be converted to long can also be
+ * indexed.  For example, date/time values represented by a
+ * {@link java.util.Date} can be translated into a long
+ * value using the {@link java.util.Date#getTime} method.  If you
+ * don't need millisecond precision, you can quantize the
+ * value, either by dividing the result of
+ * {@link java.util.Date#getTime} or using the separate getters
+ * (for year, month, etc.) to construct an <code>int</code> or
+ * <code>long</code> value.</p>
+ *
+ * <p>To perform range querying or filtering against a
+ * <code>LongField</code>, use {@link NumericRangeQuery} or {@link
+ * NumericRangeFilter}.  To sort according to a
+ * <code>LongField</code>, use the normal numeric sort types, eg
+ * {@link org.apache.lucene.search.SortField.Type#LONG}. <code>LongField</code> 
+ * values can also be loaded directly from {@link FieldCache}.</p>
+ *
+ * <p>By default, a <code>LongField</code>'s value is not stored but
+ * is indexed for range filtering and sorting.  You can use
+ * {@link StoredField} to also store the value.
+ *
+ * <p>You may add the same field name as an <code>LongField</code> to
+ * the same document more than once.  Range querying and
+ * filtering will be the logical OR of all values; so a range query
+ * will hit all documents that have at least one value in
+ * the range. However sort behavior is not defined.  If you need to sort,
+ * you should separately index a single-valued <code>LongField</code>.</p>
+ *
+ * <p>A <code>LongField</code> will consume somewhat more disk space
+ * in the index than an ordinary single-valued field.
+ * However, for a typical index that includes substantial
+ * textual content per document, this increase will likely
+ * be in the noise. </p>
+ *
+ * <p>Within Lucene, each numeric value is indexed as a
+ * <em>trie</em> structure, where each term is logically
+ * assigned to larger and larger pre-defined brackets (which
+ * are simply lower-precision representations of the value).
+ * The step size between each successive bracket is called the
+ * <code>precisionStep</code>, measured in bits.  Smaller
+ * <code>precisionStep</code> values result in larger number
+ * of brackets, which consumes more disk space in the index
+ * but may result in faster range search performance.  The
+ * default value, 4, was selected for a reasonable tradeoff
+ * of disk space consumption versus performance.  You can
+ * create a custom {@link FieldType} and invoke the {@link
+ * FieldType#setNumericPrecisionStep} method if you'd
+ * like to change the value.  Note that you must also
+ * specify a congruent value when creating {@link
+ * NumericRangeQuery} or {@link NumericRangeFilter}.
+ * For low cardinality fields larger precision steps are good.
+ * If the cardinality is &lt; 100, it is fair
+ * to use {@link Integer#MAX_VALUE}, which produces one
+ * term per value.
+ *
+ * <p>For more information on the internals of numeric trie
+ * indexing, including the <a
+ * href="../search/NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>
+ * configuration, see {@link NumericRangeQuery}. The format of
+ * indexed values is described in {@link NumericUtils}.
+ *
+ * <p>If you only need to sort by numeric value, and never
+ * run range querying/filtering, you can index using a
+ * <code>precisionStep</code> of {@link Integer#MAX_VALUE}.
+ * This will minimize disk space consumed. </p>
+ *
+ * <p>More advanced users can instead use {@link
+ * NumericTokenStream} directly, when indexing numbers. This
+ * class is a wrapper around this token stream type for
+ * easier, more intuitive usage.</p>
+ *
+ * @since 2.9
+ */
+
+public final class LongField extends Field {
+  
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setIndexed(true);
+    TYPE.setTokenized(true);
+    TYPE.setOmitNorms(true);
+    TYPE.setIndexOptions(IndexOptions.DOCS_ONLY);
+    TYPE.setNumericType(FieldType.NumericType.LONG);
+    TYPE.freeze();
+  }
+
+  /** Creates an LongField with the provided value
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
+  public LongField(String name, long value) {
+    super(name, TYPE);
+    fieldsData = Long.valueOf(value);
+  }
+  
+  /** Expert: allows you to customize the {@link
+   *  FieldType}. */
+  public LongField(String name, long value, FieldType type) {
+    super(name, type);
+    if (type.numericType() != FieldType.NumericType.LONG) {
+      throw new IllegalArgumentException("type.numericType() must be LONG but got " + type.numericType());
+    }
+    fieldsData = Long.valueOf(value);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/NumericField.java b/lucene/core/src/java/org/apache/lucene/document/NumericField.java
deleted file mode 100644
index 7769e81..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/NumericField.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package org.apache.lucene.document;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.analysis.NumericTokenStream; // javadocs
-import org.apache.lucene.document.NumericField.DataType;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.search.FieldCache; // javadocs
-import org.apache.lucene.search.NumericRangeFilter; // javadocs
-import org.apache.lucene.search.NumericRangeQuery; // javadocs
-import org.apache.lucene.util.NumericUtils;
-
-/**
- * <p>
- * This class provides a {@link Field} that enables indexing of numeric values
- * for efficient range filtering and sorting. Here's an example usage, adding an
- * int value:
- * 
- * <pre>
- * document.add(new NumericField(name, value));
- * </pre>
- * 
- * For optimal performance, re-use the <code>NumericField</code> and
- * {@link Document} instance for more than one document:
- * 
- * <pre>
- *  NumericField field = new NumericField(name, NumericField.DataType.INT);
- *  Document document = new Document();
- *  document.add(field);
- * 
- *  for(all documents) {
- *    ...
- *    field.setValue(value)
- *    writer.addDocument(document);
- *    ...
- *  }
- * </pre>
- *
- * <p>The java native types <code>int</code>, <code>long</code>,
- * <code>float</code> and <code>double</code> are
- * directly supported.  However, any value that can be
- * converted into these native types can also be indexed.
- * For example, date/time values represented by a
- * {@link java.util.Date} can be translated into a long
- * value using the {@link java.util.Date#getTime} method.  If you
- * don't need millisecond precision, you can quantize the
- * value, either by dividing the result of
- * {@link java.util.Date#getTime} or using the separate getters
- * (for year, month, etc.) to construct an <code>int</code> or
- * <code>long</code> value.</p>
- *
- * <p>To perform range querying or filtering against a
- * <code>NumericField</code>, use {@link NumericRangeQuery} or {@link
- * NumericRangeFilter}.  To sort according to a
- * <code>NumericField</code>, use the normal numeric sort types, eg
- * {@link org.apache.lucene.search.SortField.Type#INT}. <code>NumericField</code> 
- * values can also be loaded directly from {@link FieldCache}.</p>
- *
- * <p>By default, a <code>NumericField</code>'s value is not stored but
- * is indexed for range filtering and sorting.  You can use
- * {@link Field#Field(String,int,FieldType)}, etc.,
- * if you need to change these defaults.</p>
- *
- * <p>You may add the same field name as a <code>NumericField</code> to
- * the same document more than once.  Range querying and
- * filtering will be the logical OR of all values; so a range query
- * will hit all documents that have at least one value in
- * the range. However sort behavior is not defined.  If you need to sort,
- * you should separately index a single-valued <code>NumericField</code>.</p>
- *
- * <p>A <code>NumericField</code> will consume somewhat more disk space
- * in the index than an ordinary single-valued field.
- * However, for a typical index that includes substantial
- * textual content per document, this increase will likely
- * be in the noise. </p>
- *
- * <p>Within Lucene, each numeric value is indexed as a
- * <em>trie</em> structure, where each term is logically
- * assigned to larger and larger pre-defined brackets (which
- * are simply lower-precision representations of the value).
- * The step size between each successive bracket is called the
- * <code>precisionStep</code>, measured in bits.  Smaller
- * <code>precisionStep</code> values result in larger number
- * of brackets, which consumes more disk space in the index
- * but may result in faster range search performance.  The
- * default value, 4, was selected for a reasonable tradeoff
- * of disk space consumption versus performance.  You can
- * create a custom {@link FieldType} and invoke the {@link
- * FieldType#setNumericPrecisionStep} method if you'd
- * like to change the value.  Note that you must also
- * specify a congruent value when creating {@link
- * NumericRangeQuery} or {@link NumericRangeFilter}.
- * For low cardinality fields larger precision steps are good.
- * If the cardinality is &lt; 100, it is fair
- * to use {@link Integer#MAX_VALUE}, which produces one
- * term per value.
- *
- * <p>For more information on the internals of numeric trie
- * indexing, including the <a
- * href="../search/NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>
- * configuration, see {@link NumericRangeQuery}. The format of
- * indexed values is described in {@link NumericUtils}.
- *
- * <p>If you only need to sort by numeric value, and never
- * run range querying/filtering, you can index using a
- * <code>precisionStep</code> of {@link Integer#MAX_VALUE}.
- * This will minimize disk space consumed. </p>
- *
- * <p>More advanced users can instead use {@link
- * NumericTokenStream} directly, when indexing numbers. This
- * class is a wrapper around this token stream type for
- * easier, more intuitive usage.</p>
- *
- * @since 2.9
- */
-public final class NumericField extends Field {
-  
-  /** Data type of the value in {@link NumericField}.
-   * @since 3.2
-   */
-  public static enum DataType {INT, LONG, FLOAT, DOUBLE}
-
-  /** @lucene.experimental */
-  public static FieldType getFieldType(DataType type, boolean stored) {
-    final FieldType ft = new FieldType();
-    ft.setIndexed(true);
-    ft.setStored(stored);
-    ft.setTokenized(true);
-    ft.setOmitNorms(true);
-    ft.setIndexOptions(IndexOptions.DOCS_ONLY);
-    ft.setNumericType(type);
-    ft.freeze();
-    return ft;
-  }
-
-  private static final FieldType INT_TYPE = getFieldType(DataType.INT, false);
-  private static final FieldType LONG_TYPE = getFieldType(DataType.LONG, false);
-  private static final FieldType FLOAT_TYPE = getFieldType(DataType.FLOAT, false);
-  private static final FieldType DOUBLE_TYPE = getFieldType(DataType.DOUBLE, false);
-
-  /** Creates an int NumericField with the provided value
-   *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
-  public NumericField(String name, int value) {
-    super(name, INT_TYPE);
-    fieldsData = Integer.valueOf(value);
-  }
-
-  /** Creates a long NumericField with the provided value.
-   *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
-  public NumericField(String name, long value) {
-    super(name, LONG_TYPE);
-    fieldsData = Long.valueOf(value);
-  }
-
-  /** Creates a float NumericField with the provided value.
-   *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
-  public NumericField(String name, float value) {
-    super(name, FLOAT_TYPE);
-    fieldsData = Float.valueOf(value);
-  }
-
-  /** Creates a double NumericField with the provided value.
-   *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
-  public NumericField(String name, double value) {
-    super(name, DOUBLE_TYPE);
-    fieldsData = Double.valueOf(value);
-  }
-  
-  public NumericField(String name, Number value, FieldType type) {
-    super(name, type);
-    final NumericField.DataType numericType = type.numericType();
-    if (numericType == null) {
-      throw new IllegalArgumentException("FieldType.numericType() cannot be null");
-    }
-
-    switch(numericType) {
-    case INT:
-      if (!(value instanceof Integer)) {
-        throw new IllegalArgumentException("value must be an Integer but got " + value);
-      }
-      break;
-    case LONG:
-      if (!(value instanceof Long)) {
-        throw new IllegalArgumentException("value must be a Long but got " + value);
-      }
-      break;
-    case FLOAT:
-      if (!(value instanceof Float)) {
-        throw new IllegalArgumentException("value must be a Float but got " + value);
-      }
-      break;
-    case DOUBLE:
-      if (!(value instanceof Double)) {
-        throw new IllegalArgumentException("value must be a Double but got " + value);
-      }
-      break;
-    default:
-      assert false : "Should never get here";
-    }
-
-    fieldsData = value;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/package.html b/lucene/core/src/java/org/apache/lucene/document/package.html
index 659cc74..31894ca 100644
--- a/lucene/core/src/java/org/apache/lucene/document/package.html
+++ b/lucene/core/src/java/org/apache/lucene/document/package.html
@@ -41,7 +41,8 @@ package also provides utilities for working with {@link org.apache.lucene.docume
   for extracting content from HTML.
 </p>
 <p>The {@link org.apache.lucene.document.DateTools} is a utility class to make dates and times searchable
-(remember, Lucene only searches text). {@link org.apache.lucene.document.NumericField} is a special helper class
+(remember, Lucene only searches text). {@link org.apache.lucene.document.IntField}, {@link org.apache.lucene.document.LongField},
+{@link org.apache.lucene.document.FloatField} and {@link org.apache.lucene.document.DoubleField} are a special helper class
 to simplify indexing of numeric values (and also dates) for fast range range queries with {@link org.apache.lucene.search.NumericRangeQuery}
 (using a special sortable string representation of numeric values).</p>
 </body>
diff --git a/lucene/core/src/java/org/apache/lucene/index/Norm.java b/lucene/core/src/java/org/apache/lucene/index/Norm.java
index 42ff0e8..b99f982 100644
--- a/lucene/core/src/java/org/apache/lucene/index/Norm.java
+++ b/lucene/core/src/java/org/apache/lucene/index/Norm.java
@@ -65,7 +65,7 @@ public final class Norm  {
    */
   public void setFloat(float norm) {
     setType(Type.FLOAT_32);
-    this.field.setValue(norm);
+    this.field.setFloatValue(norm);
   }
 
   /**
@@ -73,7 +73,7 @@ public final class Norm  {
    */
   public void setDouble(double norm) {
     setType(Type.FLOAT_64);
-    this.field.setValue(norm);
+    this.field.setDoubleValue(norm);
   }
 
   /**
@@ -81,7 +81,7 @@ public final class Norm  {
    */
   public void setShort(short norm) {
     setType(Type.FIXED_INTS_16);
-    this.field.setValue(norm);
+    this.field.setIntValue(norm);
     
   }
 
@@ -90,7 +90,7 @@ public final class Norm  {
    */
   public void setInt(int norm) {
     setType(Type.FIXED_INTS_32);
-    this.field.setValue(norm);
+    this.field.setIntValue(norm);
   }
 
   /**
@@ -98,7 +98,7 @@ public final class Norm  {
    */
   public void setLong(long norm) {
     setType(Type.FIXED_INTS_64);
-    this.field.setValue(norm);
+    this.field.setLongValue(norm);
   }
 
   /**
@@ -106,7 +106,7 @@ public final class Norm  {
    */
   public void setByte(byte norm) {
     setType(Type.FIXED_INTS_8);
-    this.field.setValue(norm);
+    this.field.setIntValue(norm);
   }
 
   /**
@@ -114,7 +114,7 @@ public final class Norm  {
    */
   public void setBytes(BytesRef norm) {
     setType(Type.BYTES_FIXED_STRAIGHT);
-    this.field.setValue(norm);
+    this.field.setBytesValue(norm);
   }
 
   
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldCache.java b/lucene/core/src/java/org/apache/lucene/search/FieldCache.java
index 27c432a..76ef209 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldCache.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldCache.java
@@ -22,7 +22,10 @@ import java.io.PrintStream;
 import java.text.DecimalFormat;
 
 import org.apache.lucene.analysis.NumericTokenStream; // for javadocs
-import org.apache.lucene.document.NumericField; // for javadocs
+import org.apache.lucene.document.IntField; // for javadocs
+import org.apache.lucene.document.FloatField; // for javadocs
+import org.apache.lucene.document.LongField; // for javadocs
+import org.apache.lucene.document.DoubleField; // for javadocs
 import org.apache.lucene.index.DocTermOrds;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.TermsEnum;
@@ -118,7 +121,7 @@ public interface FieldCache {
     public byte parseByte(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // IntField, instead, which already decodes
       // directly from byte[]
       return Byte.parseByte(term.utf8ToString());
     }
@@ -136,7 +139,7 @@ public interface FieldCache {
     public short parseShort(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // IntField, instead, which already decodes
       // directly from byte[]
       return Short.parseShort(term.utf8ToString());
     }
@@ -154,7 +157,7 @@ public interface FieldCache {
     public int parseInt(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // IntField, instead, which already decodes
       // directly from byte[]
       return Integer.parseInt(term.utf8ToString());
     }
@@ -172,7 +175,7 @@ public interface FieldCache {
     public float parseFloat(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // FloatField, instead, which already decodes
       // directly from byte[]
       return Float.parseFloat(term.utf8ToString());
     }
@@ -190,7 +193,7 @@ public interface FieldCache {
     public long parseLong(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // LongField, instead, which already decodes
       // directly from byte[]
       return Long.parseLong(term.utf8ToString());
     }
@@ -208,7 +211,7 @@ public interface FieldCache {
     public double parseDouble(BytesRef term) {
       // TODO: would be far better to directly parse from
       // UTF8 bytes... but really users should use
-      // NumericField, instead, which already decodes
+      // DoubleField, instead, which already decodes
       // directly from byte[]
       return Double.parseDouble(term.utf8ToString());
     }
@@ -223,7 +226,7 @@ public interface FieldCache {
 
   /**
    * A parser instance for int values encoded by {@link NumericUtils}, e.g. when indexed
-   * via {@link NumericField}/{@link NumericTokenStream}.
+   * via {@link IntField}/{@link NumericTokenStream}.
    */
   public static final IntParser NUMERIC_UTILS_INT_PARSER=new IntParser(){
     public int parseInt(BytesRef term) {
@@ -242,7 +245,7 @@ public interface FieldCache {
 
   /**
    * A parser instance for float values encoded with {@link NumericUtils}, e.g. when indexed
-   * via {@link NumericField}/{@link NumericTokenStream}.
+   * via {@link FloatField}/{@link NumericTokenStream}.
    */
   public static final FloatParser NUMERIC_UTILS_FLOAT_PARSER=new FloatParser(){
     public float parseFloat(BytesRef term) {
@@ -261,7 +264,7 @@ public interface FieldCache {
 
   /**
    * A parser instance for long values encoded by {@link NumericUtils}, e.g. when indexed
-   * via {@link NumericField}/{@link NumericTokenStream}.
+   * via {@link LongField}/{@link NumericTokenStream}.
    */
   public static final LongParser NUMERIC_UTILS_LONG_PARSER = new LongParser(){
     public long parseLong(BytesRef term) {
@@ -280,7 +283,7 @@ public interface FieldCache {
 
   /**
    * A parser instance for double values encoded with {@link NumericUtils}, e.g. when indexed
-   * via {@link NumericField}/{@link NumericTokenStream}.
+   * via {@link DoubleField}/{@link NumericTokenStream}.
    */
   public static final DoubleParser NUMERIC_UTILS_DOUBLE_PARSER = new DoubleParser(){
     public double parseDouble(BytesRef term) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java b/lucene/core/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
index 0fd44f8..c84bd19 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
@@ -20,10 +20,13 @@ import java.io.IOException;
 
 import org.apache.lucene.index.AtomicReader; // for javadocs
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.document.IntField; // for javadocs
+import org.apache.lucene.document.FloatField; // for javadocs
+import org.apache.lucene.document.LongField; // for javadocs
+import org.apache.lucene.document.DoubleField; // for javadocs
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.document.NumericField; // for javadocs
 
 /**
  * A range filter built on top of a cached single term field (in {@link FieldCache}).
@@ -38,7 +41,9 @@ import org.apache.lucene.document.NumericField; // for javadocs
  * a CachingWrapperFilter on top of a single {@link TermRangeFilter}.
  *
  * For numeric data types, this filter may be significantly faster than {@link NumericRangeFilter}.
- * Furthermore, it does not need the numeric values encoded by {@link NumericField}. But
+ * Furthermore, it does not need the numeric values encoded
+ * by {@link IntField}, {@link FloatField}, {@link
+ * LongField} or {@link DoubleField}. But
  * it has the problem that it only works with exact one value/document (see below).
  *
  * <p>As with all {@link FieldCache} based functionality, {@code FieldCacheRangeFilter} is only valid for 
diff --git a/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java b/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
index a2977e7..7d4e216 100644
--- a/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
+++ b/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
@@ -18,13 +18,17 @@ package org.apache.lucene.search;
  */
 
 import org.apache.lucene.analysis.NumericTokenStream; // for javadocs
-import org.apache.lucene.document.NumericField; // for javadocs
+import org.apache.lucene.document.DoubleField; // for javadocs
+import org.apache.lucene.document.FloatField; // for javadocs
+import org.apache.lucene.document.IntField; // for javadocs
+import org.apache.lucene.document.LongField; // for javadocs
 import org.apache.lucene.util.NumericUtils; // for javadocs
 
 /**
  * A {@link Filter} that only accepts numeric values within
  * a specified range. To use this, you must first index the
- * numeric values using {@link NumericField} (expert: {@link
+ * numeric values using {@link IntField}, {@link
+ * FloatField}, {@link LongField} or {@link DoubleField} (expert: {@link
  * NumericTokenStream}).
  *
  * <p>You create a new NumericRangeFilter with the static
diff --git a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
index c446cef..97e8b88 100644
--- a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -22,8 +22,11 @@ import java.util.Comparator;
 import java.util.LinkedList;
 
 import org.apache.lucene.analysis.NumericTokenStream; // for javadocs
-import org.apache.lucene.document.NumericField; // for javadocs
-import org.apache.lucene.document.NumericField.DataType;
+import org.apache.lucene.document.DoubleField; // for javadocs
+import org.apache.lucene.document.FloatField; // for javadocs
+import org.apache.lucene.document.IntField; // for javadocs
+import org.apache.lucene.document.LongField; // for javadocs
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.index.FilteredTermsEnum;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
@@ -35,7 +38,8 @@ import org.apache.lucene.util.ToStringUtils;
 /**
  * <p>A {@link Query} that matches numeric values within a
  * specified range.  To use this, you must first index the
- * numeric values using {@link NumericField} (expert: {@link
+ * numeric values using {@link IntField}, {@link
+ * FloatField}, {@link LongField} or {@link DoubleField} (expert: {@link
  * NumericTokenStream}).  If your terms are instead textual,
  * you should use {@link TermRangeQuery}.  {@link
  * NumericRangeFilter} is the filter equivalent of this
@@ -137,7 +141,8 @@ import org.apache.lucene.util.ToStringUtils;
  *  <li>Steps <b>&ge;64</b> for <em>long/double</em> and <b>&ge;32</b> for <em>int/float</em> produces one token
  *  per value in the index and querying is as slow as a conventional {@link TermRangeQuery}. But it can be used
  *  to produce fields, that are solely used for sorting (in this case simply use {@link Integer#MAX_VALUE} as
- *  <code>precisionStep</code>). Using {@link NumericField NumericFields} for sorting
+ *  <code>precisionStep</code>). Using {@link IntField},
+ * {@link LongField}, {@link FloatField} or {@link DoubleField} for sorting
  *  is ideal, because building the field cache is much faster than with text-only numbers.
  *  These fields have one term per value and therefore also work with term enumeration for building distinct lists
  *  (e.g. facets / preselected values to search for).
@@ -155,7 +160,7 @@ import org.apache.lucene.util.ToStringUtils;
  **/
 public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
 
-  private NumericRangeQuery(final String field, final int precisionStep, final DataType dataType,
+  private NumericRangeQuery(final String field, final int precisionStep, final NumericType dataType,
     T min, T max, final boolean minInclusive, final boolean maxInclusive
   ) {
     super(field);
@@ -189,7 +194,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
         break;
       default:
         // should never happen
-        throw new IllegalArgumentException("Invalid numeric DataType");
+        throw new IllegalArgumentException("Invalid numeric NumericType");
     }
     
     // shortcut if upper bound == lower bound
@@ -208,7 +213,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Long> newLongRange(final String field, final int precisionStep,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Long>(field, precisionStep, DataType.LONG, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Long>(field, precisionStep, NumericType.LONG, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -221,7 +226,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Long> newLongRange(final String field,
     Long min, Long max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Long>(field, NumericUtils.PRECISION_STEP_DEFAULT, DataType.LONG, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Long>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.LONG, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -234,7 +239,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Integer> newIntRange(final String field, final int precisionStep,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Integer>(field, precisionStep, DataType.INT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Integer>(field, precisionStep, NumericType.INT, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -247,7 +252,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Integer> newIntRange(final String field,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Integer>(field, NumericUtils.PRECISION_STEP_DEFAULT, DataType.INT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Integer>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.INT, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -262,7 +267,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Double> newDoubleRange(final String field, final int precisionStep,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Double>(field, precisionStep, DataType.DOUBLE, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Double>(field, precisionStep, NumericType.DOUBLE, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -277,7 +282,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Double> newDoubleRange(final String field,
     Double min, Double max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Double>(field, NumericUtils.PRECISION_STEP_DEFAULT, DataType.DOUBLE, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Double>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.DOUBLE, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -292,7 +297,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Float> newFloatRange(final String field, final int precisionStep,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Float>(field, precisionStep, DataType.FLOAT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Float>(field, precisionStep, NumericType.FLOAT, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -307,7 +312,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
   public static NumericRangeQuery<Float> newFloatRange(final String field,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<Float>(field, NumericUtils.PRECISION_STEP_DEFAULT, DataType.FLOAT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<Float>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.FLOAT, min, max, minInclusive, maxInclusive);
   }
 
   @Override @SuppressWarnings("unchecked")
@@ -377,7 +382,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
 
   // members (package private, to be also fast accessible by NumericRangeTermEnum)
   final int precisionStep;
-  final DataType dataType;
+  final NumericType dataType;
   final T min, max;
   final boolean minInclusive,maxInclusive;
 
@@ -415,10 +420,10 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
         case DOUBLE: {
           // lower
           long minBound;
-          if (dataType == DataType.LONG) {
+          if (dataType == NumericType.LONG) {
             minBound = (min == null) ? Long.MIN_VALUE : min.longValue();
           } else {
-            assert dataType == DataType.DOUBLE;
+            assert dataType == NumericType.DOUBLE;
             minBound = (min == null) ? LONG_NEGATIVE_INFINITY
               : NumericUtils.doubleToSortableLong(min.doubleValue());
           }
@@ -429,10 +434,10 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
           
           // upper
           long maxBound;
-          if (dataType == DataType.LONG) {
+          if (dataType == NumericType.LONG) {
             maxBound = (max == null) ? Long.MAX_VALUE : max.longValue();
           } else {
-            assert dataType == DataType.DOUBLE;
+            assert dataType == NumericType.DOUBLE;
             maxBound = (max == null) ? LONG_POSITIVE_INFINITY
               : NumericUtils.doubleToSortableLong(max.doubleValue());
           }
@@ -455,10 +460,10 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
         case FLOAT: {
           // lower
           int minBound;
-          if (dataType == DataType.INT) {
+          if (dataType == NumericType.INT) {
             minBound = (min == null) ? Integer.MIN_VALUE : min.intValue();
           } else {
-            assert dataType == DataType.FLOAT;
+            assert dataType == NumericType.FLOAT;
             minBound = (min == null) ? INT_NEGATIVE_INFINITY
               : NumericUtils.floatToSortableInt(min.floatValue());
           }
@@ -469,10 +474,10 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
           
           // upper
           int maxBound;
-          if (dataType == DataType.INT) {
+          if (dataType == NumericType.INT) {
             maxBound = (max == null) ? Integer.MAX_VALUE : max.intValue();
           } else {
-            assert dataType == DataType.FLOAT;
+            assert dataType == NumericType.FLOAT;
             maxBound = (max == null) ? INT_POSITIVE_INFINITY
               : NumericUtils.floatToSortableInt(max.floatValue());
           }
@@ -493,7 +498,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
           
         default:
           // should never happen
-          throw new IllegalArgumentException("Invalid numeric DataType");
+          throw new IllegalArgumentException("Invalid NumericType");
       }
 
       termComp = getComparator();
diff --git a/lucene/core/src/java/org/apache/lucene/search/package.html b/lucene/core/src/java/org/apache/lucene/search/package.html
index f2fd420..7fedd03 100644
--- a/lucene/core/src/java/org/apache/lucene/search/package.html
+++ b/lucene/core/src/java/org/apache/lucene/search/package.html
@@ -166,8 +166,9 @@ org.apache.lucene.search.IndexSearcher#search(Query,Filter,int)}.
     <a href="NumericRangeQuery.html">NumericRangeQuery</a>
     matches all documents that occur in a numeric range.
     For NumericRangeQuery to work, you must index the values
-    using a special <a href="../document/NumericField.html">
-    NumericField</a>.
+    using a one of the numeric fields (<a href="../document/IntField.html">IntField</a>,
+    <a href="../document/LongField.html">LongField</a>, <a href="../document/FloatField.html">FloatField</a>,
+    or <a href="../document/DoubleField.html">DoubleField</a>).
 </p>
 
 <h4>
diff --git a/lucene/core/src/java/org/apache/lucene/util/NumericUtils.java b/lucene/core/src/java/org/apache/lucene/util/NumericUtils.java
index f6e60f7..9be6bc4 100644
--- a/lucene/core/src/java/org/apache/lucene/util/NumericUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/util/NumericUtils.java
@@ -18,7 +18,10 @@ package org.apache.lucene.util;
  */
 
 import org.apache.lucene.analysis.NumericTokenStream;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.DoubleField; // javadocs
+import org.apache.lucene.document.FloatField; // javadocs
+import org.apache.lucene.document.IntField; // javadocs
+import org.apache.lucene.document.LongField; // javadocs
 import org.apache.lucene.search.NumericRangeFilter;
 import org.apache.lucene.search.NumericRangeQuery; // for javadocs
 
@@ -63,8 +66,10 @@ public final class NumericUtils {
   private NumericUtils() {} // no instance!
   
   /**
-   * The default precision step used by {@link NumericField}, {@link NumericTokenStream},
-   * {@link NumericRangeQuery}, and {@link NumericRangeFilter} as default
+   * The default precision step used by {@link IntField},
+   * {@link FloatField}, {@link LongField}, {@link
+   * DoubleField}, {@link NumericTokenStream}, {@link
+   * NumericRangeQuery}, and {@link NumericRangeFilter}.
    */
   public static final int PRECISION_STEP_DEFAULT = 4;
   
diff --git a/lucene/core/src/test/org/apache/lucene/TestExternalCodecs.java b/lucene/core/src/test/org/apache/lucene/TestExternalCodecs.java
index 2d5dd27..f310e82 100644
--- a/lucene/core/src/test/org/apache/lucene/TestExternalCodecs.java
+++ b/lucene/core/src/test/org/apache/lucene/TestExternalCodecs.java
@@ -81,7 +81,7 @@ public class TestExternalCodecs extends LuceneTestCase {
 
     doc.add(idField);
     for(int i=0;i<NUM_DOCS;i++) {
-      idField.setValue(""+i);
+      idField.setStringValue(""+i);
       w.addDocument(doc);
       if ((i+1)%10 == 0) {
         w.commit();
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/pulsing/Test10KPulsings.java b/lucene/core/src/test/org/apache/lucene/codecs/pulsing/Test10KPulsings.java
index 47a1bd5..9f94aed 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/pulsing/Test10KPulsings.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/pulsing/Test10KPulsings.java
@@ -74,7 +74,7 @@ public class Test10KPulsings extends LuceneTestCase {
     NumberFormat df = new DecimalFormat("00000", new DecimalFormatSymbols(Locale.ENGLISH));
 
     for (int i = 0; i < 10050; i++) {
-      field.setValue(df.format(i));
+      field.setStringValue(df.format(i));
       iw.addDocument(document);
     }
     
@@ -132,7 +132,7 @@ public class Test10KPulsings extends LuceneTestCase {
         sb.append(df.format(i));
         sb.append(' '); // whitespace
       }
-      field.setValue(sb.toString());
+      field.setStringValue(sb.toString());
       iw.addDocument(document);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestDocument.java b/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
index f403c91..d8e40cb 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestDocument.java
@@ -255,9 +255,9 @@ public class TestDocument extends LuceneTestCase {
     Directory dir = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random, dir);
     writer.addDocument(doc);
-    field.setValue("id2");
+    field.setStringValue("id2");
     writer.addDocument(doc);
-    field.setValue("id3");
+    field.setStringValue("id3");
     writer.addDocument(doc);
     
     IndexReader reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java b/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
index dd1a516..2be8149 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
@@ -32,7 +32,8 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -548,8 +549,8 @@ public class TestBackwardsCompatibility extends LuceneTestCase {
     doc.add(new Field("content2", "here is more content with aaa aaa aaa", customType2));
     doc.add(new Field("fie\u2C77ld", "field with non-ascii name", customType2));
     // add numeric fields, to test if flex preserves encoding
-    doc.add(new NumericField("trieInt", id));
-    doc.add(new NumericField("trieLong", (long) id));
+    doc.add(new IntField("trieInt", id));
+    doc.add(new LongField("trieLong", (long) id));
     writer.addDocument(doc);
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java b/lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java
index fe5adfc..24081c7 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java
@@ -85,7 +85,7 @@ public class TestConcurrentMergeScheduler extends LuceneTestCase {
       }
 
       for(int j=0;j<20;j++) {
-        idField.setValue(Integer.toString(i*20+j));
+        idField.setStringValue(Integer.toString(i*20+j));
         writer.addDocument(doc);
       }
 
@@ -141,7 +141,7 @@ public class TestConcurrentMergeScheduler extends LuceneTestCase {
         System.out.println("\nTEST: cycle");
       }
       for(int j=0;j<100;j++) {
-        idField.setValue(Integer.toString(i*100+j));
+        idField.setStringValue(Integer.toString(i*100+j));
         writer.addDocument(doc);
       }
 
@@ -212,7 +212,7 @@ public class TestConcurrentMergeScheduler extends LuceneTestCase {
     for(int iter=0;iter<10;iter++) {
 
       for(int j=0;j<201;j++) {
-        idField.setValue(Integer.toString(iter*201+j));
+        idField.setStringValue(Integer.toString(iter*201+j));
         writer.addDocument(doc);
       }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds.java b/lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds.java
index 1caa3bd..b2e14c8 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocTermOrds.java
@@ -28,7 +28,7 @@ import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.DocTermOrds.TermOrdsIterator;
@@ -54,13 +54,13 @@ public class TestDocTermOrds extends LuceneTestCase {
     Document doc = new Document();
     Field field = newField("field", "", TextField.TYPE_UNSTORED);
     doc.add(field);
-    field.setValue("a b c");
+    field.setStringValue("a b c");
     w.addDocument(doc);
 
-    field.setValue("d e f");
+    field.setStringValue("d e f");
     w.addDocument(doc);
 
-    field.setValue("a f");
+    field.setStringValue("a f");
     w.addDocument(doc);
     
     final IndexReader r = w.getReader();
@@ -124,7 +124,7 @@ public class TestDocTermOrds extends LuceneTestCase {
     for(int id=0;id<NUM_DOCS;id++) {
       Document doc = new Document();
 
-      doc.add(new NumericField("id", id));
+      doc.add(new IntField("id", id));
       
       final int termCount = _TestUtil.nextInt(random, 0, 20*RANDOM_MULTIPLIER);
       while(ordsForDocSet.size() < termCount) {
@@ -221,7 +221,7 @@ public class TestDocTermOrds extends LuceneTestCase {
     for(int id=0;id<NUM_DOCS;id++) {
       Document doc = new Document();
 
-      doc.add(new NumericField("id", id));
+      doc.add(new IntField("id", id));
       
       final int termCount = _TestUtil.nextInt(random, 0, 20*RANDOM_MULTIPLIER);
       while(ordsForDocSet.size() < termCount) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
index 17e9111..6c3b2fc 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
@@ -614,25 +614,25 @@ public class TestDocValuesIndexing extends LuceneTestCase {
       if (isNumeric) {
         switch (valueType) {
         case VAR_INTS:
-          valField.setValue((long)i);
+          valField.setLongValue((long)i);
           break;
         case FIXED_INTS_16:
-          valField.setValue((short)i);
+          valField.setIntValue((short)i);
           break;
         case FIXED_INTS_32:
-          valField.setValue(i);
+          valField.setIntValue(i);
           break;
         case FIXED_INTS_64:
-          valField.setValue((long)i);
+          valField.setLongValue((long)i);
           break;
         case FIXED_INTS_8:
-          valField.setValue((byte)(0xFF & (i % 128)));
+          valField.setIntValue((byte)(0xFF & (i % 128)));
           break;
         case FLOAT_32:
-          valField.setValue(2.0f * i);
+          valField.setFloatValue(2.0f * i);
           break;
         case FLOAT_64:
-          valField.setValue(2.0d * i);
+          valField.setDoubleValue(2.0d * i);
           break;
         default:
           fail("unexpected value " + valueType);
@@ -642,7 +642,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
           b[j] = upto++;
         }
         if (bytesRef != null) {
-          valField.setValue(bytesRef);
+          valField.setBytesValue(bytesRef);
         }
       }
       doc.removeFields("id");
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java b/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
index 8032352..af66f9d 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
@@ -24,9 +24,13 @@ import java.util.*;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.DocumentStoredFieldVisitor;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -231,45 +235,51 @@ public class TestFieldsReader extends LuceneTestCase {
     RandomIndexWriter w = new RandomIndexWriter(random, dir);
     final int numDocs = atLeast(500);
     final Number[] answers = new Number[numDocs];
-    final NumericField.DataType[] typeAnswers = new NumericField.DataType[numDocs];
+    final NumericType[] typeAnswers = new NumericType[numDocs];
     for(int id=0;id<numDocs;id++) {
       Document doc = new Document();
-      final NumericField nf;
+      final Field nf;
+      final Field sf;
       final Number answer;
-      final NumericField.DataType typeAnswer;
+      final NumericType typeAnswer;
       if (random.nextBoolean()) {
         // float/double
         if (random.nextBoolean()) {
           final float f = random.nextFloat();
           answer = Float.valueOf(f);
-          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.FLOAT, true));
-          typeAnswer = NumericField.DataType.FLOAT;
+          nf = new FloatField("nf", f);
+          sf = new StoredField("nf", f);
+          typeAnswer = NumericType.FLOAT;
         } else {
           final double d = random.nextDouble();
           answer = Double.valueOf(d);
-          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.DOUBLE, true));
-          typeAnswer = NumericField.DataType.DOUBLE;
+          nf = new DoubleField("nf", d);
+          sf = new StoredField("nf", d);
+          typeAnswer = NumericType.DOUBLE;
         }
       } else {
         // int/long
         if (random.nextBoolean()) {
           final int i = random.nextInt();
           answer = Integer.valueOf(i);
-          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.INT, true));
-          typeAnswer = NumericField.DataType.INT;
+          nf = new IntField("nf", i);
+          sf = new StoredField("nf", i);
+          typeAnswer = NumericType.INT;
         } else {
           final long l = random.nextLong();
           answer = Long.valueOf(l);
-          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.LONG, true));
-          typeAnswer = NumericField.DataType.LONG;
+          nf = new LongField("nf", l);
+          sf = new StoredField("nf", l);
+          typeAnswer = NumericType.LONG;
         }
       }
       doc.add(nf);
+      doc.add(sf);
       answers[id] = answer;
       typeAnswers[id] = typeAnswer;
-      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, false));
+      FieldType ft = new FieldType(IntField.TYPE);
       ft.setNumericPrecisionStep(Integer.MAX_VALUE);
-      doc.add(new NumericField("id", id, ft));
+      doc.add(new IntField("id", id, ft));
       w.addDocument(doc);
     }
     final DirectoryReader r = w.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
index af06390..45e7c99 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
@@ -1660,16 +1660,16 @@ public class TestIndexWriter extends LuceneTestCase {
 
     w = new RandomIndexWriter(random, dir);
 
-    contentField.setValue("other");
+    contentField.setStringValue("other");
     w.addDocument(doc);
 
-    contentField.setValue("term");
+    contentField.setStringValue("term");
     w.addDocument(doc);
 
-    contentField.setValue(bigTerm);
+    contentField.setStringValue(bigTerm);
     w.addDocument(doc);
 
-    contentField.setValue("zzz");
+    contentField.setStringValue("zzz");
     w.addDocument(doc);
 
     reader = w.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterCommit.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterCommit.java
index f7f7f89..9b94bc9 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterCommit.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterCommit.java
@@ -347,7 +347,7 @@ public class TestIndexWriterCommit extends LuceneTestCase {
                 if (failed.get()) break;
                 for(int j=0;j<10;j++) {
                   final String s = finalI + "_" + String.valueOf(count++);
-                  f.setValue(s);
+                  f.setStringValue(s);
                   w.addDocument(doc);
                   w.commit();
                   DirectoryReader r2 = DirectoryReader.openIfChanged(r);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
index 12372b5..8554f02 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
@@ -150,7 +150,7 @@ public class TestIndexWriterExceptions extends LuceneTestCase {
         }
         doFail.set(this);
         final String id = ""+r.nextInt(50);
-        idField.setValue(id);
+        idField.setStringValue(id);
         Term idTerm = new Term("id", id);
         try {
           if (r.nextBoolean()) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMerging.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMerging.java
index 8e9eb93..30eff2b 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMerging.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMerging.java
@@ -144,7 +144,7 @@ public class TestIndexWriterMerging extends LuceneTestCase
     Field termVectorField = newField("termVector", "termVector", customType1);
     document.add(termVectorField);
     for(int i=0;i<10;i++) {
-      idField.setValue("" + i);
+      idField.setStringValue("" + i);
       writer.addDocument(document);
     }
     writer.close();
@@ -207,7 +207,7 @@ public class TestIndexWriterMerging extends LuceneTestCase
     Field idField = newField("id", "", StringField.TYPE_UNSTORED);
     document.add(idField);
     for(int i=0;i<98;i++) {
-      idField.setValue("" + i);
+      idField.setStringValue("" + i);
       writer.addDocument(document);
     }
     writer.close();
@@ -273,7 +273,7 @@ public class TestIndexWriterMerging extends LuceneTestCase
     Field idField = newField("id", "", StringField.TYPE_UNSTORED);
     document.add(idField);
     for(int i=0;i<98;i++) {
-      idField.setValue("" + i);
+      idField.setStringValue("" + i);
       writer.addDocument(document);
     }
     writer.close();
@@ -385,7 +385,7 @@ public class TestIndexWriterMerging extends LuceneTestCase
           System.out.println("TEST: iter=" + iter);
         }
         for(int j=0;j<199;j++) {
-          idField.setValue(Integer.toString(iter*201+j));
+          idField.setStringValue(Integer.toString(iter*201+j));
           writer.addDocument(doc);
         }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader.java
index ff8d3f7..4f04be0 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterReader.java
@@ -879,9 +879,9 @@ public class TestIndexWriterReader extends LuceneTestCase {
     doc.add(newField("field", "a b c", TextField.TYPE_UNSTORED));
     Field id = newField("id", "", StringField.TYPE_UNSTORED);
     doc.add(id);
-    id.setValue("0");
+    id.setStringValue("0");
     w.addDocument(doc);
-    id.setValue("1");
+    id.setStringValue("1");
     w.addDocument(doc);
     w.deleteDocuments(new Term("id", "0"));
 
@@ -903,9 +903,9 @@ public class TestIndexWriterReader extends LuceneTestCase {
     doc.add(newField("field", "a b c", TextField.TYPE_UNSTORED));
     Field id = newField("id", "", StringField.TYPE_UNSTORED);
     doc.add(id);
-    id.setValue("0");
+    id.setStringValue("0");
     w.addDocument(doc);
-    id.setValue("1");
+    id.setStringValue("1");
     w.addDocument(doc);
     IndexReader r = w.getReader();
     assertEquals(2, r.numDocs());
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java
index a850cd9..933580a 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java
@@ -306,7 +306,7 @@ public class TestIndexWriterUnicode extends LuceneTestCase {
         s = new String(chars, 0, 2);
       }
       allTerms.add(s);
-      f.setValue(s);
+      f.setStringValue(s);
 
       writer.addDocument(d);
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestMaxTermFrequency.java b/lucene/core/src/test/org/apache/lucene/index/TestMaxTermFrequency.java
index 6b285b4..66637c5 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestMaxTermFrequency.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestMaxTermFrequency.java
@@ -53,7 +53,7 @@ public class TestMaxTermFrequency extends LuceneTestCase {
     Field foo = newField("foo", "", TextField.TYPE_UNSTORED);
     doc.add(foo);
     for (int i = 0; i < 100; i++) {
-      foo.setValue(addValue());
+      foo.setStringValue(addValue());
       writer.addDocument(doc);
     }
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java b/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
index e86738e..645b172 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestMultiFields.java
@@ -60,7 +60,7 @@ public class TestMultiFields extends LuceneTestCase {
           // re-use existing term
           BytesRef term = terms.get(random.nextInt(terms.size()));
           docs.get(term).add(i);
-          f.setValue(term.utf8ToString());
+          f.setStringValue(term.utf8ToString());
         } else {
           String s = _TestUtil.randomUnicodeString(random, 10);
           BytesRef term = new BytesRef(s);
@@ -70,9 +70,9 @@ public class TestMultiFields extends LuceneTestCase {
           docs.get(term).add(i);
           terms.add(term);
           uniqueTerms.add(term);
-          f.setValue(s);
+          f.setStringValue(s);
         }
-        id.setValue(""+i);
+        id.setStringValue(""+i);
         w.addDocument(doc);
         if (random.nextInt(4) == 1) {
           w.commit();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
index 023a59e..4b04285 100755
--- a/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestNorms.java
@@ -70,7 +70,7 @@ public class TestNorms extends LuceneTestCase {
     doc.add(bar);
     
     for (int i = 0; i < 100; i++) {
-      bar.setValue("singleton");
+      bar.setStringValue("singleton");
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestParallelReaderEmptyIndex.java b/lucene/core/src/test/org/apache/lucene/index/TestParallelReaderEmptyIndex.java
index 8abb388..958ff97 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestParallelReaderEmptyIndex.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestParallelReaderEmptyIndex.java
@@ -98,10 +98,10 @@ public class TestParallelReaderEmptyIndex extends LuceneTestCase {
       FieldType customType = new FieldType(TextField.TYPE_UNSTORED);
       customType.setStoreTermVectors(true);
       doc.add(newField("test", "", customType));
-      idField.setValue("1");
+      idField.setStringValue("1");
       iw.addDocument(doc);
       doc.add(newField("test", "", TextField.TYPE_UNSTORED));
-      idField.setValue("2");
+      idField.setStringValue("2");
       iw.addDocument(doc);
       iw.close();
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java b/lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java
index 10c3d66..16ba32e 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestPostingsOffsets.java
@@ -32,7 +32,7 @@ import org.apache.lucene.codecs.lucene40.Lucene40PostingsFormat;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -239,7 +239,7 @@ public class TestPostingsOffsets extends LuceneTestCase {
 
     for(int docCount=0;docCount<numDocs;docCount++) {
       Document doc = new Document();
-      doc.add(new NumericField("id", docCount));
+      doc.add(new IntField("id", docCount));
       List<Token> tokens = new ArrayList<Token>();
       final int numTokens = atLeast(100);
       //final int numTokens = atLeast(20);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields.java b/lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields.java
index 9e92d9c..e212fce 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields.java
@@ -69,7 +69,7 @@ public class TestRandomStoredFields extends LuceneTestCase {
       Document doc = new Document();
       doc.add(idField);
       final String id = ""+i;
-      idField.setValue(id);
+      idField.setStringValue(id);
       docs.put(id, doc);
       if (VERBOSE) {
         System.out.println("TEST: add doc id=" + id);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java b/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
index 474ed15..db462d5 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestReaderClosed.java
@@ -50,7 +50,7 @@ public class TestReaderClosed extends LuceneTestCase {
     // but for preflex codec, the test can be very slow, so use less iterations.
     int num = atLeast(10);
     for (int i = 0; i < num; i++) {
-      field.setValue(_TestUtil.randomUnicodeString(random, 10));
+      field.setStringValue(_TestUtil.randomUnicodeString(random, 10));
       writer.addDocument(doc);
     }
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestRollingUpdates.java b/lucene/core/src/test/org/apache/lucene/index/TestRollingUpdates.java
index 0a83716..af97e35 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestRollingUpdates.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestRollingUpdates.java
@@ -57,7 +57,7 @@ public class TestRollingUpdates extends LuceneTestCase {
       } else {
         id++;
       }
-      ((Field) doc.getField("docid")).setValue(myID);
+      ((Field) doc.getField("docid")).setStringValue(myID);
       w.updateDocument(new Term("docid", myID), doc);
 
       if (docIter >= SIZE && random.nextInt(50) == 17) {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestStressAdvance.java b/lucene/core/src/test/org/apache/lucene/index/TestStressAdvance.java
index 7b99023..d9addb7 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestStressAdvance.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestStressAdvance.java
@@ -43,12 +43,12 @@ public class TestStressAdvance extends LuceneTestCase {
       int num = atLeast(4097);
       for(int id=0;id<num;id++) {
         if (random.nextInt(4) == 3) {
-          f.setValue("a");
+          f.setStringValue("a");
           aDocs.add(id);
         } else {
-          f.setValue("b");
+          f.setStringValue("b");
         }
-        idField.setValue(""+id);
+        idField.setStringValue(""+id);
         w.addDocument(doc);
       }
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestSumDocFreq.java b/lucene/core/src/test/org/apache/lucene/index/TestSumDocFreq.java
index 3d494f2..bfa6be6 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestSumDocFreq.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestSumDocFreq.java
@@ -45,13 +45,13 @@ public class TestSumDocFreq extends LuceneTestCase {
     doc.add(field1);
     doc.add(field2);
     for (int i = 0; i < numDocs; i++) {
-      id.setValue("" + i);
+      id.setStringValue("" + i);
       char ch1 = (char) _TestUtil.nextInt(random, 'a', 'z');
       char ch2 = (char) _TestUtil.nextInt(random, 'a', 'z');
-      field1.setValue("" + ch1 + " " + ch2);
+      field1.setStringValue("" + ch1 + " " + ch2);
       ch1 = (char) _TestUtil.nextInt(random, 'a', 'z');
       ch2 = (char) _TestUtil.nextInt(random, 'a', 'z');
-      field2.setValue("" + ch1 + " " + ch2);
+      field2.setStringValue("" + ch1 + " " + ch2);
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
index 17d5d2d..bcf89a6 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum.java
@@ -32,7 +32,7 @@ import java.util.TreeSet;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.search.FieldCache;
@@ -164,7 +164,7 @@ public class TestTermsEnum extends LuceneTestCase {
 
   private void addDoc(RandomIndexWriter w, Collection<String> terms, Map<BytesRef,Integer> termToID, int id) throws IOException {
     Document doc = new Document();
-    doc.add(new NumericField("id", id));
+    doc.add(new IntField("id", id));
     if (VERBOSE) {
       System.out.println("TEST: addDoc id:" + id + " terms=" + terms);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
index bda74bf..c3b819f 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTermsEnum2.java
@@ -71,7 +71,7 @@ public class TestTermsEnum2 extends LuceneTestCase {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
       String s = _TestUtil.randomUnicodeString(random);
-      field.setValue(s);
+      field.setStringValue(s);
       terms.add(new BytesRef(s));
       writer.addDocument(doc);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java b/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
index 8223ad6..5f40fdb 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestTypePromotion.java
@@ -215,33 +215,33 @@ public class TestTypePromotion extends LuceneTestCase {
       switch (valueType) {
       case VAR_INTS:
         values[i] = random.nextInt();
-        valField.setValue(values[i]);
+        valField.setLongValue(values[i]);
         break;
       case FIXED_INTS_16:
         values[i] = random.nextInt(Short.MAX_VALUE);
-        valField.setValue((short) values[i]);
+        valField.setIntValue((short) values[i]);
         break;
       case FIXED_INTS_32:
         values[i] = random.nextInt();
-        valField.setValue((int) values[i]);
+        valField.setIntValue((int) values[i]);
         break;
       case FIXED_INTS_64:
         values[i] = random.nextLong();
-        valField.setValue(values[i]);
+        valField.setLongValue(values[i]);
         break;
       case FLOAT_64:
         double nextDouble = random.nextDouble();
         values[i] = Double.doubleToRawLongBits(nextDouble);
-        valField.setValue(nextDouble);
+        valField.setDoubleValue(nextDouble);
         break;
       case FLOAT_32:
         final float nextFloat = random.nextFloat();
         values[i] = Double.doubleToRawLongBits(nextFloat);
-        valField.setValue(nextFloat);
+        valField.setFloatValue(nextFloat);
         break;
       case FIXED_INTS_8:
         values[i] = (byte) i;
-        valField.setValue((byte)values[i]);
+        valField.setIntValue((byte)values[i]);
         break;
       case BYTES_FIXED_DEREF:
       case BYTES_FIXED_SORTED:
@@ -250,7 +250,7 @@ public class TestTypePromotion extends LuceneTestCase {
         byte bytes[] = new byte[8];
         ByteArrayDataOutput out = new ByteArrayDataOutput(bytes, 0, 8);
         out.writeLong(values[i]);
-        valField.setValue(new BytesRef(bytes));
+        valField.setBytesValue(new BytesRef(bytes));
         break;
       case BYTES_VAR_DEREF:
       case BYTES_VAR_SORTED:
@@ -267,7 +267,7 @@ public class TestTypePromotion extends LuceneTestCase {
           lout.writeLong(values[i]);
           len = 8;
         }
-        valField.setValue(new BytesRef(lbytes, 0, len));
+        valField.setBytesValue(new BytesRef(lbytes, 0, len));
         break;
 
       default:
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestUniqueTermCount.java b/lucene/core/src/test/org/apache/lucene/index/TestUniqueTermCount.java
index ebbbeeb..850b507 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestUniqueTermCount.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestUniqueTermCount.java
@@ -52,7 +52,7 @@ public class TestUniqueTermCount extends LuceneTestCase {
     Field foo = newField("foo", "", TextField.TYPE_UNSTORED);
     doc.add(foo);
     for (int i = 0; i < 100; i++) {
-      foo.setValue(addValue());
+      foo.setStringValue(addValue());
       writer.addDocument(doc);
     }
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter.java b/lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter.java
index b51ec02..f12f4c6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter.java
+++ b/lucene/core/src/test/org/apache/lucene/search/BaseTestRangeFilter.java
@@ -135,7 +135,7 @@ public class BaseTestRangeFilter extends LuceneTestCase {
       int maxCount = 0;
 
       for (int d = minId; d <= maxId; d++) {
-        idField.setValue(pad(d));
+        idField.setStringValue(pad(d));
         int r = index.allowNegativeRandomInts ? random.nextInt() : random
           .nextInt(Integer.MAX_VALUE);
         if (index.maxR < r) {
@@ -151,8 +151,8 @@ public class BaseTestRangeFilter extends LuceneTestCase {
         } else if (r == index.minR) {
           minCount++;
         }
-        randField.setValue(pad(r));
-        bodyField.setValue("body");
+        randField.setStringValue(pad(r));
+        bodyField.setStringValue("body");
         writer.addDocument(doc);
       }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
index 5835db9..da5b24f 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQuery.java
@@ -55,9 +55,9 @@ public class TestAutomatonQuery extends LuceneTestCase {
     doc.add(field);
     doc.add(footerField);
     writer.addDocument(doc);
-    field.setValue("some text from doc two a short piece 5678.91");
+    field.setStringValue("some text from doc two a short piece 5678.91");
     writer.addDocument(doc);
-    field.setValue("doc three has some different stuff"
+    field.setStringValue("doc three has some different stuff"
         + " with numbers 1234 5678.9 and letter b");
     writer.addDocument(doc);
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
index 3e62540..ad043b1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestAutomatonQueryUnicode.java
@@ -54,30 +54,30 @@ public class TestAutomatonQueryUnicode extends LuceneTestCase {
     doc.add(titleField);
     doc.add(field);
     doc.add(footerField);
-    field.setValue("\uD866\uDF05abcdef");
+    field.setStringValue("\uD866\uDF05abcdef");
     writer.addDocument(doc);
-    field.setValue("\uD866\uDF06ghijkl");
+    field.setStringValue("\uD866\uDF06ghijkl");
     writer.addDocument(doc);
     // this sorts before the previous two in UTF-8/UTF-32, but after in UTF-16!!!
-    field.setValue("\uFB94mnopqr"); 
+    field.setStringValue("\uFB94mnopqr"); 
     writer.addDocument(doc);
-    field.setValue("\uFB95stuvwx"); // this one too.
+    field.setStringValue("\uFB95stuvwx"); // this one too.
     writer.addDocument(doc);
-    field.setValue("a\uFFFCbc");
+    field.setStringValue("a\uFFFCbc");
     writer.addDocument(doc);
-    field.setValue("a\uFFFDbc");
+    field.setStringValue("a\uFFFDbc");
     writer.addDocument(doc);
-    field.setValue("a\uFFFEbc");
+    field.setStringValue("a\uFFFEbc");
     writer.addDocument(doc);
-    field.setValue("a\uFB94bc");
+    field.setStringValue("a\uFB94bc");
     writer.addDocument(doc);
-    field.setValue("bacadaba");
+    field.setStringValue("bacadaba");
     writer.addDocument(doc);
-    field.setValue("\uFFFD");
+    field.setStringValue("\uFFFD");
     writer.addDocument(doc);
-    field.setValue("\uFFFD\uD866\uDF05");
+    field.setStringValue("\uFFFD\uD866\uDF05");
     writer.addDocument(doc);
-    field.setValue("\uFFFD\uFFFD");
+    field.setStringValue("\uFFFD\uFFFD");
     writer.addDocument(doc);
     reader = writer.getReader();
     searcher = newSearcher(reader);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
index da848bf..c8fee43 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
@@ -61,13 +61,13 @@ public class TestDocValuesScoring extends LuceneTestCase {
     Field field2 = newField("bar", "", TextField.TYPE_UNSTORED);
     doc.add(field2);
     
-    field.setValue("quick brown fox");
-    field2.setValue("quick brown fox");
-    dvField.setValue(2f); // boost x2
+    field.setStringValue("quick brown fox");
+    field2.setStringValue("quick brown fox");
+    dvField.setFloatValue(2f); // boost x2
     iw.addDocument(doc);
-    field.setValue("jumps over lazy brown dog");
-    field2.setValue("jumps over lazy brown dog");
-    dvField.setValue(4f); // boost x4
+    field.setStringValue("jumps over lazy brown dog");
+    field2.setStringValue("jumps over lazy brown dog");
+    dvField.setFloatValue(4f); // boost x4
     iw.addDocument(doc);
     IndexReader ir = iw.getReader();
     iw.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java b/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
index 04af28f..3d31c26 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
@@ -29,7 +29,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.*;
 import org.apache.lucene.store.Directory;
@@ -78,7 +78,7 @@ public class TestFieldCache extends LuceneTestCase {
       }
 
       if (i%2 == 0) {
-        doc.add(new NumericField("numInt", i));
+        doc.add(new IntField("numInt", i));
       }
 
       // sometimes skip the field:
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery2.java b/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery2.java
index e947d20..dc55dc8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery2.java
@@ -94,7 +94,7 @@ public class TestFuzzyQuery2 extends LuceneTestCase {
     doc.add(field);
     
     for (int i = 0; i < terms; i++) {
-      field.setValue(mapInt(codePointTable, i));
+      field.setStringValue(mapInt(codePointTable, i));
       writer.addDocument(doc);
     }   
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
index b9fb192..ae886c1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMultiValuedNumericRangeQuery.java
@@ -23,7 +23,7 @@ import java.text.DecimalFormatSymbols;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -52,7 +52,7 @@ public class TestMultiValuedNumericRangeQuery extends LuceneTestCase {
       for (int m=0, c=random.nextInt(10); m<=c; m++) {
         int value = random.nextInt(Integer.MAX_VALUE);
         doc.add(newField("asc", format.format(value), StringField.TYPE_UNSTORED));
-        doc.add(new NumericField("trie", value));
+        doc.add(new IntField("trie", value));
       }
       writer.addDocument(doc);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java b/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
index 150ecaa..aa61e83 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
@@ -20,7 +20,8 @@ package org.apache.lucene.search;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
@@ -60,7 +61,9 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
         .setMaxBufferedDocs(_TestUtil.nextInt(random, 100, 1000))
         .setMergePolicy(newLogMergePolicy()));
     
-    final FieldType storedInt = NumericField.getFieldType(NumericField.DataType.INT, true);
+    final FieldType storedInt = new FieldType(IntField.TYPE);
+    storedInt.setStored(true);
+    storedInt.freeze();
 
     final FieldType storedInt8 = new FieldType(storedInt);
     storedInt8.setNumericPrecisionStep(8);
@@ -74,7 +77,7 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     final FieldType storedIntNone = new FieldType(storedInt);
     storedIntNone.setNumericPrecisionStep(Integer.MAX_VALUE);
 
-    final FieldType unstoredInt = NumericField.getFieldType(NumericField.DataType.INT, false);
+    final FieldType unstoredInt = IntField.TYPE;
 
     final FieldType unstoredInt8 = new FieldType(unstoredInt);
     unstoredInt8.setNumericPrecisionStep(8);
@@ -85,14 +88,14 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     final FieldType unstoredInt2 = new FieldType(unstoredInt);
     unstoredInt2.setNumericPrecisionStep(2);
 
-    NumericField
-      field8 = new NumericField("field8", 0, storedInt8),
-      field4 = new NumericField("field4", 0, storedInt4),
-      field2 = new NumericField("field2", 0, storedInt2),
-      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, 0, storedIntNone),
-      ascfield8 = new NumericField("ascfield8", 0, unstoredInt8),
-      ascfield4 = new NumericField("ascfield4", 0, unstoredInt4),
-      ascfield2 = new NumericField("ascfield2", 0, unstoredInt2);
+    IntField
+      field8 = new IntField("field8", 0, storedInt8),
+      field4 = new IntField("field4", 0, storedInt4),
+      field2 = new IntField("field2", 0, storedInt2),
+      fieldNoTrie = new IntField("field"+Integer.MAX_VALUE, 0, storedIntNone),
+      ascfield8 = new IntField("ascfield8", 0, unstoredInt8),
+      ascfield4 = new IntField("ascfield4", 0, unstoredInt4),
+      ascfield2 = new IntField("ascfield2", 0, unstoredInt2);
     
     Document doc = new Document();
     // add fields, that have a distance to test general functionality
@@ -103,15 +106,15 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     // Add a series of noDocs docs with increasing int values
     for (int l=0; l<noDocs; l++) {
       int val=distance*l+startOffset;
-      field8.setValue(val);
-      field4.setValue(val);
-      field2.setValue(val);
-      fieldNoTrie.setValue(val);
+      field8.setIntValue(val);
+      field4.setIntValue(val);
+      field2.setIntValue(val);
+      fieldNoTrie.setIntValue(val);
 
       val=l-(noDocs/2);
-      ascfield8.setValue(val);
-      ascfield4.setValue(val);
-      ascfield2.setValue(val);
+      ascfield8.setIntValue(val);
+      ascfield4.setIntValue(val);
+      ascfield2.setIntValue(val);
       writer.addDocument(doc);
     }
   
@@ -299,23 +302,23 @@ public class TestNumericRangeQuery32 extends LuceneTestCase {
     RandomIndexWriter writer = new RandomIndexWriter(random, dir,
       newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)));
     Document doc = new Document();
-    doc.add(new NumericField("float", Float.NEGATIVE_INFINITY));
-    doc.add(new NumericField("int", Integer.MIN_VALUE));
+    doc.add(new FloatField("float", Float.NEGATIVE_INFINITY));
+    doc.add(new IntField("int", Integer.MIN_VALUE));
     writer.addDocument(doc);
     
     doc = new Document();
-    doc.add(new NumericField("float", Float.POSITIVE_INFINITY));
-    doc.add(new NumericField("int", Integer.MAX_VALUE));
+    doc.add(new FloatField("float", Float.POSITIVE_INFINITY));
+    doc.add(new IntField("int", Integer.MAX_VALUE));
     writer.addDocument(doc);
     
     doc = new Document();
-    doc.add(new NumericField("float", 0.0f));
-    doc.add(new NumericField("int", 0));
+    doc.add(new FloatField("float", 0.0f));
+    doc.add(new IntField("int", 0));
     writer.addDocument(doc);
     
     for (float f : TestNumericUtils.FLOAT_NANs) {
       doc = new Document();
-      doc.add(new NumericField("float", f));
+      doc.add(new FloatField("float", f));
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java b/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
index b164ef4..d4019a6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
@@ -19,8 +19,9 @@ package org.apache.lucene.search;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
@@ -60,7 +61,9 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
         .setMaxBufferedDocs(_TestUtil.nextInt(random, 100, 1000))
         .setMergePolicy(newLogMergePolicy()));
 
-    final FieldType storedLong = NumericField.getFieldType(NumericField.DataType.LONG, true);
+    final FieldType storedLong = new FieldType(LongField.TYPE);
+    storedLong.setStored(true);
+    storedLong.freeze();
 
     final FieldType storedLong8 = new FieldType(storedLong);
     storedLong8.setNumericPrecisionStep(8);
@@ -77,7 +80,7 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     final FieldType storedLongNone = new FieldType(storedLong);
     storedLongNone.setNumericPrecisionStep(Integer.MAX_VALUE);
 
-    final FieldType unstoredLong = NumericField.getFieldType(NumericField.DataType.LONG, false);
+    final FieldType unstoredLong = LongField.TYPE;
 
     final FieldType unstoredLong8 = new FieldType(unstoredLong);
     unstoredLong8.setNumericPrecisionStep(8);
@@ -91,16 +94,16 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     final FieldType unstoredLong2 = new FieldType(unstoredLong);
     unstoredLong2.setNumericPrecisionStep(2);
 
-    NumericField
-      field8 = new NumericField("field8", 0L, storedLong8),
-      field6 = new NumericField("field6", 0L, storedLong6),
-      field4 = new NumericField("field4", 0L, storedLong4),
-      field2 = new NumericField("field2", 0L, storedLong2),
-      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, 0L, storedLongNone),
-      ascfield8 = new NumericField("ascfield8", 0L, unstoredLong8),
-      ascfield6 = new NumericField("ascfield6", 0L, unstoredLong6),
-      ascfield4 = new NumericField("ascfield4", 0L, unstoredLong4),
-      ascfield2 = new NumericField("ascfield2", 0L, unstoredLong2);
+    LongField
+      field8 = new LongField("field8", 0L, storedLong8),
+      field6 = new LongField("field6", 0L, storedLong6),
+      field4 = new LongField("field4", 0L, storedLong4),
+      field2 = new LongField("field2", 0L, storedLong2),
+      fieldNoTrie = new LongField("field"+Integer.MAX_VALUE, 0L, storedLongNone),
+      ascfield8 = new LongField("ascfield8", 0L, unstoredLong8),
+      ascfield6 = new LongField("ascfield6", 0L, unstoredLong6),
+      ascfield4 = new LongField("ascfield4", 0L, unstoredLong4),
+      ascfield2 = new LongField("ascfield2", 0L, unstoredLong2);
 
     Document doc = new Document();
     // add fields, that have a distance to test general functionality
@@ -111,17 +114,17 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     // Add a series of noDocs docs with increasing long values, by updating the fields
     for (int l=0; l<noDocs; l++) {
       long val=distance*l+startOffset;
-      field8.setValue(val);
-      field6.setValue(val);
-      field4.setValue(val);
-      field2.setValue(val);
-      fieldNoTrie.setValue(val);
+      field8.setLongValue(val);
+      field6.setLongValue(val);
+      field4.setLongValue(val);
+      field2.setLongValue(val);
+      fieldNoTrie.setLongValue(val);
 
       val=l-(noDocs/2);
-      ascfield8.setValue(val);
-      ascfield6.setValue(val);
-      ascfield4.setValue(val);
-      ascfield2.setValue(val);
+      ascfield8.setLongValue(val);
+      ascfield6.setLongValue(val);
+      ascfield4.setLongValue(val);
+      ascfield2.setLongValue(val);
       writer.addDocument(doc);
     }
     reader = writer.getReader();
@@ -324,23 +327,23 @@ public class TestNumericRangeQuery64 extends LuceneTestCase {
     RandomIndexWriter writer = new RandomIndexWriter(random, dir,
       newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)));
     Document doc = new Document();
-    doc.add(new NumericField("double", Double.NEGATIVE_INFINITY));
-    doc.add(new NumericField("long", Long.MIN_VALUE));
+    doc.add(new DoubleField("double", Double.NEGATIVE_INFINITY));
+    doc.add(new LongField("long", Long.MIN_VALUE));
     writer.addDocument(doc);
     
     doc = new Document();
-    doc.add(new NumericField("double", Double.POSITIVE_INFINITY));
-    doc.add(new NumericField("long", Long.MAX_VALUE));
+    doc.add(new DoubleField("double", Double.POSITIVE_INFINITY));
+    doc.add(new LongField("long", Long.MAX_VALUE));
     writer.addDocument(doc);
     
     doc = new Document();
-    doc.add(new NumericField("double", 0.0));
-    doc.add(new NumericField("long", 0L));
+    doc.add(new DoubleField("double", 0.0));
+    doc.add(new LongField("long", 0L));
     writer.addDocument(doc);
     
     for (double d : TestNumericUtils.DOUBLE_NANs) {
       doc = new Document();
-      doc.add(new NumericField("double", d));
+      doc.add(new DoubleField("double", d));
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
index bc7c9e6..75d1e79 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
@@ -654,7 +654,7 @@ public class TestPhraseQuery extends LuceneTestCase {
         }
       }
       docs.add(doc);
-      f.setValue(sb.toString());
+      f.setStringValue(sb.toString());
       w.addDocument(d);
     }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPrefixInBooleanQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestPrefixInBooleanQuery.java
index 4d4d40d..c5cb7ef 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPrefixInBooleanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPrefixInBooleanQuery.java
@@ -58,15 +58,15 @@ public class TestPrefixInBooleanQuery extends LuceneTestCase {
       writer.addDocument(doc);
     }
     
-    field.setValue("tangfulin");
+    field.setStringValue("tangfulin");
     writer.addDocument(doc);
 
-    field.setValue("meaninglessnames");
+    field.setStringValue("meaninglessnames");
     for (int i = 5138; i < 11377; ++i) {
       writer.addDocument(doc);
     }
     
-    field.setValue("tangfulin");
+    field.setStringValue("tangfulin");
     writer.addDocument(doc);
     
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPrefixRandom.java b/lucene/core/src/test/org/apache/lucene/search/TestPrefixRandom.java
index 629a9d9..6e5d860 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPrefixRandom.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPrefixRandom.java
@@ -64,7 +64,7 @@ public class TestPrefixRandom extends LuceneTestCase {
     final String codec = Codec.getDefault().getName();
     int num = codec.equals("Lucene3x") ? 200 * RANDOM_MULTIPLIER : atLeast(1000);
     for (int i = 0; i < num; i++) {
-      field.setValue(_TestUtil.randomUnicodeString(random, 10));
+      field.setStringValue(_TestUtil.randomUnicodeString(random, 10));
       writer.addDocument(doc);
     }
     reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom.java b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom.java
index 95060ca..11d499e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom.java
@@ -60,7 +60,7 @@ public class TestRegexpRandom extends LuceneTestCase {
     
     NumberFormat df = new DecimalFormat("000", new DecimalFormatSymbols(Locale.ENGLISH));
     for (int i = 0; i < 1000; i++) {
-      field.setValue(df.format(i));
+      field.setStringValue(df.format(i));
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
index 44a7801..64e5d59 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestRegexpRandom2.java
@@ -72,7 +72,7 @@ public class TestRegexpRandom2 extends LuceneTestCase {
     int num = atLeast(200);
     for (int i = 0; i < num; i++) {
       String s = _TestUtil.randomUnicodeString(random);
-      field.setValue(s);
+      field.setStringValue(s);
       terms.add(s);
       writer.addDocument(doc);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSearchWithThreads.java b/lucene/core/src/test/org/apache/lucene/search/TestSearchWithThreads.java
index 47f6f49..3de902d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSearchWithThreads.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSearchWithThreads.java
@@ -55,7 +55,7 @@ public class TestSearchWithThreads extends LuceneTestCase {
         sb.append(random.nextBoolean() ? "aaa" : "bbb");
         sb.append(' ');
       }
-      body.setValue(sb.toString());
+      body.setStringValue(sb.toString());
       w.addDocument(doc);
       sb.delete(0, sb.length());
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimilarityProvider.java b/lucene/core/src/test/org/apache/lucene/search/TestSimilarityProvider.java
index 979fca5..4f52f03 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimilarityProvider.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimilarityProvider.java
@@ -54,11 +54,11 @@ public class TestSimilarityProvider extends LuceneTestCase {
     Field field2 = newField("bar", "", TextField.TYPE_UNSTORED);
     doc.add(field2);
     
-    field.setValue("quick brown fox");
-    field2.setValue("quick brown fox");
+    field.setStringValue("quick brown fox");
+    field2.setStringValue("quick brown fox");
     iw.addDocument(doc);
-    field.setValue("jumps over lazy brown dog");
-    field2.setValue("jumps over lazy brown dog");
+    field.setStringValue("jumps over lazy brown dog");
+    field2.setStringValue("jumps over lazy brown dog");
     iw.addDocument(doc);
     reader = iw.getReader();
     iw.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSloppyPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSloppyPhraseQuery.java
index 42c06db..fc1782b 100755
--- a/lucene/core/src/test/org/apache/lucene/search/TestSloppyPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSloppyPhraseQuery.java
@@ -239,13 +239,13 @@ public class TestSloppyPhraseQuery extends LuceneTestCase {
     Field f = new Field("lyrics", "", customType);
     Document doc = new Document();
     doc.add(f);
-    f.setValue("drug drug");
+    f.setStringValue("drug drug");
     iw.addDocument(doc);
-    f.setValue("drug druggy drug");
+    f.setStringValue("drug druggy drug");
     iw.addDocument(doc);
-    f.setValue("drug druggy druggy drug");
+    f.setStringValue("drug druggy druggy drug");
     iw.addDocument(doc);
-    f.setValue("drug druggy drug druggy drug");
+    f.setStringValue("drug druggy drug druggy drug");
     iw.addDocument(doc);
     IndexReader ir = iw.getReader();
     iw.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
index fab180f..9734057 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
@@ -22,7 +22,8 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.AtomicReaderContext;
@@ -30,7 +31,6 @@ import org.apache.lucene.index.CompositeReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -97,7 +97,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
         final Document doc = new Document();
         doc.add(newField("string", _TestUtil.randomRealisticUnicodeString(random), StringField.TYPE_UNSTORED));
         doc.add(newField("text", content[random.nextInt(content.length)], TextField.TYPE_UNSTORED));
-        doc.add(new NumericField("float", random.nextFloat()));
+        doc.add(new FloatField("float", random.nextFloat()));
         final int intValue;
         if (random.nextInt(100) == 17) {
           intValue = Integer.MIN_VALUE;
@@ -106,7 +106,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
         } else {
           intValue = random.nextInt();
         }
-        doc.add(new NumericField("int", intValue));
+        doc.add(new IntField("int", intValue));
         if (VERBOSE) {
           System.out.println("  doc=" + doc);
         }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestWildcardRandom.java b/lucene/core/src/test/org/apache/lucene/search/TestWildcardRandom.java
index d7a5a9c..f5d8f2b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestWildcardRandom.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestWildcardRandom.java
@@ -57,7 +57,7 @@ public class TestWildcardRandom extends LuceneTestCase {
     
     NumberFormat df = new DecimalFormat("000", new DecimalFormatSymbols(Locale.ENGLISH));
     for (int i = 0; i < 1000; i++) {
-      field.setValue(df.format(i));
+      field.setStringValue(df.format(i));
       writer.addDocument(doc);
     }
     
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
index 02cc898..e0d0ab6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
@@ -46,11 +46,11 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     Field field = newField("field", "", TextField.TYPE_UNSTORED);
     doc.add(field);
     
-    field.setValue("quick brown fox");
+    field.setStringValue("quick brown fox");
     iw.addDocument(doc);
-    field.setValue("jumps over lazy broun dog");
+    field.setStringValue("jumps over lazy broun dog");
     iw.addDocument(doc);
-    field.setValue("jumps over extremely very lazy broxn dog");
+    field.setStringValue("jumps over extremely very lazy broxn dog");
     iw.addDocument(doc);
     reader = iw.getReader();
     iw.close();
diff --git a/lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java b/lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java
index 121af4c..d521249 100644
--- a/lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java
+++ b/lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java
@@ -161,8 +161,8 @@ public class TestMultiMMap extends LuceneTestCase {
     
     int numDocs = 100;
     for (int i = 0; i < numDocs; i++) {
-      docid.setValue("" + i);
-      junk.setValue(_TestUtil.randomUnicodeString(random));
+      docid.setStringValue("" + i);
+      junk.setStringValue(_TestUtil.randomUnicodeString(random));
       writer.addDocument(doc);
     }
     IndexReader reader = writer.getReader();
diff --git a/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java b/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
index 02c7840..cccb850 100644
--- a/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
+++ b/lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
@@ -1627,7 +1627,7 @@ public class TestFSTs extends LuceneTestCase {
           }
         }
         allIDs.add(idString);
-        idField.setValue(idString);
+        idField.setStringValue(idString);
         w.addDocument(doc);
       }
 
@@ -1752,7 +1752,7 @@ public class TestFSTs extends LuceneTestCase {
     }
 
     for(String term : allTerms) {
-      f.setValue(term);
+      f.setStringValue(term);
       w.addDocument(doc);
     }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java b/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
index a180844..e893199 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
@@ -25,6 +25,7 @@ import java.util.Random;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.document.DocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
@@ -176,9 +177,6 @@ public class RandomIndexWriter implements Closeable {
     String name = "random_" + type.name() + "" + docValuesFieldPrefix;
     if ("Lucene3x".equals(codec.getName()) || doc.getField(name) != null)
         return;
-    FieldType ft = new FieldType();
-    ft.setDocValueType(type);
-    ft.freeze();
     final Field f;
     switch (type) {
     case BYTES_FIXED_DEREF:
@@ -193,33 +191,33 @@ public class RandomIndexWriter implements Closeable {
         fixedRef.grow(fixedBytesLength);
         fixedRef.length = fixedBytesLength;
       }
-      f = new Field(name, fixedRef, ft);
+      f = new DocValuesField(name, fixedRef, type);
       break;
     case BYTES_VAR_DEREF:
     case BYTES_VAR_STRAIGHT:
     case BYTES_VAR_SORTED:
-      f = new Field(name, new BytesRef(_TestUtil.randomUnicodeString(random, 200)), ft);
+      f = new DocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(random, 200)), type);
       break;
     case FLOAT_32:
-      f = new Field(name, random.nextFloat(), ft);
+      f = new DocValuesField(name, random.nextFloat(), type);
       break;
     case FLOAT_64:
-      f = new Field(name, random.nextDouble(), ft);
+      f = new DocValuesField(name, random.nextDouble(), type);
       break;
     case VAR_INTS:
-      f = new Field(name, random.nextLong(), ft);
+      f = new DocValuesField(name, random.nextLong(), type);
       break;
     case FIXED_INTS_16:
-      f = new Field(name, random.nextInt(Short.MAX_VALUE), ft);
+      f = new DocValuesField(name, random.nextInt(Short.MAX_VALUE), type);
       break;
     case FIXED_INTS_32:
-      f = new Field(name, random.nextInt(), ft);
+      f = new DocValuesField(name, random.nextInt(), type);
       break;
     case FIXED_INTS_64:
-      f = new Field(name, random.nextLong(), ft);
+      f = new DocValuesField(name, random.nextLong(), type);
       break;
     case FIXED_INTS_8:
-      f = new Field(name, random.nextInt(128), ft);
+      f = new DocValuesField(name, random.nextInt(128), type);
       break;
     default:
       throw new IllegalArgumentException("no such type: " + type);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java b/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
index 1ef7340..3185cf1 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
@@ -175,12 +175,12 @@ public class LineFileDocs implements Closeable {
       throw new RuntimeException("line: [" + line + "] is in an invalid format !");
     }
 
-    docState.body.setValue(line.substring(1+spot2, line.length()));
+    docState.body.setStringValue(line.substring(1+spot2, line.length()));
     final String title = line.substring(0, spot);
-    docState.title.setValue(title);
-    docState.titleTokenized.setValue(title);
-    docState.date.setValue(line.substring(1+spot, spot2));
-    docState.id.setValue(Integer.toString(id.getAndIncrement()));
+    docState.title.setStringValue(title);
+    docState.titleTokenized.setStringValue(title);
+    docState.date.setStringValue(line.substring(1+spot, spot2));
+    docState.id.setStringValue(Integer.toString(id.getAndIncrement()));
     return docState.doc;
   }
 }
diff --git a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
index 75eb5b5..c68b045 100644
--- a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
+++ b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
@@ -20,22 +20,26 @@ package org.apache.lucene.benchmark.byTask.feeds;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.util.HashMap;
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
 import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
-import java.util.Locale;
 import java.util.Random;
-import java.util.Date;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.text.SimpleDateFormat;
-import java.text.ParsePosition;
 
 import org.apache.lucene.benchmark.byTask.utils.Config;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 
@@ -89,7 +93,7 @@ public class DocMaker implements Closeable {
   static class DocState {
     
     private final Map<String,Field> fields;
-    private final Map<String,NumericField> numericFields;
+    private final Map<String,Field> numericFields;
     private final boolean reuseFields;
     final Document doc;
     DocData docData = new DocData();
@@ -100,7 +104,7 @@ public class DocMaker implements Closeable {
       
       if (reuseFields) {
         fields =  new HashMap<String,Field>();
-        numericFields = new HashMap<String,NumericField>();
+        numericFields = new HashMap<String,Field>();
         
         // Initialize the map with the default fields.
         fields.put(BODY_FIELD, new Field(BODY_FIELD, "", bodyFt));
@@ -109,8 +113,8 @@ public class DocMaker implements Closeable {
         fields.put(ID_FIELD, new Field(ID_FIELD, "", StringField.TYPE_STORED));
         fields.put(NAME_FIELD, new Field(NAME_FIELD, "", ft));
 
-        numericFields.put(DATE_MSEC_FIELD, new NumericField(DATE_MSEC_FIELD, 0L));
-        numericFields.put(TIME_SEC_FIELD, new NumericField(TIME_SEC_FIELD, 0));
+        numericFields.put(DATE_MSEC_FIELD, new LongField(DATE_MSEC_FIELD, 0L));
+        numericFields.put(TIME_SEC_FIELD, new IntField(TIME_SEC_FIELD, 0));
         
         doc = new Document();
       } else {
@@ -138,8 +142,8 @@ public class DocMaker implements Closeable {
       return f;
     }
 
-    NumericField getNumericField(String name, NumericField.DataType type) {
-      NumericField f;
+    Field getNumericField(String name, NumericType type) {
+      Field f;
       if (reuseFields) {
         f = numericFields.get(name);
       } else {
@@ -149,16 +153,16 @@ public class DocMaker implements Closeable {
       if (f == null) {
         switch(type) {
         case INT:
-          f = new NumericField(name, 0);
+          f = new IntField(name, 0);
           break;
         case LONG:
-          f = new NumericField(name, 0L);
+          f = new LongField(name, 0L);
           break;
         case FLOAT:
-          f = new NumericField(name, 0.0f);
+          f = new FloatField(name, 0.0F);
           break;
         case DOUBLE:
-          f = new NumericField(name, 0.0);
+          f = new DoubleField(name, 0.0);
           break;
         default:
           assert false;
@@ -233,7 +237,7 @@ public class DocMaker implements Closeable {
         id = numDocsCreated.getAndIncrement();
       }
     }
-    idField.setValue(Integer.toString(id));
+    idField.setStringValue(Integer.toString(id));
     doc.add(idField);
     
     // Set NAME_FIELD
@@ -241,7 +245,7 @@ public class DocMaker implements Closeable {
     if (name == null) name = "";
     name = cnt < 0 ? name : name + "_" + cnt;
     Field nameField = ds.getField(NAME_FIELD, valType);
-    nameField.setValue(name);
+    nameField.setStringValue(name);
     doc.add(nameField);
     
     // Set DATE_FIELD
@@ -260,7 +264,7 @@ public class DocMaker implements Closeable {
       dateString = "";
     }
     Field dateStringField = ds.getField(DATE_FIELD, valType);
-    dateStringField.setValue(dateString);
+    dateStringField.setStringValue(dateString);
     doc.add(dateStringField);
 
     if (date == null) {
@@ -268,21 +272,21 @@ public class DocMaker implements Closeable {
       date = new Date();
     }
 
-    NumericField dateField = ds.getNumericField(DATE_MSEC_FIELD, NumericField.DataType.LONG);
-    dateField.setValue(date.getTime());
+    Field dateField = ds.getNumericField(DATE_MSEC_FIELD, NumericType.LONG);
+    dateField.setLongValue(date.getTime());
     doc.add(dateField);
 
     util.cal.setTime(date);
     final int sec = util.cal.get(Calendar.HOUR_OF_DAY)*3600 + util.cal.get(Calendar.MINUTE)*60 + util.cal.get(Calendar.SECOND);
 
-    NumericField timeSecField = ds.getNumericField(TIME_SEC_FIELD, NumericField.DataType.INT);
-    timeSecField.setValue(sec);
+    Field timeSecField = ds.getNumericField(TIME_SEC_FIELD, NumericType.INT);
+    timeSecField.setIntValue(sec);
     doc.add(timeSecField);
     
     // Set TITLE_FIELD
     String title = docData.getTitle();
     Field titleField = ds.getField(TITLE_FIELD, valType);
-    titleField.setValue(title == null ? "" : title);
+    titleField.setStringValue(title == null ? "" : title);
     doc.add(titleField);
     
     String body = docData.getBody();
@@ -303,12 +307,12 @@ public class DocMaker implements Closeable {
         docData.setBody(body.substring(size)); // some left
       }
       Field bodyField = ds.getField(BODY_FIELD, bodyValType);
-      bodyField.setValue(bdy);
+      bodyField.setStringValue(bdy);
       doc.add(bodyField);
       
       if (storeBytes) {
         Field bytesField = ds.getField(BYTES_FIELD, StringField.TYPE_STORED);
-        bytesField.setValue(bdy.getBytes("UTF-8"));
+        bytesField.setBytesValue(bdy.getBytes("UTF-8"));
         doc.add(bytesField);
       }
     }
@@ -318,7 +322,7 @@ public class DocMaker implements Closeable {
       if (props != null) {
         for (final Map.Entry<Object,Object> entry : props.entrySet()) {
           Field f = ds.getField((String) entry.getKey(), valType);
-          f.setValue((String) entry.getValue());
+          f.setStringValue((String) entry.getValue());
           doc.add(f);
         }
         docData.setProps(null);
diff --git a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java
index 3e2ce92..a459afc 100644
--- a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java
+++ b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java
@@ -26,7 +26,10 @@ import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.feeds.DocMaker;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.index.IndexableField;
 
 /**
@@ -69,7 +72,13 @@ public class ReadTokensTask extends PerfTask {
     Analyzer analyzer = getRunData().getAnalyzer();
     int tokenCount = 0;
     for(final IndexableField field : fields) {
-      if (!field.fieldType().tokenized() || field instanceof NumericField) continue;
+      if (!field.fieldType().tokenized() ||
+          field instanceof IntField ||
+          field instanceof LongField ||
+          field instanceof FloatField ||
+          field instanceof DoubleField) {
+        continue;
+      }
       
       final TokenStream stream = field.tokenStream(analyzer);
       // reset the TokenStream to the first token
diff --git a/modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java b/modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
index 60ebf70..e1dfbea 100644
--- a/modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
+++ b/modules/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
@@ -549,7 +549,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
     Document d = new Document();
     d.add(parentStreamField);
 
-    fullPathField.setValue(categoryPath.toString(delimiter, length));
+    fullPathField.setStringValue(categoryPath.toString(delimiter, length));
     d.add(fullPathField);
 
     // Note that we do no pass an Analyzer here because the fields that are
diff --git a/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java b/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
index 8cf67e1..4e1f822 100644
--- a/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
+++ b/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
@@ -227,7 +227,7 @@ public class AllGroupHeadsCollectorTest extends LuceneTestCase {
       Field content = newField("content", "", TextField.TYPE_UNSTORED);
       doc.add(content);
       docNoGroup.add(content);
-      NumericField id = new NumericField("id", 0);
+      IntField id = new IntField("id", 0);
       doc.add(id);
       docNoGroup.add(id);
       final GroupDoc[] groupDocs = new GroupDoc[numDocs];
@@ -256,16 +256,16 @@ public class AllGroupHeadsCollectorTest extends LuceneTestCase {
 
         groupDocs[i] = groupDoc;
         if (groupDoc.group != null) {
-          group.setValue(groupDoc.group.utf8ToString());
+          group.setStringValue(groupDoc.group.utf8ToString());
           if (canUseIDV) {
-            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));
+            valuesField.setBytesValue(new BytesRef(groupDoc.group.utf8ToString()));
           }
         }
-        sort1.setValue(groupDoc.sort1.utf8ToString());
-        sort2.setValue(groupDoc.sort2.utf8ToString());
-        sort3.setValue(groupDoc.sort3.utf8ToString());
-        content.setValue(groupDoc.content);
-        id.setValue(groupDoc.id);
+        sort1.setStringValue(groupDoc.sort1.utf8ToString());
+        sort2.setStringValue(groupDoc.sort2.utf8ToString());
+        sort3.setStringValue(groupDoc.sort3.utf8ToString());
+        content.setStringValue(groupDoc.content);
+        id.setIntValue(groupDoc.id);
         if (groupDoc.group == null) {
           w.addDocument(docNoGroup);
         } else {
diff --git a/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java b/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index ae33f56..d5a77ee 100644
--- a/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ b/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -595,7 +595,7 @@ public class TestGrouping extends LuceneTestCase {
         }
         doc.add(newField("sort1", groupValue.sort1.utf8ToString(), StringField.TYPE_UNSTORED));
         doc.add(newField("sort2", groupValue.sort2.utf8ToString(), StringField.TYPE_UNSTORED));
-        doc.add(new NumericField("id", groupValue.id));
+        doc.add(new IntField("id", groupValue.id));
         doc.add(newField("content", groupValue.content, TextField.TYPE_UNSTORED));
         //System.out.println("TEST:     doc content=" + groupValue.content + " group=" + (groupValue.group == null ? "null" : groupValue.group.utf8ToString()) + " sort1=" + groupValue.sort1.utf8ToString() + " id=" + groupValue.id);
       }
@@ -721,7 +721,7 @@ public class TestGrouping extends LuceneTestCase {
       Field content = newField("content", "", TextField.TYPE_UNSTORED);
       doc.add(content);
       docNoGroup.add(content);
-      NumericField id = new NumericField("id", 0);
+      IntField id = new IntField("id", 0);
       doc.add(id);
       docNoGroup.add(id);
       final GroupDoc[] groupDocs = new GroupDoc[numDocs];
@@ -745,15 +745,15 @@ public class TestGrouping extends LuceneTestCase {
 
         groupDocs[i] = groupDoc;
         if (groupDoc.group != null) {
-          group.setValue(groupDoc.group.utf8ToString());
+          group.setStringValue(groupDoc.group.utf8ToString());
           if (canUseIDV) {
-            idvGroupField.setValue(BytesRef.deepCopyOf(groupDoc.group));
+            idvGroupField.setBytesValue(BytesRef.deepCopyOf(groupDoc.group));
           }
         }
-        sort1.setValue(groupDoc.sort1.utf8ToString());
-        sort2.setValue(groupDoc.sort2.utf8ToString());
-        content.setValue(groupDoc.content);
-        id.setValue(groupDoc.id);
+        sort1.setStringValue(groupDoc.sort1.utf8ToString());
+        sort2.setStringValue(groupDoc.sort2.utf8ToString());
+        content.setStringValue(groupDoc.content);
+        id.setIntValue(groupDoc.id);
         if (groupDoc.group == null) {
           w.addDocument(docNoGroup);
         } else {
diff --git a/modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java b/modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
index f60a7a6..b5f4dc1 100644
--- a/modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
+++ b/modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
@@ -25,7 +25,7 @@ import java.util.List;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.AtomicReaderContext;
@@ -59,7 +59,7 @@ public class TestBlockJoin extends LuceneTestCase {
   private Document makeJob(String skill, int year) {
     Document job = new Document();
     job.add(newField("skill", skill, StringField.TYPE_STORED));
-    job.add(new NumericField("year", year));
+    job.add(new IntField("year", year));
     job.add(new StoredField("year", year));
     return job;
   }
@@ -68,7 +68,7 @@ public class TestBlockJoin extends LuceneTestCase {
   private Document makeQualification(String qualification, int year) {
     Document job = new Document();
     job.add(newField("qualification", qualification, StringField.TYPE_STORED));
-    job.add(new NumericField("year", year));
+    job.add(new IntField("year", year));
     return job;
   }
 
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java
index f6d03e9..cce60af 100644
--- a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/NumericRangeQueryNodeBuilder.java
@@ -17,12 +17,12 @@ package org.apache.lucene.queryparser.flexible.standard.builders;
  * limitations under the License.
  */
 
-import org.apache.lucene.document.NumericField;
-import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
 import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
 import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
 import org.apache.lucene.queryparser.flexible.standard.nodes.NumericQueryNode;
 import org.apache.lucene.queryparser.flexible.standard.nodes.NumericRangeQueryNode;
@@ -54,7 +54,7 @@ public class NumericRangeQueryNodeBuilder implements StandardQueryBuilder {
     Number upperNumber = upperNumericNode.getValue();
     
     NumericConfig numericConfig = numericRangeNode.getNumericConfig();
-    NumericField.DataType numberType = numericConfig.getType();
+    NumericType numberType = numericConfig.getType();
     String field = StringUtils.toString(numericRangeNode.getField());
     boolean minInclusive = numericRangeNode.isLowerInclusive();
     boolean maxInclusive = numericRangeNode.isUpperInclusive();
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java
index 1258e3b..af89d42 100644
--- a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/NumericConfig.java
@@ -19,7 +19,7 @@ package org.apache.lucene.queryparser.flexible.standard.config;
 
 import java.text.NumberFormat;
 
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.search.NumericRangeQuery;
 
 /**
@@ -35,7 +35,7 @@ public class NumericConfig {
   
   private NumberFormat format;
   
-  private NumericField.DataType type;
+  private NumericType type;
   
   /**
    * Constructs a {@link NumericConfig} object.
@@ -50,10 +50,10 @@ public class NumericConfig {
    * 
    * @see NumericConfig#setPrecisionStep(int)
    * @see NumericConfig#setNumberFormat(NumberFormat)
-   * @see #setType(org.apache.lucene.document.NumericField.DataType)
+   * @see #setType(org.apache.lucene.document.FieldType.NumericType)
    */
   public NumericConfig(int precisionStep, NumberFormat format,
-      NumericField.DataType type) {
+      NumericType type) {
     setPrecisionStep(precisionStep);
     setNumberFormat(format);
     setType(type);
@@ -99,7 +99,7 @@ public class NumericConfig {
    * 
    * @return the numeric type used to index the numeric values
    */
-  public NumericField.DataType getType() {
+  public NumericType getType() {
     return type;
   }
   
@@ -108,7 +108,7 @@ public class NumericConfig {
    * 
    * @param type the numeric type used to index the numeric values
    */
-  public void setType(NumericField.DataType type) {
+  public void setType(NumericType type) {
     
     if (type == null) {
       throw new IllegalArgumentException("type cannot be null!");
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java
index a5aa937..68d0037 100644
--- a/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/NumericRangeQueryNode.java
@@ -1,12 +1,5 @@
 package org.apache.lucene.queryparser.flexible.standard.nodes;
 
-import org.apache.lucene.document.NumericField;
-import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
-import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
-import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
-import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
-import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
-
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with this
@@ -24,6 +17,13 @@ import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
  * the License.
  */
 
+import org.apache.lucene.document.FieldType.NumericType;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
+import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
+import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.NumericConfig;
+
 /**
  * This query node represents a range query composed by {@link NumericQueryNode}
  * bounds, which means the bound values are {@link Number}s.
@@ -53,16 +53,16 @@ public class NumericRangeQueryNode extends
     setBounds(lower, upper, lowerInclusive, upperInclusive, numericConfig);
   }
   
-  private static NumericField.DataType getNumericDataType(Number number) throws QueryNodeException {
+  private static NumericType getNumericDataType(Number number) throws QueryNodeException {
     
     if (number instanceof Long) {
-      return NumericField.DataType.LONG;
+      return NumericType.LONG;
     } else if (number instanceof Integer) {
-      return NumericField.DataType.INT;
+      return NumericType.INT;
     } else if (number instanceof Double) {
-      return NumericField.DataType.DOUBLE;
+      return NumericType.DOUBLE;
     } else if (number instanceof Float) {
-      return NumericField.DataType.FLOAT;
+      return NumericType.FLOAT;
     } else {
       throw new QueryNodeException(
           new MessageImpl(
@@ -90,7 +90,7 @@ public class NumericRangeQueryNode extends
       throw new IllegalArgumentException("numericConfig cannot be null!");
     }
     
-    NumericField.DataType lowerNumberType, upperNumberType;
+    NumericType lowerNumberType, upperNumberType;
     
     if (lower != null && lower.getValue() != null) {
       lowerNumberType = getNumericDataType(lower.getValue());
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
index c257896..bf558ae 100644
--- a/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
@@ -33,8 +33,13 @@ import java.util.TimeZone;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoubleField;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType.NumericType;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
@@ -171,10 +176,10 @@ public class TestNumericQueryParser extends LuceneTestCase {
     while ((randomInt = normalizeNumber(Math.abs(random.nextInt())).intValue()) == 0)
       ;
     
-    randomNumberMap.put(NumericField.DataType.LONG.name(), randomLong);
-    randomNumberMap.put(NumericField.DataType.INT.name(), randomInt);
-    randomNumberMap.put(NumericField.DataType.FLOAT.name(), randomFloat);
-    randomNumberMap.put(NumericField.DataType.DOUBLE.name(), randomDouble);
+    randomNumberMap.put(NumericType.LONG.name(), randomLong);
+    randomNumberMap.put(NumericType.INT.name(), randomInt);
+    randomNumberMap.put(NumericType.FLOAT.name(), randomFloat);
+    randomNumberMap.put(NumericType.DOUBLE.name(), randomDouble);
     randomNumberMap.put(DATE_FIELD_NAME, randomDate);
     
     RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);
@@ -187,29 +192,32 @@ public class TestNumericQueryParser extends LuceneTestCase {
     
     Document doc = new Document();
     HashMap<String,NumericConfig> numericConfigMap = new HashMap<String,NumericConfig>();
-    HashMap<String,NumericField> numericFieldMap = new HashMap<String,NumericField>();
+    HashMap<String,Field> numericFieldMap = new HashMap<String,Field>();
     qp.setNumericConfigMap(numericConfigMap);
     
-    for (NumericField.DataType type : NumericField.DataType.values()) {
+    for (NumericType type : NumericType.values()) {
       numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,
           NUMBER_FORMAT, type));
 
-      FieldType ft = new FieldType(NumericField.getFieldType(type, true));
+      FieldType ft = new FieldType(IntField.TYPE);
+      ft.setNumericType(type);
+      ft.setStored(true);
       ft.setNumericPrecisionStep(PRECISION_STEP);
-      final NumericField field;
+      ft.freeze();
+      final Field field;
 
       switch(type) {
       case INT:
-        field = new NumericField(type.name(), 0, ft);
+        field = new IntField(type.name(), 0, ft);
         break;
       case FLOAT:
-        field = new NumericField(type.name(), 0.0f, ft);
+        field = new FloatField(type.name(), 0.0f, ft);
         break;
       case LONG:
-        field = new NumericField(type.name(), 0l, ft);
+        field = new LongField(type.name(), 0l, ft);
         break;
       case DOUBLE:
-        field = new NumericField(type.name(), 0.0, ft);
+        field = new DoubleField(type.name(), 0.0, ft);
         break;
       default:
         assert false;
@@ -220,10 +228,11 @@ public class TestNumericQueryParser extends LuceneTestCase {
     }
     
     numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,
-        DATE_FORMAT, NumericField.DataType.LONG));
-    FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));
+        DATE_FORMAT, NumericType.LONG));
+    FieldType ft = new FieldType(LongField.TYPE);
+    ft.setStored(true);
     ft.setNumericPrecisionStep(PRECISION_STEP);
-    NumericField dateField = new NumericField(DATE_FIELD_NAME, 0l, ft);
+    LongField dateField = new LongField(DATE_FIELD_NAME, 0l, ft);
     numericFieldMap.put(DATE_FIELD_NAME, dateField);
     doc.add(dateField);
     
@@ -253,17 +262,17 @@ public class TestNumericQueryParser extends LuceneTestCase {
       case NEGATIVE:
         Number number = RANDOM_NUMBER_MAP.get(fieldName);
         
-        if (NumericField.DataType.LONG.name().equals(fieldName)
+        if (NumericType.LONG.name().equals(fieldName)
             || DATE_FIELD_NAME.equals(fieldName)) {
           number = -number.longValue();
           
-        } else if (NumericField.DataType.DOUBLE.name().equals(fieldName)) {
+        } else if (NumericType.DOUBLE.name().equals(fieldName)) {
           number = -number.doubleValue();
           
-        } else if (NumericField.DataType.FLOAT.name().equals(fieldName)) {
+        } else if (NumericType.FLOAT.name().equals(fieldName)) {
           number = -number.floatValue();
           
-        } else if (NumericField.DataType.INT.name().equals(fieldName)) {
+        } else if (NumericType.INT.name().equals(fieldName)) {
           number = -number.intValue();
           
         } else {
@@ -281,27 +290,27 @@ public class TestNumericQueryParser extends LuceneTestCase {
   }
   
   private static void setFieldValues(NumberType numberType,
-      HashMap<String,NumericField> numericFieldMap) {
+      HashMap<String,Field> numericFieldMap) {
     
-    Number number = getNumberType(numberType, NumericField.DataType.DOUBLE
+    Number number = getNumberType(numberType, NumericType.DOUBLE
         .name());
-    numericFieldMap.get(NumericField.DataType.DOUBLE.name()).setValue(
+    numericFieldMap.get(NumericType.DOUBLE.name()).setDoubleValue(
         number.doubleValue());
     
-    number = getNumberType(numberType, NumericField.DataType.INT.name());
-    numericFieldMap.get(NumericField.DataType.INT.name()).setValue(
+    number = getNumberType(numberType, NumericType.INT.name());
+    numericFieldMap.get(NumericType.INT.name()).setIntValue(
         number.intValue());
     
-    number = getNumberType(numberType, NumericField.DataType.LONG.name());
-    numericFieldMap.get(NumericField.DataType.LONG.name()).setValue(
+    number = getNumberType(numberType, NumericType.LONG.name());
+    numericFieldMap.get(NumericType.LONG.name()).setLongValue(
         number.longValue());
     
-    number = getNumberType(numberType, NumericField.DataType.FLOAT.name());
-    numericFieldMap.get(NumericField.DataType.FLOAT.name()).setValue(
+    number = getNumberType(numberType, NumericType.FLOAT.name());
+    numericFieldMap.get(NumericType.FLOAT.name()).setFloatValue(
         number.floatValue());
     
     number = getNumberType(numberType, DATE_FIELD_NAME);
-    numericFieldMap.get(DATE_FIELD_NAME).setValue(number.longValue());
+    numericFieldMap.get(DATE_FIELD_NAME).setLongValue(number.longValue());
   }
   
   private static int randomDateStyle(Random random) {
@@ -399,7 +408,7 @@ public class TestNumericQueryParser extends LuceneTestCase {
     String lowerInclusiveStr = (lowerInclusive ? "[" : "{");
     String upperInclusiveStr = (upperInclusive ? "]" : "}");
     
-    for (NumericField.DataType type : NumericField.DataType.values()) {
+    for (NumericType type : NumericType.values()) {
       String lowerStr = numberToString(getNumberType(lowerType, type.name()));
       String upperStr = numberToString(getNumberType(upperType, type.name()));
       
@@ -445,7 +454,7 @@ public class TestNumericQueryParser extends LuceneTestCase {
 
     StringBuilder sb = new StringBuilder();
     
-    for (NumericField.DataType type : NumericField.DataType.values()) {
+    for (NumericType type : NumericType.values()) {
       String boundStr = numberToString(getNumberType(boundType, type.name()));
       
       sb.append("+").append(type.name()).append(operator).append('"').append(boundStr).append('"').append(' ');
@@ -464,7 +473,7 @@ public class TestNumericQueryParser extends LuceneTestCase {
       throws QueryNodeException, IOException {
     StringBuilder sb = new StringBuilder();
     
-    for (NumericField.DataType type : NumericField.DataType.values()) {
+    for (NumericType type : NumericType.values()) {
       String numberStr = numberToString(getNumberType(numberType, type.name()));
       sb.append('+').append(type.name()).append(":\"").append(numberStr)
           .append("\" ");
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java
index af320cf..1d8f9eb 100644
--- a/modules/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/xml/TestParser.java
@@ -22,7 +22,7 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
@@ -69,7 +69,7 @@ public class TestParser extends LuceneTestCase {
       Document doc = new Document();
       doc.add(newField("date", date, TextField.TYPE_STORED));
       doc.add(newField("contents", content, TextField.TYPE_STORED));
-      doc.add(new NumericField("date2", Integer.valueOf(date)));
+      doc.add(new IntField("date2", Integer.valueOf(date)));
       writer.addDocument(doc);
       line = d.readLine();
     }
diff --git a/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java b/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
index 9e3a832..73e9cf0 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/QueryComponent.java
@@ -504,7 +504,7 @@ public class QueryComponent extends SearchComponent
           // indexedToReadable() should be a no-op and should
           // thus be harmless anyway (for all current ways anyway)
           if (val instanceof String) {
-            field.setValue((String)val);
+            field.setStringValue((String)val);
             val = ft.toObject(field);
           }
 
@@ -513,7 +513,7 @@ public class QueryComponent extends SearchComponent
           // data as BytesRef:
           if (val instanceof BytesRef) {
             UnicodeUtil.UTF8toUTF16((BytesRef)val, spare);
-            field.setValue(spare.toString());
+            field.setStringValue(spare.toString());
             val = ft.toObject(field);
           }
 
diff --git a/solr/core/src/java/org/apache/solr/response/transform/ElevatedMarkerFactory.java b/solr/core/src/java/org/apache/solr/response/transform/ElevatedMarkerFactory.java
index 049d9e5..db6852c 100644
--- a/solr/core/src/java/org/apache/solr/response/transform/ElevatedMarkerFactory.java
+++ b/solr/core/src/java/org/apache/solr/response/transform/ElevatedMarkerFactory.java
@@ -20,7 +20,6 @@ package org.apache.solr.response.transform;
 import java.util.Set;
 
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
diff --git a/solr/core/src/java/org/apache/solr/response/transform/ExcludedMarkerFactory.java b/solr/core/src/java/org/apache/solr/response/transform/ExcludedMarkerFactory.java
index 29e670e3..c8e4cf0 100644
--- a/solr/core/src/java/org/apache/solr/response/transform/ExcludedMarkerFactory.java
+++ b/solr/core/src/java/org/apache/solr/response/transform/ExcludedMarkerFactory.java
@@ -20,7 +20,6 @@ package org.apache.solr.response.transform;
 import java.util.Set;
 
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.NumericField;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.handler.component.QueryElevationComponent;
diff --git a/solr/core/src/java/org/apache/solr/schema/TrieField.java b/solr/core/src/java/org/apache/solr/schema/TrieField.java
index 705f7e3..92e4764 100644
--- a/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -16,16 +16,24 @@
  */
 package org.apache.solr.schema;
 
+import java.io.IOException;
+import java.util.Date;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.FieldType.NumericType;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.LongField;
 import org.apache.lucene.index.IndexableField;
-import org.apache.lucene.search.*;
-
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
 import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
 import org.apache.lucene.queries.function.valuesource.IntFieldSource;
 import org.apache.lucene.queries.function.valuesource.LongFieldSource;
+import org.apache.lucene.search.*;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.NumericUtils;
@@ -37,13 +45,10 @@ import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.*;
 
-import java.io.IOException;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Date;
-
 /**
- * Provides field types to support for Lucene's {@link NumericField}.
+ * Provides field types to support for Lucene's {@link
+ * IntField}, {@link LongField}, {@link FloatField} and
+ * {@link DoubleField}.
  * See {@link org.apache.lucene.search.NumericRangeQuery} for more details.
  * It supports integer, float, long, double and date types.
  * <p/>
@@ -481,57 +486,57 @@ public class TrieField extends org.apache.solr.schema.FieldType {
 
     switch (type) {
       case INTEGER:
-        ft.setNumericType(NumericField.DataType.INT);
+        ft.setNumericType(NumericType.INT);
         break;
       case FLOAT:
-        ft.setNumericType(NumericField.DataType.FLOAT);
+        ft.setNumericType(NumericType.FLOAT);
         break;
       case LONG:
-        ft.setNumericType(NumericField.DataType.LONG);
+        ft.setNumericType(NumericType.LONG);
         break;
       case DOUBLE:
-        ft.setNumericType(NumericField.DataType.DOUBLE);
+        ft.setNumericType(NumericType.DOUBLE);
         break;
       case DATE:
-        ft.setNumericType(NumericField.DataType.LONG);
+        ft.setNumericType(NumericType.LONG);
         break;
       default:
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
     }
     ft.setNumericPrecisionStep(precisionStep);
 
-    final org.apache.lucene.document.NumericField f;
+    final org.apache.lucene.document.Field f;
 
     switch (type) {
       case INTEGER:
         int i = (value instanceof Number)
           ? ((Number)value).intValue()
           : Integer.parseInt(value.toString());
-        f = new org.apache.lucene.document.NumericField(field.getName(), i, ft);
+        f = new org.apache.lucene.document.IntField(field.getName(), i, ft);
         break;
       case FLOAT:
         float fl = (value instanceof Number)
           ? ((Number)value).floatValue()
           : Float.parseFloat(value.toString());
-        f = new org.apache.lucene.document.NumericField(field.getName(), fl, ft);
+        f = new org.apache.lucene.document.FloatField(field.getName(), fl, ft);
         break;
       case LONG:
         long l = (value instanceof Number)
           ? ((Number)value).longValue()
           : Long.parseLong(value.toString());
-        f = new org.apache.lucene.document.NumericField(field.getName(), l, ft);
+        f = new org.apache.lucene.document.LongField(field.getName(), l, ft);
         break;
       case DOUBLE:
         double d = (value instanceof Number)
           ? ((Number)value).doubleValue()
           : Double.parseDouble(value.toString());
-        f = new org.apache.lucene.document.NumericField(field.getName(), d, ft);
+        f = new org.apache.lucene.document.DoubleField(field.getName(), d, ft);
         break;
       case DATE:
         Date date = (value instanceof Date)
           ? ((Date)value)
           : dateField.parseMath(null, value.toString());
-        f = new org.apache.lucene.document.NumericField(field.getName(), date.getTime(), ft);
+        f = new org.apache.lucene.document.LongField(field.getName(), date.getTime(), ft);
         break;
       default:
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
diff --git a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 0bdab89..16b12cf 100644
--- a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -23,12 +23,15 @@ import java.net.URL;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.FloatField;
+import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.LazyDocument;
-import org.apache.lucene.document.NumericField;
+import org.apache.lucene.document.LongField;
+import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.*;
 import org.apache.lucene.index.AtomicReaderContext;
@@ -451,30 +454,34 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable,SolrIn
 
     @Override
     public void intField(FieldInfo fieldInfo, int value) {
-      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, true));
+      FieldType ft = new FieldType(IntField.TYPE);
+      ft.setStored(true);
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, value, ft));
+      doc.add(new IntField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void longField(FieldInfo fieldInfo, long value) {
-      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));
+      FieldType ft = new FieldType(LongField.TYPE);
+      ft.setStored(true);
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, value, ft));
+      doc.add(new LongField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void floatField(FieldInfo fieldInfo, float value) {
-      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.FLOAT, true));
+      FieldType ft = new FieldType(FloatField.TYPE);
+      ft.setStored(true);
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, value, ft));
+      doc.add(new FloatField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void doubleField(FieldInfo fieldInfo, double value) {
-      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.DOUBLE, true));
+      FieldType ft = new FieldType(DoubleField.TYPE);
+      ft.setStored(true);
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, value, ft));
+      doc.add(new DoubleField(fieldInfo.name, value, ft));
     }
   }
 
diff --git a/solr/core/src/test/org/apache/solr/search/TestSort.java b/solr/core/src/test/org/apache/solr/search/TestSort.java
index f7b249b..70bbdf1 100755
--- a/solr/core/src/test/org/apache/solr/search/TestSort.java
+++ b/solr/core/src/test/org/apache/solr/search/TestSort.java
@@ -175,12 +175,12 @@ public class TestSort extends SolrTestCaseJ4 {
         Document document = new Document();
         if (r.nextInt(100) < v1EmptyPercent) {
           mydoc.val = Integer.toString(r.nextInt(maxval));
-          f.setValue(mydoc.val);
+          f.setStringValue(mydoc.val);
           document.add(f);
         }
         if (r.nextInt(100) < v2EmptyPercent) {
           mydoc.val2 = Integer.toString(r.nextInt(maxval));
-          f2.setValue(mydoc.val2);
+          f2.setStringValue(mydoc.val2);
           document.add(f2);
         }
 

