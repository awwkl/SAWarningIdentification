GitDiffStart: ac43e0a68df9ed765a1b278a7d16e159f2150ee4 | Tue May 13 11:58:31 2014 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/search/SortedSetSelector.java b/lucene/core/src/java/org/apache/lucene/search/SortedSetSelector.java
new file mode 100644
index 0000000..5ae4feb
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SortedSetSelector.java
@@ -0,0 +1,228 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.RandomAccessOrds;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.util.BytesRef;
+
+/** Selects a value from the document's set to use as the representative value */
+public class SortedSetSelector {
+  
+  /** 
+   * Type of selection to perform.
+   * <p>
+   * Limitations:
+   * <ul>
+   *   <li>Fields containing {@link Integer#MAX_VALUE} or more unique values
+   *       are unsupported.
+   *   <li>Selectors other than ({@link Type#MIN}) require 
+   *       optional codec support. However several codecs provided by Lucene, 
+   *       including the current default codec, support this.
+   * </ul>
+   */
+  public enum Type {
+    /** 
+     * Selects the minimum value in the set 
+     */
+    MIN,
+    /** 
+     * Selects the maximum value in the set 
+     */
+    MAX,
+    /** 
+     * Selects the middle value in the set.
+     * <p>
+     * If the set has an even number of values, the lower of the middle two is chosen.
+     */
+    MIDDLE_MIN,
+    /** 
+     * Selects the middle value in the set.
+     * <p>
+     * If the set has an even number of values, the higher of the middle two is chosen
+     */
+    MIDDLE_MAX
+  }
+  
+  /** Wraps a multi-valued SortedSetDocValues as a single-valued view, using the specified selector */
+  public static SortedDocValues wrap(SortedSetDocValues sortedSet, Type selector) {
+    if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {
+      throw new UnsupportedOperationException("fields containing more than " + (Integer.MAX_VALUE-1) + " unique terms are unsupported");
+    }
+    
+    SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);
+    if (singleton != null) {
+      // it's actually single-valued in practice, but indexed as multi-valued,
+      // so just sort on the underlying single-valued dv directly.
+      // regardless of selector type, this optimization is safe!
+      return singleton;
+    } else if (selector == Type.MIN) {
+      return new MinValue(sortedSet);
+    } else {
+      if (sortedSet instanceof RandomAccessOrds == false) {
+        throw new UnsupportedOperationException("codec does not support random access ordinals, cannot use selector: " + selector);
+      }
+      RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;
+      switch(selector) {
+        case MAX: return new MaxValue(randomOrds);
+        case MIDDLE_MIN: return new MiddleMinValue(randomOrds);
+        case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);
+        case MIN: 
+        default: 
+          throw new AssertionError();
+      }
+    }
+  }
+  
+  /** Wraps a SortedSetDocValues and returns the first ordinal (min) */
+  static class MinValue extends SortedDocValues {
+    final SortedSetDocValues in;
+    
+    MinValue(SortedSetDocValues in) {
+      this.in = in;
+    }
+
+    @Override
+    public int getOrd(int docID) {
+      in.setDocument(docID);
+      return (int) in.nextOrd();
+    }
+
+    @Override
+    public void lookupOrd(int ord, BytesRef result) {
+      in.lookupOrd(ord, result);
+    }
+
+    @Override
+    public int getValueCount() {
+      return (int) in.getValueCount();
+    }
+
+    @Override
+    public int lookupTerm(BytesRef key) {
+      return (int) in.lookupTerm(key);
+    }
+  }
+  
+  /** Wraps a SortedSetDocValues and returns the last ordinal (max) */
+  static class MaxValue extends SortedDocValues {
+    final RandomAccessOrds in;
+    
+    MaxValue(RandomAccessOrds in) {
+      this.in = in;
+    }
+
+    @Override
+    public int getOrd(int docID) {
+      in.setDocument(docID);
+      final int count = in.cardinality();
+      if (count == 0) {
+        return -1;
+      } else {
+        return (int) in.ordAt(count-1);
+      }
+    }
+
+    @Override
+    public void lookupOrd(int ord, BytesRef result) {
+      in.lookupOrd(ord, result);
+    }
+
+    @Override
+    public int getValueCount() {
+      return (int) in.getValueCount();
+    }
+    
+    @Override
+    public int lookupTerm(BytesRef key) {
+      return (int) in.lookupTerm(key);
+    }
+  }
+  
+  /** Wraps a SortedSetDocValues and returns the middle ordinal (or min of the two) */
+  static class MiddleMinValue extends SortedDocValues {
+    final RandomAccessOrds in;
+    
+    MiddleMinValue(RandomAccessOrds in) {
+      this.in = in;
+    }
+
+    @Override
+    public int getOrd(int docID) {
+      in.setDocument(docID);
+      final int count = in.cardinality();
+      if (count == 0) {
+        return -1;
+      } else {
+        return (int) in.ordAt((count-1) >>> 1);
+      }
+    }
+
+    @Override
+    public void lookupOrd(int ord, BytesRef result) {
+      in.lookupOrd(ord, result);
+    }
+
+    @Override
+    public int getValueCount() {
+      return (int) in.getValueCount();
+    }
+    
+    @Override
+    public int lookupTerm(BytesRef key) {
+      return (int) in.lookupTerm(key);
+    }
+  }
+  
+  /** Wraps a SortedSetDocValues and returns the middle ordinal (or max of the two) */
+  static class MiddleMaxValue extends SortedDocValues {
+    final RandomAccessOrds in;
+    
+    MiddleMaxValue(RandomAccessOrds in) {
+      this.in = in;
+    }
+
+    @Override
+    public int getOrd(int docID) {
+      in.setDocument(docID);
+      final int count = in.cardinality();
+      if (count == 0) {
+        return -1;
+      } else {
+        return (int) in.ordAt(count >>> 1);
+      }
+    }
+
+    @Override
+    public void lookupOrd(int ord, BytesRef result) {
+      in.lookupOrd(ord, result);
+    }
+
+    @Override
+    public int getValueCount() {
+      return (int) in.getValueCount();
+    }
+    
+    @Override
+    public int lookupTerm(BytesRef key) {
+      return (int) in.lookupTerm(key);
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java b/lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java
new file mode 100644
index 0000000..157d4a3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java
@@ -0,0 +1,133 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.search.FieldComparator;
+import org.apache.lucene.search.SortField;
+
+/** 
+ * SortField for {@link SortedSetDocValues}.
+ * <p>
+ * A SortedSetDocValues contains multiple values for a field, so sorting with
+ * this technique "selects" a value as the representative sort value for the document.
+ * <p>
+ * By default, the minimum value in the set is selected as the sort value, but
+ * this can be customized. Selectors other than the default do have some limitations
+ * to ensure that all selections happen in constant-time for performance.
+ * <p>
+ * Like sorting by string, this also supports sorting missing values as first or last,
+ * via {@link #setMissingValue(Object)}.
+ * <p>
+ * @see SortedSetSelector
+ */
+public class SortedSetSortField extends SortField {
+  
+  private final SortedSetSelector.Type selector;
+  
+  /**
+   * Creates a sort, possibly in reverse, by the minimum value in the set 
+   * for the document.
+   * @param field Name of field to sort by.  Must not be null.
+   * @param reverse True if natural order should be reversed.
+   */
+  public SortedSetSortField(String field, boolean reverse) {
+    this(field, reverse, SortedSetSelector.Type.MIN);
+  }
+
+  /**
+   * Creates a sort, possibly in reverse, specifying how the sort value from 
+   * the document's set is selected.
+   * @param field Name of field to sort by.  Must not be null.
+   * @param reverse True if natural order should be reversed.
+   * @param selector custom selector type for choosing the sort value from the set.
+   * <p>
+   * NOTE: selectors other than {@link SortedSetSelector.Type#MIN} require optional codec support.
+   */
+  public SortedSetSortField(String field, boolean reverse, SortedSetSelector.Type selector) {
+    super(field, SortField.Type.CUSTOM, reverse);
+    if (selector == null) {
+      throw new NullPointerException();
+    }
+    this.selector = selector;
+  }
+  
+  /** Returns the selector in use for this sort */
+  public SortedSetSelector.Type getSelector() {
+    return selector;
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * super.hashCode() + selector.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (!super.equals(obj)) return false;
+    if (getClass() != obj.getClass()) return false;
+    SortedSetSortField other = (SortedSetSortField) obj;
+    if (selector != other.selector) return false;
+    return true;
+  }
+  
+  @Override
+  public String toString() {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("<sortedset" + ": \"").append(getField()).append("\">");
+    if (getReverse()) buffer.append('!');
+    if (missingValue != null) {
+      buffer.append(" missingValue=");
+      buffer.append(missingValue);
+    }
+    buffer.append(" selector=");
+    buffer.append(selector);
+
+    return buffer.toString();
+  }
+
+  /**
+   * Set how missing values (the empty set) are sorted.
+   * <p>
+   * Note that this must be {@link #STRING_FIRST} or {@link #STRING_LAST}.
+   */
+  @Override
+  public void setMissingValue(Object missingValue) {
+    if (missingValue != STRING_FIRST && missingValue != STRING_LAST) {
+      throw new IllegalArgumentException("For SORTED_SET type, missing value must be either STRING_FIRST or STRING_LAST");
+    }
+    this.missingValue = missingValue;
+  }
+  
+  @Override
+  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {
+    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {
+      @Override
+      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {
+        SortedSetDocValues sortedSet = DocValues.getSortedSet(context.reader(), field);
+        return SortedSetSelector.wrap(sortedSet, selector);
+      }
+    };
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSelector.java b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSelector.java
new file mode 100644
index 0000000..0468c0f
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSelector.java
@@ -0,0 +1,556 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.diskdv.DiskDocValuesFormat;
+import org.apache.lucene.codecs.lucene45.Lucene45DocValuesFormat;
+import org.apache.lucene.codecs.memory.DirectDocValuesFormat;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.SortedSetDocValuesField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+/** Tests for SortedSetSortField selectors other than MIN,
+ *  these require optional codec support (random access to ordinals) */
+public class TestSortedSetSelector extends LuceneTestCase {
+  static Codec savedCodec;
+  
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    savedCodec = Codec.getDefault();
+    // currently only these codecs that support random access ordinals
+    int victim = random().nextInt(3);
+    switch(victim) {
+      case 0:  Codec.setDefault(TestUtil.alwaysDocValuesFormat(new DirectDocValuesFormat()));
+      case 1:  Codec.setDefault(TestUtil.alwaysDocValuesFormat(new DiskDocValuesFormat()));
+      default: Codec.setDefault(TestUtil.alwaysDocValuesFormat(new Lucene45DocValuesFormat()));
+    }
+  }
+  
+  @AfterClass
+  public static void afterClass() throws Exception {
+    Codec.setDefault(savedCodec);
+  }
+  
+  public void testMax() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'baz' comes before 'foo'
+    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMaxReverse() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    
+    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSelector.Type.MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'baz' comes before 'foo'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMaxMissingFirst() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MAX);
+    sortField.setMissingValue(SortField.STRING_FIRST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // null comes first
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    // 'baz' comes before 'foo'
+    assertEquals("3", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMaxMissingLast() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MAX);
+    sortField.setMissingValue(SortField.STRING_LAST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // 'baz' comes before 'foo'
+    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    // null comes last
+    assertEquals("1", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMaxSingleton() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMin() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MIN));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMinReverse() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSelector.Type.MIDDLE_MIN));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMinMissingFirst() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MIN);
+    sortField.setMissingValue(SortField.STRING_FIRST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // null comes first
+    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    // 'b' comes before 'c'
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMinMissingLast() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MIN);
+    sortField.setMissingValue(SortField.STRING_LAST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    // null comes last
+    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMinSingleton() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MIN));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMax() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMaxReverse() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSelector.Type.MIDDLE_MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMaxMissingFirst() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MAX);
+    sortField.setMissingValue(SortField.STRING_FIRST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // null comes first
+    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    // 'b' comes before 'c'
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMaxMissingLast() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    SortField sortField = new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MAX);
+    sortField.setMissingValue(SortField.STRING_LAST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // 'b' comes before 'c'
+    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    // null comes last
+    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMiddleMaxSingleton() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    // slow wrapper does not support random access ordinals (there is no need for that!)
+    IndexSearcher searcher = newSearcher(ir, false);
+    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSelector.Type.MIDDLE_MAX));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java
new file mode 100644
index 0000000..6a35e42
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java
@@ -0,0 +1,229 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.SortedSetDocValuesField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
+
+/** Simple tests for SortedSetSortField, indexing the sortedset up front */
+@SuppressCodecs({"Lucene40", "Lucene41"}) // avoid codecs that don't support sortedset
+public class TestSortedSetSortField extends LuceneTestCase {
+  
+  public void testEmptyIndex() throws Exception {
+    IndexSearcher empty = newSearcher(new MultiReader());
+    Query query = new TermQuery(new Term("contents", "foo"));
+  
+    Sort sort = new Sort();
+    sort.setSort(new SortedSetSortField("sortedset", false));
+    TopDocs td = empty.search(query, null, 10, sort, true, true);
+    assertEquals(0, td.totalHits);
+    
+    // for an empty index, any selector should work
+    for (SortedSetSelector.Type v : SortedSetSelector.Type.values()) {
+      sort.setSort(new SortedSetSortField("sortedset", false, v));
+      td = empty.search(query, null, 10, sort, true, true);
+      assertEquals(0, td.totalHits);
+    }
+  }
+  
+  public void testEquals() throws Exception {
+    SortField sf = new SortedSetSortField("a", false);
+    assertFalse(sf.equals(null));
+    
+    assertEquals(sf, sf);
+    
+    SortField sf2 = new SortedSetSortField("a", false);
+    assertEquals(sf, sf2);
+    assertEquals(sf.hashCode(), sf2.hashCode());
+    
+    assertFalse(sf.equals(new SortedSetSortField("a", true)));
+    assertFalse(sf.equals(new SortedSetSortField("b", false)));
+    assertFalse(sf.equals(new SortedSetSortField("a", false, SortedSetSelector.Type.MAX)));
+    assertFalse(sf.equals("foo"));
+  }
+  
+  public void testForward() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    IndexSearcher searcher = newSearcher(ir);
+    Sort sort = new Sort(new SortedSetSortField("value", false));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    
+    ir.close();
+    dir.close();
+  }
+  
+  public void testReverse() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    IndexSearcher searcher = newSearcher(ir);
+    Sort sort = new Sort(new SortedSetSortField("value", true));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMissingFirst() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    IndexSearcher searcher = newSearcher(ir);
+    SortField sortField = new SortedSetSortField("value", false);
+    sortField.setMissingValue(SortField.STRING_FIRST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // 'bar' comes before 'baz'
+    // null comes first
+    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+  
+  public void testMissingLast() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(newStringField("id", "3", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    IndexSearcher searcher = newSearcher(ir);
+    SortField sortField = new SortedSetSortField("value", false);
+    sortField.setMissingValue(SortField.STRING_LAST);
+    Sort sort = new Sort(sortField);
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(3, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+    // null comes last
+    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+  
+  public void testSingleton() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
+    doc.add(newStringField("id", "2", Field.Store.YES));
+    writer.addDocument(doc);
+    doc = new Document();
+    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
+    doc.add(newStringField("id", "1", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader ir = writer.getReader();
+    writer.shutdown();
+    
+    IndexSearcher searcher = newSearcher(ir);
+    Sort sort = new Sort(new SortedSetSortField("value", false));
+
+    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
+    assertEquals(2, td.totalHits);
+    // 'bar' comes before 'baz'
+    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
+    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
+
+    ir.close();
+    dir.close();
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java b/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java
deleted file mode 100644
index b3dc175..0000000
--- a/lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java
+++ /dev/null
@@ -1,327 +0,0 @@
-package org.apache.lucene.sandbox.queries;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.DocValues;
-import org.apache.lucene.index.RandomAccessOrds;
-import org.apache.lucene.index.SortedDocValues;
-import org.apache.lucene.index.SortedSetDocValues;
-import org.apache.lucene.search.FieldComparator;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BytesRef;
-
-/** 
- * SortField for {@link SortedSetDocValues}.
- * <p>
- * A SortedSetDocValues contains multiple values for a field, so sorting with
- * this technique "selects" a value as the representative sort value for the document.
- * <p>
- * By default, the minimum value in the set is selected as the sort value, but
- * this can be customized. Selectors other than the default do have some limitations
- * (see below) to ensure that all selections happen in constant-time for performance.
- * <p>
- * Like sorting by string, this also supports sorting missing values as first or last,
- * via {@link #setMissingValue(Object)}.
- * <p>
- * Limitations:
- * <ul>
- *   <li>Fields containing {@link Integer#MAX_VALUE} or more unique values
- *       are unsupported.
- *   <li>Selectors other than the default ({@link Selector#MIN}) require 
- *       optional codec support. However several codecs provided by Lucene, 
- *       including the current default codec, support this.
- * </ul>
- */
-public class SortedSetSortField extends SortField {
-  
-  /** Selects a value from the document's set to use as the sort value */
-  public static enum Selector {
-    /** 
-     * Selects the minimum value in the set 
-     */
-    MIN,
-    /** 
-     * Selects the maximum value in the set 
-     */
-    MAX,
-    /** 
-     * Selects the middle value in the set.
-     * <p>
-     * If the set has an even number of values, the lower of the middle two is chosen.
-     */
-    MIDDLE_MIN,
-    /** 
-     * Selects the middle value in the set.
-     * <p>
-     * If the set has an even number of values, the higher of the middle two is chosen
-     */
-    MIDDLE_MAX
-  }
-  
-  private final Selector selector;
-  
-  /**
-   * Creates a sort, possibly in reverse, by the minimum value in the set 
-   * for the document.
-   * @param field Name of field to sort by.  Must not be null.
-   * @param reverse True if natural order should be reversed.
-   */
-  public SortedSetSortField(String field, boolean reverse) {
-    this(field, reverse, Selector.MIN);
-  }
-
-  /**
-   * Creates a sort, possibly in reverse, specifying how the sort value from 
-   * the document's set is selected.
-   * @param field Name of field to sort by.  Must not be null.
-   * @param reverse True if natural order should be reversed.
-   * @param selector custom selector for choosing the sort value from the set.
-   * <p>
-   * NOTE: selectors other than {@link Selector#MIN} require optional codec support.
-   */
-  public SortedSetSortField(String field, boolean reverse, Selector selector) {
-    super(field, SortField.Type.CUSTOM, reverse);
-    if (selector == null) {
-      throw new NullPointerException();
-    }
-    this.selector = selector;
-  }
-  
-  /** Returns the selector in use for this sort */
-  public Selector getSelector() {
-    return selector;
-  }
-
-  @Override
-  public int hashCode() {
-    return 31 * super.hashCode() + selector.hashCode();
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) return true;
-    if (!super.equals(obj)) return false;
-    if (getClass() != obj.getClass()) return false;
-    SortedSetSortField other = (SortedSetSortField) obj;
-    if (selector != other.selector) return false;
-    return true;
-  }
-  
-  @Override
-  public String toString() {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("<sortedset" + ": \"").append(getField()).append("\">");
-    if (getReverse()) buffer.append('!');
-    if (missingValue != null) {
-      buffer.append(" missingValue=");
-      buffer.append(missingValue);
-    }
-    buffer.append(" selector=");
-    buffer.append(selector);
-
-    return buffer.toString();
-  }
-
-  /**
-   * Set how missing values (the empty set) are sorted.
-   * <p>
-   * Note that this must be {@link #STRING_FIRST} or {@link #STRING_LAST}.
-   */
-  @Override
-  public void setMissingValue(Object missingValue) {
-    if (missingValue != STRING_FIRST && missingValue != STRING_LAST) {
-      throw new IllegalArgumentException("For SORTED_SET type, missing value must be either STRING_FIRST or STRING_LAST");
-    }
-    this.missingValue = missingValue;
-  }
-  
-  @Override
-  public FieldComparator<?> getComparator(int numHits, int sortPos) throws IOException {
-    return new FieldComparator.TermOrdValComparator(numHits, getField(), missingValue == STRING_LAST) {
-      @Override
-      protected SortedDocValues getSortedDocValues(AtomicReaderContext context, String field) throws IOException {
-        SortedSetDocValues sortedSet = DocValues.getSortedSet(context.reader(), field);
-        
-        if (sortedSet.getValueCount() >= Integer.MAX_VALUE) {
-          throw new UnsupportedOperationException("fields containing more than " + (Integer.MAX_VALUE-1) + " unique terms are unsupported");
-        }
-        
-        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);
-        if (singleton != null) {
-          // it's actually single-valued in practice, but indexed as multi-valued,
-          // so just sort on the underlying single-valued dv directly.
-          // regardless of selector type, this optimization is safe!
-          return singleton;
-        } else if (selector == Selector.MIN) {
-          return new MinValue(sortedSet);
-        } else {
-          if (sortedSet instanceof RandomAccessOrds == false) {
-            throw new UnsupportedOperationException("codec does not support random access ordinals, cannot use selector: " + selector);
-          }
-          RandomAccessOrds randomOrds = (RandomAccessOrds) sortedSet;
-          switch(selector) {
-            case MAX: return new MaxValue(randomOrds);
-            case MIDDLE_MIN: return new MiddleMinValue(randomOrds);
-            case MIDDLE_MAX: return new MiddleMaxValue(randomOrds);
-            case MIN: 
-            default: 
-              throw new AssertionError();
-          }
-        }
-      }
-    };
-  }
-  
-  /** Wraps a SortedSetDocValues and returns the first ordinal (min) */
-  static class MinValue extends SortedDocValues {
-    final SortedSetDocValues in;
-    
-    MinValue(SortedSetDocValues in) {
-      this.in = in;
-    }
-
-    @Override
-    public int getOrd(int docID) {
-      in.setDocument(docID);
-      return (int) in.nextOrd();
-    }
-
-    @Override
-    public void lookupOrd(int ord, BytesRef result) {
-      in.lookupOrd(ord, result);
-    }
-
-    @Override
-    public int getValueCount() {
-      return (int) in.getValueCount();
-    }
-
-    @Override
-    public int lookupTerm(BytesRef key) {
-      return (int) in.lookupTerm(key);
-    }
-  }
-  
-  /** Wraps a SortedSetDocValues and returns the last ordinal (max) */
-  static class MaxValue extends SortedDocValues {
-    final RandomAccessOrds in;
-    
-    MaxValue(RandomAccessOrds in) {
-      this.in = in;
-    }
-
-    @Override
-    public int getOrd(int docID) {
-      in.setDocument(docID);
-      final int count = in.cardinality();
-      if (count == 0) {
-        return -1;
-      } else {
-        return (int) in.ordAt(count-1);
-      }
-    }
-
-    @Override
-    public void lookupOrd(int ord, BytesRef result) {
-      in.lookupOrd(ord, result);
-    }
-
-    @Override
-    public int getValueCount() {
-      return (int) in.getValueCount();
-    }
-    
-    @Override
-    public int lookupTerm(BytesRef key) {
-      return (int) in.lookupTerm(key);
-    }
-  }
-  
-  /** Wraps a SortedSetDocValues and returns the middle ordinal (or min of the two) */
-  static class MiddleMinValue extends SortedDocValues {
-    final RandomAccessOrds in;
-    
-    MiddleMinValue(RandomAccessOrds in) {
-      this.in = in;
-    }
-
-    @Override
-    public int getOrd(int docID) {
-      in.setDocument(docID);
-      final int count = in.cardinality();
-      if (count == 0) {
-        return -1;
-      } else {
-        return (int) in.ordAt((count-1) >>> 1);
-      }
-    }
-
-    @Override
-    public void lookupOrd(int ord, BytesRef result) {
-      in.lookupOrd(ord, result);
-    }
-
-    @Override
-    public int getValueCount() {
-      return (int) in.getValueCount();
-    }
-    
-    @Override
-    public int lookupTerm(BytesRef key) {
-      return (int) in.lookupTerm(key);
-    }
-  }
-  
-  /** Wraps a SortedSetDocValues and returns the middle ordinal (or max of the two) */
-  static class MiddleMaxValue extends SortedDocValues {
-    final RandomAccessOrds in;
-    
-    MiddleMaxValue(RandomAccessOrds in) {
-      this.in = in;
-    }
-
-    @Override
-    public int getOrd(int docID) {
-      in.setDocument(docID);
-      final int count = in.cardinality();
-      if (count == 0) {
-        return -1;
-      } else {
-        return (int) in.ordAt(count >>> 1);
-      }
-    }
-
-    @Override
-    public void lookupOrd(int ord, BytesRef result) {
-      in.lookupOrd(ord, result);
-    }
-
-    @Override
-    public int getValueCount() {
-      return (int) in.getValueCount();
-    }
-    
-    @Override
-    public int lookupTerm(BytesRef key) {
-      return (int) in.lookupTerm(key);
-    }
-  }
-}
diff --git a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortField.java b/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortField.java
deleted file mode 100644
index aae5d15..0000000
--- a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortField.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package org.apache.lucene.sandbox.queries;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.SortedSetDocValuesField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.MultiReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
-
-/** Simple tests for SortedSetSortField, indexing the sortedset up front */
-@SuppressCodecs({"Lucene40", "Lucene41"}) // avoid codecs that don't support sortedset
-public class TestSortedSetSortField extends LuceneTestCase {
-  
-  public void testEmptyIndex() throws Exception {
-    IndexSearcher empty = newSearcher(new MultiReader());
-    Query query = new TermQuery(new Term("contents", "foo"));
-  
-    Sort sort = new Sort();
-    sort.setSort(new SortedSetSortField("sortedset", false));
-    TopDocs td = empty.search(query, null, 10, sort, true, true);
-    assertEquals(0, td.totalHits);
-    
-    // for an empty index, any selector should work
-    for (SortedSetSortField.Selector v : SortedSetSortField.Selector.values()) {
-      sort.setSort(new SortedSetSortField("sortedset", false, v));
-      td = empty.search(query, null, 10, sort, true, true);
-      assertEquals(0, td.totalHits);
-    }
-  }
-  
-  public void testEquals() throws Exception {
-    SortField sf = new SortedSetSortField("a", false);
-    assertFalse(sf.equals(null));
-    
-    assertEquals(sf, sf);
-    
-    SortField sf2 = new SortedSetSortField("a", false);
-    assertEquals(sf, sf2);
-    assertEquals(sf.hashCode(), sf2.hashCode());
-    
-    assertFalse(sf.equals(new SortedSetSortField("a", true)));
-    assertFalse(sf.equals(new SortedSetSortField("b", false)));
-    assertFalse(sf.equals(new SortedSetSortField("a", false, SortedSetSortField.Selector.MAX)));
-    assertFalse(sf.equals("foo"));
-  }
-  
-  public void testForward() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    IndexSearcher searcher = newSearcher(ir);
-    Sort sort = new Sort(new SortedSetSortField("value", false));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testReverse() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    IndexSearcher searcher = newSearcher(ir);
-    Sort sort = new Sort(new SortedSetSortField("value", true));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMissingFirst() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    IndexSearcher searcher = newSearcher(ir);
-    SortField sortField = new SortedSetSortField("value", false);
-    sortField.setMissingValue(SortField.STRING_FIRST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // 'bar' comes before 'baz'
-    // null comes first
-    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMissingLast() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    IndexSearcher searcher = newSearcher(ir);
-    SortField sortField = new SortedSetSortField("value", false);
-    sortField.setMissingValue(SortField.STRING_LAST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    // null comes last
-    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-  
-  public void testSingleton() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    IndexSearcher searcher = newSearcher(ir);
-    Sort sort = new Sort(new SortedSetSortField("value", false));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-}
diff --git a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortFieldSelectors.java b/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortFieldSelectors.java
deleted file mode 100644
index 4d3705f..0000000
--- a/lucene/sandbox/src/test/org/apache/lucene/sandbox/queries/TestSortedSetSortFieldSelectors.java
+++ /dev/null
@@ -1,556 +0,0 @@
-package org.apache.lucene.sandbox.queries;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.diskdv.DiskDocValuesFormat;
-import org.apache.lucene.codecs.lucene45.Lucene45DocValuesFormat;
-import org.apache.lucene.codecs.memory.DirectDocValuesFormat;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.SortedSetDocValuesField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-/** Tests for SortedSetSortField selectors other than MIN,
- *  these require optional codec support (random access to ordinals) */
-public class TestSortedSetSortFieldSelectors extends LuceneTestCase {
-  static Codec savedCodec;
-  
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    savedCodec = Codec.getDefault();
-    // currently only these codecs that support random access ordinals
-    int victim = random().nextInt(3);
-    switch(victim) {
-      case 0:  Codec.setDefault(TestUtil.alwaysDocValuesFormat(new DirectDocValuesFormat()));
-      case 1:  Codec.setDefault(TestUtil.alwaysDocValuesFormat(new DiskDocValuesFormat()));
-      default: Codec.setDefault(TestUtil.alwaysDocValuesFormat(new Lucene45DocValuesFormat()));
-    }
-  }
-  
-  @AfterClass
-  public static void afterClass() throws Exception {
-    Codec.setDefault(savedCodec);
-  }
-  
-  public void testMax() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'baz' comes before 'foo'
-    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMaxReverse() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    
-    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSortField.Selector.MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'baz' comes before 'foo'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMaxMissingFirst() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MAX);
-    sortField.setMissingValue(SortField.STRING_FIRST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // null comes first
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    // 'baz' comes before 'foo'
-    assertEquals("3", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMaxMissingLast() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("foo")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MAX);
-    sortField.setMissingValue(SortField.STRING_LAST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // 'baz' comes before 'foo'
-    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    // null comes last
-    assertEquals("1", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMaxSingleton() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMin() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MIN));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMinReverse() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSortField.Selector.MIDDLE_MIN));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMinMissingFirst() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MIN);
-    sortField.setMissingValue(SortField.STRING_FIRST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // null comes first
-    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    // 'b' comes before 'c'
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMinMissingLast() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MIN);
-    sortField.setMissingValue(SortField.STRING_LAST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    // null comes last
-    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMinSingleton() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MIN));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMax() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMaxReverse() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", true, SortedSetSortField.Selector.MIDDLE_MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMaxMissingFirst() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MAX);
-    sortField.setMissingValue(SortField.STRING_FIRST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // null comes first
-    assertEquals("3", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    // 'b' comes before 'c'
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMaxMissingLast() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(newStringField("id", "3", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("a")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("c")));
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("d")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("b")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    SortField sortField = new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MAX);
-    sortField.setMissingValue(SortField.STRING_LAST);
-    Sort sort = new Sort(sortField);
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(3, td.totalHits);
-    // 'b' comes before 'c'
-    assertEquals("2", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("1", searcher.doc(td.scoreDocs[1].doc).get("id"));
-    // null comes last
-    assertEquals("3", searcher.doc(td.scoreDocs[2].doc).get("id"));
-    
-    ir.close();
-    dir.close();
-  }
-  
-  public void testMiddleMaxSingleton() throws Exception {
-    Directory dir = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("baz")));
-    doc.add(newStringField("id", "2", Field.Store.YES));
-    writer.addDocument(doc);
-    doc = new Document();
-    doc.add(new SortedSetDocValuesField("value", new BytesRef("bar")));
-    doc.add(newStringField("id", "1", Field.Store.YES));
-    writer.addDocument(doc);
-    IndexReader ir = writer.getReader();
-    writer.shutdown();
-    
-    // slow wrapper does not support random access ordinals (there is no need for that!)
-    IndexSearcher searcher = newSearcher(ir, false);
-    Sort sort = new Sort(new SortedSetSortField("value", false, SortedSetSortField.Selector.MIDDLE_MAX));
-
-    TopDocs td = searcher.search(new MatchAllDocsQuery(), 10, sort);
-    assertEquals(2, td.totalHits);
-    // 'bar' comes before 'baz'
-    assertEquals("1", searcher.doc(td.scoreDocs[0].doc).get("id"));
-    assertEquals("2", searcher.doc(td.scoreDocs[1].doc).get("id"));
-
-    ir.close();
-    dir.close();
-  }
-}

