GitDiffStart: f18502ed419b511a68d1467e0aecd5ff91da90c0 | Tue Jul 20 20:17:54 2010 +0000
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java
new file mode 100644
index 0000000..08f2fea
--- /dev/null
+++ b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/DistanceUtils.java
@@ -0,0 +1,435 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial;
+
+import org.apache.lucene.spatial.geometry.DistanceUnits;
+import org.apache.lucene.spatial.geometry.FloatLatLng;
+import org.apache.lucene.spatial.geometry.LatLng;
+import org.apache.lucene.spatial.geometry.shape.LLRect;
+import org.apache.lucene.spatial.geometry.shape.Rectangle;
+import org.apache.lucene.spatial.tier.InvalidGeoException;
+
+/**
+ * <p><font color="red"><b>NOTE:</b> This API is still in
+ * flux and might change in incompatible ways in the next
+ * release.</font>
+ */
+//TODO: Move this up one package level
+public class DistanceUtils {
+
+  public static final double DEGREES_TO_RADIANS = Math.PI / 180.0;
+  public static final double RADIANS_TO_DEGREES = 180.0 / Math.PI;
+  public static final double DEG_45 = Math.PI / 4.0;
+  public static final double DEG_225 = 5 * DEG_45;
+  public static final double DEG_90 = Math.PI / 2;
+  public static final double DEG_180 = Math.PI;
+  public static final double SIN_45 = Math.sin(DEG_45);
+  public static final double KM_TO_MILES = 0.621371192;
+  public static final double MILES_TO_KM = 1.609344;
+    /**
+   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
+   *
+   * [1] http://en.wikipedia.org/wiki/Earth_radius
+   */
+  public static final double EARTH_MEAN_RADIUS_KM = 6371.009;
+
+  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM / MILES_TO_KM;
+
+  public static final double EARTH_EQUATORIAL_RADIUS_MI = 3963.205;
+  public static final double EARTH_EQUATORIAL_RADIUS_KM = EARTH_EQUATORIAL_RADIUS_MI * MILES_TO_KM;
+
+
+  public static double getDistanceMi(double x1, double y1, double x2, double y2) {
+    return getLLMDistance(x1, y1, x2, y2);
+  }
+
+  /**
+   * 
+   * @param x1
+   * @param y1
+   * @param miles
+   * @return boundary rectangle where getY/getX is top left, getMinY/getMinX is bottom right
+   */
+  public static Rectangle getBoundary (double x1, double y1, double miles) {
+
+    LLRect box = LLRect.createBox( new FloatLatLng( x1, y1 ), miles, miles );
+    
+    //System.out.println("Box: "+maxX+" | "+ maxY+" | "+ minX + " | "+ minY);
+    return box.toRectangle();
+
+  }
+  
+  public static double getLLMDistance (double x1, double y1, double x2, double y2) {
+
+    LatLng p1 = new FloatLatLng( x1, y1 );
+    LatLng p2 = new FloatLatLng( x2, y2 );
+    return p1.arcDistance( p2, DistanceUnits.MILES );
+  }
+
+  /**
+   * distance/radius.
+   * @param distance The distance travelled
+   * @param radius The radius of the sphere
+   * @return The angular distance, in radians
+   */
+  public static double angularDistance(double distance, double radius){
+    return distance/radius;
+  }
+
+  /**
+   * Calculate the p-norm (i.e. length) beteen two vectors
+   *
+   * @param vec1  The first vector
+   * @param vec2  The second vector
+   * @param power The power (2 for Euclidean distance, 1 for manhattan, etc.)
+   * @return The length.
+   *         <p/>
+   *         See http://en.wikipedia.org/wiki/Lp_space
+   * @see #vectorDistance(double[], double[], double, double)
+   */
+  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
+    return vectorDistance(vec1, vec2, power, 1.0 / power);
+  }
+
+  /**
+   * Calculate the p-norm (i.e. length) between two vectors
+   *
+   * @param vec1         The first vector
+   * @param vec2         The second vector
+   * @param power        The power (2 for Euclidean distance, 1 for manhattan, etc.)
+   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
+   * @return The length.
+   */
+  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
+    double result = 0;
+
+    if (power == 0) {
+      for (int i = 0; i < vec1.length; i++) {
+        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
+      }
+
+    } else if (power == 1.0) {
+      for (int i = 0; i < vec1.length; i++) {
+        result += vec1[i] - vec2[i];
+      }
+    } else if (power == 2.0) {
+      result = Math.sqrt(squaredEuclideanDistance(vec1, vec2));
+    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
+      for (int i = 0; i < vec1.length; i++) {
+        result = Math.max(result, Math.max(vec1[i], vec2[i]));
+      }
+    } else {
+      for (int i = 0; i < vec1.length; i++) {
+        result += Math.pow(vec1[i] - vec2[i], power);
+      }
+      result = Math.pow(result, oneOverPower);
+    }
+    return result;
+  }
+
+  /**
+   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
+   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximatation).
+   *
+   * @param center     The center point
+   * @param result Holds the result, potentially resizing if needed.
+   * @param distance   The d from the center to the corner
+   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
+   * @return The point, either the upperLeft or the lower right
+   */
+  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
+    if (result == null || result.length != center.length) {
+      result = new double[center.length];
+    }
+    if (upperRight == false) {
+      distance = -distance;
+    }
+    //We don't care about the power here,
+    // b/c we are always in a rectangular coordinate system, so any norm can be used by
+    //using the definition of sine
+    distance = SIN_45 * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarily for cosine
+    for (int i = 0; i < center.length; i++) {
+      result[i] = center[i] + distance;
+    }
+    return result;
+  }
+
+  /**
+   * @param latCenter  In degrees
+   * @param lonCenter  In degrees
+   * @param distance The distance
+   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
+   * @param upperRight If true, calculate the upper right corner, else the lower left
+   * @param radius The radius of the sphere to use.
+   * @return The Lat/Lon in degrees
+   *
+   * @see #latLonCorner(double, double, double, double[], boolean, double)
+   */
+  public static double[] latLonCornerDegs(double latCenter, double lonCenter,
+                                          double distance, double [] result,
+                                          boolean upperRight, double radius) {
+    result = latLonCorner(latCenter * DEGREES_TO_RADIANS,
+            lonCenter * DEGREES_TO_RADIANS, distance, result, upperRight, radius);
+    result[0] = result[0] * RADIANS_TO_DEGREES;
+    result[1] = result[1] * RADIANS_TO_DEGREES;
+    return result;
+  }
+
+  /**
+   * Uses Haversine to calculate the corner
+   *
+   * @param latCenter  In radians
+   * @param lonCenter  In radians
+   * @param distance   The distance
+   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
+   * @param upperRight If true, give lat/lon for the upper right corner, else lower left
+   * @param radius     The radius to use for the calculation
+   * @return The Lat/Lon in Radians
+
+   */
+  public static double[] latLonCorner(double latCenter, double lonCenter,
+                                      double distance, double [] result, boolean upperRight, double radius) {
+    // Haversine formula
+    double brng = upperRight ? DEG_45 : DEG_225;
+    double lat2 = Math.asin(Math.sin(latCenter) * Math.cos(distance / radius) +
+            Math.cos(latCenter) * Math.sin(distance / radius) * Math.cos(brng));
+    double lon2 = lonCenter + Math.atan2(Math.sin(brng) * Math.sin(distance / radius) * Math.cos(latCenter),
+            Math.cos(distance / radius) - Math.sin(latCenter) * Math.sin(lat2));
+
+    /*lat2 = (lat2*180)/Math.PI;
+    lon2 = (lon2*180)/Math.PI;*/
+    //From Lucene.  Move back to Lucene when synced
+    // normalize long first
+    if (result == null || result.length != 2){
+      result = new double[2];
+    }
+    result[0] = lat2;
+    result[1] = lon2;
+    normLng(result);
+
+    // normalize lat - could flip poles
+    normLat(result);
+
+    return result;
+  }
+
+  /**
+   * @param latLng The lat/lon, in radians. lat in position 0, long in position 1
+   */
+  public static void normLat(double[] latLng) {
+
+    if (latLng[0] > DEG_90) {
+      latLng[0] = DEG_90 - (latLng[0] - DEG_90);
+      if (latLng[1] < 0) {
+        latLng[1] = latLng[1] + DEG_180;
+      } else {
+        latLng[1] = latLng[1] - DEG_180;
+      }
+    } else if (latLng[0] < -DEG_90) {
+      latLng[0] = -DEG_90 - (latLng[0] + DEG_90);
+      if (latLng[1] < 0) {
+        latLng[1] = latLng[1] + DEG_180;
+      } else {
+        latLng[1] = latLng[1] - DEG_180;
+      }
+    }
+
+  }
+
+  /**
+   * Returns a normalized Lng rectangle shape for the bounding box
+   *
+   * @param latLng The lat/lon, in radians, lat in position 0, long in position 1
+   */
+  public static void normLng(double[] latLng) {
+    if (latLng[1] > DEG_180) {
+      latLng[1] = -1.0 * (DEG_180 - (latLng[1] - DEG_180));
+    } else if (latLng[1] < -DEG_180) {
+      latLng[1] = (latLng[1] + DEG_180) + DEG_180;
+    }
+  }
+
+  /**
+   * The square of the Euclidean Distance.  Not really a distance, but useful if all that matters is
+   * comparing the result to another one.
+   *
+   * @param vec1 The first point
+   * @param vec2 The second point
+   * @return The squared Euclidean distance
+   */
+  public static double squaredEuclideanDistance(double[] vec1, double[] vec2) {
+    double result = 0;
+    for (int i = 0; i < vec1.length; i++) {
+      double v = vec1[i] - vec2[i];
+      result += v * v;
+    }
+    return result;
+  }
+
+  /**
+   * @param x1     The x coordinate of the first point, in radians
+   * @param y1     The y coordinate of the first point, in radians
+   * @param x2     The x coordinate of the second point, in radians
+   * @param y2     The y coordinate of the second point, in radians
+   * @param radius The radius of the sphere
+   * @return The distance between the two points, as determined by the Haversine formula.
+
+   */
+  public static double haversine(double x1, double y1, double x2, double y2, double radius) {
+    double result = 0;
+    //make sure they aren't all the same, as then we can just return 0
+    if ((x1 != x2) || (y1 != y2)) {
+      double diffX = x1 - x2;
+      double diffY = y1 - y2;
+      double hsinX = Math.sin(diffX * 0.5);
+      double hsinY = Math.sin(diffY * 0.5);
+      double h = hsinX * hsinX +
+              (Math.cos(x1) * Math.cos(x2) * hsinY * hsinY);
+      result = (radius * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)));
+    }
+    return result;
+  }
+
+  /**
+   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
+   * containing the values.
+   *
+   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
+   * @param externalVal The value to parse
+   * @param dimension   The expected number of values for the point
+   * @return An array of the values that make up the point (aka vector)
+   * @throws org.apache.lucene.spatial.tier.InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
+   */
+  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidGeoException {
+    //TODO: Should we support sparse vectors?
+    if (out == null || out.length != dimension) out = new String[dimension];
+    int idx = externalVal.indexOf(',');
+    int end = idx;
+    int start = 0;
+    int i = 0;
+    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
+      out[0] = externalVal.trim();
+      i = 1;
+    } else if (idx > 0) {//if it is zero, that is an error
+      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
+      for (; i < dimension; i++) {
+        while (start < end && externalVal.charAt(start) == ' ') start++;
+        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
+        if (start == end) {
+          break;
+        }
+        out[i] = externalVal.substring(start, end);
+        start = idx + 1;
+        end = externalVal.indexOf(',', start);
+        idx = end;
+        if (end == -1) {
+          end = externalVal.length();
+        }
+      }
+    }
+    if (i != dimension) {
+      throw new InvalidGeoException("incompatible dimension (" + dimension +
+              ") and values (" + externalVal + ").  Only " + i + " values specified");
+    }
+    return out;
+  }
+
+  /**
+   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
+   * containing the values.
+   *
+   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
+   * @param externalVal The value to parse
+   * @param dimension   The expected number of values for the point
+   * @return An array of the values that make up the point (aka vector)
+   * @throws InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
+   */
+  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidGeoException{
+    if (out == null || out.length != dimension) out = new double[dimension];
+    int idx = externalVal.indexOf(',');
+    int end = idx;
+    int start = 0;
+    int i = 0;
+    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
+      out[0] = Double.parseDouble(externalVal.trim());
+      i = 1;
+    } else if (idx > 0) {//if it is zero, that is an error
+      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
+      for (; i < dimension; i++) {
+        //TODO: abstract common code with other parsePoint
+        while (start < end && externalVal.charAt(start) == ' ') start++;
+        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
+        if (start == end) {
+          break;
+        }
+        out[i] = Double.parseDouble(externalVal.substring(start, end));
+        start = idx + 1;
+        end = externalVal.indexOf(',', start);
+        idx = end;
+        if (end == -1) {
+          end = externalVal.length();
+        }
+      }
+    }
+    if (i != dimension) {
+      throw new InvalidGeoException("incompatible dimension (" + dimension +
+              ") and values (" + externalVal + ").  Only " + i + " values specified");
+    }
+    return out;
+  }
+
+  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidGeoException {
+    return parseLatitudeLongitude(null, latLonStr);
+  }
+
+  /**
+   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
+   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
+   * <p/>
+   * The latitude is assumed to be the first part of the string and the longitude the second part.
+   *
+   * @param latLon    A preallocated array to hold the result
+   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
+   * @return The lat long
+   * @throws InvalidGeoException if there was an error parsing
+   */
+  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidGeoException {
+    if (latLon == null) {
+      latLon = new double[2];
+    }
+    double[] toks = parsePointDouble(null, latLonStr, 2);
+
+    if (toks[0] < -90.0 || toks[0] > 90.0) {
+      throw new InvalidGeoException(
+              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
+                      + toks[0] + "]");
+    }
+    latLon[0] = toks[0];
+
+
+    if (toks[1] < -180.0 || toks[1] > 180.0) {
+
+      throw new InvalidGeoException(
+              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
+                      + toks[1] + "]");
+    }
+    latLon[1] = toks[1];
+
+    return latLon;
+  }
+}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
index 87f3424..69431f7 100644
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
+++ b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
@@ -25,9 +25,9 @@ import org.apache.lucene.search.FieldCache.DocTerms;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.FilteredDocIdSet;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.spatial.tier.DistanceFilter;
-import org.apache.lucene.spatial.tier.DistanceUtils;
 
 
 /** <p><font color="red"><b>NOTE:</b> This API is still in
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
index c438f9a..836dab3 100644
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
+++ b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
@@ -17,6 +17,8 @@
 
 package org.apache.lucene.spatial.tier;
 
+import org.apache.lucene.spatial.DistanceUtils;
+
 import java.util.HashMap;
 import java.util.Map;
 
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java
deleted file mode 100644
index 464db15..0000000
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java
+++ /dev/null
@@ -1,434 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
-import org.apache.lucene.spatial.geometry.LatLng;
-import org.apache.lucene.spatial.geometry.shape.LLRect;
-import org.apache.lucene.spatial.geometry.shape.Rectangle;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-//TODO: Move this up one package level
-public class DistanceUtils {
-
-  public static final double DEGREES_TO_RADIANS = Math.PI / 180.0;
-  public static final double RADIANS_TO_DEGREES = 180.0 / Math.PI;
-  public static final double DEG_45 = Math.PI / 4.0;
-  public static final double DEG_225 = 5 * DEG_45;
-  public static final double DEG_90 = Math.PI / 2;
-  public static final double DEG_180 = Math.PI;
-  public static final double SIN_45 = Math.sin(DEG_45);
-  public static final double KM_TO_MILES = 0.621371192;
-  public static final double MILES_TO_KM = 1.609344;
-    /**
-   * The International Union of Geodesy and Geophysics says the Earth's mean radius in KM is:
-   *
-   * [1] http://en.wikipedia.org/wiki/Earth_radius
-   */
-  public static final double EARTH_MEAN_RADIUS_KM = 6371.009;
-
-  public static final double EARTH_MEAN_RADIUS_MI = EARTH_MEAN_RADIUS_KM / MILES_TO_KM;
-
-  public static final double EARTH_EQUATORIAL_RADIUS_MI = 3963.205;
-  public static final double EARTH_EQUATORIAL_RADIUS_KM = EARTH_EQUATORIAL_RADIUS_MI * MILES_TO_KM;
-
-
-  public static double getDistanceMi(double x1, double y1, double x2, double y2) {
-    return getLLMDistance(x1, y1, x2, y2);
-  }
-
-  /**
-   * 
-   * @param x1
-   * @param y1
-   * @param miles
-   * @return boundary rectangle where getY/getX is top left, getMinY/getMinX is bottom right
-   */
-  public static Rectangle getBoundary (double x1, double y1, double miles) {
-
-    LLRect box = LLRect.createBox( new FloatLatLng( x1, y1 ), miles, miles );
-    
-    //System.out.println("Box: "+maxX+" | "+ maxY+" | "+ minX + " | "+ minY);
-    return box.toRectangle();
-
-  }
-  
-  public static double getLLMDistance (double x1, double y1, double x2, double y2) {
-
-    LatLng p1 = new FloatLatLng( x1, y1 );
-    LatLng p2 = new FloatLatLng( x2, y2 );
-    return p1.arcDistance( p2, DistanceUnits.MILES );
-  }
-
-  /**
-   * distance/radius.
-   * @param distance The distance travelled
-   * @param radius The radius of the sphere
-   * @return The angular distance, in radians
-   */
-  public static double angularDistance(double distance, double radius){
-    return distance/radius;
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) beteen two vectors
-   *
-   * @param vec1  The first vector
-   * @param vec2  The second vector
-   * @param power The power (2 for Euclidean distance, 1 for manhattan, etc.)
-   * @return The length.
-   *         <p/>
-   *         See http://en.wikipedia.org/wiki/Lp_space
-   * @see #vectorDistance(double[], double[], double, double)
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power) {
-    return vectorDistance(vec1, vec2, power, 1.0 / power);
-  }
-
-  /**
-   * Calculate the p-norm (i.e. length) between two vectors
-   *
-   * @param vec1         The first vector
-   * @param vec2         The second vector
-   * @param power        The power (2 for Euclidean distance, 1 for manhattan, etc.)
-   * @param oneOverPower If you've precalculated oneOverPower and cached it, use this method to save one division operation over {@link #vectorDistance(double[], double[], double)}.
-   * @return The length.
-   */
-  public static double vectorDistance(double[] vec1, double[] vec2, double power, double oneOverPower) {
-    double result = 0;
-
-    if (power == 0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i] == 0 ? 0 : 1;
-      }
-
-    } else if (power == 1.0) {
-      for (int i = 0; i < vec1.length; i++) {
-        result += vec1[i] - vec2[i];
-      }
-    } else if (power == 2.0) {
-      result = Math.sqrt(squaredEuclideanDistance(vec1, vec2));
-    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infinite norm?
-      for (int i = 0; i < vec1.length; i++) {
-        result = Math.max(result, Math.max(vec1[i], vec2[i]));
-      }
-    } else {
-      for (int i = 0; i < vec1.length; i++) {
-        result += Math.pow(vec1[i] - vec2[i], power);
-      }
-      result = Math.pow(result, oneOverPower);
-    }
-    return result;
-  }
-
-  /**
-   * Return the coordinates of a vector that is the corner of a box (upper right or lower left), assuming a Rectangular
-   * coordinate system.  Note, this does not apply for points on a sphere or ellipse (although it could be used as an approximatation).
-   *
-   * @param center     The center point
-   * @param result Holds the result, potentially resizing if needed.
-   * @param distance   The d from the center to the corner
-   * @param upperRight If true, return the coords for the upper right corner, else return the lower left.
-   * @return The point, either the upperLeft or the lower right
-   */
-  public static double[] vectorBoxCorner(double[] center, double[] result, double distance, boolean upperRight) {
-    if (result == null || result.length != center.length) {
-      result = new double[center.length];
-    }
-    if (upperRight == false) {
-      distance = -distance;
-    }
-    //We don't care about the power here,
-    // b/c we are always in a rectangular coordinate system, so any norm can be used by
-    //using the definition of sine
-    distance = SIN_45 * distance; // sin(Pi/4) == (2^0.5)/2 == opp/hyp == opp/distance, solve for opp, similarily for cosine
-    for (int i = 0; i < center.length; i++) {
-      result[i] = center[i] + distance;
-    }
-    return result;
-  }
-
-  /**
-   * @param latCenter  In degrees
-   * @param lonCenter  In degrees
-   * @param distance The distance
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @param upperRight If true, calculate the upper right corner, else the lower left
-   * @param radius The radius of the sphere to use.
-   * @return The Lat/Lon in degrees
-   *
-   * @see #latLonCorner(double, double, double, double[], boolean, double)
-   */
-  public static double[] latLonCornerDegs(double latCenter, double lonCenter,
-                                          double distance, double [] result,
-                                          boolean upperRight, double radius) {
-    result = latLonCorner(latCenter * DEGREES_TO_RADIANS,
-            lonCenter * DEGREES_TO_RADIANS, distance, result, upperRight, radius);
-    result[0] = result[0] * RADIANS_TO_DEGREES;
-    result[1] = result[1] * RADIANS_TO_DEGREES;
-    return result;
-  }
-
-  /**
-   * Uses Haversine to calculate the corner
-   *
-   * @param latCenter  In radians
-   * @param lonCenter  In radians
-   * @param distance   The distance
-   * @param result A preallocated array to hold the results.  If null, a new one is constructed.
-   * @param upperRight If true, give lat/lon for the upper right corner, else lower left
-   * @param radius     The radius to use for the calculation
-   * @return The Lat/Lon in Radians
-
-   */
-  public static double[] latLonCorner(double latCenter, double lonCenter,
-                                      double distance, double [] result, boolean upperRight, double radius) {
-    // Haversine formula
-    double brng = upperRight ? DEG_45 : DEG_225;
-    double lat2 = Math.asin(Math.sin(latCenter) * Math.cos(distance / radius) +
-            Math.cos(latCenter) * Math.sin(distance / radius) * Math.cos(brng));
-    double lon2 = lonCenter + Math.atan2(Math.sin(brng) * Math.sin(distance / radius) * Math.cos(latCenter),
-            Math.cos(distance / radius) - Math.sin(latCenter) * Math.sin(lat2));
-
-    /*lat2 = (lat2*180)/Math.PI;
-    lon2 = (lon2*180)/Math.PI;*/
-    //From Lucene.  Move back to Lucene when synced
-    // normalize long first
-    if (result == null || result.length != 2){
-      result = new double[2];
-    }
-    result[0] = lat2;
-    result[1] = lon2;
-    normLng(result);
-
-    // normalize lat - could flip poles
-    normLat(result);
-
-    return result;
-  }
-
-  /**
-   * @param latLng The lat/lon, in radians. lat in position 0, long in position 1
-   */
-  public static void normLat(double[] latLng) {
-
-    if (latLng[0] > DEG_90) {
-      latLng[0] = DEG_90 - (latLng[0] - DEG_90);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180;
-      } else {
-        latLng[1] = latLng[1] - DEG_180;
-      }
-    } else if (latLng[0] < -DEG_90) {
-      latLng[0] = -DEG_90 - (latLng[0] + DEG_90);
-      if (latLng[1] < 0) {
-        latLng[1] = latLng[1] + DEG_180;
-      } else {
-        latLng[1] = latLng[1] - DEG_180;
-      }
-    }
-
-  }
-
-  /**
-   * Returns a normalized Lng rectangle shape for the bounding box
-   *
-   * @param latLng The lat/lon, in radians, lat in position 0, long in position 1
-   */
-  public static void normLng(double[] latLng) {
-    if (latLng[1] > DEG_180) {
-      latLng[1] = -1.0 * (DEG_180 - (latLng[1] - DEG_180));
-    } else if (latLng[1] < -DEG_180) {
-      latLng[1] = (latLng[1] + DEG_180) + DEG_180;
-    }
-  }
-
-  /**
-   * The square of the Euclidean Distance.  Not really a distance, but useful if all that matters is
-   * comparing the result to another one.
-   *
-   * @param vec1 The first point
-   * @param vec2 The second point
-   * @return The squared Euclidean distance
-   */
-  public static double squaredEuclideanDistance(double[] vec1, double[] vec2) {
-    double result = 0;
-    for (int i = 0; i < vec1.length; i++) {
-      double v = vec1[i] - vec2[i];
-      result += v * v;
-    }
-    return result;
-  }
-
-  /**
-   * @param x1     The x coordinate of the first point, in radians
-   * @param y1     The y coordinate of the first point, in radians
-   * @param x2     The x coordinate of the second point, in radians
-   * @param y2     The y coordinate of the second point, in radians
-   * @param radius The radius of the sphere
-   * @return The distance between the two points, as determined by the Haversine formula.
-
-   */
-  public static double haversine(double x1, double y1, double x2, double y2, double radius) {
-    double result = 0;
-    //make sure they aren't all the same, as then we can just return 0
-    if ((x1 != x2) || (y1 != y2)) {
-      double diffX = x1 - x2;
-      double diffY = y1 - y2;
-      double hsinX = Math.sin(diffX * 0.5);
-      double hsinY = Math.sin(diffY * 0.5);
-      double h = hsinX * hsinX +
-              (Math.cos(x1) * Math.cos(x2) * hsinY * hsinY);
-      result = (radius * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)));
-    }
-    return result;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a String array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static String[] parsePoint(String[] out, String externalVal, int dimension) throws InvalidGeoException{
-    //TODO: Should we support sparse vectors?
-    if (out == null || out.length != dimension) out = new String[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = externalVal.trim();
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = externalVal.substring(start, end);
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidGeoException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  /**
-   * Given a string containing <i>dimension</i> values encoded in it, separated by commas, return a double array of length <i>dimension</i>
-   * containing the values.
-   *
-   * @param out         A preallocated array.  Must be size dimension.  If it is not it will be resized.
-   * @param externalVal The value to parse
-   * @param dimension   The expected number of values for the point
-   * @return An array of the values that make up the point (aka vector)
-   * @throws InvalidGeoException if the dimension specified does not match the number of values in the externalValue.
-   */
-  public static double[] parsePointDouble(double[] out, String externalVal, int dimension) throws InvalidGeoException{
-    if (out == null || out.length != dimension) out = new double[dimension];
-    int idx = externalVal.indexOf(',');
-    int end = idx;
-    int start = 0;
-    int i = 0;
-    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {//we have a single point, dimension better be 1
-      out[0] = Double.parseDouble(externalVal.trim());
-      i = 1;
-    } else if (idx > 0) {//if it is zero, that is an error
-      //Parse out a comma separated list of point values, as in: 73.5,89.2,7773.4
-      for (; i < dimension; i++) {
-        //TODO: abstract common code with other parsePoint
-        while (start < end && externalVal.charAt(start) == ' ') start++;
-        while (end > start && externalVal.charAt(end - 1) == ' ') end--;
-        if (start == end) {
-          break;
-        }
-        out[i] = Double.parseDouble(externalVal.substring(start, end));
-        start = idx + 1;
-        end = externalVal.indexOf(',', start);
-        idx = end;
-        if (end == -1) {
-          end = externalVal.length();
-        }
-      }
-    }
-    if (i != dimension) {
-      throw new InvalidGeoException("incompatible dimension (" + dimension +
-              ") and values (" + externalVal + ").  Only " + i + " values specified");
-    }
-    return out;
-  }
-
-  public static final double[] parseLatitudeLongitude(String latLonStr) throws InvalidGeoException {
-    return parseLatitudeLongitude(null, latLonStr);
-  }
-
-  /**
-   * extract (by calling {@link #parsePoint(String[], String, int)} and validate the latitude and longitude contained
-   * in the String by making sure the latitude is between 90 & -90 and longitude is between -180 and 180.
-   * <p/>
-   * The latitude is assumed to be the first part of the string and the longitude the second part.
-   *
-   * @param latLon    A preallocated array to hold the result
-   * @param latLonStr The string to parse.  Latitude is the first value, longitude is the second.
-   * @return The lat long
-   * @throws InvalidGeoException if there was an error parsing
-   */
-  public static final double[] parseLatitudeLongitude(double[] latLon, String latLonStr) throws InvalidGeoException {
-    if (latLon == null) {
-      latLon = new double[2];
-    }
-    double[] toks = parsePointDouble(null, latLonStr, 2);
-
-    if (toks[0] < -90.0 || toks[0] > 90.0) {
-      throw new InvalidGeoException(
-              "Invalid latitude: latitudes are range -90 to 90: provided lat: ["
-                      + toks[0] + "]");
-    }
-    latLon[0] = toks[0];
-
-
-    if (toks[1] < -180.0 || toks[1] > 180.0) {
-
-      throw new InvalidGeoException(
-              "Invalid longitude: longitudes are range -180 to 180: provided lon: ["
-                      + toks[1] + "]");
-    }
-    latLon[1] = toks[1];
-
-    return latLon;
-  }
-}
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
index 98db7b8..44fba38 100644
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
+++ b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
@@ -23,6 +23,7 @@ import org.apache.lucene.search.FilteredDocIdSet;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.spatial.DistanceUtils;
 
 
 /**
diff --git a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java
index d965fff..42ed3ce 100644
--- a/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java
+++ b/lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/SinusoidalProjector.java
@@ -17,8 +17,6 @@
 
 package org.apache.lucene.spatial.tier.projections;
 
-import org.apache.lucene.spatial.tier.DistanceUtils;
-
 /**
  * Based on Sinusoidal Projections
  * Project a latitude / longitude on a 2D cartesian map
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java
index 9884b54..f0e0e30 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/DistanceUtilsTest.java
@@ -1,7 +1,6 @@
 package org.apache.lucene.spatial;
 
 import junit.framework.TestCase;
-import org.apache.lucene.spatial.tier.DistanceUtils;
 import org.apache.lucene.spatial.tier.InvalidGeoException;
 
 
@@ -180,7 +179,7 @@ public class DistanceUtilsTest extends TestCase {
 
 
     try {
-      parse = org.apache.lucene.spatial.tier.DistanceUtils.parsePoint(null, "89.0         ,   ", 3);
+      parse = DistanceUtils.parsePoint(null, "89.0         ,   ", 3);
       assertTrue(false);
     } catch (InvalidGeoException e) {
     }
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java
index 04c6c15..71c5f02 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java
@@ -16,6 +16,8 @@
  */
 package org.apache.lucene.spatial.tier;
 
+import org.apache.lucene.spatial.DistanceUtils;
+
 import java.text.DecimalFormat;
 
 
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
index 47fd2c7..c42149f 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
@@ -40,6 +40,7 @@ import org.apache.lucene.search.function.CustomScoreQuery;
 import org.apache.lucene.search.function.CustomScoreProvider;
 import org.apache.lucene.search.function.FieldScoreQuery;
 import org.apache.lucene.search.function.FieldScoreQuery.Type;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
 import org.apache.lucene.spatial.geometry.DistanceUnits;
 import org.apache.lucene.spatial.geometry.FloatLatLng;
diff --git a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java
index db11db3..8cb11fa 100644
--- a/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java
+++ b/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/projections/SinusoidalProjectorTest.java
@@ -1,10 +1,7 @@
 package org.apache.lucene.spatial.tier.projections;
 
-import org.apache.lucene.spatial.tier.DistanceUtils;
 import org.junit.Test;
 
-import static junit.framework.Assert.*;
-
 
 /**
  *
diff --git a/solr/src/java/org/apache/solr/schema/GeoHashField.java b/solr/src/java/org/apache/solr/schema/GeoHashField.java
index 506b083..9be6130 100644
--- a/solr/src/java/org/apache/solr/schema/GeoHashField.java
+++ b/solr/src/java/org/apache/solr/schema/GeoHashField.java
@@ -21,7 +21,7 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.tier.InvalidGeoException;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
@@ -42,7 +42,7 @@ import java.io.IOException;
  * href="http://en.wikipedia.org/wiki/Geohash">Geohash</a> field. The field is
  * provided as a lat/lon pair and is internally represented as a string.
  *
- * @see org.apache.lucene.spatial.tier.DistanceUtils#parseLatitudeLongitude(double[], String)
+ * @see org.apache.lucene.spatial.DistanceUtils#parseLatitudeLongitude(double[], String)
  */
 public class GeoHashField extends FieldType implements SpatialQueryable {
 
diff --git a/solr/src/java/org/apache/solr/schema/LatLonType.java b/solr/src/java/org/apache/solr/schema/LatLonType.java
index 0de85b1..3043c9c 100644
--- a/solr/src/java/org/apache/solr/schema/LatLonType.java
+++ b/solr/src/java/org/apache/solr/schema/LatLonType.java
@@ -22,9 +22,8 @@ import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.tier.InvalidGeoException;
-import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.response.XMLWriter;
diff --git a/solr/src/java/org/apache/solr/schema/PointType.java b/solr/src/java/org/apache/solr/schema/PointType.java
index e3941da..55a9df5 100644
--- a/solr/src/java/org/apache/solr/schema/PointType.java
+++ b/solr/src/java/org/apache/solr/schema/PointType.java
@@ -23,7 +23,7 @@ import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.tier.InvalidGeoException;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.MapSolrParams;
@@ -201,8 +201,8 @@ public class PointType extends CoordinateFieldType implements SpatialQueryable {
     } else {
       BooleanQuery tmp = new BooleanQuery();
       //TODO: Handle distance measures, as this assumes Euclidean
-      double [] ur = org.apache.lucene.spatial.tier.DistanceUtils.vectorBoxCorner(point, null, options.distance, true);
-      double [] ll = org.apache.lucene.spatial.tier.DistanceUtils.vectorBoxCorner(point, null, options.distance, false);
+      double [] ur = DistanceUtils.vectorBoxCorner(point, null, options.distance, true);
+      double [] ll = DistanceUtils.vectorBoxCorner(point, null, options.distance, false);
       for (int i = 0; i < ur.length; i++) {
         SchemaField subSF = subField(options.field, i);
         Query range = subSF.getType().getRangeQuery(parser, subSF, String.valueOf(ll[i]), String.valueOf(ur[i]), true, true);
diff --git a/solr/src/java/org/apache/solr/search/SpatialFilterQParser.java b/solr/src/java/org/apache/solr/search/SpatialFilterQParser.java
index 325ba46..6c80583 100644
--- a/solr/src/java/org/apache/solr/search/SpatialFilterQParser.java
+++ b/solr/src/java/org/apache/solr/search/SpatialFilterQParser.java
@@ -20,7 +20,7 @@ package org.apache.solr.search;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
diff --git a/solr/src/java/org/apache/solr/search/ValueSourceParser.java b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
index 46cc1bb..a7f2d14 100755
--- a/solr/src/java/org/apache/solr/search/ValueSourceParser.java
+++ b/solr/src/java/org/apache/solr/search/ValueSourceParser.java
@@ -26,7 +26,7 @@ import org.apache.lucene.search.spell.JaroWinklerDistance;
 import org.apache.lucene.search.spell.LevensteinDistance;
 import org.apache.lucene.search.spell.NGramDistance;
 import org.apache.lucene.search.spell.StringDistance;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.solr.common.SolrException;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java b/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
index 4aa4d40..5e26fb4 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/GeohashHaversineFunction.java
@@ -17,7 +17,7 @@ package org.apache.solr.search.function.distance;
  */
 
 
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.index.IndexReader;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java b/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
index 2fff282..26ee222 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/HaversineFunction.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.function.distance;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Searcher;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.search.function.MultiValueSource;
 import org.apache.solr.search.function.DocValues;
diff --git a/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java b/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
index d019733..729e7de 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/SquaredEuclideanFunction.java
@@ -16,7 +16,7 @@ package org.apache.solr.search.function.distance;
  * limitations under the License.
  */
 
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.search.function.DocValues;
 import org.apache.solr.search.function.MultiValueSource;
 
diff --git a/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java b/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
index c259611..5d87683 100644
--- a/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
+++ b/solr/src/java/org/apache/solr/search/function/distance/VectorDistanceFunction.java
@@ -18,7 +18,7 @@ package org.apache.solr.search.function.distance;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Searcher;
-import org.apache.lucene.spatial.tier.DistanceUtils;
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.search.function.DocValues;
 import org.apache.solr.search.function.MultiValueSource;
diff --git a/solr/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java b/solr/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
index c1bf97c..7436446 100644
--- a/solr/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
+++ b/solr/src/test/org/apache/solr/search/function/distance/DistanceFunctionTest.java
@@ -16,8 +16,8 @@ package org.apache.solr.search.function.distance;
  * limitations under the License.
  */
 
+import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
-import org.apache.lucene.spatial.tier.DistanceUtils;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrException;
 import org.junit.BeforeClass;

