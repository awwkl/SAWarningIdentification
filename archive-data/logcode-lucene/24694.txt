GitDiffStart: 6fd283db33eb3050cf587c2952a873f604569046 | Sat Jun 1 18:55:16 2002 +0000
diff --git a/sandbox/contributions/webcrawler-LARM/CHANGES.txt b/sandbox/contributions/webcrawler-LARM/CHANGES.txt
index 2234b40..58d8bf7 100644
--- a/sandbox/contributions/webcrawler-LARM/CHANGES.txt
+++ b/sandbox/contributions/webcrawler-LARM/CHANGES.txt
@@ -1,5 +1,12 @@
 $id: $
 
+2002-06-01 (cmarschner)
+	* divided Storage into LinkStorage and DocumentStorage
+	* introduced StoragePipeline, made MessageHandler a LinkStorage. Fetcher now stores everything in storages
+	* removed a couple of unused classes
+	now everything's prepared for a LuceneStorage
+	* added build.xml by Mehran Mehr
+
 2002-05-23 (cmarschner)
 	* removed 0x0d0d from the source files (Otis?)
 	* included Apache License into all of the source files in de.lanlab.larm.* directories
diff --git a/sandbox/contributions/webcrawler-LARM/TODO.txt b/sandbox/contributions/webcrawler-LARM/TODO.txt
new file mode 100644
index 0000000..823ba5c
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/TODO.txt
@@ -0,0 +1,69 @@
+
+Todos for 1.0 (not yet ordered in decreasing priority)
+
+$id: $
+
+* Bugs
+	- on very fast LAN connections (100MBit), sockets are not freed as fast as allocated
+	- some relative URLs are not appended appropriately, leading to wrong and growing URLs
+
+* Build
+	- added build.xml, but build.bat and build.sh are still working without ANT. Change that.
+
+* LuceneStorage
+	- define a configurable interface that saves fetched pages into a Lucene index
+
+* Configuration
+	- move all configuration stuff into a meaningful properties file
+
+* URLs: 
+	- include a URLNormalizer
+	  * lowercase host names
+	  * avoid ambiguities like '%20' / '+'
+	  * make sure http://host URLs end with "/"
+	  * avoid host name aliases
+	    - two host names / one ip adress can point to the same web site: www.lmu.de / www.uni-muenchen.de
+	    - two host names / one ip adress can point to different web sites (then other URLs / pages must differ)
+	      suche.lmu.de / interesse.lmu.de
+	  * cater 301/302 result codes
+
+* Repository
+	- optionally use a database as repository (caches, queues, logs)
+	- if done so, use URL reordering to speed things up
+
+* Tests
+	  - Put all tests into a JUnit test suite
+
+* distribution
+	- optionally send messages through a JMS topic. 
+	- create an executable that installs a source (like JMS, page files) and a storage pipeline
+	- partition the URL space for distributed Fetchers
+
+* Speed
+	- avoid synchronization delays by putting several URLMessages into one FetcherTask
+
+* Services
+	- clean up ThreadMonitor
+	- incorporate a CRON-like service that enables timed GC'ing, batched data transfer, and
+	  monitoring
+
+* Politeness
+	- add the option to restrict the number of host accesses per hour/minute
+
+* Anchor text extraction
+	  * read until a meaningful end tag, not just the first encountered
+	  * remove entities
+	  * optionally remove Tags, leave ALT attribute
+	  * remove redundant spaces
+
+
+
+Nice-to-have:
+
+* Stop and Continue (probably with database repository)
+* "Hot Configure" from outside
+* Web Interface
+
+Next topic:
+* Incremental crawling
+
diff --git a/sandbox/contributions/webcrawler-LARM/build.xml b/sandbox/contributions/webcrawler-LARM/build.xml
new file mode 100644
index 0000000..4aecf84
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/build.xml
@@ -0,0 +1,112 @@
+<?xml version="1.0"?>
+
+<project name="webcrawler-LARM" default="build" basedir=".">
+
+  <property name="name"           value="webcrawler_LARM"/>
+  <property name="version"        value="0.5"/>
+  <property name="final.name"     value="${name}-${version}"/>
+  <property name="debug"          value="on"/>
+
+  <property name="src.dir"        value="./src"/>
+  <property name="lib.dir"        value="./libs"/>
+  <property name="logs.dir"       value="./logs"/>
+  <property name="cache.dir"      value="./cachingqueue"/>
+  <property name="build.dir"      value="./build"/>
+
+  <property name="src.httpclient" value="${lib.dir}/HTTPClient.zip"/>
+  <property name="build.classes"  value="${build.dir}/src"/>
+  <property name="build.src"      value="${build.dir}/src"/>
+  <property name="build.encoding" value="ISO-8859-1"/>
+
+  <property name="threads"        value="15"/>
+
+<!-- Build classpath -->
+  <path id="classpath">
+    <pathelement location="${build.classes}"/>
+    <fileset dir="${lib.dir}">
+      <include name="*.jar" />
+    </fileset>
+  </path>
+
+  <path id="run.classpath">
+    <pathelement location="${build.dir}/${final.name}.jar"/>
+    <fileset dir="${lib.dir}">
+      <include name="*.jar" />
+    </fileset>
+  </path>
+
+  <!-- ================================================================== -->
+  <!-- B U I L D                                                          -->
+  <!-- ================================================================== -->
+  <target name="build"
+    description="-> builds jar file">
+    <mkdir dir="${build.dir}"/>
+    <mkdir dir="${build.classes}"/>
+    <mkdir dir="${build.src}"/>
+    <unzip src="${src.httpclient}" dest="${build.src}" overwrite="false"/>
+    <javac
+      encoding="${build.encoding}"
+      srcdir="${src.dir}:${build.src}"
+      excludes="**/CVS/*"
+      destdir="${build.classes}"
+      debug="${debug}">
+      <classpath refid="classpath"/>
+    </javac>
+    <jar
+      jarfile="${build.dir}/${final.name}.jar"
+      basedir="${build.classes}"
+    />
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Check Syntax for Run Task                                          -->
+  <!-- ================================================================== -->
+  <target name="checksyntax" unless="start">
+    <echo>
+    use run with the following syntax
+    
+    ant run -Dstart=&lt;URL&gt; -Drestrictto=&lt;Pattern&gt; [-threads=&lt;Thread Count&gt;]
+    
+    default value for threads is 15
+    </echo>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- R U N                                                              -->
+  <!-- ================================================================== -->
+  <target name="run" depends="build, checksyntax" if="start"
+    description="-> runs command-line version of the crawler">
+    <delete dir="${logs.dir}"/>
+    <mkdir dir="${logs.dir}"/>
+    <java 
+      classname="de.lanlab.larm.fetcher.FetcherMain"
+      fork="yes">
+      <jvmarg value="-server"/>
+      <jvmarg value="-Xmx400mb"/>
+      <arg value="-start"/>
+      <arg value="${start}"/>
+      <arg value="-restrictto"/>
+      <arg value="${restrictto}"/>
+      <arg value="-threads"/>
+      <arg value="${threads}"/>
+      <classpath refid="run.classpath"/>
+    </java>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- C L E A N   L A S T   R U N                                        -->
+  <!-- ================================================================== -->
+  <target name="cleanlastrun"
+    description="-> cleans files created by each run of the crawler">
+    <delete dir="${logs.dir}"/>
+    <delete dir="${cache.dir}"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- C L E A N   A L L                                                  -->
+  <!-- ================================================================== -->
+  <target name="cleanall" depends="cleanlastrun"
+    description="-> cleans all build and run files">
+    <delete dir="${build.dir}"/>
+  </target>
+</project>
diff --git a/sandbox/contributions/webcrawler-LARM/libs/placeholder b/sandbox/contributions/webcrawler-LARM/libs/placeholder
new file mode 100644
index 0000000..3c05700
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/libs/placeholder
@@ -0,0 +1 @@
+CVS happy
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
index ec4854c..0783da5 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
@@ -106,10 +106,11 @@ public class Fetcher implements MessageListener
      * @param storage      the storage where all documents are stored
      * @param hostManager  the host manager
      */
-    public Fetcher(int maxThreads, DocumentStorage storage, HostManager hostManager)
+    public Fetcher(int maxThreads, DocumentStorage docStorage, LinkStorage linkStorage, HostManager hostManager)
     {
         this.storage = storage;
-        FetcherTask.setStorage(storage);
+        FetcherTask.setDocStorage(docStorage);
+        FetcherTask.setLinkStorage(linkStorage);
         fetcherPool = new ThreadPool(maxThreads, new FetcherThreadFactory(hostManager));
         fetcherPool.setQueue(new FetcherTaskQueue());
         docsRead = 0;
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
index 7604c37..d724791 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
@@ -179,7 +179,14 @@ public class FetcherMain
         // existing message pipeline
         SimpleLogger storeLog = new SimpleLogger("store", false);
         SimpleLogger linksLog = new SimpleLogger("links", false);
-        this.storage = new LogStorage(storeLog, true, "logs/pagefile");
+
+
+        StoragePipeline storage = new StoragePipeline();
+        storage.addDocStorage(new LogStorage(storeLog, /* save in page files? */ false, /* logfile prefix */ "logs/pagefile"));
+        storage.addLinkStorage(new LinkLogStorage(linksLog));
+        storage.addLinkStorage(messageHandler);
+        //storage.addStorage(new LuceneStorage(...));
+        //storage.addStorage(new JMSStorage(...));
 
         // a third example would be the NullStorage, which converts the documents into
         // heat, which evaporates above the processor
@@ -188,14 +195,14 @@ public class FetcherMain
         // create the filters and add them to the message queue
         urlScopeFilter = new URLScopeFilter();
 
-        urlVisitedFilter = new URLVisitedFilter(100000, linksLog);
+        urlVisitedFilter = new URLVisitedFilter(100000);
 
         // dnsResolver = new DNSResolver();
         hostManager = new HostManager(1000);
 
         reFilter = new RobotExclusionFilter(hostManager);
 
-        fetcher = new Fetcher(nrThreads, storage, hostManager);
+        fetcher = new Fetcher(nrThreads, storage, storage, hostManager);
 
         knownPathsFilter = new KnownPathsFilter();
 
@@ -207,6 +214,8 @@ public class FetcherMain
         // prevent GZipped files from being decoded
         HTTPConnection.removeDefaultModule(HTTPClient.ContentEncodingModule.class);
 
+
+
         // initialize the threads
         fetcher.init();
 
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
index f55de4e..dba9a8e 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
@@ -61,6 +61,8 @@ import de.lanlab.larm.util.ObservableInputStream;
 import de.lanlab.larm.util.WebDocument;
 import de.lanlab.larm.util.SimpleCharArrayReader;
 import de.lanlab.larm.storage.DocumentStorage;
+import de.lanlab.larm.storage.LinkStorage;
+
 import de.lanlab.larm.util.State;
 import de.lanlab.larm.util.SimpleLogger;
 import de.lanlab.larm.net.HttpTimeoutFactory;
@@ -122,9 +124,16 @@ public class FetcherTask
     private volatile long bytesRead = 0;
 
     /**
-     * the storage this task will put the document to
+     * the docStorage this task will put the document to
+     */
+    private static volatile DocumentStorage docStorage;
+
+    /**
+     * the docStorage this task will put the links to
      */
-    private static volatile DocumentStorage storage;
+    private static volatile LinkStorage linkStorage;
+
+
 
     /**
      * task state IDs. comparisons will be done by their references, so always
@@ -207,13 +216,23 @@ public class FetcherTask
 
 
     /**
-     * Sets the document storage
+     * Sets the document docStorage
+     *
+     * @param docStorage  The new docStorage
+     */
+    public static void setDocStorage(DocumentStorage docStorage)
+    {
+        FetcherTask.docStorage = docStorage;
+    }
+
+    /**
+     * Sets the document linkStorage
      *
-     * @param storage  The new storage
+     * @param linkStorage  The new linkStorage
      */
-    public static void setStorage(DocumentStorage storage)
+    public static void setLinkStorage(LinkStorage linkStorage)
     {
-        FetcherTask.storage = storage;
+        FetcherTask.linkStorage = linkStorage;
     }
 
 
@@ -382,8 +401,9 @@ public class FetcherTask
                     log.log("scanned");
                 }
                 taskState.setState(FT_STORING, ipURL);
-                messageHandler.putMessages(foundUrls);
-                storage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));
+                linkStorage.storeLinks(foundUrls);
+                //messageHandler.putMessages(foundUrls);
+                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));
                 log.log("stored");
             }
         }
@@ -519,8 +539,8 @@ public class FetcherTask
 
 
     /**
-     * this is called whenever a links was found in the current document,
-     * Don't create too many objects here, this will be called
+     * this is called whenever a link was found in the current document,
+     * Don't create too many objects here, as this will be called
      * millions of times
      *
      * @param link  Description of the Parameter
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
index 2c83845..23006a9 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
@@ -52,7 +52,7 @@
  * <http://www.apache.org/>.
  */
 
- package de.lanlab.larm.fetcher;
+package de.lanlab.larm.fetcher;
 
 
 /**
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
index 14ed2be..a7b1512 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
@@ -58,6 +58,7 @@ import java.util.*;
 import de.lanlab.larm.util.SimpleObservable;
 import de.lanlab.larm.util.CachingQueue;
 import de.lanlab.larm.util.UnderflowException;
+import de.lanlab.larm.storage.LinkStorage;
 
 /**
  *  this is a message handler that runs in its own thread.
@@ -71,7 +72,7 @@ import de.lanlab.larm.util.UnderflowException;
  *  This implements a chain of responsibility-style message handling
  * @version $Id$
  */
-public class MessageHandler implements Runnable
+public class MessageHandler implements Runnable, LinkStorage
 {
 
     /**
@@ -118,7 +119,7 @@ public class MessageHandler implements Runnable
     /**
      *  messageHandler-Thread erzeugen und starten
      */
-    MessageHandler()
+    public MessageHandler()
     {
         t = new Thread(this,"MessageHandler Thread");
         t.setPriority(5);   // higher priority to prevent starving when a lot of fetcher threads are used
@@ -175,7 +176,7 @@ public class MessageHandler implements Runnable
 
 
     /**
-     *  einen Event in die Schlange schreiben
+     *  insert one message into the queue
      */
     public void putMessage(Message msg)
     {
@@ -208,6 +209,13 @@ public class MessageHandler implements Runnable
         }
     }
 
+    public Collection storeLinks(Collection links)
+    {
+        putMessages(links);
+        return links;
+    }
+
+
     /**
      *  the main messageHandler-Thread.
      */
@@ -251,22 +259,22 @@ public class MessageHandler implements Runnable
                     messageQueueObservable.setChanged();
                     messageQueueObservable.notifyObservers(new Integer(-1));      // Message processed
 
-                    // und verteilen. Die Listener erhalten die Message in ihrer
-                    // Eintragungsreihenfolge und k?nen die Message auch ver?dern
+                    // now distribute them. The handlers get the messages in the order
+                    // of insertion and have the right to change them
 
                     Iterator i = listeners.iterator();
                     while(i.hasNext())
                     {
-                        //System.out.println("Verteile...");
                         try
                         {
                             MessageListener listener = (MessageListener)i.next();
                             m = (Message)listener.handleRequest(m);
                             if (m == null)
                             {
+                                // handler has consumed the message
                                 messageProcessorObservable.setChanged();
                                 messageProcessorObservable.notifyObservers(listener);
-                                break;     // Handler hat die Message konsumiert
+                                break;
                             }
                         }
                         catch(ClassCastException e)
@@ -285,7 +293,7 @@ public class MessageHandler implements Runnable
                 messagesWaiting = false;
                 // System.out.println("MessageHandler: messagesWaiting = true although nothing queued!");
                 // @FIXME: here is still a multi threading issue. I don't get it why this happens.
-                //         does someone want to draw a petri net of this?
+                //         does someone want to draw a petri net of this? ;-)
             }
             catch (Exception e)
             {
@@ -300,4 +308,8 @@ public class MessageHandler implements Runnable
     {
         return messageQueue.size();
     }
+
+    public void openLinkStorage()
+    {
+    }
 }
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
index e972930..4ed5feb 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
@@ -69,7 +69,7 @@ import de.lanlab.larm.util.SimpleLogger;
  * @created   3. Januar 2002
  * @version $Id$
  */
-class URLVisitedFilter extends Filter implements MessageListener
+public class URLVisitedFilter extends Filter implements MessageListener
 {
 
     /**
@@ -79,13 +79,10 @@ class URLVisitedFilter extends Filter implements MessageListener
      */
     public void notifyAddedToMessageHandler(MessageHandler handler)
     {
-        this.messageHandler = handler;
     }
 
 
-    MessageHandler messageHandler;
-
-    SimpleLogger log;
+    //SimpleLogger log;
 
     HashSet urlHash;
 
@@ -98,10 +95,9 @@ class URLVisitedFilter extends Filter implements MessageListener
      *
      * @param initialHashCapacity  Description of the Parameter
      */
-    public URLVisitedFilter(int initialHashCapacity, SimpleLogger log)
+    public URLVisitedFilter(int initialHashCapacity)
     {
         urlHash = new HashSet(initialHashCapacity);
-        this.log = log;
         //urlVector = new Vector(initialHashCapacity);
     }
 
@@ -132,10 +128,6 @@ class URLVisitedFilter extends Filter implements MessageListener
             {
                 //System.out.println("URLVisitedFilter: " + urlString + " already present.");
                 filtered++;
-                if(log != null)
-                {
-                    log.log(urlMessage.getInfo());
-                }
                 return null;
             }
             else
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java
new file mode 100644
index 0000000..c384208
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java
@@ -0,0 +1,264 @@
+/*
+ *  ====================================================================
+ *  The Apache Software License, Version 1.1
+ *
+ *  Copyright (c) 2001 The Apache Software Foundation.  All rights
+ *  reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ *
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ *
+ *  3. The end-user documentation included with the redistribution,
+ *  if any, must include the following acknowledgment:
+ *  "This product includes software developed by the
+ *  Apache Software Foundation (http://www.apache.org/)."
+ *  Alternately, this acknowledgment may appear in the software itself,
+ *  if and wherever such third-party acknowledgments normally appear.
+ *
+ *  4. The names "Apache" and "Apache Software Foundation" and
+ *  "Apache Lucene" must not be used to endorse or promote products
+ *  derived from this software without prior written permission. For
+ *  written permission, please contact apache@apache.org.
+ *
+ *  5. Products derived from this software may not be called "Apache",
+ *  "Apache Lucene", nor may "Apache" appear in their name, without
+ *  prior written permission of the Apache Software Foundation.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *  ====================================================================
+ *
+ *  This software consists of voluntary contributions made by many
+ *  individuals on behalf of the Apache Software Foundation.  For more
+ *  information on the Apache Software Foundation, please see
+ *  <http://www.apache.org/>.
+ */
+package de.lanlab.larm.parser;
+
+import java.util.Hashtable;
+import java.io.*;
+
+/**
+ * A very simple entity manager. Based on HeX, the HTML enabled XML parser, by
+ * Anders Kristensen, HP Labs Bristol
+ *
+ * @author    Administrator
+ * @created   1. Juni 2002
+ */
+public class EntityManager
+{
+    /**
+     * Description of the Field
+     */
+    protected Hashtable entities = new Hashtable();
+
+    /**
+     * Description of the Field
+     */
+    private Tokenizer tok;
+
+
+    /**
+     * Constructor for the EntityManager object
+     *
+     * @param tok  Description of the Parameter
+     */
+    public EntityManager(Tokenizer tok)
+    {
+        this.tok = tok;
+        entities.put("amp", "&");
+        entities.put("lt", "<");
+        entities.put("gt", ">");
+        entities.put("apos", "'");
+        entities.put("quot", "\"");
+        entities.put("auml", "?");
+        entities.put("ouml", "?");
+        entities.put("uuml", "?");
+        entities.put("Auml", "?");
+        entities.put("Ouml", "?");
+        entities.put("Uuml", "?");
+        entities.put("szlig", "?");
+
+    }
+
+
+    /**
+     * Finds entitiy and character references in the provided char array and
+     * decodes them. The operation is destructive, i.e. the encoded string
+     * replaces the original - this is atrightforward since the new string can
+     * only get shorter.
+     *
+     * @param buffer         Description of the Parameter
+     * @return               Description of the Return Value
+     * @exception Exception  Description of the Exception
+     */
+    public final SimpleCharArrayWriter entityDecode(SimpleCharArrayWriter buffer)
+        throws Exception
+    {
+        char[] buf = buffer.getCharArray();
+        // avoids method calls
+        int len = buffer.size();
+
+        // not fastest but certainly simplest:
+        if (indexOf(buf, '&', 0, len) == -1)
+        {
+            return buffer;
+        }
+        SimpleCharArrayWriter newbuf = new SimpleCharArrayWriter(len);
+
+        for (int start = 0; ; )
+        {
+            int x = indexOf(buf, '&', start, len);
+            if (x == -1)
+            {
+                newbuf.write(buf, start, len - start);
+                return newbuf;
+            }
+            else
+            {
+                newbuf.write(buf, start, x - start);
+                start = x + 1;
+                x = indexOf(buf, ';', start, len);
+                if (x == -1)
+                {
+                    //tok.warning("Entity reference not semicolon terminated");
+                    newbuf.write('&');
+                    //break; //???????????
+                }
+                else
+                {
+                    try
+                    {
+                        writeEntityDef(buf, start, x - start, newbuf);
+                        start = x + 1;
+                    }
+                    catch (Exception ex)
+                    {
+                        //tok.warning("Bad entity reference");
+                    }
+                }
+            }
+        }
+    }
+
+
+    // character references are rare enough that we don't care about
+    // creating a String object for them unnecessarily...
+    /**
+     * Description of the Method
+     *
+     * @param buf                        Description of the Parameter
+     * @param off                        Description of the Parameter
+     * @param len                        Description of the Parameter
+     * @param out                        Description of the Parameter
+     * @exception Exception              Description of the Exception
+     * @exception IOException            Description of the Exception
+     * @exception NumberFormatException  Description of the Exception
+     */
+    public void writeEntityDef(char[] buf, int off, int len, Writer out)
+        throws Exception, IOException, NumberFormatException
+    {
+        Integer ch;
+        //System.out.println("Entity: " + new String(buf, off, len) +" "+off+" "+len);
+
+        if (buf[off] == '#')
+        {
+            // character reference
+            off++;
+            len--;
+            if (buf[off] == 'x' || buf[off] == 'X')
+            {
+                ch = Integer.valueOf(new String(buf, off + 1, len - 1), 16);
+            }
+            else
+            {
+                ch = Integer.valueOf(new String(buf, off, len));
+            }
+            out.write(ch.intValue());
+        }
+        else
+        {
+            String ent = new String(buf, off, len);
+            String val = (String) entities.get(ent);
+            if (val != null)
+            {
+                out.write(val);
+            }
+            else
+            {
+                out.write("&" + ent + ";");
+                //tok.warning("unknown entity reference: " + ent);
+            }
+        }
+    }
+
+
+    /**
+     * Description of the Method
+     *
+     * @param entity  Description of the Parameter
+     * @param value   Description of the Parameter
+     * @return        Description of the Return Value
+     */
+    public String defTextEntity(String entity, String value)
+    {
+        return (String) entities.put(entity, value);
+    }
+
+
+    /**
+     * Returns the index within this String of the first occurrence of the
+     * specified character, starting the search at fromIndex. This method
+     * returns -1 if the character is not found.
+     *
+     * @param buf                         Description of the Parameter
+     * @param ch                          Description of the Parameter
+     * @param from                        Description of the Parameter
+     * @param to                          Description of the Parameter
+     * @return                            Description of the Return Value
+     * @params                            buf the buffer to search
+     * @params                            ch the character to search for
+     * @params                            from the index to start the search
+     *      from
+     * @params                            to the highest possible index returned
+     *      plus 1
+     * @throws IndexOutOfBoundsException  if index out of bounds...
+     */
+    public final static int indexOf(char[] buf, int ch, int from, int to)
+    {
+        int i;
+        for (i = from; i < to && buf[i] != ch; i++)
+        {
+            ;
+        }
+        // do nothing
+        if (i < to)
+        {
+            return i;
+        }
+        else
+        {
+            return -1;
+        }
+    }
+
+}
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java
new file mode 100644
index 0000000..65b0f01
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java
@@ -0,0 +1,42 @@
+package de.lanlab.larm.parser;
+
+import java.io.CharArrayWriter;
+
+/**
+ * <p>Title: </p>
+ * <p>Description: </p>
+ * <p>Copyright: Copyright (c) 2002</p>
+ * <p>Company: </p>
+ * @author unascribed
+ * @version 1.0
+ */
+
+public final class SimpleCharArrayWriter extends java.io.CharArrayWriter {
+    public SimpleCharArrayWriter() {
+        super();
+    }
+
+    public SimpleCharArrayWriter(int size) {
+        super(size);
+    }
+
+    // use only to *decrement* size
+    public void setLength(int size) {
+       // synchronized (lock) {
+            if (size < count) count = size;
+       // }
+    }
+
+    public char[] getCharArray() {
+       // synchronized (lock) {
+            return buf;
+       // }
+    }
+
+    public int getLength()
+    {
+        return count;
+    }
+
+
+}
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
index 20bbc8c..6f3593c 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
@@ -54,14 +54,9 @@
 
 package de.lanlab.larm.parser;
 
-import hplb.org.xml.sax.*;
-import hplb.xml.*;
-import hplb.xml.util.*;
-
 import java.util.Dictionary;
 import java.util.Hashtable;
 import java.io.*;
-import hplb.misc.ByteArray;
 import java.net.URL;
 
 /**
@@ -71,42 +66,37 @@ import java.net.URL;
  * some bugs. And it's FAST, about 10 x faster than the original HEX parser.
  * Being some sort of SAX parser it calls the callback functions of the LinkHandler
  * when links are found.
- * @todo add handling of anchor texts
+ * Attention: This parser is not thread safe, as a lot of locks were removed
  *
  * @author    Clemens Marschner
  * $Id$
  */
 
-public class Tokenizer implements hplb.org.xml.sax.Parser
+public class Tokenizer
 {
     /**
      * Sets the entityHandler attribute of the Tokenizer object
      *
      * @param e  The new entityHandler value
-     */
-    public void setEntityHandler(hplb.org.xml.sax.EntityHandler e) { }
-
+     *
+    public void setEntityHandler(EntityHandler e) { }
+    */
 
     /**
      * Sets the errorHandler attribute of the Tokenizer object
      *
      * @param e  The new errorHandler value
-     */
+     *
     public void setErrorHandler(hplb.org.xml.sax.ErrorHandler e) { }
-
+    */
 
     /**
      * Sets the documentHandler attribute of the Tokenizer object
      *
      * @param e  The new documentHandler value
-     */
+     *
     public void setDocumentHandler(hplb.org.xml.sax.DocumentHandler e) { }
-
-
-    /**
-     * The value of boolean attributes is this string.
-     */
-    public final static String BOOLATTR = Atom.getAtom("BOOLATTR");
+    */
 
     // FSM states:
     final static int ST_START = 1;
@@ -173,17 +163,17 @@ public class Tokenizer implements hplb.org.xml.sax.Parser
     private boolean keepPCData;
     private boolean isInTitleTag;
     private boolean isInAnchorTag;
-    CharBuffer buf = new CharBuffer();
+    SimpleCharArrayWriter buf = new SimpleCharArrayWriter();
     boolean isStartTag = true;
     /**
      * Signals whether a non-empty element has any children. If not we must
      * generate an artificial empty-string child [characters(buf, 0, 0)].
      */
     boolean noChildren;
-    CharBuffer tagname = new CharBuffer();
-    CharBuffer attrName = new CharBuffer();
-    CharBuffer attrValue = new CharBuffer(1000);
-    CharBuffer pcData = new CharBuffer(8000);
+    SimpleCharArrayWriter tagname = new SimpleCharArrayWriter();
+    SimpleCharArrayWriter attrName = new SimpleCharArrayWriter();
+    SimpleCharArrayWriter attrValue = new SimpleCharArrayWriter(1000);
+    SimpleCharArrayWriter pcData = new SimpleCharArrayWriter(8000);
     int pcDataLength;
 
     /**
@@ -722,7 +712,7 @@ public class Tokenizer implements hplb.org.xml.sax.Parser
                      // the next end tag, at most 200 characters.
                      // (end tags are often ommited, i.e. <a ...>text</td>)
                      // regards other tags as text
-                     // todo: read until next </a> or a couple other tags
+                     // @todo: read until next </a> or a couple of other tags
                     try
                     {
                         short count = 0;
@@ -991,7 +981,7 @@ public class Tokenizer implements hplb.org.xml.sax.Parser
      * Description of the Method
      *
      * @param attrs  Description of the Parameter
-     */
+     *
     public final void keysToLowerCase(SAXAttributeMap attrs)
     {
         for (int i = 0; i < attrs.n; i++)
@@ -1003,7 +993,7 @@ public class Tokenizer implements hplb.org.xml.sax.Parser
             }
         }
     }
-
+    */
 
     // toomuch true iff we read a '<' of the next token
     /**
@@ -1036,7 +1026,7 @@ public class Tokenizer implements hplb.org.xml.sax.Parser
      *  if (toomuch) {
      *  buf.setLength(buf.size() - 1);
      *  }
-     *  CharBuffer buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;
+     *  SimpleCharArrayWriter buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;
      *  docHandler.characters(buf1.getCharArray(), 0, buf1.size());
      *  /handler.gotText(getBuffer());
      *  toStart();
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
index 6dc4efd..43e0166 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
@@ -72,6 +72,9 @@ public interface DocumentStorage
      * called to store a web document
      *
      * @param doc  the document
+     * @return the document itself or a changed version. Only makes sense if
+     * storage pipeline is used; usually the storage would return the document
+     * as is.
      */
-    public void store(WebDocument doc);
+    public WebDocument store(WebDocument doc);
 }
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java
new file mode 100644
index 0000000..7168685
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java
@@ -0,0 +1,59 @@
+package de.lanlab.larm.storage;
+
+import de.lanlab.larm.storage.LinkStorage;
+import de.lanlab.larm.util.SimpleLogger;
+import de.lanlab.larm.fetcher.URLMessage;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+/**
+ * Description of the Class
+ *
+ * @author    Administrator
+ * @created   1. Juni 2002
+ */
+public class LinkLogStorage implements LinkStorage
+{
+
+    SimpleLogger log;
+
+
+    /**
+     * Constructor for the LinkLogStorage object
+     *
+     * @param logFile  Description of the Parameter
+     */
+    public LinkLogStorage(SimpleLogger logFile)
+    {
+        this.log = logFile;
+    }
+
+
+    /**
+     * empty
+     */
+    public void openLinkStorage()
+    {
+    }
+
+
+    /**
+     * Description of the Method
+     *
+     * @param c  Description of the Parameter
+     * @return   Description of the Return Value
+     */
+    public Collection storeLinks(Collection c)
+    {
+        synchronized (log)
+        {
+            for (Iterator it = c.iterator(); it.hasNext(); )
+            {
+                log.log(((URLMessage) it.next()).getInfo());
+            }
+        }
+        return c;
+    }
+
+}
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java
new file mode 100644
index 0000000..a65bf88
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java
@@ -0,0 +1,74 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package de.lanlab.larm.storage;
+import java.util.Collection;
+
+public interface LinkStorage
+{
+
+    /**
+     * Description of the Method
+     */
+    public void openLinkStorage();
+
+
+    /**
+     * stores the extracted links may contain links of more than one document
+     *
+     * @param c  Description of the Parameter
+     * @return   the collection, may have been changed or set to null
+     */
+    public Collection storeLinks(Collection c);
+}
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
index 7d28a60..3b44c72 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
@@ -191,11 +191,14 @@ public class LogStorage implements DocumentStorage
 
 
     /**
-     * stores the document if storing is enabled
+     * writes file info to log file;
+     * stores the document if storing is enabled. in that case the log line contains
+     * the page file number and the index within that file
      *
      * @param doc  Description of the Parameter
+     * @return the unchanged document
      */
-    public void store(WebDocument doc)
+    public WebDocument store(WebDocument doc)
     {
         String docInfo = doc.getInfo();
         if (logContents && isValid && doc.getDocumentBytes() != null)
@@ -204,5 +207,6 @@ public class LogStorage implements DocumentStorage
             docInfo = docInfo + "\t" + pageFileCount + "\t" + offset;
         }
         log.logThreadSafe(docInfo);
+        return doc;
     }
 }
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
index 641b74b..d2717fc 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
@@ -65,7 +65,13 @@ public class NullStorage implements DocumentStorage
     {
     }
 
-    public void open() {}
-    public void store(WebDocument doc) {}
+    public void open()
+    {
+    }
+
+    public WebDocument store(WebDocument doc)
+    {
+        return doc;
+    }
 
 }
\ No newline at end of file
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
index 6488363..f041234 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
@@ -192,7 +192,12 @@ public class SQLServerStorage implements DocumentStorage
         }
     }
 
-    public void store(WebDocument document)
+    /**
+     *
+     * @param document
+     * @return the unchanged document
+     */
+    public WebDocument store(WebDocument document)
     {
 
         PreparedStatement addDoc = null;
@@ -217,5 +222,6 @@ public class SQLServerStorage implements DocumentStorage
                 releaseStatement(addDoc);
             }
         }
+        return document;
     }
 }
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java
new file mode 100644
index 0000000..4245f5c
--- /dev/null
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java
@@ -0,0 +1,177 @@
+/*
+ *  ====================================================================
+ *  The Apache Software License, Version 1.1
+ *
+ *  Copyright (c) 2001 The Apache Software Foundation.  All rights
+ *  reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ *
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ *
+ *  3. The end-user documentation included with the redistribution,
+ *  if any, must include the following acknowledgment:
+ *  "This product includes software developed by the
+ *  Apache Software Foundation (http://www.apache.org/)."
+ *  Alternately, this acknowledgment may appear in the software itself,
+ *  if and wherever such third-party acknowledgments normally appear.
+ *
+ *  4. The names "Apache" and "Apache Software Foundation" and
+ *  "Apache Lucene" must not be used to endorse or promote products
+ *  derived from this software without prior written permission. For
+ *  written permission, please contact apache@apache.org.
+ *
+ *  5. Products derived from this software may not be called "Apache",
+ *  "Apache Lucene", nor may "Apache" appear in their name, without
+ *  prior written permission of the Apache Software Foundation.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *  ====================================================================
+ *
+ *  This software consists of voluntary contributions made by many
+ *  individuals on behalf of the Apache Software Foundation.  For more
+ *  information on the Apache Software Foundation, please see
+ *  <http://www.apache.org/>.
+ */
+package de.lanlab.larm.storage;
+
+import de.lanlab.larm.util.WebDocument;
+import de.lanlab.larm.fetcher.URLMessage;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Collection;
+
+/**
+ * @author    Clemens Marschner
+ * @created   1. Juni 2002
+ * @version   $ver: $
+ */
+
+public class StoragePipeline implements DocumentStorage, LinkStorage
+{
+
+    boolean isOpen;
+    boolean isLinkStorageOpen;
+    ArrayList docStorages;
+    ArrayList linkStorages;
+
+
+    /**
+     * Constructor for the StoragePipeline object
+     */
+    public StoragePipeline()
+    {
+        isOpen = false;
+        isLinkStorageOpen = false;
+        docStorages = new ArrayList();
+        linkStorages = new ArrayList();
+    }
+
+
+    /**
+     * open all docStorages
+     */
+    public void open()
+    {
+        for (Iterator it = docStorages.iterator(); it.hasNext(); )
+        {
+            ((DocumentStorage) it.next()).open();
+        }
+        isOpen = true;
+    }
+
+
+    /**
+     * store the doc into all docStorages
+     * document is discarded if a storage.store() returns null
+     *
+     * @see de.lanlab.larm.storage.WebDocument#store
+     * @param doc  Description of the Parameter
+     * @return     Description of the Return Value
+     */
+    public WebDocument store(WebDocument doc)
+    {
+        for(Iterator it = docStorages.iterator(); it.hasNext();)
+        {
+            doc = ((DocumentStorage)it.next()).store(doc);
+            if(doc == null)
+            {
+                break;
+            }
+        }
+        return doc;
+    }
+
+
+    /**
+     * Adds a feature to the Storage attribute of the StoragePipeline object
+     *
+     * @param storage  The feature to be added to the Storage attribute
+     */
+    public void addDocStorage(DocumentStorage storage)
+    {
+        if (isOpen)
+        {
+            throw new IllegalStateException("storage can't be added if pipeline is already open");
+        }
+        docStorages.add(storage);
+    }
+
+    /**
+     * Adds a feature to the Storage attribute of the StoragePipeline object
+     *
+     * @param storage  The feature to be added to the Storage attribute
+     */
+    public void addLinkStorage(LinkStorage storage)
+    {
+        if (isOpen)
+        {
+            throw new IllegalStateException("storage can't be added if pipeline is already open");
+        }
+        linkStorages.add(storage);
+    }
+
+
+    public void openLinkStorage()
+    {
+        for (Iterator it = linkStorages.iterator(); it.hasNext(); )
+        {
+            ((LinkStorage) it.next()).openLinkStorage();
+        }
+        isLinkStorageOpen = true;
+    }
+
+    public Collection storeLinks(Collection c)
+    {
+        for(Iterator it = linkStorages.iterator(); it.hasNext();)
+        {
+            c =  ((LinkStorage)it.next()).storeLinks(c);
+            if(c == null)
+            {
+                break;
+            }
+        }
+        return c;
+    }
+}
+
diff --git a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
index 7c4e4b5..2248fba 100644
--- a/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
+++ b/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
@@ -141,7 +141,7 @@ public class WebDocument extends URLMessage
         this.resultCode + "\t" +
         this.mimeType + "\t" +
         this.size + "\t" +
-        "\"" + this.title.replace('\"', (char)0xff ).replace('\n',' ').replace('\r',' ') + "\"";
+        "\"" + this.title.replace('\t',' ').replace('\"', (char)0xff ).replace('\n',' ').replace('\r',' ') + "\"";
     }
 
 
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/misc/ByteArray.java b/sandbox/contributions/webcrawler-LARM/src/hplb/misc/ByteArray.java
deleted file mode 100644
index 73387d1..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/misc/ByteArray.java
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.misc;
-
-import java.io.*;
-import java.net.*;
-
-/**
- * This class is a container for algorithms working on byte arrays - some
- * of the algorithms are analogous to those in java.lang.String.
- * @author      Anders Kristensen
- */
-public class ByteArray {
-
-  /** Returns copy of characters in s as a new byte array. */
-  public static final byte[] getBytes(String s) {
-    int len = s.length();
-    byte b[] = new byte[len];
-    s.getBytes(0, len, b, 0);
-    return b;
-  }
-
-  /** Returns contents of file as byte array. */
-  public static byte[] loadFromFile(String filename) throws IOException {
-    return loadFromFile(new File(filename));
-  }
-
-  /** Returns contents of file <i>file</i> as byte array. */
-  public static byte[] loadFromFile(File file) throws IOException {
-    int n, nread = 0, len = (int) file.length();
-    FileInputStream fin = new FileInputStream(file);
-    byte[] content = new byte[len];
-
-    while (nread < len) {
-      if ((n = fin.read(content, nread, len - nread)) == -1)
-        throw new IOException("Error loading Compound from file");
-      nread += n;
-    }
-
-    return content;
-  }
-
-  /**
-   * Reads n bytes from the specified input stream. It will return
-   * fewer bytes if fewer bytes are available on the stream.
-   * Hence the application should check the resulting arrays length.
-   */
-  public static byte[] readn(InputStream in, int n) throws IOException {
-    byte[] buf = new byte[n];
-    int ntotal = 0;
-    int nread;
-
-    while (ntotal < n) {
-      nread = in.read(buf, ntotal, n - ntotal);
-      if (nread < 0) {
-        // we got less than expected - return what we got
-        byte[] newbuf = new byte[ntotal];
-        System.arraycopy(buf, 0, newbuf, 0, ntotal);
-        return newbuf;
-      }
-      ntotal += nread;
-    }
-    return buf;
-  }
-
-  /**
-   * Return contents of a WWW resource identified by a URL.
-   * @param url the resource to retrieve
-   * @return    the resource contents as a byte array
-   */
-  public static byte[] getContent(URL url) throws IOException {
-    URLConnection conn = url.openConnection();
-    InputStream in = conn.getInputStream();
-    int length;
-
-    /*
-     * N.B. URLConnection.getContentLength() is buggy for "http" resources
-     * (at least in JDK1.0.2) and won't work for "file" URLs either.
-     */
-    length = length = conn.getContentLength();
-    if (length == -1)
-      length = conn.getHeaderFieldInt("Content-Length", -1);
-    if (length == -1)
-      return readAll(in);
-    return readn(in, length);
-  }
-
-  /**
-   * Read all input from an InputStream and return as a byte array.
-   * This method will not return before the end of the stream is reached.
-   * @return    contents of the stream
-   */
-  public static byte[] readAll(InputStream in) throws IOException {
-    byte[] buf = new byte[1024];
-    int nread, ntotal = 0;
-
-    while ((nread = in.read(buf, ntotal, buf.length - ntotal)) > -1) {
-      ntotal += nread;
-      if (ntotal == buf.length) {
-        // extend buffer
-        byte[] newbuf = new byte[buf.length * 2];
-        System.arraycopy(buf, 0, newbuf, 0, buf.length);
-        buf = newbuf;
-      }
-    }
-    if (ntotal < buf.length) {
-      // we cannot have excess space
-      byte[] newbuf = new byte[ntotal];
-      System.arraycopy(buf, 0, newbuf, 0, ntotal);
-      buf = newbuf;
-    }
-    return buf;
-  }
-
-  /**
-   * Copies data from the specified input stream to the output stream
-   * until end of file is met.
-   * @return    the total number of bytes written to the output stream
-   */
-  public static int cpybytes(InputStream in, OutputStream out)
-    throws IOException
-  {
-    byte[] buf = new byte[1024];
-    int n, ntotal = 0;
-    while ((n = in.read(buf)) > -1) {
-      out.write(buf, 0, n);
-      ntotal += n;
-    }
-    return ntotal;
-  }
-
-  /**
-   * Copies data from the specified input stream to the output stream
-   * until <em>n</em> bytes has been copied or end of file is met.
-   * @return    the total number of bytes written to the output stream
-   */
-  public static int cpybytes(InputStream in, OutputStream out, int n)
-    throws IOException
-  {
-    int sz = n < 1024 ? n : 1024;
-    byte[] buf = new byte[sz];
-    int chunk, nread, ntotal = 0;
-
-    chunk = sz;
-
-    while (ntotal < n && (nread = in.read(buf, 0, chunk)) > -1) {
-      out.write(buf, 0, nread);
-      ntotal += nread;
-      chunk = (n - ntotal < sz) ? n - ntotal : sz;
-    }
-    return ntotal;
-  }
-
-  /**
-   * Returns the index within this String of the first occurrence of the
-   * specified character or -1 if the character is not found.
-   * @params buf        the buffer to search
-   * @params ch         the character to search for
-   */
-  public static final int indexOf(byte[] buf,
-                                  int ch) {
-    return indexOf(buf, ch, 0, buf.length);
-  }
-
-  /**
-   * Returns the index within this String of the first occurrence of the
-   * specified character, starting the search at fromIndex. This method
-   * returns -1 if the character is not found.
-   * @params buf        the buffer to search
-   * @params ch         the character to search for
-   * @params fromIndex  the index to start the search from 
-   * @params toIndex    the highest possible index returned plus 1
-   */
-  public static final int indexOf(byte[] buf,
-                                  int ch,
-                                  int fromIndex,
-                                  int toIndex) {
-    int i;
-
-    for (i = fromIndex; i < toIndex && buf[i] != ch; i++)
-      ;  // do nothing
-
-    if (i < toIndex)
-      return i;
-    else
-      return -1;
-  }
-
-  /**
-   * Returns the index of the first occurrence of s in the specified
-   * buffer or -1 if this is not found.
-   */
-  public static final int indexOf(byte[] buf, String s) {
-    return indexOf(buf, s, 0);
-  }
-
-  /**
-   * Returns the index of the first occurrence of s in the specified
-   * buffer. The search starts from fromIndex. This method returns -1
-   * if the index is not found.
-   */
-  public static final int indexOf(byte[] buf, String s, int fromIndex) {
-    int i;                  // index into buf
-    int j;                  // index into s
-    int max_i = buf.length;
-    int max_j = s.length();
-
-    for (i = fromIndex; i + max_j <= max_i; i++) {
-      for (j = 0; j < max_j; j++) {
-        if (buf[j + i] != s.charAt(j))
-          break;
-      }
-      if (j == max_j) return i;
-    }
-    return -1;
-  }
-
-/*
-  // for testing indexOf(byte[], String, int)
-  public static void main(String[] args) {
-    byte[] buf = getBytes(args[0]);
-    System.out.println("IndexOf(arg0, arg1, 0) = " + indexOf(buf, args[1], 3));
-  }
-*/
-
-  public static final boolean isSpace(int ch) {
-    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') return true;
-    else return false;
-  }
-
-  public static final int skipSpaces(byte[] buf, int fromIndex, int toIndex) {
-    int i;
-    for (i = fromIndex; i < toIndex && isSpace(buf[i]); i++)
-      ;
-    return i;
-  }
-  /**
-   * Find byte pattern ptrn in buffer buf.
-   * @return    index of first occurrence of ptrn in buf, -1 if no occurence
-   */
-  public static final int findBytes(byte buf[],
-                                    int off,
-                                    int len,
-                                    byte ptrn[]) {
-    // Note: This code is completely incomprehensible without a drawing...
-
-    int buf_len = off + len;
-    int ptrn_len = ptrn.length;
-    int i;                       // index into buf
-    int j;                       // index into ptrn;
-    byte b = ptrn[0];            // next byte of interest
-
-    for (i = off; i < buf_len; ) {
-      j = 0;
-      while (i < buf_len && j < ptrn_len && buf[i] == ptrn[j]) {
-        i++;
-        j++;
-      }
-      if (i == buf_len || j == ptrn_len)
-        return i - j;
-      else {
-        // We have to go back a bit as there may be an overlapping
-        // match starting a bit later in buf...
-        i = i - j + 1;
-      }
-    }
-    return -1;
-  }
-
-/*
-  // for testing findBytes(byte[], int, int, byte[]) 
-  public static void main(String args[]) {
-    if (args.length < 4) {
-      System.err.println("Usage: s1 off len s2");
-      System.exit(1);
-    }
-    byte b1[] = new byte[args[0].length()];
-    byte b2[] = new byte[args[3].length()];
-    args[0].getBytes(0, args[0].length(), b1, 0);
-    args[3].getBytes(0, args[3].length(), b2, 0);
-    int off = Integer.parseInt(args[1]);
-    int len = Integer.parseInt(args[2]);
-    System.out.println("Index = " + findBytes(b1, off, len, b2));
-  }
-*/
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Attribute.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Attribute.java
deleted file mode 100644
index 3d7a4dc..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Attribute.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface Attribute {
-    
-    public String   getName();
-    public Node     getValue();
-    public void     setValue(Node arg);
-    
-    public boolean  getSpecified();
-    public void     setSpecified(boolean arg);
-    
-    public String   toString();
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/AttributeList.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/AttributeList.java
deleted file mode 100644
index 5339b89..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/AttributeList.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface AttributeList {
-    public Attribute    getAttribute(String attrName);
-    public Attribute    setAttribute(Attribute attr);
-    public Attribute    remove(String attrName);
-    public Attribute    item(int index);
-    public int          getLength();
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Comment.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Comment.java
deleted file mode 100644
index 17d5491..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Comment.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * Represents the content of comments: &lt;!-- ... --&gt;
- */
-public interface Comment extends Node {
-    public String getData();
-    public void setData(String arg);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DOM.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DOM.java
deleted file mode 100644
index 7560877..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DOM.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface DOM {
-    public Document createDocument(String type);
-    public boolean hasFeature(String feature);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Document.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Document.java
deleted file mode 100644
index 7c71b5e..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Document.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface Document extends DocumentFragment {
-    public Node             getDocumentType();
-    public void             setDocumentType(Node arg);
-    
-    public Element          getDocumentElement();
-    public void             setDocumentElement(Element arg);
-    
-    public DocumentContext  getContextInfo();
-    public void             setContextInfo(DocumentContext arg);
-    
-    public DocumentContext  createDocumentContext();
-    public Element          createElement(String tagName, AttributeList attributes);
-    public Text             createTextNode(String data);
-    public Comment          createComment(String data);
-    public PI               createPI(String name, String data);
-    public Attribute        createAttribute(String name, Node value);
-    public AttributeList    createAttributeList();
-    public NodeIterator     getElementsByTagName();
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentContext.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentContext.java
deleted file mode 100644
index 508c629..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentContext.java
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface DocumentContext {
-    
-    public Document getDocument();
-    public void setDocument(Document arg);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentFragment.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentFragment.java
deleted file mode 100644
index 3cae0af..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/DocumentFragment.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface DocumentFragment extends Node {
-    public Document getMasterDoc();
-    public void setMasterDoc(Document arg);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Element.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Element.java
deleted file mode 100644
index 8240ffa..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Element.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface Element extends Node {
-    public String           getTagName();
-    public AttributeList    attributes();
-    public void             setAttribute(Attribute newAttr);
-    public void             normalize();
-    public NodeIterator     getElementsByTagName();
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Makefile b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Makefile
deleted file mode 100644
index 946af9e..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Makefile
+++ /dev/null
@@ -1,38 +0,0 @@
-# This Makefile generated by hplb.util.jmkmf
-# Java package is org.w3c.dom
-
-.SUFFIXES: .java .class .jj
-JPACKAGE     = org.w3c.dom
-JAVA         = java
-JAVAC        = javac
-JAVACC       = java COM.sun.labs.javacc.Main
-JFLAGS       = 
-OBJS         = \
-  Attribute.class \
-  AttributeList.class \
-  Comment.class \
-  DOM.class \
-  Document.class \
-  DocumentContext.class \
-  DocumentFragment.class \
-  Element.class \
-  Node.class \
-  NodeIterator.class \
-  PI.class \
-  Text.class \
-  TreeIterator.class
-JAVADOCFLAGS = -d ../../../doc/api -author -noindex -notree
-
-all: $(OBJS)
-
-doc:
-	javadoc $(JAVADOCFLAGS)  $(JPACKAGE)
-
-.jj.java: $*.jj
-	$(JAVACC) $<
-
-.java.class: $*.java
-	$(JAVAC) $(JFLAGS) $<
-
-clean:
-	rm -f *.class *~
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Node.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Node.java
deleted file mode 100644
index 7587fce..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Node.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface Node {
-    // NodeType
-    public static final int DOCUMENT             = 1;
-    public static final int ELEMENT              = 2;
-    public static final int ATTRIBUTE            = 3;
-    public static final int PI                   = 4;
-    public static final int COMMENT              = 5;
-    public static final int TEXT                 = 6;
-    
-    public int              getNodeType();
-    public Node             getParentNode();
-    public NodeIterator     getChildNodes();
-    public boolean          hasChildNodes();
-    public Node             getFirstChild();
-    public Node             getPreviousSibling();
-    public Node             getNextSibling();
-    public Node             insertBefore(Node newChild, Node refChild);
-    public Node             replaceChild(Node newChild, Node oldChild);
-    public Node             removeChild(Node oldChild);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/NodeIterator.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/NodeIterator.java
deleted file mode 100644
index 9194fb7..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/NodeIterator.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface NodeIterator {
-    public int  getLength();
-    public Node getCurrent();
-    public Node toNext();
-    public Node toPrevious();
-    public Node toFirst();
-    public Node toLast();
-    public Node toNth(int Nth);
-    public Node toNode(Node destNode);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/PI.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/PI.java
deleted file mode 100644
index af63d9f..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/PI.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * Processing Instruction
- */
-public interface PI extends Node {
-    public String   getName();
-    public void     setName(String arg);
-    
-    public String   getData();
-    public void     setData(String arg);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Text.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Text.java
deleted file mode 100644
index 2490c9e..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/Text.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface Text extends Node {
-    public String getData();
-    public void setData(String arg);
-
-    public void append(String data);
-    public void insert(int offset, String data);
-    public void delete(int offset, int count);
-    public void replace(int offset, int count, String data);
-    public void splice(Element element, int offset, int count);
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/TreeIterator.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/TreeIterator.java
deleted file mode 100644
index bdb2339..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/w3c/dom/TreeIterator.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * $Id$
- */
-
-package hplb.org.w3c.dom;
-
-/**
- * 
- */
-public interface TreeIterator extends NodeIterator {
-    public int  numChildren();
-    public int  numPreviousSiblings();
-    public int  numNextSiblings();
-    public Node toParent();
-    public Node toPreviousSibling();
-    public Node toNextSibling();
-    public Node toFirstChild();
-    public Node toLastChild();
-    public Node toNthChild();
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/AttributeMap.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/AttributeMap.java
deleted file mode 100644
index ef71eba..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/AttributeMap.java
+++ /dev/null
@@ -1,146 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-import java.util.Enumeration;
-
-/**
-  * A map of attributes for the current element.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>This map will be valid only during the invocation of the
-  * <code>startElement</code> callback: if you need to use attribute
-  * information elsewhere, you will need to make your own copies.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.DocumentHandler#startElement
-  */
-public interface AttributeMap {
-
-
-  /**
-    * Find the names of all available attributes for an element.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return An enumeration of zero or more Strings.
-    * @see java.util.Enumeration
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public Enumeration getAttributeNames ();
-
-
-  /**
-    * Get the value of an attribute as a String.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The value as a String, or null if the attribute has no value.
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public String getValue (String attributeName);
-
-
-  /**
-    * Check if an attribute value is the name of an entity.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return true if the attribute is an entity name.
-    * @see #getEntityPublicID
-    * @see #getEntitySystemID
-    * @see #getNotationName
-    * @see #getNotationPublicID
-    * @see #getNotationSystemID
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public boolean isEntity (String aname);
-
-
-  /**
-    * Check if an attribute value is the name of a notation.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return true if the attribute is a notation name.
-    * @see #getNotationPublicID
-    * @see #getNotationSystemID
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public boolean isNotation (String aname);
-
-
-  /**
-    * Check if an attribute value is a unique identifier.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return true if the attribute is a unique identifier.
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public boolean isId (String aname);
-
-
-  /**
-    * Check if an attribute value is a reference to an ID.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return true if the attribute is a reference to an ID.
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public boolean isIdref (String aname);
-
-
-  /**
-    * Get the public identifier for an ENTITY attribute.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The public identifier or null if there is none (or if
-    *         the attribute value is not an entity name)
-    * @see #isEntity
-    */
-  public String getEntityPublicID (String aname);
-
-
-  /**
-    * Get the system identifer for an ENTITY attribute.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The system identifier or null if there is none (or if
-    *         the attribute value is not an entity name)
-    * @see #isEntity
-    */
-  public String getEntitySystemID (String aname);
-
-
-  /**
-    * Get the notation name for an ENTITY attribute.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The notation name or null if there is none (or if
-    *         the attribute value is not an entity name)
-    * @see #isEntity
-    */
-  public String getNotationName (String aname);
-
-
-  /**
-    * Get the notation public ID for an ENTITY or NOTATION attribute.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The public identifier or null if there is none (or if
-    *         the attribute value is not an entity or notation name)
-    * @see #isEntity
-    * @see #isNotation
-    */
-  public String getNotationPublicID (String aname);
-
-
-  /**
-    * Get the notation system ID for an ENTITY or NOTATION attribute.
-    * <p>This applies to the current element, and can be called only
-    * during an invocation of <code>startElement</code>.</p> 
-    * @return The system identifier or null if there is none (or if
-    *         the attribute value is not an entity or notation name)
-    * @see #isEntity
-    * @see #isNotation
-    */
-  public String getNotationSystemID (String aname);
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/DocumentHandler.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/DocumentHandler.java
deleted file mode 100644
index 13b83ec..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/DocumentHandler.java
+++ /dev/null
@@ -1,129 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * A callback interface for basic XML document events.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>This is the main handler for basic document events; it provides
-  * information on roughly the same level as the ESIS in full SGML,
-  * concentrating on logical structure rather than lexical 
-  * representation.</p>
-  * <p>If you do not set a document handler, then by default all of these
-  * events will simply be ignored.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.Parser@setDocumentHandler
-  */
-public interface DocumentHandler {
-
-
-  /**
-    * Handle the start of a document.
-    * <p>This is the first event called by a
-    * SAX-conformant parser, so you can use it to allocate and
-    * initialise new objects for the document.</p>
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void startDocument ()
-    throws Exception;
-
-
-  /**
-    * Handle the end of a document.
-    * <p>This is the last event called by a
-    * SAX-conformant parser, so you can use it to finalize and
-    * clean up objects for the document.</p>
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void endDocument ()
-    throws Exception;
-
-
-  /**
-    * Handle the document type declaration.
-    * <p>This will appear only if the XML document contains a
-    * <code>DOCTYPE</code> declaration.</p>
-    * @param name The document type name.
-    * @param publicID The public identifier of the external DTD subset
-    *                 (if any), or null.
-    * @param systemID The system identifier of the external DTD subset
-    *                 (if any), or null.
-    * @param name The document type name.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void doctype (String name, String publicID, String systemID)
-    throws Exception;
-
-
-  /**
-    * Handle the start of an element.
-    * <p>Please note that the information in the <code>attributes</code>
-    * parameter will be accurate only for the duration of this handler:
-    * if you need to use the information elsewhere, you should copy 
-    * it.</p>
-    * @param name The element type name.
-    * @param attributes The available attributes.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void startElement (String name, AttributeMap attributes)
-    throws Exception;
-
-
-  /**
-    * Handle the end of an element.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void endElement (String name)
-    throws Exception;
-
-
-  /**
-    * Handle significant character data.
-    * <p>Please note that the contents of the array will be
-    * accurate only for the duration of this handler: if you need to
-    * use them elsewhere, you should make your own copy, possible
-    * by constructing a string:</p>
-    * <pre>
-    * String data = new String(ch, start, length);
-    * </pre>
-    * @param ch An array of characters.
-    * @param start The starting position in the array.
-    * @param length The number of characters to use in the array.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void characters (char ch[], int start, int length)
-    throws Exception;
-
-
-  /**
-    * Handle ignorable whitespace.
-    * <p>Please note that the contents of the array will be
-    * accurate only for the duration of this handler: if you need to
-    * use them elsewhere, you should make your own copy, possible
-    * by constructing a string:</p>
-    * <pre>
-    * String whitespace = new String(ch, start, length);
-    * </pre>
-    * @param ch An array of whitespace characters.
-    * @param start The starting position in the array.
-    * @param length The number of characters to use in the array.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void ignorable (char ch[], int start, int length)
-    throws Exception;
-
-
-  /**
-    * Handle a processing instruction.
-    * <p>XML processing instructions have two parts: a target, which
-    * is a name, followed optionally by data.</p>
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void processingInstruction (String name, String remainder)
-    throws Exception;
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/EntityHandler.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/EntityHandler.java
deleted file mode 100644
index 93faa3d..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/EntityHandler.java
+++ /dev/null
@@ -1,48 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * A callback interface for basic XML entity-related events.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>If you do not set an entity handler, then a parser will
-  * resolve all entities to the suggested system ID, and will take no
-  * action for entity changes.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.Parser#setEntityHandler
-  */
-public interface EntityHandler {
-
-
-  /**
-    * Resolve a system identifier.
-    * <p>Before loading any entity (including the document entity),
-    * SAX parsers will filter the system identifier through this
-    * callback, and you can return a different system identifier if you
-    * wish, or null to prevent the parser from reading any entity.</p>
-    * @param ename The name of the entity, "[document]" for the
-    *              document entity, or "[external DTD]" for the external
-    *              DTD subset.
-    * @param publicID The public identifier, or null if there is none.
-    * @param systemID The system identifier suggested in the XML document.
-    * @return A system identifier, or null to skip the entity.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public String resolveEntity (String ename, String publicID, String systemID)
-    throws Exception;
-
-  /**
-    * Handle a change in the current entity.
-    * <p>Whenever the parser switches the entity (URI) that it is reading
-    * from, it will call this handler to report the change.</p>
-    * @param systemID The URI of the new entity.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void changeEntity (String systemID)
-    throws Exception;
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/ErrorHandler.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/ErrorHandler.java
deleted file mode 100644
index 4c83970..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/ErrorHandler.java
+++ /dev/null
@@ -1,52 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * A callback interface for basic XML error events.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>If you do not set an error handler, then a parser will report
-  * warnings to <code>System.err</code>, and will throw an (unspecified)
-  * exception for fata errors.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.Parser#setErrorHandler
-  */
-public interface ErrorHandler {
-
-  /**
-    * Handle a non-fatal warning.
-    * <p>A SAX parser will use this callback to report a condition
-    * that is not serious enough to stop the parse (though you may
-    * still stop the parse if you wish).</p>
-    * @param message The warning message.
-    * @param systemID The URI of the entity that caused the warning, or
-    *                 null if not available.
-    * @param line The line number in the entity, or -1 if not available.
-    * @param column The column number in the entity, or -1 if not available.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void warning (String message, String systemID, int line, int column)
-    throws java.lang.Exception;
-
-  /**
-    * Handle a fatal error.
-    * <p>A SAX parser will use this callback to report a condition
-    * that is serious enough to invalidate the parse, and may not
-    * report all (or any) significant parse events after this.  Ordinarily,
-    * you should stop immediately with an exception, but you can continue
-    * to try to collect more errors if you wish.</p>
-    * @param message The error message.
-    * @param systemID The URI of the entity that caused the error, or
-    *                 null if not available.
-    * @param line The line number in the entity, or -1 if not available.
-    * @param column The column number in the entity, or -1 if not available.
-    * @exception java.lang.Exception You may throw any exception.
-    */
-  public void fatal (String message, String systemID, int line, int column)
-    throws Exception;
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/HandlerBase.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/HandlerBase.java
deleted file mode 100644
index 1bf3f2a..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/HandlerBase.java
+++ /dev/null
@@ -1,201 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * A simple base class for deriving SAX event handlers.
-  * <p><em>This class is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>This class implements the default behaviour when no handler
-  * is specified (though parsers are not actually required to use
-  * this class).</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.XmlException
-  * @see hplb.org.xml.sax.EntityHandler
-  * @see hplb.org.xml.sax.DocumentHandler
-  * @see hplb.org.xml.sax.ErrorHandler
-  */
-public class HandlerBase
-  implements EntityHandler, DocumentHandler, ErrorHandler 
-{
-
-
-  //////////////////////////////////////////////////////////////////////
-  // Implementation of hplb.org.xml.sax.EntityHandler.
-  //////////////////////////////////////////////////////////////////////
-
-  /**
-    * Resolve an external entity.
-    * <p>By default, simply return the system ID supplied.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.EntityHandler#resolveEntity
-    */
-  public String resolveEntity (String ename, String publicID, String systemID)
-    throws Exception
-  {
-    return systemID;
-  }
-
-
-  /**
-    * Handle an entity-change event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.EntityHandler#changeEntity
-    */
-  public void changeEntity (String systemID)
-    throws Exception
-  {
-  }
-
-
-
-  //////////////////////////////////////////////////////////////////////
-  // Implementation of hplb.org.xml.sax.DocumentHandler.
-  //////////////////////////////////////////////////////////////////////
-
-
-  /**
-    * Handle a start document event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#startDocument
-    */
-  public void startDocument ()
-    throws Exception
-  {}
-
-
-  /**
-    * Handle a end document event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#endDocument
-    */
-  public void endDocument ()
-    throws Exception
-  {}
-
-  
-  /**
-    * Handle a document type declaration event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#doctype
-    */
-  public void doctype (String name, String publicID, String systemID)
-    throws Exception
-  {}
-  
-
-  /**
-    * Handle a start element event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#startElement
-    */
-  public void startElement (String name, AttributeMap attributes) 
-    throws Exception
-  {}
-  
-
-  /**
-    * Handle an end element event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#endElement
-    */
-  public void endElement (String name) 
-    throws Exception
-  {}
-  
-
-  /**
-    * Handle a character data event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#characters
-    */
-  public void characters (char ch[], int start, int length) 
-    throws Exception
-  {}
-
-
-  /**
-    * Handle an ignorable whitespace event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#ignorable
-    */
-  public void ignorable (char ch[], int start, int length) 
-    throws Exception
-  {}
-
-
-  /**
-    * Handle a processing instruction event.
-    * <p>By default, do nothing.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.DocumentHandler#processingInstruction
-    */
-  public void processingInstruction (String name, String remainder) 
-    throws Exception
-  {}
-
-
-
-  //////////////////////////////////////////////////////////////////////
-  // Implementation of ErrorHandler.
-  //////////////////////////////////////////////////////////////////////
-
-
-  /**
-    * Handle a non-fatal error.
-    * <p>By default, report the warning to System.err.</p>
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.ErrorHandler#warning
-    */
-  public void warning (String message, String systemID, int line, int column)
-    throws Exception
-  {
-    System.err.println("Warning (" +
-		       systemID +
-		       ',' +
-		       line +
-		       ',' +
-		       column +
-		       "): " +
-		       message);
-  }
-
-
-  /**
-    * Handle a fatal error.
-    * <p>By default, throw an instance of XmlException.</p>
-    * @exception hplb.org.xml.sax.XmlException A fatal parsing error
-    *                has been found.
-    * @exception java.lang.Exception When you override this method,
-    *                                you may throw any exception.
-    * @see hplb.org.xml.sax.ErrorHandler#fatal
-    */
-  public void fatal (String message, String systemID, int line, int column)
-    throws XmlException, Exception
-  {
-    throw new XmlException(message, systemID, line, column);
-  }
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Makefile b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Makefile
deleted file mode 100644
index e2ad29c..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Makefile
+++ /dev/null
@@ -1,32 +0,0 @@
-# This Makefile generated by jmkmf
-# Java package is org.xml.sax
-
-.SUFFIXES: .java .class .jj
-JPACKAGE     = org.xml.sax
-JAVA         = java
-JAVAC        = javac
-JAVACC       = java COM.sun.labs.javacc.Main
-JFLAGS       = 
-OBJS         = \
-  AttributeMap.class \
-  DocumentHandler.class \
-  EntityHandler.class \
-  ErrorHandler.class \
-  HandlerBase.class \
-  Parser.class \
-  XmlException.class 
-JAVADOCFLAGS = -d ../../../doc/api -author -noindex -notree
-
-all: $(OBJS)
-
-doc:
-	javadoc $(JAVADOCFLAGS) $(JPACKAGE)
-
-.jj.java: org.xml.sax.jj
-	$(JAVACC) $<
-
-.java.class: $*.java
-	$(JAVAC) $(JFLAGS) $<
-
-clean:
-	rm -f *.class *~
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Parser.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Parser.java
deleted file mode 100644
index 3033ef9..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/Parser.java
+++ /dev/null
@@ -1,71 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * A standard interface for event-driven XML parsers.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>All SAX-conformant XML parsers (or their front-end SAX drivers)
-  * <em>must</em> implement this interface, together with a zero-argument
-  * constructor.</p>
-  * <p>You can plug three different kinds of callback interfaces into
-  * a basic SAX parser: one for entity handling, one for basic document
-  * events, and one for error reporting.  It is not an error to start
-  * a parse without setting any handlers.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  */
-public interface Parser {
-
-
-  /**
-    * Register the handler for basic entity events.
-    * <p>If you begin a parse without setting an entity handler,
-    * the parser will by default resolve all entities to their
-    * default system IDs.</p>
-    * @param handler An object to receive callbacks for events.
-    * @see hplb.org.xml.sax.EntityHandler
-    */
-  public void setEntityHandler (EntityHandler handler);
-
-
-  /**
-    * Register the handler for basic document events.
-    * <p>You may begin the parse without setting a handler, but
-    * in that case no document events will be reported.</p>
-    * @param handler An object to receive callbacks for events.
-    * @see hplb.org.xml.sax.DocumentHandler
-    */
-  public void setDocumentHandler (DocumentHandler handler);
-
-
-  /**
-    * Register the handler for errors and warnings.
-    * <p>If you begin a parse without setting an error handlers,
-    * warnings will be printed to System.err, and errors will
-    * throw an unspecified exception.</p>
-    * @param handler An object to receive callbacks for errors.
-    * @see hplb.org.xml.sax.ErrorHandler
-    */
-  public void setErrorHandler (ErrorHandler handler);
-
-
-  /**
-    * Parse an XML document.
-    * <p>Nothing exciting will happen unless you have set handlers.</p>
-    * @param publicID The public identifier for the document, or null
-    *                 if none is available.
-    * @param systemID The system identifier (URI) for the document.
-    * @exception java.lang.Exception This method may throw any exception, 
-    *            but the parser itself
-    *            will throw only exceptions derived from java.io.IOException;
-    *            anything else will come from your handlers.
-    * @see #setEntityHandler
-    * @see #setDocumentHandler
-    * @see #setErrorHandler
-    */
-  void parse (String publicID, String systemID) throws java.lang.Exception;
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/XmlException.java b/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/XmlException.java
deleted file mode 100644
index f7d4c24..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/org/xml/sax/XmlException.java
+++ /dev/null
@@ -1,73 +0,0 @@
-// $Id$
-
-package hplb.org.xml.sax;
-
-
-/**
-  * An exception for reporting XML parsing errors.
-  * <p><em>This interface is part of the Java implementation of SAX, 
-  * the Simple API for XML.  It is free for both commercial and 
-  * non-commercial use, and is distributed with no warrantee, real 
-  * or implied.</em></p>
-  * <p>This exception is not a required part of SAX, and it is not
-  * referenced in any of the core interfaces.  It is used only in
-  * the optional HandlerBase base class, as a means of signalling
-  * parsing errors.</p>
-  * @author David Megginson, Microstar Software Ltd.
-  * @see hplb.org.xml.sax.HandlerBase#fatal
-  */
-public class XmlException extends Exception {
-
-
-  /**
-    * Construct a new exception with information about the location.
-    */
-  public XmlException (String message, String systemID, int line, int column)
-  {
-    super(message);
-    this.systemID = systemID;
-    this.line = line;
-    this.column = column;
-  }
-
-
-  /**
-    * Find the system identifier (URI) where the error occurred.
-    * @return A string representing the URI, or null if none is available.
-    */
-  public String getSystemID ()
-  {
-    return systemID;
-  }
-
-
-  /**
-    * Find the line number where the error occurred.
-    * @return The line number, or -1 if none is available.
-    */
-  public int getLine ()
-  {
-    return line;
-  }
-
-
-  /**
-    * Find the column number (line offset) where the error occurred.
-    * @return The column number, or -1 if none is available.
-    */
-  public int getColumn ()
-  {
-    return column;
-  }
-
-
-
-  //
-  // Internal state.
-  //
-
-  private String systemID;
-  private int line;
-  private int column;
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Atom.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Atom.java
deleted file mode 100644
index 097b85d..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Atom.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import java.util.Hashtable;
-
-/**
- * This class is responsible for maintaining strings as <em>atoms</em>,
- * i.e. if two strings returned by getAtom() are equal in the sense of
- * String.equal() then they are in fact the same Object. This is used to
- * "intern" element and attribute names which can then be compared using
- * the more efficient reference equality, a la "s1==s2".
- * 
- * @author  Anders Kristensen
- */
-public final class Atom {
-  /** Holds atoms: element names (GIs), and attribute names. */
-  private static final Hashtable atoms = new Hashtable();
-  
-    /**
-     * Return an atom corresponding to the argument.
-     */
-    public static String getAtom(String s) {
-        synchronized (atoms) {
-            String a = (String) atoms.get(s);
-            if (a == null) {
-                atoms.put(s, s);
-                a = s;
-            }
-        return a;
-        }
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrImpl.java
deleted file mode 100644
index 4e84b2f..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrImpl.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * 
- * @author  Anders Kristensen
- */
-public final class AttrImpl implements Attribute {
-    protected String name;
-    protected Node value;
-    protected boolean specified;
-    
-    public AttrImpl(String name, String value) {
-        this(name, new TextImpl(Node.TEXT, value), true);
-    }
-    
-    public AttrImpl(String name, Node value, boolean specified) {
-        this.name = name;
-        this.value = value;
-        this.specified = specified;
-    }
-    
-    public String getName() {
-        return name;
-    }
-    
-    public Node getValue() {
-        return value;
-    }
-    
-    public void setValue(Node arg) {
-        value = arg;
-    }
-    
-    public boolean getSpecified() {
-        return specified;
-    }
-    
-    public void setSpecified(boolean arg) {
-        specified = arg;
-    }
-    
-    public String toString() {
-        return value.toString();
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrListImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrListImpl.java
deleted file mode 100644
index 4296267..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/AttrListImpl.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * An ordered Dictionary. keys() and elements() returns Enumerations
- * which enumerate over elements in the order they were inserted.
- * Elements are stored linearly. Operations put(), get(), and remove()
- * are linear in the number of elements in the Dictionary.
- * 
- * <p>Allows direct access to elements (as an alternative to using
- * Enumerators) for speed.
- * 
- * <p>Can function as a <em>bag</em>, i.e. it can be created with a mode
- * which allows the same key to map to multiple entries. In this case 
- * operations get() and remove() operate on the <em>first</em> pair in
- * the map. Hence to get hold of all values associated with a key it is
- * necessary to use the direct access to underlying arrays.
- * 
- * @author  Anders Kristensen
- */
-public class AttrListImpl implements AttributeList {
-    protected Attribute[] elms;
-    
-    /**
-     * Number of elements. The elements are held at indices 0 to n in elms.
-     */
-    protected int n = 0;
-    
-    public AttrListImpl() {
-        this(2);
-    }
-    
-    /**
-     * Create an AttrListImpl with the specififed initial capacity.
-     */
-    public AttrListImpl(int size) {
-        if (size <= 0) throw new IllegalArgumentException(
-                "Initial size must be at least 1");
-        elms = new Attribute[size];
-    }
-    
-    /**
-     * Returns the value to which the key is mapped in this dictionary. 
-     */
-    public synchronized Attribute getAttribute(String attrName) {
-        int i = getIndex(attrName);
-        return (i < 0 ? null : elms[i]);
-    }
-    
-    protected int getIndex(String name) {
-        for (int i = 0; i < n; i++) {
-            if (elms[i].getName().equals(name)) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    // XXX: what if attrName != attr.getName()???
-    public synchronized Attribute setAttribute(Attribute attr) {
-        int i = getIndex(attr.getName());
-        if (i >= 0) {
-            Attribute old = elms[i];
-            elms[i] = attr;
-            return old;
-        }
-        
-        int len = elms.length;
-        if (len == n) {
-            // double size of key,elms arrays
-            AttrImpl[] e;
-            e = new AttrImpl[len * 2];
-            System.arraycopy(elms, 0, e, 0, len);
-            elms = e;
-        }
-        elms[n] = attr;
-        n++;
-        return null;
-    }
-    
-    public synchronized Attribute remove(String attrName) {
-        int i = getIndex(attrName);
-        if (i < 0) return null;
-        Attribute val = elms[i];
-        System.arraycopy(elms, i+1, elms, i, n-i-1);
-        n--;
-        return val;
-    }
-    
-    public synchronized Attribute item(int index) {
-        if (index < 0 || index >= n) {
-            throw new IndexOutOfBoundsException(""+index);
-        }
-        return elms[index];
-    }
-    
-    /** Returns the number of keys in this dictionary. */
-    public synchronized int getLength() {
-        return n;
-    }
-    
-    public synchronized String toString() {
-        StringBuffer sb = new StringBuffer();
-        boolean f = true;
-        int n = getLength();
-        
-        sb.append("{ ");
-        for (int i = 0; i < n; i++) {
-            if (f) { f = false; }
-            else { sb.append(", "); }
-            Attribute attr = item(i);
-            sb.append(attr.getName() + '=' + attr);
-        }
-        sb.append(" }");
-        return sb.toString();
-    }
-    
-    /**/
-    // for testing
-    public static void main(String[] args) throws Exception {
-        AttrListImpl alist;
-        Attribute attr;
-        java.io.BufferedReader r;
-        java.util.StringTokenizer tok;
-        String op;
-        
-        if (args.length > 1) {
-            alist = new AttrListImpl(Integer.parseInt(args[0]));
-        } else {
-            alist = new AttrListImpl();
-        }
-        
-        System.out.println(
-            "Enter operations... op's are one of\n"+
-            "put <key> <val>\n"+
-            "get <key>\n"+
-            "rem <key>\n"+
-            "size\n"+
-            "quit\n");
-        
-        r = new java.io.BufferedReader(
-                new java.io.InputStreamReader(System.in)); 
-        while (true) {
-            System.out.print("doyourworst> ");
-            tok = new java.util.StringTokenizer(r.readLine());
-            op = tok.nextToken();
-            if ("put".equals(op)) {
-                attr = new AttrImpl(tok.nextToken(), tok.nextToken());
-                System.out.println("Value: " +
-                        alist.setAttribute(attr));
-            } else if ("get".equals(op)) {
-                attr = alist.getAttribute(tok.nextToken());
-                System.out.println("Value: " +
-                        (attr == null ? "No such element" : attr.toString()));
-            } else if ("rem".equals(op)) {
-                attr = alist.remove(tok.nextToken());
-                System.out.println("Value: " + attr);
-            } else if (op.startsWith("s")) {
-                System.out.println("Size: " + alist.getLength());
-            } else if (op.startsWith("q")) {
-                break;
-            } else {
-                System.out.println("Unrecognized op: " + op);
-            }
-            
-            System.out.println("AttributeList: " + alist);
-            System.out.println("Size: " + alist.getLength());
-            System.out.println();
-        }
-    }
-    //*/
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/CharBuffer.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/CharBuffer.java
deleted file mode 100644
index 5eee304..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/CharBuffer.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * $Id$
- *
- * Copyright 1997 Hewlett-Packard Company
- *
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-/**
- * A java.io.CharArrayWriter with the additional property that users can get
- * to the actual underlying storage. Hence it's very fast (and dangerous).
- * @author      Anders Kristensen
- */
-public final class CharBuffer extends java.io.CharArrayWriter {
-    public CharBuffer() {
-        super();
-    }
-
-    public CharBuffer(int size) {
-        super(size);
-    }
-
-    // use only to *decrement* size
-    public void setLength(int size) {
-        synchronized (lock) {
-            if (size < count) count = size;
-	    }
-	}
-
-    public char[] getCharArray() {
-	    synchronized (lock) {
-	        return buf;
-	    }
-    }
-
-    public int getLength()
-    {
-        return count;
-    }
-
-
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DOMImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DOMImpl.java
deleted file mode 100644
index 5645c2c..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DOMImpl.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.DOM;
-import hplb.org.w3c.dom.Document;
-
-public class DOMImpl implements DOM {
-    public Document createDocument(String type) {
-        return new DocumentImpl();
-    }
-    public boolean hasFeature(String feature) {
-        return false;
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocContextImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocContextImpl.java
deleted file mode 100644
index fc2db0c..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocContextImpl.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-public class DocContextImpl implements DocumentContext {
-    Document doc;
-    
-    public Document getDocument() {
-        return doc;
-    }
-    
-    public void setDocument(Document arg) {
-        doc = arg;
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocumentImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocumentImpl.java
deleted file mode 100644
index 54badf6..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/DocumentImpl.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * 
- */
-public class DocumentImpl extends NodeImpl implements Document {
-    DocumentContext context;
-    Document        masterDoc = this;
-    Node            type;
-    Element         rootNode;
-    
-    public DocumentImpl() {
-        super(Node.DOCUMENT);
-    }
-    
-    public Document getMasterDoc() {
-        return masterDoc;
-    }
-    public void setMasterDoc(Document arg) {
-        masterDoc = arg;
-    }
-    
-    public Node getDocumentType() {
-        return type;
-    }
-    public void setDocumentType(Node arg) {
-        type = arg;
-    }
-    
-    public Element getDocumentElement() {
-        return rootNode;
-    }
-    public void setDocumentElement(Element arg) {
-        rootNode = arg;
-    }
-    
-    public DocumentContext getContextInfo() {
-        return context;
-    }
-    public void setContextInfo(DocumentContext arg) {
-        context = arg;
-    }
-    
-    public Document createDocument() {
-        return new DocumentImpl();
-    }
-    
-    public DocumentContext createDocumentContext() {
-        return new DocContextImpl();
-    }
-    
-    public Element createElement(String tagName, AttributeList attributes) {
-        return new ElementImpl(tagName, attributes);
-    }
-    
-    public Text createTextNode(String data) {
-        return new TextImpl(Node.TEXT, data);
-    }
-    
-    public Comment createComment(String data) {
-        return new TextImpl(Node.COMMENT, data);
-    }
-    
-    public PI createPI(String name, String data) {
-        PI pi = new TextImpl(Node.PI, data);
-        pi.setName(name);
-        return pi;
-    }
-    
-    public Attribute createAttribute(String name, Node value) {
-        return new AttrImpl(name, value, true);
-    }
-    
-    public AttributeList createAttributeList() {
-        return new AttrListImpl();
-    }
-    
-    public NodeIterator getElementsByTagName() {
-        throw new NullPointerException("NOT IMPLEMENTED");
-    }
-    
-    public String toString() {
-        return "ROOT";
-        /*
-        if (children == null) return "";
-        StringBuffer sb = new StringBuffer();
-        int len = children.getLength();
-        for (int i = 0; i < len; i++) {
-            System.out.println(children.item(i));
-        }
-        return sb.toString();
-        */
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/ElementImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/ElementImpl.java
deleted file mode 100644
index 98b011c..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/ElementImpl.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * 
- * @author  Anders Kristensen
- */
-public class ElementImpl extends NodeImpl implements Element {
-    protected String tagName;
-    protected AttributeList attrs;  // Note: Parser ensures this wont be null
-    
-    public ElementImpl(String tagName, AttributeList attributes) {
-        super(Node.ELEMENT);
-        this.tagName = tagName;
-        attrs = attributes;
-    }
-    
-    public String getTagName() {
-        return tagName;
-    }
-    
-    public AttributeList attributes() {
-        return attrs;
-    }
-    
-    public void setAttribute(Attribute newAttr) {
-        if (attrs == null) attrs = new AttrListImpl();
-        attrs.setAttribute(newAttr);
-    }
-    
-    public void normalize() {}
-    
-    public NodeIterator getElementsByTagName() {
-        throw new IllegalArgumentException(
-            "Why wasn't this method defined by the DOM WG to take an arg???");
-    }
-    
-    public String toString() {
-        boolean empty = (children == null || children.getLength() == 0);
-        return "<" + tagName + " "
-               + (attrs != null ? attrs.toString() : "{}")
-               + (empty ? " />" : ">");
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/EntityManager.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/EntityManager.java
deleted file mode 100644
index c88b0e2..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/EntityManager.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * $Id$
- *
- * Copyright 1997 Hewlett-Packard Company
- *
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-import java.util.Hashtable;
-import java.io.*;
-
-/**
- * A very simple entity manager.
- * @author  Anders Kristensen
- */
-public class EntityManager {
-    protected Hashtable entities = new Hashtable();
-    private hplb.org.xml.sax.Parser tok;
-
-    public EntityManager(hplb.org.xml.sax.Parser tok) {
-        this.tok = tok;
-        entities.put("amp",   "&");
-        entities.put("lt",    "<");
-        entities.put("gt",    ">");
-        entities.put("apos",  "'");
-        entities.put("quot", "\"");
-    }
-
-    /**
-     * Finds entitiy and character references in the provided char array
-     * and decodes them. The operation is destructive, i.e. the encoded
-     * string replaces the original - this is atrightforward since the
-     * new string can only get shorter.
-     */
-    public final CharBuffer entityDecode(CharBuffer buffer) throws Exception {
-        char[] buf = buffer.getCharArray();  // avoids method calls
-        int len = buffer.size();
-
-        // not fastest but certainly simplest:
-        if (indexOf(buf, '&', 0, len) == -1) return buffer;
-        CharBuffer newbuf = new CharBuffer(len);
-
-        for (int start = 0; ; ) {
-            int x = indexOf(buf, '&', start, len);
-            if (x == -1) {
-                newbuf.write(buf, start, len - start);
-                return newbuf;
-            } else {
-                newbuf.write(buf, start, x - start);
-                start = x+1;
-                x = indexOf(buf, ';', start, len);
-                if (x == -1) {
-                    //tok.warning("Entity reference not semicolon terminated");
-                    newbuf.write('&');
-                    //break; //???????????
-                } else {
-                    try {
-                        writeEntityDef(buf, start, x-start, newbuf);
-                        start = x+1;
-                    } catch (Exception ex) {
-                        //tok.warning("Bad entity reference");
-                    }
-                }
-            }
-        }
-    }
-
-    // character references are rare enough that we don't care about
-    // creating a String object for them unnecessarily...
-    public void writeEntityDef(char[] buf, int off, int len, Writer out)
-        throws Exception, IOException, NumberFormatException
-    {
-        Integer ch;
-        //System.out.println("Entity: " + new String(buf, off, len) +" "+off+" "+len);
-
-        if (buf[off] == '#') {  // character reference
-            off++;
-            len--;
-            if (buf[off] == 'x' || buf[off] == 'X') {
-                ch = Integer.valueOf(new String(buf, off+1, len-1), 16);
-            } else {
-                ch = Integer.valueOf(new String(buf, off, len));
-            }
-            out.write(ch.intValue());
-         } else {
-            String ent = new String(buf, off, len);
-            String val = (String) entities.get(ent);
-            if (val != null) {
-                out.write(val);
-            } else {
-                out.write("&" + ent + ";");
-                //tok.warning("unknown entity reference: " + ent);
-            }
-        }
-    }
-
-    public String defTextEntity(String entity, String value) {
-        return (String) entities.put(entity, value);
-    }
-
-    /**
-     * Returns the index within this String of the first occurrence of the
-     * specified character, starting the search at fromIndex. This method
-     * returns -1 if the character is not found.
-     * @params buf        the buffer to search
-     * @params ch         the character to search for
-     * @params from       the index to start the search from
-     * @params to         the highest possible index returned plus 1
-     * @throws IndexOutOfBoundsException  if index out of bounds...
-     */
-    public static final int indexOf(char[] buf, int ch, int from, int to) {
-        int i;
-        for (i = from; i < to && buf[i] != ch; i++)
-            ;  // do nothing
-        if (i < to) return i;
-        else return -1;
-    }
-
-    // FOR TESTING
-    /*
-    public static void main(String[] args) throws Exception {
-        Parser tok = new Parser();
-        tst.xml.TokArgs.args(args, tok);
-        CharBuffer buf1 = new CharBuffer();
-        buf1.write(args[0]);
-        CharBuffer buf2 = tok.entMngr.entityDecode(buf1);
-
-        System.out.println("Changed: " + (buf1 != buf2));
-        System.out.println("Result: [" + buf2 + "]");
-    }
-    */
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HTML.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HTML.java
deleted file mode 100644
index 7884315..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HTML.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-/**
- * Parser customizations for correctly parsing HTML.
- * Defines a set of empty elements (&lt;hr&gt;, &lt;br&gt;, etc.)
- * and for some elements it defines which other start tags
- * implicitly ends them. As an example, an &lt;li&gt; element within
- * a &lt;ul&gt; list is terminated by either a &lt;/ul&gt; end tag
- * or another &lt;li&gt; start tag.
- *
- * @author  Anders Kristensen
- */
-public class HTML {
-    public static String A          = a("a");//
-    public static String ACRONYM    = a("acronym");//
-    public static String ADDRESS    = a("address");
-    public static String APPLET     = a("applet");//
-    public static String AREA       = a("area");
-    public static String B          = a("b");//
-    public static String BASE       = a("base");
-    public static String BASEFONT   = a("basefont");//
-    public static String BDO        = a("bdo");//
-    public static String BIG        = a("big");//
-    public static String BLOCKQUOTE = a("blockquote");
-    public static String BODY       = a("body");//
-    public static String BR         = a("br");
-    public static String BUTTON     = a("button");//
-    public static String CAPTION    = a("caption");//
-    public static String CENTER     = a("center");
-    public static String CITE       = a("cite");//
-    public static String CODE       = a("code");//
-    public static String COL        = a("col");
-    public static String COLGROUP   = a("colgroup");//
-    public static String DD         = a("dd");
-    public static String DEL        = a("del");//
-    public static String DFN        = a("dfn");//
-    public static String DIR        = a("dir");
-    public static String DIV        = a("div");
-    public static String DL         = a("dl");
-    public static String DT         = a("dt");
-    public static String EM         = a("em");//
-    public static String FIELDSET   = a("fieldset");
-    public static String FONT       = a("font");//
-    public static String FORM       = a("form");
-    public static String FRAME      = a("frame");
-    public static String FRAMESET   = a("frameset");//
-    public static String H1         = a("h1");
-    public static String H2         = a("h2");
-    public static String H3         = a("h3");
-    public static String H4         = a("h4");
-    public static String H5         = a("h5");
-    public static String H6         = a("h6");
-    public static String HEAD       = a("head");
-    public static String HR         = a("hr");
-    public static String HTML       = a("html");
-    public static String I          = a("i");//
-    public static String IFRAME     = a("iframe");//
-    public static String IMG        = a("img");
-    public static String INPUT      = a("input");
-    public static String INS        = a("ins");//
-    public static String ISINDEX    = a("isindex");//
-    public static String KBD        = a("kbd");//
-    public static String LABEL      = a("label");//
-    public static String LEGEND     = a("legend");//
-    public static String LI         = a("li");
-    public static String LINK       = a("link");
-    public static String MAP        = a("map");//
-    public static String MENU       = a("menu");
-    public static String META       = a("meta");
-    public static String NOFRAMES   = a("noframes");//
-    public static String NOSCRIPT   = a("noscript");
-    public static String OBJECT     = a("object");//
-    public static String OL         = a("ol");
-    public static String OPTION     = a("option");//
-    public static String P          = a("p");
-    public static String PARAM      = a("param");
-    public static String PRE        = a("pre");
-    public static String Q          = a("q");//
-    public static String S          = a("s");//
-    public static String SAMP       = a("samp");//
-    public static String SCRIPT     = a("script");//
-    public static String SELECT     = a("select");//
-    public static String SMALL      = a("small");//
-    public static String SPAN       = a("span");//
-    public static String STRIKE     = a("strike");//
-    public static String STRONG     = a("strong");//
-    public static String STYLE      = a("style");//
-    public static String SUB        = a("sub");//
-    public static String SUP        = a("sup");//
-    public static String TABLE      = a("table");
-    public static String TBODY      = a("tbody");//
-    public static String TD         = a("td");//
-    public static String TEXTAREA   = a("textarea");//
-    public static String TFOOT      = a("tfoot");//
-    public static String TH         = a("th");//
-    public static String THEAD      = a("thead");//
-    public static String TITLE      = a("title");//
-    public static String TR         = a("tr");
-    public static String TT         = a("tt");//
-    public static String U          = a("u");//
-    public static String UL         = a("ul");
-    public static String VAR        = a("var");//
-    
-    private static String a(String s) { return Atom.getAtom(s); }
-    
-    /** The full set of HTML4.0 element names. */
-    public static final String[] elements = {
-        A, ACRONYM, ADDRESS, APPLET, AREA , B, BASE, BASEFONT, BDO, BIG,
-        BLOCKQUOTE, BODY, BR, BUTTON, CAPTION, CENTER, CITE, CODE, COL,
-        COLGROUP, DD, DEL, DFN, DIR, DIV, DL, DT, EM, FIELDSET, FONT, FORM,
-        FRAME, FRAMESET, H1, H2, H3, H4, H5, H6, HEAD, HR, HTML, I, IFRAME,
-        IMG, INPUT, INS, ISINDEX, KBD, LABEL, LEGEND, LI, LINK, MAP, MENU,
-        META, NOFRAMES, NOSCRIPT, OBJECT, OL, OPTION, P, PARAM, PRE, Q, S,
-        SAMP, SCRIPT, SELECT, SMALL, SPAN, STRIKE, STRONG, STYLE, SUB, SUP,
-        TABLE, TBODY, TD, TEXTAREA, TFOOT, TH, THEAD, TITLE, TR, TT, U, UL, VAR
-    };
-    
-    // FIXME: the parser kindof supports optional end tags but not
-    //        at all optional start tags (eg <html>, <head>)
-    // FIXME: add support for HTML entities not in HTML (lots of those)
-
-    // FIXME: this list probably not complete!!!
-    /** Empty elements in HTML4.0: <em>br</em>, <em>img</em>, etc. */
-    public static final String[] emptyElms = {
-        AREA, BASE, BR, COL, FRAME, HR, IMG, LINK, META, PARAM };
-
-    public static final String[] li_terminators = { LI };
-    public static final String[] dt_terminators = { DT, DD };
-    public static final String[] dd_terminators = dt_terminators;
-    // <head> terminators: <body> and just about everything else
-
-    /** Block-level HTML4.0 elements. */
-    public static final String[] block_level = {
-        ADDRESS, BLOCKQUOTE, CENTER, DIR, DIV, DL, FIELDSET, FORM,
-        H1, H2, H3, H4, H5, H6, HR, MENU, NOSCRIPT, OL, P, PRE, TABLE, UL };
-
-    // The P element can contain any *inline* markup - hence it is
-    // terminated by any *blocklevel* markup (incl. other P elements):
-    public static final String[] p_terminators = block_level;
-
-    // elements which cannot contain PCDATA don't care about whitespace
-    // FIXME: ignore_ws probably not complete  [don't include empty elements]
-    public static final String[] ignore_ws = {
-        HEAD, HTML, OL, MENU, TABLE, TR , UL };
-    
-    public static void applyHacks(Tokenizer tok) {
-        for (int i = 0; i < elements.length; i++) {
-            tok.ignoreCase(elements[i]);
-        }
-        
-        EntityManager entMngr = tok.entMngr;
-        
-        // standard SGML entities
-        entMngr.defTextEntity("amp", "&");    // ampersand
-        entMngr.defTextEntity("gt", ">");     // greater than
-        entMngr.defTextEntity("lt", "<");     // less than
-        entMngr.defTextEntity("quot", "\"");  // double quote
-
-        // PUBLIC ISO 8879-1986//    entities Added Latin 1//EN//HTML
-        entMngr.defTextEntity("AElig",  "\u00c6");   // capital AE diphthong (ligature)
-        entMngr.defTextEntity("Aacute", "\u00c1");  // capital A, acute accent
-        entMngr.defTextEntity("Acirc",  "\u00c2");   // capital A, circumflex accent
-        entMngr.defTextEntity("Agrave", "\u00c0");  // capital A, grave accent
-        entMngr.defTextEntity("Aring",  "\u00c5");   // capital A, ring
-        entMngr.defTextEntity("Atilde", "\u00c3");  // capital A, tilde
-        entMngr.defTextEntity("Auml",   "\u00c4");    // capital A, dieresis or umlaut mark
-        entMngr.defTextEntity("Ccedil", "\u00c7");  // capital C, cedilla
-        entMngr.defTextEntity("ETH",    "\u00d0");     // capital Eth, Icelandic
-        entMngr.defTextEntity("Eacute", "\u00c9");  // capital E, acute accent
-        entMngr.defTextEntity("Ecirc",  "\u00ca");   // capital E, circumflex accent
-        entMngr.defTextEntity("Egrave", "\u00c8");  // capital E, grave accent
-        entMngr.defTextEntity("Euml",   "\u00cb");    // capital E, dieresis or umlaut mark
-        entMngr.defTextEntity("Iacute", "\u00cd");  // capital I, acute accent
-        entMngr.defTextEntity("Icirc",  "\u00ce");   // capital I, circumflex accent
-        entMngr.defTextEntity("Igrave", "\u00cc");  // capital I, grave accent
-        entMngr.defTextEntity("Iuml",   "\u00cf");    // capital I, dieresis or umlaut mark
-        entMngr.defTextEntity("Ntilde", "\u00d1");  // capital N, tilde
-        entMngr.defTextEntity("Oacute", "\u00d3");  // capital O, acute accent
-        entMngr.defTextEntity("Ocirc",  "\u00d4");   // capital O, circumflex accent
-        entMngr.defTextEntity("Ograve", "\u00d2");  // capital O, grave accent
-        entMngr.defTextEntity("Oslash", "\u00d8");  // capital O, slash
-        entMngr.defTextEntity("Otilde", "\u00d5");  // capital O, tilde
-        entMngr.defTextEntity("Ouml",   "\u00d6");    // capital O, dieresis or umlaut mark
-        entMngr.defTextEntity("THORN",  "\u00de");   // capital THORN, Icelandic
-        entMngr.defTextEntity("Uacute", "\u00da");  // capital U, acute accent
-        entMngr.defTextEntity("Ucirc",  "\u00db");   // capital U, circumflex accent
-        entMngr.defTextEntity("Ugrave", "\u00d9");  // capital U, grave accent
-        entMngr.defTextEntity("Uuml",   "\u00dc");    // capital U, dieresis or umlaut mark
-        entMngr.defTextEntity("Yacute", "\u00dd");  // capital Y, acute accent
-        entMngr.defTextEntity("aacute", "\u00e1");  // small a, acute accent
-        entMngr.defTextEntity("acirc",  "\u00e2");   // small a, circumflex accent
-        entMngr.defTextEntity("aelig",  "\u00e6");   // small ae diphthong (ligature)
-        entMngr.defTextEntity("agrave", "\u00e0");  // small a, grave accent
-        entMngr.defTextEntity("aring",  "\u00e5");   // small a, ring
-        entMngr.defTextEntity("atilde", "\u00e3");  // small a, tilde
-        entMngr.defTextEntity("auml",   "\u00e4");    // small a, dieresis or umlaut mark
-        entMngr.defTextEntity("ccedil", "\u00e7");  // small c, cedilla
-        entMngr.defTextEntity("eacute", "\u00e9");  // small e, acute accent
-        entMngr.defTextEntity("ecirc",  "\u00ea");   // small e, circumflex accent
-        entMngr.defTextEntity("egrave", "\u00e8");  // small e, grave accent
-        entMngr.defTextEntity("eth",    "\u00f0");     // small eth, Icelandic
-        entMngr.defTextEntity("euml",   "\u00eb");    // small e, dieresis or umlaut mark
-        entMngr.defTextEntity("iacute", "\u00ed");  // small i, acute accent
-        entMngr.defTextEntity("icirc",  "\u00ee");   // small i, circumflex accent
-        entMngr.defTextEntity("igrave", "\u00ec");  // small i, grave accent
-        entMngr.defTextEntity("iuml",   "\u00ef");    // small i, dieresis or umlaut mark
-        entMngr.defTextEntity("ntilde", "\u00f1");  // small n, tilde
-        entMngr.defTextEntity("oacute", "\u00f3");  // small o, acute accent
-        entMngr.defTextEntity("ocirc",  "\u00f4");   // small o, circumflex accent
-        entMngr.defTextEntity("ograve", "\u00f2");  // small o, grave accent
-        entMngr.defTextEntity("oslash", "\u00f8");  // small o, slash
-        entMngr.defTextEntity("otilde", "\u00f5");  // small o, tilde
-        entMngr.defTextEntity("ouml",   "\u00f6");    // small o, dieresis or umlaut mark
-        entMngr.defTextEntity("szlig",  "\u00df");   // small sharp s, German (sz ligature)
-        entMngr.defTextEntity("thorn",  "\u00fe");   // small thorn, Icelandic
-        entMngr.defTextEntity("uacute", "\u00fa");  // small u, acute accent
-        entMngr.defTextEntity("ucirc",  "\u00fb");   // small u, circumflex accent
-        entMngr.defTextEntity("ugrave", "\u00f9");  // small u, grave accent
-        entMngr.defTextEntity("uuml",   "\u00fc");    // small u, dieresis or umlaut mark
-        entMngr.defTextEntity("yacute", "\u00fd");  // small y, acute accent
-        entMngr.defTextEntity("yuml",   "\u00ff");    // small y, dieresis or umlaut mark
-
-        // Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
-        entMngr.defTextEntity("nbsp",   "\u00a0");  // non breaking space
-        entMngr.defTextEntity("reg",    "\u00ae");   // registered sign
-        entMngr.defTextEntity("copy",   "\u00a9");  // copyright sign
-
-        // Additional ISO-8859/1     entities listed in rfc1866 (section 14)
-        entMngr.defTextEntity("iexcl",  "\u00a1");
-        entMngr.defTextEntity("cent",   "\u00a2");
-        entMngr.defTextEntity("pound",  "\u00a3");
-        entMngr.defTextEntity("curren", "\u00a4");
-        entMngr.defTextEntity("yen",    "\u00a5");
-        entMngr.defTextEntity("brvbar", "\u00a6");
-        entMngr.defTextEntity("sect",   "\u00a7");
-        entMngr.defTextEntity("uml",    "\u00a8");
-        entMngr.defTextEntity("ordf",   "\u00aa");
-        entMngr.defTextEntity("laquo",  "\u00ab");
-        entMngr.defTextEntity("not",    "\u00ac");
-        entMngr.defTextEntity("shy",    "\u00ad");  // soft hyphen
-        entMngr.defTextEntity("macr",   "\u00af");
-        entMngr.defTextEntity("deg",    "\u00b0");
-        entMngr.defTextEntity("plusmn", "\u00b1");
-        entMngr.defTextEntity("sup1",   "\u00b9");
-        entMngr.defTextEntity("sup2",   "\u00b2");
-        entMngr.defTextEntity("sup3",   "\u00b3");
-        entMngr.defTextEntity("acute",  "\u00b4");
-        entMngr.defTextEntity("micro",  "\u00b5");
-        entMngr.defTextEntity("para",   "\u00b6");
-        entMngr.defTextEntity("middot", "\u00b7");
-        entMngr.defTextEntity("cedil",  "\u00b8");
-        entMngr.defTextEntity("ordm",   "\u00ba");
-        entMngr.defTextEntity("raquo",  "\u00bb");
-        entMngr.defTextEntity("frac14", "\u00bc");
-        entMngr.defTextEntity("frac12", "\u00bd");
-        entMngr.defTextEntity("frac34", "\u00be");
-        entMngr.defTextEntity("iquest", "\u00bf");
-        entMngr.defTextEntity("times",  "\u00d7");
-        entMngr.defTextEntity("divide", "\u00f7");
-    }
-
-    public static void applyHacks(Parser parser) {
-        parser.addEmptyElms(emptyElms);
-        parser.setElmTerminators(LI, li_terminators);
-        parser.setElmTerminators(DT, dt_terminators);
-        parser.setElmTerminators(DD, dd_terminators);
-        parser.setElmTerminators(P, p_terminators);
-        //parser.ignoreWS(ginore_ws);
-        applyHacks(parser.getTokenizer());
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HtmlXmlParser.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HtmlXmlParser.java
deleted file mode 100644
index d256336..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/HtmlXmlParser.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-/** 
- * The HtmlXmlParser is a Parser with some HTML specific <i>hacks</i>
- * applied to it which means it will more or less correctly parse most
- * HTML pages, also when they arbitrary embedded XML markup. It is
- * very forgiving as is commonly the case with HTML parsers.
- * 
- * @author  Anders Kristensen
- */
-public class HtmlXmlParser extends Parser {
-    public HtmlXmlParser() {
-        super();
-        HTML.applyHacks(this);
-        tok.rcgnzCDATA = false;
-    }
-    
-    // for debugging
-    public static void main(String[] args) throws Exception {
-        Parser parser = new HtmlXmlParser();
-        hplb.org.w3c.dom.Document doc = parser.parse(System.in);
-        Utils.pp(doc, System.out);
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeImpl.java
deleted file mode 100644
index 60ea04a..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeImpl.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * Implements management of list of children.
- * @author  Anders Kristensen
- */
-public abstract class NodeImpl implements Node {
-    protected int type;
-    protected NodeImpl parent;
-    protected NodeListImpl children = new NodeListImpl();
-    
-    public NodeImpl(int type) {
-        this.type = type;
-    }
-    
-    public NodeListImpl getChildren() {
-        return children;
-    }
-    
-    public int getNodeType() {
-        return type;
-    }
-    
-    public Node getParentNode() {
-        return parent;
-    }
-    
-    public NodeIterator getChildNodes() {
-        return children.getIterator();
-    }
-    
-    public boolean hasChildNodes() {
-        return (children.getLength() > 0);
-    }
-    
-    public Node getFirstChild() {
-        return children.item(0);
-    }
-    
-    public Node getPreviousSibling() {
-        if (parent == null) return null;
-        else return parent.children.getPreviousNode(this);
-    }
-    
-    public Node getNextSibling() {
-        if (parent == null) return null;
-        else return parent.children.getNextNode(this);
-    }
-    
-    public Node insertBefore(Node newChild, Node refChild) {
-        NodeImpl node = (NodeImpl) children.insertBefore(newChild, refChild);
-        if (node != null) ((NodeImpl) newChild).parent = this;
-        return node;
-    }
-    
-    public Node insertAfter(Node newChild, Node refChild) {
-        NodeImpl node = (NodeImpl) children.insertAfter(newChild, refChild);
-        if (node != null) ((NodeImpl) newChild).parent = this;
-        return node;
-    }
-    
-    public Node replaceChild(Node newChild, Node oldChild) {
-        NodeImpl node = (NodeImpl) children.replace(newChild, oldChild);
-        if (node != null) {
-            node.parent = null;
-            ((NodeImpl) newChild).parent = this;
-        }
-        return node;
-    }
-    
-    public Node removeChild(Node oldChild) {
-        NodeImpl node = (NodeImpl) children.remove(oldChild);
-        if (node != null) node.parent = null;
-        return node;
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeListImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeListImpl.java
deleted file mode 100644
index 92271b5..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/NodeListImpl.java
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * 
- * @author  Anders Kristensen
- */
-public class NodeListImpl {
-    protected Node[] elms;
-    protected int count = 0;
-    
-    public NodeListImpl() {
-        this(5);
-    }
-    
-    public NodeListImpl(int size) {
-        if (size <= 0) throw new IllegalArgumentException(
-                "Initial size of must be at least 1");
-        elms = new Node[size];
-    }
-    
-    public synchronized void add(Node node) {
-        int len = elms.length;
-        if (len == count) {
-            Node[] e = new Node[len * 2];
-            System.arraycopy(elms, 0, e, 0, len);
-            elms = e;
-        }
-        elms[count++] = node;
-    }
-    
-    public synchronized Node replace(int index, Node replaceNode) {
-        if (index < 0 || index >= count) {
-            throw new IndexOutOfBoundsException(""+index);
-        } else if (index == count) {
-            add(replaceNode);
-            return null;
-        } else {
-            Node node = elms[index];
-            elms[index] = replaceNode;
-            return node;
-        }
-    }
-    
-    // XXX: TEST THIS METHOD!!!
-    public synchronized Node insert(int index, Node newNode) {
-        Node res = null;
-        if (index < 0 || index > count) {
-            throw new IndexOutOfBoundsException(""+index);
-        } else if (index == count) {
-            add(newNode);
-        } else {
-            int len = elms.length;
-            if (len == count) {
-                Node[] e = new Node[len * 2];
-                System.arraycopy(elms, 0, e, 0, index);
-                System.arraycopy(elms, index, e, index+1, count-index);
-                elms = e;
-            } else {
-                System.arraycopy(elms, index, elms, index+1, count-index);
-            }
-            res = elms[index];
-            elms[index] = newNode;
-            count++;
-        }
-        return res;
-    }
-    
-    public NodeIterator getIterator() {
-        return new NodeIteratorImpl(this);
-    }
-    
-    public synchronized Node remove(int index) {
-        if (index < 0 || index >= count) {
-            throw new IndexOutOfBoundsException(""+index);
-        }
-        Node node = elms[index];
-        System.arraycopy(elms, index+1, elms, index, count-index-1);
-        count--;
-        return node;
-    }
-    
-    public synchronized Node item(int index) {
-        if (index < 0 || index >= count) {
-            return null;
-        }
-        return elms[index];
-    }
-    
-    /** Returns the number of keys in this dictionary. */
-    public synchronized int getLength() {
-        return count;
-    }
-    
-    public Node getPreviousNode(Node node) {
-        for (int i = 1; i < count; i++) {
-            if (elms[i] == node) return elms[i-1];
-        }
-        return null;
-    }
-    
-    public Node getNextNode(Node node) {
-        for (int i = 0; i < count-1; i++) {
-            if (elms[i] == node) return elms[i+1];
-        }
-        return null;
-    }
-    
-    public Node insertBefore(Node node, Node ref) {
-        int idx = index(ref);
-        if (idx > -1) insert(idx, node);
-        else add(node);
-        return node;
-    }
-    
-    public Node insertAfter(Node node, Node ref) {
-        int idx = index(ref);
-        if (idx > -1) insert(idx+1, node);
-        else add(node);
-        return node;
-    }
-    
-    public Node replace(Node node, Node ref) {
-        return replace(index(ref), node);
-    }
-    
-    public Node remove(Node node) {
-        int idx = index(node);
-        return (idx > -1 ? remove(idx) : null);
-    }
-    
-    public int index(Node node) {
-        for (int i = 0; i < count; i++) {
-            if (elms[i] == node) return i;
-        }
-        return -1;
-    }
-    
-    public synchronized String toString() {
-        StringBuffer sb = new StringBuffer();
-        boolean f = true;
-        int count = getLength();
-        
-        sb.append("{ ");
-        for (int i = 0; i < count; i++) {
-            if (f) { f = false; }
-            else { sb.append(", "); }
-            sb.append(item(i).toString());
-        }
-        sb.append(" }");
-        return sb.toString();
-    }
-}
-
-
-// FIXME: doesn't work properly when list changed underneath iterator
-// proper thing would be to use observer pattern on current element--if
-// this is removed we get callback and reposition the cursor... THISISAHACK!
-// FIXME synchronize on the list itself.
-class NodeIteratorImpl implements NodeIterator {
-    NodeListImpl nlist;
-    int index;
-    
-    /**
-     * Create iterator over the specified NodeList. The initial position
-     * will be one *before* the first element. Calling toNext() will
-     * position the iterator at the first element.
-     */
-    public NodeIteratorImpl(NodeListImpl list) {
-        nlist = list;
-        index = -1;
-    }
-    
-    public int getLength() {
-        return nlist.getLength();
-    }
-    
-    public Node getCurrent() {
-        return (index >= 0 && index < nlist.count) ? nlist.item(index) : null;
-    }
-    
-    public Node toNext() {
-        if (index < nlist.count) index++;
-        return getCurrent();
-    }
-    
-    public Node toPrevious() {
-        if (index >= 0) index--;
-        return getCurrent();
-    }
-    
-    public Node toFirst() {
-        index = 0;
-        return getCurrent();
-    }
-    
-    public Node toLast() {
-        index = nlist.count;
-        return getCurrent();
-    }
-    
-    public Node toNth(int Nth) {
-        index = Nth;
-        return getCurrent();
-    }
-    
-    // FIXME: multi-threading problems here... (race condition)
-    public Node toNode(Node destNode) {
-        int idx = nlist.index(destNode);
-        return (idx >= 0 ? toNth(idx) : null);
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Parser.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Parser.java
deleted file mode 100644
index aa76e03..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Parser.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-package hplb.xml;
-
-import hplb.org.xml.sax.*;
-import hplb.org.w3c.dom.*;
-import java.util.*;
-import java.io.*;
-
-/**
- * Parses a stream of MarkupTokens into a tree structure.
- * Uses Tokenizer.
- * 
- * <p>This class has very shallow (no) understanding of HTML. Correct
- * handling of &lt;p&gt; tags requires some special code as does correct
- * handling of &lt;li&gt;. This parser doesn't know that an "li" tag can
- * be terminated by another "li" tag or a "ul" end tag. Hence "li" is
- * treated as an empty tag here which means that in the generated parse
- * tree the children of the "li" element are represented as siblings of it.
- * 
- * @see Tokenizer
- * @author  Anders Kristensen
- */
-public class Parser implements DocumentHandler {
-    // FIXME: add support for discriminate per-element whitespace handling
-    
-    /**
-     * Set of elements which the parser will expect to be empty, i.e. it
-     * will not expect an end tag (e.g. IMG, META HTML elements).
-     * End tags for any of these are ignored...
-     */
-    protected Hashtable emptyElms = new Hashtable();
-    
-    /**
-     * Maps element names to a list of names of other elements which
-     * terminate that element. So for example "dt" might be mapped to
-     * ("dt", "dd") and "p" might be mapped to all blocklevel HTML
-     * elements.
-     */
-    protected Hashtable terminators = new Hashtable();
-    protected Tokenizer tok;
-    protected DOM dom;
-    protected Document root;
-    protected Node current;
-    
-    /**
-     * Non-fatal errors are written to this PrintStream. Fatal errors
-     * are reported as Exceptions.
-     */
-    PrintStream err = System.err;
-    
-    public Parser() {
-        tok = new Tokenizer();
-        tok.setDocumentHandler(this);
-        dom = new DOMImpl();
-    }
-    
-    public DOM setDOM(DOM dom) {
-        DOM old = dom;
-        this.dom = dom;
-        return old;
-    }
-    
-    public Tokenizer getTokenizer() {
-        return tok;
-    }
-    
-    /**
-     * Add the set of HTML empty elements to the set of tags recognized
-     * as empty tags.
-     */
-    public void addEmptyElms(String[] elms) {
-        for (int i = 0; i < elms.length; i++) {
-            emptyElms.put(elms[i], elms[i]);
-        }
-    }
-    
-    public void clearEmptyElmSet() {
-        emptyElms.clear();
-    }
-    
-    public boolean isEmptyElm(String elmName) {
-        return emptyElms.get(elmName) != null;
-    }
-    
-    public void setElmTerminators(String elmName, String[] elmTerms) {
-        terminators.put(elmName, putIds(new Hashtable(), elmTerms));
-    }
-    
-    public void addTerminator(String elmName, String elmTerm) {
-        Hashtable h = (Hashtable) terminators.get(elmName);
-        if (h == null) terminators.put(elmName, h = new Hashtable());
-        h.put(elmTerm, elmTerm);
-    }
-    
-    public static final Dictionary putIds(Dictionary dict, String[] sary) {
-        for (int i = 0; i < sary.length; i++) {
-            dict.put(sary[i], sary[i]);
-        }
-        return dict;
-    }
-    
-    protected Document root() {
-        return root;
-    }
-    
-    public Document parse(InputStream in) throws Exception {
-        root = dom.createDocument(null);
-        current = root;
-        tok.parse(in);
-        return root();
-    }
-   
-    public void startDocument() {}
-    public void endDocument() {}
-    
-    // FIXME: record in root DOCUMENT the id's of elements which have one
-    
-    public void doctype(String name, String publicID, String systemID) {
-    }
-    
-    public void startElement(String name, AttributeMap attributes) {
-        //System.out.println("CURRENT: " + current);
-        
-        // does this new element terminate the current element?
-        if (current != root) {
-        String tagName = ((Element) current).getTagName();
-        if (tagName != null) {
-            Hashtable terms = (Hashtable) terminators.get(tagName);
-            if (terms != null && terms.get(name) != null) {
-                current = current.getParentNode();  // FIXME: could be null
-            }
-        }
-        }
-        
-        Element elm = root.createElement(name, getDOMAttrs(attributes));
-        // FIXME: <hr> gets written as <hr></hr> - the following line changes
-        // this tp <hr/> which is even wors - we should distinguish between
-        // those two types of empty elements.
-        current.insertBefore(elm, null);
-        if (!isEmptyElm(name)) current = elm;
-    }
-    
-    public void endElement(String name) {
-        // we go up the parse tree till we find the node which matches
-        // this end tag. This mechanism elegantly handles "implicitly
-        // closed" elements such as <li> being terminated by an
-        // enclosing <ul> being ended.
-        
-        //System.out.println("CURRENT: " + current);
-        
-        Node node = current;
-        for (;;) {
-            if (node == root) {
-                err.println("Stray end tag ignored: " + name +
-                            " line " + tok.line + " column " + tok.column);
-                return;
-            } else if (name.equals(((Element) node).getTagName())) {
-                current = node.getParentNode();
-                return;
-            } else {
-                node = node.getParentNode();
-            }
-        }
-    }
-    
-    public void characters(char[] ch, int start, int length) {
-        current.insertBefore(
-            root.createTextNode(new String(ch, start, length)), null);
-    }
-    
-    public void ignorable (char ch[], int start, int length) {
-        System.out.println("Ignorable ws: " + new String(ch, start, length));
-    }
-    
-    public void processingInstruction(String target, String remainder) {
-        // FIXME: the DOM says 2nd arg should be everything between "<?" and "?>"
-        current.insertBefore(root.createPI(target, remainder), null);
-    }
-    
-    public AttributeList getDOMAttrs(AttributeMap attrs) {
-        String name;
-        Node value;
-        Enumeration e;
-        AttributeList domAttrs = root.createAttributeList();
-        
-        for (e = attrs.getAttributeNames(); e.hasMoreElements(); ) {
-            name = (String) e.nextElement();
-            value = root.createTextNode(attrs.getValue(name));
-            domAttrs.setAttribute(root.createAttribute(name, value));
-        }
-        return domAttrs;
-    }
-    
-    // for debugging
-    public static void main(String[] args) throws Exception {
-        Parser parser = new Parser();
-        Document doc = parser.parse(System.in);
-        Utils.pp(doc, System.out);
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/SAXAttributeMap.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/SAXAttributeMap.java
deleted file mode 100644
index 69bee41..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/SAXAttributeMap.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.xml.sax.AttributeMap;
-import java.util.Enumeration;
-
-/**
- * An ordered Dictionary. keys() and elements() returns Enumerations
- * which enumerate over elements in the order they were inserted.
- * Elements are stored linearly. Operations put(), get(), and remove()
- * are linear in the number of elements in the Dictionary.
- * 
- * <p>Allows direct access to elements (as an alternative to using
- * Enumerators) for speed.
- * 
- * <p>Can function as a <em>bag</em>, i.e. it can be created with a mode
- * which allows the same key to map to multiple entries. In this case 
- * operations get() and remove() operate on the <em>first</em> pair in
- * the map. Hence to get hold of all values associated with a key it is
- * necessary to use the direct access to underlying arrays.
- * 
- * @author  Anders Kristensen
- */
-public class SAXAttributeMap implements AttributeMap {
-    
-    /** The list of keys. */
-    public String[] keys;
-    
-    /** List of values associated with keys. */
-    public String[] elms;
-    
-    /**
-     * Number of elements in the Dictionary.
-     * The elements are held at indices 0 to n in the keys and elms arrays.
-     */
-    public int n = 0;
-    
-    public SAXAttributeMap() {
-        this(5);
-    }
-    
-    /**
-     * Create a SAXAttributeMap with the specififed initial cpacity.
-     */
-    public SAXAttributeMap(int size) {
-        if (size <= 0) throw new IllegalArgumentException(
-                "Initial size must be at least 1");
-        keys = new String[size];
-        elms = new String[size];
-    }
-    
-    /** Returns the number of keys in this dictionary. */
-    public synchronized int size() {
-        return n;
-    }
-    
-    /** Returns true if this dictionary maps no keys to value. */
-    public synchronized boolean isEmpty() {
-        return size() == 0;
-    }
-    
-    /**
-     * Returns an enumeration of the keys in this dictionary. 
-     */
-    public Enumeration getAttributeNames() {
-        return new SAXAttributeEnum(keys, n);
-    }
-
-    /**
-     * Returns the value to which the key is mapped in this dictionary. 
-     */
-    public synchronized String getValue(String key) {
-        int i = getIndex(key);
-        return (i < 0 ? null : elms[i]);
-    }
-    
-    protected int getIndex(String key) {
-        for (int i = 0; i < n; i++) {
-            if (keys[i].equals(key))
-                return i;
-        }
-        return -1;
-    }
-
-    /**
-     * Maps the specified key to the specified value in this dictionary.
-     * Neither the key nor the value can be null. 
-     * 
-     * <p>The value can be retrieved by calling the get method with a key
-     * that is equal to the original key. 
-     * @return  the previous value to which the key was mapped in
-     *          this dictionary, or null if the key did not have a
-     *          previous mapping.
-     * @throws NullPointerException  if the key or value is null
-     */
-    public synchronized String put(String key, String value) {
-        if (value == null) throw new NullPointerException("value is null");
-        int i = getIndex(key);
-        if (i >= 0) {
-            String old = elms[i];
-            elms[i] = value;
-            return old;
-        }
-        int len = keys.length;
-        if (len == n) {
-            // double size of key,elms arrays
-            String[] k, e;
-            k = new String[len * 2];
-            e = new String[len * 2];
-            System.arraycopy(keys, 0, k, 0, len);
-            System.arraycopy(elms, 0, e, 0, len);
-            keys = k;
-            elms = e;
-        }
-        keys[n] = key;
-        elms[n] = value;
-        n++;
-        return null;
-    }
-  
-  public void clear() {
-    n = 0;
-  }
-    
-  public boolean isEntity (String aname) { return false; }
-  public boolean isNotation (String aname) { return false; }
-  public boolean isId (String aname) { return false; }
-  public boolean isIdref (String aname) { return false; }
-  public String getEntityPublicID (String aname) { return null; }
-  public String getEntitySystemID (String aname) { return null; }
-  public String getNotationName (String aname) { return null; }
-  public String getNotationPublicID (String aname) { return null; }
-  public String getNotationSystemID (String aname) { return null; }
-
-    public synchronized String toString() {
-        StringBuffer sb = new StringBuffer();
-        boolean f = true;
-        
-        sb.append("{ ");
-        for (Enumeration e = getAttributeNames(); e.hasMoreElements(); ) {
-            if (f) { f = false; }
-            else { sb.append(", "); }
-            String key = (String) e.nextElement();
-            sb.append("" + key + '=' + getValue(key));
-        }
-        sb.append(" }");
-        return sb.toString();
-    }
-    
-    /*
-    // for testing
-    public static void main(String[] args) throws Exception {
-        SAXAttributeMap d;
-        java.io.BufferedReader r;
-        java.util.StringTokenizer tok;
-        String op;
-        
-        if (args.length > 1) {
-            d = new SAXAttributeMap(Integer.parseInt(args[0]));
-        } else {
-            d = new SAXAttributeMap();
-        }
-        
-        System.out.println(
-            "Enter operations... op's are one of\n"+
-            "put <key> <val>\n"+
-            "get <key>\n"+
-            "enum\n"+
-            "size\n"+
-            "quit\n");
-        
-        r = new java.io.BufferedReader(
-                new java.io.InputStreamReader(System.in)); 
-        while (true) {
-            System.out.print("doyourworst> ");
-            tok = new java.util.StringTokenizer(r.readLine());
-            op = tok.nextToken();
-            if ("put".equals(op)) {
-                System.out.println("Value: " +
-                                   d.put(tok.nextToken(), tok.nextToken()));
-            } else if ("get".equals(op)) {
-                System.out.println("Value: " + d.getValue(tok.nextToken()));
-            } else if ("enum".equals(op)) {
-                for (Enumeration e = d.getAttributeNames();
-                     e.hasMoreElements(); ) {
-                    System.out.println("" + e.nextElement() + " ");
-                }
-            } else if (op.startsWith("s")) {
-                System.out.println("Size: " + d.size());
-            } else if (op.startsWith("q")) {
-                break;
-            } else {
-                System.out.println("Unrecognized op: " + op);
-            }
-            
-            System.out.println("Dictionary: " + d);
-            System.out.println("Size: " + d.size());
-            System.out.println();
-        }
-    }
-    */
-}
-
-class SAXAttributeEnum implements Enumeration {
-    String[] objs;
-    int i = 0, n;
-    
-    public SAXAttributeEnum(String[] objs, int n) {
-        this.objs = objs;
-        this.n = n;
-    }
-    
-    public boolean hasMoreElements() {
-        return i < n;
-    }
-    
-    public Object nextElement() {
-        return objs[i++];
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/TextImpl.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/TextImpl.java
deleted file mode 100644
index 9df683f..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/TextImpl.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-// FIXME: check parameters reasonable [within bounds]
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-
-/**
- * Class whose instances represent PCDATA, comments, and PIs (processing
- * instructions.
- * @author  Anders Kristensen
- */
-public class TextImpl extends NodeImpl implements Text, Comment, PI {
-    protected String data;
-    protected String name; // only valid for PIs
-    
-    /**
-     * Construct new leaf node whose value is textual.
-     * @param type  one of Node.PI, Node.COMMENT, and Node.TEXT.
-     * @param data  the PCDATA, CDATA, comment, whatever
-     */
-    public TextImpl(int type, String data) {
-        super(type);
-        this.data = data;
-    }
-    
-    // getData/setData common for the three interfaces
-    public String getData() {
-        return data;
-    }
-    public void setData(String arg) {
-        data = arg;
-    }
-    
-    // Text specific methods:
-    
-    public void append(String data) {
-        this.data = this.data + data;
-    }
-    
-    public void insert(int offset, String data) {
-        this.data = this.data.substring(0, offset)
-                    + data
-                    + this.data.substring(offset);
-    }
-    
-    public void delete(int offset, int count) {
-        this.data = this.data.substring(0, offset)
-                    + this.data.substring(offset + count);
-    }
-    
-    public void replace(int offset, int count, String data) {
-        this.data = this.data.substring(0, offset)
-                    + data
-                    + this.data.substring(offset + count);
-    }
-    
-    public void splice(Element element, int offset, int count) {
-        if (offset <= 0) {
-            parent.insertBefore(element, this);
-        } else if (offset+count > data.length()) {
-            parent.insertAfter(element, this);
-        } else {
-            Node n;
-            n = new TextImpl(Node.TEXT, data.substring(offset, offset+count));
-            element.insertBefore(n , null);
-            n = new TextImpl(Node.TEXT, data.substring(offset+count));
-            parent.insertAfter(n, this);
-            data = data.substring(0, offset);
-        }
-    }
-    
-    // PI specific methods:
-    public String getName() {
-        return name;
-    }
-    public void setName(String arg) {
-        name = arg;
-    }
-    
-    protected String typeAsString() {
-        switch (type) {
-            case Node.PI:        return "PI";
-            case Node.COMMENT:   return "COMMENT";
-            case Node.TEXT:      return "TEXT";
-            default:        return "UNKNOWN";
-        }
-    }
-    
-    public String toDebugString() {
-        return typeAsString() +
-               (data == null ? "" : Utils.compact(data));
-    }
-    
-    public String toString() {
-        switch (type) {
-            case Node.PI:        return "<?" + name + " " + data + "?>";
-            case Node.COMMENT:   return "<!--" + data + "-->";
-            case Node.TEXT:      return data;
-            default:        return "UNKNOWN";
-        }
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Tokenizer.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Tokenizer.java
deleted file mode 100644
index 9f77289..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Tokenizer.java
+++ /dev/null
@@ -1,690 +0,0 @@
-/*
- * $Id$
- *
- * Copyright 1997 Hewlett-Packard Company
- *
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-/*
- * FIXME:
- *   - use java.io.Reader and Unicode chars...
- *   - recognize PIs and CDATA
- *   - recognize PEs and CEs (optionally)
- *   - Do NOT map element and attr names to lower (or upper) case
- */
-
-package hplb.xml;
-
-import hplb.org.xml.sax.*;
-import java.util.Dictionary;
-import java.util.Hashtable;
-import java.io.*;
-import hplb.misc.ByteArray;
-import java.net.URL;
-
-/**
- * This is a hand-written lexical analyzer for XML/HTML Markup.
- * The parser is simple, fast and quite robust.
- * Element and attribute names are mapped to lower case.
- * Comments are returned as (part of) PCDATA tokens.
- * Markup elements within comments is not recognized as markup.
- *
- * @author      Anders Kristensen
- */
-public class Tokenizer implements hplb.org.xml.sax.Parser {
-
-    /** The value of boolean attributes is this string. */
-    public static final String BOOLATTR = Atom.getAtom("BOOLATTR");
-
-    // FSM states:
-    static final int ST_START           = 1;
-    static final int ST_TAG_LT          = 3;
-    static final int ST_TAG_NAME        = 4;
-    static final int ST_TAG_WS          = 5;
-    static final int ST_EMPTY_TAG_SLASH = 6;
-    static final int ST_NAME            = 7;
-    static final int ST_NAME_WS         = 8;
-    static final int ST_EQ              = 9;
-    static final int ST_VALUE           = 10;
-    static final int ST_VALUE_QUOTED    = 11;
-    static final int ST_PCDATA          = 21;
-    static final int ST_COMMENT         = 22;
-
-    HandlerBase    dfltHandler = new HandlerBase();
-    EntityHandler   entHandler = dfltHandler;
-    DocumentHandler docHandler = dfltHandler;
-    ErrorHandler    errHandler = dfltHandler;
-    SAXAttributeMap attrs = new SAXAttributeMap();
-    String sysID;
-
-    protected Hashtable noCaseElms;
-    public boolean rcgnzWS       = true;   // is white space chars recognized as PCDATA
-                                           // even when preceeding tags?
-    public boolean rcgnzEntities = true;
-    public boolean rcgnzCDATA    = true;
-    public boolean rcgnzComments = true;   //
-    public boolean atomize       = false;  // make element and attr names atoms
-
-    CharBuffer buf       = new CharBuffer();
-    boolean isStartTag   = true;
-    /**
-     * Signals whether a non-empty element has any children. If not we
-     * must generate an artificial empty-string child [characters(buf, 0, 0)].
-     */
-    boolean noChildren;
-    CharBuffer tagname   = new CharBuffer();
-    CharBuffer attrName  = new CharBuffer();
-    CharBuffer attrValue = new CharBuffer();
-    Reader in;
-
-    public final EntityManager entMngr = new EntityManager(this);
-    protected int state = ST_START;
-    protected int _line = 1;
-    protected int _column = 0;
-    public int line;          // can be used in Handler callbacks
-    public int column;        // can be used in Handler callbacks
-    protected int qchar;      // <'> or <"> when parsing quoted attr values
-    // we recognize attribute name-value pairs for XML PI by setting
-    // the inXMLDecl flag and going to state ST_TAG_WS
-    boolean inXMLDecl = false;  // see
-
-    public Tokenizer() {
-        pos();
-    }
-
-    public void setEntityHandler(EntityHandler handler) {
-        entHandler = handler;
-    }
-
-    public void setDocumentHandler(DocumentHandler handler) {
-        docHandler = handler;
-    }
-
-    public void setErrorHandler(ErrorHandler handler) {
-        errHandler = handler;
-    }
-
-    public void parse(String publicID, String sysID) throws Exception {
-        this.sysID = sysID;
-        parse(new URL(sysID).openStream());
-    }
-
-    public void parse(InputStream in) throws Exception
-	{
-		parse(new InputStreamReader(in));
-    }
-
-	public void parse(Reader in) throws Exception
-	{
-        this.in = in;
-        docHandler.startDocument();
-        tokenize();
-        docHandler.endDocument();
-	}
-
-    // invoked to remember current position
-    protected void pos() {
-        line = _line;
-        column = _column;
-    }
-
-    public void ignoreCase(String elementName) {
-        if (noCaseElms == null) noCaseElms = new Hashtable();
-        noCaseElms.put(elementName.toLowerCase(), elementName);
-    }
-
-    public void rcgnzWS(boolean b) {
-        rcgnzWS = b;
-    }
-
-    // invoked after doing any Handler callback - resets state
-    protected void toStart() {
-        state = ST_START;
-        buf.reset();
-        tagname.reset();
-        attrName.reset();
-        attrValue.reset();
-        attrs.clear();
-        isStartTag = true;  // until proven wrong
-        pos();
-    }
-
-  public void tokenize() throws Exception {
-    int c;
-
-    while ((c = read()) != -1) {
-      switch (state) {
-        case ST_START:
-          switch (c) {
-            case '<':
-              state = ST_TAG_LT;
-              isStartTag = true;  // until proven wrong
-              tagname.reset();
-              break;
-            case ' ': case '\t': case '\r': case '\n':
-              if (!rcgnzWS) break;
-              // else fall through
-            default:
-              state = ST_PCDATA;
-          }
-          break;
-
-        case ST_PCDATA:
-          if (c == '<') {
-            gotPCDATA(true);
-            state = ST_TAG_LT;
-          }
-          break;
-
-        case ST_TAG_LT:
-          switch (c) {
-            case '/':
-              isStartTag = false;
-              state = ST_TAG_NAME;
-              break;
-            case '!':
-              c = read();
-              if ((c == '-' && !rcgnzComments) || (c == '[' && !rcgnzCDATA)) {
-                state = ST_PCDATA;
-                break;
-              }
-              if (c == '-') state = ST_COMMENT;
-              else if (c == '[') parseCDATA();
-              else {
-                // FIXME: shouldn't be delivered as PCDATA
-                warning("Bad markup " + buf);
-                state = ST_PCDATA;
-              }
-              break;
-            case '?':
-              parsePI();
-              break;
-            case ' ': case '\t': case '\r': case '\n':
-              state = ST_TAG_WS;
-              break;
-            default:
-              tagname.write(c);
-              state = ST_TAG_NAME;
-          }
-          break;
-
-        case ST_TAG_NAME:
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n':
-              state = ST_TAG_WS;
-              break;
-            case '/': state = ST_EMPTY_TAG_SLASH; break;
-            case '>': gotTag(false); break;
-            default:  tagname.write(c);
-          }
-          break;
-
-        case ST_TAG_WS:
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n': break;
-            case '/': state = ST_EMPTY_TAG_SLASH; break;
-            case '>': gotTag(false); break;
-            case '?':
-              if (inXMLDecl) {
-                if ((c = read()) != '>') {
-                errHandler.warning("XML PI not terminated properly",
-                                   sysID, _line, _column);
-                  //err_continue("XML PI not terminated properly");
-                }
-                //handler.gotXMLDecl(attrs);  // FIXME(?)
-                toStart();
-                break;
-              }
-              // NOTE: if !inXMLDecl we fall through to default case
-            default:
-              if (!isStartTag) {
-                // bit of a hack this...
-                errHandler.warning("Malformed tag: "+buf, sysID, _line, _column);
-                //err_continue("Malformed tag: "+buf);
-                if (c == '<') {
-                    gotPCDATA(true);
-                    state = ST_TAG_LT;
-                } else {
-                    // we get here e.g. if there's an end tag with attributes
-                    state = ST_PCDATA;
-                }
-              } else {
-                // FIXME: this accepts way too many first chars for attr name
-                attrName.write(c);
-                state = ST_NAME;
-              }
-          }
-          break;
-
-        case ST_EMPTY_TAG_SLASH:
-          if (c == '>') {
-            //tagtype = TAG_EMPTY;
-            gotTag(true);
-            break;
-          } else {
-            // ERROR !? - can't throw Exception here - we go to next tag...
-            state = ST_PCDATA;
-          }
-          break;
-
-        case ST_NAME:
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n':
-              if (attrName.size() > 0) {
-                state = ST_NAME_WS;
-              }
-              break;
-            case '>':
-              if (attrName.size() > 0) gotAttr(true);
-              gotTag(false);
-              break;
-            case '=':
-              state = ST_EQ;
-              break;
-            default:
-              if (isCtlOrTspecial(c)) {
-                state = ST_PCDATA;
-              } else {
-                attrName.write(c);
-              }
-          }
-          break;
-
-        case ST_NAME_WS:   // white-space between name and '='
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n': break;
-            case '=': state = ST_EQ; break;
-            case '>': gotAttr(true); gotTag(false); break;
-            default:
-              if (isNameChar(c)) {
-                gotAttr(true);
-                attrName.write(c);
-                state = ST_TAG_WS;
-              } else {
-                state = ST_PCDATA;
-              }
-          }
-          break;
-
-        case ST_EQ:        // white-space between '=' and value
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n': break;
-            case '"':  qchar = '"';  state = ST_VALUE_QUOTED; break;
-            case '\'': qchar = '\''; state = ST_VALUE_QUOTED; break;
-            default:
-              if (isCtlOrTspecial(c)) {
-                state = ST_PCDATA;
-              } else {
-                attrValue.write(c);
-                state = ST_VALUE;
-              }
-          }
-          break;
-
-        case ST_VALUE:
-          switch (c) {
-            case ' ': case '\t': case '\r': case '\n':
-              gotAttr(false);
-              state = ST_TAG_WS;
-              break;
-            case '>':
-              gotAttr(false);
-              gotTag(false);
-              break;
-            case '/':
-              gotAttr(false);
-              state = ST_EMPTY_TAG_SLASH;
-              break;
-            default:
-              if (isCtlOrTspecial(c)) {
-                state = ST_PCDATA;
-              } else {
-                attrValue.write(c);
-              }
-          }
-          break;
-
-        case ST_VALUE_QUOTED:
-          if (c == qchar) {
-            gotAttr(false);
-            state = ST_TAG_WS;
-          } else {
-            attrValue.write(c);
-          }
-          break;
-
-        case ST_COMMENT:
-          // we've seen "...<!-" by now
-          try {
-            if (c != '-') {
-              warning("Bad comment");
-              state = ST_PCDATA;
-              break;
-            }
-            // we're within comment - read till we see "--"
-            while (true) {
-              while (read_ex() != '-') ;
-              if (read_ex() == '-') break;
-            }
-            // seen "--" - gotComment() reads past next '>'
-            gotComment();
-            //while (read_ex() != '>') ;
-            //state = ST_PCDATA;
-          } catch (EmptyInputStream ex) {
-            gotPCDATA(false);
-            break;
-          }
-      }
-    }
-    /* TODO: catch EmptyInputStream exception only here!
-    } catch (EmptyInputStream ex) {
-        err_continue("EOF while parsing " + token[state]);
-    }
-    */
-
-    // input stream ended - return rest, if any, as PCDATA
-    if (buf.size() > 0) {
-        gotPCDATA(false);
-        buf.reset();
-        }
-    }
-
-    // counts lines and columns - used in error reporting
-    // a line can be a single \r or \n or it can be \r\n - we handle them all
-    int cc; // last char read
-    public final int read() throws IOException {
-        int c = in.read();
-        if (c != -1) {
-            buf.write(c);
-
-            switch (c) {
-                case '\r': _line++; _column = 0; break;
-                case '\n':
-                    if (cc != '\r') _line++;
-                    _column = 0;
-                    break;
-                default:
-                    _column++;
-            }
-            cc = c;
-        }
-        return c;
-    }
-
-    public final int read_ex() throws IOException, EmptyInputStream {
-        int c = read();
-        if (c == -1) throw new EmptyInputStream();
-        return c;
-    }
-
-    // HTML allows <em>boolean</em> attributes - attributes without a
-    // value, or rather an implicit value which is the same as the name.
-    protected final void gotAttr(boolean isBoolean) throws Exception {
-        String nm = attrName.toString();
-        if (atomize) nm = Atom.getAtom(nm);
-        String val = isBoolean ? BOOLATTR :
-                        (rcgnzEntities ? entMngr.entityDecode(attrValue) :
-                            attrValue).toString();
-        attrName.reset();
-        attrValue.reset();
-        attrs.put(nm, val);
-    }
-
-    protected void gotTag(boolean isEmpty) throws Exception {
-        String nm = tagname.toString();
-        String nm_lc = nm.toLowerCase();
-        if (noCaseElms != null && noCaseElms.get(nm_lc) != null) {
-            nm = nm_lc;
-            keysToLowerCase(attrs);
-        }
-        if (atomize) nm = Atom.getAtom(nm);
-        if (isStartTag) {
-            docHandler.startElement(nm, attrs);
-            //handler.gotSTag(nm, isEmpty, attrs, getBuffer());
-            if (isEmpty) docHandler.endElement(nm);
-            noChildren = !isEmpty;
-        } else {
-            if (noChildren) {
-                docHandler.characters(buf.getCharArray(), 0, 0);
-                noChildren = false;
-            }
-            docHandler.endElement(nm);
-            //handler.gotETag(nm, getBuffer());
-        }
-        toStart();
-    }
-
-    public final void keysToLowerCase(SAXAttributeMap attrs) {
-        for (int i = 0; i < attrs.n; i++) {
-            attrs.keys[i] = attrs.keys[i].toLowerCase();
-            if (atomize) attrs.keys[i] = Atom.getAtom(attrs.keys[i]);
-        }
-    }
-
-    // toomuch true iff we read a '<' of the next token
-    protected void gotPCDATA(boolean toomuch) throws Exception {
-        noChildren = false;
-        if (toomuch) {
-            buf.setLength(buf.size() - 1);
-        }
-        CharBuffer buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;
-        docHandler.characters(buf1.getCharArray(), 0, buf1.size());
-        //handler.gotText(getBuffer());
-        toStart();
-        if (toomuch) {
-            buf.write('<');
-            column--;
-        }
-    }
-
-    // XXX: should pass the comment on as docHandler.ignorable() ??
-    protected void gotComment() throws IOException, EmptyInputStream {
-        //toStart();  // so an unexpected EOF causes rest to be returned as PCDATA
-        while (read_ex() != '>') ;
-        toStart();
-    }
-
-    // Processing Instruction
-    protected void parsePI() throws Exception {
-        int i;
-        String target;
-
-        noChildren = false;
-        inXMLDecl = false;
-        i = buf.size();
-        try {
-        while (!isWS(read_ex())) ;
-        target = buf.toString();
-        target = target.substring(i, target.length() - 1);
-
-        if ("XML".equals(target)) {
-            inXMLDecl = true;
-            state = ST_TAG_WS;
-            return;
-        }
-
-        while (isWS(read_ex())) ;
-        i = buf.size() - 1;
-        while (true) {
-            while (read_ex() != '?') ;
-            if (read_ex() == '>') {
-                String s = buf.toString();
-                docHandler.processingInstruction(
-                        Atom.getAtom(target), s.substring(i, s.length()-2));
-                //handler.gotPI(Atom.getAtom(target),
-                //              s.substring(i, s.length()-2));
-                break;
-            }
-        }
-        } catch (EmptyInputStream ex) {
-            gotPCDATA(false);
-            errHandler.warning("EOF while parsing PI", sysID, _line, _column);
-            //err_continue("EOF while parsing PI");
-        }
-        toStart();
-    }
-
-    // CDATA section
-    // XXX: should contents be amalgamated with surrounding PCDATA?
-    protected void parseCDATA() throws Exception {
-        // we've seen "<![" by now
-        try {
-            if (read_ex() == 'C' && read_ex() == 'D' && read_ex() == 'A' &&
-                read_ex() == 'T' && read_ex() == 'A' && read_ex() == '[') {
-                int i1 = buf.size();
-                while (read_ex() != ']' ||
-                       read_ex() != ']' ||
-                       read_ex() != '>') ;
-                docHandler.characters(buf.getCharArray(), i1, buf.size()-3-i1);
-            } else {
-                warning("Bad CDATA markup");
-                state = ST_PCDATA;
-            }
-        } catch (EmptyInputStream ex) {
-            warning("EOF while parsing CDATA section");
-            gotPCDATA(false);
-        }
-        toStart();
-    }
-
-    public boolean isWS(int c) {
-        switch (c) {
-            case ' ': case '\t': case '\r': case '\n': return true;
-            default: return false;
-        }
-    }
-
-    /**
-     * Returns true if c is either an ascii control character or
-     * a tspecial according to the HTTP specification.
-     */
-  //   private static final boolean[] isCtlOrTSpecial = new boolean[]
-//     {
-//        /* 0 */     true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
-//        /* 14 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
-//        /* 28 */    true , true , true , true , true , false, true , false, false, false, false, false, true , true ,
-//        /* 42 */    false, false, true , false, false, true , false, false, false, false, false, false, false, false,
-//        /* 56 */    false, false, true , true , true , true , true , true , true , false, false, false, false, false,
-//        /* 70 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 84 */    false, false, false, false, false, false, false, true , true , true , false, false, false, false,
-//        /* 98 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 112 */   false, false, false, false, false, false, false, false, false, false, false, true , false, true ,
-//        /* 126 */   false, true , false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 252 */   false, false, false, false
-//    };
-
-    public static final boolean isCtlOrTspecial(int c) {
-        switch (c) {
-          // control characters (0-31 and 127):
-          case  0: case  1: case  2: case  3: case  4: case  5:
-          case  6: case  7: case  8: case  9: case 10: case 11:
-          case 12: case 13: case 14: case 15: case 16: case 17:
-          case 18: case 19: case 20: case 21: case 22: case 23:
-          case 24: case 25: case 26: case 27: case 28: case 29:
-          case 30: case 31: case 127:
-
-          // tspecials:
-          case '(': case ')': case '<': case '>': case '@':
-          case ',': case ';': case ':': case '\\': case '"':
-          case '/': case '[': case ']': case '?': case '=':
-          case '{': case '}': case ' ': // case '\t':
-            return true;
-
-          default:
-            return false;
-        }
-    }
-
-/*    public static void main(String[])
-    {
-    System.out.println("private static final boolean[] isCtlOrTSpecial = \n{");  // bzw. isNameChar
-        for(int i=0; i<256; i++)
-        {
-            if(i>0)
-                System.out.print(", ");
-            if(i % 14 == 0)
-            {
-                System.out.print("\n/* " + i + " *" + "/   ");
-            }
-            if(Tokenizer.isCtlOrTspecial(i))  // bzw. isNameChar(i)
-            {
-                System.out.print("true ");
-            }
-            else
-            {
-                System.out.print("false");
-            }
-
-
-        }
-        System.out.print("};\n\n");
-    }
-    */
-
-//    public static final boolean isCtlOrTspecial(int c)
-//    {
-//        return (c < 256 ? isCtlOrTSpecial[c] : false);
-//    }
-//
-//    private static final boolean[] isNameChar =
-//    {
-//        /* 0 */     false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 14 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 28 */    false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 42 */    false, false, false, true , true , false, true , true , true , true , true , true , true , true ,
-//        /* 56 */    true , true , false, false, false, false, false, false, false, true , true , true , true , true ,
-//        /* 70 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
-//        /* 84 */    true , true , true , true , true , true , true , false, false, false, false, true , false, true ,
-//        /* 98 */    true , true , true , true , true , true , true , true , true , true , true , true , true , true ,
-//        /* 112 */   true , true , true , true , true , true , true , true , true , true , true , false, false, false,
-//        /* 126 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 140 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 154 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 168 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 182 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 196 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 210 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 224 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 238 */   false, false, false, false, false, false, false, false, false, false, false, false, false, false,
-//        /* 252 */   false, false, false, false
-//    };
-//    public static final boolean isNameChar(int c)
-//    {
-//        return (c < 256 ? isNameChar[c] : false);
-//    }
-//
-    /*
-    // I don't think this is a very standard definition of what can
-    // go into tag and attribute names.*/
-    public static final boolean isNameChar(int c) {
-        return ('a' <= c && c <= 'z') ||
-               ('A' <= c && c <= 'Z') ||
-               ('0' <= c && c <= '9') ||
-               c == '.' || c == '-' || c == '_';
-    }
-
-
-
-    protected final void warning(String s) throws Exception {
-        errHandler.warning(s, sysID, _line, _column);
-    }
-
-    protected final void fatal(String s) throws Exception {
-        errHandler.fatal(s, sysID, _line, _column);
-    }
-}
-
-class EmptyInputStream extends Exception {
-    EmptyInputStream() {}
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Utils.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Utils.java
deleted file mode 100644
index 66eda25..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/Utils.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml;
-
-import hplb.org.w3c.dom.*;
-import java.io.*;
-import java.util.*;
-
-public class Utils {
-    /** Pretty-print elm. */
-    public static void pp(Node node, PrintStream out) {
-        pp(node, out, 0);
-    }
-    
-    public static void pp(Node node, PrintStream out, int indent) {
-        indent(out, indent);
-        out.println("" + node);
-        indent += 2;
-        
-        NodeIterator iter = node.getChildNodes();
-        Node child;
-        while ((child = iter.toNext()) != null) {
-            pp(child, out, indent);
-        }
-    }
-    
-    public static String compact(String s) {
-        if (s.length() < 18) {
-            return "[" + noCRLF(s) + "]";
-        } else {
-            return "[" + noCRLF(s.substring(0, 7)) + "..." +
-                   noCRLF(s.substring(s.length() - 7)) + "]";
-        }
-    }
-    
-    public static String noCRLF(String s) {
-        return s.replace('\r', ' ').replace('\n', ' ');
-    }
-    
-    public static void indent(PrintStream out, int indent) {
-        for (int i = 0; i < indent; i++) out.print(' ');
-    }
-    
-    /**
-     * Encode an XML attribute value. Changes &lt;"&gt; to "&amp;quote;".
-     */
-    public static String encAttrVal(String val) {
-        if (val.indexOf('"') > -1) {
-            StringBuffer sbuf = new StringBuffer();
-            int offset = 0, i;
-            while ((i = val.indexOf('"', offset)) > -1) {
-                sbuf.append(val.substring(offset, i));
-                sbuf.append("&quote;");
-                offset = i+1;
-            }
-            sbuf.append(val.substring(offset));
-            return sbuf.toString();
-        }
-        return val;
-    }
-    
-    /**
-     * Encode the specified String as XML PCDATA, i.e. "&lt;" is
-     * encoded as "&amp;lt;" and "&amp;" is encoded as "&amp;amp;".
-     */
-    public static String encPCDATA(String s) {
-        if (s.indexOf('<') > -1 || s.indexOf('&') > -1) {
-            StringBuffer sbuf = new StringBuffer();
-            int offset = 0;
-            int i = s.indexOf('<', offset);
-            int j = s.indexOf('&', offset);
-            while (i > -1 || j > -1) {
-                if (i > j) {
-                    sbuf.append(s.substring(offset, i));
-                    sbuf.append("&quote;");
-                    offset = i+1;
-                    i = s.indexOf('<', offset);
-                } else {
-                    sbuf.append(s.substring(offset, j));
-                    sbuf.append("&quote;");
-                    offset = j+1;
-                    j = s.indexOf('&', offset);
-                }
-            }
-            sbuf.append(s.substring(offset));
-            return sbuf.toString();
-        }
-        return s;
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlObserver.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlObserver.java
deleted file mode 100644
index ab8cbdb..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlObserver.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import java.net.URL;
-
-/**
- * A callback interface used in conjunction with UrlScanner. Allows actions
- * to be taken whenever the scanner finds a URL in an HTML document. The
- * scanner knows about most HTML 4.0 elements which can contain URLs.
- * Can be used, for example, to implement robot code which crawls a hypertext
- * graph. This interface is similar to Jeff Poskanzer's Acme.HtmlObserver.
- * 
- * @see     HtmlScanner
- * @author  Anders Kristensen
- */
-public interface HtmlObserver {
-    /** Invoked when the scanner finds an &lt;a href=""&gt; URL. */
-    public void gotAHref(String urlStr, URL contextUrl, Object data);
-
-    /** Invoked when the scanner finds an &lt;img src=""&gt; URL. */
-    public void gotImgSrc(String urlStr, URL contextUrl, Object data);
-
-    /** Invoked when the scanner finds a &lt;base href=""&gt; URL. */
-    public void gotBaseHref(String urlStr, URL contextUrl, Object data );
-
-    /** Invoked when the scanner finds a &lt;area href=""&gt; URL. */
-    public void gotAreaHref(String urlStr, URL contextUrl, Object data );
-
-    /** Invoked when the scanner finds an &lt;frame src=""&gt; URL. */
-    public void gotFrameSrc(String urlStr, URL contextUrl, Object data );
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlScanner.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlScanner.java
deleted file mode 100644
index c1e9a4f..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/HtmlScanner.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * $Id$
- *
- * Copyright 1997 Hewlett-Packard Company
- *
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import hplb.org.xml.sax.HandlerBase;
-import hplb.org.xml.sax.AttributeMap;
-import hplb.org.xml.sax.XmlException;
-import hplb.org.xml.sax.ErrorHandler;
-import hplb.org.xml.sax.EntityHandler;
-import hplb.org.xml.sax.DocumentHandler;
-import hplb.xml.*;
-import java.net.*;
-import java.io.*;
-
-/**
- * The HtmlScanner parses an HTML document for elements containing links.
- * For each link found it will invoke a client-provided callback method.
- * It knows about most HTML4.0 links and also knows about the &lt;base&gt;.
- *
- * <p>For an example use see UrlScanner.
- *
- * @see     HtmlObserver
- * @see     UrlScanner
- * @author  Anders Kristensen
- */
-public class HtmlScanner extends HandlerBase {
-    HtmlObserver observer;
-    URL contextURL;
-    Object data;
-    Tokenizer tok;
-    Reader in;
-
-    /**
-     * Parse the input on the specified stream as if it was HTML and
-     * invoke the provided observer as links are encountered.
-     * @param url   the URL to parse for links
-     * @param observer  the callback object
-     * @param data  client-specific data; this is passed back to the
-     *              client in callbacks; this scanner doesn't use it
-     * @throws Exception    see hplb.org.xml.sax.Parser.parse()
-     * @see hplb.org.xml.sax.Parser.parse
-     */
-    public HtmlScanner(URL url, HtmlObserver observer ) throws Exception {
-        this(new BufferedReader(new InputStreamReader(url.openStream())), url, observer);
-    }
-
-    /**
-     * Parse the input on the specified stream as if it was HTML and
-     * invoke the provided observer as links are encountered.
-     * @param in    the input stream
-     * @param url   the URL corresponding to this document
-     * @param observer  the callback object
-     * @throws Exception    see hplb.org.xml.sax.Parser.parse()
-     * @see hplb.org.xml.sax.Parser.parse
-	 * @deprecated
-     */
-    public HtmlScanner(InputStream in, URL url, HtmlObserver observer)
-        throws Exception
-    {
-        this(new BufferedReader(new InputStreamReader(in)), url, observer, null);
-    }
-
-	    /**
-     * Parse the input on the specified stream as if it was HTML and
-     * invoke the provided observer as links are encountered.
-     * @param in    the Reader
-     * @param url   the URL corresponding to this document
-     * @param observer  the callback object
-     * @throws Exception    see hplb.org.xml.sax.Parser.parse()
-     * @see hplb.org.xml.sax.Parser.parse
-     */
-    public HtmlScanner(Reader in, URL url, HtmlObserver observer)
-        throws Exception
-    {
-        this(in, url, observer, null);
-    }
-
-	/**
-     * Parse the input on the specified stream as if it was HTML and
-     * invoke the provided observer as links are encountered.
-	 * Although not deprecated, this method should not be used. Use HtmlScanner(Reader...) instead
-	 * @deprecated
-	 */
-    public HtmlScanner(InputStream in, URL url, HtmlObserver observer, Object data)
-        throws Exception
-    {
-		this(new BufferedReader(new InputStreamReader(in)), url, observer, data);
-	}
-
-    /**
-     * Parse the input on the specified stream as if it was HTML and
-     * invoke the provided observer as links are encountered.
-     * @param in    the input stream
-     * @param url   the URL corresponding to this document
-     * @param observer  the callback object
-     * @param data  client-specific data; this is passed back to the
-     *              client in callbacks; this scanner doesn't use it
-     * @throws Exception    see hplb.org.xml.sax.Parser.parse()
-     * @see hplb.org.xml.sax.Parser.parse
-     */
-    public HtmlScanner(Reader in, URL url, HtmlObserver observer, Object data)
-        throws Exception
-    {
-        this.in = in;
-        this.observer = observer;
-        this.contextURL = url;
-        this.data = data;
-        tok = new Tokenizer();
-        setDocumentHandler(this);
-        HTML.applyHacks(tok);
-        tok.rcgnzEntities = false;
-        tok.rcgnzCDATA = false;
-        tok.atomize = true;
-    }
-
-    public void setDocumentHandler(DocumentHandler doc)
-    {
-        tok.setDocumentHandler(doc);
-    }
-
-    public void setEntityHandler(EntityHandler ent)
-    {
-        tok.setEntityHandler(ent);
-    }
-
-    public void setErrorHandler(ErrorHandler err)
-    {
-        tok.setErrorHandler(err);
-    }
-
-    public void parse() throws Exception
-    {
-        tok.parse(in);
-    }
-
-    public void startElement(String name, AttributeMap attributes) {
-        String val;
-
-        if (name == HTML.A) {
-            if ((val = attributes.getValue("href")) != null) {
-                observer.gotAHref(val, contextURL, data);
-            }
-        } else if (name == HTML.IMG) {
-            if ((val = attributes.getValue("src")) != null) {
-                observer.gotImgSrc(val, contextURL, data);
-            }
-        } else if (name == HTML.BASE) {
-            if ((val = attributes.getValue("href")) != null) {
-                observer.gotBaseHref(val, contextURL, data);
-                if (contextURL != null) {
-                    try {
-                        contextURL = new URL(contextURL, val);
-                    } catch (MalformedURLException ex) {
-                        System.err.println("Bad <base> URL: " + val + ".");
-                        System.err.println(ex.getMessage());
-                    }
-                }
-            }
-        } else if (name == HTML.AREA) {
-            if ((val = attributes.getValue("href")) != null) {
-                observer.gotAreaHref(val, contextURL, data);
-            }
-        } else if (name == HTML.FRAME) {
-            if ((val = attributes.getValue("src")) != null) {
-                observer.gotFrameSrc(val, contextURL, data);
-            }
-        }
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/NormalizeHtml.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/NormalizeHtml.java
deleted file mode 100644
index b590eda..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/NormalizeHtml.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * $Id$
- *
- * Copyright 1997 Hewlett-Packard Company
- *
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import hplb.xml.*;
-import hplb.org.w3c.dom.*;
-import java.io.*;
-
-/**
- * Reads an HTML document on System.in, "normalizes" it in a couple of ways, and
- * writes it to System.out. In the process HTML4.0 element names are converted to
- * upper case, attribute names are converted to lower case, all attribute values
- * gets enclosed in double quotes, all non-empty elements with an optional and
- * omitted end tag are given an end tag.
- *
- * @author      Anders Kristensen
- */
-public class NormalizeHtml {
-    static PrintStream out = System.out;
-
-    public static void usage() {
-        System.exit(1);
-    }
-
-    public static void main(String[] args) throws Exception {
-        /*
-        Tokenizer tok = new Tokenizer();
-        tok.setDocumentHandler(new NormalizeHtml());
-        HTML.applyHacks(tok);
-        //tok.rcgnzEntities = false;
-        tok.rcgnzCDATA = false;
-        tok.atomize = true;
-        tok.parse(System.in);
-        */
-        HtmlXmlParser parser = new HtmlXmlParser();
-        Tokenizer tok = parser.getTokenizer();
-        tok.rcgnzEntities = false;
-        tok.rcgnzCDATA = false;
-        tok.rcgnzComments = false;
-        tok.atomize = true;
-        print(parser.parse(System.in));
-    }
-
-    public static void print(Document doc) {
-        //print(doc.getDocumentElement());
-        NodeIterator iter = doc.getChildNodes();
-        while (iter.toNext() != null) {
-            printNode(iter.getCurrent());
-        }
-    }
-
-    public static void printNode(Node node) {
-        if (node instanceof Document) print((Document) node);
-        else if (node instanceof Element) print((Element) node);
-        else if (node instanceof Text) print((Text) node);
-        else System.err.println("Error: non-text, non-element node ignored.");
-    }
-
-    public static void print(Text text) {
-        //out.print(encodeText(text.getData(), false));
-        out.print(text.getData());
-    }
-
-    public static void print(Element elm) {
-        String tagName      = elm.getTagName();
-        AttributeList attrs = elm.attributes();
-        boolean isHtmlElm = isHtmlElm(tagName);
-        boolean isEmpty = (elm.getFirstChild() == null);
-        boolean isHtmlEmptyElm =
-              (tagName == HTML.AREA
-            || tagName == HTML.BASE
-            || tagName == HTML.BR
-            || tagName == HTML.COL
-            || tagName == HTML.FRAME
-            || tagName == HTML.HR
-            || tagName == HTML.IMG
-            || tagName == HTML.LINK
-            || tagName == HTML.META
-            || tagName == HTML.PARAM);
-
-        if (isHtmlElm) tagName = tagName.toUpperCase();
-
-        // print start tag and attribute name-value pairs
-        out.print("<" + tagName);
-        int len = attrs.getLength();
-        for (int i = 0; i < len; i++) {
-            print(attrs.item(i), isHtmlElm);
-        }
-        if (isEmpty && !isHtmlEmptyElm) out.print("/");
-        out.print(">");
-        if (isEmpty) return;
-
-        // print content
-        NodeIterator iter = elm.getChildNodes();
-        while (iter.toNext() != null) {
-            printNode(iter.getCurrent());
-        }
-
-        // print end tag
-        out.print("</" + tagName + ">");
-    }
-
-    public static void print(Attribute attr, boolean toLower) {
-        String a = attr.getName();
-        out.print(" " + (toLower ? a.toLowerCase() : a)
-                + "=\"" + encodeText(attr.toString(), true) +'"');
-    }
-
-    public static String encodeText(String s, boolean attr) {
-        StringBuffer sb = new StringBuffer();
-        int ch, len = s.length();
-
-        for (int i = 0; i < len; i++) {
-            ch = s.charAt(i);
-            if (ch == '"') sb.append("&quot;");
-            /* cause we don't recognize markup within PCDATA and attr values
-            else if (ch == '&') sb.append("&amp;");
-            else if (!attr && ch == '<') sb.append("&lt;");
-            else if (!attr && ch == '>') sb.append("&gt;");
-            else if ((" \r\n\t".indexOf((char) ch) != -1)
-                     && (ch <= 31 || ch >= 127)) sb.append("&#"+ch+";");
-            */
-            else sb.append((char) ch);
-        }
-        return sb.toString();
-    }
-
-    public static boolean isHtmlElm(String tagName) {
-        int len = HTML.elements.length;
-        for (int i = 0; i < len; i++) {
-            if (tagName == HTML.elements[i]) return true;
-        }
-        return false;
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/RmMarkup.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/RmMarkup.java
deleted file mode 100644
index dcb6443..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/RmMarkup.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import hplb.xml.Tokenizer;
-import hplb.org.xml.sax.*;
-import java.io.*;
-
-public class RmMarkup extends HandlerBase {
-    static Tokenizer tok;
-    static Writer out = new OutputStreamWriter(System.out);
-
-    public void characters (char ch[], int start, int length) throws IOException {
-        out.write(ch, start, length);
-    }
-
-    public static void main(String[] args) throws Exception {
-        tok = new Tokenizer();
-        tok.setDocumentHandler(new RmMarkup());
-        TokTest.args(args, tok);
-        tok.parse(System.in);
-        out.flush();
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/TokTest.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/TokTest.java
deleted file mode 100644
index 07d3457..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/TokTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import hplb.xml.*;
-import hplb.org.xml.sax.*;
-import java.io.*;
-
-/**
- * Test of Tokenizer.
- * Usage: TokTest [-w] < html-file
- * @author  Anders Kristensen
- */
-public class TokTest implements DocumentHandler {
-    static Tokenizer tok;
-    static PrintStream out = System.out;
-    int n = 60;
-    int n2 = (n-3)/2;
-    
-    public void startDocument () {
-        out.println("START DOC");
-    }
-    
-    public void endDocument () {
-        out.println("END DOC");
-    }
-    
-    public void doctype (String name, String publicID, String systemID) {
-        out.println("DOC TYPE " + name + ", " + publicID + ", " + systemID);
-    }
-
-    public void startElement (String name, AttributeMap attributes) {
-        out.println("START " + name + ", " + attributes);
-    }
-
-    public void endElement (String name) {
-        out.println("END   " + name);
-    }
-
-    public void characters (char ch[], int start, int length) {
-        //out.println("Chars: " + new String(ch, start, length));
-        out.println("Chars: " + compact(new String(ch, start, length)));
-    }
-
-    public void ignorable (char ch[], int start, int length) {
-        out.println("Ignorable: " + compact(new String(ch, start, length)));
-    }
-
-    public void processingInstruction (String name, String remainder) {
-        out.println("PI: " + name + ", " + compact(remainder));
-    }
-    
-    // Returns short description of PCDATA argument.
-    public String compact(char[] buf) {
-        return compact(new String(buf));
-    }
-    
-    public String compact(String s) {
-        if (s.length() < n) {
-            return "[" + noCRLF(s) + "]";
-        } else {
-            return "[" + noCRLF(s.substring(0, n2)) + "..." +
-                   noCRLF(s.substring(s.length() - n2)) + "]";
-        }
-    }
-    
-    private static String noCRLF(String s) {
-        return s.replace('\r', ' ').replace('\n', ' ');
-    }
-    
-    /**
-     * Process options in 'args' vector and apply to the supplied Tokenizer.
-     */
-    public static void args(String[] args, Tokenizer tok) {
-        // case mappoing: tags/attr names/attr values, upper/lower/depends...
-        for (int i = 0; i < args.length; i++) {
-            if ("-w".equals(args[i])) {
-                tok.rcgnzWS = true;
-            } else if ("-d".equals(args[i])) {
-                tok.rcgnzComments = false;
-            } else if ("-c".equals(args[i])) {
-                tok.rcgnzCDATA = false;
-            } else if ("-e".equals(args[i])) {
-                tok.rcgnzEntities = false;
-            } else if ("-h".equals(args[i])) {
-                HTML.applyHacks(tok);
-            } else {
-                System.err.println("Unrecognized option: " + args[i]);
-            }
-        }
-    }
-    
-    public static void main(String[] args) throws Exception {
-        tok = new Tokenizer();
-        tok.setDocumentHandler(new TokTest());
-        args(args, tok);
-        tok.parse(System.in);
-    }
-}
diff --git a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/UrlScanner.java b/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/UrlScanner.java
deleted file mode 100644
index b86f8f5..0000000
--- a/sandbox/contributions/webcrawler-LARM/src/hplb/xml/util/UrlScanner.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * $Id$
- * 
- * Copyright 1997 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- * 
- * Copyright 1998 Hewlett-Packard Company
- * 
- * This file may be copied, modified and distributed only in
- * accordance with the terms of the limited licence contained
- * in the accompanying file LICENSE.TXT.
- */
-
-package hplb.xml.util;
-
-import java.net.*;
-import java.io.*;
-import java.util.Date;
-
-/**
- * Scans an HTML Web object for embedded link and prints them on stdout.
- * <b>Usage</b>:
- * <pre>
- *  java hplb.www.client.UrlScan [-t] [-v] [-h proxy-host] [-p proxy-port] URL
- *  where -t means test validity of embedded URLs and
- *        -v means be verbose
- * </pre>
- * 
- * @author      Anders Kristensen
- */
-public class UrlScanner implements HtmlObserver {
-
-    // should use getenv and/or getProperty for these:
-    static String   proxyHost;
-    static String   proxyPort;
-    static boolean  test;
-    static boolean  verbose;
-    
-    public static void usage() {
-        PrintStream out = System.out;
-        out.println("Usage: UrlScan [-v] [-t] <baseurl>");
-        out.println("Extracts URLs from System.in and writes them on stdout.");
-        out.println("  -v  verbose mode");
-        out.println("  -t  test links (using HTTP HEAD requests)");
-        
-        System.exit(1);
-    }
-    
-    public static void main(String[] args) throws Exception {
-        URL url = null;
-        //HttpClient cl;
-        //HttpResponse res = null;
-    
-        try {
-            url = new URL(args[args.length-1]);
-            for (int i = 0; i < args.length - 1; i++) {
-                if ("-t".equals(args[i])) {
-                    test = true;
-                } else if ("-v".equals(args[i])) {
-                    verbose = true;
-                } else if ("-h".equals(args[i])) {
-                    proxyHost = args[++i];
-                } else if ("-p".equals(args[i])) {
-                    proxyPort = args[++i];
-                } else {
-                    usage();
-                }
-            }
-        } catch (Exception e) {
-            usage();
-        }
-
-        //cl = new HttpClient(url);
-        if (proxyHost != null) {
-            System.getProperties().put("http.proxyHost", proxyHost);
-        }
-        if (proxyPort != null) {
-            System.getProperties().put("http.proxyPort", proxyPort);
-        }
-        /*
-        try {
-            res = cl.get();
-        } catch (UnknownHostException e) {
-            panic("Couldn't connect to host " + e.getMessage());
-        } catch (IOException e) {
-            panic("I/O exception");
-        } catch (Exception e) {
-            panic("Error: " + e.getMessage());
-        }
-        */
-        
-        new HtmlScanner(url, new UrlScanner());
-    }
-
-    public static void panic(String reason) {
-        System.out.println(reason);
-        System.exit(1);
-    }
-
-    public void gotAHref(String urlStr, URL contextUrl, Object data) {
-        try {
-            URL url = new URL(contextUrl, urlStr);
-            System.out.print(url.toExternalForm());
-            if (test) testLink(url);
-            System.out.println();
-        } catch (Exception e) {
-            if (verbose) e.printStackTrace();
-        }
-    }
-
-    /** Invoked when the scanner finds an &lt;img src=""&gt; URL. */
-    public void gotImgSrc(String urlStr, URL contextUrl, Object data) {
-        try {
-            URL url = new URL(contextUrl, urlStr);
-            System.out.print(url.toExternalForm());
-            if (test) testLink(url);
-            System.out.println();
-        } catch (Exception e) {
-            if (verbose) e.printStackTrace();
-        }
-    }
-
-    /** Invoked when the scanner finds a &lt;base href=""&gt; URL. */
-    public void gotBaseHref(String urlStr, URL contextUrl, Object data ) {
-        if (verbose) {
-            System.out.println("gotBASEHREF: " + urlStr);
-            System.out.println("               " + contextUrl);
-        }
-    }
-
-    /** Invoked when the scanner finds a &lt;area href=""&gt; URL. */
-    public void gotAreaHref(String urlStr, URL contextUrl, Object data ) {
-        if (verbose) {
-            System.out.println("gotAreaHref:   " + urlStr);
-            System.out.println("               " + contextUrl);
-        }
-    }
-
-    /** Invoked when the scanner finds an &lt;frame src=""&gt; URL. */
-    public void gotFrameSrc(String urlStr, URL contextUrl, Object data ) {
-        try {
-            URL url = new URL(contextUrl, urlStr);
-            System.out.print(url.toExternalForm());
-            if (test) testLink(url);
-            System.out.println();
-        } catch (Exception e) {
-            if (verbose) e.printStackTrace();
-        }
-    }
-    
-    public static void testLink(URL url) throws IOException {
-        throw new IOException("Not implemented");
-        /*
-        HttpClient cl = new HttpClient(url);
-        if (proxyHost != null)
-            cl.setProxyAddr(proxyHost, proxyPort);
-        HttpResponse res = cl.head();
-
-        System.out.print(" " + res.getStatusCode());
-        if (verbose) System.out.print(" " + res.getReason());
-        */
-    }
-}

