GitDiffStart: f330cf65adc5bd11d72bd3f8e78f20112da1fed5 | Tue May 22 02:50:22 2012 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/Codec.java b/lucene/core/src/java/org/apache/lucene/codecs/Codec.java
index 9a8993a..c6bea99 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/Codec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/Codec.java
@@ -70,7 +70,7 @@ public abstract class Codec implements NamedSPILoader.NamedSPI {
   public abstract FieldInfosFormat fieldInfosFormat();
   
   /** Encodes/decodes segments file */
-  public abstract SegmentInfosFormat segmentInfosFormat();
+  public abstract SegmentInfoFormat segmentInfosFormat();
   
   /** Encodes/decodes document normalization values */
   public abstract NormsFormat normsFormat();
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoFormat.java
new file mode 100644
index 0000000..de8b365
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoFormat.java
@@ -0,0 +1,33 @@
+package org.apache.lucene.codecs;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.SegmentInfo;
+
+/**
+ * Expert: Controls the format of the 
+ * {@link SegmentInfo} (segment metadata file).
+ * <p>
+ * 
+ * @see SegmentInfo
+ * @lucene.experimental
+ */
+public abstract class SegmentInfoFormat {
+  public abstract SegmentInfoReader getSegmentInfosReader();
+  public abstract SegmentInfoWriter getSegmentInfosWriter();
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoReader.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoReader.java
new file mode 100644
index 0000000..09eeab6
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoReader.java
@@ -0,0 +1,41 @@
+package org.apache.lucene.codecs;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+
+/**
+ * Specifies an API for classes that can read {@link SegmentInfo} information.
+ * @lucene.experimental
+ */
+
+public abstract class SegmentInfoReader {
+
+  /**
+   * Read {@link SegmentInfo} data from a directory.
+   * @param directory directory to read from
+   * @param segmentName name of the segment to read
+   * @return infos instance to be populated with data
+   * @throws IOException
+   */
+  public abstract SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException;
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoWriter.java
new file mode 100644
index 0000000..988aca0
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfoWriter.java
@@ -0,0 +1,39 @@
+package org.apache.lucene.codecs;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+
+/**
+ * Specifies an API for classes that can write out {@link SegmentInfo} data.
+ * @lucene.experimental
+ */
+
+public abstract class SegmentInfoWriter {
+
+  /**
+   * Write {@link SegmentInfo} data. 
+   * @throws IOException
+   */
+  public abstract void write(Directory dir, SegmentInfo info, FieldInfos fis, IOContext ioContext) throws IOException;
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosFormat.java
deleted file mode 100644
index f0ce464..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosFormat.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.apache.lucene.codecs;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Set;
-
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos; // javadocs
-
-/**
- * Expert: Controls the format of the 
- * {@link SegmentInfos} (segments file).
- * <p>
- * NOTE: This isn't a per-segment file. If you change the format, other versions
- * of lucene won't be able to read it.
- * 
- * @see SegmentInfos
- * @lucene.experimental
- */
-
-// nocommit rename (remove the s?)
-
-// TODO: would be great to handle this situation better.
-// ideally a custom implementation could implement two-phase commit differently,
-// (e.g. atomic rename), and ideally all versions of lucene could still read it.
-// but this is just reflecting reality as it is today...
-//
-// also, perhaps the name should change (to cover all global files like .fnx?)
-// then again, maybe we can just remove that file...
-public abstract class SegmentInfosFormat {
-  public abstract SegmentInfosReader getSegmentInfosReader();
-  public abstract SegmentInfosWriter getSegmentInfosWriter();
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosReader.java
deleted file mode 100644
index 55a131a..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosReader.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.apache.lucene.codecs;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-
-/**
- * Specifies an API for classes that can read {@link SegmentInfos} information.
- * @lucene.experimental
- */
-
-// nocommit rename (remove the s?)
-
-public abstract class SegmentInfosReader {
-
-  /**
-   * Read {@link SegmentInfos} data from a directory.
-   * @param directory directory to read from
-   * @param segmentsFileName name of the "segments_N" file
-   * @param header input of "segments_N" file after reading preamble
-   * @param infos empty instance to be populated with data
-   * @throws IOException
-   */
-  public abstract SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException;
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosWriter.java
deleted file mode 100644
index 5dd7e10..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/SegmentInfosWriter.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.apache.lucene.codecs;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexOutput;
-
-/**
- * Specifies an API for classes that can write out {@link SegmentInfos} data.
- * @lucene.experimental
- */
-
-// nocommit rename (remove the s?)
-
-public abstract class SegmentInfosWriter {
-
-  /**
-   * Write {@link SegmentInfos} data without closing the output. The returned
-   * output will become finished only after a successful completion of
-   * "two phase commit" that first calls {@link #prepareCommit(IndexOutput)} and
-   * then {@link #finishCommit(IndexOutput)}.
-   * @param dir directory to write data to
-   * @param segmentsFileName name of the "segments_N" file to create
-   * @param infos data to write
-   * @return an instance of {@link IndexOutput} to be used in subsequent "two
-   * phase commit" operations as described above.
-   * @throws IOException
-   */
-  public abstract void write(Directory dir, SegmentInfo info, FieldInfos fis, IOContext ioContext) throws IOException;
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
index 749d3f6..9a6ccb9 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/appending/AppendingCodec.java
@@ -23,7 +23,7 @@ import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40Codec;
@@ -31,7 +31,7 @@ import org.apache.lucene.codecs.lucene40.Lucene40DocValuesFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40NormsFormat;
-import org.apache.lucene.codecs.lucene40.Lucene40SegmentInfosFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40SegmentInfoFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40TermVectorsFormat;
 
@@ -47,7 +47,7 @@ public class AppendingCodec extends Codec {
   }
 
   private final PostingsFormat postings = new AppendingPostingsFormat();
-  private final SegmentInfosFormat infos = new Lucene40SegmentInfosFormat();
+  private final SegmentInfoFormat infos = new Lucene40SegmentInfoFormat();
   private final StoredFieldsFormat fields = new Lucene40StoredFieldsFormat();
   private final FieldInfosFormat fieldInfos = new Lucene40FieldInfosFormat();
   private final TermVectorsFormat vectors = new Lucene40TermVectorsFormat();
@@ -76,7 +76,7 @@ public class AppendingCodec extends Codec {
   }
 
   @Override
-  public SegmentInfosFormat segmentInfosFormat() {
+  public SegmentInfoFormat segmentInfosFormat() {
     return infos;
   }
   
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
index 203e972..f3e2864 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xCodec.java
@@ -28,7 +28,7 @@ import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PerDocConsumer;
 import org.apache.lucene.codecs.PerDocProducer;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
@@ -58,7 +58,7 @@ public class Lucene3xCodec extends Codec {
   
   private final FieldInfosFormat fieldInfosFormat = new Lucene3xFieldInfosFormat();
 
-  private final SegmentInfosFormat infosFormat = new Lucene3xSegmentInfosFormat();
+  private final SegmentInfoFormat infosFormat = new Lucene3xSegmentInfoFormat();
   
   private final Lucene3xNormsFormat normsFormat = new Lucene3xNormsFormat();
   
@@ -112,7 +112,7 @@ public class Lucene3xCodec extends Codec {
   }
 
   @Override
-  public SegmentInfosFormat segmentInfosFormat() {
+  public SegmentInfoFormat segmentInfosFormat() {
     return infosFormat;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoFormat.java
new file mode 100644
index 0000000..dd1da70
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoFormat.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.codecs.lucene3x;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Set;
+
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+
+/**
+ * Lucene3x ReadOnly SegmentInfoFormat implementation
+ * @deprecated (4.0) This is only used to read indexes created
+ * before 4.0.
+ * @lucene.experimental
+ */
+@Deprecated
+public class Lucene3xSegmentInfoFormat extends SegmentInfoFormat {
+  private final SegmentInfoReader reader = new Lucene3xSegmentInfoReader();
+
+  /** This format adds optional per-segment String
+   *  diagnostics storage, and switches userData to Map */
+  public static final int FORMAT_DIAGNOSTICS = -9;
+
+  /** Each segment records whether it has term vectors */
+  public static final int FORMAT_HAS_VECTORS = -10;
+
+  /** Each segment records the Lucene version that created it. */
+  public static final int FORMAT_3_1 = -11;
+
+  /** Each segment records whether its postings are written
+   *  in the new flex format */
+  public static final int FORMAT_4X_UPGRADE = -12;
+
+  /** Extension used for saving each SegmentInfo, once a 3.x
+   *  index is first committed to with 4.0. */
+  public static final String SI_EXTENSION = "si";
+  
+  @Override
+  public SegmentInfoReader getSegmentInfosReader() {
+    return reader;
+  }
+
+  @Override
+  public SegmentInfoWriter getSegmentInfosWriter() {
+    throw new UnsupportedOperationException("this codec can only be used for reading");
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader.java
new file mode 100644
index 0000000..e1ff7d4
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfoReader.java
@@ -0,0 +1,251 @@
+package org.apache.lucene.codecs.lucene3x;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.IndexFormatTooNewException;
+import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.index.SegmentInfos;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.CompoundFileDirectory;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Lucene 3x implementation of {@link SegmentInfoReader}.
+ * @lucene.experimental
+ * @deprecated
+ */
+@Deprecated
+public class Lucene3xSegmentInfoReader extends SegmentInfoReader {
+
+  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {
+    infos.version = input.readLong(); // read version
+    infos.counter = input.readInt(); // read counter
+    Lucene3xSegmentInfoReader reader = new Lucene3xSegmentInfoReader();
+    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos
+      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);
+      if (si.getVersion() == null) {
+        // Could be a 3.0 - try to open the doc stores - if it fails, it's a
+        // 2.x segment, and an IndexFormatTooOldException will be thrown,
+        // which is what we want.
+        Directory dir = directory;
+        if (si.getDocStoreOffset() != -1) {
+          if (si.getDocStoreIsCompoundFile()) {
+            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(
+                si.getDocStoreSegment(), "",
+                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);
+          }
+        } else if (si.getUseCompoundFile()) {
+          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(
+              si.name, "", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);
+        }
+
+        try {
+          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());
+        } finally {
+          // If we opened the directory, close it
+          if (dir != directory) dir.close();
+        }
+          
+        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next
+        // time the segment is read, its version won't be null and we won't
+        // need to open FieldsReader every time for each such segment.
+        si.setVersion("3.0");
+      } else if (si.getVersion().equals("2.x")) {
+        // If it's a 3x index touched by 3.1+ code, then segments record their
+        // version, whether they are 2.x ones or not. We detect that and throw
+        // appropriate exception.
+        throw new IndexFormatTooOldException("segment " + si.name + " in resource " + input, si.getVersion());
+      }
+      infos.add(si);
+    }
+      
+    infos.userData = input.readStringStringMap();
+  }
+
+  @Override
+  public SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException { 
+    return read(directory, segmentName, Lucene3xSegmentInfoFormat.FORMAT_4X_UPGRADE, context);
+  }
+
+  public SegmentInfo read(Directory directory, String segmentName, int format, IOContext context) throws IOException { 
+
+    // NOTE: this is NOT how 3.x is really written...
+    String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene3xSegmentInfoFormat.SI_EXTENSION);
+
+    boolean success = false;
+
+    IndexInput input = directory.openInput(fileName, context);
+
+    try {
+      SegmentInfo si = readSegmentInfo(segmentName, directory, format, input);
+      success = true;
+      return si;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(input);
+      } else {
+        input.close();
+      }
+    }
+  }
+
+  private static void addIfExists(Directory dir, Set<String> files, String fileName) throws IOException {
+    if (dir.fileExists(fileName)) {
+      files.add(fileName);
+    }
+  }
+
+  private SegmentInfo readSegmentInfo(String segmentName, Directory dir, int format, IndexInput input) throws IOException {
+    // check that it is a format we can understand
+    if (format > Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS) {
+      throw new IndexFormatTooOldException(input, format,
+                                           Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS, Lucene3xSegmentInfoFormat.FORMAT_4X_UPGRADE);
+    }
+    if (format < Lucene3xSegmentInfoFormat.FORMAT_4X_UPGRADE) {
+      throw new IndexFormatTooNewException(input, format,
+                                           Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS, Lucene3xSegmentInfoFormat.FORMAT_4X_UPGRADE);
+    }
+    final String version;
+    if (format <= Lucene3xSegmentInfoFormat.FORMAT_3_1) {
+      version = input.readString();
+    } else {
+      version = null;
+    }
+
+    // NOTE: we ignore this and use the incoming arg
+    // instead, if it's non-null:
+    final String name = input.readString();
+    if (segmentName == null) {
+      segmentName = name;
+    }
+
+    final int docCount = input.readInt();
+    final long delGen = input.readLong();
+    final int docStoreOffset = input.readInt();
+    final String docStoreSegment;
+    final boolean docStoreIsCompoundFile;
+    if (docStoreOffset != -1) {
+      docStoreSegment = input.readString();
+      docStoreIsCompoundFile = input.readByte() == SegmentInfo.YES;
+    } else {
+      docStoreSegment = name;
+      docStoreIsCompoundFile = false;
+    }
+
+    // pre-4.0 indexes write a byte if there is a single norms file
+    byte b = input.readByte();
+
+    //System.out.println("version=" + version + " name=" + name + " docCount=" + docCount + " delGen=" + delGen + " dso=" + docStoreOffset + " dss=" + docStoreSegment + " dssCFs=" + docStoreIsCompoundFile + " b=" + b + " format=" + format);
+
+    assert 1 == b : "expected 1 but was: "+ b + " format: " + format;
+    final int numNormGen = input.readInt();
+    final Map<Integer,Long> normGen;
+    if (numNormGen == SegmentInfo.NO) {
+      normGen = null;
+    } else {
+      normGen = new HashMap<Integer, Long>();
+      for(int j=0;j<numNormGen;j++) {
+        normGen.put(j, input.readLong());
+      }
+    }
+    final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
+
+    final int delCount = input.readInt();
+    assert delCount <= docCount;
+
+    final boolean hasProx = input.readByte() == 1;
+
+    final Map<String,String> diagnostics = input.readStringStringMap();
+
+    if (format <= Lucene3xSegmentInfoFormat.FORMAT_HAS_VECTORS) {
+      // NOTE: unused
+      final int hasVectors = input.readByte();
+    }
+
+    final Set<String> files;
+    if (format == Lucene3xSegmentInfoFormat.FORMAT_4X_UPGRADE) {
+      files = input.readStringSet();
+    } else {
+      // Replicate logic from 3.x's SegmentInfo.files():
+      files = new HashSet<String>();
+      if (isCompoundFile) {
+        files.add(IndexFileNames.segmentFileName(name, "", IndexFileNames.COMPOUND_FILE_EXTENSION));
+      } else {
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xFieldInfosReader.FIELD_INFOS_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.FREQ_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.PROX_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.TERMS_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.TERMS_INDEX_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xNormsProducer.NORMS_EXTENSION));
+      }
+
+      if (docStoreOffset != -1) {
+        if (docStoreIsCompoundFile) {
+          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION));
+        } else {
+          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION));
+          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xStoredFieldsReader.FIELDS_EXTENSION));
+          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION));
+          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION));
+          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION));
+        }
+      } else if (!isCompoundFile) {
+        files.add(IndexFileNames.segmentFileName(segmentName, "", Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION));
+        files.add(IndexFileNames.segmentFileName(segmentName, "", Lucene3xStoredFieldsReader.FIELDS_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION));
+        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION));
+      }
+
+      if (normGen != null) {
+        for(Map.Entry<Integer,Long> ent : normGen.entrySet()) {
+          long gen = ent.getValue();
+          if (gen >= SegmentInfo.YES) {
+            // Definitely a separate norm file, with generation:
+            files.add(IndexFileNames.fileNameFromGeneration(segmentName, "s" + ent.getKey(), gen));
+          } else if (gen == SegmentInfo.NO) {
+            // No separate norm
+          } else {
+            // nocommit -- i thought _X_N.sY files were pre-3.0...????
+            assert false;
+          }
+        }
+      }
+    }
+
+    SegmentInfo info = new SegmentInfo(dir, version, segmentName, docCount, docStoreOffset,
+                                       docStoreSegment, docStoreIsCompoundFile, normGen, isCompoundFile,
+                                       delCount, null, diagnostics);
+    info.setDelGen(delGen);
+    info.setFiles(files);
+    return info;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosFormat.java
deleted file mode 100644
index 4aa019d..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosFormat.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.apache.lucene.codecs.lucene3x;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Set;
-
-import org.apache.lucene.codecs.SegmentInfosFormat;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.codecs.SegmentInfosWriter;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-
-/**
- * Lucene3x ReadOnly SegmentInfosFormat implementation
- * @deprecated (4.0) This is only used to read indexes created
- * before 4.0.
- * @lucene.experimental
- */
-@Deprecated
-public class Lucene3xSegmentInfosFormat extends SegmentInfosFormat {
-  private final SegmentInfosReader reader = new Lucene3xSegmentInfosReader();
-
-  /** This format adds optional per-segment String
-   *  diagnostics storage, and switches userData to Map */
-  public static final int FORMAT_DIAGNOSTICS = -9;
-
-  /** Each segment records whether it has term vectors */
-  public static final int FORMAT_HAS_VECTORS = -10;
-
-  /** Each segment records the Lucene version that created it. */
-  public static final int FORMAT_3_1 = -11;
-
-  /** Each segment records whether its postings are written
-   *  in the new flex format */
-  public static final int FORMAT_4X_UPGRADE = -12;
-
-  /** Extension used for saving each SegmentInfo, once a 3.x
-   *  index is first committed to with 4.0. */
-  public static final String SI_EXTENSION = "si";
-  
-  @Override
-  public SegmentInfosReader getSegmentInfosReader() {
-    return reader;
-  }
-
-  @Override
-  public SegmentInfosWriter getSegmentInfosWriter() {
-    throw new UnsupportedOperationException("this codec can only be used for reading");
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader.java
deleted file mode 100644
index 13e97d1..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xSegmentInfosReader.java
+++ /dev/null
@@ -1,251 +0,0 @@
-package org.apache.lucene.codecs.lucene3x;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.IndexFormatTooNewException;
-import org.apache.lucene.index.IndexFormatTooOldException;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.CompoundFileDirectory;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Lucene 3x implementation of {@link SegmentInfosReader}.
- * @lucene.experimental
- * @deprecated
- */
-@Deprecated
-public class Lucene3xSegmentInfosReader extends SegmentInfosReader {
-
-  public static void readLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format) throws IOException {
-    infos.version = input.readLong(); // read version
-    infos.counter = input.readInt(); // read counter
-    Lucene3xSegmentInfosReader reader = new Lucene3xSegmentInfosReader();
-    for (int i = input.readInt(); i > 0; i--) { // read segmentInfos
-      SegmentInfo si = reader.readSegmentInfo(null, directory, format, input);
-      if (si.getVersion() == null) {
-        // Could be a 3.0 - try to open the doc stores - if it fails, it's a
-        // 2.x segment, and an IndexFormatTooOldException will be thrown,
-        // which is what we want.
-        Directory dir = directory;
-        if (si.getDocStoreOffset() != -1) {
-          if (si.getDocStoreIsCompoundFile()) {
-            dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(
-                si.getDocStoreSegment(), "",
-                Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION), IOContext.READONCE, false);
-          }
-        } else if (si.getUseCompoundFile()) {
-          dir = new CompoundFileDirectory(dir, IndexFileNames.segmentFileName(
-              si.name, "", IndexFileNames.COMPOUND_FILE_EXTENSION), IOContext.READONCE, false);
-        }
-
-        try {
-          Lucene3xStoredFieldsReader.checkCodeVersion(dir, si.getDocStoreSegment());
-        } finally {
-          // If we opened the directory, close it
-          if (dir != directory) dir.close();
-        }
-          
-        // Above call succeeded, so it's a 3.0 segment. Upgrade it so the next
-        // time the segment is read, its version won't be null and we won't
-        // need to open FieldsReader every time for each such segment.
-        si.setVersion("3.0");
-      } else if (si.getVersion().equals("2.x")) {
-        // If it's a 3x index touched by 3.1+ code, then segments record their
-        // version, whether they are 2.x ones or not. We detect that and throw
-        // appropriate exception.
-        throw new IndexFormatTooOldException("segment " + si.name + " in resource " + input, si.getVersion());
-      }
-      infos.add(si);
-    }
-      
-    infos.userData = input.readStringStringMap();
-  }
-
-  @Override
-  public SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException { 
-    return read(directory, segmentName, Lucene3xSegmentInfosFormat.FORMAT_4X_UPGRADE, context);
-  }
-
-  public SegmentInfo read(Directory directory, String segmentName, int format, IOContext context) throws IOException { 
-
-    // NOTE: this is NOT how 3.x is really written...
-    String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene3xSegmentInfosFormat.SI_EXTENSION);
-
-    boolean success = false;
-
-    IndexInput input = directory.openInput(fileName, context);
-
-    try {
-      SegmentInfo si = readSegmentInfo(segmentName, directory, format, input);
-      success = true;
-      return si;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(input);
-      } else {
-        input.close();
-      }
-    }
-  }
-
-  private static void addIfExists(Directory dir, Set<String> files, String fileName) throws IOException {
-    if (dir.fileExists(fileName)) {
-      files.add(fileName);
-    }
-  }
-
-  private SegmentInfo readSegmentInfo(String segmentName, Directory dir, int format, IndexInput input) throws IOException {
-    // check that it is a format we can understand
-    if (format > Lucene3xSegmentInfosFormat.FORMAT_DIAGNOSTICS) {
-      throw new IndexFormatTooOldException(input, format,
-                                           Lucene3xSegmentInfosFormat.FORMAT_DIAGNOSTICS, Lucene3xSegmentInfosFormat.FORMAT_4X_UPGRADE);
-    }
-    if (format < Lucene3xSegmentInfosFormat.FORMAT_4X_UPGRADE) {
-      throw new IndexFormatTooNewException(input, format,
-                                           Lucene3xSegmentInfosFormat.FORMAT_DIAGNOSTICS, Lucene3xSegmentInfosFormat.FORMAT_4X_UPGRADE);
-    }
-    final String version;
-    if (format <= Lucene3xSegmentInfosFormat.FORMAT_3_1) {
-      version = input.readString();
-    } else {
-      version = null;
-    }
-
-    // NOTE: we ignore this and use the incoming arg
-    // instead, if it's non-null:
-    final String name = input.readString();
-    if (segmentName == null) {
-      segmentName = name;
-    }
-
-    final int docCount = input.readInt();
-    final long delGen = input.readLong();
-    final int docStoreOffset = input.readInt();
-    final String docStoreSegment;
-    final boolean docStoreIsCompoundFile;
-    if (docStoreOffset != -1) {
-      docStoreSegment = input.readString();
-      docStoreIsCompoundFile = input.readByte() == SegmentInfo.YES;
-    } else {
-      docStoreSegment = name;
-      docStoreIsCompoundFile = false;
-    }
-
-    // pre-4.0 indexes write a byte if there is a single norms file
-    byte b = input.readByte();
-
-    //System.out.println("version=" + version + " name=" + name + " docCount=" + docCount + " delGen=" + delGen + " dso=" + docStoreOffset + " dss=" + docStoreSegment + " dssCFs=" + docStoreIsCompoundFile + " b=" + b + " format=" + format);
-
-    assert 1 == b : "expected 1 but was: "+ b + " format: " + format;
-    final int numNormGen = input.readInt();
-    final Map<Integer,Long> normGen;
-    if (numNormGen == SegmentInfo.NO) {
-      normGen = null;
-    } else {
-      normGen = new HashMap<Integer, Long>();
-      for(int j=0;j<numNormGen;j++) {
-        normGen.put(j, input.readLong());
-      }
-    }
-    final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
-
-    final int delCount = input.readInt();
-    assert delCount <= docCount;
-
-    final boolean hasProx = input.readByte() == 1;
-
-    final Map<String,String> diagnostics = input.readStringStringMap();
-
-    if (format <= Lucene3xSegmentInfosFormat.FORMAT_HAS_VECTORS) {
-      // NOTE: unused
-      final int hasVectors = input.readByte();
-    }
-
-    final Set<String> files;
-    if (format == Lucene3xSegmentInfosFormat.FORMAT_4X_UPGRADE) {
-      files = input.readStringSet();
-    } else {
-      // Replicate logic from 3.x's SegmentInfo.files():
-      files = new HashSet<String>();
-      if (isCompoundFile) {
-        files.add(IndexFileNames.segmentFileName(name, "", IndexFileNames.COMPOUND_FILE_EXTENSION));
-      } else {
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xFieldInfosReader.FIELD_INFOS_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.FREQ_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.PROX_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.TERMS_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xPostingsFormat.TERMS_INDEX_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xNormsProducer.NORMS_EXTENSION));
-      }
-
-      if (docStoreOffset != -1) {
-        if (docStoreIsCompoundFile) {
-          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION));
-        } else {
-          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION));
-          files.add(IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xStoredFieldsReader.FIELDS_EXTENSION));
-          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION));
-          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION));
-          addIfExists(dir, files, IndexFileNames.segmentFileName(docStoreSegment, "", Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION));
-        }
-      } else if (!isCompoundFile) {
-        files.add(IndexFileNames.segmentFileName(segmentName, "", Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION));
-        files.add(IndexFileNames.segmentFileName(segmentName, "", Lucene3xStoredFieldsReader.FIELDS_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION));
-        addIfExists(dir, files, IndexFileNames.segmentFileName(segmentName, "", Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION));
-      }
-
-      if (normGen != null) {
-        for(Map.Entry<Integer,Long> ent : normGen.entrySet()) {
-          long gen = ent.getValue();
-          if (gen >= SegmentInfo.YES) {
-            // Definitely a separate norm file, with generation:
-            files.add(IndexFileNames.fileNameFromGeneration(segmentName, "s" + ent.getKey(), gen));
-          } else if (gen == SegmentInfo.NO) {
-            // No seaprate norm
-          } else {
-            // nocommit -- i thought _X_N.sY files were pre-3.0...????
-            assert false;
-          }
-        }
-      }
-    }
-
-    SegmentInfo info = new SegmentInfo(dir, version, segmentName, docCount, docStoreOffset,
-                                       docStoreSegment, docStoreIsCompoundFile, normGen, isCompoundFile,
-                                       delCount, null, diagnostics);
-    info.setDelGen(delGen);
-    info.setFiles(files);
-    return info;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
index 3b0e65e..2838582 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40Codec.java
@@ -23,7 +23,7 @@ import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.perfield.PerFieldPostingsFormat;
@@ -42,7 +42,7 @@ public class Lucene40Codec extends Codec {
   private final TermVectorsFormat vectorsFormat = new Lucene40TermVectorsFormat();
   private final FieldInfosFormat fieldInfosFormat = new Lucene40FieldInfosFormat();
   private final DocValuesFormat docValuesFormat = new Lucene40DocValuesFormat();
-  private final SegmentInfosFormat infosFormat = new Lucene40SegmentInfosFormat();
+  private final SegmentInfoFormat infosFormat = new Lucene40SegmentInfoFormat();
   private final NormsFormat normsFormat = new Lucene40NormsFormat();
   private final LiveDocsFormat liveDocsFormat = new Lucene40LiveDocsFormat();
   
@@ -83,7 +83,7 @@ public class Lucene40Codec extends Codec {
   }
   
   @Override
-  public SegmentInfosFormat segmentInfosFormat() {
+  public SegmentInfoFormat segmentInfosFormat() {
     return infosFormat;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
new file mode 100644
index 0000000..884a097
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
@@ -0,0 +1,82 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.IndexWriter; // javadocs
+import org.apache.lucene.index.SegmentInfos; // javadocs
+import org.apache.lucene.store.DataOutput; // javadocs
+
+/**
+ * Lucene 4.0 Segment info format.
+ * <p>
+ * Files:
+ * <ul>
+ *   <li><tt>.si</tt>: SegVersion, SegSize, IsCompoundFile, Diagnostics, Files
+ * </ul>
+ * </p>
+ * Data types:
+ * <p>
+ * <ul>
+ *   <li>SegSize --&gt; {@link DataOutput#writeInt Int32}</li>
+ *   <li>SegVersion --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>Files --&gt; {@link DataOutput#writeStringSet Set&lt;String&gt;}</li>
+ *   <li>Diagnostics--&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
+ *   <li>IsCompoundFile --&gt; {@link DataOutput#writeByte Int8}</li>
+ * </ul>
+ * </p>
+ * Field Descriptions:
+ * <p>
+ * <ul>
+ *   <li>SegVersion is the code version that created the segment.</li>
+ *   <li>SegSize is the number of documents contained in the segment index.</li>
+ *   <li>IsCompoundFile records whether the segment is written as a compound file or
+ *       not. If this is -1, the segment is not a compound file. If it is 1, the segment
+ *       is a compound file.</li>
+ *   <li>Checksum contains the CRC32 checksum of all bytes in the segments_N file up
+ *       until the checksum. This is used to verify integrity of the file on opening the
+ *       index.</li>
+ *   <li>The Diagnostics Map is privately written by IndexWriter, as a debugging aid,
+ *       for each segment it creates. It includes metadata like the current Lucene
+ *       version, OS, Java version, why the segment was created (merge, flush,
+ *       addIndexes), etc.</li>
+ *   <li>Files is a list of files referred to by this segment.</li>
+ * </ul>
+ * </p>
+ * 
+ * @see SegmentInfos
+ * @lucene.experimental
+ */
+public class Lucene40SegmentInfoFormat extends SegmentInfoFormat {
+  private final SegmentInfoReader reader = new Lucene40SegmentInfoReader();
+  private final SegmentInfoWriter writer = new Lucene40SegmentInfoWriter();
+  
+  @Override
+  public SegmentInfoReader getSegmentInfosReader() {
+    return reader;
+  }
+
+  @Override
+  public SegmentInfoWriter getSegmentInfosWriter() {
+    return writer;
+  }
+
+  public final static String SI_EXTENSION = "si";
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
new file mode 100644
index 0000000..00f0667
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
@@ -0,0 +1,73 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Lucene 4.0 implementation of {@link SegmentInfoReader}.
+ * 
+ * @see Lucene40SegmentInfoFormat
+ * @lucene.experimental
+ */
+public class Lucene40SegmentInfoReader extends SegmentInfoReader {
+
+  @Override
+  public SegmentInfo read(Directory dir, String segment, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segment, "", Lucene40SegmentInfoFormat.SI_EXTENSION);
+    final IndexInput input = dir.openInput(fileName, context);
+    boolean success = false;
+    try {
+      final String version = input.readString();
+      final int docCount = input.readInt();
+      final int docStoreOffset = -1;
+      final String docStoreSegment = segment;
+      final boolean docStoreIsCompoundFile = false;
+      final Map<Integer,Long> normGen = null;
+      final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
+      final Map<String,String> diagnostics = input.readStringStringMap();
+      final Set<String> files = input.readStringSet();
+
+      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, docStoreOffset,
+                                             docStoreSegment, docStoreIsCompoundFile, normGen, isCompoundFile,
+                                             0, null, diagnostics);
+      si.setFiles(files);
+
+      success = true;
+
+      return si;
+
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(input);
+      } else {
+        input.close();
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
new file mode 100644
index 0000000..6ec1b14
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
@@ -0,0 +1,72 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Lucene 4.0 implementation of {@link SegmentInfoWriter}.
+ * 
+ * @see Lucene40SegmentInfoFormat
+ * @lucene.experimental
+ */
+public class Lucene40SegmentInfoWriter extends SegmentInfoWriter {
+
+  /** Save a single segment's info. */
+  @Override
+  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
+    assert si.getDelCount() <= si.docCount: "delCount=" + si.getDelCount() + " docCount=" + si.docCount + " segment=" + si.name;
+    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene40SegmentInfoFormat.SI_EXTENSION);
+    assert si.getFiles() != null;
+    si.getFiles().add(fileName);
+
+    final IndexOutput output = dir.createOutput(fileName, ioContext);
+
+    boolean success = false;
+    try {
+      // Write the Lucene version that created this segment, since 3.1
+      output.writeString(si.getVersion());
+      output.writeInt(si.docCount);
+
+      assert si.getDocStoreOffset() == -1;
+      assert si.getNormGen() == null;
+
+      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
+      output.writeStringStringMap(si.getDiagnostics());
+      output.writeStringSet(si.getFiles());
+
+      success = true;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(output);
+        si.dir.deleteFile(fileName);
+      } else {
+        output.close();
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosFormat.java
deleted file mode 100644
index d356808..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosFormat.java
+++ /dev/null
@@ -1,139 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Set;
-
-import org.apache.lucene.codecs.Codec; // javadocs
-import org.apache.lucene.codecs.LiveDocsFormat; // javadocs
-import org.apache.lucene.codecs.SegmentInfosFormat;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.codecs.SegmentInfosWriter;
-import org.apache.lucene.codecs.StoredFieldsFormat; // javadocs
-import org.apache.lucene.codecs.TermVectorsFormat; // javadocs
-import org.apache.lucene.index.FieldInfo.IndexOptions; // javadocs
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.IndexWriter; // javadocs
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos; // javadocs
-import org.apache.lucene.store.DataOutput; // javadocs
-
-/**
- * Lucene 4.0 Segments format.
- * <p>
- * Files:
- * <ul>
- *   <li><tt>segments.gen</tt>: described in {@link SegmentInfos}
- *   <li><tt>segments_N</tt>: Format, Codec, Version, NameCounter, SegCount,
- *    &lt;SegVersion, SegName, SegSize, DelGen, DocStoreOffset, [DocStoreSegment,
- *    DocStoreIsCompoundFile], NumField, NormGen<sup>NumField</sup>, 
- *    IsCompoundFile, DeletionCount, HasProx, SegCodec Diagnostics, 
- *    HasVectors&gt;<sup>SegCount</sup>, CommitUserData, Checksum
- * </ul>
- * </p>
- * Data types:
- * <p>
- * <ul>
- *   <li>Format, NameCounter, SegCount, SegSize, NumField, DocStoreOffset,
- *       DeletionCount --&gt; {@link DataOutput#writeInt Int32}</li>
- *   <li>Version, DelGen, NormGen, Checksum --&gt; 
- *       {@link DataOutput#writeLong Int64}</li>
- *   <li>SegVersion, SegName, DocStoreSegment, Codec, SegCodec --&gt; 
- *       {@link DataOutput#writeString String}</li>
- *   <li>Diagnostics, CommitUserData --&gt; 
- *       {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
- *   <li>IsCompoundFile, DocStoreIsCompoundFile, HasProx,
- *       HasVectors --&gt; {@link DataOutput#writeByte Int8}</li>
- * </ul>
- * </p>
- * Field Descriptions:
- * <p>
- * <ul>
- *   <li>Format is {@link SegmentInfos#FORMAT_4_0}.</li>
- *   <li>Codec is "Lucene40", its the {@link Codec} that wrote this particular segments file.</li>
- *   <li>Version counts how often the index has been changed by adding or deleting
- *       documents.</li>
- *   <li>NameCounter is used to generate names for new segment files.</li>
- *   <li>SegVersion is the code version that created the segment.</li>
- *   <li>SegName is the name of the segment, and is used as the file name prefix for
- *       all of the files that compose the segment's index.</li>
- *   <li>SegSize is the number of documents contained in the segment index.</li>
- *   <li>DelGen is the generation count of the deletes file. If this is -1,
- *       there are no deletes. Anything above zero means there are deletes 
- *       stored by {@link LiveDocsFormat}.</li>
- *   <li>NumField is the size of the array for NormGen, or -1 if there are no
- *       NormGens stored.</li>
- *   <li>NormGen records the generation of the separate norms files. If NumField is
- *       -1, there are no normGens stored and all assumed to be -1. The generation 
- *       then has the same meaning as delGen (above).</li>
- *   <li>IsCompoundFile records whether the segment is written as a compound file or
- *       not. If this is -1, the segment is not a compound file. If it is 1, the segment
- *       is a compound file. Else it is 0, which means we check filesystem to see if
- *       _X.cfs exists.</li>
- *   <li>DocStoreOffset, DocStoreSegment, DocStoreIsCompoundFile: If DocStoreOffset
- *       is -1, this segment has its own doc store (stored fields values and term
- *       vectors) files and DocStoreSegment and DocStoreIsCompoundFile are not stored.
- *       In this case all files for  {@link StoredFieldsFormat stored field values} and
- *       {@link TermVectorsFormat term vectors} will be stored with this segment. 
- *       Otherwise, DocStoreSegment is the name of the segment that has the shared doc 
- *       store files; DocStoreIsCompoundFile is 1 if that segment is stored in compound 
- *       file format (as a <tt>.cfx</tt> file); and DocStoreOffset is the starting document 
- *       in the shared doc store files where this segment's documents begin. In this case, 
- *       this segment does not store its own doc store files but instead shares a single 
- *       set of these files with other segments.</li>
- *   <li>Checksum contains the CRC32 checksum of all bytes in the segments_N file up
- *       until the checksum. This is used to verify integrity of the file on opening the
- *       index.</li>
- *   <li>DeletionCount records the number of deleted documents in this segment.</li>
- *   <li>HasProx is 1 if any fields in this segment have position data
- *       ({@link IndexOptions#DOCS_AND_FREQS_AND_POSITIONS DOCS_AND_FREQS_AND_POSITIONS} or 
- *       {@link IndexOptions#DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS}); 
- *       else, it's 0.</li>
- *   <li>SegCodec is the {@link Codec#getName() name} of the Codec that encoded
- *       this segment.</li>
- *   <li>CommitUserData stores an optional user-supplied opaque
- *       Map&lt;String,String&gt; that was passed to {@link IndexWriter#commit(java.util.Map)} 
- *       or {@link IndexWriter#prepareCommit(java.util.Map)}.</li>
- *   <li>The Diagnostics Map is privately written by IndexWriter, as a debugging aid,
- *       for each segment it creates. It includes metadata like the current Lucene
- *       version, OS, Java version, why the segment was created (merge, flush,
- *       addIndexes), etc.</li>
- *   <li>HasVectors is 1 if this segment stores term vectors, else it's 0.</li>
- * </ul>
- * </p>
- * 
- * @see SegmentInfos
- * @lucene.experimental
- */
-public class Lucene40SegmentInfosFormat extends SegmentInfosFormat {
-  private final SegmentInfosReader reader = new Lucene40SegmentInfosReader();
-  private final SegmentInfosWriter writer = new Lucene40SegmentInfosWriter();
-  
-  @Override
-  public SegmentInfosReader getSegmentInfosReader() {
-    return reader;
-  }
-
-  @Override
-  public SegmentInfosWriter getSegmentInfosWriter() {
-    return writer;
-  }
-
-  public final static String SI_EXTENSION = "si";
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosReader.java
deleted file mode 100644
index b03ee5f..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosReader.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Lucene 4.0 implementation of {@link SegmentInfosReader}.
- * 
- * @see Lucene40SegmentInfosFormat
- * @lucene.experimental
- */
-public class Lucene40SegmentInfosReader extends SegmentInfosReader {
-
-  @Override
-  public SegmentInfo read(Directory dir, String segment, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segment, "", Lucene40SegmentInfosFormat.SI_EXTENSION);
-    final IndexInput input = dir.openInput(fileName, context);
-    boolean success = false;
-    try {
-      final String version = input.readString();
-      final int docCount = input.readInt();
-      final int docStoreOffset = -1;
-      final String docStoreSegment = segment;
-      final boolean docStoreIsCompoundFile = false;
-      final Map<Integer,Long> normGen = null;
-      final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
-      final Map<String,String> diagnostics = input.readStringStringMap();
-      final Set<String> files = input.readStringSet();
-
-      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, docStoreOffset,
-                                             docStoreSegment, docStoreIsCompoundFile, normGen, isCompoundFile,
-                                             0, null, diagnostics);
-      si.setFiles(files);
-
-      success = true;
-
-      return si;
-
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(input);
-      } else {
-        input.close();
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosWriter.java
deleted file mode 100644
index bb74e49..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfosWriter.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Map.Entry;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.codecs.SegmentInfosWriter;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentInfos;
-import org.apache.lucene.store.ChecksumIndexOutput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FlushInfo;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Lucene 4.0 implementation of {@link SegmentInfosWriter}.
- * 
- * @see Lucene40SegmentInfosFormat
- * @lucene.experimental
- */
-public class Lucene40SegmentInfosWriter extends SegmentInfosWriter {
-
-  /** Save a single segment's info. */
-  @Override
-  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
-    assert si.getDelCount() <= si.docCount: "delCount=" + si.getDelCount() + " docCount=" + si.docCount + " segment=" + si.name;
-    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene40SegmentInfosFormat.SI_EXTENSION);
-    assert si.getFiles() != null;
-    si.getFiles().add(fileName);
-
-    final IndexOutput output = dir.createOutput(fileName, ioContext);
-
-    boolean success = false;
-    try {
-      // Write the Lucene version that created this segment, since 3.1
-      output.writeString(si.getVersion());
-      output.writeInt(si.docCount);
-
-      assert si.getDocStoreOffset() == -1;
-      assert si.getNormGen() == null;
-
-      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
-      output.writeStringStringMap(si.getDiagnostics());
-      output.writeStringSet(si.getFiles());
-
-      success = true;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(output);
-        si.dir.deleteFile(fileName);
-      } else {
-        output.close();
-      }
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
index f1413e1..ffbd770 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
@@ -137,6 +137,11 @@ its numbering.</p>
 <p>Each segment index maintains the following:</p>
 <ul>
 <li>
+{@link org.apache.lucene.codecs.lucene40.Lucene40SegmentInfoFormat Segment info}.
+   This contains metadata about a segment, such as the number of documents,
+   what files it uses, 
+</li>
+<li>
 {@link org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat Field names}. 
    This contains the set of field names used in the index.
 </li>
@@ -197,8 +202,9 @@ An optional file indicating which documents are deleted.
 <div>
 <p>All files belonging to a segment have the same name with varying extensions.
 The extensions correspond to the different file formats described below. When
-using the Compound File format (default in 1.4 and greater) these files are
-collapsed into a single .cfs file (see below for details)</p>
+using the Compound File format (default in 1.4 and greater) these files (except
+for the Segment info file, the Lock file, and Deleted documents file) are collapsed 
+into a single .cfs file (see below for details)</p>
 <p>Typically, all segments in an index are stored in a single directory,
 although this is not required.</p>
 <p>As of version 2.1 (lock-less commits), file names are never re-used (there
@@ -220,9 +226,9 @@ Lucene:</p>
 <th>Brief Description</th>
 </tr>
 <tr>
-<td>{@link org.apache.lucene.codecs.lucene40.Lucene40SegmentInfosFormat Segments File}</td>
+<td>{@link org.apache.lucene.index.SegmentInfos Segments File}</td>
 <td>segments.gen, segments_N</td>
-<td>Stores information about segments</td>
+<td>Stores information about a commit point</td>
 </tr>
 <tr>
 <td><a href="#Lock_File">Lock File</a></td>
@@ -231,6 +237,11 @@ Lucene:</p>
 file.</td>
 </tr>
 <tr>
+<td>{@link org.apache.lucene.codecs.lucene40.Lucene40SegmentInfoFormat Segment Info}</td>
+<td>.si</td>
+<td>Stores metadata about a segment</td>
+</tr>
+<tr>
 <td>{@link org.apache.lucene.store.CompoundFileDirectory Compound File}</td>
 <td>.cfs, .cfe</td>
 <td>An optional "virtual" file consisting of all the other index files for
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java
index 7a851f2..c65c4c4 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java
@@ -206,8 +206,6 @@ public abstract class PerFieldPostingsFormat extends PostingsFormat {
     return new FieldsReader(state);
   }
 
-  // nocommit simplify now that we don't have files()...?
-
   // NOTE: only called during writing; for reading we read
   // all we need from the index (ie we save the field ->
   // format mapping)
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
index 23defd7..1003bde 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextCodec.java
@@ -23,7 +23,7 @@ import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 
@@ -36,7 +36,7 @@ import org.apache.lucene.codecs.TermVectorsFormat;
 public final class SimpleTextCodec extends Codec {
   private final PostingsFormat postings = new SimpleTextPostingsFormat();
   private final StoredFieldsFormat storedFields = new SimpleTextStoredFieldsFormat();
-  private final SegmentInfosFormat segmentInfos = new SimpleTextSegmentInfosFormat();
+  private final SegmentInfoFormat segmentInfos = new SimpleTextSegmentInfosFormat();
   private final FieldInfosFormat fieldInfosFormat = new SimpleTextFieldInfosFormat();
   private final TermVectorsFormat vectorsFormat = new SimpleTextTermVectorsFormat();
   // TODO: need a plain-text impl
@@ -75,7 +75,7 @@ public final class SimpleTextCodec extends Codec {
   }
 
   @Override
-  public SegmentInfosFormat segmentInfosFormat() {
+  public SegmentInfoFormat segmentInfosFormat() {
     return segmentInfos;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosFormat.java
index 0a0490d..08d88f9 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosFormat.java
@@ -19,9 +19,9 @@ package org.apache.lucene.codecs.simpletext;
 
 import java.util.Set;
 
-import org.apache.lucene.codecs.SegmentInfosFormat;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.codecs.SegmentInfosWriter;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
 
@@ -31,19 +31,19 @@ import org.apache.lucene.index.SegmentInfo;
  * <b><font color="red">FOR RECREATIONAL USE ONLY</font></B>
  * @lucene.experimental
  */
-public class SimpleTextSegmentInfosFormat extends SegmentInfosFormat {
-  private final SegmentInfosReader reader = new SimpleTextSegmentInfosReader();
-  private final SegmentInfosWriter writer = new SimpleTextSegmentInfosWriter();
+public class SimpleTextSegmentInfosFormat extends SegmentInfoFormat {
+  private final SegmentInfoReader reader = new SimpleTextSegmentInfosReader();
+  private final SegmentInfoWriter writer = new SimpleTextSegmentInfosWriter();
 
   public static final String SI_EXTENSION = "si";
   
   @Override
-  public SegmentInfosReader getSegmentInfosReader() {
+  public SegmentInfoReader getSegmentInfosReader() {
     return reader;
   }
 
   @Override
-  public SegmentInfosWriter getSegmentInfosWriter() {
+  public SegmentInfoWriter getSegmentInfosWriter() {
     return writer;
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader.java b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader.java
index d4cddde..f81ee38 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosReader.java
@@ -24,7 +24,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.SegmentInfosReader;
+import org.apache.lucene.codecs.SegmentInfoReader;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
@@ -46,7 +46,7 @@ import static org.apache.lucene.codecs.simpletext.SimpleTextSegmentInfosWriter.*
  * <b><font color="red">FOR RECREATIONAL USE ONLY</font></B>
  * @lucene.experimental
  */
-public class SimpleTextSegmentInfosReader extends SegmentInfosReader {
+public class SimpleTextSegmentInfosReader extends SegmentInfoReader {
 
   @Override
   public SegmentInfo read(Directory directory, String segmentName, IOContext context) throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosWriter.java
index b51c0c7..4d476f9 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfosWriter.java
@@ -22,7 +22,7 @@ import java.util.Map.Entry;
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.lucene.codecs.SegmentInfosWriter;
+import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
@@ -41,7 +41,7 @@ import org.apache.lucene.util.IOUtils;
  * <b><font color="red">FOR RECREATIONAL USE ONLY</font></B>
  * @lucene.experimental
  */
-public class SimpleTextSegmentInfosWriter extends SegmentInfosWriter {
+public class SimpleTextSegmentInfosWriter extends SegmentInfoWriter {
 
   final static BytesRef SI_VERSION          = new BytesRef("    version ");
   final static BytesRef SI_DOCCOUNT         = new BytesRef("    number of documents ");
diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 5787c45..8fc60f5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -33,7 +33,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfosFormat;
+import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfoFormat;
 import org.apache.lucene.index.DocumentsWriterPerThread.FlushedSegment;
 import org.apache.lucene.index.FieldInfos.FieldNumberBiMap;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
@@ -2372,7 +2372,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit {
     final boolean hasSharedDocStore = info.getDocStoreOffset() != -1;
     final String segmentInfoFileName3X = IndexFileNames.segmentFileName(info.name,
                                                                         "",
-                                                                        Lucene3xSegmentInfosFormat.SI_EXTENSION);
+                                                                        Lucene3xSegmentInfoFormat.SI_EXTENSION);
 
     if (hasSharedDocStore) {
       // only violate the codec this way if it's preflex &
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
index 52ef586..cffc38b 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
@@ -34,16 +34,11 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.TrackingDirectoryWrapper;
 import org.apache.lucene.util.Constants;
 
-// nocommit fix jdocs for all codec's SI writer impls to
-// describe their format
-
 // nocommit fix codec api to pass this around so they can
 // store attrs
 
 // nocommit add attrs api like FI
 
-// nocommit fix PFPF to use attrs api instead of its .per file
-
 /**
  * Information about a segment such as it's name, directory, and files related
  * to the segment.
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
index 32a93dd..8ff077c 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
@@ -32,16 +32,14 @@ import java.util.Map;
 import java.util.Set;
 
 import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.SegmentInfosReader;
-import org.apache.lucene.codecs.SegmentInfosWriter;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.lucene3x.Lucene3xCodec;
-import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfosFormat;
-import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfosReader;
+import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfoFormat;
+import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfoReader;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.ChecksumIndexOutput;
 import org.apache.lucene.store.DataOutput; // javadocs
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FlushInfo;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
@@ -60,9 +58,8 @@ import org.apache.lucene.util.ThreadInterruptedException;
  * older segments_N files are present it's because they temporarily cannot be
  * deleted, or, a writer is in the process of committing, or a custom 
  * {@link org.apache.lucene.index.IndexDeletionPolicy IndexDeletionPolicy}
- * is in use). This file lists each segment by name, has details about the
- * separate norms and deletion files, and also contains the size of each
- * segment.
+ * is in use). This file lists each segment by name and has details about the
+ * codec and generation of deletes.
  * </p>
  * <p>There is also a file <tt>segments.gen</tt>. This file contains
  * the current generation (the <tt>_N</tt> in <tt>segments_N</tt>) of the index.
@@ -72,27 +69,55 @@ import org.apache.lucene.util.ThreadInterruptedException;
  * an {@link DataOutput#writeInt Int32} version header 
  * ({@link #FORMAT_SEGMENTS_GEN_CURRENT}), followed by the
  * generation recorded as {@link DataOutput#writeLong Int64}, written twice.</p>
+ * <p>
+ * Files:
+ * <ul>
+ *   <li><tt>segments.gen</tt>: GenHeader, Generation, Generation
+ *   <li><tt>segments_N</tt>: Header, Version, NameCounter, SegCount,
+ *    &lt;SegName, SegCodec, DelGen, DeletionCount&gt;<sup>SegCount</sup>, 
+ *    CommitUserData, Checksum
+ * </ul>
+ * </p>
+ * Data types:
+ * <p>
+ * <ul>
+ *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
+ *   <li>GenHeader, NameCounter, SegCount, DeletionCount --&gt; {@link DataOutput#writeInt Int32}</li>
+ *   <li>Generation, Version, DelGen, Checksum --&gt; {@link DataOutput#writeLong Int64}</li>
+ *   <li>SegName, SegCodec --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>CommitUserData --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
+ * </ul>
+ * </p>
+ * Field Descriptions:
+ * <p>
+ * <ul>
+ *   <li>Version counts how often the index has been changed by adding or deleting
+ *       documents.</li>
+ *   <li>NameCounter is used to generate names for new segment files.</li>
+ *   <li>SegName is the name of the segment, and is used as the file name prefix for
+ *       all of the files that compose the segment's index.</li>
+ *   <li>DelGen is the generation count of the deletes file. If this is -1,
+ *       there are no deletes. Anything above zero means there are deletes 
+ *       stored by {@link LiveDocsFormat}.</li>
+ *   <li>DeletionCount records the number of deleted documents in this segment.</li>
+ *   <li>Checksum contains the CRC32 checksum of all bytes in the segments_N file up
+ *       until the checksum. This is used to verify integrity of the file on opening the
+ *       index.</li>
+ *   <li>SegCodec is the {@link Codec#getName() name} of the Codec that encoded
+ *       this segment.</li>
+ *   <li>CommitUserData stores an optional user-supplied opaque
+ *       Map&lt;String,String&gt; that was passed to {@link IndexWriter#commit(java.util.Map)} 
+ *       or {@link IndexWriter#prepareCommit(java.util.Map)}.</li>
+ * </ul>
+ * </p>
  * 
  * @lucene.experimental
  */
 public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
 
-  /* 
-   * The file format version, a negative number.
-   *  
-   * NOTE: future format numbers must always be one smaller 
-   * than the latest. With time, support for old formats will
-   * be removed, however the numbers should continue to decrease. 
+  /**
+   * The file format version for the segments_N codec header
    */
-
-  // TODO: i don't think we need *all* these version numbers here?
-  // most codecs only need FORMAT_CURRENT? and we should rename it 
-  // to FORMAT_FLEX? because the 'preamble' is just FORMAT_CURRENT + codecname
-  // after that the codec takes over. 
-  
-  // also i think this class should write this, somehow we let 
-  // preflexrw hackishly override this (like seek backwards and overwrite it)
-
   public static final int VERSION_40 = 0;
 
   /** Used for the segments.gen file only!
@@ -248,13 +273,9 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
 
     lastGeneration = generation;
 
-    // TODO: scary to have default impl reopen the file... but to make it a bit more flexible,
-    // maybe we could use a plain indexinput here... could default impl rewind/wrap with checksumII,
-    // and any checksumming is then up to implementation?
     ChecksumIndexInput input = new ChecksumIndexInput(directory.openInput(segmentFileName, IOContext.READ));
     try {
       final int format = input.readInt();
-      final boolean checkCheckSum;
       if (format == CodecUtil.CODEC_MAGIC) {
         // 4.0+
         CodecUtil.checkHeaderNoMagic(input, "segments", VERSION_40, VERSION_40);
@@ -274,7 +295,7 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
         }
         userData = input.readStringStringMap();
       } else {
-        Lucene3xSegmentInfosReader.readLegacyInfos(this, directory, input, format);
+        Lucene3xSegmentInfoReader.readLegacyInfos(this, directory, input, format);
         Codec codec = Codec.forName("Lucene3x");
         for (SegmentInfo info : this) {
           info.setCodec(codec);
@@ -331,7 +352,7 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
     ChecksumIndexOutput segnOutput = null;
     boolean success = false;
 
-    // nocommit document somewhere taht we store this
+    // nocommit document somewhere that we store this
     // list-of-segs plus delGen plus other stuff
     // "generically" and then codec gets to write SI
 
@@ -343,7 +364,6 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
       segnOutput.writeLong(version); 
       segnOutput.writeInt(counter); // write counter
       segnOutput.writeInt(size()); // write infos
-      Codec codec3X = Codec.forName("Lucene3x");
       for (SegmentInfo si : this) {
         segnOutput.writeString(si.name);
         segnOutput.writeString(si.getCodec().getName());
@@ -355,7 +375,7 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
         // "ugprade" to write the .si file for it:
         String version = si.getVersion();
         if (version == null || version.startsWith("3.")) {
-          String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene3xSegmentInfosFormat.SI_EXTENSION);
+          String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene3xSegmentInfoFormat.SI_EXTENSION);
           if (!directory.fileExists(fileName)) {
             upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));
           }
@@ -393,7 +413,7 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentInfo> {
   public static String write3xInfo(Directory dir, SegmentInfo si, IOContext context) throws IOException {
 
     // NOTE: this is NOT how 3.x is really written...
-    String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene3xSegmentInfosFormat.SI_EXTENSION);
+    String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene3xSegmentInfoFormat.SI_EXTENSION);
     si.getFiles().add(fileName);
 
     //System.out.println("UPGRADE write " + fileName);
diff --git a/lucene/core/src/java/org/apache/lucene/store/ChecksumIndexOutput.java b/lucene/core/src/java/org/apache/lucene/store/ChecksumIndexOutput.java
index e01df64..eb4f742 100644
--- a/lucene/core/src/java/org/apache/lucene/store/ChecksumIndexOutput.java
+++ b/lucene/core/src/java/org/apache/lucene/store/ChecksumIndexOutput.java
@@ -71,7 +71,7 @@ public class ChecksumIndexOutput extends IndexOutput {
     throw new UnsupportedOperationException();    
   }
 
-  /** See {@link #prepareCommit} */
+  /** writes the checksum */
   public void finishCommit() throws IOException {
     main.writeLong(getChecksum());
   }
diff --git a/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java b/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java
index 7d7d01a..5e19988 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CodecUtil.java
@@ -130,7 +130,7 @@ public final class CodecUtil {
   }
 
   /** Like {@link
-   *  checkHeader(DataInput,String,int,int)} except this
+   *  #checkHeader(DataInput,String,int,int)} except this
    *  version assumes the first int has already been read
    *  and validated from the input. */
   public static int checkHeaderNoMagic(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java b/lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
index a7634f9..cbfe795 100755
--- a/lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
@@ -30,7 +30,7 @@ import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40Codec;
@@ -38,7 +38,7 @@ import org.apache.lucene.codecs.lucene40.Lucene40DocValuesFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40NormsFormat;
-import org.apache.lucene.codecs.lucene40.Lucene40SegmentInfosFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40SegmentInfoFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40StoredFieldsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40TermVectorsFormat;
 import org.apache.lucene.codecs.pulsing.Pulsing40PostingsFormat;
@@ -1150,8 +1150,8 @@ public class TestAddIndexes extends LuceneTestCase {
     }
 
     @Override
-    public SegmentInfosFormat segmentInfosFormat() {
-      return new Lucene40SegmentInfosFormat();
+    public SegmentInfoFormat segmentInfosFormat() {
+      return new Lucene40SegmentInfoFormat();
     }
 
     @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWCodec.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWCodec.java
index 921c583..2960425 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWCodec.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWCodec.java
@@ -24,7 +24,7 @@ import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
-import org.apache.lucene.codecs.SegmentInfosFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
@@ -42,7 +42,7 @@ public class PreFlexRWCodec extends Lucene3xCodec {
   private final Lucene3xNormsFormat norms = new PreFlexRWNormsFormat();
   private final FieldInfosFormat fieldInfos = new PreFlexRWFieldInfosFormat();
   private final TermVectorsFormat termVectors = new PreFlexRWTermVectorsFormat();
-  private final SegmentInfosFormat segmentInfos = new PreFlexRWSegmentInfosFormat();
+  private final SegmentInfoFormat segmentInfos = new PreFlexRWSegmentInfosFormat();
   private final StoredFieldsFormat storedFields = new PreFlexRWStoredFieldsFormat();
   // TODO: this should really be a different impl
   private final LiveDocsFormat liveDocs = new Lucene40LiveDocsFormat();
@@ -66,7 +66,7 @@ public class PreFlexRWCodec extends Lucene3xCodec {
   }
 
   @Override
-  public SegmentInfosFormat segmentInfosFormat() {
+  public SegmentInfoFormat segmentInfosFormat() {
     if (LuceneTestCase.PREFLEX_IMPERSONATION_IS_ACTIVE) {
       return segmentInfos ;
     } else {
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosFormat.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosFormat.java
index d49c01e..d9cf0a9 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosFormat.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosFormat.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.codecs.lucene3x;
 
-import org.apache.lucene.codecs.SegmentInfosWriter;
+import org.apache.lucene.codecs.SegmentInfoWriter;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -22,11 +22,11 @@ import org.apache.lucene.codecs.SegmentInfosWriter;
 /**
  * @lucene.experimental
  */
-class PreFlexRWSegmentInfosFormat extends Lucene3xSegmentInfosFormat {
-  private final SegmentInfosWriter writer = new PreFlexRWSegmentInfosWriter();
+class PreFlexRWSegmentInfosFormat extends Lucene3xSegmentInfoFormat {
+  private final SegmentInfoWriter writer = new PreFlexRWSegmentInfosWriter();
 
   @Override
-  public SegmentInfosWriter getSegmentInfosWriter() {
+  public SegmentInfoWriter getSegmentInfosWriter() {
     return writer;
   }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosWriter.java b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosWriter.java
index 89c11f5..8539752 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosWriter.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/codecs/lucene3x/PreFlexRWSegmentInfosWriter.java
@@ -21,7 +21,7 @@ import java.io.IOException;
 import java.util.Map.Entry;
 import java.util.Map;
 
-import org.apache.lucene.codecs.SegmentInfosWriter;
+import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
@@ -34,10 +34,10 @@ import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.IOUtils;
 
 /**
- * PreFlex implementation of {@link SegmentInfosWriter}.
+ * PreFlex implementation of {@link SegmentInfoWriter}.
  * @lucene.experimental
  */
-class PreFlexRWSegmentInfosWriter extends SegmentInfosWriter {
+class PreFlexRWSegmentInfosWriter extends SegmentInfoWriter {
 
   // NOTE: this is not "really" 3.x format, because we are
   // writing each SI to its own file, vs 3.x where the list

