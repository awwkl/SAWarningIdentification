GitDiffStart: 137e65ae758c07270ed15858539dbb16feb6fd4b | Mon Dec 10 20:20:12 2012 +0000
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
index 67cc603..cc4499e 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
@@ -56,7 +56,8 @@ public class MemoryDocValuesFormat extends SimpleDocValuesFormat {
 
       @Override
       public NumericDocValues getNumeric(FieldInfo field) throws IOException {
-        NumericDocValues valuesIn = producer.getNumeric(field);
+        // nocommit is that clone() ok...?  it IS necessary
+        NumericDocValues valuesIn = producer.clone().getNumeric(field);
 
         final int maxDoc = valuesIn.size();
         final long minValue = valuesIn.minValue();
@@ -95,7 +96,8 @@ public class MemoryDocValuesFormat extends SimpleDocValuesFormat {
       
       @Override
       public BinaryDocValues getBinary(FieldInfo field) throws IOException {
-        BinaryDocValues valuesIn = producer.getBinary(field);
+        // nocommit is that clone() ok...?  it IS necessary
+        BinaryDocValues valuesIn = producer.clone().getBinary(field);
         final int maxDoc = valuesIn.size();
         final int maxLength = valuesIn.maxLength();
         final boolean fixedLength = valuesIn.isFixedLength();
@@ -136,7 +138,8 @@ public class MemoryDocValuesFormat extends SimpleDocValuesFormat {
 
       @Override
       public SortedDocValues getSorted(FieldInfo field) throws IOException {
-        SortedDocValues valuesIn = producer.getSorted(field);
+        // nocommit is that clone() ok...?  it IS necessary
+        SortedDocValues valuesIn = producer.clone().getSorted(field);
         final int maxDoc = valuesIn.size();
         final int maxLength = valuesIn.maxLength();
         final boolean fixedLength = valuesIn.isFixedLength();
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
index 1fd4f48..b881216 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
@@ -167,6 +167,8 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
     @Override
     public NumericDocValuesConsumer addNumericField(FieldInfo field, final long minValue, long maxValue) throws IOException {
       assert fieldSeen(field.name);
+      assert (field.getDocValuesType() == null || DocValues.isNumber(field.getDocValuesType()) || DocValues.isFloat(field.getDocValuesType())) &&
+        (field.getNormType() == null || DocValues.isNumber(field.getNormType()) || DocValues.isFloat(field.getNormType()));
       writeFieldEntry(field);
       
       // write our minimum value to the .dat, all entries are deltas from that
@@ -224,6 +226,7 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
     @Override
     public BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, final int maxLength) throws IOException {
       assert fieldSeen(field.name);
+      assert DocValues.isBytes(field.getDocValuesType());
       assert !isNorms;
       writeFieldEntry(field);
       // write fixedlength
@@ -278,6 +281,7 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
     @Override
     public SortedDocValuesConsumer addSortedField(FieldInfo field, final int valueCount, boolean fixedLength, final int maxLength) throws IOException {
       assert fieldSeen(field.name);
+      assert DocValues.isSortedBytes(field.getDocValuesType());
       assert !isNorms;
       writeFieldEntry(field);
       // write numValues
@@ -662,7 +666,7 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
             }
             in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));
             SimpleTextUtil.readLine(in, scratch);
-            assert StringHelper.startsWith(scratch, LENGTH);
+            assert StringHelper.startsWith(scratch, LENGTH): "got " + scratch.utf8ToString() + " in=" + in;
             int len;
             try {
               len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/FilterCodec.java b/lucene/core/src/java/org/apache/lucene/codecs/FilterCodec.java
index 12f1719..0b92620 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/FilterCodec.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/FilterCodec.java
@@ -65,6 +65,11 @@ public abstract class FilterCodec extends Codec {
   }
 
   @Override
+  public SimpleDocValuesFormat simpleDocValuesFormat() {
+    return delegate.simpleDocValuesFormat();
+  }
+
+  @Override
   public FieldInfosFormat fieldInfosFormat() {
     return delegate.fieldInfosFormat();
   }
@@ -80,6 +85,11 @@ public abstract class FilterCodec extends Codec {
   }
 
   @Override
+  public SimpleNormsFormat simpleNormsFormat() {
+    return delegate.simpleNormsFormat();
+  }
+
+  @Override
   public PostingsFormat postingsFormat() {
     return delegate.postingsFormat();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValues.java b/lucene/core/src/java/org/apache/lucene/index/DocValues.java
index f1a2af0..065632e 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValues.java
@@ -518,8 +518,6 @@ public abstract class DocValues implements Closeable {
     switch(type) {
     case BYTES_VAR_SORTED:
     case BYTES_FIXED_SORTED:
-    case BYTES_VAR_DEREF:
-    case BYTES_FIXED_DEREF:
       return true;
     default:
       return false;
@@ -529,6 +527,8 @@ public abstract class DocValues implements Closeable {
   // nocommit nuke
   public static boolean isBytes(Type type) {
     switch(type) {
+    case BYTES_VAR_DEREF:
+    case BYTES_FIXED_DEREF:
     case BYTES_VAR_STRAIGHT:
     case BYTES_FIXED_STRAIGHT:
       return true;
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java b/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
index a07eb53..3dd3306 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
@@ -49,32 +49,22 @@ final class DocValuesProcessor extends StoredFieldsConsumer {
   public void addField(int docID, StorableField field, FieldInfo fieldInfo) {
     final DocValues.Type dvType = field.fieldType().docValueType();
     if (dvType != null) {
-      switch(dvType) {
-      case BYTES_VAR_STRAIGHT:
-      case BYTES_FIXED_STRAIGHT:
+      if (DocValues.isBytes(dvType)) {
         addBinaryField(fieldInfo, docID, field.binaryValue());
-        break;
-      case BYTES_VAR_SORTED:
-      case BYTES_FIXED_SORTED:
-      case BYTES_VAR_DEREF:
-      case BYTES_FIXED_DEREF:
+      } else if (DocValues.isSortedBytes(dvType)) {
         addSortedField(fieldInfo, docID, field.binaryValue());
-        break;
-      case VAR_INTS:
-      case FIXED_INTS_8:
-      case FIXED_INTS_16:
-      case FIXED_INTS_32:
-      case FIXED_INTS_64:
+      } else if (DocValues.isFloat(dvType)) {
+        if (dvType == DocValues.Type.FLOAT_32) {
+          addNumericField(fieldInfo, docID, field.numericValue().floatValue());
+        } else if (dvType == DocValues.Type.FLOAT_64) {
+          addNumericField(fieldInfo, docID, field.numericValue().doubleValue());
+        } else {
+          assert false;
+        }
+      } else if (DocValues.isNumber(dvType)) {
         addNumericField(fieldInfo, docID, field.numericValue().longValue());
-        break;
-      case FLOAT_32:
-        addNumericField(fieldInfo, docID, field.numericValue().floatValue());
-        break;
-      case FLOAT_64:
-        addNumericField(fieldInfo, docID, field.numericValue().doubleValue());
-        break;
-      default:
-        break;
+      } else {
+        assert false: "unrecognized DocValues.Type: " + dvType;
       }
     }
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java b/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
index cabc730..d57aaa6 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
@@ -1321,6 +1321,10 @@ class FieldCacheImpl implements FieldCache {
         throws IOException {
 
       BinaryDocValues valuesIn = reader.getBinaryDocValues(key.field);
+
+      // TODO: would be nice to fallback to SortedDV if it's
+      // available but BinaryDV isn't?
+
       if (valuesIn != null) {
         return valuesIn;
       } else {
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldComparator.java b/lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
index 1e2d2bb..6d625c2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
@@ -18,12 +18,10 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
-import java.util.Comparator;
 
 import org.apache.lucene.index.AtomicReader; // javadocs
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.BinaryDocValues;
-import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.search.FieldCache.ByteParser;
 import org.apache.lucene.search.FieldCache.DoubleParser;
@@ -33,7 +31,6 @@ import org.apache.lucene.search.FieldCache.LongParser;
 import org.apache.lucene.search.FieldCache.ShortParser;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.packed.PackedInts;
 
 /**
  * Expert: a FieldComparator compares hits so as to determine their
@@ -389,83 +386,6 @@ public abstract class FieldComparator<T> {
     }
   }
 
-  /** Uses float index values to sort by ascending value */
-  public static final class FloatDocValuesComparator extends FieldComparator<Double> {
-    private final double[] values;
-    private final String field;
-    private DocValues.Source currentReaderValues;
-    private double bottom;
-
-    FloatDocValuesComparator(int numHits, String field) {
-      values = new double[numHits];
-      this.field = field;
-    }
-
-    @Override
-    public int compare(int slot1, int slot2) {
-      final double v1 = values[slot1];
-      final double v2 = values[slot2];
-      if (v1 > v2) {
-        return 1;
-      } else if (v1 < v2) {
-        return -1;
-      } else {
-        return 0;
-      }
-    }
-
-    @Override
-    public int compareBottom(int doc) {
-      final double v2 = currentReaderValues.getFloat(doc);
-      if (bottom > v2) {
-        return 1;
-      } else if (bottom < v2) {
-        return -1;
-      } else {
-        return 0;
-      }
-    }
-
-    @Override
-    public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues.getFloat(doc); 
-    }
-
-    @Override
-    public FieldComparator<Double> setNextReader(AtomicReaderContext context) throws IOException {
-      final DocValues docValues = context.reader().docValues(field);
-      if (docValues != null) {
-        currentReaderValues = docValues.getSource(); 
-      } else {
-        currentReaderValues = DocValues.getDefaultSource(DocValues.Type.FLOAT_64);
-      }
-      return this;
-    }
-    
-    @Override
-    public void setBottom(final int bottom) {
-      this.bottom = values[bottom];
-    }
-
-    @Override
-    public Double value(int slot) {
-      return Double.valueOf(values[slot]);
-    }
-
-    @Override
-    public int compareDocToValue(int doc, Double valueObj) {
-      final double value = valueObj.doubleValue();
-      final double docValue = currentReaderValues.getFloat(doc);
-      if (docValue < value) {
-        return -1;
-      } else if (docValue > value) {
-        return 1;
-      } else {
-        return 0;
-      }
-    }
-  }
-
   /** Parses field's values as float (using {@link
    *  FieldCache#getFloats} and sorts by ascending value */
   public static final class FloatComparator extends NumericComparator<Float> {
@@ -739,87 +659,6 @@ public abstract class FieldComparator<T> {
     }
   }
 
-  /** Loads int index values and sorts by ascending value. */
-  public static final class IntDocValuesComparator extends FieldComparator<Long> {
-    private final long[] values;
-    private DocValues.Source currentReaderValues;
-    private final String field;
-    private long bottom;
-
-    IntDocValuesComparator(int numHits, String field) {
-      values = new long[numHits];
-      this.field = field;
-    }
-
-    @Override
-    public int compare(int slot1, int slot2) {
-      // TODO: there are sneaky non-branch ways to compute
-      // -1/+1/0 sign
-      final long v1 = values[slot1];
-      final long v2 = values[slot2];
-      if (v1 > v2) {
-        return 1;
-      } else if (v1 < v2) {
-        return -1;
-      } else {
-        return 0;
-      }
-    }
-
-    @Override
-    public int compareBottom(int doc) {
-      // TODO: there are sneaky non-branch ways to compute
-      // -1/+1/0 sign
-      final long v2 = currentReaderValues.getInt(doc);
-      if (bottom > v2) {
-        return 1;
-      } else if (bottom < v2) {
-        return -1;
-      } else {
-        return 0;
-      }
-    }
-
-    @Override
-    public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues.getInt(doc); 
-    }
-
-    @Override
-    public FieldComparator<Long> setNextReader(AtomicReaderContext context) throws IOException {
-      DocValues docValues = context.reader().docValues(field);
-      if (docValues != null) {
-        currentReaderValues = docValues.getSource();
-      } else {
-        currentReaderValues = DocValues.getDefaultSource(DocValues.Type.FIXED_INTS_64);
-      }
-      return this;
-    }
-    
-    @Override
-    public void setBottom(final int bottom) {
-      this.bottom = values[bottom];
-    }
-
-    @Override
-    public Long value(int slot) {
-      return Long.valueOf(values[slot]);
-    }
-
-    @Override
-    public int compareDocToValue(int doc, Long valueObj) {
-      final long value = valueObj.longValue();
-      final long docValue = currentReaderValues.getInt(doc);
-      if (docValue < value) {
-        return -1;
-      } else if (docValue > value) {
-        return 1;
-      } else {
-        return 0;
-      }
-    }
-  }
-
   /** Parses field's values as long (using {@link
    *  FieldCache#getLongs} and sorts by ascending value */
   public static final class LongComparator extends NumericComparator<Long> {
@@ -1313,75 +1152,25 @@ public abstract class FieldComparator<T> {
     }
   }
 
-  /** Sorts by field's natural Term sort order, using
-   *  ordinals; this is just like {@link
-   *  org.apache.lucene.search.FieldComparator.TermValComparator} except it uses DocValues to
-   *  retrieve the sort ords saved during indexing. */
-  public static final class TermOrdValDocValuesComparator extends FieldComparator<BytesRef> {
-    /* Ords for each slot.
-       @lucene.internal */
-    final int[] ords;
-
-    /* Values for each slot.
-       @lucene.internal */
-    final BytesRef[] values;
-
-    /* Which reader last copied a value into the slot. When
-       we compare two slots, we just compare-by-ord if the
-       readerGen is the same; else we must compare the
-       values (slower).
-       @lucene.internal */
-    final int[] readerGen;
-
-    /* Gen of current reader we are on.
-       @lucene.internal */
-    int currentReaderGen = -1;
-
-    /* Current reader's doc ord/values.
-       @lucene.internal */
-    DocValues.SortedSource termsIndex;
-
-    /* Comparator for comparing by value.
-       @lucene.internal */
-    Comparator<BytesRef> comp;
+  /** Sorts by field's natural Term sort order.  All
+   *  comparisons are done using BytesRef.compareTo, which is
+   *  slow for medium to large result sets but possibly
+   *  very fast for very small results sets. */
+  public static final class TermValComparator extends FieldComparator<BytesRef> {
 
+    private BytesRef[] values;
+    private BinaryDocValues docTerms;
     private final String field;
+    private BytesRef bottom;
+    private final BytesRef tempBR = new BytesRef();
 
-    /* Bottom slot, or -1 if queue isn't full yet
-       @lucene.internal */
-    int bottomSlot = -1;
-
-    /* Bottom ord (same as ords[bottomSlot] once bottomSlot
-       is set).  Cached for faster compares.
-       @lucene.internal */
-    int bottomOrd;
-
-    /* True if current bottom slot matches the current
-       reader.
-       @lucene.internal */
-    boolean bottomSameReader;
-
-    /* Bottom value (same as values[bottomSlot] once
-       bottomSlot is set).  Cached for faster compares.
-      @lucene.internal */
-    BytesRef bottomValue;
-
-    /** @lucene.internal */
-    final BytesRef tempBR = new BytesRef();
-
-    public TermOrdValDocValuesComparator(int numHits, String field) {
-      ords = new int[numHits];
+    TermValComparator(int numHits, String field) {
       values = new BytesRef[numHits];
-      readerGen = new int[numHits];
       this.field = field;
     }
 
     @Override
     public int compare(int slot1, int slot2) {
-      if (readerGen[slot1] == readerGen[slot2]) {
-        return ords[slot1] - ords[slot2];
-      }
-
       final BytesRef val1 = values[slot1];
       final BytesRef val2 = values[slot2];
       if (val1 == null) {
@@ -1392,445 +1181,60 @@ public abstract class FieldComparator<T> {
       } else if (val2 == null) {
         return 1;
       }
-      return comp.compare(val1, val2);
+
+      return val1.compareTo(val2);
     }
 
     @Override
     public int compareBottom(int doc) {
-      throw new UnsupportedOperationException();
+      docTerms.get(doc, tempBR);
+      if (bottom.bytes == BinaryDocValues.MISSING) {
+        if (tempBR.bytes == BinaryDocValues.MISSING) {
+          return 0;
+        }
+        return -1;
+      } else if (tempBR.bytes == BinaryDocValues.MISSING) {
+        return 1;
+      }
+      return bottom.compareTo(tempBR);
     }
 
     @Override
     public void copy(int slot, int doc) {
-      throw new UnsupportedOperationException();
+      if (values[slot] == null) {
+        values[slot] = new BytesRef();
+      }
+      docTerms.get(doc, values[slot]);
     }
 
     @Override
-    public int compareDocToValue(int doc, BytesRef value) {
-      return termsIndex.getBytes(doc, tempBR).compareTo(value);
+    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {
+      docTerms = FieldCache.DEFAULT.getTerms(context.reader(), field);
+      return this;
+    }
+    
+    @Override
+    public void setBottom(final int bottom) {
+      this.bottom = values[bottom];
     }
 
-    // TODO: would be nice to share these specialized impls
-    // w/ TermOrdValComparator
-
-    /** Base class for specialized (per bit width of the
-     * ords) per-segment comparator.  NOTE: this is messy;
-     * we do this only because hotspot can't reliably inline
-     * the underlying array access when looking up doc->ord
-     * @lucene.internal
-     */
-    abstract class PerSegmentComparator extends FieldComparator<BytesRef> {
-      
-      @Override
-      public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {
-        return TermOrdValDocValuesComparator.this.setNextReader(context);
-      }
+    @Override
+    public BytesRef value(int slot) {
+      return values[slot];
+    }
 
-      @Override
-      public int compare(int slot1, int slot2) {
-        return TermOrdValDocValuesComparator.this.compare(slot1, slot2);
+    @Override
+    public int compareValues(BytesRef val1, BytesRef val2) {
+      if (val1 == null) {
+        if (val2 == null) {
+          return 0;
+        }
+        return -1;
+      } else if (val2 == null) {
+        return 1;
       }
-
-      @Override
-      public void setBottom(final int bottom) {
-        TermOrdValDocValuesComparator.this.setBottom(bottom);
-      }
-
-      @Override
-      public BytesRef value(int slot) {
-        return TermOrdValDocValuesComparator.this.value(slot);
-      }
-
-      @Override
-      public int compareValues(BytesRef val1, BytesRef val2) {
-        assert val1 != null;
-        assert val2 != null;
-        return comp.compare(val1, val2);
-      }
-
-      @Override
-      public int compareDocToValue(int doc, BytesRef value) {
-        return TermOrdValDocValuesComparator.this.compareDocToValue(doc, value);
-      }
-    }
-
-    // Used per-segment when bit width of doc->ord is 8:
-    private final class ByteOrdComparator extends PerSegmentComparator {
-      private final byte[] readerOrds;
-      private final DocValues.SortedSource termsIndex;
-      private final int docBase;
-
-      public ByteOrdComparator(byte[] readerOrds, DocValues.SortedSource termsIndex, int docBase) {
-        this.readerOrds = readerOrds;
-        this.termsIndex = termsIndex;
-        this.docBase = docBase;
-      }
-
-      @Override
-      public int compareBottom(int doc) {
-        assert bottomSlot != -1;
-        final int docOrd = readerOrds[doc]&0xFF;
-        if (bottomSameReader) {
-          // ord is precisely comparable, even in the equal case
-          return bottomOrd - docOrd;
-        } else if (bottomOrd >= docOrd) {
-          // the equals case always means bottom is > doc
-          // (because we set bottomOrd to the lower bound in
-          // setBottom):
-          return 1;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public void copy(int slot, int doc) {
-        final int ord = readerOrds[doc]&0xFF;
-        ords[slot] = ord;
-        if (values[slot] == null) {
-          values[slot] = new BytesRef();
-        }
-        termsIndex.getByOrd(ord, values[slot]);
-        readerGen[slot] = currentReaderGen;
-      }
-    }
-
-    // Used per-segment when bit width of doc->ord is 16:
-    private final class ShortOrdComparator extends PerSegmentComparator {
-      private final short[] readerOrds;
-      private final DocValues.SortedSource termsIndex;
-      private final int docBase;
-
-      public ShortOrdComparator(short[] readerOrds, DocValues.SortedSource termsIndex, int docBase) {
-        this.readerOrds = readerOrds;
-        this.termsIndex = termsIndex;
-        this.docBase = docBase;
-      }
-
-      @Override
-      public int compareBottom(int doc) {
-        assert bottomSlot != -1;
-        final int docOrd = readerOrds[doc]&0xFFFF;
-        if (bottomSameReader) {
-          // ord is precisely comparable, even in the equal case
-          return bottomOrd - docOrd;
-        } else if (bottomOrd >= docOrd) {
-          // the equals case always means bottom is > doc
-          // (because we set bottomOrd to the lower bound in
-          // setBottom):
-          return 1;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public void copy(int slot, int doc) {
-        final int ord = readerOrds[doc]&0xFFFF;
-        ords[slot] = ord;
-        if (values[slot] == null) {
-          values[slot] = new BytesRef();
-        }
-        termsIndex.getByOrd(ord, values[slot]);
-        readerGen[slot] = currentReaderGen;
-      }
-    }
-
-    // Used per-segment when bit width of doc->ord is 32:
-    private final class IntOrdComparator extends PerSegmentComparator {
-      private final int[] readerOrds;
-      private final DocValues.SortedSource termsIndex;
-      private final int docBase;
-
-      public IntOrdComparator(int[] readerOrds, DocValues.SortedSource termsIndex, int docBase) {
-        this.readerOrds = readerOrds;
-        this.termsIndex = termsIndex;
-        this.docBase = docBase;
-      }
-
-      @Override
-      public int compareBottom(int doc) {
-        assert bottomSlot != -1;
-        final int docOrd = readerOrds[doc];
-        if (bottomSameReader) {
-          // ord is precisely comparable, even in the equal case
-          return bottomOrd - docOrd;
-        } else if (bottomOrd >= docOrd) {
-          // the equals case always means bottom is > doc
-          // (because we set bottomOrd to the lower bound in
-          // setBottom):
-          return 1;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public void copy(int slot, int doc) {
-        final int ord = readerOrds[doc];
-        ords[slot] = ord;
-        if (values[slot] == null) {
-          values[slot] = new BytesRef();
-        }
-        termsIndex.getByOrd(ord, values[slot]);
-        readerGen[slot] = currentReaderGen;
-      }
-    }
-
-    // Used per-segment when bit width is not a native array
-    // size (8, 16, 32):
-    private final class AnyPackedDocToOrdComparator extends PerSegmentComparator {
-      private final PackedInts.Reader readerOrds;
-      private final int docBase;
-
-      public AnyPackedDocToOrdComparator(PackedInts.Reader readerOrds, int docBase) {
-        this.readerOrds = readerOrds;
-        this.docBase = docBase;
-      }
-
-      @Override
-      public int compareBottom(int doc) {
-        assert bottomSlot != -1;
-        final int docOrd = (int) readerOrds.get(doc);
-        if (bottomSameReader) {
-          // ord is precisely comparable, even in the equal case
-          return bottomOrd - docOrd;
-        } else if (bottomOrd >= docOrd) {
-          // the equals case always means bottom is > doc
-          // (because we set bottomOrd to the lower bound in
-          // setBottom):
-          return 1;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public void copy(int slot, int doc) {
-        final int ord = (int) readerOrds.get(doc);
-        ords[slot] = ord;
-        if (values[slot] == null) {
-          values[slot] = new BytesRef();
-        }
-        termsIndex.getByOrd(ord, values[slot]);
-        readerGen[slot] = currentReaderGen;
-      }
-    }
-
-    // Used per-segment when DV doesn't use packed ints for
-    // docToOrds:
-    private final class AnyOrdComparator extends PerSegmentComparator {
-      private final int docBase;
-
-      public AnyOrdComparator(int docBase) {
-        this.docBase = docBase;
-      }
-
-      @Override
-      public int compareBottom(int doc) {
-        final int docOrd = termsIndex.ord(doc);
-        if (bottomSameReader) {
-          // ord is precisely comparable, even in the equal case
-          return bottomOrd - docOrd;
-        } else if (bottomOrd >= docOrd) {
-          // the equals case always means bottom is > doc
-          // (because we set bottomOrd to the lower bound in
-          // setBottom):
-          return 1;
-        } else {
-          return -1;
-        }
-      }
-
-      @Override
-      public void copy(int slot, int doc) {
-        final int ord = termsIndex.ord(doc);
-        ords[slot] = ord;
-        if (values[slot] == null) {
-          values[slot] = new BytesRef();
-        }
-        termsIndex.getByOrd(ord, values[slot]);
-        readerGen[slot] = currentReaderGen;
-      }
-    }
-
-    @Override
-    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {
-      final int docBase = context.docBase;
-
-      final DocValues dv = context.reader().docValues(field);
-      if (dv == null) {
-        // This may mean entire segment had no docs with
-        // this DV field; use default field value (empty
-        // byte[]) in this case:
-        termsIndex = DocValues.getDefaultSortedSource(DocValues.Type.BYTES_VAR_SORTED, context.reader().maxDoc());
-      } else {
-        termsIndex = dv.getSource().asSortedSource();
-        if (termsIndex == null) {
-          // This means segment has doc values, but they are
-          // not able to provide a sorted source; consider
-          // this a hard error:
-          throw new IllegalStateException("DocValues exist for field \"" + field + "\", but not as a sorted source: type=" + dv.getSource().getType() + " reader=" + context.reader());
-        }
-      }
-
-      comp = termsIndex.getComparator();
-
-      FieldComparator<BytesRef> perSegComp = null;
-      if (termsIndex.hasPackedDocToOrd()) {
-        final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();
-        if (docToOrd.hasArray()) {
-          final Object arr = docToOrd.getArray();
-          assert arr != null;
-          if (arr instanceof byte[]) {
-            // 8 bit packed
-            perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);
-          } else if (arr instanceof short[]) {
-            // 16 bit packed
-            perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);
-          } else if (arr instanceof int[]) {
-            // 32 bit packed
-            perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);
-          }
-        }
-
-        if (perSegComp == null) {
-          perSegComp = new AnyPackedDocToOrdComparator(docToOrd, docBase);
-        }
-      } else {
-        if (perSegComp == null) {
-          perSegComp = new AnyOrdComparator(docBase);
-        }
-      }
-        
-      currentReaderGen++;
-      if (bottomSlot != -1) {
-        perSegComp.setBottom(bottomSlot);
-      }
-
-      return perSegComp;
-    }
-    
-    @Override
-    public void setBottom(final int bottom) {
-      bottomSlot = bottom;
-
-      bottomValue = values[bottomSlot];
-      if (currentReaderGen == readerGen[bottomSlot]) {
-        bottomOrd = ords[bottomSlot];
-        bottomSameReader = true;
-      } else {
-        if (bottomValue == null) {
-          // 0 ord is null for all segments
-          assert ords[bottomSlot] == 0;
-          bottomOrd = 0;
-          bottomSameReader = true;
-          readerGen[bottomSlot] = currentReaderGen;
-        } else {
-          final int index = termsIndex.getOrdByValue(bottomValue, tempBR);
-          if (index < 0) {
-            bottomOrd = -index - 2;
-            bottomSameReader = false;
-          } else {
-            bottomOrd = index;
-            // exact value match
-            bottomSameReader = true;
-            readerGen[bottomSlot] = currentReaderGen;            
-            ords[bottomSlot] = bottomOrd;
-          }
-        }
-      }
-    }
-
-    @Override
-    public BytesRef value(int slot) {
-      return values[slot];
-    }
-  }
-
-  /** Sorts by field's natural Term sort order.  All
-   *  comparisons are done using BytesRef.compareTo, which is
-   *  slow for medium to large result sets but possibly
-   *  very fast for very small results sets. */
-  public static final class TermValComparator extends FieldComparator<BytesRef> {
-
-    private BytesRef[] values;
-    private BinaryDocValues docTerms;
-    private final String field;
-    private BytesRef bottom;
-    private final BytesRef tempBR = new BytesRef();
-
-    TermValComparator(int numHits, String field) {
-      values = new BytesRef[numHits];
-      this.field = field;
-    }
-
-    @Override
-    public int compare(int slot1, int slot2) {
-      final BytesRef val1 = values[slot1];
-      final BytesRef val2 = values[slot2];
-      if (val1 == null) {
-        if (val2 == null) {
-          return 0;
-        }
-        return -1;
-      } else if (val2 == null) {
-        return 1;
-      }
-
-      return val1.compareTo(val2);
-    }
-
-    @Override
-    public int compareBottom(int doc) {
-      docTerms.get(doc, tempBR);
-      if (bottom.bytes == BinaryDocValues.MISSING) {
-        if (tempBR.bytes == BinaryDocValues.MISSING) {
-          return 0;
-        }
-        return -1;
-      } else if (tempBR.bytes == BinaryDocValues.MISSING) {
-        return 1;
-      }
-      return bottom.compareTo(tempBR);
-    }
-
-    @Override
-    public void copy(int slot, int doc) {
-      if (values[slot] == null) {
-        values[slot] = new BytesRef();
-      }
-      docTerms.get(doc, values[slot]);
-    }
-
-    @Override
-    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {
-      docTerms = FieldCache.DEFAULT.getTerms(context.reader(), field);
-      return this;
-    }
-    
-    @Override
-    public void setBottom(final int bottom) {
-      this.bottom = values[bottom];
-    }
-
-    @Override
-    public BytesRef value(int slot) {
-      return values[slot];
-    }
-
-    @Override
-    public int compareValues(BytesRef val1, BytesRef val2) {
-      if (val1 == null) {
-        if (val2 == null) {
-          return 0;
-        }
-        return -1;
-      } else if (val2 == null) {
-        return 1;
-      }
-      return val1.compareTo(val2);
-    }
+      return val1.compareTo(val2);
+    }
 
     @Override
     public int compareDocToValue(int doc, BytesRef value) {
@@ -1838,77 +1242,4 @@ public abstract class FieldComparator<T> {
       return tempBR.compareTo(value);
     }
   }
-
-  /** Sorts by field's natural Term sort order.  All
-   *  comparisons are done using BytesRef.compareTo, which is
-   *  slow for medium to large result sets but possibly
-   *  very fast for very small results sets.  The BytesRef
-   *  values are obtained using {@link AtomicReader#docValues}. */
-  public static final class TermValDocValuesComparator extends FieldComparator<BytesRef> {
-
-    private BytesRef[] values;
-    private DocValues.Source docTerms;
-    private final String field;
-    private BytesRef bottom;
-    private final BytesRef tempBR = new BytesRef();
-
-    TermValDocValuesComparator(int numHits, String field) {
-      values = new BytesRef[numHits];
-      this.field = field;
-    }
-
-    @Override
-    public int compare(int slot1, int slot2) {
-      assert values[slot1] != null;
-      assert values[slot2] != null;
-      return values[slot1].compareTo(values[slot2]);
-    }
-
-    @Override
-    public int compareBottom(int doc) {
-      assert bottom != null;
-      return bottom.compareTo(docTerms.getBytes(doc, tempBR));
-    }
-
-    @Override
-    public void copy(int slot, int doc) {
-      if (values[slot] == null) {
-        values[slot] = new BytesRef();
-      }
-      docTerms.getBytes(doc, values[slot]);
-    }
-
-    @Override
-    public FieldComparator<BytesRef> setNextReader(AtomicReaderContext context) throws IOException {
-      final DocValues dv = context.reader().docValues(field);
-      if (dv != null) {
-        docTerms = dv.getSource();
-      } else {
-        docTerms = DocValues.getDefaultSource(DocValues.Type.BYTES_VAR_DEREF);
-      }
-      return this;
-    }
-    
-    @Override
-    public void setBottom(final int bottom) {
-      this.bottom = values[bottom];
-    }
-
-    @Override
-    public BytesRef value(int slot) {
-      return values[slot];
-    }
-
-    @Override
-    public int compareValues(BytesRef val1, BytesRef val2) {
-      assert val1 != null;
-      assert val2 != null;
-      return val1.compareTo(val2);
-    }
-
-    @Override
-    public int compareDocToValue(int doc, BytesRef value) {
-      return docTerms.getBytes(doc, tempBR).compareTo(value);
-    }
-  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/SortField.java b/lucene/core/src/java/org/apache/lucene/search/SortField.java
index b0e1b0d..d2251d1 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SortField.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SortField.java
@@ -257,7 +257,6 @@ public class SortField {
   @Override
   public String toString() {
     StringBuilder buffer = new StringBuilder();
-    String dv = useIndexValues ? " [dv]" : "";
     switch (type) {
       case SCORE:
         buffer.append("<score>");
@@ -268,11 +267,11 @@ public class SortField {
         break;
 
       case STRING:
-        buffer.append("<string" + dv + ": \"").append(field).append("\">");
+        buffer.append("<string" + ": \"").append(field).append("\">");
         break;
 
       case STRING_VAL:
-        buffer.append("<string_val" + dv + ": \"").append(field).append("\">");
+        buffer.append("<string_val" + ": \"").append(field).append("\">");
         break;
 
       case BYTE:
@@ -284,7 +283,7 @@ public class SortField {
         break;
 
       case INT:
-        buffer.append("<int" + dv + ": \"").append(field).append("\">");
+        buffer.append("<int" + ": \"").append(field).append("\">");
         break;
 
       case LONG:
@@ -292,11 +291,11 @@ public class SortField {
         break;
 
       case FLOAT:
-        buffer.append("<float" + dv + ": \"").append(field).append("\">");
+        buffer.append("<float" + ": \"").append(field).append("\">");
         break;
 
       case DOUBLE:
-        buffer.append("<double" + dv + ": \"").append(field).append("\">");
+        buffer.append("<double" + ": \"").append(field).append("\">");
         break;
 
       case CUSTOM:
@@ -347,16 +346,6 @@ public class SortField {
     return hash;
   }
 
-  private boolean useIndexValues;
-
-  public void setUseIndexValues(boolean b) {
-    useIndexValues = b;
-  }
-
-  public boolean getUseIndexValues() {
-    return useIndexValues;
-  }
-
   private Comparator<BytesRef> bytesComparator = BytesRef.getUTF8SortedAsUnicodeComparator();
 
   public void setBytesComparator(Comparator<BytesRef> b) {
@@ -389,18 +378,10 @@ public class SortField {
       return new FieldComparator.DocComparator(numHits);
 
     case INT:
-      if (useIndexValues) {
-        return new FieldComparator.IntDocValuesComparator(numHits, field);
-      } else {
-        return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);
-      }
+      return new FieldComparator.IntComparator(numHits, field, parser, (Integer) missingValue);
 
     case FLOAT:
-      if (useIndexValues) {
-        return new FieldComparator.FloatDocValuesComparator(numHits, field);
-      } else {
-        return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);
-      }
+      return new FieldComparator.FloatComparator(numHits, field, parser, (Float) missingValue);
 
     case LONG:
       return new FieldComparator.LongComparator(numHits, field, parser, (Long) missingValue);
@@ -419,18 +400,10 @@ public class SortField {
       return comparatorSource.newComparator(field, numHits, sortPos, reverse);
 
     case STRING:
-      if (useIndexValues) {
-        return new FieldComparator.TermOrdValDocValuesComparator(numHits, field);
-      } else {
-        return new FieldComparator.TermOrdValComparator(numHits, field);
-      }
+      return new FieldComparator.TermOrdValComparator(numHits, field);
 
     case STRING_VAL:
-      if (useIndexValues) {
-        return new FieldComparator.TermValDocValuesComparator(numHits, field);
-      } else {
-        return new FieldComparator.TermValComparator(numHits, field);
-      }
+      return new FieldComparator.TermValComparator(numHits, field);
 
     case REWRITEABLE:
       throw new IllegalStateException("SortField needs to be rewritten through Sort.rewrite(..) and SortField.rewrite(..)");
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
index 1624b1f..d7e845d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
@@ -47,11 +47,6 @@ public class TestSearchAfter extends LuceneTestCase {
   private IndexReader reader;
   private IndexSearcher searcher;
 
-  private static SortField useDocValues(SortField field) {
-    field.setUseIndexValues(true);
-    return field;
-  }
-
   @Override
   public void setUp() throws Exception {
     super.setUp();
@@ -125,11 +120,11 @@ public class TestSearchAfter extends LuceneTestCase {
       assertQuery(query, filter, new Sort(new SortField[] {new SortField("double", SortField.Type.DOUBLE, reversed)}));
       assertQuery(query, filter, new Sort(new SortField[] {new SortField("bytes", SortField.Type.STRING, reversed)}));
       assertQuery(query, filter, new Sort(new SortField[] {new SortField("bytesval", SortField.Type.STRING_VAL, reversed)}));
-      assertQuery(query, filter, new Sort(new SortField[] {useDocValues(new SortField("intdocvalues", SortField.Type.INT, reversed))}));
-      assertQuery(query, filter, new Sort(new SortField[] {useDocValues(new SortField("floatdocvalues", SortField.Type.FLOAT, reversed))}));
-      assertQuery(query, filter, new Sort(new SortField[] {useDocValues(new SortField("sortedbytesdocvalues", SortField.Type.STRING, reversed))}));
-      assertQuery(query, filter, new Sort(new SortField[] {useDocValues(new SortField("sortedbytesdocvaluesval", SortField.Type.STRING_VAL, reversed))}));
-      assertQuery(query, filter, new Sort(new SortField[] {useDocValues(new SortField("straightbytesdocvalues", SortField.Type.STRING_VAL, reversed))}));
+      assertQuery(query, filter, new Sort(new SortField[] {new SortField("intdocvalues", SortField.Type.INT, reversed)}));
+      assertQuery(query, filter, new Sort(new SortField[] {new SortField("floatdocvalues", SortField.Type.FLOAT, reversed)}));
+      assertQuery(query, filter, new Sort(new SortField[] {new SortField("sortedbytesdocvalues", SortField.Type.STRING, reversed)}));
+      assertQuery(query, filter, new Sort(new SortField[] {new SortField("sortedbytesdocvaluesval", SortField.Type.STRING_VAL, reversed)}));
+      assertQuery(query, filter, new Sort(new SortField[] {new SortField("straightbytesdocvalues", SortField.Type.STRING_VAL, reversed)}));
     }
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSort.java b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
index 130048b..959d3d2 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
@@ -60,11 +60,11 @@ import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.DocIdBitSet;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util._TestUtil;
 import org.junit.BeforeClass;
-
 /**
  * Unit tests for sorting code.
  *
@@ -73,6 +73,8 @@ import org.junit.BeforeClass;
  * @since   lucene 1.4
  */
 
+// nocommit unsuppress this once Lucene40 impls DV 2.0:
+@SuppressCodecs({"Lucene40"})
 public class TestSort extends LuceneTestCase {
   private static int NUM_STRINGS;
   private IndexSearcher full;
@@ -124,7 +126,7 @@ public class TestSort extends LuceneTestCase {
   }; 
 
   // create an index of all the documents, or just the x, or just the y documents
-  private IndexSearcher getIndex (boolean even, boolean odd)
+  private IndexSearcher getIndex(boolean even, boolean odd)
   throws IOException {
     Directory indexStore = newDirectory();
     dirs.add(indexStore);
@@ -149,54 +151,54 @@ public class TestSort extends LuceneTestCase {
     ft1.setStored(true);
     FieldType ft2 = new FieldType();
     ft2.setIndexed(true);
-    for (int i=0; i<data.length; ++i) {
+    for(int i=0; i<data.length; ++i) {
       if (((i%2)==0 && even) || ((i%2)==1 && odd)) {
         Document doc = new Document();
-        doc.add (new Field ("tracer", data[i][0], ft1));
-        doc.add (new TextField ("contents", data[i][1], Field.Store.NO));
+        doc.add(new Field("tracer", data[i][0], ft1));
+        doc.add(new TextField("contents", data[i][1], Field.Store.NO));
         if (data[i][2] != null) {
-          doc.add(new StringField ("int", data[i][2], Field.Store.NO));
-          doc.add(new PackedLongDocValuesField("int", Integer.parseInt(data[i][2])));
+          doc.add(new StringField("int", data[i][2], Field.Store.NO));
+          doc.add(new PackedLongDocValuesField("int_dv", Integer.parseInt(data[i][2])));
         }
         if (data[i][3] != null) {
-          doc.add(new StringField ("float", data[i][3], Field.Store.NO));
-          doc.add(new FloatDocValuesField("float", Float.parseFloat(data[i][3])));
+          doc.add(new StringField("float", data[i][3], Field.Store.NO));
+          doc.add(new FloatDocValuesField("float_dv", Float.parseFloat(data[i][3])));
         }
         if (data[i][4] != null) {
-          doc.add(new StringField ("string", data[i][4], Field.Store.NO));
+          doc.add(new StringField("string", data[i][4], Field.Store.NO));
           switch(stringDVType) {
             case BYTES_FIXED_SORTED:
-              doc.add(new SortedBytesDocValuesField("string", new BytesRef(data[i][4]), true));
+              doc.add(new SortedBytesDocValuesField("string_dv", new BytesRef(data[i][4]), true));
               break;
             case BYTES_VAR_SORTED:
-              doc.add(new SortedBytesDocValuesField("string", new BytesRef(data[i][4]), false));
+              doc.add(new SortedBytesDocValuesField("string_dv", new BytesRef(data[i][4]), false));
               break;
             case BYTES_FIXED_STRAIGHT:
-              doc.add(new StraightBytesDocValuesField("string", new BytesRef(data[i][4]), true));
+              doc.add(new StraightBytesDocValuesField("string_dv", new BytesRef(data[i][4]), true));
               break;
             case BYTES_VAR_STRAIGHT:
-              doc.add(new StraightBytesDocValuesField("string", new BytesRef(data[i][4]), false));
+              doc.add(new StraightBytesDocValuesField("string_dv", new BytesRef(data[i][4]), false));
               break;
             case BYTES_FIXED_DEREF:
-              doc.add(new DerefBytesDocValuesField("string", new BytesRef(data[i][4]), true));
+              doc.add(new DerefBytesDocValuesField("string_dv", new BytesRef(data[i][4]), true));
               break;
             case BYTES_VAR_DEREF:
-              doc.add(new DerefBytesDocValuesField("string", new BytesRef(data[i][4]), false));
+              doc.add(new DerefBytesDocValuesField("string_dv", new BytesRef(data[i][4]), false));
               break;
             default:
               throw new IllegalStateException("unknown type " + stringDVType);
           }
         }
-        if (data[i][5] != null) doc.add (new StringField ("custom",   data[i][5], Field.Store.NO));
-        if (data[i][6] != null) doc.add (new StringField ("i18n",     data[i][6], Field.Store.NO));
-        if (data[i][7] != null) doc.add (new StringField ("long",     data[i][7], Field.Store.NO));
+        if (data[i][5] != null) doc.add(new StringField("custom",   data[i][5], Field.Store.NO));
+        if (data[i][6] != null) doc.add(new StringField("i18n",     data[i][6], Field.Store.NO));
+        if (data[i][7] != null) doc.add(new StringField("long",     data[i][7], Field.Store.NO));
         if (data[i][8] != null) {
-          doc.add(new StringField ("double", data[i][8], Field.Store.NO));
-          doc.add(new DoubleDocValuesField("double", Double.parseDouble(data[i][8])));
+          doc.add(new StringField("double", data[i][8], Field.Store.NO));
+          doc.add(new DoubleDocValuesField("double_dv", Double.parseDouble(data[i][8])));
         }
-        if (data[i][9] != null) doc.add (new StringField ("short",     data[i][9], Field.Store.NO));
-        if (data[i][10] != null) doc.add (new StringField ("byte",     data[i][10], Field.Store.NO));
-        if (data[i][11] != null) doc.add (new StringField ("parser",     data[i][11], Field.Store.NO));
+        if (data[i][9] != null) doc.add(new StringField("short",     data[i][9], Field.Store.NO));
+        if (data[i][10] != null) doc.add(new StringField("byte",     data[i][10], Field.Store.NO));
+        if (data[i][11] != null) doc.add(new StringField("parser",     data[i][11], Field.Store.NO));
 
         for(IndexableField f : doc.getFields()) {
           if (f.fieldType().indexed() && !f.fieldType().omitNorms()) {
@@ -204,44 +206,54 @@ public class TestSort extends LuceneTestCase {
           }
         }
 
-        writer.addDocument (doc);
+        writer.addDocument(doc);
       }
     }
 
     IndexReader reader = writer.getReader();
     writer.close ();
-    IndexSearcher s = newSearcher(reader);
+    // nocommit back to newSearcher(true)? problem is this
+    // sometimes uses slow reader wrapper which does not
+    // provide DV 2.0
+    IndexSearcher s = newSearcher(reader, false);
     return s;
   }
 
   private IndexSearcher getFullIndex()
   throws IOException {
-    return getIndex (true, true);
+    return getIndex(true, true);
   }
   
   private IndexSearcher getFullStrings() throws IOException {
     Directory indexStore = newDirectory();
     dirs.add(indexStore);
     IndexWriter writer = new IndexWriter(
-        indexStore,
-        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).
-            setMergePolicy(newLogMergePolicy(97))
-    );
+                                         indexStore,
+                                         newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).
+                                         setMergePolicy(newLogMergePolicy(97)));
     FieldType onlyStored = new FieldType();
     onlyStored.setStored(true);
     final int fixedLen = getRandomNumber(2, 8);
     final int fixedLen2 = getRandomNumber(1, 4);
-    for (int i=0; i<NUM_STRINGS; i++) {
+    for(int i=0; i<NUM_STRINGS; i++) {
       Document doc = new Document();
       String num = getRandomCharString(getRandomNumber(2, 8), 48, 52);
-      doc.add (new Field ("tracer", num, onlyStored));
-      //doc.add (new Field ("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
+      doc.add(new Field("tracer", num, onlyStored));
+      //doc.add(new Field("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string", num, Field.Store.NO));
-      doc.add(new SortedBytesDocValuesField("string", new BytesRef(num)));
+      if (dvStringSorted) {
+        doc.add(new SortedBytesDocValuesField("string_dv", new BytesRef(num)));
+      } else {
+        doc.add(new DerefBytesDocValuesField("string_dv", new BytesRef(num)));
+      }
       String num2 = getRandomCharString(getRandomNumber(1, 4), 48, 50);
-      doc.add(new StringField ("string2", num2, Field.Store.NO));
-      doc.add(new SortedBytesDocValuesField("string2", new BytesRef(num2)));
-      doc.add (new Field ("tracer2", num2, onlyStored));
+      doc.add(new StringField("string2", num2, Field.Store.NO));
+      if (dvStringSorted) {
+        doc.add(new SortedBytesDocValuesField("string2_dv", new BytesRef(num2)));
+      } else {
+        doc.add(new DerefBytesDocValuesField("string2_dv", new BytesRef(num2)));
+      }
+      doc.add(new Field("tracer2", num2, onlyStored));
       for(IndexableField f2 : doc.getFields()) {
         if (f2.fieldType().indexed() && !f2.fieldType().omitNorms()) {
           ((Field) f2).setBoost(2.0f);
@@ -249,14 +261,22 @@ public class TestSort extends LuceneTestCase {
       }
 
       String numFixed = getRandomCharString(fixedLen, 48, 52);
-      doc.add (new Field ("tracer_fixed", numFixed, onlyStored));
-      //doc.add (new Field ("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
+      doc.add(new Field("tracer_fixed", numFixed, onlyStored));
+      //doc.add(new Field("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string_fixed", numFixed, Field.Store.NO));
-      doc.add(new SortedBytesDocValuesField("string_fixed", new BytesRef(numFixed), true));
+      if (dvStringSorted) {
+        doc.add(new SortedBytesDocValuesField("string_fixed_dv", new BytesRef(numFixed), true));
+      } else {
+        doc.add(new DerefBytesDocValuesField("string_fixed_dv", new BytesRef(numFixed), true));
+      }
       String num2Fixed = getRandomCharString(fixedLen2, 48, 52);
-      doc.add(new StringField ("string2_fixed", num2Fixed, Field.Store.NO));
-      doc.add(new SortedBytesDocValuesField("string2_fixed", new BytesRef(num2Fixed), true));
-      doc.add (new Field ("tracer2_fixed", num2Fixed, onlyStored));
+      doc.add(new StringField("string2_fixed", num2Fixed, Field.Store.NO));
+      if (dvStringSorted) {
+        doc.add(new SortedBytesDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed), true));
+      } else {
+        doc.add(new DerefBytesDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed), true));
+      }
+      doc.add(new Field("tracer2_fixed", num2Fixed, onlyStored));
 
       for(IndexableField f2 : doc.getFields()) {
         if (f2.fieldType().indexed() && !f2.fieldType().omitNorms()) {
@@ -264,12 +284,15 @@ public class TestSort extends LuceneTestCase {
         }
       }
 
-      writer.addDocument (doc);
+      writer.addDocument(doc);
     }
     //System.out.println(writer.getSegmentCount());
     writer.close();
     IndexReader reader = DirectoryReader.open(indexStore);
-    IndexSearcher searcher = newSearcher(reader);
+    // nocommit back to newSearcher(true)? problem is this
+    // sometimes uses slow reader wrapper which does not
+    // provide DV 2.0
+    IndexSearcher searcher = newSearcher(reader, false);
 
     /*
     for(int docID=0;docID<reader.maxDoc();docID++) {
@@ -304,7 +327,7 @@ public class TestSort extends LuceneTestCase {
   
   public String getRandomNumberString(int num, int low, int high) {
     StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < num; i++) {
+    for(int i = 0; i < num; i++) {
       sb.append(getRandomNumber(low, high));
     }
     return sb.toString();
@@ -316,7 +339,7 @@ public class TestSort extends LuceneTestCase {
   
   public String getRandomCharString(int num, int start, int end) {
     StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < num; i++) {
+    for(int i = 0; i < num; i++) {
       sb.append(new Character((char) getRandomNumber(start, end)));
     }
     return sb.toString();
@@ -331,17 +354,17 @@ public class TestSort extends LuceneTestCase {
 
   private IndexSearcher getXIndex()
   throws IOException {
-    return getIndex (true, false);
+    return getIndex(true, false);
   }
 
   private IndexSearcher getYIndex()
   throws IOException {
-    return getIndex (false, true);
+    return getIndex(false, true);
   }
 
   private IndexSearcher getEmptyIndex()
   throws IOException {
-    return getIndex (false, false);
+    return getIndex(false, false);
   }
 
   // Set to true if the DV "string" field is indexed as a
@@ -356,13 +379,13 @@ public class TestSort extends LuceneTestCase {
     full = getFullIndex();
     searchX = getXIndex();
     searchY = getYIndex();
-    queryX = new TermQuery (new Term ("contents", "x"));
-    queryY = new TermQuery (new Term ("contents", "y"));
-    queryA = new TermQuery (new Term ("contents", "a"));
-    queryE = new TermQuery (new Term ("contents", "e"));
-    queryF = new TermQuery (new Term ("contents", "f"));
-    queryG = new TermQuery (new Term ("contents", "g"));
-    queryM = new TermQuery (new Term ("contents", "m"));
+    queryX = new TermQuery(new Term("contents", "x"));
+    queryY = new TermQuery(new Term("contents", "y"));
+    queryA = new TermQuery(new Term("contents", "a"));
+    queryE = new TermQuery(new Term("contents", "e"));
+    queryF = new TermQuery(new Term("contents", "f"));
+    queryG = new TermQuery(new Term("contents", "g"));
+    queryM = new TermQuery(new Term("contents", "m"));
     sort = new Sort();
     
   }
@@ -374,78 +397,79 @@ public class TestSort extends LuceneTestCase {
     full.reader.close();
     searchX.reader.close();
     searchY.reader.close();
-    for (Directory dir : dirs)
+    for(Directory dir : dirs) {
       dir.close();
+    }
     super.tearDown();
   }
 
   // test the sorts by score and document number
   public void testBuiltInSorts() throws Exception {
     sort = new Sort();
-    assertMatches (full, queryX, sort, "ACEGI");
-    assertMatches (full, queryY, sort, "BDFHJ");
+    assertMatches(full, queryX, sort, "ACEGI");
+    assertMatches(full, queryY, sort, "BDFHJ");
 
     sort.setSort(SortField.FIELD_DOC);
-    assertMatches (full, queryX, sort, "ACEGI");
-    assertMatches (full, queryY, sort, "BDFHJ");
+    assertMatches(full, queryX, sort, "ACEGI");
+    assertMatches(full, queryY, sort, "BDFHJ");
   }
 
-  private static SortField useDocValues(SortField field) {
-    field.setUseIndexValues(true);
-    return field;
-  }
   // test sorts where the type of field is specified
   public void testTypedSort() throws Exception {
-    sort.setSort (new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "IGAEC");
-    assertMatches (full, queryY, sort, "DHFJB");
+    sort.setSort(new SortField("int", SortField.Type.INT), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "IGAEC");
+    assertMatches(full, queryY, sort, "DHFJB");
     
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "GCIEA");
-    assertMatches (full, queryY, sort, "DHJFB");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "GCIEA");
+    assertMatches(full, queryY, sort, "DHJFB");
 
-    sort.setSort (new SortField ("long", SortField.Type.LONG), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "EACGI");
-    assertMatches (full, queryY, sort, "FBJHD");
+    sort.setSort(new SortField("long", SortField.Type.LONG), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "EACGI");
+    assertMatches(full, queryY, sort, "FBJHD");
 
-    sort.setSort (new SortField ("double", SortField.Type.DOUBLE), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "AGICE");
-    assertMatches (full, queryY, sort, "DJHBF");
+    sort.setSort(new SortField("double", SortField.Type.DOUBLE), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "AGICE");
+    assertMatches(full, queryY, sort, "DJHBF");
     
-    sort.setSort (new SortField ("byte", SortField.Type.BYTE), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "CIGAE");
-    assertMatches (full, queryY, sort, "DHFBJ");
+    sort.setSort(new SortField("byte", SortField.Type.BYTE), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "CIGAE");
+    assertMatches(full, queryY, sort, "DHFBJ");
 
-    sort.setSort (new SortField ("short", SortField.Type.SHORT), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "IAGCE");
-    assertMatches (full, queryY, sort, "DFHBJ");
+    sort.setSort(new SortField("short", SortField.Type.SHORT), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "IAGCE");
+    assertMatches(full, queryY, sort, "DFHBJ");
 
-    sort.setSort (new SortField ("string", SortField.Type.STRING), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "AIGEC");
-    assertMatches (full, queryY, sort, "DJHFB");
+    sort.setSort(new SortField("string", SortField.Type.STRING), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "AIGEC");
+    assertMatches(full, queryY, sort, "DJHFB");
     
-    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "IGAEC");
-    assertMatches (full, queryY, sort, "DHFJB");
+    sort.setSort(new SortField("int_dv", SortField.Type.INT), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "IGAEC");
+    assertMatches(full, queryY, sort, "DHFJB");
 
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "GCIEA");
-    assertMatches (full, queryY, sort, "DHJFB");
-      
-    sort.setSort (useDocValues(new SortField ("double", SortField.Type.DOUBLE)), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "AGICE");
-    assertMatches (full, queryY, sort, "DJHBF");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "GCIEA");
+    assertMatches(full, queryY, sort, "DHJFB");
+
+    sort.setSort(new SortField("double_dv", SortField.Type.DOUBLE), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "AGICE");
+    assertMatches(full, queryY, sort, "DJHBF");
 
-    sort.setSort (useDocValues(new SortField ("string", getDVStringSortType())), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "AIGEC");
-    assertMatches (full, queryY, sort, "DJHFB");
+    sort.setSort(new SortField("string_dv", getDVStringSortType()), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "AIGEC");
+    assertMatches(full, queryY, sort, "DJHFB");
   }
 
   private SortField.Type getDVStringSortType() {
     if (dvStringSorted) {
       // If you index as sorted source you can still sort by
       // value instead:
-      return random().nextBoolean() ? SortField.Type.STRING : SortField.Type.STRING_VAL;
+      // nocommit re-enable?  we need to fix FC.getTerms to
+      // "fallback" to getTermsIndex if the sorted DV is
+      // available
+      //return random().nextBoolean() ? SortField.Type.STRING : SortField.Type.STRING_VAL;
+      return SortField.Type.STRING;
     } else {
       return SortField.Type.STRING_VAL;
     }
@@ -531,20 +555,23 @@ public class TestSort extends LuceneTestCase {
 
     // Doc values field, var length
     sort.setSort(
-                 useDocValues(new SortField("string", getDVStringSortType())),
-                 useDocValues(new SortField("string2", getDVStringSortType(), true)),
+                 new SortField("string_dv", getDVStringSortType()),
+                 new SortField("string2_dv", getDVStringSortType(), true),
                  SortField.FIELD_DOC);
     verifyStringSort(sort);
 
     // Doc values field, fixed length
     sort.setSort(
-                 useDocValues(new SortField("string_fixed", getDVStringSortType())),
-                 useDocValues(new SortField("string2_fixed", getDVStringSortType(), true)),
+                 new SortField("string_fixed_dv", getDVStringSortType()),
+                 new SortField("string2_fixed_dv", getDVStringSortType(), true),
                  SortField.FIELD_DOC);
     verifyStringSort(sort);
   }
 
   private void verifyStringSort(Sort sort) throws Exception {
+    if (VERBOSE) {
+      System.out.println("verifySort sort=" + sort);
+    }
     final IndexSearcher searcher = getFullStrings();
     final ScoreDoc[] result = searcher.search(new MatchAllDocsQuery(), null, _TestUtil.nextInt(random(), 500, searcher.getIndexReader().maxDoc()), sort).scoreDocs;
     StringBuilder buff = new StringBuilder();
@@ -553,12 +580,12 @@ public class TestSort extends LuceneTestCase {
     String lastSub = null;
     int lastDocId = 0;
     boolean fail = false;
-    final String fieldSuffix = sort.getSort()[0].getField().endsWith("_fixed") ? "_fixed" : "";
-    for (int x = 0; x < n; ++x) {
+    final String fieldSuffix = (sort.getSort()[0].getField().indexOf("_fixed") != -1) ? "_fixed" : "";
+    for(int x = 0; x < n; ++x) {
       StoredDocument doc2 = searcher.doc(result[x].doc);
       StorableField[] v = doc2.getFields("tracer" + fieldSuffix);
       StorableField[] v2 = doc2.getFields("tracer2" + fieldSuffix);
-      for (int j = 0; j < v.length; ++j) {
+      for(int j = 0; j < v.length; ++j) {
         buff.append(v[j].stringValue() + "(" + v2[j].stringValue() + ")(" + result[x].doc+")\n");
         if (last != null) {
           int cmp = v[j].stringValue().compareTo(last);
@@ -606,57 +633,57 @@ public class TestSort extends LuceneTestCase {
     FieldCache fc = FieldCache.DEFAULT;
 
 
-    sort.setSort (new SortField ("parser", new FieldCache.IntParser(){
+    sort.setSort(new SortField("parser", new FieldCache.IntParser(){
       public final int parseInt(final BytesRef term) {
         return (term.bytes[term.offset]-'A') * 123456;
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " IntParser");
     fc.purgeAllCaches();
 
-    sort.setSort (new SortField ("parser", new FieldCache.FloatParser(){
+    sort.setSort(new SortField("parser", new FieldCache.FloatParser(){
       public final float parseFloat(final BytesRef term) {
-        return (float) Math.sqrt( term.bytes[term.offset] );
+        return (float) Math.sqrt( term.bytes[term.offset]);
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " FloatParser");
     fc.purgeAllCaches();
 
-    sort.setSort (new SortField ("parser", new FieldCache.LongParser(){
+    sort.setSort(new SortField("parser", new FieldCache.LongParser(){
       public final long parseLong(final BytesRef term) {
         return (term.bytes[term.offset]-'A') * 1234567890L;
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " LongParser");
     fc.purgeAllCaches();
 
-    sort.setSort (new SortField ("parser", new FieldCache.DoubleParser(){
+    sort.setSort(new SortField("parser", new FieldCache.DoubleParser(){
       public final double parseDouble(final BytesRef term) {
-        return Math.pow( term.bytes[term.offset], (term.bytes[term.offset]-'A') );
+        return Math.pow( term.bytes[term.offset], (term.bytes[term.offset]-'A'));
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " DoubleParser");
     fc.purgeAllCaches();
 
-    sort.setSort (new SortField ("parser", new FieldCache.ByteParser(){
+    sort.setSort(new SortField("parser", new FieldCache.ByteParser(){
       public final byte parseByte(final BytesRef term) {
         return (byte) (term.bytes[term.offset]-'A');
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " ByteParser");
     fc.purgeAllCaches();
 
-    sort.setSort (new SortField ("parser", new FieldCache.ShortParser(){
+    sort.setSort(new SortField("parser", new FieldCache.ShortParser(){
       public final short parseShort(final BytesRef term) {
         return (short) (term.bytes[term.offset]-'A');
       }
-    }), SortField.FIELD_DOC );
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    }), SortField.FIELD_DOC);
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
     assertSaneFieldCaches(getTestName() + " ShortParser");
     fc.purgeAllCaches();
   }
@@ -666,35 +693,35 @@ public class TestSort extends LuceneTestCase {
     IndexSearcher empty = getEmptyIndex();
 
     sort = new Sort();
-    assertMatches (empty, queryX, sort, "");
+    assertMatches(empty, queryX, sort, "");
 
     sort.setSort(SortField.FIELD_DOC);
-    assertMatches (empty, queryX, sort, "");
+    assertMatches(empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("int", SortField.Type.INT), SortField.FIELD_DOC);
+    assertMatches(empty, queryX, sort, "");
     
-    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("int_dv", SortField.Type.INT), SortField.FIELD_DOC);
+    assertMatches(empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("string", SortField.Type.STRING, true), SortField.FIELD_DOC );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("string", SortField.Type.STRING, true), SortField.FIELD_DOC);
+    assertMatches(empty, queryX, sort, "");
 
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT), new SortField ("string", SortField.Type.STRING) );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT), new SortField("string", SortField.Type.STRING));
+    assertMatches(empty, queryX, sort, "");
     
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)), new SortField ("string", SortField.Type.STRING) );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT), new SortField("string", SortField.Type.STRING));
+    assertMatches(empty, queryX, sort, "");
 
-    sort.setSort (useDocValues(new SortField ("string", getDVStringSortType(), true)), SortField.FIELD_DOC );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("string_dv", getDVStringSortType(), true), SortField.FIELD_DOC);
+    assertMatches(empty, queryX, sort, "");
 
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)),
-                  useDocValues(new SortField ("string", getDVStringSortType())) );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT),
+                  new SortField("string_dv", getDVStringSortType()));
+    assertMatches(empty, queryX, sort, "");
     
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)), useDocValues(new SortField ("string", getDVStringSortType())) );
-    assertMatches (empty, queryX, sort, "");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT), new SortField("string_dv", getDVStringSortType()));
+    assertMatches(empty, queryX, sort, "");
   }
 
   static class MyFieldComparator extends FieldComparator<Integer> {
@@ -763,43 +790,43 @@ public class TestSort extends LuceneTestCase {
 
   // Test sorting w/ custom FieldComparator
   public void testNewCustomFieldParserSort() throws Exception {
-    sort.setSort (new SortField ("parser", new MyFieldComparatorSource()));
-    assertMatches (full, queryA, sort, "JIHGFEDCBA");
+    sort.setSort(new SortField("parser", new MyFieldComparatorSource()));
+    assertMatches(full, queryA, sort, "JIHGFEDCBA");
   }
 
   // test sorts in reverse
   public void testReverseSort() throws Exception {
-    sort.setSort (new SortField (null, SortField.Type.SCORE, true), SortField.FIELD_DOC );
-    assertMatches (full, queryX, sort, "IEGCA");
-    assertMatches (full, queryY, sort, "JFHDB");
+    sort.setSort(new SortField(null, SortField.Type.SCORE, true), SortField.FIELD_DOC);
+    assertMatches(full, queryX, sort, "IEGCA");
+    assertMatches(full, queryY, sort, "JFHDB");
 
-    sort.setSort (new SortField (null, SortField.Type.DOC, true));
-    assertMatches (full, queryX, sort, "IGECA");
-    assertMatches (full, queryY, sort, "JHFDB");
+    sort.setSort(new SortField(null, SortField.Type.DOC, true));
+    assertMatches(full, queryX, sort, "IGECA");
+    assertMatches(full, queryY, sort, "JHFDB");
 
-    sort.setSort (new SortField ("int", SortField.Type.INT, true) );
-    assertMatches (full, queryX, sort, "CAEGI");
-    assertMatches (full, queryY, sort, "BJFHD");
+    sort.setSort(new SortField("int", SortField.Type.INT, true));
+    assertMatches(full, queryX, sort, "CAEGI");
+    assertMatches(full, queryY, sort, "BJFHD");
 
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT, true) );
-    assertMatches (full, queryX, sort, "AECIG");
-    assertMatches (full, queryY, sort, "BFJHD");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT, true));
+    assertMatches(full, queryX, sort, "AECIG");
+    assertMatches(full, queryY, sort, "BFJHD");
     
-    sort.setSort (new SortField ("string", SortField.Type.STRING, true) );
-    assertMatches (full, queryX, sort, "CEGIA");
-    assertMatches (full, queryY, sort, "BFHJD");
+    sort.setSort(new SortField("string", SortField.Type.STRING, true));
+    assertMatches(full, queryX, sort, "CEGIA");
+    assertMatches(full, queryY, sort, "BFHJD");
     
-    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT, true)) );
-    assertMatches (full, queryX, sort, "CAEGI");
-    assertMatches (full, queryY, sort, "BJFHD");
+    sort.setSort(new SortField("int_dv", SortField.Type.INT, true));
+    assertMatches(full, queryX, sort, "CAEGI");
+    assertMatches(full, queryY, sort, "BJFHD");
     
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT, true)) );
-    assertMatches (full, queryX, sort, "AECIG");
-    assertMatches (full, queryY, sort, "BFJHD");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT, true));
+    assertMatches(full, queryX, sort, "AECIG");
+    assertMatches(full, queryY, sort, "BFJHD");
 
-    sort.setSort (useDocValues(new SortField ("string", getDVStringSortType(), true)) );
-    assertMatches (full, queryX, sort, "CEGIA");
-    assertMatches (full, queryY, sort, "BFHJD");
+    sort.setSort(new SortField("string_dv", getDVStringSortType(), true));
+    assertMatches(full, queryX, sort, "CEGIA");
+    assertMatches(full, queryY, sort, "BFHJD");
   }
 
   // test sorting when the sort field is empty (undefined) for some of the documents
@@ -807,80 +834,80 @@ public class TestSort extends LuceneTestCase {
 
     // NOTE: do not test DocValues fields here, since you
     // can't sort when some documents don't have the field
-    sort.setSort (new SortField ("string", SortField.Type.STRING) );
-    assertMatches (full, queryF, sort, "ZJI");
+    sort.setSort(new SortField("string", SortField.Type.STRING));
+    assertMatches(full, queryF, sort, "ZJI");
 
-    sort.setSort (new SortField ("string", SortField.Type.STRING, true) );
-    assertMatches (full, queryF, sort, "IJZ");
+    sort.setSort(new SortField("string", SortField.Type.STRING, true));
+    assertMatches(full, queryF, sort, "IJZ");
     
-    sort.setSort (new SortField ("int", SortField.Type.INT) );
-    assertMatches (full, queryF, sort, "IZJ");
+    sort.setSort(new SortField("int", SortField.Type.INT));
+    assertMatches(full, queryF, sort, "IZJ");
 
-    sort.setSort (new SortField ("int", SortField.Type.INT, true) );
-    assertMatches (full, queryF, sort, "JZI");
+    sort.setSort(new SortField("int", SortField.Type.INT, true));
+    assertMatches(full, queryF, sort, "JZI");
 
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT) );
-    assertMatches (full, queryF, sort, "ZJI");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT));
+    assertMatches(full, queryF, sort, "ZJI");
 
     // using a nonexisting field as first sort key shouldn't make a difference:
-    sort.setSort (new SortField ("nosuchfield", SortField.Type.STRING),
-        new SortField ("float", SortField.Type.FLOAT) );
-    assertMatches (full, queryF, sort, "ZJI");
+    sort.setSort(new SortField("nosuchfield", SortField.Type.STRING),
+        new SortField("float", SortField.Type.FLOAT));
+    assertMatches(full, queryF, sort, "ZJI");
 
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT, true) );
-    assertMatches (full, queryF, sort, "IJZ");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT, true));
+    assertMatches(full, queryF, sort, "IJZ");
 
     // When a field is null for both documents, the next SortField should be used.
-    sort.setSort (new SortField ("int", SortField.Type.INT),
-                                new SortField ("string", SortField.Type.STRING),
-        new SortField ("float", SortField.Type.FLOAT) );
-    assertMatches (full, queryG, sort, "ZWXY");
+    sort.setSort(new SortField("int", SortField.Type.INT),
+                 new SortField("string", SortField.Type.STRING),
+        new SortField("float", SortField.Type.FLOAT));
+    assertMatches(full, queryG, sort, "ZWXY");
 
     // Reverse the last criterium to make sure the test didn't pass by chance
-    sort.setSort (new SortField ("int", SortField.Type.INT),
-                                new SortField ("string", SortField.Type.STRING),
-                  new SortField ("float", SortField.Type.FLOAT, true) );
-    assertMatches (full, queryG, sort, "ZYXW");
+    sort.setSort(new SortField("int", SortField.Type.INT),
+                 new SortField("string", SortField.Type.STRING),
+                 new SortField("float", SortField.Type.FLOAT, true));
+    assertMatches(full, queryG, sort, "ZYXW");
 
     // Do the same for a ParallelMultiSearcher
     ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory("testEmptyFieldSort"));
-    IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);
+    IndexSearcher parallelSearcher = new IndexSearcher(full.getIndexReader(), exec);
 
-    sort.setSort (new SortField ("int", SortField.Type.INT),
-                  new SortField ("string", SortField.Type.STRING),
-                  new SortField ("float", SortField.Type.FLOAT) );
-    assertMatches (parallelSearcher, queryG, sort, "ZWXY");
+    sort.setSort(new SortField("int", SortField.Type.INT),
+                 new SortField("string", SortField.Type.STRING),
+                 new SortField("float", SortField.Type.FLOAT));
+    assertMatches(parallelSearcher, queryG, sort, "ZWXY");
 
-    sort.setSort (new SortField ("int", SortField.Type.INT),
-                  new SortField ("string", SortField.Type.STRING),
-                  new SortField ("float", SortField.Type.FLOAT, true) );
-    assertMatches (parallelSearcher, queryG, sort, "ZYXW");
+    sort.setSort(new SortField("int", SortField.Type.INT),
+                 new SortField("string", SortField.Type.STRING),
+                 new SortField("float", SortField.Type.FLOAT, true));
+    assertMatches(parallelSearcher, queryG, sort, "ZYXW");
     exec.shutdown();
     exec.awaitTermination(1000, TimeUnit.MILLISECONDS);
   }
 
   // test sorts using a series of fields
   public void testSortCombos() throws Exception {
-    sort.setSort (new SortField ("int", SortField.Type.INT), new SortField ("float", SortField.Type.FLOAT) );
-    assertMatches (full, queryX, sort, "IGEAC");
+    sort.setSort(new SortField("int", SortField.Type.INT), new SortField("float", SortField.Type.FLOAT));
+    assertMatches(full, queryX, sort, "IGEAC");
 
-    sort.setSort (new SortField ("int", SortField.Type.INT, true), new SortField (null, SortField.Type.DOC, true) );
-    assertMatches (full, queryX, sort, "CEAGI");
+    sort.setSort(new SortField("int", SortField.Type.INT, true), new SortField(null, SortField.Type.DOC, true));
+    assertMatches(full, queryX, sort, "CEAGI");
 
-    sort.setSort (new SortField ("float", SortField.Type.FLOAT), new SortField ("string", SortField.Type.STRING) );
-    assertMatches (full, queryX, sort, "GICEA");
+    sort.setSort(new SortField("float", SortField.Type.FLOAT), new SortField("string", SortField.Type.STRING));
+    assertMatches(full, queryX, sort, "GICEA");
 
-    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT)),
-                  useDocValues(new SortField ("float", SortField.Type.FLOAT)));
-    assertMatches (full, queryX, sort, "IGEAC");
+    sort.setSort(new SortField("int_dv", SortField.Type.INT),
+                 new SortField("float_dv", SortField.Type.FLOAT));
+    assertMatches(full, queryX, sort, "IGEAC");
 
-    sort.setSort (useDocValues(new SortField ("int", SortField.Type.INT, true)),
-                  useDocValues(new SortField (null, SortField.Type.DOC, true)));
-    assertMatches (full, queryX, sort, "CEAGI");
+    sort.setSort(new SortField("int_dv", SortField.Type.INT, true),
+                 new SortField(null, SortField.Type.DOC, true));
+    assertMatches(full, queryX, sort, "CEAGI");
 
-    sort.setSort (useDocValues(new SortField ("float", SortField.Type.FLOAT)),
-                  useDocValues(new SortField ("string", getDVStringSortType())));
-    assertMatches (full, queryX, sort, "GICEA");
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT),
+                 new SortField("string_dv", getDVStringSortType()));
+    assertMatches(full, queryX, sort, "GICEA");
   }
 
   // test a variety of sorts using a parallel multisearcher
@@ -889,9 +916,12 @@ public class TestSort extends LuceneTestCase {
     IndexSearcher searcher = new IndexSearcher(
                                   new MultiReader(searchX.getIndexReader(),
                                                   searchY.getIndexReader()), exec);
-    runMultiSorts(searcher, false);
-    exec.shutdown();
-    exec.awaitTermination(1000, TimeUnit.MILLISECONDS);
+    try {
+      runMultiSorts(searcher, false);
+    } finally {
+      exec.shutdown();
+      exec.awaitTermination(1000, TimeUnit.MILLISECONDS);
+    }
   }
 
   public void testTopDocsScores() throws Exception {
@@ -908,7 +938,7 @@ public class TestSort extends LuceneTestCase {
     // a filter that only allows through the first hit
     Filter filt = new Filter() {
       @Override
-      public DocIdSet getDocIdSet (AtomicReaderContext context, Bits acceptDocs) {
+      public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {
         assertNull("acceptDocs should be null, as we have no deletions", acceptDocs);
         BitSet bs = new BitSet(context.reader().maxDoc());
         bs.set(0, context.reader().maxDoc());
@@ -930,7 +960,7 @@ public class TestSort extends LuceneTestCase {
     // does not use Searcher's default search methods (with Sort) since all set
     // fillFields to true.
     Sort[] sort = new Sort[] { new Sort(SortField.FIELD_DOC), new Sort() };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, false,
           false, false, true);
@@ -938,7 +968,7 @@ public class TestSort extends LuceneTestCase {
       full.search(q, tdc);
       
       ScoreDoc[] sd = tdc.topDocs().scoreDocs;
-      for (int j = 1; j < sd.length; j++) {
+      for(int j = 1; j < sd.length; j++) {
         assertTrue(sd[j].doc != sd[j - 1].doc);
       }
       
@@ -949,7 +979,7 @@ public class TestSort extends LuceneTestCase {
 
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, false,
           false, true);
@@ -958,7 +988,7 @@ public class TestSort extends LuceneTestCase {
       
       TopDocs td = tdc.topDocs();
       ScoreDoc[] sd = td.scoreDocs;
-      for (int j = 0; j < sd.length; j++) {
+      for(int j = 0; j < sd.length; j++) {
         assertTrue(Float.isNaN(sd[j].score));
       }
       assertTrue(Float.isNaN(td.getMaxScore()));
@@ -969,7 +999,7 @@ public class TestSort extends LuceneTestCase {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
           false, true);
@@ -978,7 +1008,7 @@ public class TestSort extends LuceneTestCase {
       
       TopDocs td = tdc.topDocs();
       ScoreDoc[] sd = td.scoreDocs;
-      for (int j = 0; j < sd.length; j++) {
+      for(int j = 0; j < sd.length; j++) {
         assertTrue(!Float.isNaN(sd[j].score));
       }
       assertTrue(Float.isNaN(td.getMaxScore()));
@@ -990,7 +1020,7 @@ public class TestSort extends LuceneTestCase {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC, SortField.FIELD_SCORE) };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
           false, true);
@@ -999,7 +1029,7 @@ public class TestSort extends LuceneTestCase {
       
       TopDocs td = tdc.topDocs();
       ScoreDoc[] sd = td.scoreDocs;
-      for (int j = 0; j < sd.length; j++) {
+      for(int j = 0; j < sd.length; j++) {
         assertTrue(!Float.isNaN(sd[j].score));
       }
       assertTrue(Float.isNaN(td.getMaxScore()));
@@ -1010,7 +1040,7 @@ public class TestSort extends LuceneTestCase {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
           true, true);
@@ -1019,7 +1049,7 @@ public class TestSort extends LuceneTestCase {
       
       TopDocs td = tdc.topDocs();
       ScoreDoc[] sd = td.scoreDocs;
-      for (int j = 0; j < sd.length; j++) {
+      for(int j = 0; j < sd.length; j++) {
         assertTrue(!Float.isNaN(sd[j].score));
       }
       assertTrue(!Float.isNaN(td.getMaxScore()));
@@ -1058,8 +1088,8 @@ public class TestSort extends LuceneTestCase {
     // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return
     // the clause instead of BQ.
     bq.setMinimumNumberShouldMatch(1);
-    for (int i = 0; i < sort.length; i++) {
-      for (int j = 0; j < tfcOptions.length; j++) {
+    for(int i = 0; i < sort.length; i++) {
+      for(int j = 0; j < tfcOptions.length; j++) {
         TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10,
             tfcOptions[j][0], tfcOptions[j][1], tfcOptions[j][2], false);
 
@@ -1107,8 +1137,8 @@ public class TestSort extends LuceneTestCase {
     // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return
     // the clause instead of BQ.
     bq.setMinimumNumberShouldMatch(1);
-    for (int i = 0; i < sort.length; i++) {
-      for (int j = 0; j < tfcOptions.length; j++) {
+    for(int i = 0; i < sort.length; i++) {
+      for(int j = 0; j < tfcOptions.length; j++) {
         TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10,
             tfcOptions[j][0], tfcOptions[j][1], tfcOptions[j][2], false);
 
@@ -1127,7 +1157,7 @@ public class TestSort extends LuceneTestCase {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
-    for (int i = 0; i < sort.length; i++) {
+    for(int i = 0; i < sort.length; i++) {
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true, true, true);
       TopDocs td = tdc.topDocs();
       assertEquals(0, td.totalHits);
@@ -1141,11 +1171,11 @@ public class TestSort extends LuceneTestCase {
     String expected = isFull ? "ABCDEFGHIJ" : "ACEGIBDFHJ";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField ("int", SortField.Type.INT));
+    sort.setSort(new SortField("int", SortField.Type.INT));
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(new SortField ("int", SortField.Type.INT), SortField.FIELD_DOC);
+    sort.setSort(new SortField("int", SortField.Type.INT), SortField.FIELD_DOC);
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
@@ -1153,7 +1183,7 @@ public class TestSort extends LuceneTestCase {
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
     
-    sort.setSort(new SortField ("float", SortField.Type.FLOAT), SortField.FIELD_DOC);
+    sort.setSort(new SortField("float", SortField.Type.FLOAT), SortField.FIELD_DOC);
     assertMatches(multi, queryA, sort, "GDHJCIEFAB");
 
     sort.setSort(new SortField("float", SortField.Type.FLOAT));
@@ -1178,65 +1208,65 @@ public class TestSort extends LuceneTestCase {
     sort.setSort(new SortField("float", SortField.Type.FLOAT),new SortField("string", SortField.Type.STRING));
     assertMatches(multi, queryA, sort, "GDHJICEFAB");
 
-    sort.setSort(new SortField ("int", SortField.Type.INT));
+    sort.setSort(new SortField("int", SortField.Type.INT));
     assertMatches(multi, queryF, sort, "IZJ");
 
-    sort.setSort(new SortField ("int", SortField.Type.INT, true));
+    sort.setSort(new SortField("int", SortField.Type.INT, true));
     assertMatches(multi, queryF, sort, "JZI");
 
-    sort.setSort(new SortField ("float", SortField.Type.FLOAT));
+    sort.setSort(new SortField("float", SortField.Type.FLOAT));
     assertMatches(multi, queryF, sort, "ZJI");
 
-    sort.setSort(new SortField ("string", SortField.Type.STRING));
+    sort.setSort(new SortField("string", SortField.Type.STRING));
     assertMatches(multi, queryF, sort, "ZJI");
 
-    sort.setSort(new SortField ("string", SortField.Type.STRING, true));
+    sort.setSort(new SortField("string", SortField.Type.STRING, true));
     assertMatches(multi, queryF, sort, "IJZ");
 
-    sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT));
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)), SortField.FIELD_DOC);
+    sort.setSort(new SortField("int_dv", SortField.Type.INT), SortField.FIELD_DOC);
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
 
-    sort.setSort(useDocValues(new SortField("int", SortField.Type.INT)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT));
     expected = isFull ? "IDHFGJABEC" : "IDHFGJAEBC";
     assertMatches(multi, queryA, sort, expected);
     
-    sort.setSort(useDocValues(new SortField ("float", SortField.Type.FLOAT)), SortField.FIELD_DOC);
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT), SortField.FIELD_DOC);
     assertMatches(multi, queryA, sort, "GDHJCIEFAB");
 
-    sort.setSort(useDocValues(new SortField("float", SortField.Type.FLOAT)));
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT));
     assertMatches(multi, queryA, sort, "GDHJCIEFAB");
     
-    sort.setSort(useDocValues(new SortField("int", SortField.Type.INT, true)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT, true));
     expected = isFull ? "CABEJGFHDI" : "CAEBJGFHDI";
     assertMatches(multi, queryA, sort, expected);
     
-    sort.setSort(useDocValues(new SortField("int", SortField.Type.INT)), useDocValues(new SortField("float", SortField.Type.FLOAT)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT), new SortField("float_dv", SortField.Type.FLOAT));
     assertMatches(multi, queryA, sort, "IDHFGJEABC");
     
-    sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT));
     assertMatches(multi, queryF, sort, "IZJ");
 
-    sort.setSort(useDocValues(new SortField ("int", SortField.Type.INT, true)));
+    sort.setSort(new SortField("int_dv", SortField.Type.INT, true));
     assertMatches(multi, queryF, sort, "JZI");
 
-    sort.setSort(useDocValues(new SortField("string", getDVStringSortType())));
+    sort.setSort(new SortField("string_dv", getDVStringSortType()));
     assertMatches(multi, queryA, sort, "DJAIHGFEBC");
       
-    sort.setSort(useDocValues(new SortField("string", getDVStringSortType(), true)));
+    sort.setSort(new SortField("string_dv", getDVStringSortType(), true));
     assertMatches(multi, queryA, sort, "CBEFGHIAJD");
       
-    sort.setSort(useDocValues(new SortField("float", SortField.Type.FLOAT)),useDocValues(new SortField("string", getDVStringSortType())));
+    sort.setSort(new SortField("float_dv", SortField.Type.FLOAT), new SortField("string_dv", getDVStringSortType()));
     assertMatches(multi, queryA, sort, "GDHJICEFAB");
 
-    sort.setSort(useDocValues(new SortField ("string", getDVStringSortType())));
+    sort.setSort(new SortField("string_dv", getDVStringSortType()));
     assertMatches(multi, queryF, sort, "ZJI");
 
-    sort.setSort(useDocValues(new SortField ("string", getDVStringSortType(), true)));
+    sort.setSort(new SortField("string_dv", getDVStringSortType(), true));
     assertMatches(multi, queryF, sort, "IJZ");
     
     // up to this point, all of the searches should have "sane" 
@@ -1247,13 +1277,16 @@ public class TestSort extends LuceneTestCase {
   }
 
   private void assertMatches(IndexSearcher searcher, Query query, Sort sort, String expectedResult) throws IOException {
-    assertMatches( null, searcher, query, sort, expectedResult );
+    assertMatches( null, searcher, query, sort, expectedResult);
   }
 
 
   // make sure the documents returned by the search match the expected list
   private void assertMatches(String msg, IndexSearcher searcher, Query query, Sort sort,
       String expectedResult) throws IOException {
+    if (VERBOSE) {
+      System.out.println("assertMatches searcher=" + searcher + " sort=" + sort);
+    }
 
     //ScoreDoc[] result = searcher.search (query, null, 1000, sort).scoreDocs;
     TopDocs hits = searcher.search(query, null, Math.max(1, expectedResult.length()), sort, true, true);
@@ -1261,10 +1294,10 @@ public class TestSort extends LuceneTestCase {
     assertEquals(expectedResult.length(),hits.totalHits);
     StringBuilder buff = new StringBuilder(10);
     int n = result.length;
-    for (int i=0; i<n; ++i) {
+    for(int i=0; i<n; ++i) {
       StoredDocument doc = searcher.doc(result[i].doc);
       StorableField[] v = doc.getFields("tracer");
-      for (int j=0; j<v.length; ++j) {
+      for(int j=0; j<v.length; ++j) {
         buff.append (v[j].stringValue());
       }
     }
@@ -1300,17 +1333,17 @@ public class TestSort extends LuceneTestCase {
     Directory indexStore = newDirectory();
     IndexWriter writer = new IndexWriter(indexStore, newIndexWriterConfig(
         TEST_VERSION_CURRENT, new MockAnalyzer(random())));
-    for (int i=0; i<5; i++) {
+    for(int i=0; i<5; i++) {
         Document doc = new Document();
-        doc.add (new StringField ("string", "a"+i, Field.Store.NO));
-        doc.add (new StringField ("string", "b"+i, Field.Store.NO));
-        writer.addDocument (doc);
+        doc.add(new StringField("string", "a"+i, Field.Store.NO));
+        doc.add(new StringField("string", "b"+i, Field.Store.NO));
+        writer.addDocument(doc);
     }
     writer.forceMerge(1); // enforce one segment to have a higher unique term count in all cases
     writer.close();
     sort.setSort(
         new SortField("string", SortField.Type.STRING),
-        SortField.FIELD_DOC );
+        SortField.FIELD_DOC);
     // this should not throw AIOOBE or RuntimeEx
     IndexReader reader = DirectoryReader.open(indexStore);
     IndexSearcher searcher = new IndexSearcher(reader);
@@ -1322,11 +1355,11 @@ public class TestSort extends LuceneTestCase {
   public void testCountingCollector() throws Exception {
     Directory indexStore = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), indexStore);
-    for (int i=0; i<5; i++) {
+    for(int i=0; i<5; i++) {
       Document doc = new Document();
-      doc.add (new StringField ("string", "a"+i, Field.Store.NO));
-      doc.add (new StringField ("string", "b"+i, Field.Store.NO));
-      writer.addDocument (doc);
+      doc.add(new StringField("string", "a"+i, Field.Store.NO));
+      doc.add(new StringField("string", "b"+i, Field.Store.NO));
+      writer.addDocument(doc);
     }
     IndexReader reader = writer.getReader();
     writer.close();
@@ -1434,7 +1467,6 @@ public class TestSort extends LuceneTestCase {
       final SortField sf;
       if (random.nextBoolean()) {
         sf = new SortField("stringdv", SortField.Type.STRING, reverse);
-        sf.setUseIndexValues(true);
       } else {
         sf = new SortField("string", SortField.Type.STRING, reverse);
       }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java
index 05527f9..e32e558 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java
@@ -637,7 +637,6 @@ public abstract class ThreadedIndexingAndSearchingTestCase extends LuceneTestCas
     s.search(q, 10);
     int hitCount = s.search(q, null, 10, new Sort(new SortField("title", SortField.Type.STRING))).totalHits;
     final Sort dvSort = new Sort(new SortField("title", SortField.Type.STRING));
-    dvSort.getSort()[0].setUseIndexValues(true);
     int hitCount2 = s.search(q, null, 10, dvSort).totalHits;
     assertEquals(hitCount, hitCount2);
     return hitCount;

