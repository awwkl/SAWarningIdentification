GitDiffStart: b3671752f2e723b461ac1c251a0e995f5eb29b2d | Tue Jul 12 02:22:24 2011 +0000
diff --git a/lucene/build.xml b/lucene/build.xml
index ab98e30..17e1777 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -416,9 +416,6 @@
   <!-- ================================================================== -->
   <target name="clean-javacc">
     <delete>
-      <fileset dir="contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser" includes="*.java">
-        <containsregexp expression="Generated.*By.*JavaCC"/>
-      </fileset>
       <fileset dir="contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser" includes="*.java">
         <containsregexp expression="Generated.*By.*JavaCC"/>
       </fileset>
diff --git a/lucene/contrib/queryparser/build.xml b/lucene/contrib/queryparser/build.xml
index f1492c8..ab7e453 100644
--- a/lucene/contrib/queryparser/build.xml
+++ b/lucene/contrib/queryparser/build.xml
@@ -37,7 +37,7 @@
   <!--
     NOTE: see the README.javacc for details on how to fully regenerate the parser
   -->
-  <target name="javacc" depends="javacc-flexible,javacc-surround"/>
+  <target name="javacc" depends="javacc-flexible"/>
 
   <target name="javacc-flexible" depends="javacc-check">
     <delete>
@@ -102,12 +102,6 @@ import org.apache.lucene.queryParser.core.messages.*;"
                              byline="true"/>
   </target>
 
-  <target name="javacc-surround" depends="javacc-check" description="generate surround query parser from jj (requires javacc 4.1">
-  	<invoke-javacc target="src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.jj"
-                   outputDir="src/java/org/apache/lucene/queryParser/surround/parser"
-    />
-  </target>
-
   <target name="build-queryparser" unless="queryparser.uptodate">
     <echo>QueryParser Contrib building dependency modules/queryparser</echo>
     <subant target="default">
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
deleted file mode 100644
index ae8defe..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
+++ /dev/null
@@ -1,349 +0,0 @@
-package org.apache.lucene.queryParser.analyzing;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.StringReader;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.util.Version;
-
-/**
- * Overrides Lucene's default QueryParser so that Fuzzy-, Prefix-, Range-, and WildcardQuerys
- * are also passed through the given analyzer, but wild card characters (like <code>*</code>) 
- * don't get removed from the search terms.
- * 
- * <p><b>Warning:</b> This class should only be used with analyzers that do not use stopwords
- * or that add tokens. Also, several stemming analyzers are inappropriate: for example, GermanAnalyzer 
- * will turn <code>H&auml;user</code> into <code>hau</code>, but <code>H?user</code> will 
- * become <code>h?user</code> when using this parser and thus no match would be found (i.e.
- * using this parser will be no improvement over QueryParser in such cases). 
- *
- */
-public class AnalyzingQueryParser extends org.apache.lucene.queryparser.classic.QueryParser {
-
-  /**
-   * Constructs a query parser.
-   * @param field    the default field for query terms.
-   * @param analyzer used to find terms in the query text.
-   */
-  public AnalyzingQueryParser(Version matchVersion, String field, Analyzer analyzer) {
-    super(matchVersion, field, analyzer);
-  }
-
-  /**
-   * Called when parser
-   * parses an input term token that contains one or more wildcard
-   * characters (like <code>*</code>), but is not a prefix term token (one
-   * that has just a single * character at the end).
-   * <p>
-   * Example: will be called for <code>H?user</code> or for <code>H*user</code> 
-   * but not for <code>*user</code>.
-   * <p>
-   * Depending on analyzer and settings, a wildcard term may (most probably will)
-   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
-   * <p>
-   * Overrides super class, by passing terms through analyzer.
-   *
-   * @param  field   Name of the field query will use.
-   * @param  termStr Term token that contains one or more wild card
-   *                 characters (? or *), but is not simple prefix term
-   *
-   * @return Resulting {@link Query} built for the term
-   * @throws ParseException
-   */
-  @Override
-  protected Query getWildcardQuery(String field, String termStr) throws ParseException {
-    List<String> tlist = new ArrayList<String>();
-    List<String> wlist = new ArrayList<String>();
-    /* somewhat a hack: find/store wildcard chars
-     * in order to put them back after analyzing */
-    boolean isWithinToken = (!termStr.startsWith("?") && !termStr.startsWith("*"));
-    StringBuilder tmpBuffer = new StringBuilder();
-    char[] chars = termStr.toCharArray();
-    for (int i = 0; i < termStr.length(); i++) {
-      if (chars[i] == '?' || chars[i] == '*') {
-        if (isWithinToken) {
-          tlist.add(tmpBuffer.toString());
-          tmpBuffer.setLength(0);
-        }
-        isWithinToken = false;
-      } else {
-        if (!isWithinToken) {
-          wlist.add(tmpBuffer.toString());
-          tmpBuffer.setLength(0);
-        }
-        isWithinToken = true;
-      }
-      tmpBuffer.append(chars[i]);
-    }
-    if (isWithinToken) {
-      tlist.add(tmpBuffer.toString());
-    } else {
-      wlist.add(tmpBuffer.toString());
-    }
-
-    // get Analyzer from superclass and tokenize the term
-    TokenStream source;
-    
-    int countTokens = 0;
-    try {
-      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
-      source.reset();
-    } catch (IOException e1) {
-      throw new RuntimeException(e1);
-    }
-    CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
-    while (true) {
-      try {
-        if (!source.incrementToken()) break;
-      } catch (IOException e) {
-        break;
-      }
-      String term = termAtt.toString();
-      if (!"".equals(term)) {
-        try {
-          tlist.set(countTokens++, term);
-        } catch (IndexOutOfBoundsException ioobe) {
-          countTokens = -1;
-        }
-      }
-    }
-    try {
-      source.end();
-      source.close();
-    } catch (IOException e) {
-      // ignore
-    }
-
-    if (countTokens != tlist.size()) {
-      /* this means that the analyzer used either added or consumed 
-       * (common for a stemmer) tokens, and we can't build a WildcardQuery */
-      throw new ParseException("Cannot build WildcardQuery with analyzer "
-          + getAnalyzer().getClass() + " - tokens added or lost");
-    }
-
-    if (tlist.size() == 0) {
-      return null;
-    } else if (tlist.size() == 1) {
-      if (wlist != null && wlist.size() == 1) {
-        /* if wlist contains one wildcard, it must be at the end, because:
-         * 1) wildcards are not allowed in 1st position of a term by QueryParser
-         * 2) if wildcard was *not* in end, there would be *two* or more tokens */
-        return super.getWildcardQuery(field, tlist.get(0)
-            + wlist.get(0).toString());
-      } else {
-        /* we should never get here! if so, this method was called
-         * with a termStr containing no wildcard ... */
-        throw new IllegalArgumentException("getWildcardQuery called without wildcard");
-      }
-    } else {
-      /* the term was tokenized, let's rebuild to one token
-       * with wildcards put back in postion */
-      StringBuilder sb = new StringBuilder();
-      for (int i = 0; i < tlist.size(); i++) {
-        sb.append( tlist.get(i));
-        if (wlist != null && wlist.size() > i) {
-          sb.append(wlist.get(i));
-        }
-      }
-      return super.getWildcardQuery(field, sb.toString());
-    }
-  }
-
-  /**
-   * Called when parser parses an input term
-   * token that uses prefix notation; that is, contains a single '*' wildcard
-   * character as its last character. Since this is a special case
-   * of generic wildcard term, and such a query can be optimized easily,
-   * this usually results in a different query object.
-   * <p>
-   * Depending on analyzer and settings, a prefix term may (most probably will)
-   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
-   * <p>
-   * Overrides super class, by passing terms through analyzer.
-   *
-   * @param  field   Name of the field query will use.
-   * @param  termStr Term token to use for building term for the query
-   *                 (<b>without</b> trailing '*' character!)
-   *
-   * @return Resulting {@link Query} built for the term
-   * @throws ParseException
-   */
-  @Override
-  protected Query getPrefixQuery(String field, String termStr) throws ParseException {
-    // get Analyzer from superclass and tokenize the term
-    TokenStream source;
-    List<String> tlist = new ArrayList<String>();
-    try {
-      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
-      source.reset();
-    } catch (IOException e1) {
-      throw new RuntimeException(e1);
-    }
-    CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
-    while (true) {
-      try {
-        if (!source.incrementToken()) break;
-      } catch (IOException e) {
-        break;
-      }
-      tlist.add(termAtt.toString());
-    }
-
-    try {
-      source.end();
-      source.close();
-    } catch (IOException e) {
-      // ignore
-    }
-
-    if (tlist.size() == 1) {
-      return super.getPrefixQuery(field, tlist.get(0));
-    } else {
-      /* this means that the analyzer used either added or consumed
-       * (common for a stemmer) tokens, and we can't build a PrefixQuery */
-      throw new ParseException("Cannot build PrefixQuery with analyzer "
-          + getAnalyzer().getClass()
-          + (tlist.size() > 1 ? " - token(s) added" : " - token consumed"));
-    }
-  }
-
-  /**
-   * Called when parser parses an input term token that has the fuzzy suffix (~) appended.
-   * <p>
-   * Depending on analyzer and settings, a fuzzy term may (most probably will)
-   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
-   * <p>
-   * Overrides super class, by passing terms through analyzer.
-   *
-   * @param field Name of the field query will use.
-   * @param termStr Term token to use for building term for the query
-   *
-   * @return Resulting {@link Query} built for the term
-   * @exception ParseException
-   */
-  @Override
-  protected Query getFuzzyQuery(String field, String termStr, float minSimilarity)
-      throws ParseException {
-    // get Analyzer from superclass and tokenize the term
-    TokenStream source = null;
-    String nextToken = null;
-    boolean multipleTokens = false;
-    
-    try {
-      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
-      CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
-      source.reset();
-      if (source.incrementToken()) {
-        nextToken = termAtt.toString();
-      }
-      multipleTokens = source.incrementToken();
-    } catch (IOException e) {
-      nextToken = null;
-    }
-
-    try {
-      source.end();
-      source.close();
-    } catch (IOException e) {
-      // ignore
-    }
-
-    if (multipleTokens) {
-      throw new ParseException("Cannot build FuzzyQuery with analyzer " + getAnalyzer().getClass()
-          + " - tokens were added");
-    }
-
-    return (nextToken == null) ? null : super.getFuzzyQuery(field, nextToken, minSimilarity);
-  }
-
-  /**
-   * Overrides super class, by passing terms through analyzer.
-   * @exception ParseException
-   */
-  @Override
-  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive)
-      throws ParseException {
-    // get Analyzer from superclass and tokenize the terms
-    TokenStream source = null;
-    CharTermAttribute termAtt = null;
-    boolean multipleTokens = false;
-
-    if (part1 != null) {
-      // part1
-      try {
-        source = getAnalyzer().reusableTokenStream(field, new StringReader(part1));
-        termAtt = source.addAttribute(CharTermAttribute.class);
-        source.reset();
-        multipleTokens = false;
-
-
-        if (source.incrementToken()) {
-          part1 = termAtt.toString();
-        }
-        multipleTokens = source.incrementToken();
-      } catch (IOException e) {
-        // ignore
-      }
-      try {
-        source.end();
-        source.close();
-      } catch (IOException e) {
-        // ignore
-      }
-      if (multipleTokens) {
-        throw new ParseException("Cannot build RangeQuery with analyzer " + getAnalyzer().getClass()
-            + " - tokens were added to part1");
-      }
-    }
-
-    if (part2 != null) {
-      try {
-        // part2
-        source = getAnalyzer().reusableTokenStream(field, new StringReader(part2));
-        termAtt = source.addAttribute(CharTermAttribute.class);
-        source.reset();
-        if (source.incrementToken()) {
-          part2 = termAtt.toString();
-        }
-        multipleTokens = source.incrementToken();
-      } catch (IOException e) {
-        // ignore
-      }
-      try {
-        source.end();
-        source.close();
-      } catch (IOException e) {
-        // ignore
-      }
-      if (multipleTokens) {
-        throw new ParseException("Cannot build RangeQuery with analyzer " + getAnalyzer().getClass()
-            + " - tokens were added to part2");
-      }
-    }
-    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/package.html
deleted file mode 100644
index 2785a6b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/analyzing/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<body>
-QueryParser that passes Fuzzy-, Prefix-, Range-, and WildcardQuerys through the given analyzer.
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java
deleted file mode 100644
index 97deb6f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.java
+++ /dev/null
@@ -1,401 +0,0 @@
-package org.apache.lucene.queryParser.complexPhrase;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.queryparser.classic.QueryParser;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.util.Version;
-
-/**
- * QueryParser which permits complex phrase query syntax eg "(john jon
- * jonathan~) peters*".
- * <p>
- * Performs potentially multiple passes over Query text to parse any nested
- * logic in PhraseQueries. - First pass takes any PhraseQuery content between
- * quotes and stores for subsequent pass. All other query content is parsed as
- * normal - Second pass parses any stored PhraseQuery content, checking all
- * embedded clauses are referring to the same field and therefore can be
- * rewritten as Span queries. All PhraseQuery clauses are expressed as
- * ComplexPhraseQuery objects
- * </p>
- * <p>
- * This could arguably be done in one pass using a new QueryParser but here I am
- * working within the constraints of the existing parser as a base class. This
- * currently simply feeds all phrase content through an analyzer to select
- * phrase terms - any "special" syntax such as * ~ * etc are not given special
- * status
- * </p>
- * 
- */
-public class ComplexPhraseQueryParser extends QueryParser {
-  private ArrayList<ComplexPhraseQuery> complexPhrases = null;
-
-  private boolean isPass2ResolvingPhrases;
-
-  private ComplexPhraseQuery currentPhraseQuery = null;
-
-  public ComplexPhraseQueryParser(Version matchVersion, String f, Analyzer a) {
-    super(matchVersion, f, a);
-  }
-
-  @Override
-  protected Query getFieldQuery(String field, String queryText, int slop) {
-    ComplexPhraseQuery cpq = new ComplexPhraseQuery(field, queryText, slop);
-    complexPhrases.add(cpq); // add to list of phrases to be parsed once
-    // we
-    // are through with this pass
-    return cpq;
-  }
-
-  @Override
-  public Query parse(String query) throws ParseException {
-    if (isPass2ResolvingPhrases) {
-      MultiTermQuery.RewriteMethod oldMethod = getMultiTermRewriteMethod();
-      try {
-        // Temporarily force BooleanQuery rewrite so that Parser will
-        // generate visible
-        // collection of terms which we can convert into SpanQueries.
-        // ConstantScoreRewrite mode produces an
-        // opaque ConstantScoreQuery object which cannot be interrogated for
-        // terms in the same way a BooleanQuery can.
-        // QueryParser is not guaranteed threadsafe anyway so this temporary
-        // state change should not
-        // present an issue
-        setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-        return super.parse(query);
-      } finally {
-        setMultiTermRewriteMethod(oldMethod);
-      }
-    }
-
-    // First pass - parse the top-level query recording any PhraseQuerys
-    // which will need to be resolved
-    complexPhrases = new ArrayList<ComplexPhraseQuery>();
-    Query q = super.parse(query);
-
-    // Perform second pass, using this QueryParser to parse any nested
-    // PhraseQueries with different
-    // set of syntax restrictions (i.e. all fields must be same)
-    isPass2ResolvingPhrases = true;
-    try {
-      for (Iterator<ComplexPhraseQuery> iterator = complexPhrases.iterator(); iterator.hasNext();) {
-        currentPhraseQuery = iterator.next();
-        // in each phrase, now parse the contents between quotes as a
-        // separate parse operation
-        currentPhraseQuery.parsePhraseElements(this);
-      }
-    } finally {
-      isPass2ResolvingPhrases = false;
-    }
-    return q;
-  }
-
-  // There is No "getTermQuery throws ParseException" method to override so
-  // unfortunately need
-  // to throw a runtime exception here if a term for another field is embedded
-  // in phrase query
-  @Override
-  protected Query newTermQuery(Term term) {
-    if (isPass2ResolvingPhrases) {
-      try {
-        checkPhraseClauseIsForSameField(term.field());
-      } catch (ParseException pe) {
-        throw new RuntimeException("Error parsing complex phrase", pe);
-      }
-    }
-    return super.newTermQuery(term);
-  }
-
-  // Helper method used to report on any clauses that appear in query syntax
-  private void checkPhraseClauseIsForSameField(String field)
-      throws ParseException {
-    if (!field.equals(currentPhraseQuery.field)) {
-      throw new ParseException("Cannot have clause for field \"" + field
-          + "\" nested in phrase " + " for field \"" + currentPhraseQuery.field
-          + "\"");
-    }
-  }
-
-  @Override
-  protected Query getWildcardQuery(String field, String termStr)
-      throws ParseException {
-    if (isPass2ResolvingPhrases) {
-      checkPhraseClauseIsForSameField(field);
-    }
-    return super.getWildcardQuery(field, termStr);
-  }
-
-  @Override
-  protected Query getRangeQuery(String field, String part1, String part2,
-      boolean startInclusive, boolean endInclusive) throws ParseException {
-    if (isPass2ResolvingPhrases) {
-      checkPhraseClauseIsForSameField(field);
-    }
-    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
-  }
-
-  @Override
-  protected Query newRangeQuery(String field, String part1, String part2,
-      boolean startInclusive, boolean endInclusive) {
-    if (isPass2ResolvingPhrases) {
-      // Must use old-style RangeQuery in order to produce a BooleanQuery
-      // that can be turned into SpanOr clause
-      TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, part1, part2, startInclusive, endInclusive);
-      rangeQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-      return rangeQuery;
-    }
-    return super.newRangeQuery(field, part1, part2, startInclusive, endInclusive);
-  }
-
-  @Override
-  protected Query getFuzzyQuery(String field, String termStr,
-      float minSimilarity) throws ParseException {
-    if (isPass2ResolvingPhrases) {
-      checkPhraseClauseIsForSameField(field);
-    }
-    return super.getFuzzyQuery(field, termStr, minSimilarity);
-  }
-
-  /*
-   * Used to handle the query content in between quotes and produced Span-based
-   * interpretations of the clauses.
-   */
-  static class ComplexPhraseQuery extends Query {
-
-    String field;
-
-    String phrasedQueryStringContents;
-
-    int slopFactor;
-
-    private Query contents;
-
-    public ComplexPhraseQuery(String field, String phrasedQueryStringContents,
-        int slopFactor) {
-      super();
-      this.field = field;
-      this.phrasedQueryStringContents = phrasedQueryStringContents;
-      this.slopFactor = slopFactor;
-    }
-
-    // Called by ComplexPhraseQueryParser for each phrase after the main
-    // parse
-    // thread is through
-    protected void parsePhraseElements(QueryParser qp) throws ParseException {
-      // TODO ensure that field-sensitivity is preserved ie the query
-      // string below is parsed as
-      // field+":("+phrasedQueryStringContents+")"
-      // but this will need code in rewrite to unwrap the first layer of
-      // boolean query
-      contents = qp.parse(phrasedQueryStringContents);
-    }
-
-    @Override
-    public Query rewrite(IndexReader reader) throws IOException {
-      // ArrayList spanClauses = new ArrayList();
-      if (contents instanceof TermQuery) {
-        return contents;
-      }
-      // Build a sequence of Span clauses arranged in a SpanNear - child
-      // clauses can be complex
-      // Booleans e.g. nots and ors etc
-      int numNegatives = 0;
-      if (!(contents instanceof BooleanQuery)) {
-        throw new IllegalArgumentException("Unknown query type \""
-            + contents.getClass().getName()
-            + "\" found in phrase query string \"" + phrasedQueryStringContents
-            + "\"");
-      }
-      BooleanQuery bq = (BooleanQuery) contents;
-      BooleanClause[] bclauses = bq.getClauses();
-      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];
-      // For all clauses e.g. one* two~
-      for (int i = 0; i < bclauses.length; i++) {
-        // HashSet bclauseterms=new HashSet();
-        Query qc = bclauses[i].getQuery();
-        // Rewrite this clause e.g one* becomes (one OR onerous)
-        qc = qc.rewrite(reader);
-        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
-          numNegatives++;
-        }
-
-        if (qc instanceof BooleanQuery) {
-          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();
-          addComplexPhraseClause(sc, (BooleanQuery) qc);
-          if (sc.size() > 0) {
-            allSpanClauses[i] = sc.get(0);
-          } else {
-            // Insert fake term e.g. phrase query was for "Fred Smithe*" and
-            // there were no "Smithe*" terms - need to
-            // prevent match on just "Fred".
-            allSpanClauses[i] = new SpanTermQuery(new Term(field,
-                "Dummy clause because no terms found - must match nothing"));
-          }
-        } else {
-          if (qc instanceof TermQuery) {
-            TermQuery tq = (TermQuery) qc;
-            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());
-          } else {
-            throw new IllegalArgumentException("Unknown query type \""
-                + qc.getClass().getName()
-                + "\" found in phrase query string \""
-                + phrasedQueryStringContents + "\"");
-          }
-
-        }
-      }
-      if (numNegatives == 0) {
-        // The simple case - no negative elements in phrase
-        return new SpanNearQuery(allSpanClauses, slopFactor, true);
-      }
-      // Complex case - we have mixed positives and negatives in the
-      // sequence.
-      // Need to return a SpanNotQuery
-      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();
-      for (int j = 0; j < allSpanClauses.length; j++) {
-        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
-          positiveClauses.add(allSpanClauses[j]);
-        }
-      }
-
-      SpanQuery[] includeClauses = positiveClauses
-          .toArray(new SpanQuery[positiveClauses.size()]);
-
-      SpanQuery include = null;
-      if (includeClauses.length == 1) {
-        include = includeClauses[0]; // only one positive clause
-      } else {
-        // need to increase slop factor based on gaps introduced by
-        // negatives
-        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,
-            true);
-      }
-      // Use sequence of positive and negative values as the exclude.
-      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,
-          true);
-      SpanNotQuery snot = new SpanNotQuery(include, exclude);
-      return snot;
-    }
-
-    private void addComplexPhraseClause(List<SpanQuery> spanClauses, BooleanQuery qc) {
-      ArrayList<SpanQuery> ors = new ArrayList<SpanQuery>();
-      ArrayList<SpanQuery> nots = new ArrayList<SpanQuery>();
-      BooleanClause[] bclauses = qc.getClauses();
-
-      // For all clauses e.g. one* two~
-      for (int i = 0; i < bclauses.length; i++) {
-        Query childQuery = bclauses[i].getQuery();
-
-        // select the list to which we will add these options
-        ArrayList<SpanQuery> chosenList = ors;
-        if (bclauses[i].getOccur() == BooleanClause.Occur.MUST_NOT) {
-          chosenList = nots;
-        }
-
-        if (childQuery instanceof TermQuery) {
-          TermQuery tq = (TermQuery) childQuery;
-          SpanTermQuery stq = new SpanTermQuery(tq.getTerm());
-          stq.setBoost(tq.getBoost());
-          chosenList.add(stq);
-        } else if (childQuery instanceof BooleanQuery) {
-          BooleanQuery cbq = (BooleanQuery) childQuery;
-          addComplexPhraseClause(chosenList, cbq);
-        } else {
-          // TODO alternatively could call extract terms here?
-          throw new IllegalArgumentException("Unknown query type:"
-              + childQuery.getClass().getName());
-        }
-      }
-      if (ors.size() == 0) {
-        return;
-      }
-      SpanOrQuery soq = new SpanOrQuery(ors
-          .toArray(new SpanQuery[ors.size()]));
-      if (nots.size() == 0) {
-        spanClauses.add(soq);
-      } else {
-        SpanOrQuery snqs = new SpanOrQuery(nots
-            .toArray(new SpanQuery[nots.size()]));
-        SpanNotQuery snq = new SpanNotQuery(soq, snqs);
-        spanClauses.add(snq);
-      }
-    }
-
-    @Override
-    public String toString(String field) {
-      return "\"" + phrasedQueryStringContents + "\"";
-    }
-
-    @Override
-    public int hashCode() {
-      final int prime = 31;
-      int result = 1;
-      result = prime * result + ((field == null) ? 0 : field.hashCode());
-      result = prime
-          * result
-          + ((phrasedQueryStringContents == null) ? 0
-              : phrasedQueryStringContents.hashCode());
-      result = prime * result + slopFactor;
-      return result;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj)
-        return true;
-      if (obj == null)
-        return false;
-      if (getClass() != obj.getClass())
-        return false;
-      ComplexPhraseQuery other = (ComplexPhraseQuery) obj;
-      if (field == null) {
-        if (other.field != null)
-          return false;
-      } else if (!field.equals(other.field))
-        return false;
-      if (phrasedQueryStringContents == null) {
-        if (other.phrasedQueryStringContents != null)
-          return false;
-      } else if (!phrasedQueryStringContents
-          .equals(other.phrasedQueryStringContents))
-        return false;
-      if (slopFactor != other.slopFactor)
-        return false;
-      return true;
-    }
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/package.html
deleted file mode 100644
index ade19fc..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/complexPhrase/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<body>
-QueryParser which permits complex phrase query syntax eg "(john jon jonathan~) peters*"
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtendableQueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtendableQueryParser.java
deleted file mode 100644
index c85712b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtendableQueryParser.java
+++ /dev/null
@@ -1,142 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.queryParser.ext.Extensions.Pair;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.queryparser.classic.QueryParser;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.util.Version;
-
-/**
- * The {@link ExtendableQueryParser} enables arbitrary query parser extension
- * based on a customizable field naming scheme. The lucene query syntax allows
- * implicit and explicit field definitions as query prefix followed by a colon
- * (':') character. The {@link ExtendableQueryParser} allows to encode extension
- * keys into the field symbol associated with a registered instance of
- * {@link ParserExtension}. A customizable separation character separates the
- * extension key from the actual field symbol. The {@link ExtendableQueryParser}
- * splits (@see {@link Extensions#splitExtensionField(String, String)}) the
- * extension key from the field symbol and tries to resolve the associated
- * {@link ParserExtension}. If the parser can't resolve the key or the field
- * token does not contain a separation character, {@link ExtendableQueryParser}
- * yields the same behavior as its super class {@link QueryParser}. Otherwise,
- * if the key is associated with a {@link ParserExtension} instance, the parser
- * builds an instance of {@link ExtensionQuery} to be processed by
- * {@link ParserExtension#parse(ExtensionQuery)}.If a extension field does not
- * contain a field part the default field for the query will be used.
- * <p>
- * To guarantee that an extension field is processed with its associated
- * extension, the extension query part must escape any special characters like
- * '*' or '['. If the extension query contains any whitespace characters, the
- * extension query part must be enclosed in quotes.
- * Example ('_' used as separation character):
- * <pre>
- *   title_customExt:"Apache Lucene\?" OR content_customExt:prefix\*
- * </pre>
- * 
- * Search on the default field:
- * <pre>
- *   _customExt:"Apache Lucene\?" OR _customExt:prefix\*
- * </pre>
- * </p>
- * <p>
- * The {@link ExtendableQueryParser} itself does not implement the logic how
- * field and extension key are separated or ordered. All logic regarding the
- * extension key and field symbol parsing is located in {@link Extensions}.
- * Customized extension schemes should be implemented by sub-classing
- * {@link Extensions}.
- * </p>
- * <p>
- * For details about the default encoding scheme see {@link Extensions}.
- * </p>
- * 
- * @see Extensions
- * @see ParserExtension
- * @see ExtensionQuery
- */
-public class ExtendableQueryParser extends QueryParser {
-
-  private final String defaultField;
-  private final Extensions extensions;
-
-  /**
-   * Default empty extensions instance
-   */
-  private static final Extensions DEFAULT_EXTENSION = new Extensions();
-
-  /**
-   * Creates a new {@link ExtendableQueryParser} instance
-   * 
-   * @param matchVersion
-   *          the lucene version to use.
-   * @param f
-   *          the default query field
-   * @param a
-   *          the analyzer used to find terms in a query string
-   */
-  public ExtendableQueryParser(final Version matchVersion, final String f,
-      final Analyzer a) {
-    this(matchVersion, f, a, DEFAULT_EXTENSION);
-
-  }
-
-  /**
-   * Creates a new {@link ExtendableQueryParser} instance
-   * 
-   * @param matchVersion
-   *          the lucene version to use.
-   * @param f
-   *          the default query field
-   * @param a
-   *          the analyzer used to find terms in a query string
-   * @param ext
-   *          the query parser extensions
-   */
-  public ExtendableQueryParser(final Version matchVersion, final String f,
-      final Analyzer a, final Extensions ext) {
-    super(matchVersion, f, a);
-    this.defaultField = f;
-    this.extensions = ext;
-  }
-
-  /**
-   * Returns the extension field delimiter character.
-   * 
-   * @return the extension field delimiter character.
-   */
-  public char getExtensionFieldDelimiter() {
-    return extensions.getExtensionFieldDelimiter();
-  }
-
-  @Override
-  protected Query getFieldQuery(final String field, final String queryText, boolean quoted)
-      throws ParseException {
-    final Pair<String,String> splitExtensionField = this.extensions
-        .splitExtensionField(defaultField, field);
-    final ParserExtension extension = this.extensions
-        .getExtension(splitExtensionField.cud);
-    if (extension != null) {
-      return extension.parse(new ExtensionQuery(this, splitExtensionField.cur,
-          queryText));
-    }
-    return super.getFieldQuery(field, queryText, quoted);
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtensionQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtensionQuery.java
deleted file mode 100644
index 423cad3..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ExtensionQuery.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-import org.apache.lucene.queryparser.classic.QueryParser;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * {@link ExtensionQuery} holds all query components extracted from the original
- * query string like the query field and the extension query string.
- * 
- * @see Extensions
- * @see ExtendableQueryParser
- * @see ParserExtension
- */
-public class ExtensionQuery {
-
-  private final String field;
-  private final String rawQueryString;
-  private final QueryParser topLevelParser;
-
-  /**
-   * Creates a new {@link ExtensionQuery}
-   * 
-   * @param field
-   *          the query field
-   * @param rawQueryString
-   *          the raw extension query string
-   */
-  public ExtensionQuery(QueryParser topLevelParser, String field, String rawQueryString) {
-    this.field = field;
-    this.rawQueryString = rawQueryString;
-    this.topLevelParser = topLevelParser;
-  }
-
-  /**
-   * Returns the query field
-   * 
-   * @return the query field
-   */
-  public String getField() {
-    return field;
-  }
-
-  /**
-   * Returns the raw extension query string
-   * 
-   * @return the raw extension query string
-   */
-  public String getRawQueryString() {
-    return rawQueryString;
-  }
-  
-  /**
-   * Returns the top level parser which created this {@link ExtensionQuery} 
-   * @return the top level parser which created this {@link ExtensionQuery}
-   */
-  public QueryParser getTopLevelParser() {
-    return topLevelParser;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/Extensions.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/Extensions.java
deleted file mode 100644
index 9e3ee39..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/Extensions.java
+++ /dev/null
@@ -1,218 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import org.apache.lucene.queryparser.classic.QueryParser;
-
-import java.util.HashMap;
-import java.util.Map;
-
-
-/**
- * The {@link Extensions} class represents an extension mapping to associate
- * {@link ParserExtension} instances with extension keys. An extension key is a
- * string encoded into a Lucene standard query parser field symbol recognized by
- * {@link ExtendableQueryParser}. The query parser passes each extension field
- * token to {@link #splitExtensionField(String, String)} to separate the
- * extension key from the field identifier.
- * <p>
- * In addition to the key to extension mapping this class also defines the field
- * name overloading scheme. {@link ExtendableQueryParser} uses the given
- * extension to split the actual field name and extension key by calling
- * {@link #splitExtensionField(String, String)}. To change the order or the key
- * / field name encoding scheme users can subclass {@link Extensions} to
- * implement their own.
- * 
- * @see ExtendableQueryParser
- * @see ParserExtension
- */
-public class Extensions {
-  private final Map<String,ParserExtension> extensions = new HashMap<String,ParserExtension>();
-  private final char extensionFieldDelimiter;
-  /**
-   * The default extension field delimiter character. This constant is set to
-   * ':'
-   */
-  public static final char DEFAULT_EXTENSION_FIELD_DELIMITER = ':';
-
-  /**
-   * Creates a new {@link Extensions} instance with the
-   * {@link #DEFAULT_EXTENSION_FIELD_DELIMITER} as a delimiter character.
-   */
-  public Extensions() {
-    this(DEFAULT_EXTENSION_FIELD_DELIMITER);
-  }
-
-  /**
-   * Creates a new {@link Extensions} instance
-   * 
-   * @param extensionFieldDelimiter
-   *          the extensions field delimiter character
-   */
-  public Extensions(char extensionFieldDelimiter) {
-    this.extensionFieldDelimiter = extensionFieldDelimiter;
-  }
-
-  /**
-   * Adds a new {@link ParserExtension} instance associated with the given key.
-   * 
-   * @param key
-   *          the parser extension key
-   * @param extension
-   *          the parser extension
-   */
-  public void add(String key, ParserExtension extension) {
-    this.extensions.put(key, extension);
-  }
-
-  /**
-   * Returns the {@link ParserExtension} instance for the given key or
-   * <code>null</code> if no extension can be found for the key.
-   * 
-   * @param key
-   *          the extension key
-   * @return the {@link ParserExtension} instance for the given key or
-   *         <code>null</code> if no extension can be found for the key.
-   */
-  public final ParserExtension getExtension(String key) {
-    return this.extensions.get(key);
-  }
-
-  /**
-   * Returns the extension field delimiter
-   * 
-   * @return the extension field delimiter
-   */
-  public char getExtensionFieldDelimiter() {
-    return extensionFieldDelimiter;
-  }
-
-  /**
-   * Splits a extension field and returns the field / extension part as a
-   * {@link Pair}. This method tries to split on the first occurrence of the
-   * extension field delimiter, if the delimiter is not present in the string
-   * the result will contain a <code>null</code> value for the extension key and
-   * the given field string as the field value. If the given extension field
-   * string contains no field identifier the result pair will carry the given
-   * default field as the field value.
-   * 
-   * @param defaultField
-   *          the default query field
-   * @param field
-   *          the extension field string
-   * @return a {@link Pair} with the field name as the {@link Pair#cur} and the
-   *         extension key as the {@link Pair#cud}
-   */
-  public Pair<String,String> splitExtensionField(String defaultField,
-      String field) {
-    int indexOf = field.indexOf(this.extensionFieldDelimiter);
-    if (indexOf < 0)
-      return new Pair<String,String>(field, null);
-    final String indexField = indexOf == 0 ? defaultField : field.substring(0,
-        indexOf);
-    final String extensionKey = field.substring(indexOf + 1);
-    return new Pair<String,String>(indexField, extensionKey);
-
-  }
-
-  /**
-   * Escapes an extension field. The default implementation is equivalent to
-   * {@link QueryParser#escape(String)}.
-   * 
-   * @param extfield
-   *          the extension field identifier
-   * @return the extension field identifier with all special chars escaped with
-   *         a backslash character.
-   */
-  public String escapeExtensionField(String extfield) {
-    return QueryParser.escape(extfield);
-  }
-
-  /**
-   * Builds an extension field string from a given extension key and the default
-   * query field. The default field and the key are delimited with the extension
-   * field delimiter character. This method makes no assumption about the order
-   * of the extension key and the field. By default the extension key is
-   * appended to the end of the returned string while the field is added to the
-   * beginning. Special Query characters are escaped in the result.
-   * <p>
-   * Note: {@link Extensions} subclasses must maintain the contract between
-   * {@link #buildExtensionField(String)} and
-   * {@link #splitExtensionField(String, String)} where the latter inverts the
-   * former.
-   * </p>
-   */
-  public String buildExtensionField(String extensionKey) {
-    return buildExtensionField(extensionKey, "");
-  }
-
-  /**
-   * Builds an extension field string from a given extension key and the
-   * extensions field. The field and the key are delimited with the extension
-   * field delimiter character. This method makes no assumption about the order
-   * of the extension key and the field. By default the extension key is
-   * appended to the end of the returned string while the field is added to the
-   * beginning. Special Query characters are escaped in the result.
-   * <p>
-   * Note: {@link Extensions} subclasses must maintain the contract between
-   * {@link #buildExtensionField(String, String)} and
-   * {@link #splitExtensionField(String, String)} where the latter inverts the
-   * former.
-   * </p>
-   * 
-   * @param extensionKey
-   *          the extension key
-   * @param field
-   *          the field to apply the extension on.
-   * @return escaped extension field identifier
-   * @see #buildExtensionField(String) to use the default query field
-   */
-  public String buildExtensionField(String extensionKey, String field) {
-    StringBuilder builder = new StringBuilder(field);
-    builder.append(this.extensionFieldDelimiter);
-    builder.append(extensionKey);
-    return escapeExtensionField(builder.toString());
-  }
-
-  /**
-   * This class represents a generic pair.
-   * 
-   * @param <Cur>
-   *          the pairs first element
-   * @param <Cud>
-   *          the pairs last element of the pair.
-   */
-  public static class Pair<Cur,Cud> {
-
-    public final Cur cur;
-    public final Cud cud;
-
-    /**
-     * Creates a new Pair
-     * 
-     * @param cur
-     *          the pairs first element
-     * @param cud
-     *          the pairs last element
-     */
-    public Pair(Cur cur, Cud cud) {
-      this.cur = cur;
-      this.cud = cud;
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ParserExtension.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ParserExtension.java
deleted file mode 100644
index 77f9ada..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/ParserExtension.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.search.Query;
-
-/**
- * This class represents an extension base class to the Lucene standard
- * {@link org.apache.lucene.queryparser.classic.QueryParser}. The
- * {@link org.apache.lucene.queryparser.classic.QueryParser} is generated by the JavaCC
- * parser generator. Changing or adding functionality or syntax in the standard
- * query parser requires changes to the JavaCC source file. To enable extending
- * the standard query parser without changing the JavaCC sources and re-generate
- * the parser the {@link ParserExtension} can be customized and plugged into an
- * instance of {@link ExtendableQueryParser}, a direct subclass of
- * {@link org.apache.lucene.queryparser.classic.QueryParser}.
- * 
- * @see Extensions
- * @see ExtendableQueryParser
- */
-public abstract class ParserExtension {
-
-  /**
-   * Processes the given {@link ExtensionQuery} and returns a corresponding
-   * {@link Query} instance. Subclasses must either return a {@link Query}
-   * instance or raise a {@link ParseException}. This method must not return
-   * <code>null</code>.
-   * 
-   * @param query
-   *          the extension query
-   * @return a new query instance
-   * @throws ParseException
-   *           if the query can not be parsed.
-   */
-  public abstract Query parse(final ExtensionQuery query) throws ParseException;
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/package.html
deleted file mode 100644
index 13549a8..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/ext/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html><head></head>
-<body>
-Extendable QueryParser provides a simple and flexible extension mechanism by overloading query field names.
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/package.html
deleted file mode 100644
index 3ea34b5..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/package.html
+++ /dev/null
@@ -1,22 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<body>
-A QueryParser that supports the Span family of queries as well as pre and infix notation.
-</body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/CharStream.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/CharStream.java
deleted file mode 100644
index 7c2d5f2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/CharStream.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 4.1 */
-/* JavaCCOptions:STATIC=false */
-package org.apache.lucene.queryParser.surround.parser;
-
-/**
- * This interface describes a character stream that maintains line and
- * column number positions of the characters.  It also has the capability
- * to backup the stream to some extent.  An implementation of this
- * interface is used in the TokenManager implementation generated by
- * JavaCCParser.
- *
- * All the methods except backup can be implemented in any fashion. backup
- * needs to be implemented correctly for the correct operation of the lexer.
- * Rest of the methods are all used to get information like line number,
- * column number and the String that constitutes a token and are not used
- * by the lexer. Hence their implementation won't affect the generated lexer's
- * operation.
- */
-
-public interface CharStream {
-
-  /**
-   * Returns the next character from the selected input.  The method
-   * of selecting the input is the responsibility of the class
-   * implementing this interface.  Can throw any java.io.IOException.
-   */
-  char readChar() throws java.io.IOException;
-
-  /**
-   * Returns the column position of the character last read.
-   * @deprecated (gen)
-   * @see #getEndColumn
-   */
-  int getColumn();
-
-  /**
-   * Returns the line number of the character last read.
-   * @deprecated (gen)
-   * @see #getEndLine
-   */
-  int getLine();
-
-  /**
-   * Returns the column number of the last character for current token (being
-   * matched after the last call to BeginTOken).
-   */
-  int getEndColumn();
-
-  /**
-   * Returns the line number of the last character for current token (being
-   * matched after the last call to BeginTOken).
-   */
-  int getEndLine();
-
-  /**
-   * Returns the column number of the first character for current token (being
-   * matched after the last call to BeginTOken).
-   */
-  int getBeginColumn();
-
-  /**
-   * Returns the line number of the first character for current token (being
-   * matched after the last call to BeginTOken).
-   */
-  int getBeginLine();
-
-  /**
-   * Backs up the input stream by amount steps. Lexer calls this method if it
-   * had already read some characters, but could not use them to match a
-   * (longer) token. So, they will be used again as the prefix of the next
-   * token and it is the implemetation's responsibility to do this right.
-   */
-  void backup(int amount);
-
-  /**
-   * Returns the next character that marks the beginning of the next token.
-   * All characters must remain in the buffer between two successive calls
-   * to this method to implement backup correctly.
-   */
-  char BeginToken() throws java.io.IOException;
-
-  /**
-   * Returns a string made up of characters from the marked token beginning
-   * to the current buffer position. Implementations have the choice of returning
-   * anything that they want to. For example, for efficiency, one might decide
-   * to just return null, which is a valid implementation.
-   */
-  String GetImage();
-
-  /**
-   * Returns an array of characters that make up the suffix of length 'len' for
-   * the currently matched token. This is used to build up the matched string
-   * for use in actions in the case of MORE. A simple and inefficient
-   * implementation of this is as follows :
-   *
-   *   {
-   *      String t = GetImage();
-   *      return t.substring(t.length() - len, t.length()).toCharArray();
-   *   }
-   */
-  char[] GetSuffix(int len);
-
-  /**
-   * The lexer calls this function to indicate that it is done with the stream
-   * and hence implementations can free any resources held by this class.
-   * Again, the body of this function can be just empty and it will not
-   * affect the lexer's operation.
-   */
-  void Done();
-
-}
-/* JavaCC - OriginalChecksum=872eafa2c180de2e08862f87f675b2dd (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/FastCharStream.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/FastCharStream.java
deleted file mode 100644
index 093c4eb..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/FastCharStream.java
+++ /dev/null
@@ -1,121 +0,0 @@
-// FastCharStream.java
-package org.apache.lucene.queryParser.surround.parser;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.*;
-
-/** An efficient implementation of JavaCC's CharStream interface.  <p>Note that
- * this does not do line-number counting, but instead keeps track of the
- * character position of the token in the input, as required by Lucene's {@link
- * org.apache.lucene.analysis.Token} API. */
-public final class FastCharStream implements CharStream {
-  char[] buffer = null;
-
-  int bufferLength = 0;				  // end of valid chars
-  int bufferPosition = 0;			  // next char to read
-
-  int tokenStart = 0;				  // offset in buffer
-  int bufferStart = 0;				  // position in file of buffer
-
-  Reader input;					  // source of chars
-
-  /** Constructs from a Reader. */
-  public FastCharStream(Reader r) {
-    input = r;
-  }
-
-  public final char readChar() throws IOException {
-    if (bufferPosition >= bufferLength)
-      refill();
-    return buffer[bufferPosition++];
-  }
-
-  private final void refill() throws IOException {
-    int newPosition = bufferLength - tokenStart;
-
-    if (tokenStart == 0) {			  // token won't fit in buffer
-      if (buffer == null) {			  // first time: alloc buffer
-	buffer = new char[2048];
-      } else if (bufferLength == buffer.length) { // grow buffer
-	char[] newBuffer = new char[buffer.length*2];
-	System.arraycopy(buffer, 0, newBuffer, 0, bufferLength);
-	buffer = newBuffer;
-      }
-    } else {					  // shift token to front
-      System.arraycopy(buffer, tokenStart, buffer, 0, newPosition);
-    }
-
-    bufferLength = newPosition;			  // update state
-    bufferPosition = newPosition;
-    bufferStart += tokenStart;
-    tokenStart = 0;
-
-    int charsRead =				  // fill space in buffer
-      input.read(buffer, newPosition, buffer.length-newPosition);
-    if (charsRead == -1)
-      throw new IOException("read past eof");
-    else
-      bufferLength += charsRead;
-  }
-
-  public final char BeginToken() throws IOException {
-    tokenStart = bufferPosition;
-    return readChar();
-  }
-
-  public final void backup(int amount) {
-    bufferPosition -= amount;
-  }
-
-  public final String GetImage() {
-    return new String(buffer, tokenStart, bufferPosition - tokenStart);
-  }
-
-  public final char[] GetSuffix(int len) {
-    char[] value = new char[len];
-    System.arraycopy(buffer, bufferPosition - len, value, 0, len);
-    return value;
-  }
-
-  public final void Done() {
-    try {
-      input.close();
-    } catch (IOException e) {
-      System.err.println("Caught: " + e + "; ignoring.");
-    }
-  }
-
-  public final int getColumn() {
-    return bufferStart + bufferPosition;
-  }
-  public final int getLine() {
-    return 1;
-  }
-  public final int getEndColumn() {
-    return bufferStart + bufferPosition;
-  }
-  public final int getEndLine() {
-    return 1;
-  }
-  public final int getBeginColumn() {
-    return bufferStart + tokenStart;
-  }
-  public final int getBeginLine() {
-    return 1;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/ParseException.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/ParseException.java
deleted file mode 100644
index 99a3261..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/ParseException.java
+++ /dev/null
@@ -1,198 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
-/* JavaCCOptions:KEEP_LINE_COL=null */
-package org.apache.lucene.queryParser.surround.parser;
-
-/**
- * This exception is thrown when parse errors are encountered.
- * You can explicitly create objects of this exception type by
- * calling the method generateParseException in the generated
- * parser.
- *
- * You can modify this class to customize your error reporting
- * mechanisms so long as you retain the public fields.
- */
-public class ParseException extends Exception {
-
-  /**
-   * This constructor is used by the method "generateParseException"
-   * in the generated parser.  Calling this constructor generates
-   * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
-   */
-  public ParseException(Token currentTokenVal,
-                        int[][] expectedTokenSequencesVal,
-                        String[] tokenImageVal
-                       )
-  {
-    super("");
-    specialConstructor = true;
-    currentToken = currentTokenVal;
-    expectedTokenSequences = expectedTokenSequencesVal;
-    tokenImage = tokenImageVal;
-  }
-
-  /**
-   * The following constructors are for use by you for whatever
-   * purpose you can think of.  Constructing the exception in this
-   * manner makes the exception behave in the normal way - i.e., as
-   * documented in the class "Throwable".  The fields "errorToken",
-   * "expectedTokenSequences", and "tokenImage" do not contain
-   * relevant information.  The JavaCC generated code does not use
-   * these constructors.
-   */
-
-  public ParseException() {
-    super();
-    specialConstructor = false;
-  }
-
-  /** Constructor with message. */
-  public ParseException(String message) {
-    super(message);
-    specialConstructor = false;
-  }
-
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
-
-  /**
-   * This is the last token that has been consumed successfully.  If
-   * this object has been created due to a parse error, the token
-   * followng this token will (therefore) be the first error token.
-   */
-  public Token currentToken;
-
-  /**
-   * Each entry in this array is an array of integers.  Each array
-   * of integers represents a sequence of tokens (by their ordinal
-   * values) that is expected at this point of the parse.
-   */
-  public int[][] expectedTokenSequences;
-
-  /**
-   * This is a reference to the "tokenImage" array of the generated
-   * parser within which the parse error occurred.  This array is
-   * defined in the generated ...Constants interface.
-   */
-  public String[] tokenImage;
-
-  /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
-   * error message and returns it.  If this object has been created
-   * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
-   * gets displayed.
-   */
-  public String getMessage() {
-    if (!specialConstructor) {
-      return super.getMessage();
-    }
-    StringBuffer expected = new StringBuffer();
-    int maxSize = 0;
-    for (int i = 0; i < expectedTokenSequences.length; i++) {
-      if (maxSize < expectedTokenSequences[i].length) {
-        maxSize = expectedTokenSequences[i].length;
-      }
-      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
-        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
-      }
-      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
-        expected.append("...");
-      }
-      expected.append(eol).append("    ");
-    }
-    String retval = "Encountered \"";
-    Token tok = currentToken.next;
-    for (int i = 0; i < maxSize; i++) {
-      if (i != 0) retval += " ";
-      if (tok.kind == 0) {
-        retval += tokenImage[0];
-        break;
-      }
-      retval += " " + tokenImage[tok.kind];
-      retval += " \"";
-      retval += add_escapes(tok.image);
-      retval += " \"";
-      tok = tok.next;
-    }
-    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
-    retval += "." + eol;
-    if (expectedTokenSequences.length == 1) {
-      retval += "Was expecting:" + eol + "    ";
-    } else {
-      retval += "Was expecting one of:" + eol + "    ";
-    }
-    retval += expected.toString();
-    return retval;
-  }
-
-  /**
-   * The end of line string for this machine.
-   */
-  protected String eol = System.getProperty("line.separator", "\n");
-
-  /**
-   * Used to convert raw characters to their escaped version
-   * when these raw version cannot be used as part of an ASCII
-   * string literal.
-   */
-  protected String add_escapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-}
-/* JavaCC - OriginalChecksum=2a154532f17c98e29d1671b8413edb60 (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.java
deleted file mode 100644
index be6f9b8..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.java
+++ /dev/null
@@ -1,735 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
-package org.apache.lucene.queryParser.surround.parser;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.io.StringReader;
-
-
-import org.apache.lucene.analysis.TokenStream;
-
-import org.apache.lucene.queryParser.surround.query.SrndQuery;
-import org.apache.lucene.queryParser.surround.query.FieldsQuery;
-import org.apache.lucene.queryParser.surround.query.OrQuery;
-import org.apache.lucene.queryParser.surround.query.AndQuery;
-import org.apache.lucene.queryParser.surround.query.NotQuery;
-import org.apache.lucene.queryParser.surround.query.DistanceQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTermQuery;
-import org.apache.lucene.queryParser.surround.query.SrndPrefixQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTruncQuery;
-
-/**
- * This class is generated by JavaCC.  The only method that clients should need
- * to call is <a href="#parse">parse()</a>.
- */
-
-public class QueryParser implements QueryParserConstants {
-  final int minimumPrefixLength = 3;
-  final int minimumCharsInTrunc = 3;
-  final String truncationErrorMessage = "Too unrestrictive truncation: ";
-  final String boostErrorMessage = "Cannot handle boost value: ";
-
-  /* CHECKME: These should be the same as for the tokenizer. How? */
-  final char truncator = '*';
-  final char anyChar = '?';
-  final char quote = '\"';
-  final char fieldOperator = ':';
-  final char comma = ','; /* prefix list separator */
-  final char carat = '^'; /* weight operator */
-
-  static public SrndQuery parse(String query) throws ParseException {
-    QueryParser parser = new QueryParser();
-    return parser.parse2(query);
-  }
-
-  public QueryParser() {
-    this(new FastCharStream(new StringReader("")));
-  }
-
-  public SrndQuery parse2(String query) throws ParseException {
-    ReInit(new FastCharStream(new StringReader(query)));
-    try {
-      return TopSrndQuery();
-    } catch (TokenMgrError tme) {
-      throw new ParseException(tme.getMessage());
-    }
-  }
-
-  protected SrndQuery getFieldsQuery(
-      SrndQuery q, ArrayList<String> fieldNames) {
-    /* FIXME: check acceptable subquery: at least one subquery should not be
-     * a fields query.
-     */
-    return new FieldsQuery(q, fieldNames, fieldOperator);
-  }
-
-  protected SrndQuery getOrQuery(List<SrndQuery> queries, boolean infix, Token orToken) {
-    return new OrQuery(queries, infix, orToken.image);
-  }
-
-  protected SrndQuery getAndQuery(List<SrndQuery> queries, boolean infix, Token andToken) {
-    return new AndQuery( queries, infix, andToken.image);
-  }
-
-  protected SrndQuery getNotQuery(List<SrndQuery> queries, Token notToken) {
-    return new NotQuery( queries, notToken.image);
-  }
-
-  protected static int getOpDistance(String distanceOp) {
-    /* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */
-    return distanceOp.length() == 1
-      ? 1
-      : Integer.parseInt( distanceOp.substring( 0, distanceOp.length() - 1));
-  }
-
-  protected static void checkDistanceSubQueries(DistanceQuery distq, String opName)
-  throws ParseException {
-    String m = distq.distanceSubQueryNotAllowed();
-    if (m != null) {
-      throw new ParseException("Operator " + opName + ": " + m);
-    }
-  }
-
-  protected SrndQuery getDistanceQuery(
-        List<SrndQuery> queries,
-        boolean infix,
-        Token dToken,
-        boolean ordered) throws ParseException {
-    DistanceQuery dq = new DistanceQuery(queries,
-                                        infix,
-                                        getOpDistance(dToken.image),
-                                        dToken.image,
-                                        ordered);
-    checkDistanceSubQueries(dq, dToken.image);
-    return dq;
-  }
-
-  protected SrndQuery getTermQuery(
-        String term, boolean quoted) {
-    return new SrndTermQuery(term, quoted);
-  }
-
-  protected boolean allowedSuffix(String suffixed) {
-    return (suffixed.length() - 1) >= minimumPrefixLength;
-  }
-
-  protected SrndQuery getPrefixQuery(
-      String prefix, boolean quoted) {
-    return new SrndPrefixQuery(prefix, quoted, truncator);
-  }
-
-  protected boolean allowedTruncation(String truncated) {
-    /* At least 3 normal characters needed. */
-    int nrNormalChars = 0;
-    for (int i = 0; i < truncated.length(); i++) {
-      char c = truncated.charAt(i);
-      if ((c != truncator) && (c != anyChar)) {
-        nrNormalChars++;
-      }
-    }
-    return nrNormalChars >= minimumCharsInTrunc;
-  }
-
-  protected SrndQuery getTruncQuery(String truncated) {
-    return new SrndTruncQuery(truncated, truncator, anyChar);
-  }
-
-  final public SrndQuery TopSrndQuery() throws ParseException {
-  SrndQuery q;
-    q = FieldsQuery();
-    jj_consume_token(0);
-   {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery FieldsQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<String> fieldNames;
-    fieldNames = OptionalFields();
-    q = OrQuery();
-   {if (true) return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public ArrayList<String> OptionalFields() throws ParseException {
-  Token fieldName;
-  ArrayList<String> fieldNames = null;
-    label_1:
-    while (true) {
-      if (jj_2_1(2)) {
-        ;
-      } else {
-        break label_1;
-      }
-      // to the colon
-          fieldName = jj_consume_token(TERM);
-      jj_consume_token(COLON);
-      if (fieldNames == null) {
-        fieldNames = new ArrayList<String>();
-      }
-      fieldNames.add(fieldName.image);
-    }
-   {if (true) return fieldNames;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery OrQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-    q = AndQuery();
-    label_2:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case OR:
-        ;
-        break;
-      default:
-        jj_la1[0] = jj_gen;
-        break label_2;
-      }
-      oprt = jj_consume_token(OR);
-                  /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-      q = AndQuery();
-      queries.add(q);
-    }
-   {if (true) return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery AndQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-    q = NotQuery();
-    label_3:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case AND:
-        ;
-        break;
-      default:
-        jj_la1[1] = jj_gen;
-        break label_3;
-      }
-      oprt = jj_consume_token(AND);
-                   /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-      q = NotQuery();
-      queries.add(q);
-    }
-   {if (true) return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery NotQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-    q = NQuery();
-    label_4:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case NOT:
-        ;
-        break;
-      default:
-        jj_la1[2] = jj_gen;
-        break label_4;
-      }
-      oprt = jj_consume_token(NOT);
-                    /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-      q = NQuery();
-      queries.add(q);
-    }
-   {if (true) return (queries == null) ? q : getNotQuery(queries, oprt);}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery NQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries;
-  Token dt;
-    q = WQuery();
-    label_5:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case N:
-        ;
-        break;
-      default:
-        jj_la1[3] = jj_gen;
-        break label_5;
-      }
-      dt = jj_consume_token(N);
-      queries = new ArrayList<SrndQuery>();
-      queries.add(q); /* left associative */
-
-      q = WQuery();
-      queries.add(q);
-      q = getDistanceQuery(queries, true /* infix */, dt, false /* not ordered */);
-    }
-   {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery WQuery() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries;
-  Token wt;
-    q = PrimaryQuery();
-    label_6:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case W:
-        ;
-        break;
-      default:
-        jj_la1[4] = jj_gen;
-        break label_6;
-      }
-      wt = jj_consume_token(W);
-      queries = new ArrayList<SrndQuery>();
-      queries.add(q); /* left associative */
-
-      q = PrimaryQuery();
-      queries.add(q);
-      q = getDistanceQuery(queries, true /* infix */, wt, true /* ordered */);
-    }
-   {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery PrimaryQuery() throws ParseException {
-                             /* bracketed weighted query or weighted term */
-  SrndQuery q;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case LPAREN:
-      jj_consume_token(LPAREN);
-      q = FieldsQuery();
-      jj_consume_token(RPAREN);
-      break;
-    case OR:
-    case AND:
-    case W:
-    case N:
-      q = PrefixOperatorQuery();
-      break;
-    case TRUNCQUOTED:
-    case QUOTED:
-    case SUFFIXTERM:
-    case TRUNCTERM:
-    case TERM:
-      q = SimpleTerm();
-      break;
-    default:
-      jj_la1[5] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    OptionalWeights(q);
-   {if (true) return q;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery PrefixOperatorQuery() throws ParseException {
-  Token oprt;
-  List<SrndQuery> queries;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case OR:
-      oprt = jj_consume_token(OR);
-      /* prefix OR */
-          queries = FieldsQueryList();
-     {if (true) return getOrQuery(queries, false /* not infix */, oprt);}
-      break;
-    case AND:
-      oprt = jj_consume_token(AND);
-      /* prefix AND */
-          queries = FieldsQueryList();
-     {if (true) return getAndQuery(queries, false /* not infix */, oprt);}
-      break;
-    case N:
-      oprt = jj_consume_token(N);
-      /* prefix N */
-          queries = FieldsQueryList();
-     {if (true) return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);}
-      break;
-    case W:
-      oprt = jj_consume_token(W);
-      /* prefix W */
-          queries = FieldsQueryList();
-     {if (true) return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);}
-      break;
-    default:
-      jj_la1[6] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    throw new Error("Missing return statement in function");
-  }
-
-  final public List<SrndQuery> FieldsQueryList() throws ParseException {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = new ArrayList<SrndQuery>();
-    jj_consume_token(LPAREN);
-    q = FieldsQuery();
-                     queries.add(q);
-    label_7:
-    while (true) {
-      jj_consume_token(COMMA);
-      q = FieldsQuery();
-                              queries.add(q);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case COMMA:
-        ;
-        break;
-      default:
-        jj_la1[7] = jj_gen;
-        break label_7;
-      }
-    }
-    jj_consume_token(RPAREN);
-   {if (true) return queries;}
-    throw new Error("Missing return statement in function");
-  }
-
-  final public SrndQuery SimpleTerm() throws ParseException {
-  Token term;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case TERM:
-      term = jj_consume_token(TERM);
-     {if (true) return getTermQuery(term.image, false /* not quoted */);}
-      break;
-    case QUOTED:
-      term = jj_consume_token(QUOTED);
-     {if (true) return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);}
-      break;
-    case SUFFIXTERM:
-      term = jj_consume_token(SUFFIXTERM);
-                        /* ending in * */
-      if (! allowedSuffix(term.image)) {
-        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
-      }
-      {if (true) return getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);}
-      break;
-    case TRUNCTERM:
-      term = jj_consume_token(TRUNCTERM);
-                       /* with at least one * or ? */
-      if (! allowedTruncation(term.image)) {
-        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
-      }
-      {if (true) return getTruncQuery(term.image);}
-      break;
-    case TRUNCQUOTED:
-      term = jj_consume_token(TRUNCQUOTED);
-                         /* eg. "9b-b,m"* */
-      if ((term.image.length() - 3) < minimumPrefixLength) {
-        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
-      }
-      {if (true) return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);}
-      break;
-    default:
-      jj_la1[8] = jj_gen;
-      jj_consume_token(-1);
-      throw new ParseException();
-    }
-    throw new Error("Missing return statement in function");
-  }
-
-  final public void OptionalWeights(SrndQuery q) throws ParseException {
-  Token weight=null;
-    label_8:
-    while (true) {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case CARAT:
-        ;
-        break;
-      default:
-        jj_la1[9] = jj_gen;
-        break label_8;
-      }
-      jj_consume_token(CARAT);
-      weight = jj_consume_token(NUMBER);
-      float f;
-      try {
-        f = Float.valueOf(weight.image).floatValue();
-      } catch (Exception floatExc) {
-        {if (true) throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");}
-      }
-      if (f <= 0.0) {
-        {if (true) throw new ParseException(boostErrorMessage + weight.image);}
-      }
-      q.setWeight(f * q.getWeight()); /* left associative, fwiw */
-
-    }
-  }
-
-  private boolean jj_2_1(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_1(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(0, xla); }
-  }
-
-  private boolean jj_3_1() {
-    if (jj_scan_token(TERM)) return true;
-    if (jj_scan_token(COLON)) return true;
-    return false;
-  }
-
-  /** Generated Token Manager. */
-  public QueryParserTokenManager token_source;
-  /** Current token. */
-  public Token token;
-  /** Next token. */
-  public Token jj_nt;
-  private int jj_ntk;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[10];
-  static private int[] jj_la1_0;
-  static {
-      jj_la1_init_0();
-   }
-   private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x100,0x200,0x400,0x1000,0x800,0x7c3b00,0x1b00,0x8000,0x7c0000,0x20000,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[1];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
-
-  /** Constructor with user supplied CharStream. */
-  public QueryParser(CharStream stream) {
-    token_source = new QueryParserTokenManager(stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Reinitialise. */
-  public void ReInit(CharStream stream) {
-    token_source.ReInit(stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Constructor with generated Token Manager. */
-  public QueryParser(QueryParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  /** Reinitialise. */
-  public void ReInit(QueryParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  private Token jj_consume_token(int kind) throws ParseException {
-    Token oldToken;
-    if ((oldToken = token).next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    if (token.kind == kind) {
-      jj_gen++;
-      if (++jj_gc > 100) {
-        jj_gc = 0;
-        for (int i = 0; i < jj_2_rtns.length; i++) {
-          JJCalls c = jj_2_rtns[i];
-          while (c != null) {
-            if (c.gen < jj_gen) c.first = null;
-            c = c.next;
-          }
-        }
-      }
-      return token;
-    }
-    token = oldToken;
-    jj_kind = kind;
-    throw generateParseException();
-  }
-
-  static private final class LookaheadSuccess extends java.lang.Error { }
-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  private boolean jj_scan_token(int kind) {
-    if (jj_scanpos == jj_lastpos) {
-      jj_la--;
-      if (jj_scanpos.next == null) {
-        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
-      } else {
-        jj_lastpos = jj_scanpos = jj_scanpos.next;
-      }
-    } else {
-      jj_scanpos = jj_scanpos.next;
-    }
-    if (jj_rescan) {
-      int i = 0; Token tok = token;
-      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
-      if (tok != null) jj_add_error_token(kind, i);
-    }
-    if (jj_scanpos.kind != kind) return true;
-    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
-    return false;
-  }
-
-
-/** Get the next Token. */
-  final public Token getNextToken() {
-    if (token.next != null) token = token.next;
-    else token = token.next = token_source.getNextToken();
-    jj_ntk = -1;
-    jj_gen++;
-    return token;
-  }
-
-/** Get the specific Token. */
-  final public Token getToken(int index) {
-    Token t = token;
-    for (int i = 0; i < index; i++) {
-      if (t.next != null) t = t.next;
-      else t = t.next = token_source.getNextToken();
-    }
-    return t;
-  }
-
-  private int jj_ntk() {
-    if ((jj_nt=token.next) == null)
-      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
-    else
-      return (jj_ntk = jj_nt.kind);
-  }
-
-  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
-  private int[] jj_expentry;
-  private int jj_kind = -1;
-  private int[] jj_lasttokens = new int[100];
-  private int jj_endpos;
-
-  private void jj_add_error_token(int kind, int pos) {
-    if (pos >= 100) return;
-    if (pos == jj_endpos + 1) {
-      jj_lasttokens[jj_endpos++] = kind;
-    } else if (jj_endpos != 0) {
-      jj_expentry = new int[jj_endpos];
-      for (int i = 0; i < jj_endpos; i++) {
-        jj_expentry[i] = jj_lasttokens[i];
-      }
-      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
-        int[] oldentry = (int[])(it.next());
-        if (oldentry.length == jj_expentry.length) {
-          for (int i = 0; i < jj_expentry.length; i++) {
-            if (oldentry[i] != jj_expentry[i]) {
-              continue jj_entries_loop;
-            }
-          }
-          jj_expentries.add(jj_expentry);
-          break jj_entries_loop;
-        }
-      }
-      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
-    }
-  }
-
-  /** Generate ParseException. */
-  public ParseException generateParseException() {
-    jj_expentries.clear();
-    boolean[] la1tokens = new boolean[24];
-    if (jj_kind >= 0) {
-      la1tokens[jj_kind] = true;
-      jj_kind = -1;
-    }
-    for (int i = 0; i < 10; i++) {
-      if (jj_la1[i] == jj_gen) {
-        for (int j = 0; j < 32; j++) {
-          if ((jj_la1_0[i] & (1<<j)) != 0) {
-            la1tokens[j] = true;
-          }
-        }
-      }
-    }
-    for (int i = 0; i < 24; i++) {
-      if (la1tokens[i]) {
-        jj_expentry = new int[1];
-        jj_expentry[0] = i;
-        jj_expentries.add(jj_expentry);
-      }
-    }
-    jj_endpos = 0;
-    jj_rescan_token();
-    jj_add_error_token(0, 0);
-    int[][] exptokseq = new int[jj_expentries.size()][];
-    for (int i = 0; i < jj_expentries.size(); i++) {
-      exptokseq[i] = jj_expentries.get(i);
-    }
-    return new ParseException(token, exptokseq, tokenImage);
-  }
-
-  /** Enable tracing. */
-  final public void enable_tracing() {
-  }
-
-  /** Disable tracing. */
-  final public void disable_tracing() {
-  }
-
-  private void jj_rescan_token() {
-    jj_rescan = true;
-    for (int i = 0; i < 1; i++) {
-    try {
-      JJCalls p = jj_2_rtns[i];
-      do {
-        if (p.gen > jj_gen) {
-          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
-          switch (i) {
-            case 0: jj_3_1(); break;
-          }
-        }
-        p = p.next;
-      } while (p != null);
-      } catch(LookaheadSuccess ls) { }
-    }
-    jj_rescan = false;
-  }
-
-  private void jj_save(int index, int xla) {
-    JJCalls p = jj_2_rtns[index];
-    while (p.gen > jj_gen) {
-      if (p.next == null) { p = p.next = new JJCalls(); break; }
-      p = p.next;
-    }
-    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
-  }
-
-  static final class JJCalls {
-    int gen;
-    Token first;
-    int arg;
-    JJCalls next;
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.jj b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.jj
deleted file mode 100644
index a29964a..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParser.jj
+++ /dev/null
@@ -1,454 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Surround query language parser */
-
-/* Query language operators: OR, AND, NOT, W, N, (, ), ^, *, ?, " and comma */
-
-
-options {
-  STATIC=false;
-  JAVA_UNICODE_ESCAPE=true;
-  USER_CHAR_STREAM=true;
-}
-
-PARSER_BEGIN(QueryParser)
-
-package org.apache.lucene.queryParser.surround.parser;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.io.StringReader;
-
-
-import org.apache.lucene.analysis.TokenStream;
-
-import org.apache.lucene.queryParser.surround.query.SrndQuery;
-import org.apache.lucene.queryParser.surround.query.FieldsQuery;
-import org.apache.lucene.queryParser.surround.query.OrQuery;
-import org.apache.lucene.queryParser.surround.query.AndQuery;
-import org.apache.lucene.queryParser.surround.query.NotQuery;
-import org.apache.lucene.queryParser.surround.query.DistanceQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTermQuery;
-import org.apache.lucene.queryParser.surround.query.SrndPrefixQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTruncQuery;
-
-/**
- * This class is generated by JavaCC.  The only method that clients should need
- * to call is <a href="#parse">parse()</a>.
- */
-
-public class QueryParser {
-  final int minimumPrefixLength = 3;
-  final int minimumCharsInTrunc = 3;
-  final String truncationErrorMessage = "Too unrestrictive truncation: ";
-  final String boostErrorMessage = "Cannot handle boost value: ";
- 
-  /* CHECKME: These should be the same as for the tokenizer. How? */
-  final char truncator = '*';
-  final char anyChar = '?';
-  final char quote = '\"';
-  final char fieldOperator = ':';
-  final char comma = ','; /* prefix list separator */
-  final char carat = '^'; /* weight operator */
- 
-  static public SrndQuery parse(String query) throws ParseException {
-    QueryParser parser = new QueryParser();
-    return parser.parse2(query);
-  }
-
-  public QueryParser() {
-    this(new FastCharStream(new StringReader("")));
-  }
-
-  public SrndQuery parse2(String query) throws ParseException {
-    ReInit(new FastCharStream(new StringReader(query)));
-    try {
-      return TopSrndQuery();
-    } catch (TokenMgrError tme) {
-      throw new ParseException(tme.getMessage());
-    }
-  }
-    
-  protected SrndQuery getFieldsQuery(
-      SrndQuery q, ArrayList<String> fieldNames) {
-    /* FIXME: check acceptable subquery: at least one subquery should not be
-     * a fields query.
-     */
-    return new FieldsQuery(q, fieldNames, fieldOperator);
-  }
-  
-  protected SrndQuery getOrQuery(List<SrndQuery> queries, boolean infix, Token orToken) {
-    return new OrQuery(queries, infix, orToken.image);
-  }
-
-  protected SrndQuery getAndQuery(List<SrndQuery> queries, boolean infix, Token andToken) {
-    return new AndQuery( queries, infix, andToken.image);
-  }
-  
-  protected SrndQuery getNotQuery(List<SrndQuery> queries, Token notToken) {
-    return new NotQuery( queries, notToken.image);
-  }
-  
-  protected static int getOpDistance(String distanceOp) {
-    /* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */
-    return distanceOp.length() == 1 
-      ? 1
-      : Integer.parseInt( distanceOp.substring( 0, distanceOp.length() - 1));
-  }
-  
-  protected static void checkDistanceSubQueries(DistanceQuery distq, String opName)
-  throws ParseException {
-    String m = distq.distanceSubQueryNotAllowed();
-    if (m != null) {
-      throw new ParseException("Operator " + opName + ": " + m);
-    }
-  }
-  
-  protected SrndQuery getDistanceQuery(
-        List<SrndQuery> queries,
-        boolean infix,
-        Token dToken,
-        boolean ordered) throws ParseException {
-    DistanceQuery dq = new DistanceQuery(queries,
-                                        infix,
-                                        getOpDistance(dToken.image),
-                                        dToken.image,
-                                        ordered);
-    checkDistanceSubQueries(dq, dToken.image);
-    return dq;
-  }
-
-  protected SrndQuery getTermQuery(
-        String term, boolean quoted) {
-    return new SrndTermQuery(term, quoted);
-  }
-
-  protected boolean allowedSuffix(String suffixed) {
-    return (suffixed.length() - 1) >= minimumPrefixLength;
-  }
-
-  protected SrndQuery getPrefixQuery(
-      String prefix, boolean quoted) {
-    return new SrndPrefixQuery(prefix, quoted, truncator);
-  }
-  
-  protected boolean allowedTruncation(String truncated) {
-    /* At least 3 normal characters needed. */
-    int nrNormalChars = 0;
-    for (int i = 0; i < truncated.length(); i++) {
-      char c = truncated.charAt(i);
-      if ((c != truncator) && (c != anyChar)) {
-        nrNormalChars++;
-      }
-    }
-    return nrNormalChars >= minimumCharsInTrunc;
-  }
-
-  protected SrndQuery getTruncQuery(String truncated) {
-    return new SrndTruncQuery(truncated, truncator, anyChar);
-  }
-}
-
-PARSER_END(QueryParser)
-
-/* ***************** */
-/* Token Definitions */
-/* ***************** */
-
-<*> TOKEN : {
-  <#_NUM_CHAR:   ["0"-"9"] >
-| <#_TERM_CHAR: /* everything except whitespace and operators */
-    ( ~[ " ", "\t", "\n", "\r",
-          ",", "?", "*", "(", ")", ":", "^", "\""]
-     ) >
-| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" ) >
-| <#_STAR:       "*" > /* term truncation */
-| <#_ONE_CHAR:   "?" > /* precisely one character in a term */
-/* 2..99 prefix for distance operators */
-| <#_DISTOP_NUM: ((["2"-"9"](["0"-"9"])?) | ("1" ["0"-"9"]))> 
-}
-
-<DEFAULT> SKIP : {
-  < <_WHITESPACE>>
-}
-
-/* Operator tokens (in increasing order of precedence): */
-<DEFAULT> TOKEN :
-{
-  <OR:        "OR" | "or"> 
-| <AND:       "AND" | "and">
-| <NOT:       "NOT" | "not">
-| <W:         (<_DISTOP_NUM>)? ("W"|"w")>
-| <N:         (<_DISTOP_NUM>)? ("N"|"n")>
-/* These are excluded in _TERM_CHAR: */
-| <LPAREN:    "(">
-| <RPAREN:    ")">
-| <COMMA:     ",">
-| <COLON:     ":">
-| <CARAT:     "^"> : Boost
-/* Literal non empty term between single quotes,
- * escape quoted quote or backslash by backslash.
- * Evt. truncated.
- */
-| <TRUNCQUOTED: "\"" (~["\""])+ "\"" <_STAR>>
-| <QUOTED:      "\"" ( (~["\"", "\\"]) | ("\\" ["\\", "\""]))+ "\"">
-| <SUFFIXTERM: (<_TERM_CHAR>)+ <_STAR>>
-| <TRUNCTERM:  (<_TERM_CHAR>)+
-               (<_STAR> | <_ONE_CHAR> )+ /* at least one * or ? */
-               (<_TERM_CHAR> | <_STAR>  | <_ONE_CHAR> )*
-               >
-| <TERM:       (<_TERM_CHAR>)+>
-}
-
-<Boost> TOKEN : {
-<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )?> : DEFAULT
-}
-
-
-SrndQuery TopSrndQuery() : {
-  SrndQuery q;
-}{
-  q = FieldsQuery()
-  <EOF>
-  {return q;}
-}
-
-
-SrndQuery FieldsQuery() : {
-  SrndQuery q;
-  ArrayList<String> fieldNames;
-}{
-  fieldNames = OptionalFields()
-  q = OrQuery()
-  {return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}
-}
-
-
-ArrayList<String> OptionalFields() : {
-  Token fieldName;
-  ArrayList<String> fieldNames = null;
-}{
-  ( LOOKAHEAD(2) // to the colon
-    fieldName = <TERM>
-    <COLON> {
-      if (fieldNames == null) {
-        fieldNames = new ArrayList<String>();
-      }
-      fieldNames.add(fieldName.image);
-    }
-  )*
-  {return fieldNames;}
-}
-
-
-SrndQuery OrQuery() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-}{
-  q = AndQuery()
-  ( oprt = <OR> { /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-    }    
-    q = AndQuery() {
-      queries.add(q);
-    }
-  )*
-  {return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}
-}
-
-
-SrndQuery AndQuery() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-}{
-  q = NotQuery()
-  ( oprt = <AND> { /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-    }
-    q = NotQuery() {
-      queries.add(q);
-    }
-  )* 
-  {return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}
-}
-
-
-SrndQuery NotQuery() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = null;
-  Token oprt = null;
-}{
-  q = NQuery()
-  ( oprt = <NOT>  { /* keep only last used operator */
-      if (queries == null) {
-        queries = new ArrayList<SrndQuery>();
-        queries.add(q);
-      }
-    }
-    q = NQuery() {
-      queries.add(q);
-    }
-  )*
-  {return (queries == null) ? q : getNotQuery(queries, oprt);}
-}
-
-
-SrndQuery NQuery() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries;
-  Token dt;
-}{
-  q = WQuery()
-  ( dt = <N> {
-      queries = new ArrayList<SrndQuery>();
-      queries.add(q); /* left associative */
-    }
-    q = WQuery() {
-      queries.add(q);
-      q = getDistanceQuery(queries, true /* infix */, dt, false /* not ordered */); 
-    }
-  )* 
-  {return q;}
-}
-
-
-SrndQuery WQuery() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries;
-  Token wt;
-}{
-  q = PrimaryQuery()
-  ( wt = <W> {
-      queries = new ArrayList<SrndQuery>();
-      queries.add(q); /* left associative */
-    }
-    q = PrimaryQuery() {
-      queries.add(q); 
-      q = getDistanceQuery(queries, true /* infix */, wt, true /* ordered */); 
-    }
-  )* 
-  {return q;}
-}
-
-
-SrndQuery PrimaryQuery() : { /* bracketed weighted query or weighted term */
-  SrndQuery q;
-}{
-  ( <LPAREN> q = FieldsQuery() <RPAREN>
-  | q = PrefixOperatorQuery()
-  | q = SimpleTerm()
-  )
-  OptionalWeights(q)
-  {return q;}
-}
-
-
-SrndQuery PrefixOperatorQuery() : {
-  Token oprt;
-  List<SrndQuery> queries;
-}{
-  ( oprt = <OR> /* prefix OR */
-    queries = FieldsQueryList()
-    {return getOrQuery(queries, false /* not infix */, oprt);}
-      
-  | oprt = <AND> /* prefix AND */
-    queries = FieldsQueryList()
-    {return getAndQuery(queries, false /* not infix */, oprt);}
-  
-  | oprt = <N> /* prefix N */
-    queries = FieldsQueryList()
-    {return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);}
-    
-  | oprt = <W> /* prefix W */
-    queries = FieldsQueryList()
-    {return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);}
-  )
-}
-
-
-List<SrndQuery> FieldsQueryList() : {
-  SrndQuery q;
-  ArrayList<SrndQuery> queries = new ArrayList<SrndQuery>();
-}{
-  <LPAREN>
-  q = FieldsQuery() {queries.add(q);}
-  (<COMMA> q = FieldsQuery() {queries.add(q);})+
-  <RPAREN>
-  {return queries;}
-}
-
-
-SrndQuery SimpleTerm() : {
-  Token term;
-}{
-  ( term=<TERM>
-    {return getTermQuery(term.image, false /* not quoted */);}
-      
-  | term=<QUOTED>
-    {return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);}
-      
-  | term=<SUFFIXTERM> { /* ending in * */
-      if (! allowedSuffix(term.image)) {
-        throw new ParseException(truncationErrorMessage + term.image);
-      }
-      return getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);
-    }
-      
-  | term=<TRUNCTERM> { /* with at least one * or ? */
-      if (! allowedTruncation(term.image)) {
-        throw new ParseException(truncationErrorMessage + term.image);
-      }
-      return getTruncQuery(term.image);
-    }
-      
-  | term=<TRUNCQUOTED> { /* eg. "9b-b,m"* */
-      if ((term.image.length() - 3) < minimumPrefixLength) {
-        throw new ParseException(truncationErrorMessage + term.image);
-      }
-      return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);
-    }
-  )
-}
-
-
-void OptionalWeights(SrndQuery q) : {
-  Token weight=null;
-}{
-  ( <CARAT> weight=<NUMBER> {
-      float f;
-      try {
-        f = Float.valueOf(weight.image).floatValue();
-      } catch (Exception floatExc) {
-        throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");
-      }
-      if (f <= 0.0) {
-        throw new ParseException(boostErrorMessage + weight.image);
-      }      
-      q.setWeight(f * q.getWeight()); /* left associative, fwiw */
-    }
-  )*
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserConstants.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserConstants.java
deleted file mode 100644
index fe45496..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserConstants.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. QueryParserConstants.java */
-package org.apache.lucene.queryParser.surround.parser;
-
-
-/**
- * Token literal values and constants.
- * Generated by org.javacc.parser.OtherFilesGen#start()
- */
-public interface QueryParserConstants {
-
-  /** End of File. */
-  int EOF = 0;
-  /** RegularExpression Id. */
-  int _NUM_CHAR = 1;
-  /** RegularExpression Id. */
-  int _TERM_CHAR = 2;
-  /** RegularExpression Id. */
-  int _WHITESPACE = 3;
-  /** RegularExpression Id. */
-  int _STAR = 4;
-  /** RegularExpression Id. */
-  int _ONE_CHAR = 5;
-  /** RegularExpression Id. */
-  int _DISTOP_NUM = 6;
-  /** RegularExpression Id. */
-  int OR = 8;
-  /** RegularExpression Id. */
-  int AND = 9;
-  /** RegularExpression Id. */
-  int NOT = 10;
-  /** RegularExpression Id. */
-  int W = 11;
-  /** RegularExpression Id. */
-  int N = 12;
-  /** RegularExpression Id. */
-  int LPAREN = 13;
-  /** RegularExpression Id. */
-  int RPAREN = 14;
-  /** RegularExpression Id. */
-  int COMMA = 15;
-  /** RegularExpression Id. */
-  int COLON = 16;
-  /** RegularExpression Id. */
-  int CARAT = 17;
-  /** RegularExpression Id. */
-  int TRUNCQUOTED = 18;
-  /** RegularExpression Id. */
-  int QUOTED = 19;
-  /** RegularExpression Id. */
-  int SUFFIXTERM = 20;
-  /** RegularExpression Id. */
-  int TRUNCTERM = 21;
-  /** RegularExpression Id. */
-  int TERM = 22;
-  /** RegularExpression Id. */
-  int NUMBER = 23;
-
-  /** Lexical state. */
-  int Boost = 0;
-  /** Lexical state. */
-  int DEFAULT = 1;
-
-  /** Literal token values. */
-  String[] tokenImage = {
-    "<EOF>",
-    "<_NUM_CHAR>",
-    "<_TERM_CHAR>",
-    "<_WHITESPACE>",
-    "\"*\"",
-    "\"?\"",
-    "<_DISTOP_NUM>",
-    "<token of kind 7>",
-    "<OR>",
-    "<AND>",
-    "<NOT>",
-    "<W>",
-    "<N>",
-    "\"(\"",
-    "\")\"",
-    "\",\"",
-    "\":\"",
-    "\"^\"",
-    "<TRUNCQUOTED>",
-    "<QUOTED>",
-    "<SUFFIXTERM>",
-    "<TRUNCTERM>",
-    "<TERM>",
-    "<NUMBER>",
-  };
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserTokenManager.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserTokenManager.java
deleted file mode 100644
index fb5a93f..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/QueryParserTokenManager.java
+++ /dev/null
@@ -1,714 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
-package org.apache.lucene.queryParser.surround.parser;
-import java.util.ArrayList;
-import java.util.List;
-import java.io.StringReader;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.queryParser.surround.query.SrndQuery;
-import org.apache.lucene.queryParser.surround.query.FieldsQuery;
-import org.apache.lucene.queryParser.surround.query.OrQuery;
-import org.apache.lucene.queryParser.surround.query.AndQuery;
-import org.apache.lucene.queryParser.surround.query.NotQuery;
-import org.apache.lucene.queryParser.surround.query.DistanceQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTermQuery;
-import org.apache.lucene.queryParser.surround.query.SrndPrefixQuery;
-import org.apache.lucene.queryParser.surround.query.SrndTruncQuery;
-
-/** Token Manager. */
-public class QueryParserTokenManager implements QueryParserConstants
-{
-
-  /** Debug output. */
-  public  java.io.PrintStream debugStream = System.out;
-  /** Set debug output. */
-  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_1(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_1(int pos, long active0)
-{
-   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
-}
-private int jjStopAtPos(int pos, int kind)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   return pos + 1;
-}
-private int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 40:
-         return jjStopAtPos(0, 13);
-      case 41:
-         return jjStopAtPos(0, 14);
-      case 44:
-         return jjStopAtPos(0, 15);
-      case 58:
-         return jjStopAtPos(0, 16);
-      case 94:
-         return jjStopAtPos(0, 17);
-      default :
-         return jjMoveNfa_1(0, 0);
-   }
-}
-static final long[] jjbitVec0 = {
-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-static final long[] jjbitVec2 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
-};
-private int jjMoveNfa_1(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 38;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x7bffe8faffffd9ffL & l) != 0L)
-                  {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddStates(0, 4);
-                  }
-                  else if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 7)
-                        kind = 7;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddStates(5, 7);
-                  if ((0x3fc000000000000L & l) != 0L)
-                     jjCheckNAddStates(8, 11);
-                  else if (curChar == 49)
-                     jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 19:
-                  if ((0x3fc000000000000L & l) != 0L)
-                     jjCheckNAddStates(8, 11);
-                  break;
-               case 20:
-                  if ((0x3ff000000000000L & l) != 0L)
-                     jjCheckNAdd(17);
-                  break;
-               case 21:
-                  if ((0x3ff000000000000L & l) != 0L)
-                     jjCheckNAdd(18);
-                  break;
-               case 22:
-                  if (curChar == 49)
-                     jjCheckNAddTwoStates(20, 21);
-                  break;
-               case 23:
-                  if (curChar == 34)
-                     jjCheckNAddStates(5, 7);
-                  break;
-               case 24:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddTwoStates(24, 25);
-                  break;
-               case 25:
-                  if (curChar == 34)
-                     jjstateSet[jjnewStateCnt++] = 26;
-                  break;
-               case 26:
-                  if (curChar == 42 && kind > 18)
-                     kind = 18;
-                  break;
-               case 27:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(12, 14);
-                  break;
-               case 29:
-                  if (curChar == 34)
-                     jjCheckNAddStates(12, 14);
-                  break;
-               case 30:
-                  if (curChar == 34 && kind > 19)
-                     kind = 19;
-                  break;
-               case 31:
-                  if ((0x7bffe8faffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddStates(0, 4);
-                  break;
-               case 32:
-                  if ((0x7bffe8faffffd9ffL & l) != 0L)
-                     jjCheckNAddTwoStates(32, 33);
-                  break;
-               case 33:
-                  if (curChar == 42 && kind > 20)
-                     kind = 20;
-                  break;
-               case 34:
-                  if ((0x7bffe8faffffd9ffL & l) != 0L)
-                     jjCheckNAddTwoStates(34, 35);
-                  break;
-               case 35:
-                  if ((0x8000040000000000L & l) == 0L)
-                     break;
-                  if (kind > 21)
-                     kind = 21;
-                  jjCheckNAddTwoStates(35, 36);
-                  break;
-               case 36:
-                  if ((0xfbffecfaffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 21)
-                     kind = 21;
-                  jjCheckNAdd(36);
-                  break;
-               case 37:
-                  if ((0x7bffe8faffffd9ffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAdd(37);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xffffffffbfffffffL & l) != 0L)
-                  {
-                     if (kind > 22)
-                        kind = 22;
-                     jjCheckNAddStates(0, 4);
-                  }
-                  if ((0x400000004000L & l) != 0L)
-                  {
-                     if (kind > 12)
-                        kind = 12;
-                  }
-                  else if ((0x80000000800000L & l) != 0L)
-                  {
-                     if (kind > 11)
-                        kind = 11;
-                  }
-                  else if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 9;
-                  else if (curChar == 65)
-                     jjstateSet[jjnewStateCnt++] = 6;
-                  else if (curChar == 111)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  else if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 1;
-                  if (curChar == 110)
-                     jjstateSet[jjnewStateCnt++] = 15;
-                  else if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 12;
-                  break;
-               case 1:
-                  if (curChar == 82 && kind > 8)
-                     kind = 8;
-                  break;
-               case 2:
-                  if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 1;
-                  break;
-               case 3:
-                  if (curChar == 114 && kind > 8)
-                     kind = 8;
-                  break;
-               case 4:
-                  if (curChar == 111)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  break;
-               case 5:
-                  if (curChar == 68 && kind > 9)
-                     kind = 9;
-                  break;
-               case 6:
-                  if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 5;
-                  break;
-               case 7:
-                  if (curChar == 65)
-                     jjstateSet[jjnewStateCnt++] = 6;
-                  break;
-               case 8:
-                  if (curChar == 100 && kind > 9)
-                     kind = 9;
-                  break;
-               case 9:
-                  if (curChar == 110)
-                     jjstateSet[jjnewStateCnt++] = 8;
-                  break;
-               case 10:
-                  if (curChar == 97)
-                     jjstateSet[jjnewStateCnt++] = 9;
-                  break;
-               case 11:
-                  if (curChar == 84 && kind > 10)
-                     kind = 10;
-                  break;
-               case 12:
-                  if (curChar == 79)
-                     jjstateSet[jjnewStateCnt++] = 11;
-                  break;
-               case 13:
-                  if (curChar == 78)
-                     jjstateSet[jjnewStateCnt++] = 12;
-                  break;
-               case 14:
-                  if (curChar == 116 && kind > 10)
-                     kind = 10;
-                  break;
-               case 15:
-                  if (curChar == 111)
-                     jjstateSet[jjnewStateCnt++] = 14;
-                  break;
-               case 16:
-                  if (curChar == 110)
-                     jjstateSet[jjnewStateCnt++] = 15;
-                  break;
-               case 17:
-                  if ((0x80000000800000L & l) != 0L && kind > 11)
-                     kind = 11;
-                  break;
-               case 18:
-                  if ((0x400000004000L & l) != 0L && kind > 12)
-                     kind = 12;
-                  break;
-               case 24:
-                  jjAddStates(15, 16);
-                  break;
-               case 27:
-                  if ((0xffffffffefffffffL & l) != 0L)
-                     jjCheckNAddStates(12, 14);
-                  break;
-               case 28:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 29;
-                  break;
-               case 29:
-                  if (curChar == 92)
-                     jjCheckNAddStates(12, 14);
-                  break;
-               case 31:
-                  if ((0xffffffffbfffffffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddStates(0, 4);
-                  break;
-               case 32:
-                  if ((0xffffffffbfffffffL & l) != 0L)
-                     jjCheckNAddTwoStates(32, 33);
-                  break;
-               case 34:
-                  if ((0xffffffffbfffffffL & l) != 0L)
-                     jjCheckNAddTwoStates(34, 35);
-                  break;
-               case 36:
-                  if ((0xffffffffbfffffffL & l) == 0L)
-                     break;
-                  if (kind > 21)
-                     kind = 21;
-                  jjstateSet[jjnewStateCnt++] = 36;
-                  break;
-               case 37:
-                  if ((0xffffffffbfffffffL & l) == 0L)
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAdd(37);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAddStates(0, 4);
-                  break;
-               case 24:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(15, 16);
-                  break;
-               case 27:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(12, 14);
-                  break;
-               case 32:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddTwoStates(32, 33);
-                  break;
-               case 34:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddTwoStates(34, 35);
-                  break;
-               case 36:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 21)
-                     kind = 21;
-                  jjstateSet[jjnewStateCnt++] = 36;
-                  break;
-               case 37:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 22)
-                     kind = 22;
-                  jjCheckNAdd(37);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 38 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-private int jjMoveStringLiteralDfa0_0()
-{
-   return jjMoveNfa_0(0, 0);
-}
-private int jjMoveNfa_0(int startState, int curPos)
-{
-   int startsAt = 0;
-   jjnewStateCnt = 3;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 23)
-                     kind = 23;
-                  jjAddStates(17, 18);
-                  break;
-               case 1:
-                  if (curChar == 46)
-                     jjCheckNAdd(2);
-                  break;
-               case 2:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 23)
-                     kind = 23;
-                  jjCheckNAdd(2);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         do
-         {
-            switch(jjstateSet[--i])
-            {
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
-static final int[] jjnextStates = {
-   32, 33, 34, 35, 37, 24, 27, 28, 20, 17, 21, 18, 27, 28, 30, 24, 
-   25, 0, 1, 
-};
-private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
-{
-   switch(hiByte)
-   {
-      case 0:
-         return ((jjbitVec2[i2] & l2) != 0L);
-      default :
-         if ((jjbitVec0[i1] & l1) != 0L)
-            return true;
-         return false;
-   }
-}
-
-/** Token literal values. */
-public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, null, null, null, 
-"\50", "\51", "\54", "\72", "\136", null, null, null, null, null, null, };
-
-/** Lexer state names. */
-public static final String[] lexStateNames = {
-   "Boost",
-   "DEFAULT",
-};
-
-/** Lex State array. */
-public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 1, 
-};
-static final long[] jjtoToken = {
-   0xffff01L, 
-};
-static final long[] jjtoSkip = {
-   0x80L, 
-};
-protected CharStream input_stream;
-private final int[] jjrounds = new int[38];
-private final int[] jjstateSet = new int[76];
-protected char curChar;
-/** Constructor. */
-public QueryParserTokenManager(CharStream stream){
-   input_stream = stream;
-}
-
-/** Constructor. */
-public QueryParserTokenManager(CharStream stream, int lexState){
-   this(stream);
-   SwitchTo(lexState);
-}
-
-/** Reinitialise parser. */
-public void ReInit(CharStream stream)
-{
-   jjmatchedPos = jjnewStateCnt = 0;
-   curLexState = defaultLexState;
-   input_stream = stream;
-   ReInitRounds();
-}
-private void ReInitRounds()
-{
-   int i;
-   jjround = 0x80000001;
-   for (i = 38; i-- > 0;)
-      jjrounds[i] = 0x80000000;
-}
-
-/** Reinitialise parser. */
-public void ReInit(CharStream stream, int lexState)
-{
-   ReInit(stream);
-   SwitchTo(lexState);
-}
-
-/** Switch to specified lex state. */
-public void SwitchTo(int lexState)
-{
-   if (lexState >= 2 || lexState < 0)
-      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
-   else
-      curLexState = lexState;
-}
-
-protected Token jjFillToken()
-{
-   final Token t;
-   final String curTokenImage;
-   final int beginLine;
-   final int endLine;
-   final int beginColumn;
-   final int endColumn;
-   String im = jjstrLiteralImages[jjmatchedKind];
-   curTokenImage = (im == null) ? input_stream.GetImage() : im;
-   beginLine = input_stream.getBeginLine();
-   beginColumn = input_stream.getBeginColumn();
-   endLine = input_stream.getEndLine();
-   endColumn = input_stream.getEndColumn();
-   t = Token.newToken(jjmatchedKind, curTokenImage);
-
-   t.beginLine = beginLine;
-   t.endLine = endLine;
-   t.beginColumn = beginColumn;
-   t.endColumn = endColumn;
-
-   return t;
-}
-
-int curLexState = 1;
-int defaultLexState = 1;
-int jjnewStateCnt;
-int jjround;
-int jjmatchedPos;
-int jjmatchedKind;
-
-/** Get the next Token. */
-public Token getNextToken() 
-{
-  Token matchedToken;
-  int curPos = 0;
-
-  EOFLoop :
-  for (;;)
-  {
-   try
-   {
-      curChar = input_stream.BeginToken();
-   }
-   catch(java.io.IOException e)
-   {
-      jjmatchedKind = 0;
-      matchedToken = jjFillToken();
-      return matchedToken;
-   }
-
-   switch(curLexState)
-   {
-     case 0:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_0();
-       break;
-     case 1:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_1();
-       break;
-   }
-     if (jjmatchedKind != 0x7fffffff)
-     {
-        if (jjmatchedPos + 1 < curPos)
-           input_stream.backup(curPos - jjmatchedPos - 1);
-        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
-        {
-           matchedToken = jjFillToken();
-       if (jjnewLexState[jjmatchedKind] != -1)
-         curLexState = jjnewLexState[jjmatchedKind];
-           return matchedToken;
-        }
-        else
-        {
-         if (jjnewLexState[jjmatchedKind] != -1)
-           curLexState = jjnewLexState[jjmatchedKind];
-           continue EOFLoop;
-        }
-     }
-     int error_line = input_stream.getEndLine();
-     int error_column = input_stream.getEndColumn();
-     String error_after = null;
-     boolean EOFSeen = false;
-     try { input_stream.readChar(); input_stream.backup(1); }
-     catch (java.io.IOException e1) {
-        EOFSeen = true;
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-        if (curChar == '\n' || curChar == '\r') {
-           error_line++;
-           error_column = 0;
-        }
-        else
-           error_column++;
-     }
-     if (!EOFSeen) {
-        input_stream.backup(1);
-        error_after = curPos <= 1 ? "" : input_stream.GetImage();
-     }
-     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
-  }
-}
-
-private void jjCheckNAdd(int state)
-{
-   if (jjrounds[state] != jjround)
-   {
-      jjstateSet[jjnewStateCnt++] = state;
-      jjrounds[state] = jjround;
-   }
-}
-private void jjAddStates(int start, int end)
-{
-   do {
-      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
-   } while (start++ != end);
-}
-private void jjCheckNAddTwoStates(int state1, int state2)
-{
-   jjCheckNAdd(state1);
-   jjCheckNAdd(state2);
-}
-
-private void jjCheckNAddStates(int start, int end)
-{
-   do {
-      jjCheckNAdd(jjnextStates[start]);
-   } while (start++ != end);
-}
-
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/Token.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/Token.java
deleted file mode 100644
index 6c12289..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/Token.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
-/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
-package org.apache.lucene.queryParser.surround.parser;
-
-/**
- * Describes the input token stream.
- */
-
-public class Token {
-
-  /**
-   * An integer that describes the kind of this token.  This numbering
-   * system is determined by JavaCCParser, and a table of these numbers is
-   * stored in the file ...Constants.java.
-   */
-  public int kind;
-
-  /** The line number of the first character of this Token. */
-  public int beginLine;
-  /** The column number of the first character of this Token. */
-  public int beginColumn;
-  /** The line number of the last character of this Token. */
-  public int endLine;
-  /** The column number of the last character of this Token. */
-  public int endColumn;
-
-  /**
-   * The string image of the token.
-   */
-  public String image;
-
-  /**
-   * A reference to the next regular (non-special) token from the input
-   * stream.  If this is the last token from the input stream, or if the
-   * token manager has not read tokens beyond this one, this field is
-   * set to null.  This is true only if this token is also a regular
-   * token.  Otherwise, see below for a description of the contents of
-   * this field.
-   */
-  public Token next;
-
-  /**
-   * This field is used to access special tokens that occur prior to this
-   * token, but after the immediately preceding regular (non-special) token.
-   * If there are no such special tokens, this field is set to null.
-   * When there are more than one such special token, this field refers
-   * to the last of these special tokens, which in turn refers to the next
-   * previous special token through its specialToken field, and so on
-   * until the first special token (whose specialToken field is null).
-   * The next fields of special tokens refer to other special tokens that
-   * immediately follow it (without an intervening regular token).  If there
-   * is no such token, this field is null.
-   */
-  public Token specialToken;
-
-  /**
-   * An optional attribute value of the Token.
-   * Tokens which are not used as syntactic sugar will often contain
-   * meaningful values that will be used later on by the compiler or
-   * interpreter. This attribute value is often different from the image.
-   * Any subclass of Token that actually wants to return a non-null value can
-   * override this method as appropriate.
-   */
-  public Object getValue() {
-    return null;
-  }
-
-  /**
-   * No-argument constructor
-   */
-  public Token() {}
-
-  /**
-   * Constructs a new token for the specified Image.
-   */
-  public Token(int kind)
-  {
-     this(kind, null);
-  }
-
-  /**
-   * Constructs a new token for the specified Image and Kind.
-   */
-  public Token(int kind, String image)
-  {
-     this.kind = kind;
-     this.image = image;
-  }
-
-  /**
-   * Returns the image.
-   */
-  public String toString()
-  {
-     return image;
-  }
-
-  /**
-   * Returns a new Token object, by default. However, if you want, you
-   * can create and return subclass objects based on the value of ofKind.
-   * Simply add the cases to the switch for all those special cases.
-   * For example, if you have a subclass of Token called IDToken that
-   * you want to create if ofKind is ID, simply add something like :
-   *
-   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
-   *
-   * to the following switch statement. Then you can cast matchedToken
-   * variable to the appropriate type and use sit in your lexical actions.
-   */
-  public static Token newToken(int ofKind, String image)
-  {
-     switch(ofKind)
-     {
-       default : return new Token(ofKind, image);
-     }
-  }
-
-  public static Token newToken(int ofKind)
-  {
-     return newToken(ofKind, null);
-  }
-
-}
-/* JavaCC - OriginalChecksum=a1d2d2c0d7f5810183a1438fb4d51c1c (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/TokenMgrError.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/TokenMgrError.java
deleted file mode 100644
index bced060..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/TokenMgrError.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
-/* JavaCCOptions: */
-package org.apache.lucene.queryParser.surround.parser;
-
-/** Token Manager Error. */
-@SuppressWarnings("serial")
-public class TokenMgrError extends Error
-{
-
-   /*
-    * Ordinals for various reasons why an Error of this type can be thrown.
-    */
-
-   /**
-    * Lexical error occurred.
-    */
-   static final int LEXICAL_ERROR = 0;
-
-   /**
-    * An attempt was made to create a second instance of a static token manager.
-    */
-   static final int STATIC_LEXER_ERROR = 1;
-
-   /**
-    * Tried to change to an invalid lexical state.
-    */
-   static final int INVALID_LEXICAL_STATE = 2;
-
-   /**
-    * Detected (and bailed out of) an infinite loop in the token manager.
-    */
-   static final int LOOP_DETECTED = 3;
-
-   /**
-    * Indicates the reason why the exception is thrown. It will have
-    * one of the above 4 values.
-    */
-   int errorCode;
-
-   /**
-    * Replaces unprintable characters by their escaped (or unicode escaped)
-    * equivalents in the given string
-    */
-   protected static final String addEscapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
-      }
-      return retval.toString();
-   }
-
-   /**
-    * Returns a detailed message for the Error when it is thrown by the
-    * token manager to indicate a lexical error.
-    * Parameters :
-    *    EOFSeen     : indicates if EOF caused the lexical error
-    *    curLexState : lexical state in which this error occurred
-    *    errorLine   : line number when the error occurred
-    *    errorColumn : column number when the error occurred
-    *    errorAfter  : prefix that was seen before this error occurred
-    *    curchar     : the offending character
-    * Note: You can customize the lexical error message by modifying this method.
-    */
-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
-      return("Lexical error at line " +
-           errorLine + ", column " +
-           errorColumn + ".  Encountered: " +
-           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
-           "after : \"" + addEscapes(errorAfter) + "\"");
-   }
-
-   /**
-    * You can also modify the body of this method to customize your error messages.
-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like :
-    *
-    *     "Internal Error : Please file a bug report .... "
-    *
-    * from this method for such cases in the release version of your parser.
-    */
-   public String getMessage() {
-      return super.getMessage();
-   }
-
-   /*
-    * Constructors of various flavors follow.
-    */
-
-   /** No arg constructor. */
-   public TokenMgrError() {
-   }
-
-   /** Constructor with message and reason. */
-   public TokenMgrError(String message, int reason) {
-      super(message);
-      errorCode = reason;
-   }
-
-   /** Full Constructor. */
-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
-   }
-}
-/* JavaCC - OriginalChecksum=fecdd69c7d7b49407e441e312085db53 (do not edit this line) */
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/package.html
deleted file mode 100644
index f8457d1..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/parser/package.html
+++ /dev/null
@@ -1,28 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-  <head>
-    <title>Surround parser package</title>
-  </head>
-  <body>
-    This package contains the QueryParser.jj source file for the Surround parser.
-    <p/>
-    Parsing the text of a query results in a SrndQuery in the
-    org.apache.lucene.queryParser.surround.query package.
-  </body>
-</html>
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/AndQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/AndQuery.java
deleted file mode 100644
index a5d628c..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/AndQuery.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.util.List;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause;
-
-public class AndQuery extends ComposedQuery { 
-  public AndQuery(List<SrndQuery> queries, boolean inf, String opName) { 
-    super(queries, inf, opName);
-  }
-  
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery( /* subqueries can be individually boosted */
-      makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.MUST);
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/BasicQueryFactory.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/BasicQueryFactory.java
deleted file mode 100644
index a55bdd2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/BasicQueryFactory.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Create basic queries to be used during rewrite.
- * The basic queries are TermQuery and SpanTermQuery.
- * An exception can be thrown when too many of these are used.
- * SpanTermQuery and TermQuery use IndexReader.termEnum(Term), which causes the buffer usage.
- *
- * Use this class to limit the buffer usage for reading terms from an index.
- * Default is 1024, the same as the max. number of subqueries for a BooleanQuery.
- */
- 
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-
-public class BasicQueryFactory {
-  public BasicQueryFactory(int maxBasicQueries) {
-    this.maxBasicQueries = maxBasicQueries;
-    this.queriesMade = 0;
-  }
-  
-  public BasicQueryFactory() {
-    this(1024);
-  }
-  
-  private int maxBasicQueries;
-  private int queriesMade;
-  
-  public int getNrQueriesMade() {return queriesMade;}
-  public int getMaxBasicQueries() {return maxBasicQueries;}
-  
-  private synchronized void checkMax() throws TooManyBasicQueries {
-    if (queriesMade >= maxBasicQueries)
-      throw new TooManyBasicQueries(getMaxBasicQueries());
-    queriesMade++;
-  }
-  
-  public TermQuery newTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
-    return new TermQuery(term);
-  }
-  
-  public SpanTermQuery newSpanTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
-    return new SpanTermQuery(term);
-  }
-}
-
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/ComposedQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/ComposedQuery.java
deleted file mode 100644
index 0b43d97..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/ComposedQuery.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Iterator;
-
-import org.apache.lucene.search.Query;
-
-public abstract class ComposedQuery extends SrndQuery { 
-  
-  public ComposedQuery(List qs, boolean operatorInfix, String opName) {
-    recompose(qs);
-    this.operatorInfix = operatorInfix;
-    this.opName = opName;
-  }
-  
-  protected void recompose(List queries) {
-    if (queries.size() < 2) throw new AssertionError("Too few subqueries"); 
-    this.queries = queries;
-  }
-  
-  private String opName;
-  public String getOperatorName() {return opName;}
-  
-  private List queries;
-  
-  public Iterator getSubQueriesIterator() {return queries.listIterator();}
-
-  public int getNrSubQueries() {return queries.size();}
-  
-  public SrndQuery getSubQuery(int qn) {return (SrndQuery) queries.get(qn);}
-
-  private boolean operatorInfix; 
-  public boolean isOperatorInfix() { return operatorInfix; } /* else prefix operator */
-  
-  public List<Query> makeLuceneSubQueriesField(String fn, BasicQueryFactory qf) {
-    List<Query> luceneSubQueries = new ArrayList<Query>();
-    Iterator sqi = getSubQueriesIterator();
-    while (sqi.hasNext()) {
-      luceneSubQueries.add( ((SrndQuery) sqi.next()).makeLuceneQueryField(fn, qf));
-    }
-    return luceneSubQueries;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder r = new StringBuilder();
-    if (isOperatorInfix()) {
-      infixToString(r);
-    } else {
-      prefixToString(r);
-    }
-    weightToString(r);
-    return r.toString();
-  }
-
-  /* Override for different spacing */
-  protected String getPrefixSeparator() { return ", ";}
-  protected String getBracketOpen() { return "(";}
-  protected String getBracketClose() { return ")";}
-  
-  protected void infixToString(StringBuilder r) {
-    /* Brackets are possibly redundant in the result. */
-    Iterator sqi = getSubQueriesIterator();
-    r.append(getBracketOpen());
-    if (sqi.hasNext()) {
-      r.append(sqi.next().toString());
-      while (sqi.hasNext()) {
-        r.append(" ");
-        r.append(getOperatorName()); /* infix operator */
-        r.append(" ");
-        r.append(sqi.next().toString());
-      }
-    }
-    r.append(getBracketClose());
-  }
-
-  protected void prefixToString(StringBuilder r) {
-    Iterator sqi = getSubQueriesIterator();
-    r.append(getOperatorName()); /* prefix operator */
-    r.append(getBracketOpen());
-    if (sqi.hasNext()) {
-      r.append(sqi.next().toString());
-      while (sqi.hasNext()) {
-        r.append(getPrefixSeparator());
-        r.append(sqi.next().toString());
-      }
-    }
-    r.append(getBracketClose());
-  }
-  
-  
-  @Override
-  public boolean isFieldsSubQueryAcceptable() {
-    /* at least one subquery should be acceptable */
-    Iterator sqi = getSubQueriesIterator();
-    while (sqi.hasNext()) {
-      if (((SrndQuery) sqi.next()).isFieldsSubQueryAcceptable()) {
-        return true;
-      }
-    }
-    return false;
-  }
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceQuery.java
deleted file mode 100644
index 9e40f00..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceQuery.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.util.List;
-import java.util.Iterator;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-
-public class DistanceQuery extends ComposedQuery implements DistanceSubQuery {
-  public DistanceQuery(
-      List<SrndQuery> queries,
-      boolean infix,
-      int opDistance,
-      String opName,
-      boolean ordered) {
-    super(queries, infix, opName);
-    this.opDistance = opDistance; /* the distance indicated in the operator */
-    this.ordered = ordered;
-  }
-
-  private int opDistance;
-  public int getOpDistance() {return opDistance;}
-  
-  private boolean ordered;
-  public boolean subQueriesOrdered() {return ordered;}
-  
-  public String distanceSubQueryNotAllowed() {
-    Iterator<?> sqi = getSubQueriesIterator();
-    while (sqi.hasNext()) {
-      Object leq = sqi.next();
-      if (leq instanceof DistanceSubQuery) {
-        DistanceSubQuery dsq = (DistanceSubQuery) leq;
-        String m = dsq.distanceSubQueryNotAllowed();
-        if (m != null) {
-          return m; 
-        }
-      } else {
-        return "Operator " + getOperatorName() + " does not allow subquery " + leq.toString();
-      }
-    }
-    return null; /* subqueries acceptable */
-  }
-
-  
-  public void addSpanQueries(SpanNearClauseFactory sncf) throws IOException {
-    Query snq = getSpanNearQuery(sncf.getIndexReader(),
-                                  sncf.getFieldName(),
-                                  getWeight(),
-                                  sncf.getBasicQueryFactory());
-    sncf.addSpanNearQuery(snq);
-  }
-
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new Query () {
-      
-      @Override
-      public String toString(String fn) {
-        return getClass().toString() + " " + fieldName + " (" + fn + "?)";
-      }
-      
-      @Override
-      public Query rewrite(IndexReader reader) throws IOException {
-        return getSpanNearQuery(reader, fieldName, getBoost(), qf);
-      }
-      
-    };
-  }
-  
-  public Query getSpanNearQuery(
-          IndexReader reader,
-          String fieldName,
-          float boost,
-          BasicQueryFactory qf) throws IOException {
-    SpanQuery[] spanNearClauses = new SpanQuery[getNrSubQueries()];
-    Iterator<?> sqi = getSubQueriesIterator();
-    int qi = 0;
-    while (sqi.hasNext()) {
-      SpanNearClauseFactory sncf = new SpanNearClauseFactory(reader, fieldName, qf);
-      
-      ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
-      if (sncf.size() == 0) { /* distance operator requires all sub queries */
-        while (sqi.hasNext()) { /* produce evt. error messages but ignore results */
-          ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
-          sncf.clear();
-        }
-        return SrndQuery.theEmptyLcnQuery;
-      }
-      
-      spanNearClauses[qi] = sncf.makeSpanNearClause();
-
-      qi++;
-    }
-    
-    SpanNearQuery r = new SpanNearQuery(spanNearClauses, getOpDistance() - 1, subQueriesOrdered());
-    r.setBoost(boost);
-    return r;
-  }
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceSubQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceSubQuery.java
deleted file mode 100644
index d63b82e..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/DistanceSubQuery.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-public interface DistanceSubQuery {
-  /** When distanceSubQueryNotAllowed() returns non null, the reason why the subquery
-   * is not allowed as a distance subquery is returned.
-   * <br>When distanceSubQueryNotAllowed() returns null addSpanNearQueries() can be used
-   * in the creation of the span near clause for the subquery.
-   */
-  String distanceSubQueryNotAllowed();
-    
-  void addSpanQueries(SpanNearClauseFactory sncf) throws IOException;
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/FieldsQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/FieldsQuery.java
deleted file mode 100644
index daea96d..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/FieldsQuery.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Iterator;
-
-import org.apache.lucene.search.Query;
-
-public class FieldsQuery extends SrndQuery { /* mostly untested */
-  private SrndQuery q;
-  private List<String> fieldNames;
-  private final char fieldOp;
-  private final String OrOperatorName = "OR"; /* for expanded queries, not normally visible */
-  
-  public FieldsQuery(SrndQuery q, List<String> fieldNames, char fieldOp) {
-    this.q = q;
-    this.fieldNames = fieldNames;
-    this.fieldOp = fieldOp;
-  }
-  
-  public FieldsQuery(SrndQuery q, String fieldName, char fieldOp) {
-    this.q = q;
-    fieldNames = new ArrayList<String>();
-    fieldNames.add(fieldName);
-    this.fieldOp = fieldOp;
-  }
-  
-  @Override
-  public boolean isFieldsSubQueryAcceptable() {
-    return false;
-  }
-  
-  public Query makeLuceneQueryNoBoost(BasicQueryFactory qf) {
-    if (fieldNames.size() == 1) { /* single field name: no new queries needed */
-      return q.makeLuceneQueryFieldNoBoost(fieldNames.get(0), qf);
-    } else { /* OR query over the fields */
-      List<SrndQuery> queries = new ArrayList<SrndQuery>();
-      Iterator<String> fni = getFieldNames().listIterator();
-      SrndQuery qc;
-      while (fni.hasNext()) {
-        qc = (SrndQuery) q.clone();
-        queries.add( new FieldsQuery( qc, fni.next(), fieldOp));
-      }
-      OrQuery oq = new OrQuery(queries,
-                              true /* infix OR for field names */,
-                              OrOperatorName);
-      System.out.println(getClass().toString() + ", fields expanded: " + oq.toString()); /* needs testing */
-      return oq.makeLuceneQueryField(null, qf);
-    }
-  }
-
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return makeLuceneQueryNoBoost(qf); /* use this.fieldNames instead of fieldName */
-  }
-
-  
-  public List<String> getFieldNames() {return fieldNames;}
-
-  public char getFieldOperator() { return fieldOp;}
-  
-  @Override
-  public String toString() {
-    StringBuilder r = new StringBuilder();
-    r.append("(");
-    fieldNamesToString(r);
-    r.append(q.toString());
-    r.append(")");
-    return r.toString();
-  }
-  
-  protected void fieldNamesToString(StringBuilder r) {
-    Iterator<String> fni = getFieldNames().listIterator();
-    while (fni.hasNext()) {
-      r.append(fni.next());
-      r.append(getFieldOperator());
-    }
-  }
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/NotQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/NotQuery.java
deleted file mode 100644
index a53b639..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/NotQuery.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
-
-public class NotQuery extends ComposedQuery { 
-  public NotQuery(List<SrndQuery> queries, String opName) { super(queries, true /* infix */, opName); }
-  
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
-    BooleanQuery bq = new BooleanQuery();
-    bq.add( luceneSubQueries.get(0), BooleanClause.Occur.MUST);
-    SrndBooleanQuery.addQueriesToBoolean(bq,
-            // FIXME: do not allow weights on prohibited subqueries.
-            luceneSubQueries.subList(1, luceneSubQueries.size()),
-            // later subqueries: not required, prohibited
-            BooleanClause.Occur.MUST_NOT);
-    return bq;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/OrQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/OrQuery.java
deleted file mode 100644
index 72fd5f0..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/OrQuery.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-import java.util.Iterator;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause;
-
-import java.io.IOException;
-
-public class OrQuery extends ComposedQuery implements DistanceSubQuery { 
-  public OrQuery(List<SrndQuery> queries, boolean infix, String opName) {
-    super(queries, infix, opName);
-  }
-  
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery(
-      /* subqueries can be individually boosted */
-      makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.SHOULD);
-  }
-  
-  public String distanceSubQueryNotAllowed() {
-    Iterator sqi = getSubQueriesIterator();
-    while (sqi.hasNext()) {
-      SrndQuery leq = (SrndQuery) sqi.next();
-      if (leq instanceof DistanceSubQuery) {
-        String m = ((DistanceSubQuery)leq).distanceSubQueryNotAllowed();
-        if (m != null) {
-          return m;
-        }
-      } else {
-        return "subquery not allowed: " + leq.toString();
-      }
-    }
-    return null;
-  }
-    
-  public void addSpanQueries(SpanNearClauseFactory sncf) throws IOException {
-    Iterator sqi = getSubQueriesIterator();
-    while (sqi.hasNext()) {
-      ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
-    }
-  }
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SimpleTerm.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SimpleTerm.java
deleted file mode 100644
index 436aaba..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SimpleTerm.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.Query;
-
-public abstract class SimpleTerm
-  extends SrndQuery
-  implements DistanceSubQuery, Comparable<SimpleTerm>
-{
-  public SimpleTerm(boolean q) {quoted = q;}
-  
-  private boolean quoted;
-  boolean isQuoted() {return quoted;}
-  
-  public String getQuote() {return "\"";}
-  public String getFieldOperator() {return "/";}
-  
-  public abstract String toStringUnquoted();
-  
-  public int compareTo(SimpleTerm ost) {
-    /* for ordering terms and prefixes before using an index, not used */
-    return this.toStringUnquoted().compareTo( ost.toStringUnquoted());
-  }
-  
-  protected void suffixToString(StringBuilder r) {} /* override for prefix query */
-  
-  @Override
-  public String toString() {
-    StringBuilder r = new StringBuilder();
-    if (isQuoted()) {
-      r.append(getQuote());
-    }
-    r.append(toStringUnquoted());
-    if (isQuoted()) {
-      r.append(getQuote());
-    }
-    suffixToString(r);
-    weightToString(r);
-    return r.toString();
-  }
-  
-  public abstract void visitMatchingTerms(
-                            IndexReader reader,
-                            String fieldName,
-                            MatchingTermVisitor mtv) throws IOException;
-  
-  public interface MatchingTermVisitor {
-    void visitMatchingTerm(Term t)throws IOException;
-  }
-
-  public String distanceSubQueryNotAllowed() {return null;}
-
-  
-  @Override
-  public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new Query() {
-      @Override
-      public String toString(String fn) {
-        return getClass().toString() + " " + fieldName + " (" + fn + "?)";
-      }
-      
-      @Override
-      public Query rewrite(IndexReader reader) throws IOException {
-        final List<Query> luceneSubQueries = new ArrayList<Query>();
-        visitMatchingTerms( reader, fieldName,
-            new MatchingTermVisitor() {
-              public void visitMatchingTerm(Term term) throws IOException {
-                luceneSubQueries.add(qf.newTermQuery(term));
-              }
-            });
-        return  (luceneSubQueries.size() == 0) ? SrndQuery.theEmptyLcnQuery
-              : (luceneSubQueries.size() == 1) ? luceneSubQueries.get(0)
-              : SrndBooleanQuery.makeBooleanQuery(
-                  /* luceneSubQueries all have default weight */
-                  luceneSubQueries, BooleanClause.Occur.SHOULD); /* OR the subquery terms */ 
-      }
-    };
-  }
-    
-  public void addSpanQueries(final SpanNearClauseFactory sncf) throws IOException {
-    visitMatchingTerms(
-          sncf.getIndexReader(),
-          sncf.getFieldName(),
-          new MatchingTermVisitor() {
-            public void visitMatchingTerm(Term term) throws IOException {
-              sncf.addTermWeighted(term, getWeight());
-            }
-          });
-  }
-}
-
-
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java
deleted file mode 100644
index 44f534b..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
-SpanNearClauseFactory:
-
-Operations:
-
-- create for a field name and an indexreader.
-
-- add a weighted Term
-  this should add a corresponding SpanTermQuery, or
-  increase the weight of an existing one.
-  
-- add a weighted subquery SpanNearQuery 
-
-- create a clause for SpanNearQuery from the things added above.
-  For this, create an array of SpanQuery's from the added ones.
-  The clause normally is a SpanOrQuery over the added subquery SpanNearQuery
-  the SpanTermQuery's for the added Term's
-*/
-
-/* When  it is necessary to suppress double subqueries as much as possible:
-   hashCode() and equals() on unweighted SpanQuery are needed (possibly via getTerms(),
-   the terms are individually hashable).
-   Idem SpanNearQuery: hash on the subqueries and the slop.
-   Evt. merge SpanNearQuery's by adding the weights of the corresponding subqueries.
- */
- 
-/* To be determined:
-   Are SpanQuery weights handled correctly during search by Lucene?
-   Should the resulting SpanOrQuery be sorted?
-   Could other SpanQueries be added for use in this factory:
-   - SpanOrQuery: in principle yes, but it only has access to it's terms
-                  via getTerms(); are the corresponding weights available?
-   - SpanFirstQuery: treat similar to subquery SpanNearQuery. (ok?)
-   - SpanNotQuery: treat similar to subquery SpanNearQuery. (ok?)
- */
-
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.HashMap;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-
-
-public class SpanNearClauseFactory {
-  public SpanNearClauseFactory(IndexReader reader, String fieldName, BasicQueryFactory qf) {
-    this.reader = reader;
-    this.fieldName = fieldName;
-    this.weightBySpanQuery = new HashMap<SpanQuery, Float>(); 
-    this.qf = qf;
-  }
-  private IndexReader reader;
-  private String fieldName;
-  private HashMap<SpanQuery, Float> weightBySpanQuery;
-  private BasicQueryFactory qf;
-  
-  public IndexReader getIndexReader() {return reader;}
-  
-  public String getFieldName() {return fieldName;}
-
-  public BasicQueryFactory getBasicQueryFactory() {return qf;}
-  
-  public int size() {return weightBySpanQuery.size();}
-  
-  public void clear() {weightBySpanQuery.clear();}
-
-  protected void addSpanQueryWeighted(SpanQuery sq, float weight) {
-    Float w = weightBySpanQuery.get(sq);
-    if (w != null)
-      w = Float.valueOf(w.floatValue() + weight);
-    else
-      w = Float.valueOf(weight);
-    weightBySpanQuery.put(sq, w); 
-  }
-  
-  public void addTermWeighted(Term t, float weight) throws IOException {   
-    SpanTermQuery stq = qf.newSpanTermQuery(t);
-    /* CHECKME: wrap in Hashable...? */
-    addSpanQueryWeighted(stq, weight);
-  }
-  
-  public void addSpanNearQuery(Query q) {
-    if (q == SrndQuery.theEmptyLcnQuery)
-      return;
-    if (! (q instanceof SpanNearQuery))
-      throw new AssertionError("Expected SpanNearQuery: " + q.toString(getFieldName()));
-    /* CHECKME: wrap in Hashable...? */
-    addSpanQueryWeighted((SpanNearQuery)q, q.getBoost());
-  }
-  
-  public SpanQuery makeSpanNearClause() {
-    SpanQuery [] spanQueries = new SpanQuery[size()];
-    Iterator<SpanQuery> sqi = weightBySpanQuery.keySet().iterator();
-    int i = 0;
-    while (sqi.hasNext()) {
-      SpanQuery sq = sqi.next();
-      sq.setBoost(weightBySpanQuery.get(sq).floatValue());
-      spanQueries[i++] = sq;
-    }
-    
-    if (spanQueries.length == 1)
-      return spanQueries[0];
-    else
-      return new SpanOrQuery(spanQueries);
-  }
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndBooleanQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndBooleanQuery.java
deleted file mode 100644
index d2b3c6c..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndBooleanQuery.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
-
-class SrndBooleanQuery {
-  public static void addQueriesToBoolean(
-          BooleanQuery bq,
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    for (int i = 0; i < queries.size(); i++) {
-      bq.add( queries.get(i), occur);
-    }
-  }
-  
-  public static Query makeBooleanQuery(
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    if (queries.size() <= 1) {
-      throw new AssertionError("Too few subqueries: " + queries.size());
-    }
-    BooleanQuery bq = new BooleanQuery();
-    addQueriesToBoolean(bq, queries.subList(0, queries.size()), occur);
-    return bq;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndPrefixQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndPrefixQuery.java
deleted file mode 100644
index 1c2d139..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndPrefixQuery.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.MultiFields;
-
-import java.io.IOException;
-
-
-public class SrndPrefixQuery extends SimpleTerm {
-  private final BytesRef prefixRef;
-  public SrndPrefixQuery(String prefix, boolean quoted, char truncator) {
-    super(quoted);
-    this.prefix = prefix;
-    prefixRef = new BytesRef(prefix);
-    this.truncator = truncator;
-  }
-
-  private final String prefix;
-  public String getPrefix() {return prefix;}
-  
-  private final char truncator;
-  public char getSuffixOperator() {return truncator;}
-  
-  public Term getLucenePrefixTerm(String fieldName) {
-    return new Term(fieldName, getPrefix());
-  }
-  
-  @Override
-  public String toStringUnquoted() {return getPrefix();}
-  
-  @Override
-  protected void suffixToString(StringBuilder r) {r.append(getSuffixOperator());}
-  
-  @Override
-  public void visitMatchingTerms(
-    IndexReader reader,
-    String fieldName,
-    MatchingTermVisitor mtv) throws IOException
-  {
-    /* inspired by PrefixQuery.rewrite(): */
-    Terms terms = MultiFields.getTerms(reader, fieldName);
-    if (terms != null) {
-      TermsEnum termsEnum = terms.iterator();
-
-      boolean skip = false;
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getPrefix()));
-      if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLucenePrefixTerm(fieldName));
-      } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
-        if (termsEnum.term().startsWith(prefixRef)) {
-          mtv.visitMatchingTerm(new Term(fieldName, termsEnum.term().utf8ToString()));
-        } else {
-          skip = true;
-        }
-      } else {
-        // EOF
-        skip = true;
-      }
-
-      if (!skip) {
-        while(true) {
-          BytesRef text = termsEnum.next();
-          if (text != null && text.startsWith(prefixRef)) {
-            mtv.visitMatchingTerm(new Term(fieldName, text.utf8ToString()));
-          } else {
-            break;
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndQuery.java
deleted file mode 100644
index 523c076..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndQuery.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-
-public abstract class SrndQuery implements Cloneable {
-  public SrndQuery() {}
-  
-  private float weight = (float) 1.0;
-  private boolean weighted = false;
-
-  public void setWeight(float w) {
-    weight = w; /* as parsed from the query text */
-    weighted = true;
-  } 
-  public boolean isWeighted() {return weighted;}
-  public float getWeight() { return weight; }
-  public String getWeightString() {return Float.toString(getWeight());}
-
-  public String getWeightOperator() {return "^";}
-
-  protected void weightToString(StringBuilder r) { /* append the weight part of a query */
-    if (isWeighted()) {
-      r.append(getWeightOperator());
-      r.append(getWeightString());
-    }
-  }
-  
-  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf){
-    Query q = makeLuceneQueryFieldNoBoost(fieldName, qf);
-    if (isWeighted()) {
-      q.setBoost(getWeight() * q.getBoost()); /* weight may be at any level in a SrndQuery */
-    }
-    return q;
-  }
-  
-  public abstract Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf);
-  
-  @Override
-  public abstract String toString();
-  
-  public boolean isFieldsSubQueryAcceptable() {return true;}
-    
-  @Override
-  public Object clone() {
-    try {
-      return super.clone();
-    } catch (CloneNotSupportedException cns) {
-      throw new Error(cns);
-    }
-  }
-  
-/* An empty Lucene query */
-  public final static Query theEmptyLcnQuery = new BooleanQuery() { /* no changes allowed */
-    @Override
-    public void setBoost(float boost) {
-      throw new UnsupportedOperationException();
-    }
-    @Override
-    public void add(BooleanClause clause) {
-      throw new UnsupportedOperationException();
-    }
-    @Override
-    public void add(Query query, BooleanClause.Occur occur) {
-      throw new UnsupportedOperationException();
-    }
-  };
-}
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTermQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTermQuery.java
deleted file mode 100644
index b272d16..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTermQuery.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.MultiFields;
-import org.apache.lucene.util.BytesRef;
-
- 
-public class SrndTermQuery extends SimpleTerm {
-  public SrndTermQuery(String termText, boolean quoted) {
-    super(quoted);
-    this.termText = termText;
-  }
-
-  private final String termText;
-  public String getTermText() {return termText;}
-        
-  public Term getLuceneTerm(String fieldName) {
-    return new Term(fieldName, getTermText());
-  }
-  
-  @Override
-  public String toStringUnquoted() {return getTermText();}
-  
-  @Override
-  public void visitMatchingTerms(
-    IndexReader reader,
-    String fieldName,
-    MatchingTermVisitor mtv) throws IOException
-  {
-    /* check term presence in index here for symmetry with other SimpleTerm's */
-    Terms terms = MultiFields.getTerms(reader, fieldName);
-    if (terms != null) {
-      TermsEnum termsEnum = terms.iterator();
-
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getTermText()));
-      if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLuceneTerm(fieldName));
-      }
-    }
-  }
-}
-  
-
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTruncQuery.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTruncQuery.java
deleted file mode 100644
index df9b952..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/SrndTruncQuery.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.MultiFields;
-
-import java.io.IOException;
-
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
-
-
-public class SrndTruncQuery extends SimpleTerm {
-  public SrndTruncQuery(String truncated, char unlimited, char mask) {
-    super(false); /* not quoted */
-    this.truncated = truncated;
-    this.unlimited = unlimited;
-    this.mask = mask;
-    truncatedToPrefixAndPattern();
-  }
-  
-  private final String truncated;
-  private final char unlimited;
-  private final char mask;
-  
-  private String prefix;
-  private BytesRef prefixRef;
-  private Pattern pattern;
-  
-  
-  public String getTruncated() {return truncated;}
-  
-  @Override
-  public String toStringUnquoted() {return getTruncated();}
-
-  
-  protected boolean matchingChar(char c) {
-    return (c != unlimited) && (c != mask);
-  }
-
-  protected void appendRegExpForChar(char c, StringBuilder re) {
-    if (c == unlimited)
-      re.append(".*");
-    else if (c == mask)
-      re.append(".");
-    else
-      re.append(c);
-  }
-  
-  protected void truncatedToPrefixAndPattern() {
-    int i = 0;
-    while ((i < truncated.length()) && matchingChar(truncated.charAt(i))) {
-      i++;
-    }
-    prefix = truncated.substring(0, i);
-    prefixRef = new BytesRef(prefix);
-    
-    StringBuilder re = new StringBuilder();
-    while (i < truncated.length()) {
-      appendRegExpForChar(truncated.charAt(i), re);
-      i++;
-    }
-    pattern = Pattern.compile(re.toString());
-  }
-  
-  @Override
-  public void visitMatchingTerms(
-    IndexReader reader,
-    String fieldName,
-    MatchingTermVisitor mtv) throws IOException
-  {
-    int prefixLength = prefix.length();
-    Terms terms = MultiFields.getTerms(reader, fieldName);
-    if (terms != null) {
-      Matcher matcher = pattern.matcher("");
-      try {
-        TermsEnum termsEnum = terms.iterator();
-
-        TermsEnum.SeekStatus status = termsEnum.seekCeil(prefixRef);
-        BytesRef text;
-        if (status == TermsEnum.SeekStatus.FOUND) {
-          text = prefixRef;
-        } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
-          text = termsEnum.term();
-        } else {
-          text = null;
-        }
-
-        while(text != null) {
-          if (text != null && text.startsWith(prefixRef)) {
-            String textString = text.utf8ToString();
-            matcher.reset(textString.substring(prefixLength));
-            if (matcher.matches()) {
-              mtv.visitMatchingTerm(new Term(fieldName, textString));
-            }
-          } else {
-            break;
-          }
-          text = termsEnum.next();
-        }
-      } finally {
-        matcher.reset();
-      }
-    }
-  }
-}
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/TooManyBasicQueries.java b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/TooManyBasicQueries.java
deleted file mode 100644
index bf5d074..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/TooManyBasicQueries.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException; /* subclass to be usable from within Query.rewrite() */
-
-public class TooManyBasicQueries extends IOException {
-  public TooManyBasicQueries(int maxBasicQueries) {
-    super("Exceeded maximum of " + maxBasicQueries + " basic queries.");
-  }
-}
-  
-
diff --git a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/package.html b/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/package.html
deleted file mode 100644
index 4d125a2..0000000
--- a/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/surround/query/package.html
+++ /dev/null
@@ -1,32 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-  <head>
-    <title>Surround query package</title>
-  </head>
-  <body>
-    This package contains SrndQuery and its subclasses.
-    <p/>
-    The parser in the org.apache.lucene.queryParser.surround.parser package
-    normally generates a SrndQuery.
-    <p/>
-    For searching an org.apache.lucene.search.Query is provided by
-    the SrndQuery.makeLuceneQueryField method.
-    For this, TermQuery, BooleanQuery and SpanQuery are used from Lucene.
-  </body>
-</html>
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java
deleted file mode 100644
index 515d430..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java
+++ /dev/null
@@ -1,150 +0,0 @@
-package org.apache.lucene.queryParser.analyzing;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.io.Reader;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- */
-public class TestAnalyzingQueryParser extends LuceneTestCase {
-
-  private Analyzer a;
-
-  private String[] wildcardInput;
-  private String[] wildcardExpected;
-  private String[] prefixInput;
-  private String[] prefixExpected;
-  private String[] rangeInput;
-  private String[] rangeExpected;
-  private String[] fuzzyInput;
-  private String[] fuzzyExpected;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    wildcardInput = new String[] { "übersetzung über*ung",
-        "Mötley Cr\u00fce Mötl?* Crü?", "Renée Zellweger Ren?? Zellw?ger" };
-    wildcardExpected = new String[] { "ubersetzung uber*ung", "motley crue motl?* cru?",
-        "renee zellweger ren?? zellw?ger" };
-
-    prefixInput = new String[] { "übersetzung übersetz*",
-        "Mötley Crüe Mötl* crü*", "René? Zellw*" };
-    prefixExpected = new String[] { "ubersetzung ubersetz*", "motley crue motl* cru*",
-        "rene? zellw*" };
-
-    rangeInput = new String[] { "[aa TO bb]", "{Anaïs TO Zoé}" };
-    rangeExpected = new String[] { "[aa TO bb]", "{anais TO zoe}" };
-
-    fuzzyInput = new String[] { "?bersetzung ?bersetzung~0.9",
-        "Mötley Crüe Mötley~0.75 Crüe~0.5",
-        "Renée Zellweger Renée~0.9 Zellweger~" };
-    fuzzyExpected = new String[] { "ubersetzung ubersetzung~0.9",
-        "motley crue motley~0.75 crue~0.5", "renee zellweger renee~0.9 zellweger~2.0" };
-
-    a = new ASCIIAnalyzer();
-  }
-
-  public void testWildCardQuery() throws ParseException {
-    for (int i = 0; i < wildcardInput.length; i++) {
-      assertEquals("Testing wildcards with analyzer " + a.getClass() + ", input string: "
-          + wildcardInput[i], wildcardExpected[i], parseWithAnalyzingQueryParser(wildcardInput[i], a));
-    }
-  }
-
-  public void testPrefixQuery() throws ParseException {
-    for (int i = 0; i < prefixInput.length; i++) {
-      assertEquals("Testing prefixes with analyzer " + a.getClass() + ", input string: "
-          + prefixInput[i], prefixExpected[i], parseWithAnalyzingQueryParser(prefixInput[i], a));
-    }
-  }
-
-  public void testRangeQuery() throws ParseException {
-    for (int i = 0; i < rangeInput.length; i++) {
-      assertEquals("Testing ranges with analyzer " + a.getClass() + ", input string: "
-          + rangeInput[i], rangeExpected[i], parseWithAnalyzingQueryParser(rangeInput[i], a));
-    }
-  }
-
-  public void testFuzzyQuery() throws ParseException {
-    for (int i = 0; i < fuzzyInput.length; i++) {
-      assertEquals("Testing fuzzys with analyzer " + a.getClass() + ", input string: "
-          + fuzzyInput[i], fuzzyExpected[i], parseWithAnalyzingQueryParser(fuzzyInput[i], a));
-    }
-  }
-
-  private String parseWithAnalyzingQueryParser(String s, Analyzer a) throws ParseException {
-    AnalyzingQueryParser qp = new AnalyzingQueryParser(TEST_VERSION_CURRENT, "field", a);
-    org.apache.lucene.search.Query q = qp.parse(s);
-    return q.toString("field");
-  }
-
-}
-
-final class TestFoldingFilter extends TokenFilter {
-  final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
-
-  public TestFoldingFilter(TokenStream input) {
-    super(input);
-  }
-
-  @Override
-  public boolean incrementToken() throws IOException {
-    if (input.incrementToken()) {
-      char term[] = termAtt.buffer();
-      for (int i = 0; i < term.length; i++)
-        switch(term[i]) {
-          case 'ü':
-            term[i] = 'u'; 
-            break;
-          case 'ö': 
-            term[i] = 'o'; 
-            break;
-          case 'é': 
-            term[i] = 'e'; 
-            break;
-          case 'ï': 
-            term[i] = 'i'; 
-            break;
-        }
-      return true;
-    } else {
-      return false;
-    }
-  }
-}
-
-final class ASCIIAnalyzer extends org.apache.lucene.analysis.Analyzer {
-  public ASCIIAnalyzer() {
-  }
-
-  @Override
-  public TokenStream tokenStream(String fieldName, Reader reader) {
-    TokenStream result = new MockTokenizer(reader, MockTokenizer.SIMPLE, true);
-    result = new TestFoldingFilter(result);
-    return result;
-  }
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/complexPhrase/TestComplexPhraseQuery.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/complexPhrase/TestComplexPhraseQuery.java
deleted file mode 100644
index f3cd3f3..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/complexPhrase/TestComplexPhraseQuery.java
+++ /dev/null
@@ -1,147 +0,0 @@
-package org.apache.lucene.queryParser.complexPhrase;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.HashSet;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.queryparser.classic.QueryParser;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-public class TestComplexPhraseQuery extends LuceneTestCase {
-  Directory rd;
-  Analyzer analyzer = new MockAnalyzer(random);
-
-  DocData docsContent[] = { new DocData("john smith", "1"),
-      new DocData("johathon smith", "2"),
-      new DocData("john percival smith", "3"),
-      new DocData("jackson waits tom", "4") };
-
-  private IndexSearcher searcher;
-
-  String defaultFieldName = "name";
-
-  public void testComplexPhrases() throws Exception {
-    checkMatches("\"john smith\"", "1"); // Simple multi-term still works
-    checkMatches("\"j*   smyth~\"", "1,2"); // wildcards and fuzzies are OK in
-    // phrases
-    checkMatches("\"(jo* -john)  smith\"", "2"); // boolean logic works
-    checkMatches("\"jo*  smith\"~2", "1,2,3"); // position logic works.
-    checkMatches("\"jo* [sma TO smZ]\" ", "1,2"); // range queries supported
-    checkMatches("\"john\"", "1,3"); // Simple single-term still works
-    checkMatches("\"(john OR johathon)  smith\"", "1,2"); // boolean logic with
-    // brackets works.
-    checkMatches("\"(jo* -john) smyth~\"", "2"); // boolean logic with
-    // brackets works.
-
-    // checkMatches("\"john -percival\"", "1"); // not logic doesn't work
-    // currently :(.
-
-    checkMatches("\"john  nosuchword*\"", ""); // phrases with clauses producing
-    // empty sets
-
-    checkBadQuery("\"jo*  id:1 smith\""); // mixing fields in a phrase is bad
-    checkBadQuery("\"jo* \"smith\" \""); // phrases inside phrases is bad
-  }
-
-  private void checkBadQuery(String qString) {
-    QueryParser qp = new ComplexPhraseQueryParser(TEST_VERSION_CURRENT, defaultFieldName, analyzer);
-    Throwable expected = null;
-    try {
-      qp.parse(qString);
-    } catch (Throwable e) {
-      expected = e;
-    }
-    assertNotNull("Expected parse error in " + qString, expected);
-
-  }
-
-  private void checkMatches(String qString, String expectedVals)
-      throws Exception {
-    QueryParser qp = new ComplexPhraseQueryParser(TEST_VERSION_CURRENT, defaultFieldName, analyzer);
-    qp.setFuzzyPrefixLength(1); // usually a good idea
-
-    Query q = qp.parse(qString);
-
-    HashSet<String> expecteds = new HashSet<String>();
-    String[] vals = expectedVals.split(",");
-    for (int i = 0; i < vals.length; i++) {
-      if (vals[i].length() > 0)
-        expecteds.add(vals[i]);
-    }
-
-    TopDocs td = searcher.search(q, 10);
-    ScoreDoc[] sd = td.scoreDocs;
-    for (int i = 0; i < sd.length; i++) {
-      Document doc = searcher.doc(sd[i].doc);
-      String id = doc.get("id");
-      assertTrue(qString + "matched doc#" + id + " not expected", expecteds
-          .contains(id));
-      expecteds.remove(id);
-    }
-
-    assertEquals(qString + " missing some matches ", 0, expecteds.size());
-
-  }
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    rd = newDirectory();
-    IndexWriter w = new IndexWriter(rd, newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer));
-    for (int i = 0; i < docsContent.length; i++) {
-      Document doc = new Document();
-      doc.add(newField("name", docsContent[i].name, Field.Store.YES,
-          Field.Index.ANALYZED));
-      doc.add(newField("id", docsContent[i].id, Field.Store.YES,
-          Field.Index.ANALYZED));
-      w.addDocument(doc);
-    }
-    w.close();
-    searcher = new IndexSearcher(rd, true);
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    searcher.close();
-    rd.close();
-    super.tearDown();
-  }
-
-  static class DocData {
-    String name;
-
-    String id;
-
-    public DocData(String name, String id) {
-      super();
-      this.name = name;
-      this.id = id;
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/ExtensionStub.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/ExtensionStub.java
deleted file mode 100644
index 59f1722..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/ExtensionStub.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-class ExtensionStub extends ParserExtension {
-
-  @Override
-  public Query parse(ExtensionQuery components) throws ParseException {
-    return new TermQuery(new Term(components.getField(), components
-        .getRawQueryString()));
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java
deleted file mode 100644
index 7aedc93..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.queryparser.classic.ParseException;
-import org.apache.lucene.queryparser.classic.QueryParser;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * Testcase for the class {@link ExtendableQueryParser}
- */
-public class TestExtendableQueryParser extends LuceneTestCase {
-  private static char[] DELIMITERS = new char[] {
-      Extensions.DEFAULT_EXTENSION_FIELD_DELIMITER, '-', '|' };
-
-  public QueryParser getParser(Analyzer a, Extensions extensions)
-      throws Exception {
-    if (a == null)
-      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
-    QueryParser qp = extensions == null ? new ExtendableQueryParser(
-        TEST_VERSION_CURRENT, "field", a) : new ExtendableQueryParser(
-        TEST_VERSION_CURRENT, "field", a, extensions);
-    qp.setDefaultOperator(QueryParser.OR_OPERATOR);
-    return qp;
-  }
-
-  public void testUnescapedExtDelimiter() throws Exception {
-    Extensions ext = newExtensions(':');
-    ext.add("testExt", new ExtensionStub());
-    ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null, ext);
-    try {
-      parser.parse("aField:testExt:\"foo \\& bar\"");
-      fail("extension field delimiter is not escaped");
-    } catch (ParseException e) {
-    }
-  }
-
-  public void testExtFieldUnqoted() throws Exception {
-    for (int i = 0; i < DELIMITERS.length; i++) {
-      Extensions ext = newExtensions(DELIMITERS[i]);
-      ext.add("testExt", new ExtensionStub());
-      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
-          ext);
-      String field = ext.buildExtensionField("testExt", "aField");
-      Query query = parser.parse(String.format("%s:foo bar", field));
-      assertTrue("expected instance of BooleanQuery but was "
-          + query.getClass(), query instanceof BooleanQuery);
-      BooleanQuery bquery = (BooleanQuery) query;
-      BooleanClause[] clauses = bquery.getClauses();
-      assertEquals(2, clauses.length);
-      BooleanClause booleanClause = clauses[0];
-      query = booleanClause.getQuery();
-      assertTrue("expected instance of TermQuery but was " + query.getClass(),
-          query instanceof TermQuery);
-      TermQuery tquery = (TermQuery) query;
-      assertEquals("aField", tquery.getTerm()
-          .field());
-      assertEquals("foo", tquery.getTerm().text());
-
-      booleanClause = clauses[1];
-      query = booleanClause.getQuery();
-      assertTrue("expected instance of TermQuery but was " + query.getClass(),
-          query instanceof TermQuery);
-      tquery = (TermQuery) query;
-      assertEquals("field", tquery.getTerm().field());
-      assertEquals("bar", tquery.getTerm().text());
-    }
-  }
-
-  public void testExtDefaultField() throws Exception {
-    for (int i = 0; i < DELIMITERS.length; i++) {
-      Extensions ext = newExtensions(DELIMITERS[i]);
-      ext.add("testExt", new ExtensionStub());
-      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
-          ext);
-      String field = ext.buildExtensionField("testExt");
-      Query parse = parser.parse(String.format("%s:\"foo \\& bar\"", field));
-      assertTrue("expected instance of TermQuery but was " + parse.getClass(),
-          parse instanceof TermQuery);
-      TermQuery tquery = (TermQuery) parse;
-      assertEquals("field", tquery.getTerm().field());
-      assertEquals("foo & bar", tquery.getTerm().text());
-    }
-  }
-
-  public Extensions newExtensions(char delimiter) {
-    return new Extensions(delimiter);
-  }
-
-  public void testExtField() throws Exception {
-    for (int i = 0; i < DELIMITERS.length; i++) {
-      Extensions ext = newExtensions(DELIMITERS[i]);
-      ext.add("testExt", new ExtensionStub());
-      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
-          ext);
-      String field = ext.buildExtensionField("testExt", "afield");
-      Query parse = parser.parse(String.format("%s:\"foo \\& bar\"", field));
-      assertTrue("expected instance of TermQuery but was " + parse.getClass(),
-          parse instanceof TermQuery);
-      TermQuery tquery = (TermQuery) parse;
-      assertEquals("afield", tquery.getTerm().field());
-      assertEquals("foo & bar", tquery.getTerm().text());
-    }
-  }
-
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtensions.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtensions.java
deleted file mode 100644
index 3e73cb4..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/ext/TestExtensions.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package org.apache.lucene.queryParser.ext;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.LuceneTestCase;
-
-/**
- * Testcase for the {@link Extensions} class
- */
-public class TestExtensions extends LuceneTestCase {
-
-  private Extensions ext;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    this.ext = new Extensions();
-  }
-
-  public void testBuildExtensionField() {
-    assertEquals("field\\:key", ext.buildExtensionField("key", "field"));
-    assertEquals("\\:key", ext.buildExtensionField("key"));
-
-    ext = new Extensions('.');
-    assertEquals("field.key", ext.buildExtensionField("key", "field"));
-    assertEquals(".key", ext.buildExtensionField("key"));
-  }
-
-  public void testSplitExtensionField() {
-    assertEquals("field\\:key", ext.buildExtensionField("key", "field"));
-    assertEquals("\\:key", ext.buildExtensionField("key"));
-
-    ext = new Extensions('.');
-    assertEquals("field.key", ext.buildExtensionField("key", "field"));
-    assertEquals(".key", ext.buildExtensionField("key"));
-  }
-
-  public void testAddGetExtension() {
-    ParserExtension extension = new ExtensionStub();
-    assertNull(ext.getExtension("foo"));
-    ext.add("foo", extension);
-    assertSame(extension, ext.getExtension("foo"));
-    ext.add("foo", null);
-    assertNull(ext.getExtension("foo"));
-  }
-
-  public void testGetExtDelimiter() {
-    assertEquals(Extensions.DEFAULT_EXTENSION_FIELD_DELIMITER, this.ext
-        .getExtensionFieldDelimiter());
-    ext = new Extensions('?');
-    assertEquals('?', this.ext.getExtensionFieldDelimiter());
-  }
-
-  public void testEscapeExtension() {
-    assertEquals("abc\\:\\?\\{\\}\\[\\]\\\\\\(\\)\\+\\-\\!\\~", ext
-        .escapeExtensionField("abc:?{}[]\\()+-!~"));
-    try {
-      ext.escapeExtensionField(null);
-      fail("should throw NPE - escape string is null");
-    } catch (NullPointerException e) {
-      // 
-    }
-  }
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/BooleanQueryTst.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/BooleanQueryTst.java
deleted file mode 100644
index bba9321..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/BooleanQueryTst.java
+++ /dev/null
@@ -1,134 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Collector;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.Query;
-
-import org.apache.lucene.queryParser.surround.parser.QueryParser;
-
-import org.junit.Assert;
-
-public class BooleanQueryTst {
-  String queryText;
-  final int[] expectedDocNrs;
-  SingleFieldTestDb dBase;
-  String fieldName;
-  Assert testCase;
-  BasicQueryFactory qf;
-  boolean verbose = true;
-
-  public BooleanQueryTst(
-      String queryText,
-      int[] expectedDocNrs,
-      SingleFieldTestDb dBase,
-      String fieldName,
-      Assert testCase,
-      BasicQueryFactory qf) {
-    this.queryText = queryText;
-    this.expectedDocNrs = expectedDocNrs;
-    this.dBase = dBase;
-    this.fieldName = fieldName;
-    this.testCase = testCase;
-    this.qf = qf;
-  }
-  
-  public void setVerbose(boolean verbose) {this.verbose = verbose;}
-
-  class TestCollector extends Collector { // FIXME: use check hits from Lucene tests
-    int totalMatched;
-    boolean[] encountered;
-    private Scorer scorer = null;
-    private int docBase = 0;
-
-    TestCollector() {
-      totalMatched = 0;
-      encountered = new boolean[expectedDocNrs.length];
-    }
-
-    @Override
-    public void setScorer(Scorer scorer) throws IOException {
-      this.scorer = scorer;
-    }
-
-    @Override
-    public boolean acceptsDocsOutOfOrder() {
-      return true;
-    }
-
-    @Override
-    public void setNextReader(AtomicReaderContext context) throws IOException {
-      docBase = context.docBase;
-    }
-    
-    @Override
-    public void collect(int docNr) throws IOException {
-      float score = scorer.score();
-      docNr += docBase;
-      /* System.out.println(docNr + " '" + dBase.getDocs()[docNr] + "': " + score); */
-      Assert.assertTrue(queryText + ": positive score", score > 0.0);
-      Assert.assertTrue(queryText + ": too many hits", totalMatched < expectedDocNrs.length);
-      int i;
-      for (i = 0; i < expectedDocNrs.length; i++) {
-        if ((! encountered[i]) && (expectedDocNrs[i] == docNr)) {
-          encountered[i] = true;
-          break;
-        }
-      }
-      if (i == expectedDocNrs.length) {
-        Assert.assertTrue(queryText + ": doc nr for hit not expected: " + docNr, false);
-      }
-      totalMatched++;
-    }
-
-    void checkNrHits() {
-      Assert.assertEquals(queryText + ": nr of hits", expectedDocNrs.length, totalMatched);
-    }
-  }
-
-  public void doTest() throws Exception {
-
-    if (verbose) {    
-        System.out.println("");
-        System.out.println("Query: " + queryText);
-    }
-    
-    SrndQuery lq = QueryParser.parse(queryText);
-    
-    /* if (verbose) System.out.println("Srnd: " + lq.toString()); */
-    
-    Query query = lq.makeLuceneQueryField(fieldName, qf);
-    /* if (verbose) System.out.println("Lucene: " + query.toString()); */
-
-    TestCollector tc = new TestCollector();
-    IndexSearcher searcher = new IndexSearcher(dBase.getDb(), true);
-    try {
-      searcher.search(query, tc);
-    } finally {
-      searcher.close();
-    }
-    tc.checkNrHits();
-  }
-}
-
-
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/ExceptionQueryTst.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/ExceptionQueryTst.java
deleted file mode 100644
index 2fa38ba..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/ExceptionQueryTst.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.surround.parser.ParseException;
-import org.apache.lucene.queryParser.surround.parser.QueryParser;
-
-
-public class ExceptionQueryTst {
-  private String queryText;
-  private boolean verbose;
-  
-  public ExceptionQueryTst(String queryText, boolean verbose) {
-    this.queryText = queryText;
-    this.verbose = verbose;
-  }
-
-  public void doTest(StringBuilder failQueries) {
-    boolean pass = false;
-    SrndQuery lq = null;
-    try {
-      lq = QueryParser.parse(queryText);
-      if (verbose) {
-        System.out.println("Query: " + queryText + "\nParsed as: " + lq.toString());
-      }
-    } catch (ParseException e) {
-      if (verbose) {
-        System.out.println("Parse exception for query:\n"
-                            + queryText + "\n"
-                            + e.getMessage());
-      }
-      pass = true;
-    }
-    if (! pass) {
-      failQueries.append(queryText);
-      failQueries.append("\nParsed as: ");
-      failQueries.append(lq.toString());
-      failQueries.append("\n");
-    }
-  }
-  
-  public static String getFailQueries(String[] exceptionQueries, boolean verbose) {
-    StringBuilder failQueries = new StringBuilder();
-    for (int i = 0; i < exceptionQueries.length; i++ ) {
-      new ExceptionQueryTst( exceptionQueries[i], verbose).doTest(failQueries);
-    }
-    return failQueries.toString();
-  }
-}
-
-
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/SingleFieldTestDb.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/SingleFieldTestDb.java
deleted file mode 100644
index dffb925..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/SingleFieldTestDb.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Random;
-
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.util.Version;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-
-public class SingleFieldTestDb {
-  private Directory db;
-  private String[] docs;
-  private String fieldName;
-  
-  public SingleFieldTestDb(Random random, String[] documents, String fName) {
-    try {
-      db = new MockDirectoryWrapper(random, new RAMDirectory());
-      docs = documents;
-      fieldName = fName;
-      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(
-          Version.LUCENE_CURRENT,
-          new MockAnalyzer(random)));
-      for (int j = 0; j < docs.length; j++) {
-        Document d = new Document();
-        d.add(new Field(fieldName, docs[j], Field.Store.NO, Field.Index.ANALYZED));
-        writer.addDocument(d);
-      }
-      writer.close();
-    } catch (java.io.IOException ioe) {
-      throw new Error(ioe);
-    }
-  }
-  
-  Directory getDb() {return db;}
-  String[] getDocs() {return docs;}
-  String getFieldname() {return fieldName;}
-}
-
-
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test01Exceptions.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test01Exceptions.java
deleted file mode 100644
index 493658c..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test01Exceptions.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
-import org.apache.lucene.util.LuceneTestCase;
-
-public class Test01Exceptions extends LuceneTestCase {
-  /** Main for running test case by itself. */
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test01Exceptions.class));
-  }
-
-  boolean verbose = false; /* to show actual parsing error messages */
-  final String fieldName = "bi";
-
-  String[] exceptionQueries = {
-    "*",
-    "a*",
-    "ab*",
-    "?",
-    "a?",
-    "ab?",
-    "a???b",
-    "a?",
-    "a*b?",
-    "word1 word2",
-    "word2 AND",
-    "word1 OR",
-    "AND(word2)",
-    "AND(word2,)",
-    "AND(word2,word1,)",
-    "OR(word2)",
-    "OR(word2 ,",
-    "OR(word2 , word1 ,)",
-    "xx NOT",
-    "xx (a AND b)",
-    "(a AND b",
-    "a OR b)",
-    "or(word2+ not ord+, and xyz,def)",
-    ""
-  };
-
-  public void test01Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
-    if (m.length() > 0) {
-      fail("No ParseException for:\n" + m);
-    }
-  }
-}
-
-
-
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test02Boolean.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test02Boolean.java
deleted file mode 100644
index c179d94..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test02Boolean.java
+++ /dev/null
@@ -1,122 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
-import org.apache.lucene.util.LuceneTestCase;
-
-public class Test02Boolean extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test02Boolean.class));
-  }
-
-  final String fieldName = "bi";
-  boolean verbose = false;
-  int maxBasicQueries = 16;
-
-  String[] docs1 = {
-    "word1 word2 word3",
-    "word4 word5",
-    "ord1 ord2 ord3",
-    "orda1 orda2 orda3 word2 worda3",
-    "a c e a b c"
-  };
-
-  SingleFieldTestDb db1 = new SingleFieldTestDb(random, docs1, fieldName);
-
-  public void normalTest1(String query, int[] expdnrs) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db1, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
-  }
-
-  public void test02Terms01() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "word1", expdnrs);
-  }
-  public void test02Terms02() throws Exception {
-    int[] expdnrs = {0, 1, 3}; normalTest1( "word*", expdnrs);
-  }
-  public void test02Terms03() throws Exception {
-    int[] expdnrs = {2}; normalTest1( "ord2", expdnrs);
-  }
-  public void test02Terms04() throws Exception {
-    int[] expdnrs = {}; normalTest1( "kxork*", expdnrs);
-  }
-  public void test02Terms05() throws Exception {
-    int[] expdnrs = {0, 1, 3}; normalTest1( "wor*", expdnrs);
-  }
-  public void test02Terms06() throws Exception {
-    int[] expdnrs = {}; normalTest1( "ab", expdnrs);
-  }
-  
-  public void test02Terms10() throws Exception {
-    int[] expdnrs = {}; normalTest1( "abc?", expdnrs);
-  }
-  public void test02Terms13() throws Exception {
-    int[] expdnrs = {0,1,3}; normalTest1( "word?", expdnrs);
-  }
-  public void test02Terms14() throws Exception {
-    int[] expdnrs = {0,1,3}; normalTest1( "w?rd?", expdnrs);
-  }
-  public void test02Terms20() throws Exception {
-    int[] expdnrs = {0,1,3}; normalTest1( "w*rd?", expdnrs);
-  }
-  public void test02Terms21() throws Exception {
-    int[] expdnrs = {3}; normalTest1( "w*rd??", expdnrs);
-  }
-  public void test02Terms22() throws Exception {
-    int[] expdnrs = {3}; normalTest1( "w*?da?", expdnrs);
-  }
-  public void test02Terms23() throws Exception {
-    int[] expdnrs = {}; normalTest1( "w?da?", expdnrs);
-  }
-  
-  public void test03And01() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "word1 AND word2", expdnrs);
-  }
-  public void test03And02() throws Exception {
-    int[] expdnrs = {3}; normalTest1( "word* and ord*", expdnrs);
-  }
-  public void test03And03() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "and(word1,word2)", expdnrs);
-  }
-  public void test04Or01() throws Exception {
-    int[] expdnrs = {0, 3}; normalTest1( "word1 or word2", expdnrs);
-  }
-  public void test04Or02() throws Exception {
-    int[] expdnrs = {0, 1, 2, 3}; normalTest1( "word* OR ord*", expdnrs);
-  }
-  public void test04Or03() throws Exception {
-    int[] expdnrs = {0, 3}; normalTest1( "OR (word1, word2)", expdnrs);
-  }
-  public void test05Not01() throws Exception {
-    int[] expdnrs = {3}; normalTest1( "word2 NOT word1", expdnrs);
-  }
-  public void test05Not02() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "word2* not ord*", expdnrs);
-  }
-  public void test06AndOr01() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "(word1 or ab)and or(word2,xyz, defg)", expdnrs);
-  }
-  public void test07AndOrNot02() throws Exception {
-    int[] expdnrs = {0}; normalTest1( "or( word2* not ord*, and(xyz,def))", expdnrs);
-  }
-}
diff --git a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test03Distance.java b/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test03Distance.java
deleted file mode 100644
index f230bb5..0000000
--- a/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/surround/query/Test03Distance.java
+++ /dev/null
@@ -1,243 +0,0 @@
-package org.apache.lucene.queryParser.surround.query;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
-import org.apache.lucene.util.LuceneTestCase;
-
-public class Test03Distance extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test03Distance.class));
-  }
-  boolean verbose = false;
-  int maxBasicQueries = 16;
-  
-  String [] exceptionQueries = {
-    "(aa and bb) w cc",
-    "(aa or bb) w (cc and dd)",
-    "(aa opt bb) w cc",
-    "(aa not bb) w cc",
-    "(aa or bb) w (bi:cc)",
-    "(aa or bb) w bi:cc",
-    "(aa or bi:bb) w cc",
-    "(aa or (bi:bb)) w cc",
-    "(aa or (bb and dd)) w cc"
-  };
-  
-  public void test00Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
-    if (m.length() > 0) {
-      fail("No ParseException for:\n" + m);
-    }
-  }
-
-  final String fieldName = "bi";
-
-  String[] docs1 = {
-    "word1 word2 word3",
-    "word4 word5",
-    "ord1 ord2 ord3",
-    "orda1 orda2 orda3 word2 worda3",
-    "a c e a b c"
-  };
-
-  SingleFieldTestDb db1 = new SingleFieldTestDb(random, docs1, fieldName);
-
-  private void distanceTst(String query, int[] expdnrs, SingleFieldTestDb db) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
-  }
-
-  public void distanceTest1(String query, int[] expdnrs) throws Exception {
-    distanceTst(query, expdnrs, db1);
-  }
-  
-  public void test0W01() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1 w word2", expdnrs);
-  }
-  public void test0N01() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1 n word2", expdnrs);
-  }
-  public void test0N01r() throws Exception { /* r reverse */
-    int[] expdnrs = {0}; distanceTest1( "word2 n word1", expdnrs);
-  }
-  
-  public void test0W02() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "word2 w word1", expdnrs);
-  }
-  
-  public void test0W03() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "word2 2W word1", expdnrs);
-  }
-  public void test0N03() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word2 2N word1", expdnrs);
-  }
-  public void test0N03r() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1 2N word2", expdnrs);
-  }
-  
-  public void test0W04() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "word2 3w word1", expdnrs);
-  }
-
-  public void test0N04() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word2 3n word1", expdnrs);
-  }
-  public void test0N04r() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1 3n word2", expdnrs);
-  }
-
-  public void test0W05() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "orda1 w orda3", expdnrs);
-  }
-  public void test0W06() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "orda1 2w orda3", expdnrs);
-  }
-  
-  public void test1Wtrunc01() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1* w word2", expdnrs);
-  }
-  public void test1Wtrunc02() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word* w word2", expdnrs);
-  }
-  public void test1Wtrunc02r() throws Exception {
-    int[] expdnrs = {0,3}; distanceTest1( "word2 w word*", expdnrs);
-  }
-  public void test1Ntrunc02() throws Exception {
-    int[] expdnrs = {0,3}; distanceTest1( "word* n word2", expdnrs);
-  }
-  public void test1Ntrunc02r() throws Exception {
-    int[] expdnrs = {0,3}; distanceTest1( "word2 n word*", expdnrs);
-  }
-
-  public void test1Wtrunc03() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1* w word2*", expdnrs);
-  }
-  public void test1Ntrunc03() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word1* N word2*", expdnrs);
-  }
-  
-  public void test1Wtrunc04() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "kxork* w kxor*", expdnrs);
-  }
-  public void test1Ntrunc04() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "kxork* 99n kxor*", expdnrs);
-  }
-
-  public void test1Wtrunc05() throws Exception {
-    int[] expdnrs = {}; distanceTest1( "word2* 2W word1*", expdnrs);
-  }
-  public void test1Ntrunc05() throws Exception {
-    int[] expdnrs = {0}; distanceTest1( "word2* 2N word1*", expdnrs);
-  }
-
-  public void test1Wtrunc06() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "ord* W word*", expdnrs);
-  }
-  public void test1Ntrunc06() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "ord* N word*", expdnrs);
-  }
-  public void test1Ntrunc06r() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "word* N ord*", expdnrs);
-  }
-  
-  public void test1Wtrunc07() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) W word*", expdnrs);
-  }
-  public void test1Wtrunc08() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) W (word2 OR worda3)", expdnrs);
-  }
-  public void test1Wtrunc09() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2W (word2 OR worda3)", expdnrs);
-  }
-  public void test1Ntrunc09() throws Exception {
-    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2N (word2 OR worda3)", expdnrs);
-  }
-
-  String[] docs2 = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3",
-    ""
-  };
-
-  SingleFieldTestDb db2 = new SingleFieldTestDb(random, docs2, fieldName);
-  
-  public void distanceTest2(String query, int[] expdnrs) throws Exception {
-    distanceTst(query, expdnrs, db2);
-  }
-  
-  public void test2Wprefix01() throws Exception {
-    int[] expdnrs = {0}; distanceTest2( "W (w1, w2, w3)", expdnrs);
-  }
-  public void test2Nprefix01a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w1, w2, w3)", expdnrs);
-  }
-  public void test2Nprefix01b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w3, w1, w2)", expdnrs);
-  }
-  
-  public void test2Wprefix02() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2W(w1,w2,w3)", expdnrs);
-  }
-
-  public void test2Nprefix02a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
-  }
-  public void test2Nprefix02b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
-  }
-
-  public void test2Wnested01() throws Exception {
-    int[] expdnrs = {0}; distanceTest2( "w1 W w2 W w3", expdnrs);
-  }
-  public void test2Nnested01() throws Exception {
-    int[] expdnrs = {0}; distanceTest2( "w1 N w2 N w3", expdnrs);
-  }
-  
-  public void test2Wnested02() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "w1 2W w2 2W w3", expdnrs);
-  }
-  public void test2Nnested02() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "w1 2N w2 2N w3", expdnrs);
-  }
-  
-  String[] docs3 = {
-    "low pressure temperature inversion and rain",
-    "when the temperature has a negative height above a depression no precipitation gradient is expected",
-    "when the temperature has a negative height gradient above a depression no precipitation is expected",
-    ""
-  };
-
-  SingleFieldTestDb db3 = new SingleFieldTestDb(random, docs3, fieldName);
-
-  public void distanceTest3(String query, int[] expdnrs) throws Exception {
-    distanceTst(query, expdnrs, db3);
-  }
-
-  public void test3Example01() throws Exception {
-    int[] expdnrs = {0,2}; // query does not match doc 1 because "gradient" is in wrong place there.
-    distanceTest3("50n((low w pressure*) or depression*,"
-                   + "5n(temperat*, (invers* or (negativ* 3n gradient*))),"
-                   + "rain* or precipitat*)",
-                   expdnrs);
-  }
-}
diff --git a/modules/queryparser/build.xml b/modules/queryparser/build.xml
index 7bdec27..ff34f9c 100644
--- a/modules/queryparser/build.xml
+++ b/modules/queryparser/build.xml
@@ -33,10 +33,13 @@
       <fileset dir="src/java/org/apache/lucene/queryparser/classic" includes="*.java">
         <containsregexp expression="Generated.*By.*JavaCC"/>
       </fileset>
+      <fileset dir="src/java/org/apache/lucene/queryparser/surround/parser" includes="*.java">
+        <containsregexp expression="Generated.*By.*JavaCC"/>
+      </fileset>
     </delete>
   </target>
 
-  <target name="javacc" depends="init,javacc-check,clean-javacc,javacc-QueryParser"/>
+  <target name="javacc" depends="init,javacc-check,clean-javacc,javacc-QueryParser,javacc-surround"/>
 
   <target name="javacc-QueryParser" depends="init,javacc-check" if="javacc.present">
     <sequential>
@@ -56,4 +59,10 @@
     </sequential>
   </target>
 
+  <target name="javacc-surround" depends="javacc-check" description="generate surround query parser from jj (requires javacc 4.1">
+  	<invoke-javacc target="src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj"
+                   outputDir="src/java/org/apache/lucene/queryparser/surround/parser"
+    />
+  </target>
+
 </project>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java
new file mode 100644
index 0000000..bacc296
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/AnalyzingQueryParser.java
@@ -0,0 +1,349 @@
+package org.apache.lucene.queryparser.analyzing;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.Version;
+
+/**
+ * Overrides Lucene's default QueryParser so that Fuzzy-, Prefix-, Range-, and WildcardQuerys
+ * are also passed through the given analyzer, but wild card characters (like <code>*</code>) 
+ * don't get removed from the search terms.
+ * 
+ * <p><b>Warning:</b> This class should only be used with analyzers that do not use stopwords
+ * or that add tokens. Also, several stemming analyzers are inappropriate: for example, GermanAnalyzer 
+ * will turn <code>H&auml;user</code> into <code>hau</code>, but <code>H?user</code> will 
+ * become <code>h?user</code> when using this parser and thus no match would be found (i.e.
+ * using this parser will be no improvement over QueryParser in such cases). 
+ *
+ */
+public class AnalyzingQueryParser extends org.apache.lucene.queryparser.classic.QueryParser {
+
+  /**
+   * Constructs a query parser.
+   * @param field    the default field for query terms.
+   * @param analyzer used to find terms in the query text.
+   */
+  public AnalyzingQueryParser(Version matchVersion, String field, Analyzer analyzer) {
+    super(matchVersion, field, analyzer);
+  }
+
+  /**
+   * Called when parser
+   * parses an input term token that contains one or more wildcard
+   * characters (like <code>*</code>), but is not a prefix term token (one
+   * that has just a single * character at the end).
+   * <p>
+   * Example: will be called for <code>H?user</code> or for <code>H*user</code> 
+   * but not for <code>*user</code>.
+   * <p>
+   * Depending on analyzer and settings, a wildcard term may (most probably will)
+   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
+   * <p>
+   * Overrides super class, by passing terms through analyzer.
+   *
+   * @param  field   Name of the field query will use.
+   * @param  termStr Term token that contains one or more wild card
+   *                 characters (? or *), but is not simple prefix term
+   *
+   * @return Resulting {@link Query} built for the term
+   * @throws ParseException
+   */
+  @Override
+  protected Query getWildcardQuery(String field, String termStr) throws ParseException {
+    List<String> tlist = new ArrayList<String>();
+    List<String> wlist = new ArrayList<String>();
+    /* somewhat a hack: find/store wildcard chars
+     * in order to put them back after analyzing */
+    boolean isWithinToken = (!termStr.startsWith("?") && !termStr.startsWith("*"));
+    StringBuilder tmpBuffer = new StringBuilder();
+    char[] chars = termStr.toCharArray();
+    for (int i = 0; i < termStr.length(); i++) {
+      if (chars[i] == '?' || chars[i] == '*') {
+        if (isWithinToken) {
+          tlist.add(tmpBuffer.toString());
+          tmpBuffer.setLength(0);
+        }
+        isWithinToken = false;
+      } else {
+        if (!isWithinToken) {
+          wlist.add(tmpBuffer.toString());
+          tmpBuffer.setLength(0);
+        }
+        isWithinToken = true;
+      }
+      tmpBuffer.append(chars[i]);
+    }
+    if (isWithinToken) {
+      tlist.add(tmpBuffer.toString());
+    } else {
+      wlist.add(tmpBuffer.toString());
+    }
+
+    // get Analyzer from superclass and tokenize the term
+    TokenStream source;
+    
+    int countTokens = 0;
+    try {
+      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
+      source.reset();
+    } catch (IOException e1) {
+      throw new RuntimeException(e1);
+    }
+    CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
+    while (true) {
+      try {
+        if (!source.incrementToken()) break;
+      } catch (IOException e) {
+        break;
+      }
+      String term = termAtt.toString();
+      if (!"".equals(term)) {
+        try {
+          tlist.set(countTokens++, term);
+        } catch (IndexOutOfBoundsException ioobe) {
+          countTokens = -1;
+        }
+      }
+    }
+    try {
+      source.end();
+      source.close();
+    } catch (IOException e) {
+      // ignore
+    }
+
+    if (countTokens != tlist.size()) {
+      /* this means that the analyzer used either added or consumed 
+       * (common for a stemmer) tokens, and we can't build a WildcardQuery */
+      throw new ParseException("Cannot build WildcardQuery with analyzer "
+          + getAnalyzer().getClass() + " - tokens added or lost");
+    }
+
+    if (tlist.size() == 0) {
+      return null;
+    } else if (tlist.size() == 1) {
+      if (wlist != null && wlist.size() == 1) {
+        /* if wlist contains one wildcard, it must be at the end, because:
+         * 1) wildcards are not allowed in 1st position of a term by QueryParser
+         * 2) if wildcard was *not* in end, there would be *two* or more tokens */
+        return super.getWildcardQuery(field, tlist.get(0)
+            + wlist.get(0).toString());
+      } else {
+        /* we should never get here! if so, this method was called
+         * with a termStr containing no wildcard ... */
+        throw new IllegalArgumentException("getWildcardQuery called without wildcard");
+      }
+    } else {
+      /* the term was tokenized, let's rebuild to one token
+       * with wildcards put back in postion */
+      StringBuilder sb = new StringBuilder();
+      for (int i = 0; i < tlist.size(); i++) {
+        sb.append( tlist.get(i));
+        if (wlist != null && wlist.size() > i) {
+          sb.append(wlist.get(i));
+        }
+      }
+      return super.getWildcardQuery(field, sb.toString());
+    }
+  }
+
+  /**
+   * Called when parser parses an input term
+   * token that uses prefix notation; that is, contains a single '*' wildcard
+   * character as its last character. Since this is a special case
+   * of generic wildcard term, and such a query can be optimized easily,
+   * this usually results in a different query object.
+   * <p>
+   * Depending on analyzer and settings, a prefix term may (most probably will)
+   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
+   * <p>
+   * Overrides super class, by passing terms through analyzer.
+   *
+   * @param  field   Name of the field query will use.
+   * @param  termStr Term token to use for building term for the query
+   *                 (<b>without</b> trailing '*' character!)
+   *
+   * @return Resulting {@link Query} built for the term
+   * @throws ParseException
+   */
+  @Override
+  protected Query getPrefixQuery(String field, String termStr) throws ParseException {
+    // get Analyzer from superclass and tokenize the term
+    TokenStream source;
+    List<String> tlist = new ArrayList<String>();
+    try {
+      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
+      source.reset();
+    } catch (IOException e1) {
+      throw new RuntimeException(e1);
+    }
+    CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
+    while (true) {
+      try {
+        if (!source.incrementToken()) break;
+      } catch (IOException e) {
+        break;
+      }
+      tlist.add(termAtt.toString());
+    }
+
+    try {
+      source.end();
+      source.close();
+    } catch (IOException e) {
+      // ignore
+    }
+
+    if (tlist.size() == 1) {
+      return super.getPrefixQuery(field, tlist.get(0));
+    } else {
+      /* this means that the analyzer used either added or consumed
+       * (common for a stemmer) tokens, and we can't build a PrefixQuery */
+      throw new ParseException("Cannot build PrefixQuery with analyzer "
+          + getAnalyzer().getClass()
+          + (tlist.size() > 1 ? " - token(s) added" : " - token consumed"));
+    }
+  }
+
+  /**
+   * Called when parser parses an input term token that has the fuzzy suffix (~) appended.
+   * <p>
+   * Depending on analyzer and settings, a fuzzy term may (most probably will)
+   * be lower-cased automatically. It <b>will</b> go through the default Analyzer.
+   * <p>
+   * Overrides super class, by passing terms through analyzer.
+   *
+   * @param field Name of the field query will use.
+   * @param termStr Term token to use for building term for the query
+   *
+   * @return Resulting {@link Query} built for the term
+   * @exception ParseException
+   */
+  @Override
+  protected Query getFuzzyQuery(String field, String termStr, float minSimilarity)
+      throws ParseException {
+    // get Analyzer from superclass and tokenize the term
+    TokenStream source = null;
+    String nextToken = null;
+    boolean multipleTokens = false;
+    
+    try {
+      source = getAnalyzer().reusableTokenStream(field, new StringReader(termStr));
+      CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class);
+      source.reset();
+      if (source.incrementToken()) {
+        nextToken = termAtt.toString();
+      }
+      multipleTokens = source.incrementToken();
+    } catch (IOException e) {
+      nextToken = null;
+    }
+
+    try {
+      source.end();
+      source.close();
+    } catch (IOException e) {
+      // ignore
+    }
+
+    if (multipleTokens) {
+      throw new ParseException("Cannot build FuzzyQuery with analyzer " + getAnalyzer().getClass()
+          + " - tokens were added");
+    }
+
+    return (nextToken == null) ? null : super.getFuzzyQuery(field, nextToken, minSimilarity);
+  }
+
+  /**
+   * Overrides super class, by passing terms through analyzer.
+   * @exception ParseException
+   */
+  @Override
+  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive)
+      throws ParseException {
+    // get Analyzer from superclass and tokenize the terms
+    TokenStream source = null;
+    CharTermAttribute termAtt = null;
+    boolean multipleTokens = false;
+
+    if (part1 != null) {
+      // part1
+      try {
+        source = getAnalyzer().reusableTokenStream(field, new StringReader(part1));
+        termAtt = source.addAttribute(CharTermAttribute.class);
+        source.reset();
+        multipleTokens = false;
+
+
+        if (source.incrementToken()) {
+          part1 = termAtt.toString();
+        }
+        multipleTokens = source.incrementToken();
+      } catch (IOException e) {
+        // ignore
+      }
+      try {
+        source.end();
+        source.close();
+      } catch (IOException e) {
+        // ignore
+      }
+      if (multipleTokens) {
+        throw new ParseException("Cannot build RangeQuery with analyzer " + getAnalyzer().getClass()
+            + " - tokens were added to part1");
+      }
+    }
+
+    if (part2 != null) {
+      try {
+        // part2
+        source = getAnalyzer().reusableTokenStream(field, new StringReader(part2));
+        termAtt = source.addAttribute(CharTermAttribute.class);
+        source.reset();
+        if (source.incrementToken()) {
+          part2 = termAtt.toString();
+        }
+        multipleTokens = source.incrementToken();
+      } catch (IOException e) {
+        // ignore
+      }
+      try {
+        source.end();
+        source.close();
+      } catch (IOException e) {
+        // ignore
+      }
+      if (multipleTokens) {
+        throw new ParseException("Cannot build RangeQuery with analyzer " + getAnalyzer().getClass()
+            + " - tokens were added to part2");
+      }
+    }
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/package.html
new file mode 100644
index 0000000..2785a6b
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/analyzing/package.html
@@ -0,0 +1,22 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<body>
+QueryParser that passes Fuzzy-, Prefix-, Range-, and WildcardQuerys through the given analyzer.
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
new file mode 100644
index 0000000..f7611c7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
@@ -0,0 +1,401 @@
+package org.apache.lucene.queryparser.complexPhrase;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanNotQuery;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.util.Version;
+
+/**
+ * QueryParser which permits complex phrase query syntax eg "(john jon
+ * jonathan~) peters*".
+ * <p>
+ * Performs potentially multiple passes over Query text to parse any nested
+ * logic in PhraseQueries. - First pass takes any PhraseQuery content between
+ * quotes and stores for subsequent pass. All other query content is parsed as
+ * normal - Second pass parses any stored PhraseQuery content, checking all
+ * embedded clauses are referring to the same field and therefore can be
+ * rewritten as Span queries. All PhraseQuery clauses are expressed as
+ * ComplexPhraseQuery objects
+ * </p>
+ * <p>
+ * This could arguably be done in one pass using a new QueryParser but here I am
+ * working within the constraints of the existing parser as a base class. This
+ * currently simply feeds all phrase content through an analyzer to select
+ * phrase terms - any "special" syntax such as * ~ * etc are not given special
+ * status
+ * </p>
+ * 
+ */
+public class ComplexPhraseQueryParser extends QueryParser {
+  private ArrayList<ComplexPhraseQuery> complexPhrases = null;
+
+  private boolean isPass2ResolvingPhrases;
+
+  private ComplexPhraseQuery currentPhraseQuery = null;
+
+  public ComplexPhraseQueryParser(Version matchVersion, String f, Analyzer a) {
+    super(matchVersion, f, a);
+  }
+
+  @Override
+  protected Query getFieldQuery(String field, String queryText, int slop) {
+    ComplexPhraseQuery cpq = new ComplexPhraseQuery(field, queryText, slop);
+    complexPhrases.add(cpq); // add to list of phrases to be parsed once
+    // we
+    // are through with this pass
+    return cpq;
+  }
+
+  @Override
+  public Query parse(String query) throws ParseException {
+    if (isPass2ResolvingPhrases) {
+      MultiTermQuery.RewriteMethod oldMethod = getMultiTermRewriteMethod();
+      try {
+        // Temporarily force BooleanQuery rewrite so that Parser will
+        // generate visible
+        // collection of terms which we can convert into SpanQueries.
+        // ConstantScoreRewrite mode produces an
+        // opaque ConstantScoreQuery object which cannot be interrogated for
+        // terms in the same way a BooleanQuery can.
+        // QueryParser is not guaranteed threadsafe anyway so this temporary
+        // state change should not
+        // present an issue
+        setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
+        return super.parse(query);
+      } finally {
+        setMultiTermRewriteMethod(oldMethod);
+      }
+    }
+
+    // First pass - parse the top-level query recording any PhraseQuerys
+    // which will need to be resolved
+    complexPhrases = new ArrayList<ComplexPhraseQuery>();
+    Query q = super.parse(query);
+
+    // Perform second pass, using this QueryParser to parse any nested
+    // PhraseQueries with different
+    // set of syntax restrictions (i.e. all fields must be same)
+    isPass2ResolvingPhrases = true;
+    try {
+      for (Iterator<ComplexPhraseQuery> iterator = complexPhrases.iterator(); iterator.hasNext();) {
+        currentPhraseQuery = iterator.next();
+        // in each phrase, now parse the contents between quotes as a
+        // separate parse operation
+        currentPhraseQuery.parsePhraseElements(this);
+      }
+    } finally {
+      isPass2ResolvingPhrases = false;
+    }
+    return q;
+  }
+
+  // There is No "getTermQuery throws ParseException" method to override so
+  // unfortunately need
+  // to throw a runtime exception here if a term for another field is embedded
+  // in phrase query
+  @Override
+  protected Query newTermQuery(Term term) {
+    if (isPass2ResolvingPhrases) {
+      try {
+        checkPhraseClauseIsForSameField(term.field());
+      } catch (ParseException pe) {
+        throw new RuntimeException("Error parsing complex phrase", pe);
+      }
+    }
+    return super.newTermQuery(term);
+  }
+
+  // Helper method used to report on any clauses that appear in query syntax
+  private void checkPhraseClauseIsForSameField(String field)
+      throws ParseException {
+    if (!field.equals(currentPhraseQuery.field)) {
+      throw new ParseException("Cannot have clause for field \"" + field
+          + "\" nested in phrase " + " for field \"" + currentPhraseQuery.field
+          + "\"");
+    }
+  }
+
+  @Override
+  protected Query getWildcardQuery(String field, String termStr)
+      throws ParseException {
+    if (isPass2ResolvingPhrases) {
+      checkPhraseClauseIsForSameField(field);
+    }
+    return super.getWildcardQuery(field, termStr);
+  }
+
+  @Override
+  protected Query getRangeQuery(String field, String part1, String part2,
+      boolean startInclusive, boolean endInclusive) throws ParseException {
+    if (isPass2ResolvingPhrases) {
+      checkPhraseClauseIsForSameField(field);
+    }
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
+  }
+
+  @Override
+  protected Query newRangeQuery(String field, String part1, String part2,
+      boolean startInclusive, boolean endInclusive) {
+    if (isPass2ResolvingPhrases) {
+      // Must use old-style RangeQuery in order to produce a BooleanQuery
+      // that can be turned into SpanOr clause
+      TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, part1, part2, startInclusive, endInclusive);
+      rangeQuery.setRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
+      return rangeQuery;
+    }
+    return super.newRangeQuery(field, part1, part2, startInclusive, endInclusive);
+  }
+
+  @Override
+  protected Query getFuzzyQuery(String field, String termStr,
+      float minSimilarity) throws ParseException {
+    if (isPass2ResolvingPhrases) {
+      checkPhraseClauseIsForSameField(field);
+    }
+    return super.getFuzzyQuery(field, termStr, minSimilarity);
+  }
+
+  /*
+   * Used to handle the query content in between quotes and produced Span-based
+   * interpretations of the clauses.
+   */
+  static class ComplexPhraseQuery extends Query {
+
+    String field;
+
+    String phrasedQueryStringContents;
+
+    int slopFactor;
+
+    private Query contents;
+
+    public ComplexPhraseQuery(String field, String phrasedQueryStringContents,
+        int slopFactor) {
+      super();
+      this.field = field;
+      this.phrasedQueryStringContents = phrasedQueryStringContents;
+      this.slopFactor = slopFactor;
+    }
+
+    // Called by ComplexPhraseQueryParser for each phrase after the main
+    // parse
+    // thread is through
+    protected void parsePhraseElements(QueryParser qp) throws ParseException {
+      // TODO ensure that field-sensitivity is preserved ie the query
+      // string below is parsed as
+      // field+":("+phrasedQueryStringContents+")"
+      // but this will need code in rewrite to unwrap the first layer of
+      // boolean query
+      contents = qp.parse(phrasedQueryStringContents);
+    }
+
+    @Override
+    public Query rewrite(IndexReader reader) throws IOException {
+      // ArrayList spanClauses = new ArrayList();
+      if (contents instanceof TermQuery) {
+        return contents;
+      }
+      // Build a sequence of Span clauses arranged in a SpanNear - child
+      // clauses can be complex
+      // Booleans e.g. nots and ors etc
+      int numNegatives = 0;
+      if (!(contents instanceof BooleanQuery)) {
+        throw new IllegalArgumentException("Unknown query type \""
+            + contents.getClass().getName()
+            + "\" found in phrase query string \"" + phrasedQueryStringContents
+            + "\"");
+      }
+      BooleanQuery bq = (BooleanQuery) contents;
+      BooleanClause[] bclauses = bq.getClauses();
+      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];
+      // For all clauses e.g. one* two~
+      for (int i = 0; i < bclauses.length; i++) {
+        // HashSet bclauseterms=new HashSet();
+        Query qc = bclauses[i].getQuery();
+        // Rewrite this clause e.g one* becomes (one OR onerous)
+        qc = qc.rewrite(reader);
+        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
+          numNegatives++;
+        }
+
+        if (qc instanceof BooleanQuery) {
+          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();
+          addComplexPhraseClause(sc, (BooleanQuery) qc);
+          if (sc.size() > 0) {
+            allSpanClauses[i] = sc.get(0);
+          } else {
+            // Insert fake term e.g. phrase query was for "Fred Smithe*" and
+            // there were no "Smithe*" terms - need to
+            // prevent match on just "Fred".
+            allSpanClauses[i] = new SpanTermQuery(new Term(field,
+                "Dummy clause because no terms found - must match nothing"));
+          }
+        } else {
+          if (qc instanceof TermQuery) {
+            TermQuery tq = (TermQuery) qc;
+            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());
+          } else {
+            throw new IllegalArgumentException("Unknown query type \""
+                + qc.getClass().getName()
+                + "\" found in phrase query string \""
+                + phrasedQueryStringContents + "\"");
+          }
+
+        }
+      }
+      if (numNegatives == 0) {
+        // The simple case - no negative elements in phrase
+        return new SpanNearQuery(allSpanClauses, slopFactor, true);
+      }
+      // Complex case - we have mixed positives and negatives in the
+      // sequence.
+      // Need to return a SpanNotQuery
+      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();
+      for (int j = 0; j < allSpanClauses.length; j++) {
+        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {
+          positiveClauses.add(allSpanClauses[j]);
+        }
+      }
+
+      SpanQuery[] includeClauses = positiveClauses
+          .toArray(new SpanQuery[positiveClauses.size()]);
+
+      SpanQuery include = null;
+      if (includeClauses.length == 1) {
+        include = includeClauses[0]; // only one positive clause
+      } else {
+        // need to increase slop factor based on gaps introduced by
+        // negatives
+        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,
+            true);
+      }
+      // Use sequence of positive and negative values as the exclude.
+      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,
+          true);
+      SpanNotQuery snot = new SpanNotQuery(include, exclude);
+      return snot;
+    }
+
+    private void addComplexPhraseClause(List<SpanQuery> spanClauses, BooleanQuery qc) {
+      ArrayList<SpanQuery> ors = new ArrayList<SpanQuery>();
+      ArrayList<SpanQuery> nots = new ArrayList<SpanQuery>();
+      BooleanClause[] bclauses = qc.getClauses();
+
+      // For all clauses e.g. one* two~
+      for (int i = 0; i < bclauses.length; i++) {
+        Query childQuery = bclauses[i].getQuery();
+
+        // select the list to which we will add these options
+        ArrayList<SpanQuery> chosenList = ors;
+        if (bclauses[i].getOccur() == BooleanClause.Occur.MUST_NOT) {
+          chosenList = nots;
+        }
+
+        if (childQuery instanceof TermQuery) {
+          TermQuery tq = (TermQuery) childQuery;
+          SpanTermQuery stq = new SpanTermQuery(tq.getTerm());
+          stq.setBoost(tq.getBoost());
+          chosenList.add(stq);
+        } else if (childQuery instanceof BooleanQuery) {
+          BooleanQuery cbq = (BooleanQuery) childQuery;
+          addComplexPhraseClause(chosenList, cbq);
+        } else {
+          // TODO alternatively could call extract terms here?
+          throw new IllegalArgumentException("Unknown query type:"
+              + childQuery.getClass().getName());
+        }
+      }
+      if (ors.size() == 0) {
+        return;
+      }
+      SpanOrQuery soq = new SpanOrQuery(ors
+          .toArray(new SpanQuery[ors.size()]));
+      if (nots.size() == 0) {
+        spanClauses.add(soq);
+      } else {
+        SpanOrQuery snqs = new SpanOrQuery(nots
+            .toArray(new SpanQuery[nots.size()]));
+        SpanNotQuery snq = new SpanNotQuery(soq, snqs);
+        spanClauses.add(snq);
+      }
+    }
+
+    @Override
+    public String toString(String field) {
+      return "\"" + phrasedQueryStringContents + "\"";
+    }
+
+    @Override
+    public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + ((field == null) ? 0 : field.hashCode());
+      result = prime
+          * result
+          + ((phrasedQueryStringContents == null) ? 0
+              : phrasedQueryStringContents.hashCode());
+      result = prime * result + slopFactor;
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj)
+        return true;
+      if (obj == null)
+        return false;
+      if (getClass() != obj.getClass())
+        return false;
+      ComplexPhraseQuery other = (ComplexPhraseQuery) obj;
+      if (field == null) {
+        if (other.field != null)
+          return false;
+      } else if (!field.equals(other.field))
+        return false;
+      if (phrasedQueryStringContents == null) {
+        if (other.phrasedQueryStringContents != null)
+          return false;
+      } else if (!phrasedQueryStringContents
+          .equals(other.phrasedQueryStringContents))
+        return false;
+      if (slopFactor != other.slopFactor)
+        return false;
+      return true;
+    }
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/package.html
new file mode 100644
index 0000000..ade19fc
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/package.html
@@ -0,0 +1,22 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<body>
+QueryParser which permits complex phrase query syntax eg "(john jon jonathan~) peters*"
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtendableQueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtendableQueryParser.java
new file mode 100644
index 0000000..fdda8c3
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtendableQueryParser.java
@@ -0,0 +1,142 @@
+package org.apache.lucene.queryparser.ext;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryparser.ext.Extensions.Pair;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.Version;
+
+/**
+ * The {@link ExtendableQueryParser} enables arbitrary query parser extension
+ * based on a customizable field naming scheme. The lucene query syntax allows
+ * implicit and explicit field definitions as query prefix followed by a colon
+ * (':') character. The {@link ExtendableQueryParser} allows to encode extension
+ * keys into the field symbol associated with a registered instance of
+ * {@link ParserExtension}. A customizable separation character separates the
+ * extension key from the actual field symbol. The {@link ExtendableQueryParser}
+ * splits (@see {@link Extensions#splitExtensionField(String, String)}) the
+ * extension key from the field symbol and tries to resolve the associated
+ * {@link ParserExtension}. If the parser can't resolve the key or the field
+ * token does not contain a separation character, {@link ExtendableQueryParser}
+ * yields the same behavior as its super class {@link QueryParser}. Otherwise,
+ * if the key is associated with a {@link ParserExtension} instance, the parser
+ * builds an instance of {@link ExtensionQuery} to be processed by
+ * {@link ParserExtension#parse(ExtensionQuery)}.If a extension field does not
+ * contain a field part the default field for the query will be used.
+ * <p>
+ * To guarantee that an extension field is processed with its associated
+ * extension, the extension query part must escape any special characters like
+ * '*' or '['. If the extension query contains any whitespace characters, the
+ * extension query part must be enclosed in quotes.
+ * Example ('_' used as separation character):
+ * <pre>
+ *   title_customExt:"Apache Lucene\?" OR content_customExt:prefix\*
+ * </pre>
+ * 
+ * Search on the default field:
+ * <pre>
+ *   _customExt:"Apache Lucene\?" OR _customExt:prefix\*
+ * </pre>
+ * </p>
+ * <p>
+ * The {@link ExtendableQueryParser} itself does not implement the logic how
+ * field and extension key are separated or ordered. All logic regarding the
+ * extension key and field symbol parsing is located in {@link Extensions}.
+ * Customized extension schemes should be implemented by sub-classing
+ * {@link Extensions}.
+ * </p>
+ * <p>
+ * For details about the default encoding scheme see {@link Extensions}.
+ * </p>
+ * 
+ * @see Extensions
+ * @see ParserExtension
+ * @see ExtensionQuery
+ */
+public class ExtendableQueryParser extends QueryParser {
+
+  private final String defaultField;
+  private final Extensions extensions;
+
+  /**
+   * Default empty extensions instance
+   */
+  private static final Extensions DEFAULT_EXTENSION = new Extensions();
+
+  /**
+   * Creates a new {@link ExtendableQueryParser} instance
+   * 
+   * @param matchVersion
+   *          the lucene version to use.
+   * @param f
+   *          the default query field
+   * @param a
+   *          the analyzer used to find terms in a query string
+   */
+  public ExtendableQueryParser(final Version matchVersion, final String f,
+      final Analyzer a) {
+    this(matchVersion, f, a, DEFAULT_EXTENSION);
+
+  }
+
+  /**
+   * Creates a new {@link ExtendableQueryParser} instance
+   * 
+   * @param matchVersion
+   *          the lucene version to use.
+   * @param f
+   *          the default query field
+   * @param a
+   *          the analyzer used to find terms in a query string
+   * @param ext
+   *          the query parser extensions
+   */
+  public ExtendableQueryParser(final Version matchVersion, final String f,
+      final Analyzer a, final Extensions ext) {
+    super(matchVersion, f, a);
+    this.defaultField = f;
+    this.extensions = ext;
+  }
+
+  /**
+   * Returns the extension field delimiter character.
+   * 
+   * @return the extension field delimiter character.
+   */
+  public char getExtensionFieldDelimiter() {
+    return extensions.getExtensionFieldDelimiter();
+  }
+
+  @Override
+  protected Query getFieldQuery(final String field, final String queryText, boolean quoted)
+      throws ParseException {
+    final Pair<String,String> splitExtensionField = this.extensions
+        .splitExtensionField(defaultField, field);
+    final ParserExtension extension = this.extensions
+        .getExtension(splitExtensionField.cud);
+    if (extension != null) {
+      return extension.parse(new ExtensionQuery(this, splitExtensionField.cur,
+          queryText));
+    }
+    return super.getFieldQuery(field, queryText, quoted);
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtensionQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtensionQuery.java
new file mode 100644
index 0000000..4789633
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ExtensionQuery.java
@@ -0,0 +1,75 @@
+package org.apache.lucene.queryparser.ext;
+
+import org.apache.lucene.queryparser.classic.QueryParser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * {@link ExtensionQuery} holds all query components extracted from the original
+ * query string like the query field and the extension query string.
+ * 
+ * @see Extensions
+ * @see ExtendableQueryParser
+ * @see ParserExtension
+ */
+public class ExtensionQuery {
+
+  private final String field;
+  private final String rawQueryString;
+  private final QueryParser topLevelParser;
+
+  /**
+   * Creates a new {@link ExtensionQuery}
+   * 
+   * @param field
+   *          the query field
+   * @param rawQueryString
+   *          the raw extension query string
+   */
+  public ExtensionQuery(QueryParser topLevelParser, String field, String rawQueryString) {
+    this.field = field;
+    this.rawQueryString = rawQueryString;
+    this.topLevelParser = topLevelParser;
+  }
+
+  /**
+   * Returns the query field
+   * 
+   * @return the query field
+   */
+  public String getField() {
+    return field;
+  }
+
+  /**
+   * Returns the raw extension query string
+   * 
+   * @return the raw extension query string
+   */
+  public String getRawQueryString() {
+    return rawQueryString;
+  }
+  
+  /**
+   * Returns the top level parser which created this {@link ExtensionQuery} 
+   * @return the top level parser which created this {@link ExtensionQuery}
+   */
+  public QueryParser getTopLevelParser() {
+    return topLevelParser;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/Extensions.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/Extensions.java
new file mode 100644
index 0000000..04f9128
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/Extensions.java
@@ -0,0 +1,218 @@
+package org.apache.lucene.queryparser.ext;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import org.apache.lucene.queryparser.classic.QueryParser;
+
+import java.util.HashMap;
+import java.util.Map;
+
+
+/**
+ * The {@link Extensions} class represents an extension mapping to associate
+ * {@link ParserExtension} instances with extension keys. An extension key is a
+ * string encoded into a Lucene standard query parser field symbol recognized by
+ * {@link ExtendableQueryParser}. The query parser passes each extension field
+ * token to {@link #splitExtensionField(String, String)} to separate the
+ * extension key from the field identifier.
+ * <p>
+ * In addition to the key to extension mapping this class also defines the field
+ * name overloading scheme. {@link ExtendableQueryParser} uses the given
+ * extension to split the actual field name and extension key by calling
+ * {@link #splitExtensionField(String, String)}. To change the order or the key
+ * / field name encoding scheme users can subclass {@link Extensions} to
+ * implement their own.
+ * 
+ * @see ExtendableQueryParser
+ * @see ParserExtension
+ */
+public class Extensions {
+  private final Map<String,ParserExtension> extensions = new HashMap<String,ParserExtension>();
+  private final char extensionFieldDelimiter;
+  /**
+   * The default extension field delimiter character. This constant is set to
+   * ':'
+   */
+  public static final char DEFAULT_EXTENSION_FIELD_DELIMITER = ':';
+
+  /**
+   * Creates a new {@link Extensions} instance with the
+   * {@link #DEFAULT_EXTENSION_FIELD_DELIMITER} as a delimiter character.
+   */
+  public Extensions() {
+    this(DEFAULT_EXTENSION_FIELD_DELIMITER);
+  }
+
+  /**
+   * Creates a new {@link Extensions} instance
+   * 
+   * @param extensionFieldDelimiter
+   *          the extensions field delimiter character
+   */
+  public Extensions(char extensionFieldDelimiter) {
+    this.extensionFieldDelimiter = extensionFieldDelimiter;
+  }
+
+  /**
+   * Adds a new {@link ParserExtension} instance associated with the given key.
+   * 
+   * @param key
+   *          the parser extension key
+   * @param extension
+   *          the parser extension
+   */
+  public void add(String key, ParserExtension extension) {
+    this.extensions.put(key, extension);
+  }
+
+  /**
+   * Returns the {@link ParserExtension} instance for the given key or
+   * <code>null</code> if no extension can be found for the key.
+   * 
+   * @param key
+   *          the extension key
+   * @return the {@link ParserExtension} instance for the given key or
+   *         <code>null</code> if no extension can be found for the key.
+   */
+  public final ParserExtension getExtension(String key) {
+    return this.extensions.get(key);
+  }
+
+  /**
+   * Returns the extension field delimiter
+   * 
+   * @return the extension field delimiter
+   */
+  public char getExtensionFieldDelimiter() {
+    return extensionFieldDelimiter;
+  }
+
+  /**
+   * Splits a extension field and returns the field / extension part as a
+   * {@link Pair}. This method tries to split on the first occurrence of the
+   * extension field delimiter, if the delimiter is not present in the string
+   * the result will contain a <code>null</code> value for the extension key and
+   * the given field string as the field value. If the given extension field
+   * string contains no field identifier the result pair will carry the given
+   * default field as the field value.
+   * 
+   * @param defaultField
+   *          the default query field
+   * @param field
+   *          the extension field string
+   * @return a {@link Pair} with the field name as the {@link Pair#cur} and the
+   *         extension key as the {@link Pair#cud}
+   */
+  public Pair<String,String> splitExtensionField(String defaultField,
+      String field) {
+    int indexOf = field.indexOf(this.extensionFieldDelimiter);
+    if (indexOf < 0)
+      return new Pair<String,String>(field, null);
+    final String indexField = indexOf == 0 ? defaultField : field.substring(0,
+        indexOf);
+    final String extensionKey = field.substring(indexOf + 1);
+    return new Pair<String,String>(indexField, extensionKey);
+
+  }
+
+  /**
+   * Escapes an extension field. The default implementation is equivalent to
+   * {@link QueryParser#escape(String)}.
+   * 
+   * @param extfield
+   *          the extension field identifier
+   * @return the extension field identifier with all special chars escaped with
+   *         a backslash character.
+   */
+  public String escapeExtensionField(String extfield) {
+    return QueryParser.escape(extfield);
+  }
+
+  /**
+   * Builds an extension field string from a given extension key and the default
+   * query field. The default field and the key are delimited with the extension
+   * field delimiter character. This method makes no assumption about the order
+   * of the extension key and the field. By default the extension key is
+   * appended to the end of the returned string while the field is added to the
+   * beginning. Special Query characters are escaped in the result.
+   * <p>
+   * Note: {@link Extensions} subclasses must maintain the contract between
+   * {@link #buildExtensionField(String)} and
+   * {@link #splitExtensionField(String, String)} where the latter inverts the
+   * former.
+   * </p>
+   */
+  public String buildExtensionField(String extensionKey) {
+    return buildExtensionField(extensionKey, "");
+  }
+
+  /**
+   * Builds an extension field string from a given extension key and the
+   * extensions field. The field and the key are delimited with the extension
+   * field delimiter character. This method makes no assumption about the order
+   * of the extension key and the field. By default the extension key is
+   * appended to the end of the returned string while the field is added to the
+   * beginning. Special Query characters are escaped in the result.
+   * <p>
+   * Note: {@link Extensions} subclasses must maintain the contract between
+   * {@link #buildExtensionField(String, String)} and
+   * {@link #splitExtensionField(String, String)} where the latter inverts the
+   * former.
+   * </p>
+   * 
+   * @param extensionKey
+   *          the extension key
+   * @param field
+   *          the field to apply the extension on.
+   * @return escaped extension field identifier
+   * @see #buildExtensionField(String) to use the default query field
+   */
+  public String buildExtensionField(String extensionKey, String field) {
+    StringBuilder builder = new StringBuilder(field);
+    builder.append(this.extensionFieldDelimiter);
+    builder.append(extensionKey);
+    return escapeExtensionField(builder.toString());
+  }
+
+  /**
+   * This class represents a generic pair.
+   * 
+   * @param <Cur>
+   *          the pairs first element
+   * @param <Cud>
+   *          the pairs last element of the pair.
+   */
+  public static class Pair<Cur,Cud> {
+
+    public final Cur cur;
+    public final Cud cud;
+
+    /**
+     * Creates a new Pair
+     * 
+     * @param cur
+     *          the pairs first element
+     * @param cud
+     *          the pairs last element
+     */
+    public Pair(Cur cur, Cud cud) {
+      this.cur = cur;
+      this.cud = cud;
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ParserExtension.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ParserExtension.java
new file mode 100644
index 0000000..294a8a3
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/ParserExtension.java
@@ -0,0 +1,53 @@
+package org.apache.lucene.queryparser.ext;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.search.Query;
+
+/**
+ * This class represents an extension base class to the Lucene standard
+ * {@link org.apache.lucene.queryparser.classic.QueryParser}. The
+ * {@link org.apache.lucene.queryparser.classic.QueryParser} is generated by the JavaCC
+ * parser generator. Changing or adding functionality or syntax in the standard
+ * query parser requires changes to the JavaCC source file. To enable extending
+ * the standard query parser without changing the JavaCC sources and re-generate
+ * the parser the {@link ParserExtension} can be customized and plugged into an
+ * instance of {@link ExtendableQueryParser}, a direct subclass of
+ * {@link org.apache.lucene.queryparser.classic.QueryParser}.
+ * 
+ * @see Extensions
+ * @see ExtendableQueryParser
+ */
+public abstract class ParserExtension {
+
+  /**
+   * Processes the given {@link ExtensionQuery} and returns a corresponding
+   * {@link Query} instance. Subclasses must either return a {@link Query}
+   * instance or raise a {@link ParseException}. This method must not return
+   * <code>null</code>.
+   * 
+   * @param query
+   *          the extension query
+   * @return a new query instance
+   * @throws ParseException
+   *           if the query can not be parsed.
+   */
+  public abstract Query parse(final ExtensionQuery query) throws ParseException;
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/package.html
new file mode 100644
index 0000000..13549a8
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/ext/package.html
@@ -0,0 +1,22 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html><head></head>
+<body>
+Extendable QueryParser provides a simple and flexible extension mechanism by overloading query field names.
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/package.html
new file mode 100644
index 0000000..3ea34b5
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/package.html
@@ -0,0 +1,22 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<body>
+A QueryParser that supports the Span family of queries as well as pre and infix notation.
+</body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/CharStream.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/CharStream.java
new file mode 100644
index 0000000..f0e5405
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/CharStream.java
@@ -0,0 +1,112 @@
+/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false */
+package org.apache.lucene.queryparser.surround.parser;
+
+/**
+ * This interface describes a character stream that maintains line and
+ * column number positions of the characters.  It also has the capability
+ * to backup the stream to some extent.  An implementation of this
+ * interface is used in the TokenManager implementation generated by
+ * JavaCCParser.
+ *
+ * All the methods except backup can be implemented in any fashion. backup
+ * needs to be implemented correctly for the correct operation of the lexer.
+ * Rest of the methods are all used to get information like line number,
+ * column number and the String that constitutes a token and are not used
+ * by the lexer. Hence their implementation won't affect the generated lexer's
+ * operation.
+ */
+
+public interface CharStream {
+
+  /**
+   * Returns the next character from the selected input.  The method
+   * of selecting the input is the responsibility of the class
+   * implementing this interface.  Can throw any java.io.IOException.
+   */
+  char readChar() throws java.io.IOException;
+
+  /**
+   * Returns the column position of the character last read.
+   * @deprecated (gen)
+   * @see #getEndColumn
+   */
+  int getColumn();
+
+  /**
+   * Returns the line number of the character last read.
+   * @deprecated (gen)
+   * @see #getEndLine
+   */
+  int getLine();
+
+  /**
+   * Returns the column number of the last character for current token (being
+   * matched after the last call to BeginTOken).
+   */
+  int getEndColumn();
+
+  /**
+   * Returns the line number of the last character for current token (being
+   * matched after the last call to BeginTOken).
+   */
+  int getEndLine();
+
+  /**
+   * Returns the column number of the first character for current token (being
+   * matched after the last call to BeginTOken).
+   */
+  int getBeginColumn();
+
+  /**
+   * Returns the line number of the first character for current token (being
+   * matched after the last call to BeginTOken).
+   */
+  int getBeginLine();
+
+  /**
+   * Backs up the input stream by amount steps. Lexer calls this method if it
+   * had already read some characters, but could not use them to match a
+   * (longer) token. So, they will be used again as the prefix of the next
+   * token and it is the implemetation's responsibility to do this right.
+   */
+  void backup(int amount);
+
+  /**
+   * Returns the next character that marks the beginning of the next token.
+   * All characters must remain in the buffer between two successive calls
+   * to this method to implement backup correctly.
+   */
+  char BeginToken() throws java.io.IOException;
+
+  /**
+   * Returns a string made up of characters from the marked token beginning
+   * to the current buffer position. Implementations have the choice of returning
+   * anything that they want to. For example, for efficiency, one might decide
+   * to just return null, which is a valid implementation.
+   */
+  String GetImage();
+
+  /**
+   * Returns an array of characters that make up the suffix of length 'len' for
+   * the currently matched token. This is used to build up the matched string
+   * for use in actions in the case of MORE. A simple and inefficient
+   * implementation of this is as follows :
+   *
+   *   {
+   *      String t = GetImage();
+   *      return t.substring(t.length() - len, t.length()).toCharArray();
+   *   }
+   */
+  char[] GetSuffix(int len);
+
+  /**
+   * The lexer calls this function to indicate that it is done with the stream
+   * and hence implementations can free any resources held by this class.
+   * Again, the body of this function can be just empty and it will not
+   * affect the lexer's operation.
+   */
+  void Done();
+
+}
+/* JavaCC - OriginalChecksum=872eafa2c180de2e08862f87f675b2dd (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/FastCharStream.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/FastCharStream.java
new file mode 100644
index 0000000..e035e61
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/FastCharStream.java
@@ -0,0 +1,121 @@
+// FastCharStream.java
+package org.apache.lucene.queryparser.surround.parser;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.*;
+
+/** An efficient implementation of JavaCC's CharStream interface.  <p>Note that
+ * this does not do line-number counting, but instead keeps track of the
+ * character position of the token in the input, as required by Lucene's {@link
+ * org.apache.lucene.analysis.Token} API. */
+public final class FastCharStream implements CharStream {
+  char[] buffer = null;
+
+  int bufferLength = 0;				  // end of valid chars
+  int bufferPosition = 0;			  // next char to read
+
+  int tokenStart = 0;				  // offset in buffer
+  int bufferStart = 0;				  // position in file of buffer
+
+  Reader input;					  // source of chars
+
+  /** Constructs from a Reader. */
+  public FastCharStream(Reader r) {
+    input = r;
+  }
+
+  public final char readChar() throws IOException {
+    if (bufferPosition >= bufferLength)
+      refill();
+    return buffer[bufferPosition++];
+  }
+
+  private final void refill() throws IOException {
+    int newPosition = bufferLength - tokenStart;
+
+    if (tokenStart == 0) {			  // token won't fit in buffer
+      if (buffer == null) {			  // first time: alloc buffer
+	buffer = new char[2048];
+      } else if (bufferLength == buffer.length) { // grow buffer
+	char[] newBuffer = new char[buffer.length*2];
+	System.arraycopy(buffer, 0, newBuffer, 0, bufferLength);
+	buffer = newBuffer;
+      }
+    } else {					  // shift token to front
+      System.arraycopy(buffer, tokenStart, buffer, 0, newPosition);
+    }
+
+    bufferLength = newPosition;			  // update state
+    bufferPosition = newPosition;
+    bufferStart += tokenStart;
+    tokenStart = 0;
+
+    int charsRead =				  // fill space in buffer
+      input.read(buffer, newPosition, buffer.length-newPosition);
+    if (charsRead == -1)
+      throw new IOException("read past eof");
+    else
+      bufferLength += charsRead;
+  }
+
+  public final char BeginToken() throws IOException {
+    tokenStart = bufferPosition;
+    return readChar();
+  }
+
+  public final void backup(int amount) {
+    bufferPosition -= amount;
+  }
+
+  public final String GetImage() {
+    return new String(buffer, tokenStart, bufferPosition - tokenStart);
+  }
+
+  public final char[] GetSuffix(int len) {
+    char[] value = new char[len];
+    System.arraycopy(buffer, bufferPosition - len, value, 0, len);
+    return value;
+  }
+
+  public final void Done() {
+    try {
+      input.close();
+    } catch (IOException e) {
+      System.err.println("Caught: " + e + "; ignoring.");
+    }
+  }
+
+  public final int getColumn() {
+    return bufferStart + bufferPosition;
+  }
+  public final int getLine() {
+    return 1;
+  }
+  public final int getEndColumn() {
+    return bufferStart + bufferPosition;
+  }
+  public final int getEndLine() {
+    return 1;
+  }
+  public final int getBeginColumn() {
+    return bufferStart + tokenStart;
+  }
+  public final int getBeginLine() {
+    return 1;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/ParseException.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/ParseException.java
new file mode 100644
index 0000000..a555e24
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/ParseException.java
@@ -0,0 +1,198 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package org.apache.lucene.queryparser.surround.parser;
+
+/**
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
+ *
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
+ */
+public class ParseException extends Exception {
+
+  /**
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.  The boolean
+   * flag "specialConstructor" is also set to true to indicate that
+   * this constructor was used to create this object.
+   * This constructor calls its super class with the empty string
+   * to force the "toString" method of parent class "Throwable" to
+   * print the error message in the form:
+   *     ParseException: <result of getMessage>
+   */
+  public ParseException(Token currentTokenVal,
+                        int[][] expectedTokenSequencesVal,
+                        String[] tokenImageVal
+                       )
+  {
+    super("");
+    specialConstructor = true;
+    currentToken = currentTokenVal;
+    expectedTokenSequences = expectedTokenSequencesVal;
+    tokenImage = tokenImageVal;
+  }
+
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
+
+  public ParseException() {
+    super();
+    specialConstructor = false;
+  }
+
+  /** Constructor with message. */
+  public ParseException(String message) {
+    super(message);
+    specialConstructor = false;
+  }
+
+  /**
+   * This variable determines which constructor was used to create
+   * this object and thereby affects the semantics of the
+   * "getMessage" method (see below).
+   */
+  protected boolean specialConstructor;
+
+  /**
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
+   */
+  public Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
+   */
+  public int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
+   */
+  public String[] tokenImage;
+
+  /**
+   * This method has the standard behavior when this object has been
+   * created using the standard constructors.  Otherwise, it uses
+   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser), then this method is called during the printing
+   * of the final stack trace, and hence the correct error message
+   * gets displayed.
+   */
+  public String getMessage() {
+    if (!specialConstructor) {
+      return super.getMessage();
+    }
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0) retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  protected String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
+   */
+  protected String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+}
+/* JavaCC - OriginalChecksum=2a154532f17c98e29d1671b8413edb60 (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.java
new file mode 100644
index 0000000..d79746e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.java
@@ -0,0 +1,735 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParser.java */
+package org.apache.lucene.queryparser.surround.parser;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.io.StringReader;
+
+
+import org.apache.lucene.analysis.TokenStream;
+
+import org.apache.lucene.queryparser.surround.query.SrndQuery;
+import org.apache.lucene.queryparser.surround.query.FieldsQuery;
+import org.apache.lucene.queryparser.surround.query.OrQuery;
+import org.apache.lucene.queryparser.surround.query.AndQuery;
+import org.apache.lucene.queryparser.surround.query.NotQuery;
+import org.apache.lucene.queryparser.surround.query.DistanceQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTermQuery;
+import org.apache.lucene.queryparser.surround.query.SrndPrefixQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTruncQuery;
+
+/**
+ * This class is generated by JavaCC.  The only method that clients should need
+ * to call is <a href="#parse">parse()</a>.
+ */
+
+public class QueryParser implements QueryParserConstants {
+  final int minimumPrefixLength = 3;
+  final int minimumCharsInTrunc = 3;
+  final String truncationErrorMessage = "Too unrestrictive truncation: ";
+  final String boostErrorMessage = "Cannot handle boost value: ";
+
+  /* CHECKME: These should be the same as for the tokenizer. How? */
+  final char truncator = '*';
+  final char anyChar = '?';
+  final char quote = '\"';
+  final char fieldOperator = ':';
+  final char comma = ','; /* prefix list separator */
+  final char carat = '^'; /* weight operator */
+
+  static public SrndQuery parse(String query) throws ParseException {
+    QueryParser parser = new QueryParser();
+    return parser.parse2(query);
+  }
+
+  public QueryParser() {
+    this(new FastCharStream(new StringReader("")));
+  }
+
+  public SrndQuery parse2(String query) throws ParseException {
+    ReInit(new FastCharStream(new StringReader(query)));
+    try {
+      return TopSrndQuery();
+    } catch (TokenMgrError tme) {
+      throw new ParseException(tme.getMessage());
+    }
+  }
+
+  protected SrndQuery getFieldsQuery(
+      SrndQuery q, ArrayList<String> fieldNames) {
+    /* FIXME: check acceptable subquery: at least one subquery should not be
+     * a fields query.
+     */
+    return new FieldsQuery(q, fieldNames, fieldOperator);
+  }
+
+  protected SrndQuery getOrQuery(List<SrndQuery> queries, boolean infix, Token orToken) {
+    return new OrQuery(queries, infix, orToken.image);
+  }
+
+  protected SrndQuery getAndQuery(List<SrndQuery> queries, boolean infix, Token andToken) {
+    return new AndQuery( queries, infix, andToken.image);
+  }
+
+  protected SrndQuery getNotQuery(List<SrndQuery> queries, Token notToken) {
+    return new NotQuery( queries, notToken.image);
+  }
+
+  protected static int getOpDistance(String distanceOp) {
+    /* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */
+    return distanceOp.length() == 1
+      ? 1
+      : Integer.parseInt( distanceOp.substring( 0, distanceOp.length() - 1));
+  }
+
+  protected static void checkDistanceSubQueries(DistanceQuery distq, String opName)
+  throws ParseException {
+    String m = distq.distanceSubQueryNotAllowed();
+    if (m != null) {
+      throw new ParseException("Operator " + opName + ": " + m);
+    }
+  }
+
+  protected SrndQuery getDistanceQuery(
+        List<SrndQuery> queries,
+        boolean infix,
+        Token dToken,
+        boolean ordered) throws ParseException {
+    DistanceQuery dq = new DistanceQuery(queries,
+                                        infix,
+                                        getOpDistance(dToken.image),
+                                        dToken.image,
+                                        ordered);
+    checkDistanceSubQueries(dq, dToken.image);
+    return dq;
+  }
+
+  protected SrndQuery getTermQuery(
+        String term, boolean quoted) {
+    return new SrndTermQuery(term, quoted);
+  }
+
+  protected boolean allowedSuffix(String suffixed) {
+    return (suffixed.length() - 1) >= minimumPrefixLength;
+  }
+
+  protected SrndQuery getPrefixQuery(
+      String prefix, boolean quoted) {
+    return new SrndPrefixQuery(prefix, quoted, truncator);
+  }
+
+  protected boolean allowedTruncation(String truncated) {
+    /* At least 3 normal characters needed. */
+    int nrNormalChars = 0;
+    for (int i = 0; i < truncated.length(); i++) {
+      char c = truncated.charAt(i);
+      if ((c != truncator) && (c != anyChar)) {
+        nrNormalChars++;
+      }
+    }
+    return nrNormalChars >= minimumCharsInTrunc;
+  }
+
+  protected SrndQuery getTruncQuery(String truncated) {
+    return new SrndTruncQuery(truncated, truncator, anyChar);
+  }
+
+  final public SrndQuery TopSrndQuery() throws ParseException {
+  SrndQuery q;
+    q = FieldsQuery();
+    jj_consume_token(0);
+   {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery FieldsQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<String> fieldNames;
+    fieldNames = OptionalFields();
+    q = OrQuery();
+   {if (true) return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ArrayList<String> OptionalFields() throws ParseException {
+  Token fieldName;
+  ArrayList<String> fieldNames = null;
+    label_1:
+    while (true) {
+      if (jj_2_1(2)) {
+        ;
+      } else {
+        break label_1;
+      }
+      // to the colon
+          fieldName = jj_consume_token(TERM);
+      jj_consume_token(COLON);
+      if (fieldNames == null) {
+        fieldNames = new ArrayList<String>();
+      }
+      fieldNames.add(fieldName.image);
+    }
+   {if (true) return fieldNames;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery OrQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+    q = AndQuery();
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case OR:
+        ;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        break label_2;
+      }
+      oprt = jj_consume_token(OR);
+                  /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+      q = AndQuery();
+      queries.add(q);
+    }
+   {if (true) return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery AndQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+    q = NotQuery();
+    label_3:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AND:
+        ;
+        break;
+      default:
+        jj_la1[1] = jj_gen;
+        break label_3;
+      }
+      oprt = jj_consume_token(AND);
+                   /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+      q = NotQuery();
+      queries.add(q);
+    }
+   {if (true) return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery NotQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+    q = NQuery();
+    label_4:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case NOT:
+        ;
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        break label_4;
+      }
+      oprt = jj_consume_token(NOT);
+                    /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+      q = NQuery();
+      queries.add(q);
+    }
+   {if (true) return (queries == null) ? q : getNotQuery(queries, oprt);}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery NQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries;
+  Token dt;
+    q = WQuery();
+    label_5:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case N:
+        ;
+        break;
+      default:
+        jj_la1[3] = jj_gen;
+        break label_5;
+      }
+      dt = jj_consume_token(N);
+      queries = new ArrayList<SrndQuery>();
+      queries.add(q); /* left associative */
+
+      q = WQuery();
+      queries.add(q);
+      q = getDistanceQuery(queries, true /* infix */, dt, false /* not ordered */);
+    }
+   {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery WQuery() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries;
+  Token wt;
+    q = PrimaryQuery();
+    label_6:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case W:
+        ;
+        break;
+      default:
+        jj_la1[4] = jj_gen;
+        break label_6;
+      }
+      wt = jj_consume_token(W);
+      queries = new ArrayList<SrndQuery>();
+      queries.add(q); /* left associative */
+
+      q = PrimaryQuery();
+      queries.add(q);
+      q = getDistanceQuery(queries, true /* infix */, wt, true /* ordered */);
+    }
+   {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery PrimaryQuery() throws ParseException {
+                             /* bracketed weighted query or weighted term */
+  SrndQuery q;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case LPAREN:
+      jj_consume_token(LPAREN);
+      q = FieldsQuery();
+      jj_consume_token(RPAREN);
+      break;
+    case OR:
+    case AND:
+    case W:
+    case N:
+      q = PrefixOperatorQuery();
+      break;
+    case TRUNCQUOTED:
+    case QUOTED:
+    case SUFFIXTERM:
+    case TRUNCTERM:
+    case TERM:
+      q = SimpleTerm();
+      break;
+    default:
+      jj_la1[5] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    OptionalWeights(q);
+   {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery PrefixOperatorQuery() throws ParseException {
+  Token oprt;
+  List<SrndQuery> queries;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case OR:
+      oprt = jj_consume_token(OR);
+      /* prefix OR */
+          queries = FieldsQueryList();
+     {if (true) return getOrQuery(queries, false /* not infix */, oprt);}
+      break;
+    case AND:
+      oprt = jj_consume_token(AND);
+      /* prefix AND */
+          queries = FieldsQueryList();
+     {if (true) return getAndQuery(queries, false /* not infix */, oprt);}
+      break;
+    case N:
+      oprt = jj_consume_token(N);
+      /* prefix N */
+          queries = FieldsQueryList();
+     {if (true) return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);}
+      break;
+    case W:
+      oprt = jj_consume_token(W);
+      /* prefix W */
+          queries = FieldsQueryList();
+     {if (true) return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);}
+      break;
+    default:
+      jj_la1[6] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public List<SrndQuery> FieldsQueryList() throws ParseException {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = new ArrayList<SrndQuery>();
+    jj_consume_token(LPAREN);
+    q = FieldsQuery();
+                     queries.add(q);
+    label_7:
+    while (true) {
+      jj_consume_token(COMMA);
+      q = FieldsQuery();
+                              queries.add(q);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case COMMA:
+        ;
+        break;
+      default:
+        jj_la1[7] = jj_gen;
+        break label_7;
+      }
+    }
+    jj_consume_token(RPAREN);
+   {if (true) return queries;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public SrndQuery SimpleTerm() throws ParseException {
+  Token term;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TERM:
+      term = jj_consume_token(TERM);
+     {if (true) return getTermQuery(term.image, false /* not quoted */);}
+      break;
+    case QUOTED:
+      term = jj_consume_token(QUOTED);
+     {if (true) return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);}
+      break;
+    case SUFFIXTERM:
+      term = jj_consume_token(SUFFIXTERM);
+                        /* ending in * */
+      if (! allowedSuffix(term.image)) {
+        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
+      }
+      {if (true) return getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);}
+      break;
+    case TRUNCTERM:
+      term = jj_consume_token(TRUNCTERM);
+                       /* with at least one * or ? */
+      if (! allowedTruncation(term.image)) {
+        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
+      }
+      {if (true) return getTruncQuery(term.image);}
+      break;
+    case TRUNCQUOTED:
+      term = jj_consume_token(TRUNCQUOTED);
+                         /* eg. "9b-b,m"* */
+      if ((term.image.length() - 3) < minimumPrefixLength) {
+        {if (true) throw new ParseException(truncationErrorMessage + term.image);}
+      }
+      {if (true) return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);}
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public void OptionalWeights(SrndQuery q) throws ParseException {
+  Token weight=null;
+    label_8:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case CARAT:
+        ;
+        break;
+      default:
+        jj_la1[9] = jj_gen;
+        break label_8;
+      }
+      jj_consume_token(CARAT);
+      weight = jj_consume_token(NUMBER);
+      float f;
+      try {
+        f = Float.valueOf(weight.image).floatValue();
+      } catch (Exception floatExc) {
+        {if (true) throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");}
+      }
+      if (f <= 0.0) {
+        {if (true) throw new ParseException(boostErrorMessage + weight.image);}
+      }
+      q.setWeight(f * q.getWeight()); /* left associative, fwiw */
+
+    }
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(TERM)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public QueryParserTokenManager token_source;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[10];
+  static private int[] jj_la1_0;
+  static {
+      jj_la1_init_0();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0x100,0x200,0x400,0x1000,0x800,0x7c3b00,0x1b00,0x8000,0x7c0000,0x20000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[1];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with user supplied CharStream. */
+  public QueryParser(CharStream stream) {
+    token_source = new QueryParserTokenManager(stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(CharStream stream) {
+    token_source.ReInit(stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public QueryParser(QueryParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(QueryParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[24];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 10; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 24; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 1; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj
new file mode 100644
index 0000000..8c64f09
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParser.jj
@@ -0,0 +1,454 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Surround query language parser */
+
+/* Query language operators: OR, AND, NOT, W, N, (, ), ^, *, ?, " and comma */
+
+
+options {
+  STATIC=false;
+  JAVA_UNICODE_ESCAPE=true;
+  USER_CHAR_STREAM=true;
+}
+
+PARSER_BEGIN(QueryParser)
+
+package org.apache.lucene.queryparser.surround.parser;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.io.StringReader;
+
+
+import org.apache.lucene.analysis.TokenStream;
+
+import org.apache.lucene.queryparser.surround.query.SrndQuery;
+import org.apache.lucene.queryparser.surround.query.FieldsQuery;
+import org.apache.lucene.queryparser.surround.query.OrQuery;
+import org.apache.lucene.queryparser.surround.query.AndQuery;
+import org.apache.lucene.queryparser.surround.query.NotQuery;
+import org.apache.lucene.queryparser.surround.query.DistanceQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTermQuery;
+import org.apache.lucene.queryparser.surround.query.SrndPrefixQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTruncQuery;
+
+/**
+ * This class is generated by JavaCC.  The only method that clients should need
+ * to call is <a href="#parse">parse()</a>.
+ */
+
+public class QueryParser {
+  final int minimumPrefixLength = 3;
+  final int minimumCharsInTrunc = 3;
+  final String truncationErrorMessage = "Too unrestrictive truncation: ";
+  final String boostErrorMessage = "Cannot handle boost value: ";
+ 
+  /* CHECKME: These should be the same as for the tokenizer. How? */
+  final char truncator = '*';
+  final char anyChar = '?';
+  final char quote = '\"';
+  final char fieldOperator = ':';
+  final char comma = ','; /* prefix list separator */
+  final char carat = '^'; /* weight operator */
+ 
+  static public SrndQuery parse(String query) throws ParseException {
+    QueryParser parser = new QueryParser();
+    return parser.parse2(query);
+  }
+
+  public QueryParser() {
+    this(new FastCharStream(new StringReader("")));
+  }
+
+  public SrndQuery parse2(String query) throws ParseException {
+    ReInit(new FastCharStream(new StringReader(query)));
+    try {
+      return TopSrndQuery();
+    } catch (TokenMgrError tme) {
+      throw new ParseException(tme.getMessage());
+    }
+  }
+    
+  protected SrndQuery getFieldsQuery(
+      SrndQuery q, ArrayList<String> fieldNames) {
+    /* FIXME: check acceptable subquery: at least one subquery should not be
+     * a fields query.
+     */
+    return new FieldsQuery(q, fieldNames, fieldOperator);
+  }
+  
+  protected SrndQuery getOrQuery(List<SrndQuery> queries, boolean infix, Token orToken) {
+    return new OrQuery(queries, infix, orToken.image);
+  }
+
+  protected SrndQuery getAndQuery(List<SrndQuery> queries, boolean infix, Token andToken) {
+    return new AndQuery( queries, infix, andToken.image);
+  }
+  
+  protected SrndQuery getNotQuery(List<SrndQuery> queries, Token notToken) {
+    return new NotQuery( queries, notToken.image);
+  }
+  
+  protected static int getOpDistance(String distanceOp) {
+    /* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */
+    return distanceOp.length() == 1 
+      ? 1
+      : Integer.parseInt( distanceOp.substring( 0, distanceOp.length() - 1));
+  }
+  
+  protected static void checkDistanceSubQueries(DistanceQuery distq, String opName)
+  throws ParseException {
+    String m = distq.distanceSubQueryNotAllowed();
+    if (m != null) {
+      throw new ParseException("Operator " + opName + ": " + m);
+    }
+  }
+  
+  protected SrndQuery getDistanceQuery(
+        List<SrndQuery> queries,
+        boolean infix,
+        Token dToken,
+        boolean ordered) throws ParseException {
+    DistanceQuery dq = new DistanceQuery(queries,
+                                        infix,
+                                        getOpDistance(dToken.image),
+                                        dToken.image,
+                                        ordered);
+    checkDistanceSubQueries(dq, dToken.image);
+    return dq;
+  }
+
+  protected SrndQuery getTermQuery(
+        String term, boolean quoted) {
+    return new SrndTermQuery(term, quoted);
+  }
+
+  protected boolean allowedSuffix(String suffixed) {
+    return (suffixed.length() - 1) >= minimumPrefixLength;
+  }
+
+  protected SrndQuery getPrefixQuery(
+      String prefix, boolean quoted) {
+    return new SrndPrefixQuery(prefix, quoted, truncator);
+  }
+  
+  protected boolean allowedTruncation(String truncated) {
+    /* At least 3 normal characters needed. */
+    int nrNormalChars = 0;
+    for (int i = 0; i < truncated.length(); i++) {
+      char c = truncated.charAt(i);
+      if ((c != truncator) && (c != anyChar)) {
+        nrNormalChars++;
+      }
+    }
+    return nrNormalChars >= minimumCharsInTrunc;
+  }
+
+  protected SrndQuery getTruncQuery(String truncated) {
+    return new SrndTruncQuery(truncated, truncator, anyChar);
+  }
+}
+
+PARSER_END(QueryParser)
+
+/* ***************** */
+/* Token Definitions */
+/* ***************** */
+
+<*> TOKEN : {
+  <#_NUM_CHAR:   ["0"-"9"] >
+| <#_TERM_CHAR: /* everything except whitespace and operators */
+    ( ~[ " ", "\t", "\n", "\r",
+          ",", "?", "*", "(", ")", ":", "^", "\""]
+     ) >
+| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" ) >
+| <#_STAR:       "*" > /* term truncation */
+| <#_ONE_CHAR:   "?" > /* precisely one character in a term */
+/* 2..99 prefix for distance operators */
+| <#_DISTOP_NUM: ((["2"-"9"](["0"-"9"])?) | ("1" ["0"-"9"]))> 
+}
+
+<DEFAULT> SKIP : {
+  < <_WHITESPACE>>
+}
+
+/* Operator tokens (in increasing order of precedence): */
+<DEFAULT> TOKEN :
+{
+  <OR:        "OR" | "or"> 
+| <AND:       "AND" | "and">
+| <NOT:       "NOT" | "not">
+| <W:         (<_DISTOP_NUM>)? ("W"|"w")>
+| <N:         (<_DISTOP_NUM>)? ("N"|"n")>
+/* These are excluded in _TERM_CHAR: */
+| <LPAREN:    "(">
+| <RPAREN:    ")">
+| <COMMA:     ",">
+| <COLON:     ":">
+| <CARAT:     "^"> : Boost
+/* Literal non empty term between single quotes,
+ * escape quoted quote or backslash by backslash.
+ * Evt. truncated.
+ */
+| <TRUNCQUOTED: "\"" (~["\""])+ "\"" <_STAR>>
+| <QUOTED:      "\"" ( (~["\"", "\\"]) | ("\\" ["\\", "\""]))+ "\"">
+| <SUFFIXTERM: (<_TERM_CHAR>)+ <_STAR>>
+| <TRUNCTERM:  (<_TERM_CHAR>)+
+               (<_STAR> | <_ONE_CHAR> )+ /* at least one * or ? */
+               (<_TERM_CHAR> | <_STAR>  | <_ONE_CHAR> )*
+               >
+| <TERM:       (<_TERM_CHAR>)+>
+}
+
+<Boost> TOKEN : {
+<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )?> : DEFAULT
+}
+
+
+SrndQuery TopSrndQuery() : {
+  SrndQuery q;
+}{
+  q = FieldsQuery()
+  <EOF>
+  {return q;}
+}
+
+
+SrndQuery FieldsQuery() : {
+  SrndQuery q;
+  ArrayList<String> fieldNames;
+}{
+  fieldNames = OptionalFields()
+  q = OrQuery()
+  {return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}
+}
+
+
+ArrayList<String> OptionalFields() : {
+  Token fieldName;
+  ArrayList<String> fieldNames = null;
+}{
+  ( LOOKAHEAD(2) // to the colon
+    fieldName = <TERM>
+    <COLON> {
+      if (fieldNames == null) {
+        fieldNames = new ArrayList<String>();
+      }
+      fieldNames.add(fieldName.image);
+    }
+  )*
+  {return fieldNames;}
+}
+
+
+SrndQuery OrQuery() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+}{
+  q = AndQuery()
+  ( oprt = <OR> { /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+    }    
+    q = AndQuery() {
+      queries.add(q);
+    }
+  )*
+  {return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}
+}
+
+
+SrndQuery AndQuery() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+}{
+  q = NotQuery()
+  ( oprt = <AND> { /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+    }
+    q = NotQuery() {
+      queries.add(q);
+    }
+  )* 
+  {return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}
+}
+
+
+SrndQuery NotQuery() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = null;
+  Token oprt = null;
+}{
+  q = NQuery()
+  ( oprt = <NOT>  { /* keep only last used operator */
+      if (queries == null) {
+        queries = new ArrayList<SrndQuery>();
+        queries.add(q);
+      }
+    }
+    q = NQuery() {
+      queries.add(q);
+    }
+  )*
+  {return (queries == null) ? q : getNotQuery(queries, oprt);}
+}
+
+
+SrndQuery NQuery() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries;
+  Token dt;
+}{
+  q = WQuery()
+  ( dt = <N> {
+      queries = new ArrayList<SrndQuery>();
+      queries.add(q); /* left associative */
+    }
+    q = WQuery() {
+      queries.add(q);
+      q = getDistanceQuery(queries, true /* infix */, dt, false /* not ordered */); 
+    }
+  )* 
+  {return q;}
+}
+
+
+SrndQuery WQuery() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries;
+  Token wt;
+}{
+  q = PrimaryQuery()
+  ( wt = <W> {
+      queries = new ArrayList<SrndQuery>();
+      queries.add(q); /* left associative */
+    }
+    q = PrimaryQuery() {
+      queries.add(q); 
+      q = getDistanceQuery(queries, true /* infix */, wt, true /* ordered */); 
+    }
+  )* 
+  {return q;}
+}
+
+
+SrndQuery PrimaryQuery() : { /* bracketed weighted query or weighted term */
+  SrndQuery q;
+}{
+  ( <LPAREN> q = FieldsQuery() <RPAREN>
+  | q = PrefixOperatorQuery()
+  | q = SimpleTerm()
+  )
+  OptionalWeights(q)
+  {return q;}
+}
+
+
+SrndQuery PrefixOperatorQuery() : {
+  Token oprt;
+  List<SrndQuery> queries;
+}{
+  ( oprt = <OR> /* prefix OR */
+    queries = FieldsQueryList()
+    {return getOrQuery(queries, false /* not infix */, oprt);}
+      
+  | oprt = <AND> /* prefix AND */
+    queries = FieldsQueryList()
+    {return getAndQuery(queries, false /* not infix */, oprt);}
+  
+  | oprt = <N> /* prefix N */
+    queries = FieldsQueryList()
+    {return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);}
+    
+  | oprt = <W> /* prefix W */
+    queries = FieldsQueryList()
+    {return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);}
+  )
+}
+
+
+List<SrndQuery> FieldsQueryList() : {
+  SrndQuery q;
+  ArrayList<SrndQuery> queries = new ArrayList<SrndQuery>();
+}{
+  <LPAREN>
+  q = FieldsQuery() {queries.add(q);}
+  (<COMMA> q = FieldsQuery() {queries.add(q);})+
+  <RPAREN>
+  {return queries;}
+}
+
+
+SrndQuery SimpleTerm() : {
+  Token term;
+}{
+  ( term=<TERM>
+    {return getTermQuery(term.image, false /* not quoted */);}
+      
+  | term=<QUOTED>
+    {return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);}
+      
+  | term=<SUFFIXTERM> { /* ending in * */
+      if (! allowedSuffix(term.image)) {
+        throw new ParseException(truncationErrorMessage + term.image);
+      }
+      return getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);
+    }
+      
+  | term=<TRUNCTERM> { /* with at least one * or ? */
+      if (! allowedTruncation(term.image)) {
+        throw new ParseException(truncationErrorMessage + term.image);
+      }
+      return getTruncQuery(term.image);
+    }
+      
+  | term=<TRUNCQUOTED> { /* eg. "9b-b,m"* */
+      if ((term.image.length() - 3) < minimumPrefixLength) {
+        throw new ParseException(truncationErrorMessage + term.image);
+      }
+      return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);
+    }
+  )
+}
+
+
+void OptionalWeights(SrndQuery q) : {
+  Token weight=null;
+}{
+  ( <CARAT> weight=<NUMBER> {
+      float f;
+      try {
+        f = Float.valueOf(weight.image).floatValue();
+      } catch (Exception floatExc) {
+        throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");
+      }
+      if (f <= 0.0) {
+        throw new ParseException(boostErrorMessage + weight.image);
+      }      
+      q.setWeight(f * q.getWeight()); /* left associative, fwiw */
+    }
+  )*
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserConstants.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserConstants.java
new file mode 100644
index 0000000..bba63f2
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserConstants.java
@@ -0,0 +1,91 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserConstants.java */
+package org.apache.lucene.queryparser.surround.parser;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface QueryParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int _NUM_CHAR = 1;
+  /** RegularExpression Id. */
+  int _TERM_CHAR = 2;
+  /** RegularExpression Id. */
+  int _WHITESPACE = 3;
+  /** RegularExpression Id. */
+  int _STAR = 4;
+  /** RegularExpression Id. */
+  int _ONE_CHAR = 5;
+  /** RegularExpression Id. */
+  int _DISTOP_NUM = 6;
+  /** RegularExpression Id. */
+  int OR = 8;
+  /** RegularExpression Id. */
+  int AND = 9;
+  /** RegularExpression Id. */
+  int NOT = 10;
+  /** RegularExpression Id. */
+  int W = 11;
+  /** RegularExpression Id. */
+  int N = 12;
+  /** RegularExpression Id. */
+  int LPAREN = 13;
+  /** RegularExpression Id. */
+  int RPAREN = 14;
+  /** RegularExpression Id. */
+  int COMMA = 15;
+  /** RegularExpression Id. */
+  int COLON = 16;
+  /** RegularExpression Id. */
+  int CARAT = 17;
+  /** RegularExpression Id. */
+  int TRUNCQUOTED = 18;
+  /** RegularExpression Id. */
+  int QUOTED = 19;
+  /** RegularExpression Id. */
+  int SUFFIXTERM = 20;
+  /** RegularExpression Id. */
+  int TRUNCTERM = 21;
+  /** RegularExpression Id. */
+  int TERM = 22;
+  /** RegularExpression Id. */
+  int NUMBER = 23;
+
+  /** Lexical state. */
+  int Boost = 0;
+  /** Lexical state. */
+  int DEFAULT = 1;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "<_NUM_CHAR>",
+    "<_TERM_CHAR>",
+    "<_WHITESPACE>",
+    "\"*\"",
+    "\"?\"",
+    "<_DISTOP_NUM>",
+    "<token of kind 7>",
+    "<OR>",
+    "<AND>",
+    "<NOT>",
+    "<W>",
+    "<N>",
+    "\"(\"",
+    "\")\"",
+    "\",\"",
+    "\":\"",
+    "\"^\"",
+    "<TRUNCQUOTED>",
+    "<QUOTED>",
+    "<SUFFIXTERM>",
+    "<TRUNCTERM>",
+    "<TERM>",
+    "<NUMBER>",
+  };
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java
new file mode 100644
index 0000000..dfbe431
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java
@@ -0,0 +1,714 @@
+/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
+package org.apache.lucene.queryparser.surround.parser;
+import java.util.ArrayList;
+import java.util.List;
+import java.io.StringReader;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.queryparser.surround.query.SrndQuery;
+import org.apache.lucene.queryparser.surround.query.FieldsQuery;
+import org.apache.lucene.queryparser.surround.query.OrQuery;
+import org.apache.lucene.queryparser.surround.query.AndQuery;
+import org.apache.lucene.queryparser.surround.query.NotQuery;
+import org.apache.lucene.queryparser.surround.query.DistanceQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTermQuery;
+import org.apache.lucene.queryparser.surround.query.SrndPrefixQuery;
+import org.apache.lucene.queryparser.surround.query.SrndTruncQuery;
+
+/** Token Manager. */
+public class QueryParserTokenManager implements QueryParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 44:
+         return jjStopAtPos(0, 15);
+      case 58:
+         return jjStopAtPos(0, 16);
+      case 94:
+         return jjStopAtPos(0, 17);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 38;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x7bffe8faffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(5, 7);
+                  if ((0x3fc000000000000L & l) != 0L)
+                     jjCheckNAddStates(8, 11);
+                  else if (curChar == 49)
+                     jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 19:
+                  if ((0x3fc000000000000L & l) != 0L)
+                     jjCheckNAddStates(8, 11);
+                  break;
+               case 20:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAdd(17);
+                  break;
+               case 21:
+                  if ((0x3ff000000000000L & l) != 0L)
+                     jjCheckNAdd(18);
+                  break;
+               case 22:
+                  if (curChar == 49)
+                     jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 23:
+                  if (curChar == 34)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 24:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddTwoStates(24, 25);
+                  break;
+               case 25:
+                  if (curChar == 34)
+                     jjstateSet[jjnewStateCnt++] = 26;
+                  break;
+               case 26:
+                  if (curChar == 42 && kind > 18)
+                     kind = 18;
+                  break;
+               case 27:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(12, 14);
+                  break;
+               case 29:
+                  if (curChar == 34)
+                     jjCheckNAddStates(12, 14);
+                  break;
+               case 30:
+                  if (curChar == 34 && kind > 19)
+                     kind = 19;
+                  break;
+               case 31:
+                  if ((0x7bffe8faffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 32:
+                  if ((0x7bffe8faffffd9ffL & l) != 0L)
+                     jjCheckNAddTwoStates(32, 33);
+                  break;
+               case 33:
+                  if (curChar == 42 && kind > 20)
+                     kind = 20;
+                  break;
+               case 34:
+                  if ((0x7bffe8faffffd9ffL & l) != 0L)
+                     jjCheckNAddTwoStates(34, 35);
+                  break;
+               case 35:
+                  if ((0x8000040000000000L & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAddTwoStates(35, 36);
+                  break;
+               case 36:
+                  if ((0xfbffecfaffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAdd(36);
+                  break;
+               case 37:
+                  if ((0x7bffe8faffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAdd(37);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xffffffffbfffffffL & l) != 0L)
+                  {
+                     if (kind > 22)
+                        kind = 22;
+                     jjCheckNAddStates(0, 4);
+                  }
+                  if ((0x400000004000L & l) != 0L)
+                  {
+                     if (kind > 12)
+                        kind = 12;
+                  }
+                  else if ((0x80000000800000L & l) != 0L)
+                  {
+                     if (kind > 11)
+                        kind = 11;
+                  }
+                  else if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 9;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  else if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 12;
+                  break;
+               case 1:
+                  if (curChar == 82 && kind > 8)
+                     kind = 8;
+                  break;
+               case 2:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 3:
+                  if (curChar == 114 && kind > 8)
+                     kind = 8;
+                  break;
+               case 4:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               case 5:
+                  if (curChar == 68 && kind > 9)
+                     kind = 9;
+                  break;
+               case 6:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 5;
+                  break;
+               case 7:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 100 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 97)
+                     jjstateSet[jjnewStateCnt++] = 9;
+                  break;
+               case 11:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 12:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 13:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 12;
+                  break;
+               case 14:
+                  if (curChar == 116 && kind > 10)
+                     kind = 10;
+                  break;
+               case 15:
+                  if (curChar == 111)
+                     jjstateSet[jjnewStateCnt++] = 14;
+                  break;
+               case 16:
+                  if (curChar == 110)
+                     jjstateSet[jjnewStateCnt++] = 15;
+                  break;
+               case 17:
+                  if ((0x80000000800000L & l) != 0L && kind > 11)
+                     kind = 11;
+                  break;
+               case 18:
+                  if ((0x400000004000L & l) != 0L && kind > 12)
+                     kind = 12;
+                  break;
+               case 24:
+                  jjAddStates(15, 16);
+                  break;
+               case 27:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(12, 14);
+                  break;
+               case 28:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 29;
+                  break;
+               case 29:
+                  if (curChar == 92)
+                     jjCheckNAddStates(12, 14);
+                  break;
+               case 31:
+                  if ((0xffffffffbfffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 32:
+                  if ((0xffffffffbfffffffL & l) != 0L)
+                     jjCheckNAddTwoStates(32, 33);
+                  break;
+               case 34:
+                  if ((0xffffffffbfffffffL & l) != 0L)
+                     jjCheckNAddTwoStates(34, 35);
+                  break;
+               case 36:
+                  if ((0xffffffffbfffffffL & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjstateSet[jjnewStateCnt++] = 36;
+                  break;
+               case 37:
+                  if ((0xffffffffbfffffffL & l) == 0L)
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAdd(37);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAddStates(0, 4);
+                  break;
+               case 24:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(15, 16);
+                  break;
+               case 27:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjAddStates(12, 14);
+                  break;
+               case 32:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddTwoStates(32, 33);
+                  break;
+               case 34:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddTwoStates(34, 35);
+                  break;
+               case 36:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjstateSet[jjnewStateCnt++] = 36;
+                  break;
+               case 37:
+                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 22)
+                     kind = 22;
+                  jjCheckNAdd(37);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 38 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 3;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjAddStates(17, 18);
+                  break;
+               case 1:
+                  if (curChar == 46)
+                     jjCheckNAdd(2);
+                  break;
+               case 2:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAdd(2);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   32, 33, 34, 35, 37, 24, 27, 28, 20, 17, 21, 18, 27, 28, 30, 24, 
+   25, 0, 1, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec2[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec0[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
+"\50", "\51", "\54", "\72", "\136", null, null, null, null, null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Boost",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 1, 
+};
+static final long[] jjtoToken = {
+   0xffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected CharStream input_stream;
+private final int[] jjrounds = new int[38];
+private final int[] jjstateSet = new int[76];
+protected char curChar;
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream){
+   input_stream = stream;
+}
+
+/** Constructor. */
+public QueryParserTokenManager(CharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 38; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(CharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 2 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 1;
+int defaultLexState = 1;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/Token.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/Token.java
new file mode 100644
index 0000000..21dfc0e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/Token.java
@@ -0,0 +1,124 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+package org.apache.lucene.queryparser.surround.parser;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token {
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+     this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+     this.kind = kind;
+     this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+     return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+     switch(ofKind)
+     {
+       default : return new Token(ofKind, image);
+     }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+     return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=a1d2d2c0d7f5810183a1438fb4d51c1c (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/TokenMgrError.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/TokenMgrError.java
new file mode 100644
index 0000000..e0c9c1e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/TokenMgrError.java
@@ -0,0 +1,141 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+package org.apache.lucene.queryparser.surround.parser;
+
+/** Token Manager Error. */
+@SuppressWarnings("serial")
+public class TokenMgrError extends Error
+{
+
+   /*
+    * Ordinals for various reasons why an Error of this type can be thrown.
+    */
+
+   /**
+    * Lexical error occurred.
+    */
+   static final int LEXICAL_ERROR = 0;
+
+   /**
+    * An attempt was made to create a second instance of a static token manager.
+    */
+   static final int STATIC_LEXER_ERROR = 1;
+
+   /**
+    * Tried to change to an invalid lexical state.
+    */
+   static final int INVALID_LEXICAL_STATE = 2;
+
+   /**
+    * Detected (and bailed out of) an infinite loop in the token manager.
+    */
+   static final int LOOP_DETECTED = 3;
+
+   /**
+    * Indicates the reason why the exception is thrown. It will have
+    * one of the above 4 values.
+    */
+   int errorCode;
+
+   /**
+    * Replaces unprintable characters by their escaped (or unicode escaped)
+    * equivalents in the given string
+    */
+   protected static final String addEscapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
+        }
+      }
+      return retval.toString();
+   }
+
+   /**
+    * Returns a detailed message for the Error when it is thrown by the
+    * token manager to indicate a lexical error.
+    * Parameters :
+    *    EOFSeen     : indicates if EOF caused the lexical error
+    *    curLexState : lexical state in which this error occurred
+    *    errorLine   : line number when the error occurred
+    *    errorColumn : column number when the error occurred
+    *    errorAfter  : prefix that was seen before this error occurred
+    *    curchar     : the offending character
+    * Note: You can customize the lexical error message by modifying this method.
+    */
+   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+      return("Lexical error at line " +
+           errorLine + ", column " +
+           errorColumn + ".  Encountered: " +
+           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+           "after : \"" + addEscapes(errorAfter) + "\"");
+   }
+
+   /**
+    * You can also modify the body of this method to customize your error messages.
+    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+    * of end-users concern, so you can return something like :
+    *
+    *     "Internal Error : Please file a bug report .... "
+    *
+    * from this method for such cases in the release version of your parser.
+    */
+   public String getMessage() {
+      return super.getMessage();
+   }
+
+   /*
+    * Constructors of various flavors follow.
+    */
+
+   /** No arg constructor. */
+   public TokenMgrError() {
+   }
+
+   /** Constructor with message and reason. */
+   public TokenMgrError(String message, int reason) {
+      super(message);
+      errorCode = reason;
+   }
+
+   /** Full Constructor. */
+   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+   }
+}
+/* JavaCC - OriginalChecksum=fecdd69c7d7b49407e441e312085db53 (do not edit this line) */
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/package.html
new file mode 100644
index 0000000..0d46240
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/package.html
@@ -0,0 +1,28 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+  <head>
+    <title>Surround parser package</title>
+  </head>
+  <body>
+    This package contains the QueryParser.jj source file for the Surround parser.
+    <p/>
+    Parsing the text of a query results in a SrndQuery in the
+    org.apache.lucene.queryparser.surround.query package.
+  </body>
+</html>
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
new file mode 100644
index 0000000..08583cf
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
@@ -0,0 +1,34 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.util.List;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanClause;
+
+public class AndQuery extends ComposedQuery { 
+  public AndQuery(List<SrndQuery> queries, boolean inf, String opName) { 
+    super(queries, inf, opName);
+  }
+  
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
+    return SrndBooleanQuery.makeBooleanQuery( /* subqueries can be individually boosted */
+      makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.MUST);
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
new file mode 100644
index 0000000..1f9aa4d
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Create basic queries to be used during rewrite.
+ * The basic queries are TermQuery and SpanTermQuery.
+ * An exception can be thrown when too many of these are used.
+ * SpanTermQuery and TermQuery use IndexReader.termEnum(Term), which causes the buffer usage.
+ *
+ * Use this class to limit the buffer usage for reading terms from an index.
+ * Default is 1024, the same as the max. number of subqueries for a BooleanQuery.
+ */
+ 
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+
+public class BasicQueryFactory {
+  public BasicQueryFactory(int maxBasicQueries) {
+    this.maxBasicQueries = maxBasicQueries;
+    this.queriesMade = 0;
+  }
+  
+  public BasicQueryFactory() {
+    this(1024);
+  }
+  
+  private int maxBasicQueries;
+  private int queriesMade;
+  
+  public int getNrQueriesMade() {return queriesMade;}
+  public int getMaxBasicQueries() {return maxBasicQueries;}
+  
+  private synchronized void checkMax() throws TooManyBasicQueries {
+    if (queriesMade >= maxBasicQueries)
+      throw new TooManyBasicQueries(getMaxBasicQueries());
+    queriesMade++;
+  }
+  
+  public TermQuery newTermQuery(Term term) throws TooManyBasicQueries {
+    checkMax();
+    return new TermQuery(term);
+  }
+  
+  public SpanTermQuery newSpanTermQuery(Term term) throws TooManyBasicQueries {
+    checkMax();
+    return new SpanTermQuery(term);
+  }
+}
+
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/ComposedQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/ComposedQuery.java
new file mode 100644
index 0000000..0435d09
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/ComposedQuery.java
@@ -0,0 +1,121 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.apache.lucene.search.Query;
+
+public abstract class ComposedQuery extends SrndQuery { 
+  
+  public ComposedQuery(List qs, boolean operatorInfix, String opName) {
+    recompose(qs);
+    this.operatorInfix = operatorInfix;
+    this.opName = opName;
+  }
+  
+  protected void recompose(List queries) {
+    if (queries.size() < 2) throw new AssertionError("Too few subqueries"); 
+    this.queries = queries;
+  }
+  
+  private String opName;
+  public String getOperatorName() {return opName;}
+  
+  private List queries;
+  
+  public Iterator getSubQueriesIterator() {return queries.listIterator();}
+
+  public int getNrSubQueries() {return queries.size();}
+  
+  public SrndQuery getSubQuery(int qn) {return (SrndQuery) queries.get(qn);}
+
+  private boolean operatorInfix; 
+  public boolean isOperatorInfix() { return operatorInfix; } /* else prefix operator */
+  
+  public List<Query> makeLuceneSubQueriesField(String fn, BasicQueryFactory qf) {
+    List<Query> luceneSubQueries = new ArrayList<Query>();
+    Iterator sqi = getSubQueriesIterator();
+    while (sqi.hasNext()) {
+      luceneSubQueries.add( ((SrndQuery) sqi.next()).makeLuceneQueryField(fn, qf));
+    }
+    return luceneSubQueries;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder r = new StringBuilder();
+    if (isOperatorInfix()) {
+      infixToString(r);
+    } else {
+      prefixToString(r);
+    }
+    weightToString(r);
+    return r.toString();
+  }
+
+  /* Override for different spacing */
+  protected String getPrefixSeparator() { return ", ";}
+  protected String getBracketOpen() { return "(";}
+  protected String getBracketClose() { return ")";}
+  
+  protected void infixToString(StringBuilder r) {
+    /* Brackets are possibly redundant in the result. */
+    Iterator sqi = getSubQueriesIterator();
+    r.append(getBracketOpen());
+    if (sqi.hasNext()) {
+      r.append(sqi.next().toString());
+      while (sqi.hasNext()) {
+        r.append(" ");
+        r.append(getOperatorName()); /* infix operator */
+        r.append(" ");
+        r.append(sqi.next().toString());
+      }
+    }
+    r.append(getBracketClose());
+  }
+
+  protected void prefixToString(StringBuilder r) {
+    Iterator sqi = getSubQueriesIterator();
+    r.append(getOperatorName()); /* prefix operator */
+    r.append(getBracketOpen());
+    if (sqi.hasNext()) {
+      r.append(sqi.next().toString());
+      while (sqi.hasNext()) {
+        r.append(getPrefixSeparator());
+        r.append(sqi.next().toString());
+      }
+    }
+    r.append(getBracketClose());
+  }
+  
+  
+  @Override
+  public boolean isFieldsSubQueryAcceptable() {
+    /* at least one subquery should be acceptable */
+    Iterator sqi = getSubQueriesIterator();
+    while (sqi.hasNext()) {
+      if (((SrndQuery) sqi.next()).isFieldsSubQueryAcceptable()) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
new file mode 100644
index 0000000..ed654ba
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
@@ -0,0 +1,121 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.util.List;
+import java.util.Iterator;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+
+public class DistanceQuery extends ComposedQuery implements DistanceSubQuery {
+  public DistanceQuery(
+      List<SrndQuery> queries,
+      boolean infix,
+      int opDistance,
+      String opName,
+      boolean ordered) {
+    super(queries, infix, opName);
+    this.opDistance = opDistance; /* the distance indicated in the operator */
+    this.ordered = ordered;
+  }
+
+  private int opDistance;
+  public int getOpDistance() {return opDistance;}
+  
+  private boolean ordered;
+  public boolean subQueriesOrdered() {return ordered;}
+  
+  public String distanceSubQueryNotAllowed() {
+    Iterator<?> sqi = getSubQueriesIterator();
+    while (sqi.hasNext()) {
+      Object leq = sqi.next();
+      if (leq instanceof DistanceSubQuery) {
+        DistanceSubQuery dsq = (DistanceSubQuery) leq;
+        String m = dsq.distanceSubQueryNotAllowed();
+        if (m != null) {
+          return m; 
+        }
+      } else {
+        return "Operator " + getOperatorName() + " does not allow subquery " + leq.toString();
+      }
+    }
+    return null; /* subqueries acceptable */
+  }
+
+  
+  public void addSpanQueries(SpanNearClauseFactory sncf) throws IOException {
+    Query snq = getSpanNearQuery(sncf.getIndexReader(),
+                                  sncf.getFieldName(),
+                                  getWeight(),
+                                  sncf.getBasicQueryFactory());
+    sncf.addSpanNearQuery(snq);
+  }
+
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
+    return new Query () {
+      
+      @Override
+      public String toString(String fn) {
+        return getClass().toString() + " " + fieldName + " (" + fn + "?)";
+      }
+      
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        return getSpanNearQuery(reader, fieldName, getBoost(), qf);
+      }
+      
+    };
+  }
+  
+  public Query getSpanNearQuery(
+          IndexReader reader,
+          String fieldName,
+          float boost,
+          BasicQueryFactory qf) throws IOException {
+    SpanQuery[] spanNearClauses = new SpanQuery[getNrSubQueries()];
+    Iterator<?> sqi = getSubQueriesIterator();
+    int qi = 0;
+    while (sqi.hasNext()) {
+      SpanNearClauseFactory sncf = new SpanNearClauseFactory(reader, fieldName, qf);
+      
+      ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
+      if (sncf.size() == 0) { /* distance operator requires all sub queries */
+        while (sqi.hasNext()) { /* produce evt. error messages but ignore results */
+          ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
+          sncf.clear();
+        }
+        return SrndQuery.theEmptyLcnQuery;
+      }
+      
+      spanNearClauses[qi] = sncf.makeSpanNearClause();
+
+      qi++;
+    }
+    
+    SpanNearQuery r = new SpanNearQuery(spanNearClauses, getOpDistance() - 1, subQueriesOrdered());
+    r.setBoost(boost);
+    return r;
+  }
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceSubQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceSubQuery.java
new file mode 100644
index 0000000..8460b5e
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceSubQuery.java
@@ -0,0 +1,31 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+public interface DistanceSubQuery {
+  /** When distanceSubQueryNotAllowed() returns non null, the reason why the subquery
+   * is not allowed as a distance subquery is returned.
+   * <br>When distanceSubQueryNotAllowed() returns null addSpanNearQueries() can be used
+   * in the creation of the span near clause for the subquery.
+   */
+  String distanceSubQueryNotAllowed();
+    
+  void addSpanQueries(SpanNearClauseFactory sncf) throws IOException;
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
new file mode 100644
index 0000000..114e9c7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
@@ -0,0 +1,96 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Iterator;
+
+import org.apache.lucene.search.Query;
+
+public class FieldsQuery extends SrndQuery { /* mostly untested */
+  private SrndQuery q;
+  private List<String> fieldNames;
+  private final char fieldOp;
+  private final String OrOperatorName = "OR"; /* for expanded queries, not normally visible */
+  
+  public FieldsQuery(SrndQuery q, List<String> fieldNames, char fieldOp) {
+    this.q = q;
+    this.fieldNames = fieldNames;
+    this.fieldOp = fieldOp;
+  }
+  
+  public FieldsQuery(SrndQuery q, String fieldName, char fieldOp) {
+    this.q = q;
+    fieldNames = new ArrayList<String>();
+    fieldNames.add(fieldName);
+    this.fieldOp = fieldOp;
+  }
+  
+  @Override
+  public boolean isFieldsSubQueryAcceptable() {
+    return false;
+  }
+  
+  public Query makeLuceneQueryNoBoost(BasicQueryFactory qf) {
+    if (fieldNames.size() == 1) { /* single field name: no new queries needed */
+      return q.makeLuceneQueryFieldNoBoost(fieldNames.get(0), qf);
+    } else { /* OR query over the fields */
+      List<SrndQuery> queries = new ArrayList<SrndQuery>();
+      Iterator<String> fni = getFieldNames().listIterator();
+      SrndQuery qc;
+      while (fni.hasNext()) {
+        qc = (SrndQuery) q.clone();
+        queries.add( new FieldsQuery( qc, fni.next(), fieldOp));
+      }
+      OrQuery oq = new OrQuery(queries,
+                              true /* infix OR for field names */,
+                              OrOperatorName);
+      System.out.println(getClass().toString() + ", fields expanded: " + oq.toString()); /* needs testing */
+      return oq.makeLuceneQueryField(null, qf);
+    }
+  }
+
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
+    return makeLuceneQueryNoBoost(qf); /* use this.fieldNames instead of fieldName */
+  }
+
+  
+  public List<String> getFieldNames() {return fieldNames;}
+
+  public char getFieldOperator() { return fieldOp;}
+  
+  @Override
+  public String toString() {
+    StringBuilder r = new StringBuilder();
+    r.append("(");
+    fieldNamesToString(r);
+    r.append(q.toString());
+    r.append(")");
+    return r.toString();
+  }
+  
+  protected void fieldNamesToString(StringBuilder r) {
+    Iterator<String> fni = getFieldNames().listIterator();
+    while (fni.hasNext()) {
+      r.append(fni.next());
+      r.append(getFieldOperator());
+    }
+  }
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
new file mode 100644
index 0000000..c724be1
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
@@ -0,0 +1,39 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BooleanClause;
+
+public class NotQuery extends ComposedQuery { 
+  public NotQuery(List<SrndQuery> queries, String opName) { super(queries, true /* infix */, opName); }
+  
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
+    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
+    BooleanQuery bq = new BooleanQuery();
+    bq.add( luceneSubQueries.get(0), BooleanClause.Occur.MUST);
+    SrndBooleanQuery.addQueriesToBoolean(bq,
+            // FIXME: do not allow weights on prohibited subqueries.
+            luceneSubQueries.subList(1, luceneSubQueries.size()),
+            // later subqueries: not required, prohibited
+            BooleanClause.Occur.MUST_NOT);
+    return bq;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
new file mode 100644
index 0000000..bafa7db
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
@@ -0,0 +1,61 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.Iterator;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanClause;
+
+import java.io.IOException;
+
+public class OrQuery extends ComposedQuery implements DistanceSubQuery { 
+  public OrQuery(List<SrndQuery> queries, boolean infix, String opName) {
+    super(queries, infix, opName);
+  }
+  
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
+    return SrndBooleanQuery.makeBooleanQuery(
+      /* subqueries can be individually boosted */
+      makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.SHOULD);
+  }
+  
+  public String distanceSubQueryNotAllowed() {
+    Iterator sqi = getSubQueriesIterator();
+    while (sqi.hasNext()) {
+      SrndQuery leq = (SrndQuery) sqi.next();
+      if (leq instanceof DistanceSubQuery) {
+        String m = ((DistanceSubQuery)leq).distanceSubQueryNotAllowed();
+        if (m != null) {
+          return m;
+        }
+      } else {
+        return "subquery not allowed: " + leq.toString();
+      }
+    }
+    return null;
+  }
+    
+  public void addSpanQueries(SpanNearClauseFactory sncf) throws IOException {
+    Iterator sqi = getSubQueriesIterator();
+    while (sqi.hasNext()) {
+      ((DistanceSubQuery)sqi.next()).addSpanQueries(sncf);
+    }
+  }
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
new file mode 100644
index 0000000..3e9c1e3
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
@@ -0,0 +1,115 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.Query;
+
+public abstract class SimpleTerm
+  extends SrndQuery
+  implements DistanceSubQuery, Comparable<SimpleTerm>
+{
+  public SimpleTerm(boolean q) {quoted = q;}
+  
+  private boolean quoted;
+  boolean isQuoted() {return quoted;}
+  
+  public String getQuote() {return "\"";}
+  public String getFieldOperator() {return "/";}
+  
+  public abstract String toStringUnquoted();
+  
+  public int compareTo(SimpleTerm ost) {
+    /* for ordering terms and prefixes before using an index, not used */
+    return this.toStringUnquoted().compareTo( ost.toStringUnquoted());
+  }
+  
+  protected void suffixToString(StringBuilder r) {} /* override for prefix query */
+  
+  @Override
+  public String toString() {
+    StringBuilder r = new StringBuilder();
+    if (isQuoted()) {
+      r.append(getQuote());
+    }
+    r.append(toStringUnquoted());
+    if (isQuoted()) {
+      r.append(getQuote());
+    }
+    suffixToString(r);
+    weightToString(r);
+    return r.toString();
+  }
+  
+  public abstract void visitMatchingTerms(
+                            IndexReader reader,
+                            String fieldName,
+                            MatchingTermVisitor mtv) throws IOException;
+  
+  public interface MatchingTermVisitor {
+    void visitMatchingTerm(Term t)throws IOException;
+  }
+
+  public String distanceSubQueryNotAllowed() {return null;}
+
+  
+  @Override
+  public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
+    return new Query() {
+      @Override
+      public String toString(String fn) {
+        return getClass().toString() + " " + fieldName + " (" + fn + "?)";
+      }
+      
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        final List<Query> luceneSubQueries = new ArrayList<Query>();
+        visitMatchingTerms( reader, fieldName,
+            new MatchingTermVisitor() {
+              public void visitMatchingTerm(Term term) throws IOException {
+                luceneSubQueries.add(qf.newTermQuery(term));
+              }
+            });
+        return  (luceneSubQueries.size() == 0) ? SrndQuery.theEmptyLcnQuery
+              : (luceneSubQueries.size() == 1) ? luceneSubQueries.get(0)
+              : SrndBooleanQuery.makeBooleanQuery(
+                  /* luceneSubQueries all have default weight */
+                  luceneSubQueries, BooleanClause.Occur.SHOULD); /* OR the subquery terms */ 
+      }
+    };
+  }
+    
+  public void addSpanQueries(final SpanNearClauseFactory sncf) throws IOException {
+    visitMatchingTerms(
+          sncf.getIndexReader(),
+          sncf.getFieldName(),
+          new MatchingTermVisitor() {
+            public void visitMatchingTerm(Term term) throws IOException {
+              sncf.addTermWeighted(term, getWeight());
+            }
+          });
+  }
+}
+
+
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
new file mode 100644
index 0000000..68df313
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
@@ -0,0 +1,129 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+SpanNearClauseFactory:
+
+Operations:
+
+- create for a field name and an indexreader.
+
+- add a weighted Term
+  this should add a corresponding SpanTermQuery, or
+  increase the weight of an existing one.
+  
+- add a weighted subquery SpanNearQuery 
+
+- create a clause for SpanNearQuery from the things added above.
+  For this, create an array of SpanQuery's from the added ones.
+  The clause normally is a SpanOrQuery over the added subquery SpanNearQuery
+  the SpanTermQuery's for the added Term's
+*/
+
+/* When  it is necessary to suppress double subqueries as much as possible:
+   hashCode() and equals() on unweighted SpanQuery are needed (possibly via getTerms(),
+   the terms are individually hashable).
+   Idem SpanNearQuery: hash on the subqueries and the slop.
+   Evt. merge SpanNearQuery's by adding the weights of the corresponding subqueries.
+ */
+ 
+/* To be determined:
+   Are SpanQuery weights handled correctly during search by Lucene?
+   Should the resulting SpanOrQuery be sorted?
+   Could other SpanQueries be added for use in this factory:
+   - SpanOrQuery: in principle yes, but it only has access to it's terms
+                  via getTerms(); are the corresponding weights available?
+   - SpanFirstQuery: treat similar to subquery SpanNearQuery. (ok?)
+   - SpanNotQuery: treat similar to subquery SpanNearQuery. (ok?)
+ */
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.HashMap;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+
+
+public class SpanNearClauseFactory {
+  public SpanNearClauseFactory(IndexReader reader, String fieldName, BasicQueryFactory qf) {
+    this.reader = reader;
+    this.fieldName = fieldName;
+    this.weightBySpanQuery = new HashMap<SpanQuery, Float>(); 
+    this.qf = qf;
+  }
+  private IndexReader reader;
+  private String fieldName;
+  private HashMap<SpanQuery, Float> weightBySpanQuery;
+  private BasicQueryFactory qf;
+  
+  public IndexReader getIndexReader() {return reader;}
+  
+  public String getFieldName() {return fieldName;}
+
+  public BasicQueryFactory getBasicQueryFactory() {return qf;}
+  
+  public int size() {return weightBySpanQuery.size();}
+  
+  public void clear() {weightBySpanQuery.clear();}
+
+  protected void addSpanQueryWeighted(SpanQuery sq, float weight) {
+    Float w = weightBySpanQuery.get(sq);
+    if (w != null)
+      w = Float.valueOf(w.floatValue() + weight);
+    else
+      w = Float.valueOf(weight);
+    weightBySpanQuery.put(sq, w); 
+  }
+  
+  public void addTermWeighted(Term t, float weight) throws IOException {   
+    SpanTermQuery stq = qf.newSpanTermQuery(t);
+    /* CHECKME: wrap in Hashable...? */
+    addSpanQueryWeighted(stq, weight);
+  }
+  
+  public void addSpanNearQuery(Query q) {
+    if (q == SrndQuery.theEmptyLcnQuery)
+      return;
+    if (! (q instanceof SpanNearQuery))
+      throw new AssertionError("Expected SpanNearQuery: " + q.toString(getFieldName()));
+    /* CHECKME: wrap in Hashable...? */
+    addSpanQueryWeighted((SpanNearQuery)q, q.getBoost());
+  }
+  
+  public SpanQuery makeSpanNearClause() {
+    SpanQuery [] spanQueries = new SpanQuery[size()];
+    Iterator<SpanQuery> sqi = weightBySpanQuery.keySet().iterator();
+    int i = 0;
+    while (sqi.hasNext()) {
+      SpanQuery sq = sqi.next();
+      sq.setBoost(weightBySpanQuery.get(sq).floatValue());
+      spanQueries[i++] = sq;
+    }
+    
+    if (spanQueries.length == 1)
+      return spanQueries[0];
+    else
+      return new SpanOrQuery(spanQueries);
+  }
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
new file mode 100644
index 0000000..fc836af
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
@@ -0,0 +1,45 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BooleanClause;
+
+class SrndBooleanQuery {
+  public static void addQueriesToBoolean(
+          BooleanQuery bq,
+          List<Query> queries,
+          BooleanClause.Occur occur) {
+    for (int i = 0; i < queries.size(); i++) {
+      bq.add( queries.get(i), occur);
+    }
+  }
+  
+  public static Query makeBooleanQuery(
+          List<Query> queries,
+          BooleanClause.Occur occur) {
+    if (queries.size() <= 1) {
+      throw new AssertionError("Too few subqueries: " + queries.size());
+    }
+    BooleanQuery bq = new BooleanQuery();
+    addQueriesToBoolean(bq, queries.subList(0, queries.size()), occur);
+    return bq;
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
new file mode 100644
index 0000000..6af5267
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
+
+import java.io.IOException;
+
+
+public class SrndPrefixQuery extends SimpleTerm {
+  private final BytesRef prefixRef;
+  public SrndPrefixQuery(String prefix, boolean quoted, char truncator) {
+    super(quoted);
+    this.prefix = prefix;
+    prefixRef = new BytesRef(prefix);
+    this.truncator = truncator;
+  }
+
+  private final String prefix;
+  public String getPrefix() {return prefix;}
+  
+  private final char truncator;
+  public char getSuffixOperator() {return truncator;}
+  
+  public Term getLucenePrefixTerm(String fieldName) {
+    return new Term(fieldName, getPrefix());
+  }
+  
+  @Override
+  public String toStringUnquoted() {return getPrefix();}
+  
+  @Override
+  protected void suffixToString(StringBuilder r) {r.append(getSuffixOperator());}
+  
+  @Override
+  public void visitMatchingTerms(
+    IndexReader reader,
+    String fieldName,
+    MatchingTermVisitor mtv) throws IOException
+  {
+    /* inspired by PrefixQuery.rewrite(): */
+    Terms terms = MultiFields.getTerms(reader, fieldName);
+    if (terms != null) {
+      TermsEnum termsEnum = terms.iterator();
+
+      boolean skip = false;
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getPrefix()));
+      if (status == TermsEnum.SeekStatus.FOUND) {
+        mtv.visitMatchingTerm(getLucenePrefixTerm(fieldName));
+      } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
+        if (termsEnum.term().startsWith(prefixRef)) {
+          mtv.visitMatchingTerm(new Term(fieldName, termsEnum.term().utf8ToString()));
+        } else {
+          skip = true;
+        }
+      } else {
+        // EOF
+        skip = true;
+      }
+
+      if (!skip) {
+        while(true) {
+          BytesRef text = termsEnum.next();
+          if (text != null && text.startsWith(prefixRef)) {
+            mtv.visitMatchingTerm(new Term(fieldName, text.utf8ToString()));
+          } else {
+            break;
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
new file mode 100644
index 0000000..6d913ad
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
@@ -0,0 +1,86 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+
+public abstract class SrndQuery implements Cloneable {
+  public SrndQuery() {}
+  
+  private float weight = (float) 1.0;
+  private boolean weighted = false;
+
+  public void setWeight(float w) {
+    weight = w; /* as parsed from the query text */
+    weighted = true;
+  } 
+  public boolean isWeighted() {return weighted;}
+  public float getWeight() { return weight; }
+  public String getWeightString() {return Float.toString(getWeight());}
+
+  public String getWeightOperator() {return "^";}
+
+  protected void weightToString(StringBuilder r) { /* append the weight part of a query */
+    if (isWeighted()) {
+      r.append(getWeightOperator());
+      r.append(getWeightString());
+    }
+  }
+  
+  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf){
+    Query q = makeLuceneQueryFieldNoBoost(fieldName, qf);
+    if (isWeighted()) {
+      q.setBoost(getWeight() * q.getBoost()); /* weight may be at any level in a SrndQuery */
+    }
+    return q;
+  }
+  
+  public abstract Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf);
+  
+  @Override
+  public abstract String toString();
+  
+  public boolean isFieldsSubQueryAcceptable() {return true;}
+    
+  @Override
+  public Object clone() {
+    try {
+      return super.clone();
+    } catch (CloneNotSupportedException cns) {
+      throw new Error(cns);
+    }
+  }
+  
+/* An empty Lucene query */
+  public final static Query theEmptyLcnQuery = new BooleanQuery() { /* no changes allowed */
+    @Override
+    public void setBoost(float boost) {
+      throw new UnsupportedOperationException();
+    }
+    @Override
+    public void add(BooleanClause clause) {
+      throw new UnsupportedOperationException();
+    }
+    @Override
+    public void add(Query query, BooleanClause.Occur occur) {
+      throw new UnsupportedOperationException();
+    }
+  };
+}
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
new file mode 100644
index 0000000..b8bb356
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
@@ -0,0 +1,65 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.MultiFields;
+import org.apache.lucene.util.BytesRef;
+
+ 
+public class SrndTermQuery extends SimpleTerm {
+  public SrndTermQuery(String termText, boolean quoted) {
+    super(quoted);
+    this.termText = termText;
+  }
+
+  private final String termText;
+  public String getTermText() {return termText;}
+        
+  public Term getLuceneTerm(String fieldName) {
+    return new Term(fieldName, getTermText());
+  }
+  
+  @Override
+  public String toStringUnquoted() {return getTermText();}
+  
+  @Override
+  public void visitMatchingTerms(
+    IndexReader reader,
+    String fieldName,
+    MatchingTermVisitor mtv) throws IOException
+  {
+    /* check term presence in index here for symmetry with other SimpleTerm's */
+    Terms terms = MultiFields.getTerms(reader, fieldName);
+    if (terms != null) {
+      TermsEnum termsEnum = terms.iterator();
+
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getTermText()));
+      if (status == TermsEnum.SeekStatus.FOUND) {
+        mtv.visitMatchingTerm(getLuceneTerm(fieldName));
+      }
+    }
+  }
+}
+  
+
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
new file mode 100644
index 0000000..9ba02a7
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
@@ -0,0 +1,125 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
+
+import java.io.IOException;
+
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+public class SrndTruncQuery extends SimpleTerm {
+  public SrndTruncQuery(String truncated, char unlimited, char mask) {
+    super(false); /* not quoted */
+    this.truncated = truncated;
+    this.unlimited = unlimited;
+    this.mask = mask;
+    truncatedToPrefixAndPattern();
+  }
+  
+  private final String truncated;
+  private final char unlimited;
+  private final char mask;
+  
+  private String prefix;
+  private BytesRef prefixRef;
+  private Pattern pattern;
+  
+  
+  public String getTruncated() {return truncated;}
+  
+  @Override
+  public String toStringUnquoted() {return getTruncated();}
+
+  
+  protected boolean matchingChar(char c) {
+    return (c != unlimited) && (c != mask);
+  }
+
+  protected void appendRegExpForChar(char c, StringBuilder re) {
+    if (c == unlimited)
+      re.append(".*");
+    else if (c == mask)
+      re.append(".");
+    else
+      re.append(c);
+  }
+  
+  protected void truncatedToPrefixAndPattern() {
+    int i = 0;
+    while ((i < truncated.length()) && matchingChar(truncated.charAt(i))) {
+      i++;
+    }
+    prefix = truncated.substring(0, i);
+    prefixRef = new BytesRef(prefix);
+    
+    StringBuilder re = new StringBuilder();
+    while (i < truncated.length()) {
+      appendRegExpForChar(truncated.charAt(i), re);
+      i++;
+    }
+    pattern = Pattern.compile(re.toString());
+  }
+  
+  @Override
+  public void visitMatchingTerms(
+    IndexReader reader,
+    String fieldName,
+    MatchingTermVisitor mtv) throws IOException
+  {
+    int prefixLength = prefix.length();
+    Terms terms = MultiFields.getTerms(reader, fieldName);
+    if (terms != null) {
+      Matcher matcher = pattern.matcher("");
+      try {
+        TermsEnum termsEnum = terms.iterator();
+
+        TermsEnum.SeekStatus status = termsEnum.seekCeil(prefixRef);
+        BytesRef text;
+        if (status == TermsEnum.SeekStatus.FOUND) {
+          text = prefixRef;
+        } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
+          text = termsEnum.term();
+        } else {
+          text = null;
+        }
+
+        while(text != null) {
+          if (text != null && text.startsWith(prefixRef)) {
+            String textString = text.utf8ToString();
+            matcher.reset(textString.substring(prefixLength));
+            if (matcher.matches()) {
+              mtv.visitMatchingTerm(new Term(fieldName, textString));
+            }
+          } else {
+            break;
+          }
+          text = termsEnum.next();
+        }
+      } finally {
+        matcher.reset();
+      }
+    }
+  }
+}
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/TooManyBasicQueries.java b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/TooManyBasicQueries.java
new file mode 100644
index 0000000..c7080d6
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/TooManyBasicQueries.java
@@ -0,0 +1,27 @@
+package org.apache.lucene.queryparser.surround.query;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException; /* subclass to be usable from within Query.rewrite() */
+
+public class TooManyBasicQueries extends IOException {
+  public TooManyBasicQueries(int maxBasicQueries) {
+    super("Exceeded maximum of " + maxBasicQueries + " basic queries.");
+  }
+}
+  
+
diff --git a/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/package.html b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/package.html
new file mode 100644
index 0000000..2dd7a03
--- /dev/null
+++ b/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/query/package.html
@@ -0,0 +1,32 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+  <head>
+    <title>Surround query package</title>
+  </head>
+  <body>
+    This package contains SrndQuery and its subclasses.
+    <p/>
+    The parser in the org.apache.lucene.queryparser.surround.parser package
+    normally generates a SrndQuery.
+    <p/>
+    For searching an org.apache.lucene.search.Query is provided by
+    the SrndQuery.makeLuceneQueryField method.
+    For this, TermQuery, BooleanQuery and SpanQuery are used from Lucene.
+  </body>
+</html>
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/analyzing/TestAnalyzingQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/analyzing/TestAnalyzingQueryParser.java
new file mode 100644
index 0000000..22b9df4
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/analyzing/TestAnalyzingQueryParser.java
@@ -0,0 +1,150 @@
+package org.apache.lucene.queryparser.analyzing;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ */
+public class TestAnalyzingQueryParser extends LuceneTestCase {
+
+  private Analyzer a;
+
+  private String[] wildcardInput;
+  private String[] wildcardExpected;
+  private String[] prefixInput;
+  private String[] prefixExpected;
+  private String[] rangeInput;
+  private String[] rangeExpected;
+  private String[] fuzzyInput;
+  private String[] fuzzyExpected;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    wildcardInput = new String[] { "übersetzung über*ung",
+        "Mötley Cr\u00fce Mötl?* Crü?", "Renée Zellweger Ren?? Zellw?ger" };
+    wildcardExpected = new String[] { "ubersetzung uber*ung", "motley crue motl?* cru?",
+        "renee zellweger ren?? zellw?ger" };
+
+    prefixInput = new String[] { "übersetzung übersetz*",
+        "Mötley Crüe Mötl* crü*", "René? Zellw*" };
+    prefixExpected = new String[] { "ubersetzung ubersetz*", "motley crue motl* cru*",
+        "rene? zellw*" };
+
+    rangeInput = new String[] { "[aa TO bb]", "{Anaïs TO Zoé}" };
+    rangeExpected = new String[] { "[aa TO bb]", "{anais TO zoe}" };
+
+    fuzzyInput = new String[] { "?bersetzung ?bersetzung~0.9",
+        "Mötley Crüe Mötley~0.75 Crüe~0.5",
+        "Renée Zellweger Renée~0.9 Zellweger~" };
+    fuzzyExpected = new String[] { "ubersetzung ubersetzung~0.9",
+        "motley crue motley~0.75 crue~0.5", "renee zellweger renee~0.9 zellweger~2.0" };
+
+    a = new ASCIIAnalyzer();
+  }
+
+  public void testWildCardQuery() throws ParseException {
+    for (int i = 0; i < wildcardInput.length; i++) {
+      assertEquals("Testing wildcards with analyzer " + a.getClass() + ", input string: "
+          + wildcardInput[i], wildcardExpected[i], parseWithAnalyzingQueryParser(wildcardInput[i], a));
+    }
+  }
+
+  public void testPrefixQuery() throws ParseException {
+    for (int i = 0; i < prefixInput.length; i++) {
+      assertEquals("Testing prefixes with analyzer " + a.getClass() + ", input string: "
+          + prefixInput[i], prefixExpected[i], parseWithAnalyzingQueryParser(prefixInput[i], a));
+    }
+  }
+
+  public void testRangeQuery() throws ParseException {
+    for (int i = 0; i < rangeInput.length; i++) {
+      assertEquals("Testing ranges with analyzer " + a.getClass() + ", input string: "
+          + rangeInput[i], rangeExpected[i], parseWithAnalyzingQueryParser(rangeInput[i], a));
+    }
+  }
+
+  public void testFuzzyQuery() throws ParseException {
+    for (int i = 0; i < fuzzyInput.length; i++) {
+      assertEquals("Testing fuzzys with analyzer " + a.getClass() + ", input string: "
+          + fuzzyInput[i], fuzzyExpected[i], parseWithAnalyzingQueryParser(fuzzyInput[i], a));
+    }
+  }
+
+  private String parseWithAnalyzingQueryParser(String s, Analyzer a) throws ParseException {
+    AnalyzingQueryParser qp = new AnalyzingQueryParser(TEST_VERSION_CURRENT, "field", a);
+    org.apache.lucene.search.Query q = qp.parse(s);
+    return q.toString("field");
+  }
+
+}
+
+final class TestFoldingFilter extends TokenFilter {
+  final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+
+  public TestFoldingFilter(TokenStream input) {
+    super(input);
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char term[] = termAtt.buffer();
+      for (int i = 0; i < term.length; i++)
+        switch(term[i]) {
+          case 'ü':
+            term[i] = 'u'; 
+            break;
+          case 'ö': 
+            term[i] = 'o'; 
+            break;
+          case 'é': 
+            term[i] = 'e'; 
+            break;
+          case 'ï': 
+            term[i] = 'i'; 
+            break;
+        }
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
+
+final class ASCIIAnalyzer extends org.apache.lucene.analysis.Analyzer {
+  public ASCIIAnalyzer() {
+  }
+
+  @Override
+  public TokenStream tokenStream(String fieldName, Reader reader) {
+    TokenStream result = new MockTokenizer(reader, MockTokenizer.SIMPLE, true);
+    result = new TestFoldingFilter(result);
+    return result;
+  }
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
new file mode 100644
index 0000000..e1f8c23
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
@@ -0,0 +1,147 @@
+package org.apache.lucene.queryparser.complexPhrase;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashSet;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestComplexPhraseQuery extends LuceneTestCase {
+  Directory rd;
+  Analyzer analyzer = new MockAnalyzer(random);
+
+  DocData docsContent[] = { new DocData("john smith", "1"),
+      new DocData("johathon smith", "2"),
+      new DocData("john percival smith", "3"),
+      new DocData("jackson waits tom", "4") };
+
+  private IndexSearcher searcher;
+
+  String defaultFieldName = "name";
+
+  public void testComplexPhrases() throws Exception {
+    checkMatches("\"john smith\"", "1"); // Simple multi-term still works
+    checkMatches("\"j*   smyth~\"", "1,2"); // wildcards and fuzzies are OK in
+    // phrases
+    checkMatches("\"(jo* -john)  smith\"", "2"); // boolean logic works
+    checkMatches("\"jo*  smith\"~2", "1,2,3"); // position logic works.
+    checkMatches("\"jo* [sma TO smZ]\" ", "1,2"); // range queries supported
+    checkMatches("\"john\"", "1,3"); // Simple single-term still works
+    checkMatches("\"(john OR johathon)  smith\"", "1,2"); // boolean logic with
+    // brackets works.
+    checkMatches("\"(jo* -john) smyth~\"", "2"); // boolean logic with
+    // brackets works.
+
+    // checkMatches("\"john -percival\"", "1"); // not logic doesn't work
+    // currently :(.
+
+    checkMatches("\"john  nosuchword*\"", ""); // phrases with clauses producing
+    // empty sets
+
+    checkBadQuery("\"jo*  id:1 smith\""); // mixing fields in a phrase is bad
+    checkBadQuery("\"jo* \"smith\" \""); // phrases inside phrases is bad
+  }
+
+  private void checkBadQuery(String qString) {
+    QueryParser qp = new ComplexPhraseQueryParser(TEST_VERSION_CURRENT, defaultFieldName, analyzer);
+    Throwable expected = null;
+    try {
+      qp.parse(qString);
+    } catch (Throwable e) {
+      expected = e;
+    }
+    assertNotNull("Expected parse error in " + qString, expected);
+
+  }
+
+  private void checkMatches(String qString, String expectedVals)
+      throws Exception {
+    QueryParser qp = new ComplexPhraseQueryParser(TEST_VERSION_CURRENT, defaultFieldName, analyzer);
+    qp.setFuzzyPrefixLength(1); // usually a good idea
+
+    Query q = qp.parse(qString);
+
+    HashSet<String> expecteds = new HashSet<String>();
+    String[] vals = expectedVals.split(",");
+    for (int i = 0; i < vals.length; i++) {
+      if (vals[i].length() > 0)
+        expecteds.add(vals[i]);
+    }
+
+    TopDocs td = searcher.search(q, 10);
+    ScoreDoc[] sd = td.scoreDocs;
+    for (int i = 0; i < sd.length; i++) {
+      Document doc = searcher.doc(sd[i].doc);
+      String id = doc.get("id");
+      assertTrue(qString + "matched doc#" + id + " not expected", expecteds
+          .contains(id));
+      expecteds.remove(id);
+    }
+
+    assertEquals(qString + " missing some matches ", 0, expecteds.size());
+
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    rd = newDirectory();
+    IndexWriter w = new IndexWriter(rd, newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer));
+    for (int i = 0; i < docsContent.length; i++) {
+      Document doc = new Document();
+      doc.add(newField("name", docsContent[i].name, Field.Store.YES,
+          Field.Index.ANALYZED));
+      doc.add(newField("id", docsContent[i].id, Field.Store.YES,
+          Field.Index.ANALYZED));
+      w.addDocument(doc);
+    }
+    w.close();
+    searcher = new IndexSearcher(rd, true);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    searcher.close();
+    rd.close();
+    super.tearDown();
+  }
+
+  static class DocData {
+    String name;
+
+    String id;
+
+    public DocData(String name, String id) {
+      super();
+      this.name = name;
+      this.id = id;
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/ExtensionStub.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/ExtensionStub.java
new file mode 100644
index 0000000..7285b08
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/ExtensionStub.java
@@ -0,0 +1,33 @@
+package org.apache.lucene.queryparser.ext;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class ExtensionStub extends ParserExtension {
+
+  @Override
+  public Query parse(ExtensionQuery components) throws ParseException {
+    return new TermQuery(new Term(components.getField(), components
+        .getRawQueryString()));
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java
new file mode 100644
index 0000000..3592728
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java
@@ -0,0 +1,128 @@
+package org.apache.lucene.queryparser.ext;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * Testcase for the class {@link ExtendableQueryParser}
+ */
+public class TestExtendableQueryParser extends LuceneTestCase {
+  private static char[] DELIMITERS = new char[] {
+      Extensions.DEFAULT_EXTENSION_FIELD_DELIMITER, '-', '|' };
+
+  public QueryParser getParser(Analyzer a, Extensions extensions)
+      throws Exception {
+    if (a == null)
+      a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
+    QueryParser qp = extensions == null ? new ExtendableQueryParser(
+        TEST_VERSION_CURRENT, "field", a) : new ExtendableQueryParser(
+        TEST_VERSION_CURRENT, "field", a, extensions);
+    qp.setDefaultOperator(QueryParser.OR_OPERATOR);
+    return qp;
+  }
+
+  public void testUnescapedExtDelimiter() throws Exception {
+    Extensions ext = newExtensions(':');
+    ext.add("testExt", new ExtensionStub());
+    ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null, ext);
+    try {
+      parser.parse("aField:testExt:\"foo \\& bar\"");
+      fail("extension field delimiter is not escaped");
+    } catch (ParseException e) {
+    }
+  }
+
+  public void testExtFieldUnqoted() throws Exception {
+    for (int i = 0; i < DELIMITERS.length; i++) {
+      Extensions ext = newExtensions(DELIMITERS[i]);
+      ext.add("testExt", new ExtensionStub());
+      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
+          ext);
+      String field = ext.buildExtensionField("testExt", "aField");
+      Query query = parser.parse(String.format("%s:foo bar", field));
+      assertTrue("expected instance of BooleanQuery but was "
+          + query.getClass(), query instanceof BooleanQuery);
+      BooleanQuery bquery = (BooleanQuery) query;
+      BooleanClause[] clauses = bquery.getClauses();
+      assertEquals(2, clauses.length);
+      BooleanClause booleanClause = clauses[0];
+      query = booleanClause.getQuery();
+      assertTrue("expected instance of TermQuery but was " + query.getClass(),
+          query instanceof TermQuery);
+      TermQuery tquery = (TermQuery) query;
+      assertEquals("aField", tquery.getTerm()
+          .field());
+      assertEquals("foo", tquery.getTerm().text());
+
+      booleanClause = clauses[1];
+      query = booleanClause.getQuery();
+      assertTrue("expected instance of TermQuery but was " + query.getClass(),
+          query instanceof TermQuery);
+      tquery = (TermQuery) query;
+      assertEquals("field", tquery.getTerm().field());
+      assertEquals("bar", tquery.getTerm().text());
+    }
+  }
+
+  public void testExtDefaultField() throws Exception {
+    for (int i = 0; i < DELIMITERS.length; i++) {
+      Extensions ext = newExtensions(DELIMITERS[i]);
+      ext.add("testExt", new ExtensionStub());
+      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
+          ext);
+      String field = ext.buildExtensionField("testExt");
+      Query parse = parser.parse(String.format("%s:\"foo \\& bar\"", field));
+      assertTrue("expected instance of TermQuery but was " + parse.getClass(),
+          parse instanceof TermQuery);
+      TermQuery tquery = (TermQuery) parse;
+      assertEquals("field", tquery.getTerm().field());
+      assertEquals("foo & bar", tquery.getTerm().text());
+    }
+  }
+
+  public Extensions newExtensions(char delimiter) {
+    return new Extensions(delimiter);
+  }
+
+  public void testExtField() throws Exception {
+    for (int i = 0; i < DELIMITERS.length; i++) {
+      Extensions ext = newExtensions(DELIMITERS[i]);
+      ext.add("testExt", new ExtensionStub());
+      ExtendableQueryParser parser = (ExtendableQueryParser) getParser(null,
+          ext);
+      String field = ext.buildExtensionField("testExt", "afield");
+      Query parse = parser.parse(String.format("%s:\"foo \\& bar\"", field));
+      assertTrue("expected instance of TermQuery but was " + parse.getClass(),
+          parse instanceof TermQuery);
+      TermQuery tquery = (TermQuery) parse;
+      assertEquals("afield", tquery.getTerm().field());
+      assertEquals("foo & bar", tquery.getTerm().text());
+    }
+  }
+
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtensions.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtensions.java
new file mode 100644
index 0000000..c590ecb
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtensions.java
@@ -0,0 +1,79 @@
+package org.apache.lucene.queryparser.ext;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * Testcase for the {@link Extensions} class
+ */
+public class TestExtensions extends LuceneTestCase {
+
+  private Extensions ext;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    this.ext = new Extensions();
+  }
+
+  public void testBuildExtensionField() {
+    assertEquals("field\\:key", ext.buildExtensionField("key", "field"));
+    assertEquals("\\:key", ext.buildExtensionField("key"));
+
+    ext = new Extensions('.');
+    assertEquals("field.key", ext.buildExtensionField("key", "field"));
+    assertEquals(".key", ext.buildExtensionField("key"));
+  }
+
+  public void testSplitExtensionField() {
+    assertEquals("field\\:key", ext.buildExtensionField("key", "field"));
+    assertEquals("\\:key", ext.buildExtensionField("key"));
+
+    ext = new Extensions('.');
+    assertEquals("field.key", ext.buildExtensionField("key", "field"));
+    assertEquals(".key", ext.buildExtensionField("key"));
+  }
+
+  public void testAddGetExtension() {
+    ParserExtension extension = new ExtensionStub();
+    assertNull(ext.getExtension("foo"));
+    ext.add("foo", extension);
+    assertSame(extension, ext.getExtension("foo"));
+    ext.add("foo", null);
+    assertNull(ext.getExtension("foo"));
+  }
+
+  public void testGetExtDelimiter() {
+    assertEquals(Extensions.DEFAULT_EXTENSION_FIELD_DELIMITER, this.ext
+        .getExtensionFieldDelimiter());
+    ext = new Extensions('?');
+    assertEquals('?', this.ext.getExtensionFieldDelimiter());
+  }
+
+  public void testEscapeExtension() {
+    assertEquals("abc\\:\\?\\{\\}\\[\\]\\\\\\(\\)\\+\\-\\!\\~", ext
+        .escapeExtensionField("abc:?{}[]\\()+-!~"));
+    try {
+      ext.escapeExtensionField(null);
+      fail("should throw NPE - escape string is null");
+    } catch (NullPointerException e) {
+      // 
+    }
+  }
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
new file mode 100644
index 0000000..f9ef31e
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
@@ -0,0 +1,134 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Collector;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Query;
+
+import org.apache.lucene.queryparser.surround.parser.QueryParser;
+
+import org.junit.Assert;
+
+public class BooleanQueryTst {
+  String queryText;
+  final int[] expectedDocNrs;
+  SingleFieldTestDb dBase;
+  String fieldName;
+  Assert testCase;
+  BasicQueryFactory qf;
+  boolean verbose = true;
+
+  public BooleanQueryTst(
+      String queryText,
+      int[] expectedDocNrs,
+      SingleFieldTestDb dBase,
+      String fieldName,
+      Assert testCase,
+      BasicQueryFactory qf) {
+    this.queryText = queryText;
+    this.expectedDocNrs = expectedDocNrs;
+    this.dBase = dBase;
+    this.fieldName = fieldName;
+    this.testCase = testCase;
+    this.qf = qf;
+  }
+  
+  public void setVerbose(boolean verbose) {this.verbose = verbose;}
+
+  class TestCollector extends Collector { // FIXME: use check hits from Lucene tests
+    int totalMatched;
+    boolean[] encountered;
+    private Scorer scorer = null;
+    private int docBase = 0;
+
+    TestCollector() {
+      totalMatched = 0;
+      encountered = new boolean[expectedDocNrs.length];
+    }
+
+    @Override
+    public void setScorer(Scorer scorer) throws IOException {
+      this.scorer = scorer;
+    }
+
+    @Override
+    public boolean acceptsDocsOutOfOrder() {
+      return true;
+    }
+
+    @Override
+    public void setNextReader(AtomicReaderContext context) throws IOException {
+      docBase = context.docBase;
+    }
+    
+    @Override
+    public void collect(int docNr) throws IOException {
+      float score = scorer.score();
+      docNr += docBase;
+      /* System.out.println(docNr + " '" + dBase.getDocs()[docNr] + "': " + score); */
+      Assert.assertTrue(queryText + ": positive score", score > 0.0);
+      Assert.assertTrue(queryText + ": too many hits", totalMatched < expectedDocNrs.length);
+      int i;
+      for (i = 0; i < expectedDocNrs.length; i++) {
+        if ((! encountered[i]) && (expectedDocNrs[i] == docNr)) {
+          encountered[i] = true;
+          break;
+        }
+      }
+      if (i == expectedDocNrs.length) {
+        Assert.assertTrue(queryText + ": doc nr for hit not expected: " + docNr, false);
+      }
+      totalMatched++;
+    }
+
+    void checkNrHits() {
+      Assert.assertEquals(queryText + ": nr of hits", expectedDocNrs.length, totalMatched);
+    }
+  }
+
+  public void doTest() throws Exception {
+
+    if (verbose) {    
+        System.out.println("");
+        System.out.println("Query: " + queryText);
+    }
+    
+    SrndQuery lq = QueryParser.parse(queryText);
+    
+    /* if (verbose) System.out.println("Srnd: " + lq.toString()); */
+    
+    Query query = lq.makeLuceneQueryField(fieldName, qf);
+    /* if (verbose) System.out.println("Lucene: " + query.toString()); */
+
+    TestCollector tc = new TestCollector();
+    IndexSearcher searcher = new IndexSearcher(dBase.getDb(), true);
+    try {
+      searcher.search(query, tc);
+    } finally {
+      searcher.close();
+    }
+    tc.checkNrHits();
+  }
+}
+
+
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
new file mode 100644
index 0000000..2d2c695
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
@@ -0,0 +1,66 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryparser.surround.parser.ParseException;
+import org.apache.lucene.queryparser.surround.parser.QueryParser;
+
+
+public class ExceptionQueryTst {
+  private String queryText;
+  private boolean verbose;
+  
+  public ExceptionQueryTst(String queryText, boolean verbose) {
+    this.queryText = queryText;
+    this.verbose = verbose;
+  }
+
+  public void doTest(StringBuilder failQueries) {
+    boolean pass = false;
+    SrndQuery lq = null;
+    try {
+      lq = QueryParser.parse(queryText);
+      if (verbose) {
+        System.out.println("Query: " + queryText + "\nParsed as: " + lq.toString());
+      }
+    } catch (ParseException e) {
+      if (verbose) {
+        System.out.println("Parse exception for query:\n"
+                            + queryText + "\n"
+                            + e.getMessage());
+      }
+      pass = true;
+    }
+    if (! pass) {
+      failQueries.append(queryText);
+      failQueries.append("\nParsed as: ");
+      failQueries.append(lq.toString());
+      failQueries.append("\n");
+    }
+  }
+  
+  public static String getFailQueries(String[] exceptionQueries, boolean verbose) {
+    StringBuilder failQueries = new StringBuilder();
+    for (int i = 0; i < exceptionQueries.length; i++ ) {
+      new ExceptionQueryTst( exceptionQueries[i], verbose).doTest(failQueries);
+    }
+    return failQueries.toString();
+  }
+}
+
+
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
new file mode 100644
index 0000000..5864119
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
@@ -0,0 +1,61 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Random;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.Version;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+
+public class SingleFieldTestDb {
+  private Directory db;
+  private String[] docs;
+  private String fieldName;
+  
+  public SingleFieldTestDb(Random random, String[] documents, String fName) {
+    try {
+      db = new MockDirectoryWrapper(random, new RAMDirectory());
+      docs = documents;
+      fieldName = fName;
+      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(
+          Version.LUCENE_CURRENT,
+          new MockAnalyzer(random)));
+      for (int j = 0; j < docs.length; j++) {
+        Document d = new Document();
+        d.add(new Field(fieldName, docs[j], Field.Store.NO, Field.Index.ANALYZED));
+        writer.addDocument(d);
+      }
+      writer.close();
+    } catch (java.io.IOException ioe) {
+      throw new Error(ioe);
+    }
+  }
+  
+  Directory getDb() {return db;}
+  String[] getDocs() {return docs;}
+  String getFieldname() {return fieldName;}
+}
+
+
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
new file mode 100644
index 0000000..fe5e3ab
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
@@ -0,0 +1,70 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class Test01Exceptions extends LuceneTestCase {
+  /** Main for running test case by itself. */
+  public static void main(String args[]) {
+    TestRunner.run(new TestSuite(Test01Exceptions.class));
+  }
+
+  boolean verbose = false; /* to show actual parsing error messages */
+  final String fieldName = "bi";
+
+  String[] exceptionQueries = {
+    "*",
+    "a*",
+    "ab*",
+    "?",
+    "a?",
+    "ab?",
+    "a???b",
+    "a?",
+    "a*b?",
+    "word1 word2",
+    "word2 AND",
+    "word1 OR",
+    "AND(word2)",
+    "AND(word2,)",
+    "AND(word2,word1,)",
+    "OR(word2)",
+    "OR(word2 ,",
+    "OR(word2 , word1 ,)",
+    "xx NOT",
+    "xx (a AND b)",
+    "(a AND b",
+    "a OR b)",
+    "or(word2+ not ord+, and xyz,def)",
+    ""
+  };
+
+  public void test01Exceptions() throws Exception {
+    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    if (m.length() > 0) {
+      fail("No ParseException for:\n" + m);
+    }
+  }
+}
+
+
+
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
new file mode 100644
index 0000000..e02e25e
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
@@ -0,0 +1,122 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class Test02Boolean extends LuceneTestCase {
+  public static void main(String args[]) {
+    TestRunner.run(new TestSuite(Test02Boolean.class));
+  }
+
+  final String fieldName = "bi";
+  boolean verbose = false;
+  int maxBasicQueries = 16;
+
+  String[] docs1 = {
+    "word1 word2 word3",
+    "word4 word5",
+    "ord1 ord2 ord3",
+    "orda1 orda2 orda3 word2 worda3",
+    "a c e a b c"
+  };
+
+  SingleFieldTestDb db1 = new SingleFieldTestDb(random, docs1, fieldName);
+
+  public void normalTest1(String query, int[] expdnrs) throws Exception {
+    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db1, fieldName, this,
+                                                new BasicQueryFactory(maxBasicQueries));
+    bqt.setVerbose(verbose);
+    bqt.doTest();
+  }
+
+  public void test02Terms01() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "word1", expdnrs);
+  }
+  public void test02Terms02() throws Exception {
+    int[] expdnrs = {0, 1, 3}; normalTest1( "word*", expdnrs);
+  }
+  public void test02Terms03() throws Exception {
+    int[] expdnrs = {2}; normalTest1( "ord2", expdnrs);
+  }
+  public void test02Terms04() throws Exception {
+    int[] expdnrs = {}; normalTest1( "kxork*", expdnrs);
+  }
+  public void test02Terms05() throws Exception {
+    int[] expdnrs = {0, 1, 3}; normalTest1( "wor*", expdnrs);
+  }
+  public void test02Terms06() throws Exception {
+    int[] expdnrs = {}; normalTest1( "ab", expdnrs);
+  }
+  
+  public void test02Terms10() throws Exception {
+    int[] expdnrs = {}; normalTest1( "abc?", expdnrs);
+  }
+  public void test02Terms13() throws Exception {
+    int[] expdnrs = {0,1,3}; normalTest1( "word?", expdnrs);
+  }
+  public void test02Terms14() throws Exception {
+    int[] expdnrs = {0,1,3}; normalTest1( "w?rd?", expdnrs);
+  }
+  public void test02Terms20() throws Exception {
+    int[] expdnrs = {0,1,3}; normalTest1( "w*rd?", expdnrs);
+  }
+  public void test02Terms21() throws Exception {
+    int[] expdnrs = {3}; normalTest1( "w*rd??", expdnrs);
+  }
+  public void test02Terms22() throws Exception {
+    int[] expdnrs = {3}; normalTest1( "w*?da?", expdnrs);
+  }
+  public void test02Terms23() throws Exception {
+    int[] expdnrs = {}; normalTest1( "w?da?", expdnrs);
+  }
+  
+  public void test03And01() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "word1 AND word2", expdnrs);
+  }
+  public void test03And02() throws Exception {
+    int[] expdnrs = {3}; normalTest1( "word* and ord*", expdnrs);
+  }
+  public void test03And03() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "and(word1,word2)", expdnrs);
+  }
+  public void test04Or01() throws Exception {
+    int[] expdnrs = {0, 3}; normalTest1( "word1 or word2", expdnrs);
+  }
+  public void test04Or02() throws Exception {
+    int[] expdnrs = {0, 1, 2, 3}; normalTest1( "word* OR ord*", expdnrs);
+  }
+  public void test04Or03() throws Exception {
+    int[] expdnrs = {0, 3}; normalTest1( "OR (word1, word2)", expdnrs);
+  }
+  public void test05Not01() throws Exception {
+    int[] expdnrs = {3}; normalTest1( "word2 NOT word1", expdnrs);
+  }
+  public void test05Not02() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "word2* not ord*", expdnrs);
+  }
+  public void test06AndOr01() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "(word1 or ab)and or(word2,xyz, defg)", expdnrs);
+  }
+  public void test07AndOrNot02() throws Exception {
+    int[] expdnrs = {0}; normalTest1( "or( word2* not ord*, and(xyz,def))", expdnrs);
+  }
+}
diff --git a/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
new file mode 100644
index 0000000..336acf9
--- /dev/null
+++ b/modules/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
@@ -0,0 +1,243 @@
+package org.apache.lucene.queryparser.surround.query;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class Test03Distance extends LuceneTestCase {
+  public static void main(String args[]) {
+    TestRunner.run(new TestSuite(Test03Distance.class));
+  }
+  boolean verbose = false;
+  int maxBasicQueries = 16;
+  
+  String [] exceptionQueries = {
+    "(aa and bb) w cc",
+    "(aa or bb) w (cc and dd)",
+    "(aa opt bb) w cc",
+    "(aa not bb) w cc",
+    "(aa or bb) w (bi:cc)",
+    "(aa or bb) w bi:cc",
+    "(aa or bi:bb) w cc",
+    "(aa or (bi:bb)) w cc",
+    "(aa or (bb and dd)) w cc"
+  };
+  
+  public void test00Exceptions() throws Exception {
+    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    if (m.length() > 0) {
+      fail("No ParseException for:\n" + m);
+    }
+  }
+
+  final String fieldName = "bi";
+
+  String[] docs1 = {
+    "word1 word2 word3",
+    "word4 word5",
+    "ord1 ord2 ord3",
+    "orda1 orda2 orda3 word2 worda3",
+    "a c e a b c"
+  };
+
+  SingleFieldTestDb db1 = new SingleFieldTestDb(random, docs1, fieldName);
+
+  private void distanceTst(String query, int[] expdnrs, SingleFieldTestDb db) throws Exception {
+    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db, fieldName, this,
+                                                new BasicQueryFactory(maxBasicQueries));
+    bqt.setVerbose(verbose);
+    bqt.doTest();
+  }
+
+  public void distanceTest1(String query, int[] expdnrs) throws Exception {
+    distanceTst(query, expdnrs, db1);
+  }
+  
+  public void test0W01() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1 w word2", expdnrs);
+  }
+  public void test0N01() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1 n word2", expdnrs);
+  }
+  public void test0N01r() throws Exception { /* r reverse */
+    int[] expdnrs = {0}; distanceTest1( "word2 n word1", expdnrs);
+  }
+  
+  public void test0W02() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "word2 w word1", expdnrs);
+  }
+  
+  public void test0W03() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "word2 2W word1", expdnrs);
+  }
+  public void test0N03() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word2 2N word1", expdnrs);
+  }
+  public void test0N03r() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1 2N word2", expdnrs);
+  }
+  
+  public void test0W04() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "word2 3w word1", expdnrs);
+  }
+
+  public void test0N04() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word2 3n word1", expdnrs);
+  }
+  public void test0N04r() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1 3n word2", expdnrs);
+  }
+
+  public void test0W05() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "orda1 w orda3", expdnrs);
+  }
+  public void test0W06() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "orda1 2w orda3", expdnrs);
+  }
+  
+  public void test1Wtrunc01() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1* w word2", expdnrs);
+  }
+  public void test1Wtrunc02() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word* w word2", expdnrs);
+  }
+  public void test1Wtrunc02r() throws Exception {
+    int[] expdnrs = {0,3}; distanceTest1( "word2 w word*", expdnrs);
+  }
+  public void test1Ntrunc02() throws Exception {
+    int[] expdnrs = {0,3}; distanceTest1( "word* n word2", expdnrs);
+  }
+  public void test1Ntrunc02r() throws Exception {
+    int[] expdnrs = {0,3}; distanceTest1( "word2 n word*", expdnrs);
+  }
+
+  public void test1Wtrunc03() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1* w word2*", expdnrs);
+  }
+  public void test1Ntrunc03() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word1* N word2*", expdnrs);
+  }
+  
+  public void test1Wtrunc04() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "kxork* w kxor*", expdnrs);
+  }
+  public void test1Ntrunc04() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "kxork* 99n kxor*", expdnrs);
+  }
+
+  public void test1Wtrunc05() throws Exception {
+    int[] expdnrs = {}; distanceTest1( "word2* 2W word1*", expdnrs);
+  }
+  public void test1Ntrunc05() throws Exception {
+    int[] expdnrs = {0}; distanceTest1( "word2* 2N word1*", expdnrs);
+  }
+
+  public void test1Wtrunc06() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "ord* W word*", expdnrs);
+  }
+  public void test1Ntrunc06() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "ord* N word*", expdnrs);
+  }
+  public void test1Ntrunc06r() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "word* N ord*", expdnrs);
+  }
+  
+  public void test1Wtrunc07() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) W word*", expdnrs);
+  }
+  public void test1Wtrunc08() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) W (word2 OR worda3)", expdnrs);
+  }
+  public void test1Wtrunc09() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2W (word2 OR worda3)", expdnrs);
+  }
+  public void test1Ntrunc09() throws Exception {
+    int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2N (word2 OR worda3)", expdnrs);
+  }
+
+  String[] docs2 = {
+    "w1 w2 w3 w4 w5",
+    "w1 w3 w2 w3",
+    ""
+  };
+
+  SingleFieldTestDb db2 = new SingleFieldTestDb(random, docs2, fieldName);
+  
+  public void distanceTest2(String query, int[] expdnrs) throws Exception {
+    distanceTst(query, expdnrs, db2);
+  }
+  
+  public void test2Wprefix01() throws Exception {
+    int[] expdnrs = {0}; distanceTest2( "W (w1, w2, w3)", expdnrs);
+  }
+  public void test2Nprefix01a() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "N(w1, w2, w3)", expdnrs);
+  }
+  public void test2Nprefix01b() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "N(w3, w1, w2)", expdnrs);
+  }
+  
+  public void test2Wprefix02() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "2W(w1,w2,w3)", expdnrs);
+  }
+
+  public void test2Nprefix02a() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
+  }
+  public void test2Nprefix02b() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
+  }
+
+  public void test2Wnested01() throws Exception {
+    int[] expdnrs = {0}; distanceTest2( "w1 W w2 W w3", expdnrs);
+  }
+  public void test2Nnested01() throws Exception {
+    int[] expdnrs = {0}; distanceTest2( "w1 N w2 N w3", expdnrs);
+  }
+  
+  public void test2Wnested02() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "w1 2W w2 2W w3", expdnrs);
+  }
+  public void test2Nnested02() throws Exception {
+    int[] expdnrs = {0,1}; distanceTest2( "w1 2N w2 2N w3", expdnrs);
+  }
+  
+  String[] docs3 = {
+    "low pressure temperature inversion and rain",
+    "when the temperature has a negative height above a depression no precipitation gradient is expected",
+    "when the temperature has a negative height gradient above a depression no precipitation is expected",
+    ""
+  };
+
+  SingleFieldTestDb db3 = new SingleFieldTestDb(random, docs3, fieldName);
+
+  public void distanceTest3(String query, int[] expdnrs) throws Exception {
+    distanceTst(query, expdnrs, db3);
+  }
+
+  public void test3Example01() throws Exception {
+    int[] expdnrs = {0,2}; // query does not match doc 1 because "gradient" is in wrong place there.
+    distanceTest3("50n((low w pressure*) or depression*,"
+                   + "5n(temperat*, (invers* or (negativ* 3n gradient*))),"
+                   + "rain* or precipitat*)",
+                   expdnrs);
+  }
+}

