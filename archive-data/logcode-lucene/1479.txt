GitDiffStart: 275a259b1fa0d94aec95f554c2c7451b8678bd8e | Tue Mar 22 11:52:26 2016 -0400
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
index 2f142ba..e818e1d 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
@@ -83,7 +83,7 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
     // sampling if we get called way too much: don't make gobs of bounding
     // boxes if comparator hits a worst case order (e.g. backwards distance order)
     if (setBottomCounter < 1024 || (setBottomCounter & 0x3F) == 0x3F) {
-      GeoRect box = GeoUtils.circleToBBox(longitude, latitude, haversin2(bottom));
+      GeoRect box = GeoUtils.circleToBBox(latitude, longitude, haversin2(bottom));
       // pre-encode our box to our integer encoding, so we don't have to decode 
       // to double values for uncompetitive hits. This has some cost!
       minLat = LatLonPoint.encodeLatitude(box.minLat);
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
index 8f4b347..5e7a04e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
@@ -75,7 +75,7 @@ final class LatLonPointDistanceQuery extends Query {
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);
+    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);
     // create bounding box(es) for the distance range
     // these are pre-encoded with LatLonPoint's encoding
     final byte minLat[] = new byte[Integer.BYTES];
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index cb98895..68c734e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
@@ -169,13 +169,13 @@ final class LatLonPointInPolygonQuery extends Query {
                              if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {
                                // Cell fully encloses the query
                                return Relation.CELL_CROSSES_QUERY;
-                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,
-                                                                 polyLons, polyLats,
-                                                                 minLon, minLat, maxLon, maxLat)) {
+                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,
+                                                                                polyLats, polyLons,
+                                                                                minLat, maxLat, minLon, maxLon)) {
                                return Relation.CELL_INSIDE_QUERY;
-                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,
-                                                                 polyLons, polyLats,
-                                                                 minLon, minLat, maxLon, maxLat)) {
+                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,
+                                                                                polyLats, polyLons,
+                                                                                minLat, maxLat, minLon, maxLon)) {
                                return Relation.CELL_CROSSES_QUERY;
                              } else {
                                return Relation.CELL_OUTSIDE_QUERY;
@@ -204,7 +204,7 @@ final class LatLonPointInPolygonQuery extends Query {
                 long encoded = docValues.valueAt(i);
                 double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));
                 double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));
-                if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, docLatitude, docLongitude)) {
+                if (GeoRelationUtils.pointInPolygon(polyLats, polyLons, docLatitude, docLongitude)) {
                   return true;
                 }
               }
@@ -289,9 +289,9 @@ final class LatLonPointInPolygonQuery extends Query {
     sb.append(" Points: ");
     for (int i=0; i<polyLons.length; ++i) {
       sb.append("[")
-        .append(polyLons[i])
-        .append(", ")
         .append(polyLats[i])
+        .append(", ")
+        .append(polyLons[i])
         .append("] ");
     }
     return sb.toString();
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
index e12923f..df34940 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
@@ -55,11 +55,11 @@ public class TestLatLonPointQueries extends BaseGeoPointTestCase {
     assert Double.isNaN(pointLat) == false;
 
     if (rect.minLon < rect.maxLon) {
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
     } else {
       // Rect crosses dateline:
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)
-          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)
+        || GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);
     }
   }
 
@@ -82,11 +82,11 @@ public class TestLatLonPointQueries extends BaseGeoPointTestCase {
     
     assert Double.isNaN(pointLat) == false;
     assert rect.crossesDateline() == false;
-    double y[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };
-    double x[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };
+    double polyLats[] = new double[] { rect.minLat, rect.maxLat, rect.maxLat, rect.minLat, rect.minLat };
+    double polyLons[] = new double[] { rect.minLon, rect.minLon, rect.maxLon, rect.maxLon, rect.minLon };
 
     // TODO: separately test this method is 100% correct, here treat it like a black box (like haversin)
-    return GeoRelationUtils.pointInPolygon(x, y, pointLat, pointLon);
+    return GeoRelationUtils.pointInPolygon(polyLats, polyLons, pointLat, pointLon);
   }
 
   @Override
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
index 39f12df..688315a 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
@@ -127,39 +127,39 @@ public final class GeoPointField extends Field {
 
   /** Creates a stored or un-stored GeoPointField
    *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param stored Store.YES if the content should also be stored
    *  @throws IllegalArgumentException if the field name is null.
    */
-  public GeoPointField(String name, double lon, double lat, Store stored) {
-    this(name, lon, lat, getFieldType(stored));
+  public GeoPointField(String name, double lat, double lon, Store stored) {
+    this(name, lat, lon, getFieldType(stored));
   }
 
   /** Creates a stored or un-stored GeoPointField using the specified {@link TermEncoding} method
    *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param termEncoding encoding type to use ({@link TermEncoding#NUMERIC} Terms, or {@link TermEncoding#PREFIX} only Terms)
    *  @param stored Store.YES if the content should also be stored
    *  @throws IllegalArgumentException if the field name is null.
    */
   @Deprecated
-  public GeoPointField(String name, double lon, double lat, TermEncoding termEncoding, Store stored) {
-    this(name, lon, lat, getFieldType(termEncoding, stored));
+  public GeoPointField(String name, double lat, double lon, TermEncoding termEncoding, Store stored) {
+    this(name, lat, lon, getFieldType(termEncoding, stored));
   }
 
   /** Expert: allows you to customize the {@link
    *  FieldType}.
    *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
    *  @param type customized field type: must have {@link FieldType#numericType()}
    *         of {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}.
    *  @throws IllegalArgumentException if the field name or type is null, or
    *          if the field type does not have a LONG numericType()
    */
-  public GeoPointField(String name, double lon, double lat, FieldType type) {
+  public GeoPointField(String name, double lat, double lon, FieldType type) {
     super(name, type);
 
     // field must be indexed
@@ -181,7 +181,7 @@ public final class GeoPointField extends Field {
     }
 
     // set field data
-    fieldsData = GeoEncodingUtils.mortonHash(lon, lat);
+    fieldsData = GeoEncodingUtils.mortonHash(lat, lon);
   }
 
   private static FieldType getFieldType(Store stored) {
@@ -226,25 +226,25 @@ public final class GeoPointField extends Field {
     return reuse;
   }
 
-  /** access longitude value */
-  public double getLon() {
-    return GeoEncodingUtils.mortonUnhashLon((long) fieldsData);
-  }
-
   /** access latitude value */
   public double getLat() {
     return GeoEncodingUtils.mortonUnhashLat((long) fieldsData);
   }
 
+  /** access longitude value */
+  public double getLon() {
+    return GeoEncodingUtils.mortonUnhashLon((long) fieldsData);
+  }
+
   @Override
   public String toString() {
     if (fieldsData == null) {
       return null;
     }
     StringBuilder sb = new StringBuilder();
-    sb.append(GeoEncodingUtils.mortonUnhashLon((long) fieldsData));
-    sb.append(',');
     sb.append(GeoEncodingUtils.mortonUnhashLat((long) fieldsData));
+    sb.append(',');
+    sb.append(GeoEncodingUtils.mortonUnhashLon((long) fieldsData));
     return sb.toString();
   }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
index 4a70ea3..66216ab 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
@@ -56,18 +56,18 @@ import static org.apache.lucene.spatial.geopoint.document.GeoPointField.PRECISIO
  *
  * <pre class="prettyprint">
  *   // using prefix terms
- *   GeoPointField geoPointField = new GeoPointField(fieldName1, lon, lat, GeoPointField.PREFIX_TYPE_NOT_STORED);
+ *   GeoPointField geoPointField = new GeoPointField(fieldName1, lat, lon, GeoPointField.PREFIX_TYPE_NOT_STORED);
  *   document.add(geoPointField);
  *
  *   // query by bounding box (default uses TermEncoding.PREFIX)
  *   Query q = new GeoPointInBBoxQuery(fieldName1, minLon, minLat, maxLon, maxLat);
  *
  *   // using numeric terms
- *   geoPointField = new GeoPointField(fieldName2, lon, lat, GeoPointField.NUMERIC_TYPE_NOT_STORED);
+ *   geoPointField = new GeoPointField(fieldName2, lat, lon, GeoPointField.NUMERIC_TYPE_NOT_STORED);
  *   document.add(geoPointField);
  *
  *   // query by distance (requires TermEncoding.NUMERIC)
- *   q = new GeoPointDistanceQuery(fieldName2, TermEncoding.NUMERIC, centerLon, centerLat, radiusMeters);
+ *   q = new GeoPointDistanceQuery(fieldName2, TermEncoding.NUMERIC, centerLat, centerLon, radiusMeters);
  * </pre>
  *
  * @lucene.experimental
@@ -230,4 +230,4 @@ final class GeoPointTokenStream extends TokenStream {
   public String toString() {
     return getClass().getSimpleName() + "(precisionStep=" + PRECISION_STEP + " shift=" + geoPointTermAtt.getShift() + ")";
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java
index a513b3d..2486852 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java
@@ -42,19 +42,19 @@ import org.apache.lucene.spatial.util.GeoUtils;
  *
  * @lucene.experimental */
 public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
-  /** longitude value (in degrees) for query location */
-  protected final double centerLon;
   /** latitude value (in degrees) for query location */
   protected final double centerLat;
-  /** distance (in meters) from lon, lat center location */
+  /** longitude value (in degrees) for query location */
+  protected final double centerLon;
+  /** distance (in meters) from lat, lon center location */
   protected final double radiusMeters;
 
   /**
    * Constructs a Query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a
    * distance (in meters) from a given point
    **/
-  public GeoPointDistanceQuery(final String field, final double centerLon, final double centerLat, final double radiusMeters) {
-    this(field, TermEncoding.PREFIX, centerLon, centerLat, radiusMeters);
+  public GeoPointDistanceQuery(final String field, final double centerLat, final double centerLon, final double radiusMeters) {
+    this(field, TermEncoding.PREFIX, centerLat, centerLon, radiusMeters);
   }
 
   /**
@@ -62,38 +62,38 @@ public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
    * distance (in meters) from a given point. Accepts optional
    * {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding} parameter
    **/
-  public GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final double centerLon, final double centerLat, final double radiusMeters) {
-    this(field, termEncoding, GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters), centerLon, centerLat, radiusMeters);
+  public GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final double centerLat, final double centerLon, final double radiusMeters) {
+    this(field, termEncoding, GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters), centerLat, centerLon, radiusMeters);
   }
 
-  private GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final GeoRect bbox, final double centerLon,
-                                final double centerLat, final double radiusMeters) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
+  private GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final GeoRect bbox,
+                                 final double centerLat, final double centerLon, final double radiusMeters) {
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
     {
       // check longitudinal overlap (restrict distance to maximum longitudinal radius)
       // todo this restriction technically shouldn't be needed,
       // its only purpose is to ensure the bounding box doesn't self overlap.
-      final double maxRadius = GeoDistanceUtils.maxRadialDistanceMeters(centerLon, centerLat);
+      final double maxRadius = GeoDistanceUtils.maxRadialDistanceMeters(centerLat, centerLon);
       if (radiusMeters > maxRadius) {
         throw new IllegalArgumentException("radiusMeters " + radiusMeters + " exceeds maxRadius [" + maxRadius
-            + "] at location [" + centerLon + " " + centerLat + "]");
+            + "] at location [" + centerLat + " " + centerLon + "]");
       }
     }
 
-    if (GeoUtils.isValidLon(centerLon) == false) {
-      throw new IllegalArgumentException("invalid centerLon " + centerLon);
-    }
-
     if (GeoUtils.isValidLat(centerLat) == false) {
       throw new IllegalArgumentException("invalid centerLat " + centerLat);
     }
 
+    if (GeoUtils.isValidLon(centerLon) == false) {
+      throw new IllegalArgumentException("invalid centerLon " + centerLon);
+    }
+
     if (radiusMeters <= 0.0) {
       throw new IllegalArgumentException("invalid radiusMeters " + radiusMeters);
     }
 
-    this.centerLon = centerLon;
     this.centerLat = centerLat;
+    this.centerLon = centerLon;
     this.radiusMeters = radiusMeters;
   }
 
@@ -110,7 +110,7 @@ public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
         unwrappedLon += -360.0D;
       }
       GeoPointDistanceQueryImpl left = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
-          new GeoRect(GeoUtils.MIN_LON_INCL, maxLon, minLat, maxLat));
+                                                                     new GeoRect(minLat, maxLat, GeoUtils.MIN_LON_INCL, maxLon));
       bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
 
       if (unwrappedLon < maxLon) {
@@ -118,13 +118,13 @@ public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
         unwrappedLon += 360.0D;
       }
       GeoPointDistanceQueryImpl right = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
-          new GeoRect(minLon, GeoUtils.MAX_LON_INCL, minLat, maxLat));
+                                                                      new GeoRect(minLat, maxLat, minLon, GeoUtils.MAX_LON_INCL));
       bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
 
       return bqb.build();
     }
     return new GeoPointDistanceQueryImpl(field, termEncoding, this, centerLon,
-        new GeoRect(this.minLon, this.maxLon, this.minLat, this.maxLat));
+                                         new GeoRect(this.minLat, this.maxLat, this.minLon, this.maxLon));
   }
 
   @Override
@@ -166,9 +166,9 @@ public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
       sb.append(':');
     }
     return sb.append( " Center: [")
-        .append(centerLon)
-        .append(',')
         .append(centerLat)
+        .append(',')
+        .append(centerLon)
         .append(']')
         .append(" Distance: ")
         .append(radiusMeters)
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
index 6a54e23..8f50db5 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
@@ -32,7 +32,7 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
 
   GeoPointDistanceQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointDistanceQuery q,
                             final double centerLonUnwrapped, final GeoRect bbox) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
     distanceQuery = q;
     centerLon = centerLonUnwrapped;
   }
@@ -53,20 +53,21 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
     }
 
     @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrossesCircle(minLon, minLat, maxLon, maxLat,
-          centerLon, distanceQuery.centerLat, distanceQuery.radiusMeters, true);
+    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrossesCircle(minLat, maxLat, minLon, maxLon,
+                                                distanceQuery.centerLat, centerLon, distanceQuery.radiusMeters, true);
     }
 
     @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithinCircle(minLon, minLat, maxLon, maxLat,
-          centerLon, distanceQuery.centerLat, distanceQuery.radiusMeters, true);
+    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinCircle(minLat, maxLat, minLon, maxLon,
+                                               distanceQuery.centerLat, centerLon,
+                                               distanceQuery.radiusMeters, true);
     }
 
     @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellCrosses(minLon, minLat, maxLon, maxLat);
+    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellCrosses(minLat, maxLat, minLon, maxLon);
     }
 
     /**
@@ -76,7 +77,7 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
      * {@link org.apache.lucene.util.SloppyMath#haversinMeters(double, double, double, double)} method.
      */
     @Override
-    protected boolean postFilter(final double lon, final double lat) {
+    protected boolean postFilter(final double lat, final double lon) {
       return SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, lat, lon) <= distanceQuery.radiusMeters;
     }
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java
index f24aa6a..bdfbb88 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java
@@ -37,9 +37,9 @@ public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
    * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a minimum / maximum
    * distance (in meters) range from a given point
    */
-  public GeoPointDistanceRangeQuery(final String field, final double centerLon, final double centerLat,
+  public GeoPointDistanceRangeQuery(final String field, final double centerLat, final double centerLon,
                                     final double minRadiusMeters, final double maxRadiusMeters) {
-    this(field, TermEncoding.PREFIX, centerLon, centerLat, minRadiusMeters, maxRadiusMeters);
+    this(field, TermEncoding.PREFIX, centerLat, centerLon, minRadiusMeters, maxRadiusMeters);
   }
 
   /**
@@ -47,9 +47,9 @@ public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
    * distance (in meters) range from a given point. Accepts an optional
    * {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding}
    */
-  public GeoPointDistanceRangeQuery(final String field, final TermEncoding termEncoding, final double centerLon, final double centerLat,
+  public GeoPointDistanceRangeQuery(final String field, final TermEncoding termEncoding, final double centerLat, final double centerLon,
                                     final double minRadiusMeters, final double maxRadius) {
-    super(field, termEncoding, centerLon, centerLat, maxRadius);
+    super(field, termEncoding, centerLat, centerLon, maxRadius);
     this.minRadiusMeters = minRadiusMeters;
   }
 
@@ -64,7 +64,7 @@ public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
     BooleanQuery.Builder bqb = new BooleanQuery.Builder();
 
     // create a new exclusion query
-    GeoPointDistanceQuery exclude = new GeoPointDistanceQuery(field, termEncoding, centerLon, centerLat, minRadiusMeters);
+    GeoPointDistanceQuery exclude = new GeoPointDistanceQuery(field, termEncoding, centerLat, centerLon, minRadiusMeters);
     // full map search
 //    if (radiusMeters >= GeoProjectionUtils.SEMIMINOR_AXIS) {
 //      bqb.add(new BooleanClause(new GeoPointInBBoxQuery(this.field, -180.0, -90.0, 180.0, 90.0), BooleanClause.Occur.MUST));
@@ -87,9 +87,9 @@ public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
       sb.append(':');
     }
     return sb.append( " Center: [")
-        .append(centerLon)
-        .append(',')
         .append(centerLat)
+        .append(',')
+        .append(centerLon)
         .append(']')
         .append(" From Distance: ")
         .append(minRadiusMeters)
@@ -98,14 +98,14 @@ public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
         .append(radiusMeters)
         .append(" m")
         .append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
         .append(minLat)
+        .append(',')
+        .append(minLon)
         .append(']')
         .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
         .append(maxLat)
+        .append(',')
+        .append(maxLon)
         .append("]")
         .toString();
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
index 32c0aec..f81f37e 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
@@ -47,14 +47,14 @@ import org.apache.lucene.spatial.util.GeoUtils;
 public class GeoPointInBBoxQuery extends Query {
   /** field name */
   protected final String field;
-  /** minimum longitude value (in degrees) */
-  protected final double minLon;
   /** minimum latitude value (in degrees) */
   protected final double minLat;
-  /** maximum longitude value (in degrees) */
-  protected final double maxLon;
+  /** minimum longitude value (in degrees) */
+  protected final double minLon;
   /** maximum latitude value (in degrees) */
   protected final double maxLat;
+  /** maximum longitude value (in degrees) */
+  protected final double maxLon;
   /** term encoding enum to define how the points are encoded (PREFIX or NUMERIC) */
   protected final TermEncoding termEncoding;
 
@@ -62,28 +62,28 @@ public class GeoPointInBBoxQuery extends Query {
    * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types that fall within a
    * defined bounding box
    */
-  public GeoPointInBBoxQuery(final String field, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    this(field, TermEncoding.PREFIX, minLon, minLat, maxLon, maxLat);
+  public GeoPointInBBoxQuery(final String field, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    this(field, TermEncoding.PREFIX, minLat, maxLat, minLon, maxLon);
   }
 
   /**
    * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types that fall within a
    * defined bounding box. Accepts optional {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding} parameter
    */
-  public GeoPointInBBoxQuery(final String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
+  public GeoPointInBBoxQuery(final String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
     this.field = field;
-    this.minLon = minLon;
     this.minLat = minLat;
-    this.maxLon = maxLon;
     this.maxLat = maxLat;
+    this.minLon = minLon;
+    this.maxLon = maxLon;
     this.termEncoding = termEncoding;
   }
 
   @Override
   public Query rewrite(IndexReader reader) {
     // short-circuit to match all if specifying the whole map
-    if (minLon == GeoUtils.MIN_LON_INCL && maxLon == GeoUtils.MAX_LON_INCL
-        && minLat == GeoUtils.MIN_LAT_INCL && maxLat == GeoUtils.MAX_LAT_INCL) {
+    if (minLat == GeoUtils.MIN_LAT_INCL && maxLat == GeoUtils.MAX_LAT_INCL &&
+        minLon == GeoUtils.MIN_LON_INCL && maxLon == GeoUtils.MAX_LON_INCL) {
       // FieldValueQuery is valid since DocValues are *required* for GeoPointField
       return new FieldValueQuery(field);
     }
@@ -91,13 +91,13 @@ public class GeoPointInBBoxQuery extends Query {
     if (maxLon < minLon) {
       BooleanQuery.Builder bqb = new BooleanQuery.Builder();
 
-      GeoPointInBBoxQueryImpl left = new GeoPointInBBoxQueryImpl(field, termEncoding, -180.0D, minLat, maxLon, maxLat);
+      GeoPointInBBoxQueryImpl left = new GeoPointInBBoxQueryImpl(field, termEncoding, minLat, maxLat, -180.0D, maxLon);
       bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
-      GeoPointInBBoxQueryImpl right = new GeoPointInBBoxQueryImpl(field, termEncoding, minLon, minLat, 180.0D, maxLat);
+      GeoPointInBBoxQueryImpl right = new GeoPointInBBoxQueryImpl(field, termEncoding, minLat, maxLat, minLon, 180.0D);
       bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
       return bqb.build();
     }
-    return new GeoPointInBBoxQueryImpl(field, termEncoding, minLon, minLat, maxLon, maxLat);
+    return new GeoPointInBBoxQueryImpl(field, termEncoding, minLat, maxLat, minLon, maxLon);
   }
 
   @Override
@@ -111,14 +111,14 @@ public class GeoPointInBBoxQuery extends Query {
       sb.append(':');
     }
     return sb.append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
         .append(minLat)
+        .append(',')
+        .append(minLon)
         .append(']')
         .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
         .append(maxLat)
+        .append(',')
+        .append(maxLon)
         .append("]")
         .toString();
   }
@@ -131,10 +131,10 @@ public class GeoPointInBBoxQuery extends Query {
 
     GeoPointInBBoxQuery that = (GeoPointInBBoxQuery) o;
 
-    if (Double.compare(that.maxLat, maxLat) != 0) return false;
-    if (Double.compare(that.maxLon, maxLon) != 0) return false;
     if (Double.compare(that.minLat, minLat) != 0) return false;
+    if (Double.compare(that.maxLat, maxLat) != 0) return false;
     if (Double.compare(that.minLon, minLon) != 0) return false;
+    if (Double.compare(that.maxLon, maxLon) != 0) return false;
     if (!field.equals(that.field)) return false;
 
     return true;
@@ -145,14 +145,14 @@ public class GeoPointInBBoxQuery extends Query {
     int result = super.hashCode();
     long temp;
     result = 31 * result + field.hashCode();
-    temp = Double.doubleToLongBits(minLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
     temp = Double.doubleToLongBits(minLat);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
     temp = Double.doubleToLongBits(maxLat);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(minLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
     return result;
   }
 
@@ -161,23 +161,23 @@ public class GeoPointInBBoxQuery extends Query {
     return this.field;
   }
 
-  /** getter method for retrieving the minimum longitude (in degrees) */
-  public final double getMinLon() {
-    return this.minLon;
-  }
-
   /** getter method for retrieving the minimum latitude (in degrees) */
   public final double getMinLat() {
     return this.minLat;
   }
 
-  /** getter method for retrieving the maximum longitude (in degrees) */
-  public final double getMaxLon() {
-    return this.maxLon;
-  }
-
   /** getter method for retrieving the maximum latitude (in degrees) */
   public final double getMaxLat() {
     return this.maxLat;
   }
+
+  /** getter method for retrieving the minimum longitude (in degrees) */
+  public final double getMinLon() {
+    return this.minLon;
+  }
+
+  /** getter method for retrieving the maximum longitude (in degrees) */
+  public final double getMaxLon() {
+    return this.maxLon;
+  }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
index 107b136..c19e6d2 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
@@ -36,8 +36,8 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
    * @param maxLon upper longitude (x) value of the bounding box
    * @param maxLat upper latitude (y) value of the bounding box
    */
-  GeoPointInBBoxQueryImpl(final String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    super(field, termEncoding, minLon, minLat, maxLon, maxLat);
+  GeoPointInBBoxQueryImpl(final String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    super(field, termEncoding, minLat, maxLat, minLon, maxLon);
   }
 
   @Override
@@ -50,8 +50,8 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
     final short shiftFactor;
 
     // compute diagonal radius
-    double midLon = (minLon + maxLon) * 0.5;
     double midLat = (minLat + maxLat) * 0.5;
+    double midLon = (minLon + maxLon) * 0.5;
 
     if (SloppyMath.haversinMeters(minLat, minLon, midLat, midLon) > 1000000) {
       shiftFactor = 5;
@@ -76,26 +76,29 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
      * Determine whether the quad-cell crosses the shape
      */
     @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrosses(minLon, minLat, maxLon, maxLat, GeoPointInBBoxQueryImpl.this.minLon,
-          GeoPointInBBoxQueryImpl.this.minLat, GeoPointInBBoxQueryImpl.this.maxLon, GeoPointInBBoxQueryImpl.this.maxLat);    }
+    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrosses(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImpl.this.minLat,
+                                          GeoPointInBBoxQueryImpl.this.maxLat, GeoPointInBBoxQueryImpl.this.minLon, GeoPointInBBoxQueryImpl.this.maxLon);
+    }
 
     /**
      * Determine whether quad-cell is within the shape
      */
     @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithin(minLon, minLat, maxLon, maxLat, GeoPointInBBoxQueryImpl.this.minLon,
-          GeoPointInBBoxQueryImpl.this.minLat, GeoPointInBBoxQueryImpl.this.maxLon, GeoPointInBBoxQueryImpl.this.maxLat);    }
+    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithin(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImpl.this.minLat,
+                                         GeoPointInBBoxQueryImpl.this.maxLat,
+                                         GeoPointInBBoxQueryImpl.this.minLon, GeoPointInBBoxQueryImpl.this.maxLon);
+    }
 
     @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellIntersectsMBR(minLon, minLat, maxLon, maxLat);
+    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellIntersectsMBR(minLat, maxLat, minLon, maxLon);
     }
 
     @Override
-    protected boolean postFilter(final double lon, final double lat) {
-      return GeoRelationUtils.pointInRectPrecise(lon, lat, minLon, minLat, maxLon, maxLat);
+    protected boolean postFilter(final double lat, final double lon) {
+      return GeoRelationUtils.pointInRectPrecise(lat, lon, minLat, maxLat, minLon, maxLon);
     }
   }
 
@@ -108,10 +111,10 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
 
     GeoPointInBBoxQueryImpl that = (GeoPointInBBoxQueryImpl) o;
 
-    if (Double.compare(that.maxLat, maxLat) != 0) return false;
-    if (Double.compare(that.maxLon, maxLon) != 0) return false;
     if (Double.compare(that.minLat, minLat) != 0) return false;
+    if (Double.compare(that.maxLat, maxLat) != 0) return false;
     if (Double.compare(that.minLon, minLon) != 0) return false;
+    if (Double.compare(that.maxLon, maxLon) != 0) return false;
 
     return true;
   }
@@ -120,14 +123,14 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
   public int hashCode() {
     int result = super.hashCode();
     long temp;
-    temp = Double.doubleToLongBits(minLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
     temp = Double.doubleToLongBits(minLat);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
     temp = Double.doubleToLongBits(maxLat);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(minLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
     return result;
   }
 
@@ -142,14 +145,14 @@ class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
       sb.append(':');
     }
     return sb.append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
         .append(minLat)
+        .append(',')
+        .append(minLon)
         .append(']')
         .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
         .append(maxLat)
+        .append(',')
+        .append(maxLon)
         .append("]")
         .toString();
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
index ef8c2ff..f43aaf2 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
@@ -47,30 +47,30 @@ import org.apache.lucene.spatial.util.GeoUtils;
 public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
   // polygon position arrays - this avoids the use of any objects or
   // or geo library dependencies
-  /** array of x (longitude) values (in degrees) */
-  protected final double[] x;
   /** array of y (latitude) values (in degrees) */
-  protected final double[] y;
+  protected final double[] polyLats;
+  /** array of x (longitude) values (in degrees) */
+  protected final double[] polyLons;
 
   /**
    * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} terms
    * that fall within or on the boundary of the polygon defined by the input parameters.
    */
-  public GeoPointInPolygonQuery(final String field, final double[] polyLons, final double[] polyLats) {
-    this(field, TermEncoding.PREFIX, GeoUtils.polyToBBox(polyLons, polyLats), polyLons, polyLats);
+  public GeoPointInPolygonQuery(final String field, final double[] polyLats, final double[] polyLons) {
+    this(field, TermEncoding.PREFIX, GeoUtils.polyToBBox(polyLats, polyLons), polyLats, polyLons);
   }
 
   /**
    * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} terms
    * that fall within or on the boundary of the polygon defined by the input parameters.
    */
-  public GeoPointInPolygonQuery(final String field, final TermEncoding termEncoding, final double[] polyLons, final double[] polyLats) {
-    this(field, termEncoding, GeoUtils.polyToBBox(polyLons, polyLats), polyLons, polyLats);
+  public GeoPointInPolygonQuery(final String field, final TermEncoding termEncoding, final double[] polyLats, final double[] polyLons) {
+    this(field, termEncoding, GeoUtils.polyToBBox(polyLats, polyLons), polyLats, polyLons);
   }
 
   /** Common constructor, used only internally. */
-  private GeoPointInPolygonQuery(final String field, TermEncoding termEncoding, GeoRect bbox, final double[] polyLons, final double[] polyLats) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
+  private GeoPointInPolygonQuery(final String field, TermEncoding termEncoding, GeoRect bbox, final double[] polyLats, final double[] polyLons) {
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
     if (polyLats.length != polyLons.length) {
       throw new IllegalArgumentException("polyLats and polyLons must be equal length");
     }
@@ -84,14 +84,14 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
       throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
     }
 
-    this.x = polyLons;
-    this.y = polyLats;
+    this.polyLons = polyLons;
+    this.polyLats = polyLats;
   }
 
   /** throw exception if trying to change rewrite method */
   @Override
   public Query rewrite(IndexReader reader) {
-    return new GeoPointInPolygonQueryImpl(field, termEncoding, this, this.minLon, this.minLat, this.maxLon, this.maxLat);
+    return new GeoPointInPolygonQueryImpl(field, termEncoding, this, this.minLat, this.maxLat, this.minLon, this.maxLon);
   }
 
   @Override
@@ -102,8 +102,8 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
 
     GeoPointInPolygonQuery that = (GeoPointInPolygonQuery) o;
 
-    if (!Arrays.equals(x, that.x)) return false;
-    if (!Arrays.equals(y, that.y)) return false;
+    if (!Arrays.equals(polyLats, that.polyLats)) return false;
+    if (!Arrays.equals(polyLons, that.polyLons)) return false;
 
     return true;
   }
@@ -111,15 +111,15 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
   @Override
   public int hashCode() {
     int result = super.hashCode();
-    result = 31 * result + (x != null ? Arrays.hashCode(x) : 0);
-    result = 31 * result + (y != null ? Arrays.hashCode(y) : 0);
+    result = 31 * result + (polyLats != null ? Arrays.hashCode(polyLats) : 0);
+    result = 31 * result + (polyLons != null ? Arrays.hashCode(polyLons) : 0);
     return result;
   }
 
   /** print out this polygon query */
   @Override
   public String toString(String field) {
-    assert x.length == y.length;
+    assert polyLats.length == polyLons.length;
 
     final StringBuilder sb = new StringBuilder();
     sb.append(getClass().getSimpleName());
@@ -130,11 +130,11 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
       sb.append(':');
     }
     sb.append(" Points: ");
-    for (int i=0; i<x.length; ++i) {
+    for (int i=0; i<polyLats.length; ++i) {
       sb.append("[")
-          .append(x[i])
+          .append(polyLats[i])
           .append(", ")
-          .append(y[i])
+          .append(polyLons[i])
           .append("] ");
     }
 
@@ -146,7 +146,7 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
    * The returned array is not a copy so do not change it!
    */
   public double[] getLons() {
-    return this.x;
+    return this.polyLons;
   }
 
   /**
@@ -154,6 +154,6 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
    * The returned array is not a copy so do not change it!
    */
   public double[] getLats() {
-    return this.y;
+    return this.polyLats;
   }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
index 35a3950..acace24 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
@@ -28,8 +28,8 @@ final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
   private final GeoPointInPolygonQuery polygonQuery;
 
   GeoPointInPolygonQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointInPolygonQuery q,
-                             final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    super(field, termEncoding, minLon, minLat, maxLon, maxLat);
+                             final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    super(field, termEncoding, minLat, maxLat, minLon, maxLon);
     polygonQuery = q;
   }
 
@@ -53,21 +53,21 @@ final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
     }
 
     @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrossesPolyApprox(minLon, minLat, maxLon, maxLat, polygonQuery.x, polygonQuery.y,
-          polygonQuery.minLon, polygonQuery.minLat, polygonQuery.maxLon, polygonQuery.maxLat);
+    protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrossesPolyApprox(minLat, maxLat, minLon, maxLon, polygonQuery.polyLats, polygonQuery.polyLons,
+                                                    polygonQuery.minLat, polygonQuery.maxLat, polygonQuery.minLon, polygonQuery.maxLon);
     }
 
     @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithinPolyApprox(minLon, minLat, maxLon, maxLat, polygonQuery.x, polygonQuery.y,
-          polygonQuery.minLon, polygonQuery.minLat, polygonQuery.maxLon, polygonQuery.maxLat);
+    protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinPolyApprox(minLat, maxLat, minLon, maxLon, polygonQuery.polyLats, polygonQuery.polyLons,
+                                                   polygonQuery.minLat, polygonQuery.maxLat, polygonQuery.minLon, polygonQuery.maxLon);
     }
 
     @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellContains(minLon, minLat, maxLon, maxLat) || cellWithin(minLon, minLat, maxLon, maxLat)
-          || cellCrosses(minLon, minLat, maxLon, maxLat);
+    protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellContains(minLat, maxLat, minLon, maxLon) || cellWithin(minLat, maxLat, minLon, maxLon)
+        || cellCrosses(minLat, maxLat, minLon, maxLon);
     }
 
     /**
@@ -78,8 +78,8 @@ final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
      * {@link org.apache.lucene.spatial.util.GeoRelationUtils#pointInPolygon} method.
      */
     @Override
-    protected boolean postFilter(final double lon, final double lat) {
-      return GeoRelationUtils.pointInPolygon(polygonQuery.x, polygonQuery.y, lat, lon);
+    protected boolean postFilter(final double lat, final double lon) {
+      return GeoRelationUtils.pointInPolygon(polygonQuery.polyLats, polygonQuery.polyLons, lat, lon);
     }
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
index edbd53d..a63c4d6 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
@@ -52,28 +52,28 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
    * Constructs a query matching terms that cannot be represented with a single
    * Term.
    */
-  public GeoPointMultiTermQuery(String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
+  public GeoPointMultiTermQuery(String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
     super(field);
 
-    if (GeoUtils.isValidLon(minLon) == false) {
-      throw new IllegalArgumentException("invalid minLon " + minLon);
-    }
-    if (GeoUtils.isValidLon(maxLon) == false) {
-      throw new IllegalArgumentException("invalid maxLon " + maxLon);
-    }
     if (GeoUtils.isValidLat(minLat) == false) {
       throw new IllegalArgumentException("invalid minLat " + minLat);
     }
     if (GeoUtils.isValidLat(maxLat) == false) {
       throw new IllegalArgumentException("invalid maxLat " + maxLat);
     }
+    if (GeoUtils.isValidLon(minLon) == false) {
+      throw new IllegalArgumentException("invalid minLon " + minLon);
+    }
+    if (GeoUtils.isValidLon(maxLon) == false) {
+      throw new IllegalArgumentException("invalid maxLon " + maxLon);
+    }
 
-    final long minHash = GeoEncodingUtils.mortonHash(minLon, minLat);
-    final long maxHash = GeoEncodingUtils.mortonHash(maxLon, maxLat);
-    this.minLon = GeoEncodingUtils.mortonUnhashLon(minHash);
+    final long minHash = GeoEncodingUtils.mortonHash(minLat, minLon);
+    final long maxHash = GeoEncodingUtils.mortonHash(maxLat, maxLon);
     this.minLat = GeoEncodingUtils.mortonUnhashLat(minHash);
-    this.maxLon = GeoEncodingUtils.mortonUnhashLon(maxHash);
     this.maxLat = GeoEncodingUtils.mortonUnhashLat(maxHash);
+    this.minLon = GeoEncodingUtils.mortonUnhashLon(minHash);
+    this.maxLon = GeoEncodingUtils.mortonUnhashLon(maxHash);
 
     this.maxShift = computeMaxShift();
     this.termEncoding = termEncoding;
@@ -133,34 +133,34 @@ abstract class GeoPointMultiTermQuery extends MultiTermQuery {
     /**
      * Primary driver for cells intersecting shape boundaries
      */
-    protected boolean cellIntersectsMBR(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectIntersects(minLon, minLat, maxLon, maxLat, geoPointQuery.minLon, geoPointQuery.minLat,
-          geoPointQuery.maxLon, geoPointQuery.maxLat);
+    protected boolean cellIntersectsMBR(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectIntersects(minLat, maxLat, minLon, maxLon, geoPointQuery.minLat, geoPointQuery.maxLat,
+                                             geoPointQuery.minLon, geoPointQuery.maxLon);
     }
 
     /**
      * Return whether quad-cell contains the bounding box of this shape
      */
-    protected boolean cellContains(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithin(geoPointQuery.minLon, geoPointQuery.minLat, geoPointQuery.maxLon,
-          geoPointQuery.maxLat, minLon, minLat, maxLon, maxLat);
+    protected boolean cellContains(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithin(geoPointQuery.minLat, geoPointQuery.maxLat, geoPointQuery.minLon,
+                                         geoPointQuery.maxLon, minLat, maxLat, minLon, maxLon);
     }
 
     /**
      * Determine whether the quad-cell crosses the shape
      */
-    abstract protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat);
+    abstract protected boolean cellCrosses(final double minLat, final double maxLat, final double minLon, final double maxLon);
 
     /**
      * Determine whether quad-cell is within the shape
      */
-    abstract protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat);
+    abstract protected boolean cellWithin(final double minLat, final double maxLat, final double minLon, final double maxLon);
 
     /**
      * Default shape is a rectangle, so this returns the same as {@code cellIntersectsMBR}
      */
-    abstract protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat);
+    abstract protected boolean cellIntersectsShape(final double minLat, final double maxLat, final double minLon, final double maxLon);
 
-    abstract protected boolean postFilter(final double lon, final double lat);
+    abstract protected boolean postFilter(final double lat, final double lon);
   }
 }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
index 120df7d..071ab1e 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
@@ -87,8 +87,8 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
     final short level = (short)((GeoEncodingUtils.BITS<<1)-res>>>1);
 
     // if cell is within and a factor of the precision step, or it crosses the edge of the shape add the range
-    final boolean within = res % GeoPointField.PRECISION_STEP == 0 && relationImpl.cellWithin(minLon, minLat, maxLon, maxLat);
-    if (within || (level == DETAIL_LEVEL && relationImpl.cellIntersectsShape(minLon, minLat, maxLon, maxLat))) {
+    final boolean within = res % GeoPointField.PRECISION_STEP == 0 && relationImpl.cellWithin(minLat, maxLat, minLon, maxLon);
+    if (within || (level == DETAIL_LEVEL && relationImpl.cellIntersectsShape(minLat, maxLat, minLon, maxLon))) {
       final short nextRes = (short)(res-1);
       if (nextRes % GeoPointField.PRECISION_STEP == 0) {
         rangeBounds.add(new Range(start, nextRes, !within));
@@ -96,7 +96,7 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
       } else {
         rangeBounds.add(new Range(start, res, !within));
       }
-    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBR(minLon, minLat, maxLon, maxLat)) {
+    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBR(minLat, maxLat, minLon, maxLon)) {
       computeRange(start, (short) (res - 1));
     }
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
index fbaf68e..eeb58b2 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
@@ -58,7 +58,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
 
   public GeoPointPrefixTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
     super(tenum, query);
-    this.start = mortonHash(query.minLon, query.minLat);
+    this.start = mortonHash(query.minLat, query.minLon);
     this.currentRange = new Range(0, shift, true);
     // start shift at maxShift value (from computeMaxShift)
     this.shift = maxShift;
@@ -67,12 +67,12 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
     this.currEnd = currStart | mask;
   }
 
-  private boolean within(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    return relationImpl.cellWithin(minLon, minLat, maxLon, maxLat);
+  private boolean within(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    return relationImpl.cellWithin(minLat, maxLat, minLon, maxLon);
   }
 
-  private boolean boundary(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    return shift == maxShift && relationImpl.cellIntersectsShape(minLon, minLat, maxLon, maxLat);
+  private boolean boundary(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    return shift == maxShift && relationImpl.cellIntersectsShape(minLat, maxLat, minLon, maxLon);
   }
 
   private boolean nextWithin() {
@@ -100,7 +100,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
       maxLat = mortonUnhashLat(currEnd);
 
       // within or a boundary
-      if ((isWithin = within(minLon, minLat, maxLon, maxLat) == true) || boundary(minLon, minLat, maxLon, maxLat) == true) {
+      if ((isWithin = within(minLat, maxLat, minLon, maxLon) == true) || boundary(minLat, maxLat, minLon, maxLon) == true) {
         final int m;
         if (isWithin == false || (m = shift % GeoPointField.PRECISION_STEP) == 0) {
           setNextRange(isWithin == false);
@@ -116,7 +116,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
       }
 
       // within cell but not at a depth factor of PRECISION_STEP
-      if (isWithin == true || (relationImpl.cellIntersectsMBR(minLon, minLat, maxLon , maxLat) == true && shift != maxShift)) {
+      if (isWithin == true || (relationImpl.cellIntersectsMBR(minLat, maxLat, minLon, maxLon) == true && shift != maxShift)) {
         // descend: currStart need not change since shift handles end of range
         currEnd = currStart | (1L<<--shift) - 1;
       } else {
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
index 6eea8df..7e97f16 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
@@ -140,7 +140,7 @@ final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQu
               int count = sdv.count();
               for (int i = 0; i < count; i++) {
                 long hash = sdv.valueAt(i);
-                if (termsEnum.postFilter(mortonUnhashLon(hash), mortonUnhashLat(hash))) {
+                if (termsEnum.postFilter(mortonUnhashLat(hash), mortonUnhashLon(hash))) {
                   return true;
                 }
               }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
index 9f9e251..d82b340 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
@@ -98,8 +98,8 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
     return AcceptStatus.YES;
   }
 
-  protected boolean postFilter(final double lon, final double lat) {
-    return relationImpl.postFilter(lon, lat);
+  protected boolean postFilter(final double lat, final double lon) {
+    return relationImpl.postFilter(lat, lon);
   }
 
   /**
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
index 482ed0f..8956c4b 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
@@ -34,68 +34,6 @@ public class GeoDistanceUtils {
   }
 
   /**
-   * Compute the distance between two geo-points using vincenty distance formula
-   * Vincenty uses the oblate spheroid whereas haversine uses unit sphere, this will give roughly
-   * 22m better accuracy (in worst case) than haversine
-   *
-   * @param lonA longitudinal coordinate of point A (in degrees)
-   * @param latA latitudinal coordinate of point A (in degrees)
-   * @param lonB longitudinal coordinate of point B (in degrees)
-   * @param latB latitudinal coordinate of point B (in degrees)
-   * @return distance (in meters) between point A and point B
-   */
-  public static final double vincentyDistance(final double lonA, final double latA, final double lonB, final double latB) {
-    final double L = StrictMath.toRadians(lonB - lonA);
-    final double oF = 1 - GeoProjectionUtils.FLATTENING;
-    final double U1 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latA)));
-    final double U2 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latB)));
-    final double sU1 = StrictMath.sin(U1);
-    final double cU1 = StrictMath.cos(U1);
-    final double sU2 = StrictMath.sin(U2);
-    final double cU2 = StrictMath.cos(U2);
-
-    double sigma, sinSigma, cosSigma;
-    double sinAlpha, cos2Alpha, cos2SigmaM;
-    double lambda = L;
-    double lambdaP;
-    double iters = 100;
-    double sinLambda, cosLambda, c;
-
-    do {
-      sinLambda = StrictMath.sin(lambda);
-      cosLambda = Math.cos(lambda);
-      sinSigma = Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)
-          * (cU1 * sU2 - sU1 * cU2 * cosLambda));
-      if (sinSigma == 0) {
-        return 0;
-      }
-
-      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;
-      sigma = Math.atan2(sinSigma, cosSigma);
-      sinAlpha = cU1 * cU2 * sinLambda / sinSigma;
-      cos2Alpha = 1 - sinAlpha * sinAlpha;
-      cos2SigmaM = cosSigma - 2 * sU1 * sU2 / cos2Alpha;
-
-      c = GeoProjectionUtils.FLATTENING/16 * cos2Alpha * (4 + GeoProjectionUtils.FLATTENING * (4 - 3 * cos2Alpha));
-      lambdaP = lambda;
-      lambda = L + (1 - c) * GeoProjectionUtils.FLATTENING * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *
-          (-1 + 2 * cos2SigmaM * cos2SigmaM)));
-    } while (StrictMath.abs(lambda - lambdaP) > 1E-12 && --iters > 0);
-
-    if (iters == 0) {
-      return 0;
-    }
-
-    final double uSq = cos2Alpha * (GeoProjectionUtils.SEMIMAJOR_AXIS2 - GeoProjectionUtils.SEMIMINOR_AXIS2) / (GeoProjectionUtils.SEMIMINOR_AXIS2);
-    final double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
-    final double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
-    final double deltaSigma = B * sinSigma * (cos2SigmaM + B/4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B/6 * cos2SigmaM
-        * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
-
-    return (GeoProjectionUtils.SEMIMINOR_AXIS * A * (sigma - deltaSigma));
-  }
-
-  /**
    * Computes distance between two points in a cartesian (x, y, {z - optional}) coordinate system
    */
   public static double linearDistance(double[] pt1, double[] pt2) {
@@ -133,11 +71,11 @@ public class GeoDistanceUtils {
 
   /**
    *  Finds the closest point within a rectangle (defined by rMinX, rMinY, rMaxX, rMaxY) to the given (lon, lat) point
-   *  the result is provided in closestPt.  When the point is outside the rectangle, the closest point is on an edge
+   *  the result is provided in closestPt (lat, lon).  When the point is outside the rectangle, the closest point is on an edge
    *  or corner of the rectangle; else, the closest point is the point itself.
    */
-  public static void closestPointOnBBox(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                        final double lon, final double lat, double[] closestPt) {
+  public static void closestPointOnBBox(final double rMinY, final double rMaxY, final double rMinX, final double rMaxX,
+                                        final double lat, final double lon, double[] closestPt) {
     assert closestPt != null && closestPt.length == 2;
 
     closestPt[0] = 0;
@@ -147,32 +85,32 @@ public class GeoDistanceUtils {
     boolean ySet = true;
 
     if (lon > rMaxX) {
-      closestPt[0] = rMaxX;
+      closestPt[1] = rMaxX;
     } else if (lon < rMinX) {
-      closestPt[0] = rMinX;
+      closestPt[1] = rMinX;
     } else {
       xSet = false;
     }
 
     if (lat > rMaxY) {
-      closestPt[1] = rMaxY;
+      closestPt[0] = rMaxY;
     } else if (lat < rMinY) {
-      closestPt[1] = rMinY;
+      closestPt[0] = rMinY;
     } else {
       ySet = false;
     }
 
-    if (closestPt[0] == 0 && xSet == false) {
-      closestPt[0] = lon;
+    if (closestPt[0] == 0 && ySet == false) {
+      closestPt[0] = lat;
     }
 
-    if (closestPt[1] == 0 && ySet == false) {
-      closestPt[1] = lat;
+    if (closestPt[1] == 0 && xSet == false) {
+      closestPt[1] = lon;
     }
   }
 
   /** Returns the maximum distance/radius (in meters) from the point 'center' before overlapping */
-  public static double maxRadialDistanceMeters(final double centerLon, final double centerLat) {
+  public static double maxRadialDistanceMeters(final double centerLat, final double centerLon) {
     if (Math.abs(centerLat) == GeoUtils.MAX_LAT_INCL) {
       return SloppyMath.haversinMeters(centerLat, centerLon, 0, centerLon);
     }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
index 451688d..38eef04 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
@@ -32,8 +32,9 @@ import static org.apache.lucene.spatial.util.GeoUtils.MIN_LAT_INCL;
 public final class GeoEncodingUtils {
   /** number of bits used for quantizing latitude and longitude values */
   public static final short BITS = 31;
-  private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
+
   private static final double LAT_SCALE = (0x1L<<BITS)/180.0D;
+  private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
 
   /**
    * The maximum term length (used for <code>byte[]</code> buffer size)
@@ -50,10 +51,10 @@ public final class GeoEncodingUtils {
   }
 
   /**
-   * encode longitude, latitude geopoint values using morton encoding method
+   * encode latitude, longitude geopoint values using morton encoding method
    * https://en.wikipedia.org/wiki/Z-order_curve
    */
-  public static final Long mortonHash(final double lon, final double lat) {
+  public static final Long mortonHash(final double lat, final double lon) {
     return BitUtil.interleave(scaleLon(lon), scaleLat(lat));
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java
deleted file mode 100644
index 49a7571..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.util;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-import org.apache.lucene.util.BitUtil;
-
-/**
- * Utilities for converting to/from the GeoHash standard
- *
- * The geohash long format is represented as lon/lat (x/y) interleaved with the 4 least significant bits
- * representing the level (1-12) [xyxy...xyxyllll]
- *
- * This differs from a morton encoded value which interleaves lat/lon (y/x).
- *
- * @lucene.experimental
- */
-public class GeoHashUtils {
-  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
-      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
-      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
-
-  private static final String BASE_32_STRING = new String(BASE_32);
-
-  /** maximum precision for geohash strings */
-  public static final int PRECISION = 12;
-  private static final short MORTON_OFFSET = (GeoEncodingUtils.BITS<<1) - (PRECISION*5);
-
-  // No instance:
-  private GeoHashUtils() {
-  }
-
-  /**
-   * Encode lon/lat to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)
-   */
-  public static final long longEncode(final double lon, final double lat, final int level) {
-    // shift to appropriate level
-    final short msf = (short)(((12 - level) * 5) + MORTON_OFFSET);
-    return ((BitUtil.flipFlop(GeoEncodingUtils.mortonHash(lon, lat)) >>> msf) << 4) | level;
-  }
-
-  /**
-   * Encode from geohash string to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)
-   */
-  public static final long longEncode(final String hash) {
-    int level = hash.length()-1;
-    long b;
-    long l = 0L;
-    for(char c : hash.toCharArray()) {
-      b = (long)(BASE_32_STRING.indexOf(c));
-      l |= (b<<(level--*5));
-    }
-    return (l<<4)|hash.length();
-  }
-
-  /**
-   * Encode an existing geohash long to the provided precision
-   */
-  public static long longEncode(long geohash, int level) {
-    final short precision = (short)(geohash & 15);
-    if (precision == level) {
-      return geohash;
-    } else if (precision > level) {
-      return ((geohash >>> (((precision - level) * 5) + 4)) << 4) | level;
-    }
-    return ((geohash >>> 4) << (((level - precision) * 5) + 4) | level);
-  }
-
-  /**
-   * Convert from a morton encoded long from a geohash encoded long
-   */
-  public static long fromMorton(long morton, int level) {
-    long mFlipped = BitUtil.flipFlop(morton);
-    mFlipped >>>= (((GeoHashUtils.PRECISION - level) * 5) + MORTON_OFFSET);
-    return (mFlipped << 4) | level;
-  }
-
-  /**
-   * Encode to a geohash string from the geohash based long format
-   */
-  public static final String stringEncode(long geoHashLong) {
-    int level = (int)geoHashLong&15;
-    geoHashLong >>>= 4;
-    char[] chars = new char[level];
-    do {
-      chars[--level] = BASE_32[(int) (geoHashLong&31L)];
-      geoHashLong>>>=5;
-    } while(level > 0);
-
-    return new String(chars);
-  }
-
-  /**
-   * Encode to a geohash string from full resolution longitude, latitude)
-   */
-  public static final String stringEncode(final double lon, final double lat) {
-    return stringEncode(lon, lat, 12);
-  }
-
-  /**
-   * Encode to a level specific geohash string from full resolution longitude, latitude
-   */
-  public static final String stringEncode(final double lon, final double lat, final int level) {
-    // convert to geohashlong
-    final long ghLong = fromMorton(GeoEncodingUtils.mortonHash(lon, lat), level);
-    return stringEncode(ghLong);
-
-  }
-
-  /**
-   * Encode to a full precision geohash string from a given morton encoded long value
-   */
-  public static final String stringEncodeFromMortonLong(final long hashedVal) throws Exception {
-    return stringEncode(hashedVal, PRECISION);
-  }
-
-  /**
-   * Encode to a geohash string at a given level from a morton long
-   */
-  public static final String stringEncodeFromMortonLong(long hashedVal, final int level) {
-    // bit twiddle to geohash (since geohash is a swapped (lon/lat) encoding)
-    hashedVal = BitUtil.flipFlop(hashedVal);
-
-    StringBuilder geoHash = new StringBuilder();
-    short precision = 0;
-    final short msf = (GeoEncodingUtils.BITS<<1)-5;
-    long mask = 31L<<msf;
-    do {
-      geoHash.append(BASE_32[(int)((mask & hashedVal)>>>(msf-(precision*5)))]);
-      // next 5 bits
-      mask >>>= 5;
-    } while (++precision < level);
-    return geoHash.toString();
-  }
-
-  /**
-   * Encode to a morton long value from a given geohash string
-   */
-  public static final long mortonEncode(final String hash) {
-    int level = 11;
-    long b;
-    long l = 0L;
-    for(char c : hash.toCharArray()) {
-      b = (long)(BASE_32_STRING.indexOf(c));
-      l |= (b<<((level--*5) + MORTON_OFFSET));
-    }
-    return BitUtil.flipFlop(l);
-  }
-
-  /**
-   * Encode to a morton long value from a given geohash long value
-   */
-  public static final long mortonEncode(final long geoHashLong) {
-    final int level = (int)(geoHashLong&15);
-    final short odd = (short)(level & 1);
-
-    return BitUtil.flipFlop(((geoHashLong >>> 4) << odd) << (((12 - level) * 5) + (MORTON_OFFSET - odd)));
-  }
-
-  private static final char encode(int x, int y) {
-    return BASE_32[((x & 1) + ((y & 1) * 2) + ((x & 2) * 2) + ((y & 2) * 4) + ((x & 4) * 4)) % 32];
-  }
-
-  /**
-   * Calculate all neighbors of a given geohash cell.
-   *
-   * @param geohash Geohash of the defined cell
-   * @return geohashes of all neighbor cells
-   */
-  public static Collection<? extends CharSequence> neighbors(String geohash) {
-    return addNeighbors(geohash, geohash.length(), new ArrayList<CharSequence>(8));
-  }
-
-  /**
-   * Calculate the geohash of a neighbor of a geohash
-   *
-   * @param geohash the geohash of a cell
-   * @param level   level of the geohash
-   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)
-   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)
-   * @return geohash of the defined cell
-   */
-  public final static String neighbor(String geohash, int level, int dx, int dy) {
-    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));
-
-    // Decoding the Geohash bit pattern to determine grid coordinates
-    int x0 = cell & 1;  // first bit of x
-    int y0 = cell & 2;  // first bit of y
-    int x1 = cell & 4;  // second bit of x
-    int y1 = cell & 8;  // second bit of y
-    int x2 = cell & 16; // third bit of x
-
-    // combine the bitpattern to grid coordinates.
-    // note that the semantics of x and y are swapping
-    // on each level
-    int x = x0 + (x1 / 2) + (x2 / 4);
-    int y = (y0 / 2) + (y1 / 4);
-
-    if (level == 1) {
-      // Root cells at north (namely "bcfguvyz") or at
-      // south (namely "0145hjnp") do not have neighbors
-      // in north/south direction
-      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {
-        return null;
-      } else {
-        return Character.toString(encode(x + dx, y + dy));
-      }
-    } else {
-      // define grid coordinates for next level
-      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);
-      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);
-
-      // if the defined neighbor has the same parent a the current cell
-      // encode the cell directly. Otherwise find the cell next to this
-      // cell recursively. Since encoding wraps around within a cell
-      // it can be encoded here.
-      // xLimit and YLimit must always be respectively 7 and 3
-      // since x and y semantics are swapping on each level.
-      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {
-        return geohash.substring(0, level - 1) + encode(nx, ny);
-      } else {
-        String neighbor = neighbor(geohash, level - 1, dx, dy);
-        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;
-      }
-    }
-  }
-
-  /**
-   * Add all geohashes of the cells next to a given geohash to a list.
-   *
-   * @param geohash   Geohash of a specified cell
-   * @param neighbors list to add the neighbors to
-   * @return the given list
-   */
-  public static final <E extends Collection<? super String>> E addNeighbors(String geohash, E neighbors) {
-    return addNeighbors(geohash, geohash.length(), neighbors);
-  }
-
-  /**
-   * Add all geohashes of the cells next to a given geohash to a list.
-   *
-   * @param geohash   Geohash of a specified cell
-   * @param length    level of the given geohash
-   * @param neighbors list to add the neighbors to
-   * @return the given list
-   */
-  public static final <E extends Collection<? super String>> E addNeighbors(String geohash, int length, E neighbors) {
-    String south = neighbor(geohash, length, 0, -1);
-    String north = neighbor(geohash, length, 0, +1);
-    if (north != null) {
-      neighbors.add(neighbor(north, length, -1, 0));
-      neighbors.add(north);
-      neighbors.add(neighbor(north, length, +1, 0));
-    }
-
-    neighbors.add(neighbor(geohash, length, -1, 0));
-    neighbors.add(neighbor(geohash, length, +1, 0));
-
-    if (south != null) {
-      neighbors.add(neighbor(south, length, -1, 0));
-      neighbors.add(south);
-      neighbors.add(neighbor(south, length, +1, 0));
-    }
-
-    return neighbors;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
index 12d1350..61aa09f 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
@@ -69,83 +69,14 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Converts from geocentric earth-centered earth-fixed to geodesic lat/lon/alt
-   * @param x Cartesian x coordinate
-   * @param y Cartesian y coordinate
-   * @param z Cartesian z coordinate
-   * @param lla 0: longitude 1: latitude: 2: altitude
-   * @return double array as 0: longitude 1: latitude 2: altitude
-   */
-  public static final double[] ecfToLLA(final double x, final double y, final double z, double[] lla) {
-    boolean atPole = false;
-    final double ad_c = 1.0026000D;
-    final double cos67P5 = 0.38268343236508977D;
-
-    if (lla == null) {
-      lla = new double[3];
-    }
-
-    if (x != 0.0) {
-      lla[0] = StrictMath.atan2(y,x);
-    } else {
-      if (y > 0) {
-        lla[0] = PIO2;
-      } else if (y < 0) {
-        lla[0] = -PIO2;
-      } else {
-        atPole = true;
-        lla[0] = 0.0D;
-        if (z > 0.0) {
-          lla[1] = PIO2;
-        } else if (z < 0.0) {
-          lla[1] = -PIO2;
-        } else {
-          lla[1] = PIO2;
-          lla[2] = -SEMIMINOR_AXIS;
-          return lla;
-        }
-      }
-    }
-
-    final double w2 = x*x + y*y;
-    final double w = StrictMath.sqrt(w2);
-    final double t0 = z * ad_c;
-    final double s0 = StrictMath.sqrt(t0 * t0 + w2);
-    final double sinB0 = t0 / s0;
-    final double cosB0 = w / s0;
-    final double sin3B0 = sinB0 * sinB0 * sinB0;
-    final double t1 = z + SEMIMINOR_AXIS * EP2 * sin3B0;
-    final double sum = w - SEMIMAJOR_AXIS * E2 * cosB0 * cosB0 * cosB0;
-    final double s1 = StrictMath.sqrt(t1 * t1 + sum * sum);
-    final double sinP1 = t1 / s1;
-    final double cosP1 = sum / s1;
-    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - E2 * sinP1 * sinP1);
-
-    if (cosP1 >= cos67P5) {
-      lla[2] = w / cosP1 - rn;
-    } else if (cosP1 <= -cos67P5) {
-      lla[2] = w / -cosP1 - rn;
-    } else {
-      lla[2] = z / sinP1 + rn * (E2 - 1.0);
-    }
-    if (!atPole) {
-      lla[1] = StrictMath.atan(sinP1/cosP1);
-    }
-    lla[0] = TO_DEGREES * lla[0];
-    lla[1] = TO_DEGREES * lla[1];
-
-    return lla;
-  }
-
-  /**
-   * Converts from geodesic lon lat alt to geocentric earth-centered earth-fixed
-   * @param lon geodesic longitude
+   * Converts from geodesic lat lon alt to geocentric earth-centered earth-fixed
    * @param lat geodesic latitude
+   * @param lon geodesic longitude
    * @param alt geodesic altitude
    * @param ecf reusable earth-centered earth-fixed result
    * @return either a new ecef array or the reusable ecf parameter
    */
-  public static final double[] llaToECF(double lon, double lat, double alt, double[] ecf) {
+  public static final double[] llaToECF(double lat, double lon, double alt, double[] ecf) {
     lon = TO_RADIANS * lon;
     lat = TO_RADIANS * lat;
 
@@ -177,261 +108,23 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Converts from lat lon alt (in degrees) to East North Up right-hand coordinate system
-   * @param lon longitude in degrees
-   * @param lat latitude in degrees
-   * @param alt altitude in meters
-   * @param centerLon reference point longitude in degrees
-   * @param centerLat reference point latitude in degrees
-   * @param centerAlt reference point altitude in meters
-   * @param enu result east, north, up coordinate
-   * @return east, north, up coordinate
-   */
-  public static double[] llaToENU(final double lon, final double lat, final double alt, double centerLon,
-                                  double centerLat, final double centerAlt, double[] enu) {
-    if (enu == null) {
-      enu = new double[3];
-    }
-
-    // convert point to ecf coordinates
-    final double[] ecf = llaToECF(lon, lat, alt, null);
-
-    // convert from ecf to enu
-    return ecfToENU(ecf[0], ecf[1], ecf[2], centerLon, centerLat, centerAlt, enu);
-  }
-
-  /**
-   * Converts from East North Up right-hand rule to lat lon alt in degrees
-   * @param x easting (in meters)
-   * @param y northing (in meters)
-   * @param z up (in meters)
-   * @param centerLon reference point longitude (in degrees)
-   * @param centerLat reference point latitude (in degrees)
-   * @param centerAlt reference point altitude (in meters)
-   * @param lla resulting lat, lon, alt point (in degrees)
-   * @return lat, lon, alt point (in degrees)
-   */
-  public static double[] enuToLLA(final double x, final double y, final double z, final double centerLon,
-                                  final double centerLat, final double centerAlt, double[] lla) {
-    // convert enuToECF
-    if (lla == null) {
-      lla = new double[3];
-    }
-
-    // convert enuToECF, storing intermediate result in lla
-    lla = enuToECF(x, y, z, centerLon, centerLat, centerAlt, lla);
-
-    // convert ecf to LLA
-    return ecfToLLA(lla[0], lla[1], lla[2], lla);
-  }
-
-  /**
-   * Convert from Earth-Centered-Fixed to Easting, Northing, Up Right Hand System
-   * @param x ECF X coordinate (in meters)
-   * @param y ECF Y coordinate (in meters)
-   * @param z ECF Z coordinate (in meters)
-   * @param centerLon ENU origin longitude (in degrees)
-   * @param centerLat ENU origin latitude (in degrees)
-   * @param centerAlt ENU altitude (in meters)
-   * @param enu reusable enu result
-   * @return Easting, Northing, Up coordinate
-   */
-  public static double[] ecfToENU(double x, double y, double z, final double centerLon,
-                                  final double centerLat, final double centerAlt, double[] enu) {
-    if (enu == null) {
-      enu = new double[3];
-    }
-
-    // create rotation matrix and rotate to enu orientation
-    final double[][] phi = createPhiTransform(centerLon, centerLat, null);
-
-    // convert origin to ENU
-    final double[] originECF = llaToECF(centerLon, centerLat, centerAlt, null);
-    final double[] originENU = new double[3];
-    originENU[0] = ((phi[0][0] * originECF[0]) + (phi[0][1] * originECF[1]) + (phi[0][2] * originECF[2]));
-    originENU[1] = ((phi[1][0] * originECF[0]) + (phi[1][1] * originECF[1]) + (phi[1][2] * originECF[2]));
-    originENU[2] = ((phi[2][0] * originECF[0]) + (phi[2][1] * originECF[1]) + (phi[2][2] * originECF[2]));
-
-    // rotate then translate
-    enu[0] = ((phi[0][0] * x) + (phi[0][1] * y) + (phi[0][2] * z)) - originENU[0];
-    enu[1] = ((phi[1][0] * x) + (phi[1][1] * y) + (phi[1][2] * z)) - originENU[1];
-    enu[2] = ((phi[2][0] * x) + (phi[2][1] * y) + (phi[2][2] * z)) - originENU[2];
-
-    return enu;
-  }
-
-  /**
-   * Convert from Easting, Northing, Up Right-Handed system to Earth Centered Fixed system
-   * @param x ENU x coordinate (in meters)
-   * @param y ENU y coordinate (in meters)
-   * @param z ENU z coordinate (in meters)
-   * @param centerLon ENU origin longitude (in degrees)
-   * @param centerLat ENU origin latitude (in degrees)
-   * @param centerAlt ENU origin altitude (in meters)
-   * @param ecf reusable ecf result
-   * @return ecf result coordinate
-   */
-  public static double[] enuToECF(final double x, final double y, final double z, double centerLon,
-                                  double centerLat, final double centerAlt, double[] ecf) {
-    if (ecf == null) {
-      ecf = new double[3];
-    }
-
-    double[][] phi = createTransposedPhiTransform(centerLon, centerLat, null);
-    double[] ecfOrigin = llaToECF(centerLon, centerLat, centerAlt, null);
-
-    // rotate and translate
-    ecf[0] = (phi[0][0]*x + phi[0][1]*y + phi[0][2]*z) + ecfOrigin[0];
-    ecf[1] = (phi[1][0]*x + phi[1][1]*y + phi[1][2]*z) + ecfOrigin[1];
-    ecf[2] = (phi[2][0]*x + phi[2][1]*y + phi[2][2]*z) + ecfOrigin[2];
-
-    return ecf;
-  }
-
-  /**
-   * Create the rotation matrix for converting Earth Centered Fixed to Easting Northing Up
-   * @param originLon ENU origin longitude (in degrees)
-   * @param originLat ENU origin latitude (in degrees)
-   * @param phiMatrix reusable phi matrix result
-   * @return phi rotation matrix
-   */
-  private static double[][] createPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
-
-    if (phiMatrix == null) {
-      phiMatrix = new double[3][3];
-    }
-
-    originLon = TO_RADIANS * originLon;
-    originLat = TO_RADIANS * originLat;
-
-    final double sLon = sloppySin(originLon);
-    final double cLon = cos(originLon);
-    final double sLat = sloppySin(originLat);
-    final double cLat = cos(originLat);
-
-    phiMatrix[0][0] = -sLon;
-    phiMatrix[0][1] = cLon;
-    phiMatrix[0][2] = 0.0D;
-    phiMatrix[1][0] = -sLat * cLon;
-    phiMatrix[1][1] = -sLat * sLon;
-    phiMatrix[1][2] = cLat;
-    phiMatrix[2][0] = cLat * cLon;
-    phiMatrix[2][1] = cLat * sLon;
-    phiMatrix[2][2] = sLat;
-
-    return phiMatrix;
-  }
-
-  /**
-   * Create the transposed rotation matrix for converting Easting Northing Up coordinates to Earth Centered Fixed
-   * @param originLon ENU origin longitude (in degrees)
-   * @param originLat ENU origin latitude (in degrees)
-   * @param phiMatrix reusable phi rotation matrix result
-   * @return transposed phi rotation matrix
-   */
-  private static double[][] createTransposedPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
-
-    if (phiMatrix == null) {
-      phiMatrix = new double[3][3];
-    }
-
-    originLon = TO_RADIANS * originLon;
-    originLat = TO_RADIANS * originLat;
-
-    final double sLat = sloppySin(originLat);
-    final double cLat = cos(originLat);
-    final double sLon = sloppySin(originLon);
-    final double cLon = cos(originLon);
-
-    phiMatrix[0][0] = -sLon;
-    phiMatrix[1][0] = cLon;
-    phiMatrix[2][0] = 0.0D;
-    phiMatrix[0][1] = -sLat * cLon;
-    phiMatrix[1][1] = -sLat * sLon;
-    phiMatrix[2][1] = cLat;
-    phiMatrix[0][2] = cLat * cLon;
-    phiMatrix[1][2] = cLat * sLon;
-    phiMatrix[2][2] = sLat;
-
-    return phiMatrix;
-  }
-
-  /**
-   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula
+   * Finds a point along a bearing from a given lat,lon geolocation using great circle arc
    *
-   * @param lon origin longitude in degrees
    * @param lat origin latitude in degrees
-   * @param bearing azimuthal bearing in degrees
-   * @param dist distance in meters
-   * @param pt resulting point
-   * @return the point along a bearing at a given distance in meters
-   */
-  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {
-
-    if (pt == null) {
-      pt = new double[2];
-    }
-
-    final double alpha1 = TO_RADIANS * bearing;
-    final double cosA1 = cos(alpha1);
-    final double sinA1 = sloppySin(alpha1);
-    final double tanU1 = (1-FLATTENING) * sloppyTan(TO_RADIANS * lat);
-    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));
-    final double sinU1 = tanU1*cosU1;
-    final double sig1 = StrictMath.atan2(tanU1, cosA1);
-    final double sinAlpha = cosU1 * sinA1;
-    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;
-    final double uSq = cosSqAlpha * EP2;
-    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));
-    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));
-
-    double sigma = dist / (SEMIMINOR_AXIS*A);
-    double sigmaP;
-    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;
-
-    do {
-      cos2SigmaM = cos(2*sig1 + sigma);
-      sinSigma = sloppySin(sigma);
-      cosSigma = cos(sigma);
-
-      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
-          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
-      sigmaP = sigma;
-      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;
-    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);
-
-    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;
-    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,
-        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));
-    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);
-    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));
-
-    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *
-        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));
-    pt[0] = normalizeLon(lon + TO_DEGREES * lam);
-    pt[1] = normalizeLat(TO_DEGREES * lat2);
-
-    return pt;
-  }
-
-  /**
-   * Finds a point along a bearing from a given lon,lat geolocation using great circle arc
-   *
    * @param lon origin longitude in degrees
-   * @param lat origin latitude in degrees
    * @param bearing azimuthal bearing in degrees
    * @param dist distance in meters
    * @param pt resulting point
    * @return the point along a bearing at a given distance in meters
    */
-  public static final double[] pointFromLonLatBearingGreatCircle(double lon, double lat, double bearing, double dist, double[] pt) {
+  public static final double[] pointFromLonLatBearingGreatCircle(double lat, double lon, double bearing, double dist, double[] pt) {
 
     if (pt == null) {
       pt = new double[2];
     }
 
-    lon *= TO_RADIANS;
     lat *= TO_RADIANS;
+    lon *= TO_RADIANS;
     bearing *= TO_RADIANS;
 
     final double cLat = cos(lat);
@@ -447,14 +140,14 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Finds the bearing (in degrees) between 2 geo points (lon, lat) using great circle arc
-   * @param lon1 first point longitude in degrees
+   * Finds the bearing (in degrees) between 2 geo points (lat, lon) using great circle arc
    * @param lat1 first point latitude in degrees
-   * @param lon2 second point longitude in degrees
+   * @param lon1 first point longitude in degrees
    * @param lat2 second point latitude in degrees
+   * @param lon2 second point longitude in degrees
    * @return the bearing (in degrees) between the two provided points
    */
-  public static double bearingGreatCircle(double lon1, double lat1, double lon2, double lat2) {
+  public static double bearingGreatCircle(double lat1, double lon1, double lat2, double lon2) {
     double dLon = (lon2 - lon1) * TO_RADIANS;
     lat2 *= TO_RADIANS;
     lat1 *= TO_RADIANS;
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
index e147351..8d947b4 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
@@ -18,19 +18,19 @@ package org.apache.lucene.spatial.util;
 
 /** Represents a lat/lon rectangle. */
 public class GeoRect {
-  /** minimum longitude value (in degrees) */
-  public final double minLon;
-  /** minimum latitude value (in degrees) */
-  public final double maxLon;
   /** maximum longitude value (in degrees) */
   public final double minLat;
+  /** minimum longitude value (in degrees) */
+  public final double minLon;
   /** maximum latitude value (in degrees) */
   public final double maxLat;
+  /** minimum latitude value (in degrees) */
+  public final double maxLon;
 
   /**
    * Constructs a bounding box by first validating the provided latitude and longitude coordinates
    */
-  public GeoRect(double minLon, double maxLon, double minLat, double maxLat) {
+  public GeoRect(double minLat, double maxLat, double minLon, double maxLon) {
     if (GeoUtils.isValidLon(minLon) == false) {
       throw new IllegalArgumentException("invalid minLon " + minLon);
     }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
index e40b91a..4a31202 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
@@ -28,13 +28,14 @@ public class GeoRelationUtils {
   }
 
   /**
-   * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)
+   * Determine if a bbox (defined by minLat, maxLat, minLon, maxLon) contains the provided point (defined by lat, lon)
    * NOTE: this is a basic method that does not handle dateline or pole crossing. Unwrapping must be done before
    * calling this method.
    */
-  public static boolean pointInRectPrecise(final double lon, final double lat, final double minLon,
-                                           final double minLat, final double maxLon, final double maxLat) {
-    return lon >= minLon && lon <= maxLon && lat >= minLat && lat <= maxLat;
+  public static boolean pointInRectPrecise(final double lat, final double lon,
+                                           final double minLat, final double maxLat,
+                                           final double minLon, final double maxLon) {
+    return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
   }
 
   /**
@@ -46,17 +47,17 @@ public class GeoRelationUtils {
    *
    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise
    */
-  public static boolean pointInPolygon(double[] x, double[] y, double lat, double lon) {
-    assert x.length == y.length;
+  public static boolean pointInPolygon(double[] polyLats, double[] polyLons, double lat, double lon) {
+    assert polyLats.length == polyLons.length;
     boolean inPoly = false;
     /**
      * Note: This is using a euclidean coordinate system which could result in
      * upwards of 110KM error at the equator.
      * TODO convert coordinates to cylindrical projection (e.g. mercator)
      */
-    for (int i = 1; i < x.length; i++) {
-      if (x[i] <= lon && x[i-1] >= lon || x[i-1] <= lon && x[i] >= lon) {
-        if (y[i] + (lon - x[i]) / (x[i-1] - x[i]) * (y[i-1] - y[i]) <= lat) {
+    for (int i = 1; i < polyLats.length; i++) {
+      if (polyLons[i] <= lon && polyLons[i-1] >= lon || polyLons[i-1] <= lon && polyLons[i] >= lon) {
+        if (polyLats[i] + (lon - polyLons[i]) / (polyLons[i-1] - polyLons[i]) * (polyLats[i-1] - polyLats[i]) <= lat) {
           inPoly = !inPoly;
         }
       }
@@ -71,42 +72,34 @@ public class GeoRelationUtils {
   /**
    * Computes whether two rectangles are disjoint
    */
-  public static boolean rectDisjoint(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                     final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return (aMaxX < bMinX || aMinX > bMaxX || aMaxY < bMinY || aMinY > bMaxY);
+  private static boolean rectDisjoint(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                      final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return (aMaxLon < bMinLon || aMinLon > bMaxLon || aMaxLat < bMinLat || aMinLat > bMaxLat);
   }
 
   /**
    * Computes whether the first (a) rectangle is wholly within another (b) rectangle (shared boundaries allowed)
    */
-  public static boolean rectWithin(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                   final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(aMinX < bMinX || aMinY < bMinY || aMaxX > bMaxX || aMaxY > bMaxY);
+  public static boolean rectWithin(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                   final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !(aMinLon < bMinLon || aMinLat < bMinLat || aMaxLon > bMaxLon || aMaxLat > bMaxLat);
   }
 
   /**
    * Computes whether two rectangles cross
    */
-  public static boolean rectCrosses(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                    final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(rectDisjoint(aMinX, aMinY, aMaxX, aMaxY, bMinX, bMinY, bMaxX, bMaxY) ||
-        rectWithin(aMinX, aMinY, aMaxX, aMaxY, bMinX, bMinY, bMaxX, bMaxY));
-  }
-
-  /**
-   * Computes whether rectangle a contains rectangle b (touching allowed)
-   */
-  public static boolean rectContains(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                     final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(bMinX < aMinX || bMinY < aMinY || bMaxX > aMaxX || bMaxY > aMaxY);
+  public static boolean rectCrosses(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                    final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !(rectDisjoint(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon) ||
+             rectWithin(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon));
   }
 
   /**
    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)
    */
-  public static boolean rectIntersects(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                       final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !((aMaxX < bMinX || aMinX > bMaxX || aMaxY < bMinY || aMinY > bMaxY) );
+  public static boolean rectIntersects(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                       final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !((aMaxLon < bMinLon || aMinLon > bMaxLon || aMaxLat < bMinLat || aMinLat > bMaxLat));
   }
 
   /////////////////////////
@@ -116,33 +109,35 @@ public class GeoRelationUtils {
   /**
    * Convenience method for accurately computing whether a rectangle crosses a poly
    */
-  public static boolean rectCrossesPolyPrecise(final double rMinX, final double rMinY, final double rMaxX,
-                                        final double rMaxY, final double[] shapeX, final double[] shapeY,
-                                        final double sMinX, final double sMinY, final double sMaxX,
-                                        final double sMaxY) {
+  public static boolean rectCrossesPolyPrecise(final double rMinLat, final double rMaxLat,
+                                               final double rMinLon, final double rMaxLon,
+                                               final double[] shapeLat, final double[] shapeLon,
+                                               final double sMinLat, final double sMaxLat,
+                                               final double sMinLon, final double sMaxLon) {
     // short-circuit: if the bounding boxes are disjoint then the shape does not cross
-    if (rectDisjoint(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY)) {
+    if (rectDisjoint(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon)) {
       return false;
     }
-    return rectCrossesPoly(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY);
+    return rectCrossesPoly(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLat, shapeLon);
   }
 
   /**
    * Compute whether a rectangle crosses a shape. (touching not allowed) Includes a flag for approximating the
    * relation.
    */
-  public static boolean rectCrossesPolyApprox(final double rMinX, final double rMinY, final double rMaxX,
-                                              final double rMaxY, final double[] shapeX, final double[] shapeY,
-                                              final double sMinX, final double sMinY, final double sMaxX,
-                                              final double sMaxY) {
+  public static boolean rectCrossesPolyApprox(final double rMinLat, final double rMaxLat,
+                                              final double rMinLon, final double rMaxLon,
+                                              final double[] shapeLat, final double[] shapeLon,
+                                              final double sMinLat, final double sMaxLat,
+                                              final double sMinLon, final double sMaxLon) {
     // short-circuit: if the bounding boxes are disjoint then the shape does not cross
-    if (rectDisjoint(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY)) {
+    if (rectDisjoint(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon)) {
       return false;
     }
 
-    final int polyLength = shapeX.length-1;
+    final int polyLength = shapeLon.length-1;
     for (short p=0; p<polyLength; ++p) {
-      if (lineCrossesRect(shapeX[p], shapeY[p], shapeX[p+1], shapeY[p+1], rMinX, rMinY, rMaxX, rMaxY) == true) {
+      if (lineCrossesRect(shapeLat[p], shapeLon[p], shapeLat[p+1], shapeLon[p+1], rMinLat, rMaxLat, rMinLon, rMaxLon) == true) {
         return true;
       }
     }
@@ -152,10 +147,11 @@ public class GeoRelationUtils {
   /**
    * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon
    */
-  private static boolean rectCrossesPoly(final double rMinX, final double rMinY, final double rMaxX,
-                                         final double rMaxY, final double[] shapeX, final double[] shapeY) {
-    final double[][] bbox = new double[][] { {rMinX, rMinY}, {rMaxX, rMinY}, {rMaxX, rMaxY}, {rMinX, rMaxY}, {rMinX, rMinY} };
-    final int polyLength = shapeX.length-1;
+  private static boolean rectCrossesPoly(final double rMinLat, final double rMaxLat,
+                                         final double rMinLon, final double rMaxLon,
+                                         final double[] shapeLats, final double[] shapeLons) {
+    final double[][] bbox = new double[][] { {rMinLon, rMinLat}, {rMaxLon, rMinLat}, {rMaxLon, rMaxLat}, {rMinLon, rMaxLat}, {rMinLon, rMinLat} };
+    final int polyLength = shapeLons.length-1;
     double d, s, t, a1, b1, c1, a2, b2, c2;
     double x00, y00, x01, y01, x10, y10, x11, y11;
 
@@ -165,23 +161,23 @@ public class GeoRelationUtils {
       b1 = bbox[b][0]-bbox[b+1][0];
       c1 = a1*bbox[b+1][0] + b1*bbox[b+1][1];
       for (int p=0; p<polyLength; ++p) {
-        a2 = shapeY[p+1]-shapeY[p];
-        b2 = shapeX[p]-shapeX[p+1];
+        a2 = shapeLats[p+1]-shapeLats[p];
+        b2 = shapeLons[p]-shapeLons[p+1];
         // compute determinant
         d = a1*b2 - a2*b1;
         if (d != 0) {
           // lines are not parallel, check intersecting points
-          c2 = a2*shapeX[p+1] + b2*shapeY[p+1];
+          c2 = a2*shapeLons[p+1] + b2*shapeLats[p+1];
           s = (1/d)*(b2*c1 - b1*c2);
           t = (1/d)*(a1*c2 - a2*c1);
           x00 = StrictMath.min(bbox[b][0], bbox[b+1][0]) - GeoEncodingUtils.TOLERANCE;
           x01 = StrictMath.max(bbox[b][0], bbox[b+1][0]) + GeoEncodingUtils.TOLERANCE;
           y00 = StrictMath.min(bbox[b][1], bbox[b+1][1]) - GeoEncodingUtils.TOLERANCE;
           y01 = StrictMath.max(bbox[b][1], bbox[b+1][1]) + GeoEncodingUtils.TOLERANCE;
-          x10 = StrictMath.min(shapeX[p], shapeX[p+1]) - GeoEncodingUtils.TOLERANCE;
-          x11 = StrictMath.max(shapeX[p], shapeX[p+1]) + GeoEncodingUtils.TOLERANCE;
-          y10 = StrictMath.min(shapeY[p], shapeY[p+1]) - GeoEncodingUtils.TOLERANCE;
-          y11 = StrictMath.max(shapeY[p], shapeY[p+1]) + GeoEncodingUtils.TOLERANCE;
+          x10 = StrictMath.min(shapeLons[p], shapeLons[p+1]) - GeoEncodingUtils.TOLERANCE;
+          x11 = StrictMath.max(shapeLons[p], shapeLons[p+1]) + GeoEncodingUtils.TOLERANCE;
+          y10 = StrictMath.min(shapeLats[p], shapeLats[p+1]) - GeoEncodingUtils.TOLERANCE;
+          y11 = StrictMath.max(shapeLats[p], shapeLats[p+1]) + GeoEncodingUtils.TOLERANCE;
           // check whether the intersection point is touching one of the line segments
           boolean touching = ((x00 == s && y00 == t) || (x01 == s && y01 == t))
               || ((x10 == s && y10 == t) || (x11 == s && y11 == t));
@@ -195,30 +191,35 @@ public class GeoRelationUtils {
     return false;
   }
 
-  private static boolean lineCrossesRect(double aX1, double aY1, double aX2, double aY2,
-                                         final double rMinX, final double rMinY, final double rMaxX, final double rMaxY) {
+  private static boolean lineCrossesRect(double aLat1, double aLon1,
+                                         double aLat2, double aLon2,
+                                         final double rMinLat, final double rMaxLat,
+                                         final double rMinLon, final double rMaxLon) {
     // short-circuit: if one point inside rect, other outside
-    if (pointInRectPrecise(aX1, aY1, rMinX, rMinY, rMaxX, rMaxY) ?
-        !pointInRectPrecise(aX2, aY2, rMinX, rMinY, rMaxX, rMaxY) : pointInRectPrecise(aX2, aY2, rMinX, rMinY, rMaxX, rMaxY)) {
+    if (pointInRectPrecise(aLat1, aLon1, rMinLat, rMaxLat, rMinLon, rMaxLon)) {
+      if (pointInRectPrecise(aLat2, aLon2, rMinLat, rMaxLat, rMinLon, rMaxLon) == false) {
+        return true;
+      }
+    } else if (pointInRectPrecise(aLat2, aLon2, rMinLat, rMaxLat, rMinLon, rMaxLon)) {
       return true;
     }
 
-    return lineCrossesLine(aX1, aY1, aX2, aY2, rMinX, rMinY, rMaxX, rMaxY)
-        || lineCrossesLine(aX1, aY1, aX2, aY2, rMaxX, rMinY, rMinX, rMaxY);
+    return lineCrossesLine(aLat1, aLon1, aLat2, aLon2, rMinLat, rMinLon, rMaxLat, rMaxLon)
+        || lineCrossesLine(aLat1, aLon1, aLat2, aLon2, rMaxLat, rMinLon, rMinLat, rMaxLon);
   }
 
-  private static boolean lineCrossesLine(final double aX1, final double aY1, final double aX2, final double aY2,
-                                         final double bX1, final double bY1, final double bX2, final double bY2) {
+  private static boolean lineCrossesLine(final double aLat1, final double aLon1, final double aLat2, final double aLon2,
+                                         final double bLat1, final double bLon1, final double bLat2, final double bLon2) {
     // determine if three points are ccw (right-hand rule) by computing the determinate
-    final double aX2X1d = aX2 - aX1;
-    final double aY2Y1d = aY2 - aY1;
-    final double bX2X1d = bX2 - bX1;
-    final double bY2Y1d = bY2 - bY1;
+    final double aX2X1d = aLon2 - aLon1;
+    final double aY2Y1d = aLat2 - aLat1;
+    final double bX2X1d = bLon2 - bLon1;
+    final double bY2Y1d = bLat2 - bLat1;
 
-    final double t1B = aX2X1d * (bY2 - aY1) - aY2Y1d * (bX2 - aX1);
-    final double test1 = (aX2X1d * (bY1 - aY1) - aY2Y1d * (bX1 - aX1)) * t1B;
-    final double t2B = bX2X1d * (aY2 - bY1) - bY2Y1d * (aX2 - bX1);
-    final double test2 = (bX2X1d * (aY1 - bY1) - bY2Y1d * (aX1 - bX1)) * t2B;
+    final double t1B = aX2X1d * (bLat2 - aLat1) - aY2Y1d * (bLon2 - aLon1);
+    final double test1 = (aX2X1d * (bLat1 - aLat1) - aY2Y1d * (bLon1 - aLon1)) * t1B;
+    final double t2B = bX2X1d * (aLat2 - bLat1) - bY2Y1d * (aLon2 - bLon1);
+    final double test2 = (bX2X1d * (aLat1 - bLat1) - bY2Y1d * (aLon1 - bLon1)) * t2B;
 
     if (test1 < 0 && test2 < 0) {
       return true;
@@ -226,19 +227,19 @@ public class GeoRelationUtils {
 
     if (test1 == 0 || test2 == 0) {
       // vertically collinear
-      if (aX1 == aX2 || bX1 == bX2) {
-        final double minAy = Math.min(aY1, aY2);
-        final double maxAy = Math.max(aY1, aY2);
-        final double minBy = Math.min(bY1, bY2);
-        final double maxBy = Math.max(bY1, bY2);
+      if (aLon1 == aLon2 || bLon1 == bLon2) {
+        final double minAy = Math.min(aLat1, aLat2);
+        final double maxAy = Math.max(aLat1, aLat2);
+        final double minBy = Math.min(bLat1, bLat2);
+        final double maxBy = Math.max(bLat1, bLat2);
 
         return !(minBy >= maxAy || maxBy <= minAy);
       }
       // horizontally collinear
-      final double minAx = Math.min(aX1, aX2);
-      final double maxAx = Math.max(aX1, aX2);
-      final double minBx = Math.min(bX1, bX2);
-      final double maxBx = Math.max(bX1, bX2);
+      final double minAx = Math.min(aLon1, aLon2);
+      final double maxAx = Math.max(aLon1, aLon2);
+      final double minBx = Math.min(bLon1, bLon2);
+      final double maxBx = Math.max(bLon1, bLon2);
 
       return !(minBx >= maxAx || maxBx <= minAx);
     }
@@ -249,107 +250,113 @@ public class GeoRelationUtils {
    * Computes whether a rectangle is within a polygon (shared boundaries not allowed) with more rigor than the
    * {@link GeoRelationUtils#rectWithinPolyApprox} counterpart
    */
-  public static boolean rectWithinPolyPrecise(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                       final double[] shapeX, final double[] shapeY, final double sMinX,
-                                       final double sMinY, final double sMaxX, final double sMaxY) {
+  public static boolean rectWithinPolyPrecise(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                              final double[] shapeLats, final double[] shapeLons, final double sMinLat,
+                                              final double sMaxLat, final double sMinLon, final double sMaxLon) {
     // check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
     // are contained
-    return !(rectCrossesPolyPrecise(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY, sMinX, sMinY, sMaxX, sMaxY) ||
-        !pointInPolygon(shapeX, shapeY, rMinY, rMinX) || !pointInPolygon(shapeX, shapeY, rMinY, rMaxX) ||
-        !pointInPolygon(shapeX, shapeY, rMaxY, rMaxX) || !pointInPolygon(shapeX, shapeY, rMaxY, rMinX));
+    return !(rectCrossesPolyPrecise(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLats, shapeLons, sMinLat, sMaxLat, sMinLon, sMaxLon) ||
+        !pointInPolygon(shapeLats, shapeLons, rMinLat, rMinLon) || !pointInPolygon(shapeLats, shapeLons, rMinLat, rMaxLon) ||
+        !pointInPolygon(shapeLats, shapeLons, rMaxLat, rMaxLon) || !pointInPolygon(shapeLats, shapeLons, rMaxLat, rMinLon));
   }
 
   /**
    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)
    */
-  public static boolean rectWithinPolyApprox(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                       final double[] shapeX, final double[] shapeY, final double sMinX,
-                                       final double sMinY, final double sMaxX, final double sMaxY) {
+  public static boolean rectWithinPolyApprox(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                             final double[] shapeLats, final double[] shapeLons, final double sMinLat,
+                                             final double sMaxLat, final double sMinLon, final double sMaxLon) {
     // approximation: check if rectangle crosses poly (to handle concave/pacman polys), then check one of the corners
     // are contained
 
     // short-cut: if bounding boxes cross, rect is not within
-     if (rectCrosses(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY) == true) {
+    if (rectCrosses(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon) == true) {
        return false;
      }
 
-     return !(rectCrossesPolyApprox(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY, sMinX, sMinY, sMaxX, sMaxY)
-         || !pointInPolygon(shapeX, shapeY, rMinY, rMinX));
+     return !(rectCrossesPolyApprox(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLats, shapeLons, sMinLat, sMaxLat, sMinLon, sMaxLon)
+         || !pointInPolygon(shapeLats, shapeLons, rMinLat, rMinLon));
   }
 
   /////////////////////////
   // Circle relations
   /////////////////////////
 
-  private static boolean rectAnyCornersInCircle(final double rMinX, final double rMinY, final double rMaxX,
-                                                final double rMaxY, final double centerLon, final double centerLat,
+  private static boolean rectAnyCornersInCircle(final double rMinLat, final double rMaxLat, final double rMinLon,
+                                                final double rMaxLon, final double centerLat, final double centerLon,
                                                 final double radiusMeters, final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersInCircleSloppy(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters);
+      return rectAnyCornersInCircleSloppy(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters);
     }
-    double w = Math.abs(rMaxX - rMinX);
+    double w = Math.abs(rMaxLon - rMinLon);
     if (w <= 90.0) {
-      return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+      return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
     }
     // partition
     w /= 4;
-    final double p1 = rMinX + w;
+    final double p1 = rMinLon + w;
     final double p2 = p1 + w;
     final double p3 = p2 + w;
 
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p1) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p1) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p2) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p2) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p3) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p3) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p1) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p1) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p2) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p2) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p3) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p3) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
   }
 
-  private static boolean rectAnyCornersInCircleSloppy(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                      final double centerLon, final double centerLat, final double radiusMeters) {
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+  private static boolean rectAnyCornersInCircleSloppy(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                                      final double centerLat, final double centerLon, final double radiusMeters) {
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
   }
 
   /**
    * Compute whether any of the 4 corners of the rectangle (defined by min/max X/Y) are outside the circle (defined
    * by centerLon, centerLat, radiusMeters)
    *
-   * Note: exotic rectangles at the poles (e.g., those whose lon/lat distance ratios greatly deviate from 1) can not
+   * Note: exotic rectangles at the poles (e.g., those whose lat/lon distance ratios greatly deviate from 1) can not
    * be determined by using distance alone. For this reason the approx flag may be set to false, in which case the
    * space will be further divided to more accurately compute whether the rectangle crosses the circle
    */
-  private static boolean rectAnyCornersOutsideCircle(final double rMinX, final double rMinY, final double rMaxX,
-                                                     final double rMaxY, final double centerLon, final double centerLat,
+  private static boolean rectAnyCornersOutsideCircle(final double rMinLat, final double rMaxLat, final double rMinLon,
+                                                     final double rMaxLon, final double centerLat, final double centerLon,
                                                      final double radiusMeters, final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersOutsideCircleSloppy(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters);
+      return rectAnyCornersOutsideCircleSloppy(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters);
     }
     // if span is less than 70 degrees we can approximate using distance alone
-    if (Math.abs(rMaxX - rMinX) <= 70.0) {
-      return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) > radiusMeters;
+    if (Math.abs(rMaxLon - rMinLon) <= 70.0) {
+      return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) > radiusMeters;
     }
-    return rectCrossesOblateCircle(centerLon, centerLat, radiusMeters, rMinX, rMinY, rMaxX, rMaxY);
+    return rectCrossesOblateCircle(centerLat, centerLon,
+                                   radiusMeters,
+                                   rMinLat, rMaxLat,
+                                   rMinLon, rMaxLon);
   }
 
   /**
-   * Compute whether the rectangle (defined by min/max Lon/Lat) crosses a potentially oblate circle
+   * Compute whether the rectangle (defined by min/max Lat/Lon) crosses a potentially oblate circle
    *
    * TODO benchmark for replacing existing rectCrossesCircle.
    */
-  public static boolean rectCrossesOblateCircle(double centerLon, double centerLat, double radiusMeters, double rMinLon, double rMinLat, double  rMaxLon, double rMaxLat) {
+  private static boolean rectCrossesOblateCircle(double centerLat, double centerLon,
+                                                 double radiusMeters,
+                                                 double rMinLat, double rMaxLat,
+                                                 double rMinLon, double rMaxLon) {
     double w = Math.abs(rMaxLon - rMinLon);
     final int segs = (int)Math.ceil(w / 45.0);
     w /= segs;
@@ -373,14 +380,14 @@ public class GeoRelationUtils {
       // else we treat as an oblate circle by slicing the longitude space and checking the azimuthal range
       // OPTIMIZATION: this is only executed for latitude values "closeTo" the poles (e.g., 88.0 > lat < -88.0)
       if ( (rMaxLat > 88.0 || rMinLat < -88.0)
-          && (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(p1, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(p1, rMinLat, p1, rMaxLat), radiusMeters - d1, pt))[1] < rMinLat || pt[1] < rMaxLat
-          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, maxLon, rMaxLat), radiusMeters - d2, pt))[1] < rMinLat || pt[1] < rMaxLat
-          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, (midLon = p1 + 0.5*(maxLon - p1)), rMaxLat),
-          radiusMeters - SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, midLon), pt))[1] < rMinLat
-          || pt[1] < rMaxLat == false ) {
+           && (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat, p1,
+                                                                          GeoProjectionUtils.bearingGreatCircle(rMinLat, p1, rMaxLat, p1), radiusMeters - d1, pt))[1] < rMinLat || pt[1] < rMaxLat
+           || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat, maxLon,
+                                                                          GeoProjectionUtils.bearingGreatCircle(rMinLat, maxLon, rMaxLat, maxLon), radiusMeters - d2, pt))[1] < rMinLat || pt[1] < rMaxLat
+           || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(rMinLat, maxLon,
+                                                                          GeoProjectionUtils.bearingGreatCircle(rMinLat, maxLon, rMaxLat, (midLon = p1 + 0.5*(maxLon - p1))),
+                                                                          radiusMeters - SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, midLon), pt))[1] < rMinLat
+           || pt[1] < rMaxLat == false ) {
         return true;
       }
       p1 += w;
@@ -388,81 +395,77 @@ public class GeoRelationUtils {
     return false;
   }
 
-  private static boolean rectAnyCornersOutsideCircleSloppy(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                           final double centerLon, final double centerLat, final double radiusMeters) {
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) > radiusMeters;
-  }
-
-  /**
-   * Convenience method for computing whether a rectangle is within a circle using additional precision checks
-   */
-  public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                         final double centerLon, final double centerLat, final double radiusMeters) {
-    return rectWithinCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, false);
+  private static boolean rectAnyCornersOutsideCircleSloppy(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                                           final double centerLat, final double centerLon, final double radiusMeters) {
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) > radiusMeters;
   }
 
   /**
    * Computes whether a rectangle is within a circle. Note: approx == true will be faster but less precise and may
    * fail on large rectangles
    */
-  public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                         final double centerLon, final double centerLat, final double radiusMeters,
+  public static boolean rectWithinCircle(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                         final double centerLat, final double centerLon, final double radiusMeters,
                                          final boolean approx) {
-    return rectAnyCornersOutsideCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx) == false;
-  }
-
-  /**
-   * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)
-   * NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before
-   * calling this method.
-   */
-  public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                          final double centerLon, final double centerLat, final double radiusMeters) {
-    return rectCrossesCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, false);
+    return rectAnyCornersOutsideCircle(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx) == false;
   }
 
   /**
    * Computes whether a rectangle crosses a circle. Note: approx == true will be faster but less precise and may
    * fail on large rectangles
+   *
+   * <p>NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before
+   * calling this method.
    */
-  public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                          final double centerLon, final double centerLat, final double radiusMeters,
+  public static boolean rectCrossesCircle(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                          final double centerLat, final double centerLon, final double radiusMeters,
                                           final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx)
-          || isClosestPointOnRectWithinRange(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx);
+      if (rectAnyCornersInCircle(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+        return true;
+      }
+    } else {
+      if (rectAnyCornersInCircle(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx) &&
+          rectAnyCornersOutsideCircle(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+        return true;
+      }
     }
-
-    return (rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx) &&
-        rectAnyCornersOutsideCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx))
-        || isClosestPointOnRectWithinRange(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx);
+    if (isClosestPointOnRectWithinRange(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+      return true;
+    }
+    return false;
   }
 
-  private static boolean isClosestPointOnRectWithinRange(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                         final double centerLon, final double centerLat, final double radiusMeters,
+  private static boolean isClosestPointOnRectWithinRange(final double rMinLat, final double rMaxLat,
+                                                         final double rMinLon, final double rMaxLon,
+                                                         final double centerLat, final double centerLon,
+                                                         final double radiusMeters,
                                                          final boolean approx) {
     double[] closestPt = {0, 0};
-    GeoDistanceUtils.closestPointOnBBox(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, closestPt);
-    boolean haverShortCut = SloppyMath.haversinMeters(centerLat, centerLon, closestPt[1], closestPt[0]) <= radiusMeters;
+    GeoDistanceUtils.closestPointOnBBox(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, closestPt);
+    boolean haverShortCut = SloppyMath.haversinMeters(centerLat, centerLon, closestPt[0], closestPt[1]) <= radiusMeters;
     if (approx == true || haverShortCut == true) {
       return haverShortCut;
     }
-    double lon1 = rMinX;
-    double lon2 = rMaxX;
-    double lat1 = rMinY;
-    double lat2 = rMaxY;
-    if (closestPt[0] == rMinX || closestPt[0] == rMaxX) {
-      lon1 = closestPt[0];
+    double lon1 = rMinLon;
+    double lon2 = rMaxLon;
+    double lat1 = rMinLat;
+    double lat2 = rMaxLat;
+    if (closestPt[1] == rMinLon || closestPt[1] == rMaxLon) {
+      lon1 = closestPt[1];
       lon2 = lon1;
-    } else if (closestPt[1] == rMinY || closestPt[1] == rMaxY) {
-      lat1 = closestPt[1];
+    } else if (closestPt[0] == rMinLat || closestPt[0] == rMaxLat) {
+      lat1 = closestPt[0];
       lat2 = lat1;
     }
 
-    return lineCrossesSphere(lon1, lat1, 0, lon2, lat2, 0, centerLon, centerLat, 0, radiusMeters);
+    return lineCrossesSphere(lat1, lon1, 0,
+                             lat2, lon2, 0,
+                             centerLat, centerLon, 0,
+                             radiusMeters);
   }
 
   /**
@@ -480,17 +483,18 @@ public class GeoRelationUtils {
    * @param radiusMeters search sphere radius (in meters)
    * @return whether the provided line segment is a secant of the
    */
-  private static boolean lineCrossesSphere(double lon1, double lat1, double alt1, double lon2,
-                                           double lat2, double alt2, double centerLon, double centerLat,
-                                           double centerAlt, double radiusMeters) {
+  private static boolean lineCrossesSphere(double lat1, double lon1, double alt1,
+                                           double lat2, double lon2, double alt2,
+                                           double centerLat, double centerLon, double centerAlt,
+                                           double radiusMeters) {
     // convert to cartesian 3d (in meters)
-    double[] ecf1 = GeoProjectionUtils.llaToECF(lon1, lat1, alt1, null);
-    double[] ecf2 = GeoProjectionUtils.llaToECF(lon2, lat2, alt2, null);
-    double[] cntr = GeoProjectionUtils.llaToECF(centerLon, centerLat, centerAlt, null);
+    double[] ecf1 = GeoProjectionUtils.llaToECF(lat1, lon1, alt1, null);
+    double[] ecf2 = GeoProjectionUtils.llaToECF(lat2, lon2, alt2, null);
+    double[] cntr = GeoProjectionUtils.llaToECF(centerLat, centerLon, centerAlt, null);
 
     // convert radius from arc radius to cartesian radius
-    double[] oneEighty = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(centerLon, centerLat, 180.0d, radiusMeters, new double[3]);
-    GeoProjectionUtils.llaToECF(oneEighty[0], oneEighty[1], 0, oneEighty);
+    double[] oneEighty = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(centerLat, centerLon, 180.0d, radiusMeters, new double[3]);
+    GeoProjectionUtils.llaToECF(oneEighty[1], oneEighty[0], 0, oneEighty);
 
     radiusMeters = GeoDistanceUtils.linearDistance(oneEighty, cntr);//   Math.sqrt(oneEighty[0]*cntr[0] + oneEighty[1]*cntr[1] + oneEighty[2]*cntr[2]);
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
index 6d755ce..935da60 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
@@ -34,7 +34,6 @@ import static org.apache.lucene.spatial.util.GeoProjectionUtils.MAX_LAT_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MAX_LON_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MIN_LAT_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MIN_LON_RADIANS;
-import static org.apache.lucene.spatial.util.GeoProjectionUtils.pointFromLonLatBearingGreatCircle;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.SEMIMAJOR_AXIS;
 
 /**
@@ -93,42 +92,8 @@ public final class GeoUtils {
     return (off <= 180 ? off : 360-off) - 90;
   }
 
-  /**
-   * Converts a given circle (defined as a point/radius) to an approximated line-segment polygon
-   *
-   * @param lon          longitudinal center of circle (in degrees)
-   * @param lat          latitudinal center of circle (in degrees)
-   * @param radiusMeters distance radius of circle (in meters)
-   * @return a list of lon/lat points representing the circle
-   */
-  @SuppressWarnings({"unchecked", "rawtypes"})
-  public static ArrayList<double[]> circleToPoly(final double lon, final double lat, final double radiusMeters) {
-    double angle;
-    // a little under-sampling (to limit the number of polygonal points): using archimedes estimation of pi
-    final int sides = 25;
-    ArrayList<double[]> geometry = new ArrayList();
-    double[] lons = new double[sides];
-    double[] lats = new double[sides];
-
-    double[] pt = new double[2];
-    final int sidesLen = sides - 1;
-    for (int i = 0; i < sidesLen; ++i) {
-      angle = (i * 360 / sides);
-      pt = pointFromLonLatBearingGreatCircle(lon, lat, angle, radiusMeters, pt);
-      lons[i] = pt[0];
-      lats[i] = pt[1];
-    }
-    // close the poly
-    lons[sidesLen] = lons[0];
-    lats[sidesLen] = lats[0];
-    geometry.add(lons);
-    geometry.add(lats);
-
-    return geometry;
-  }
-
   /** Compute Bounding Box for a circle using WGS-84 parameters */
-  public static GeoRect circleToBBox(final double centerLon, final double centerLat, final double radiusMeters) {
+  public static GeoRect circleToBBox(final double centerLat, final double centerLon, final double radiusMeters) {
     final double radLat = TO_RADIANS * centerLat;
     final double radLon = TO_RADIANS * centerLon;
     double radDistance = radiusMeters / SEMIMAJOR_AXIS;
@@ -155,11 +120,11 @@ public final class GeoUtils {
       maxLon = MAX_LON_RADIANS;
     }
 
-    return new GeoRect(TO_DEGREES * minLon, TO_DEGREES * maxLon, TO_DEGREES * minLat, TO_DEGREES * maxLat);
+    return new GeoRect(TO_DEGREES * minLat, TO_DEGREES * maxLat, TO_DEGREES * minLon, TO_DEGREES * maxLon);
   }
 
   /** Compute Bounding Box for a polygon using WGS-84 parameters */
-  public static GeoRect polyToBBox(double[] polyLons, double[] polyLats) {
+  public static GeoRect polyToBBox(double[] polyLats, double[] polyLons) {
     if (polyLons.length != polyLats.length) {
       throw new IllegalArgumentException("polyLons and polyLats must be equal length");
     }
@@ -182,14 +147,14 @@ public final class GeoUtils {
       maxLat = max(polyLats[i], maxLat);
     }
     // expand bounding box by TOLERANCE factor to handle round-off error
-    return new GeoRect(max(minLon - TOLERANCE, MIN_LON_INCL), min(maxLon + TOLERANCE, MAX_LON_INCL),
-        max(minLat - TOLERANCE, MIN_LAT_INCL), min(maxLat + TOLERANCE, MAX_LAT_INCL));
+    return new GeoRect(max(minLat - TOLERANCE, MIN_LAT_INCL), min(maxLat + TOLERANCE, MAX_LAT_INCL),
+                       max(minLon - TOLERANCE, MIN_LON_INCL), min(maxLon + TOLERANCE, MAX_LON_INCL));
   }
   
-
   // some sloppyish stuff, do we really need this to be done in a sloppy way?
   // unless it is performance sensitive, we should try to remove.
   static final double PIO2 = Math.PI / 2D;
+
   /**
    * Returns the trigonometric sine of an angle converted as a cos operation.
    * <p>
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointField.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointField.java
index fbbf643..41136b9 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointField.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointField.java
@@ -53,22 +53,22 @@ public class TestGeoPointField extends LuceneTestCase {
 
     // this is a simple systematic test
     GeoPointField[] pts = new GeoPointField[] {
-        new GeoPointField(FIELD_NAME, -96.774, 32.763420, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7759895324707, 32.7559529921407, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.77701950073242, 32.77866942010977, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7706036567688, 32.7756745755423, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -139.73458170890808, 27.703618681345585, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.4538113027811, 32.94823588839368, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.65084838867188, 33.06047141970814, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7772, 32.778650, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -177.23537676036358, -88.56029371730983, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -26.779373834241003, 33.541429799076354, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -77.35379276106497, 26.774024500421728, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -14.796283808944777, -90.0, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -178.8538113027811, 32.94823588839368, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, 178.8538113027811, 32.94823588839368, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -73.998776, 40.720611, GeoPointField.PREFIX_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -179.5, -44.5, GeoPointField.PREFIX_TYPE_NOT_STORED)};
+        new GeoPointField(FIELD_NAME, 32.763420, -96.774, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.7559529921407, -96.7759895324707, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.77866942010977, -96.77701950073242, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.7756745755423, -96.7706036567688, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 27.703618681345585, -139.73458170890808, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, -96.4538113027811, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 33.06047141970814, -96.65084838867188, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.778650, -96.7772, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -88.56029371730983, -177.23537676036358, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 33.541429799076354, -26.779373834241003, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 26.774024500421728, -77.35379276106497, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -90.0, -14.796283808944777, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, -178.8538113027811, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, 178.8538113027811, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 40.720611, -73.998776, GeoPointField.PREFIX_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -44.5, -179.5, GeoPointField.PREFIX_TYPE_NOT_STORED)};
 
     for (GeoPointField p : pts) {
         Document doc = new Document();
@@ -105,37 +105,39 @@ public class TestGeoPointField extends LuceneTestCase {
     directory = null;
   }
 
-  private TopDocs bboxQuery(double minLon, double minLat, double maxLon, double maxLat, int limit) throws Exception {
-    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, TermEncoding.PREFIX, minLon, minLat, maxLon, maxLat);
+  private TopDocs bboxQuery(double minLat, double maxLat, double minLon, double maxLon, int limit) throws Exception {
+    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, TermEncoding.PREFIX, minLat, maxLat, minLon, maxLon);
     return searcher.search(q, limit);
   }
 
-  private TopDocs polygonQuery(double[] lon, double[] lat, int limit) throws Exception {
-    GeoPointInPolygonQuery q = new GeoPointInPolygonQuery(FIELD_NAME, TermEncoding.PREFIX, lon, lat);
+  private TopDocs polygonQuery(double[] polyLats, double[] polyLons, int limit) throws Exception {
+    GeoPointInPolygonQuery q = new GeoPointInPolygonQuery(FIELD_NAME, TermEncoding.PREFIX, polyLats, polyLons);
     return searcher.search(q, limit);
   }
 
-  private TopDocs geoDistanceQuery(double lon, double lat, double radius, int limit) throws Exception {
-    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, TermEncoding.PREFIX, lon, lat, radius);
+  private TopDocs geoDistanceQuery(double lat, double lon, double radius, int limit) throws Exception {
+    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, TermEncoding.PREFIX, lat, lon, radius);
     return searcher.search(q, limit);
   }
 
-  private TopDocs geoDistanceRangeQuery(double lon, double lat, double minRadius, double maxRadius, int limit)
+  private TopDocs geoDistanceRangeQuery(double lat, double lon, double minRadius, double maxRadius, int limit)
       throws Exception {
-    GeoPointDistanceRangeQuery q = new GeoPointDistanceRangeQuery(FIELD_NAME, TermEncoding.PREFIX, lon, lat, minRadius, maxRadius);
+    GeoPointDistanceRangeQuery q = new GeoPointDistanceRangeQuery(FIELD_NAME, TermEncoding.PREFIX, lat, lon, minRadius, maxRadius);
     return searcher.search(q, limit);
   }
 
   public void testBBoxQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.7772, 32.778650, -96.77690000, 32.778950, 5);
+    TopDocs td = bboxQuery(32.778650, 32.778950, -96.7772, -96.77690000, 5);
     assertEquals("GeoBoundingBoxQuery failed", 4, td.totalHits);
   }
 
   public void testPolyQuery() throws Exception {
-    TopDocs td = polygonQuery(new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
-            -96.6041564, -96.7449188, -96.76826477, -96.7682647},
-        new double[]{33.073130, 32.9942669, 32.938386, 33.0374494,
-            33.1369762, 33.1162747, 33.073130, 33.073130}, 5);
+        TopDocs td = polygonQuery(
+            new double[]{33.073130, 32.9942669, 32.938386, 33.0374494,
+                33.1369762, 33.1162747, 33.073130, 33.073130},
+            new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
+                         -96.6041564, -96.7449188, -96.76826477, -96.7682647},
+            5);
     assertEquals("GeoPolygonQuery failed", 2, td.totalHits);
   }
 
@@ -157,56 +159,56 @@ public class TestGeoPointField extends LuceneTestCase {
     double yMax = 1;//5;
 
     // test cell crossing poly
-    assertTrue(GeoRelationUtils.rectCrossesPolyApprox(xMin, yMin, xMax, yMax, px, py, xMinA, yMinA, xMaxA, yMaxA));
-    assertFalse(GeoRelationUtils.rectCrossesPolyApprox(-5, 0,  0.000001, 5, px, py, xMin, yMin, xMax, yMax));
-    assertTrue(GeoRelationUtils.rectWithinPolyApprox(-5, 0, -2, 5, px, py, xMin, yMin, xMax, yMax));
+    assertTrue(GeoRelationUtils.rectCrossesPolyApprox(yMin, yMax, xMin, yMax, py, px, yMinA, yMaxA, xMinA, xMaxA));
+    assertFalse(GeoRelationUtils.rectCrossesPolyApprox(0, 5, -5, 0.000001, py, px, yMin, yMax, xMin, xMax));
+    assertTrue(GeoRelationUtils.rectWithinPolyApprox(0, 5, -5, -2, py, px, yMin, yMax, xMin, xMax));
   }
 
   public void testBBoxCrossDateline() throws Exception {
-    TopDocs td = bboxQuery(179.0, -45.0, -179.0, -44.0, 20);
+    TopDocs td = bboxQuery(-45.0, -44.0, 179.0, -179.0, 20);
     assertEquals("BBoxCrossDateline query failed", 2, td.totalHits);
   }
 
   public void testWholeMap() throws Exception {
-    TopDocs td = bboxQuery(GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LAT_INCL, 20);
-    assertEquals("testWholeMap failed", 24, td.totalHits);
-    td = polygonQuery(new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
-        new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL}, 20);
+    TopDocs td = bboxQuery(GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, 20);
     assertEquals("testWholeMap failed", 24, td.totalHits);
+    td = polygonQuery(new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL},
+                      new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
+                      20);    assertEquals("testWholeMap failed", 24, td.totalHits);
   }
 
   public void smallTest() throws Exception {
-    TopDocs td = geoDistanceQuery(-73.998776, 40.720611, 1, 20);
+    TopDocs td = geoDistanceQuery(40.720611, -73.998776, 1, 20);
     assertEquals("smallTest failed", 2, td.totalHits);
   }
 
   // GeoBoundingBox should not accept invalid lat/lon
   public void testInvalidBBox() throws Exception {
     expectThrows(Exception.class, () -> {
-      bboxQuery(179.0, -92.0, 181.0, -91.0, 20);
+      bboxQuery(-92.0, -91.0, 179.0, 181.0, 20);
     });
   }
 
   public void testGeoDistanceQuery() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -96.4538113027811, 6000, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   /** see https://issues.apache.org/jira/browse/LUCENE-6905 */
   public void testNonEmptyTermsEnum() throws Exception {
-    TopDocs td = geoDistanceQuery(-177.23537676036358, -88.56029371730983, 7757.999232959935, 20);
+    TopDocs td = geoDistanceQuery(-88.56029371730983, -177.23537676036358, 7757.999232959935, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   public void testMultiValuedQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.4538113027811, 32.7559529921407, -96.7706036567688, 32.7756745755423, 20);
+    TopDocs td = bboxQuery(32.7559529921407, 32.7756745755423, -96.4538113027811, -96.7706036567688, 20);
     // 3 single valued docs + 2 multi-valued docs
     assertEquals("testMultiValuedQuery failed", 5, td.totalHits);
   }
 
   public void testTooBigRadius() throws Exception {
     IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      geoDistanceQuery(0.0, 85.0, 4000000, 20);
+      geoDistanceQuery(85.0, 0.0, 4000000, 20);
     });
     assertTrue(expected.getMessage().contains("exceeds maxRadius"));
   }
@@ -215,19 +217,19 @@ public class TestGeoPointField extends LuceneTestCase {
    * Explicitly large
    */
   public void testGeoDistanceQueryHuge() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -96.4538113027811, 6000000, 20);
     assertEquals("GeoDistanceQuery failed", 16, td.totalHits);
   }
 
   public void testGeoDistanceQueryCrossDateline() throws Exception {
-    TopDocs td = geoDistanceQuery(-179.9538113027811, 32.94823588839368, 120000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -179.9538113027811, 120000, 20);
     assertEquals("GeoDistanceQuery failed", 3, td.totalHits);
   }
 
   // GeoDistanceQuery should not accept invalid lat/lon as origin
   public void testInvalidGeoDistanceQuery() throws Exception {
     expectThrows(Exception.class, () -> {
-      geoDistanceQuery(181.0, 92.0, 120000, 20);
+      geoDistanceQuery(92.0, 181.0, 120000, 20);
     });
   }
 
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
index 3bf22d3..53ff25c 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
@@ -43,27 +43,27 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
 
   @Override
   protected void addPointToDoc(String field, Document doc, double lat, double lon) {
-    doc.add(new GeoPointField(field, lon, lat, GeoPointField.PREFIX_TYPE_NOT_STORED));
+    doc.add(new GeoPointField(field, lat, lon, GeoPointField.PREFIX_TYPE_NOT_STORED));
   }
 
   @Override
   protected Query newRectQuery(String field, GeoRect rect) {
-    return new GeoPointInBBoxQuery(field, TermEncoding.PREFIX, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+    return new GeoPointInBBoxQuery(field, TermEncoding.PREFIX, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
   }
 
   @Override
   protected Query newDistanceQuery(String field, double centerLat, double centerLon, double radiusMeters) {
-    return new GeoPointDistanceQuery(field, TermEncoding.PREFIX, centerLon, centerLat, radiusMeters);
+    return new GeoPointDistanceQuery(field, TermEncoding.PREFIX, centerLat, centerLon, radiusMeters);
   }
 
   @Override
   protected Query newDistanceRangeQuery(String field, double centerLat, double centerLon, double minRadiusMeters, double radiusMeters) {
-    return new GeoPointDistanceRangeQuery(field, TermEncoding.PREFIX, centerLon, centerLat, minRadiusMeters, radiusMeters);
+    return new GeoPointDistanceRangeQuery(field, TermEncoding.PREFIX, centerLat, centerLon, minRadiusMeters, radiusMeters);
   }
 
   @Override
   protected Query newPolygonQuery(String field, double[] lats, double[] lons) {
-    return new GeoPointInPolygonQuery(field, TermEncoding.PREFIX, lons, lats);
+    return new GeoPointInPolygonQuery(field, TermEncoding.PREFIX, lats, lons);
   }
 
   @Override
@@ -77,11 +77,11 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
     }
 
     if (rect.minLon < rect.maxLon) {
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
     } else {
       // Rect crosses dateline:
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)
-          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)
+        || GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);
     }
   }
 
@@ -112,10 +112,10 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
 
   private static boolean radiusQueryCanBeWrong(double centerLat, double centerLon, double ptLon, double ptLat,
                                                final double radius) {
-    final long hashedCntr = GeoEncodingUtils.mortonHash(centerLon, centerLat);
+    final long hashedCntr = GeoEncodingUtils.mortonHash(centerLat, centerLon);
     centerLon = GeoEncodingUtils.mortonUnhashLon(hashedCntr);
     centerLat = GeoEncodingUtils.mortonUnhashLat(hashedCntr);
-    final long hashedPt = GeoEncodingUtils.mortonHash(ptLon, ptLat);
+    final long hashedPt = GeoEncodingUtils.mortonHash(ptLat, ptLon);
     ptLon = GeoEncodingUtils.mortonUnhashLon(hashedPt);
     ptLat = GeoEncodingUtils.mortonUnhashLat(hashedPt);
 
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointField.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointField.java
index 69a3c3f..beab5b9 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointField.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointField.java
@@ -55,22 +55,22 @@ public class TestLegacyGeoPointField extends LuceneTestCase {
 
     // this is a simple systematic test
     GeoPointField[] pts = new GeoPointField[] {
-        new GeoPointField(FIELD_NAME, -96.774, 32.763420, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7759895324707, 32.7559529921407, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.77701950073242, 32.77866942010977, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7706036567688, 32.7756745755423, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -139.73458170890808, 27.703618681345585, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.4538113027811, 32.94823588839368, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.65084838867188, 33.06047141970814, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -96.7772, 32.778650, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -177.23537676036358, -88.56029371730983, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -26.779373834241003, 33.541429799076354, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -77.35379276106497, 26.774024500421728, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -14.796283808944777, -90.0, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -178.8538113027811, 32.94823588839368, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, 178.8538113027811, 32.94823588839368, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -73.998776, 40.720611, GeoPointField.NUMERIC_TYPE_NOT_STORED),
-        new GeoPointField(FIELD_NAME, -179.5, -44.5, GeoPointField.NUMERIC_TYPE_NOT_STORED)};
+        new GeoPointField(FIELD_NAME, 32.763420, -96.774, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.7559529921407, -96.7759895324707, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.77866942010977, -96.77701950073242, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.7756745755423, -96.7706036567688, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 27.703618681345585, -139.73458170890808, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, -96.4538113027811, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 33.06047141970814, -96.65084838867188, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.778650, -96.7772, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -88.56029371730983, -177.23537676036358, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 33.541429799076354, -26.779373834241003, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 26.774024500421728, -77.35379276106497, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -90.0, -14.796283808944777, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, -178.8538113027811, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 32.94823588839368, 178.8538113027811, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, 40.720611, -73.998776, GeoPointField.NUMERIC_TYPE_NOT_STORED),
+        new GeoPointField(FIELD_NAME, -44.5, -179.5, GeoPointField.NUMERIC_TYPE_NOT_STORED)};
 
     for (GeoPointField p : pts) {
         Document doc = new Document();
@@ -107,37 +107,39 @@ public class TestLegacyGeoPointField extends LuceneTestCase {
     directory = null;
   }
 
-  private TopDocs bboxQuery(double minLon, double minLat, double maxLon, double maxLat, int limit) throws Exception {
-    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, TermEncoding.NUMERIC, minLon, minLat, maxLon, maxLat);
+  private TopDocs bboxQuery(double minLat, double maxLat, double minLon, double maxLon, int limit) throws Exception {
+    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, TermEncoding.NUMERIC, minLat, maxLat, minLon, maxLon);
     return searcher.search(q, limit);
   }
 
-  private TopDocs polygonQuery(double[] lon, double[] lat, int limit) throws Exception {
-    GeoPointInPolygonQuery q = new GeoPointInPolygonQuery(FIELD_NAME, TermEncoding.NUMERIC, lon, lat);
+  private TopDocs polygonQuery(double[] polyLats, double[] polyLons, int limit) throws Exception {
+    GeoPointInPolygonQuery q = new GeoPointInPolygonQuery(FIELD_NAME, TermEncoding.NUMERIC, polyLats, polyLons);
     return searcher.search(q, limit);
   }
 
-  private TopDocs geoDistanceQuery(double lon, double lat, double radius, int limit) throws Exception {
-    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, TermEncoding.NUMERIC, lon, lat, radius);
+  private TopDocs geoDistanceQuery(double lat, double lon, double radius, int limit) throws Exception {
+    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, TermEncoding.NUMERIC, lat, lon, radius);
     return searcher.search(q, limit);
   }
 
-  private TopDocs geoDistanceRangeQuery(double lon, double lat, double minRadius, double maxRadius, int limit)
+  private TopDocs geoDistanceRangeQuery(double lat, double lon, double minRadius, double maxRadius, int limit)
       throws Exception {
-    GeoPointDistanceRangeQuery q = new GeoPointDistanceRangeQuery(FIELD_NAME, TermEncoding.NUMERIC, lon, lat, minRadius, maxRadius);
+    GeoPointDistanceRangeQuery q = new GeoPointDistanceRangeQuery(FIELD_NAME, TermEncoding.NUMERIC, lat, lon, minRadius, maxRadius);
     return searcher.search(q, limit);
   }
 
   public void testBBoxQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.7772, 32.778650, -96.77690000, 32.778950, 5);
+    TopDocs td = bboxQuery(32.778650, 32.778950, -96.7772, -96.77690000, 5);
     assertEquals("GeoBoundingBoxQuery failed", 4, td.totalHits);
   }
 
   public void testPolyQuery() throws Exception {
-    TopDocs td = polygonQuery(new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
-            -96.6041564, -96.7449188, -96.76826477, -96.7682647},
+    TopDocs td = polygonQuery(
         new double[]{33.073130, 32.9942669, 32.938386, 33.0374494,
-            33.1369762, 33.1162747, 33.073130, 33.073130}, 5);
+            33.1369762, 33.1162747, 33.073130, 33.073130},
+        new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
+                     -96.6041564, -96.7449188, -96.76826477, -96.7682647},
+        5);
     assertEquals("GeoPolygonQuery failed", 2, td.totalHits);
   }
 
@@ -159,56 +161,56 @@ public class TestLegacyGeoPointField extends LuceneTestCase {
     double yMax = 1;//5;
 
     // test cell crossing poly
-    assertTrue(GeoRelationUtils.rectCrossesPolyApprox(xMin, yMin, xMax, yMax, px, py, xMinA, yMinA, xMaxA, yMaxA));
-    assertFalse(GeoRelationUtils.rectCrossesPolyApprox(-5, 0,  0.000001, 5, px, py, xMin, yMin, xMax, yMax));
-    assertTrue(GeoRelationUtils.rectWithinPolyApprox(-5, 0, -2, 5, px, py, xMin, yMin, xMax, yMax));
+    assertTrue(GeoRelationUtils.rectCrossesPolyApprox(yMin, yMax, xMin, yMax, py, px, yMinA, yMaxA, xMinA, xMaxA));
+    assertFalse(GeoRelationUtils.rectCrossesPolyApprox(0, 5, -5, 0.000001, py, px, yMin, yMax, xMin, xMax));
+    assertTrue(GeoRelationUtils.rectWithinPolyApprox(0, 5, -5, -2, py, px, yMin, yMax, xMin, xMax));
   }
 
   public void testBBoxCrossDateline() throws Exception {
-    TopDocs td = bboxQuery(179.0, -45.0, -179.0, -44.0, 20);
+    TopDocs td = bboxQuery(-45.0, -44.0, 179.0, -179.0, 20);
     assertEquals("BBoxCrossDateline query failed", 2, td.totalHits);
   }
 
   public void testWholeMap() throws Exception {
-    TopDocs td = bboxQuery(GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LAT_INCL, 20);
-    assertEquals("testWholeMap failed", 24, td.totalHits);
-    td = polygonQuery(new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
-        new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL}, 20);
+    TopDocs td = bboxQuery(GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, 20);
     assertEquals("testWholeMap failed", 24, td.totalHits);
+    td = polygonQuery(new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL},
+                      new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
+                      20);    assertEquals("testWholeMap failed", 24, td.totalHits);
   }
 
   public void smallTest() throws Exception {
-    TopDocs td = geoDistanceQuery(-73.998776, 40.720611, 1, 20);
+    TopDocs td = geoDistanceQuery(40.720611, -73.998776, 1, 20);
     assertEquals("smallTest failed", 2, td.totalHits);
   }
 
   // GeoBoundingBox should not accept invalid lat/lon
   public void testInvalidBBox() throws Exception {
     expectThrows(Exception.class, () -> {
-      bboxQuery(179.0, -92.0, 181.0, -91.0, 20);
+      bboxQuery(-92.0, -91.0, 179.0, 181.0, 20);
     });
   }
 
   public void testGeoDistanceQuery() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -96.4538113027811, 6000, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   /** see https://issues.apache.org/jira/browse/LUCENE-6905 */
   public void testNonEmptyTermsEnum() throws Exception {
-    TopDocs td = geoDistanceQuery(-177.23537676036358, -88.56029371730983, 7757.999232959935, 20);
+    TopDocs td = geoDistanceQuery(-88.56029371730983, -177.23537676036358, 7757.999232959935, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   public void testMultiValuedQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.4538113027811, 32.7559529921407, -96.7706036567688, 32.7756745755423, 20);
+    TopDocs td = bboxQuery(32.7559529921407, 32.7756745755423, -96.4538113027811, -96.7706036567688, 20);
     // 3 single valued docs + 2 multi-valued docs
     assertEquals("testMultiValuedQuery failed", 5, td.totalHits);
   }
 
   public void testTooBigRadius() throws Exception {
     IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      geoDistanceQuery(0.0, 85.0, 4000000, 20);
+      geoDistanceQuery(85.0, 0.0, 4000000, 20);
     });
     assertTrue(expected.getMessage().contains("exceeds maxRadius"));
   }
@@ -217,19 +219,19 @@ public class TestLegacyGeoPointField extends LuceneTestCase {
    * Explicitly large
    */
   public void testGeoDistanceQueryHuge() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -96.4538113027811, 6000000, 20);
     assertEquals("GeoDistanceQuery failed", 16, td.totalHits);
   }
 
   public void testGeoDistanceQueryCrossDateline() throws Exception {
-    TopDocs td = geoDistanceQuery(-179.9538113027811, 32.94823588839368, 120000, 20);
+    TopDocs td = geoDistanceQuery(32.94823588839368, -179.9538113027811, 120000, 20);
     assertEquals("GeoDistanceQuery failed", 3, td.totalHits);
   }
 
   // GeoDistanceQuery should not accept invalid lat/lon as origin
   public void testInvalidGeoDistanceQuery() throws Exception {
     expectThrows(Exception.class, () -> {
-      geoDistanceQuery(181.0, 92.0, 120000, 20);
+      geoDistanceQuery(92.0, 181.0, 120000, 20);
     });
   }
 
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
index c20faffd..90bfb10 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
@@ -42,27 +42,27 @@ public class TestLegacyGeoPointQuery extends BaseGeoPointTestCase {
 
   @Override
   protected void addPointToDoc(String field, Document doc, double lat, double lon) {
-    doc.add(new GeoPointField(field, lon, lat, GeoPointField.NUMERIC_TYPE_NOT_STORED));
+    doc.add(new GeoPointField(field, lat, lon, GeoPointField.NUMERIC_TYPE_NOT_STORED));
   }
 
   @Override
   protected Query newRectQuery(String field, GeoRect rect) {
-    return new GeoPointInBBoxQuery(field, TermEncoding.NUMERIC, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+    return new GeoPointInBBoxQuery(field, TermEncoding.NUMERIC, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
   }
 
   @Override
   protected Query newDistanceQuery(String field, double centerLat, double centerLon, double radiusMeters) {
-    return new GeoPointDistanceQuery(field, TermEncoding.NUMERIC, centerLon, centerLat, radiusMeters);
+    return new GeoPointDistanceQuery(field, TermEncoding.NUMERIC, centerLat, centerLon, radiusMeters);
   }
 
   @Override
   protected Query newDistanceRangeQuery(String field, double centerLat, double centerLon, double minRadiusMeters, double radiusMeters) {
-    return new GeoPointDistanceRangeQuery(field, TermEncoding.NUMERIC, centerLon, centerLat, minRadiusMeters, radiusMeters);
+    return new GeoPointDistanceRangeQuery(field, TermEncoding.NUMERIC, centerLat, centerLon, minRadiusMeters, radiusMeters);
   }
 
   @Override
   protected Query newPolygonQuery(String field, double[] lats, double[] lons) {
-    return new GeoPointInPolygonQuery(field, TermEncoding.NUMERIC, lons, lats);
+    return new GeoPointInPolygonQuery(field, TermEncoding.NUMERIC, lats, lons);
   }
 
   @Override
@@ -76,11 +76,11 @@ public class TestLegacyGeoPointQuery extends BaseGeoPointTestCase {
     }
 
     if (rect.minLon < rect.maxLon) {
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
     } else {
       // Rect crosses dateline:
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)
-          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);
+      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)
+        || GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);
     }
   }
 
@@ -111,10 +111,10 @@ public class TestLegacyGeoPointQuery extends BaseGeoPointTestCase {
 
   private static boolean radiusQueryCanBeWrong(double centerLat, double centerLon, double ptLon, double ptLat,
                                                final double radius) {
-    final long hashedCntr = GeoEncodingUtils.mortonHash(centerLon, centerLat);
+    final long hashedCntr = GeoEncodingUtils.mortonHash(centerLat, centerLon);
     centerLon = GeoEncodingUtils.mortonUnhashLon(hashedCntr);
     centerLat = GeoEncodingUtils.mortonUnhashLat(hashedCntr);
-    final long hashedPt = GeoEncodingUtils.mortonHash(ptLon, ptLat);
+    final long hashedPt = GeoEncodingUtils.mortonHash(ptLat, ptLon);
     ptLon = GeoEncodingUtils.mortonUnhashLon(hashedPt);
     ptLat = GeoEncodingUtils.mortonUnhashLat(hashedPt);
 
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
index e14ffbd..a4f70d9 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
@@ -466,7 +466,7 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       lon1 = x;
     }
 
-    return new GeoRect(lon0, lon1, lat0, lat1);
+    return new GeoRect(lat0, lat1, lon0, lon1);
   }
 
   protected void initIndexWriterConfig(String field, IndexWriterConfig iwc) {
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
index 3793832..f9dde50 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
@@ -66,154 +66,13 @@ public class TestGeoUtils extends LuceneTestCase {
     }
   }
 
-  public void testGeoHash() {
-    int numPoints = atLeast(100);
-    String randomGeoHashString;
-    String mortonGeoHash;
-    long mortonLongFromGHLong, geoHashLong, mortonLongFromGHString;
-    int randomLevel;
-    for (int i = 0; i < numPoints; ++i) {
-      // random point
-      double lat = randomLat(false);
-      double lon = randomLon(false);
-
-      // compute geohash straight from lat/lon and from morton encoded value to ensure they're the same
-      randomGeoHashString = GeoHashUtils.stringEncode(lon, lat, randomLevel = random().nextInt(12 - 1) + 1);
-      mortonGeoHash = GeoHashUtils.stringEncodeFromMortonLong(GeoEncodingUtils.mortonHash(lon, lat), randomLevel);
-      assertEquals(randomGeoHashString, mortonGeoHash);
-
-      // v&v conversion from lat/lon or geohashstring to geohash long and back to geohash string
-      geoHashLong = (random().nextBoolean()) ? GeoHashUtils.longEncode(lon, lat, randomLevel) : GeoHashUtils.longEncode(randomGeoHashString);
-      assertEquals(randomGeoHashString, GeoHashUtils.stringEncode(geoHashLong));
-
-      // v&v conversion from geohash long to morton long
-      mortonLongFromGHString = GeoHashUtils.mortonEncode(randomGeoHashString);
-      mortonLongFromGHLong = GeoHashUtils.mortonEncode(geoHashLong);
-      assertEquals(mortonLongFromGHLong, mortonLongFromGHString);
-
-      // v&v lat/lon from geohash string and geohash long
-      assertEquals(GeoEncodingUtils.mortonUnhashLat(mortonLongFromGHString), GeoEncodingUtils.mortonUnhashLat(mortonLongFromGHLong), 0);
-      assertEquals(GeoEncodingUtils.mortonUnhashLon(mortonLongFromGHString), GeoEncodingUtils.mortonUnhashLon(mortonLongFromGHLong), 0);
-    }
-  }
-
-  /**
-   * Pass condition: lat=42.6, lng=-5.6 should be encoded as "ezs42e44yx96",
-   * lat=57.64911 lng=10.40744 should be encoded as "u4pruydqqvj8"
-   */
-  public void testEncode() {
-    String hash = GeoHashUtils.stringEncode(-5.6, 42.6, 12);
-    assertEquals("ezs42e44yx96", hash);
-
-    hash = GeoHashUtils.stringEncode(10.40744, 57.64911, 12);
-    assertEquals("u4pruydqqvj8", hash);
-  }
-
-  /**
-   * Pass condition: lat=52.3738007, lng=4.8909347 should be encoded and then
-   * decoded within 0.00001 of the original value
-   */
-  public void testDecodePreciseLongitudeLatitude() {
-    final String geohash = GeoHashUtils.stringEncode(4.8909347, 52.3738007);
-    final long hash = GeoHashUtils.mortonEncode(geohash);
-
-    assertEquals(52.3738007, GeoEncodingUtils.mortonUnhashLat(hash), 0.00001D);
-    assertEquals(4.8909347, GeoEncodingUtils.mortonUnhashLon(hash), 0.00001D);
-  }
-
-  /**
-   * Pass condition: lat=84.6, lng=10.5 should be encoded and then decoded
-   * within 0.00001 of the original value
-   */
-  public void testDecodeImpreciseLongitudeLatitude() {
-    final String geohash = GeoHashUtils.stringEncode(10.5, 84.6);
-
-    final long hash = GeoHashUtils.mortonEncode(geohash);
-
-    assertEquals(84.6, GeoEncodingUtils.mortonUnhashLat(hash), 0.00001D);
-    assertEquals(10.5, GeoEncodingUtils.mortonUnhashLon(hash), 0.00001D);
-  }
-
-  public void testDecodeEncode() {
-    final String geoHash = "u173zq37x014";
-    assertEquals(geoHash, GeoHashUtils.stringEncode(4.8909347, 52.3738007));
-    final long mortonHash = GeoHashUtils.mortonEncode(geoHash);
-    final double lon = GeoEncodingUtils.mortonUnhashLon(mortonHash);
-    final double lat = GeoEncodingUtils.mortonUnhashLat(mortonHash);
-    assertEquals(52.37380061d, GeoEncodingUtils.mortonUnhashLat(mortonHash), 0.000001d);
-    assertEquals(4.8909343d, GeoEncodingUtils.mortonUnhashLon(mortonHash), 0.000001d);
-
-    assertEquals(geoHash, GeoHashUtils.stringEncode(lon, lat));
-  }
-
-  public void testNeighbors() {
-    String geohash = "gcpv";
-    List<String> expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("gcpw");
-    expectedNeighbors.add("gcpy");
-    expectedNeighbors.add("u10n");
-    expectedNeighbors.add("gcpt");
-    expectedNeighbors.add("u10j");
-    expectedNeighbors.add("gcps");
-    expectedNeighbors.add("gcpu");
-    expectedNeighbors.add("u10h");
-    Collection<? super String> neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border odd geohash
-    geohash = "u09x";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("u0c2");
-    expectedNeighbors.add("u0c8");
-    expectedNeighbors.add("u0cb");
-    expectedNeighbors.add("u09r");
-    expectedNeighbors.add("u09z");
-    expectedNeighbors.add("u09q");
-    expectedNeighbors.add("u09w");
-    expectedNeighbors.add("u09y");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors);
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border even geohash
-    geohash = "u09tv";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("u09wh");
-    expectedNeighbors.add("u09wj");
-    expectedNeighbors.add("u09wn");
-    expectedNeighbors.add("u09tu");
-    expectedNeighbors.add("u09ty");
-    expectedNeighbors.add("u09ts");
-    expectedNeighbors.add("u09tt");
-    expectedNeighbors.add("u09tw");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border even and odd geohash
-    geohash = "ezzzz";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("gbpbn");
-    expectedNeighbors.add("gbpbp");
-    expectedNeighbors.add("u0000");
-    expectedNeighbors.add("ezzzy");
-    expectedNeighbors.add("spbpb");
-    expectedNeighbors.add("ezzzw");
-    expectedNeighbors.add("ezzzx");
-    expectedNeighbors.add("spbp8");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-  }
-
   public void testClosestPointOnBBox() {
     double[] result = new double[2];
-    GeoDistanceUtils.closestPointOnBBox(20, 30, 40, 50, 70, 70, result);
-    assertEquals(40.0, result[0], 0.0);
-    assertEquals(50.0, result[1], 0.0);
+    GeoDistanceUtils.closestPointOnBBox(30, 50, 20, 40, 70, 70, result);
+    assertEquals(50.0, result[0], 0.0);
+    assertEquals(40.0, result[1], 0.0);
 
-    GeoDistanceUtils.closestPointOnBBox(-20, -20, 0, 0, 70, 70, result);
+    GeoDistanceUtils.closestPointOnBBox(-20, 0, -20, 0, 70, 70, result);
     assertEquals(0.0, result[0], 0.0);
     assertEquals(0.0, result[1], 0.0);
   }
@@ -331,7 +190,7 @@ public class TestGeoUtils extends LuceneTestCase {
         }
       } else {
 
-        if (GeoRelationUtils.rectWithinCircle(cell.minLon, cell.minLat, cell.maxLon, cell.maxLat, centerLon, centerLat, radiusMeters)) {
+        if (GeoRelationUtils.rectWithinCircle(cell.minLat, cell.maxLat, cell.minLon, cell.maxLon, centerLat, centerLon, radiusMeters, false)) {
           // Query circle fully contains this cell, just addAll:
           if (VERBOSE) {
             log.println("    circle fully contains cell: now addAll");
@@ -345,14 +204,14 @@ public class TestGeoUtils extends LuceneTestCase {
             }
           }
           continue;
-        } else if (GeoRelationUtils.rectWithin(root.minLon, root.minLat, root.maxLon, root.maxLat,
-                                       cell.minLon, cell.minLat, cell.maxLon, cell.maxLat)) {
+        } else if (GeoRelationUtils.rectWithin(root.minLat, root.maxLat, root.minLon, root.maxLon,
+                                               cell.minLat, cell.maxLat, cell.minLon, cell.maxLon)) {
           // Fall through below to "recurse"
           if (VERBOSE) {
             log.println("    cell fully contains circle: keep splitting");
           }
-        } else if (GeoRelationUtils.rectCrossesCircle(cell.minLon, cell.minLat, cell.maxLon, cell.maxLat,
-                                              centerLon, centerLat, radiusMeters)) {
+        } else if (GeoRelationUtils.rectCrossesCircle(cell.minLat, cell.maxLat, cell.minLon, cell.maxLon,
+                                                      centerLat, centerLon, radiusMeters, false)) {
           // Fall through below to "recurse"
           if (VERBOSE) {
             log.println("    cell overlaps circle: keep splitting");
@@ -470,7 +329,7 @@ public class TestGeoUtils extends LuceneTestCase {
         log.println("\nTEST: iter=" + iter + " radiusMeters=" + radiusMeters + " centerLon=" + centerLon + " centerLat=" + centerLat);
       }
 
-      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);
+      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);
       
       Set<Integer> hits = new HashSet<>();
 
@@ -555,7 +414,7 @@ public class TestGeoUtils extends LuceneTestCase {
     long decodedHash;
     BytesRefBuilder brb = new BytesRefBuilder();
     while (numIters-- >= 0) {
-      hash = GeoEncodingUtils.mortonHash(randomLon(false), randomLat(false));
+      hash = GeoEncodingUtils.mortonHash(randomLat(false), randomLon(false));
       for (int i=32; i<64; ++i) {
         GeoEncodingUtils.geoCodedToPrefixCoded(hash, i, brb);
         decodedHash = GeoEncodingUtils.prefixCodedToGeoCoded(brb.get());
@@ -565,7 +424,7 @@ public class TestGeoUtils extends LuceneTestCase {
   }
 
   public void testMortonEncoding() throws Exception {
-    long hash = GeoEncodingUtils.mortonHash(180, 90);
+    long hash = GeoEncodingUtils.mortonHash(90, 180);
     assertEquals(180.0, GeoEncodingUtils.mortonUnhashLon(hash), 0);
     assertEquals(90.0, GeoEncodingUtils.mortonUnhashLat(hash), 0);
   }
@@ -577,7 +436,7 @@ public class TestGeoUtils extends LuceneTestCase {
       double lat = randomLat(small);
       double lon = randomLon(small);
 
-      long enc = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc = GeoEncodingUtils.mortonHash(lat, lon);
       double latEnc = GeoEncodingUtils.mortonUnhashLat(enc);
       double lonEnc = GeoEncodingUtils.mortonUnhashLon(enc);
 
@@ -593,11 +452,11 @@ public class TestGeoUtils extends LuceneTestCase {
       double lat = randomLat(small);
       double lon = randomLon(small);
 
-      long enc = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc = GeoEncodingUtils.mortonHash(lat, lon);
       double latEnc = GeoEncodingUtils.mortonUnhashLat(enc);
       double lonEnc = GeoEncodingUtils.mortonUnhashLon(enc);
 
-      long enc2 = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc2 = GeoEncodingUtils.mortonHash(lat, lon);
       double latEnc2 = GeoEncodingUtils.mortonUnhashLat(enc2);
       double lonEnc2 = GeoEncodingUtils.mortonUnhashLon(enc2);
       assertEquals(latEnc, latEnc2, 0.0);
@@ -631,7 +490,7 @@ public class TestGeoUtils extends LuceneTestCase {
 
       // TODO: randomly quantize radius too, to provoke exact math errors?
 
-      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);
+      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);
 
       int numPointsToTry = 1000;
       for(int i=0;i<numPointsToTry;i++) {
@@ -694,12 +553,12 @@ public class TestGeoUtils extends LuceneTestCase {
       double lat = -90 + 180.0 * random().nextDouble();
       double lon = -180 + 360.0 * random().nextDouble();
       double radius = 50000000 * random().nextDouble();
-      GeoRect box = GeoUtils.circleToBBox(lon, lat, radius);
+      GeoRect box = GeoUtils.circleToBBox(lat, lon, radius);
       final GeoRect box1;
       final GeoRect box2;
       if (box.crossesDateline()) {
-        box1 = new GeoRect(-180, box.maxLon, box.minLat, box.maxLat);
-        box2 = new GeoRect(box.minLon, 180, box.minLat, box.maxLat);
+        box1 = new GeoRect(box.minLat, box.maxLat, -180, box.maxLon);
+        box2 = new GeoRect(box.minLat, box.maxLat, box.minLon, 180);
       } else {
         box1 = box;
         box2 = null;
@@ -723,7 +582,7 @@ public class TestGeoUtils extends LuceneTestCase {
       double lat = -90 + 180.0 * random().nextDouble();
       double lon = -180 + 360.0 * random().nextDouble();
       double radius = 50000000 * random().nextDouble();
-      GeoRect box = GeoUtils.circleToBBox(lon, lat, radius);
+      GeoRect box = GeoUtils.circleToBBox(lat, lon, radius);
 
       if (box.maxLon - lon < 90 && lon - box.minLon < 90) {
         double minPartialDistance = Math.max(SloppyMath.haversinSortKey(lat, lon, lat, box.maxLon),
@@ -756,6 +615,6 @@ public class TestGeoUtils extends LuceneTestCase {
   }
 
   public void testRectCrossesCircle() throws Exception {
-    assertTrue(GeoRelationUtils.rectCrossesCircle(-180, -90, 180, 0.0, 0.667, 0.0, 88000.0));
+    assertTrue(GeoRelationUtils.rectCrossesCircle(-90, 0.0, -180, 180, 0.0, 0.667, 88000.0, false));
   }
 }

