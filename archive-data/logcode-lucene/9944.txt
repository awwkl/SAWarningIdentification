GitDiffStart: f0ecefa78bb1b63cbe1eae9f5929fe3d665f95ba | Mon Jan 7 22:29:33 2013 +0000
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
index 2fdf075..1c80ce3 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesFormat.java
@@ -94,8 +94,6 @@ public class MemoryDocValuesFormat extends SimpleDocValuesFormat {
       public BinaryDocValues getBinary(FieldInfo field) throws IOException {
         BinaryDocValues valuesIn = producer.getBinary(field);
         final int maxDoc = valuesIn.size();
-        final int maxLength = valuesIn.maxLength();
-        final boolean fixedLength = valuesIn.isFixedLength();
         // nocommit more ram efficient
         final byte[][] values = new byte[maxDoc][];
         BytesRef scratch = new BytesRef();
@@ -118,16 +116,6 @@ public class MemoryDocValuesFormat extends SimpleDocValuesFormat {
           public int size() {
             return maxDoc;
           }
-
-          @Override
-          public boolean isFixedLength() {
-            return fixedLength;
-          }
-
-          @Override
-          public int maxLength() {
-            return maxLength;
-          }
         };
       }
 
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
index e7c9a1d..bf358e9 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSimpleDocValuesFormat.java
@@ -29,7 +29,6 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
 import org.apache.lucene.codecs.SimpleDVConsumer;
 import org.apache.lucene.codecs.SimpleDVProducer;
 import org.apache.lucene.codecs.SimpleDocValuesFormat;
@@ -63,10 +62,10 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
   final static BytesRef MINVALUE = new BytesRef("  minvalue ");
   final static BytesRef PATTERN  = new BytesRef("  pattern ");
   // used for bytes
-  final static BytesRef FIXEDLENGTH = new BytesRef("  fixedlength ");
-  final static BytesRef MAXLENGTH = new BytesRef("  maxlength ");
   final static BytesRef LENGTH = new BytesRef("length ");
+  final static BytesRef MAXLENGTH = new BytesRef("  maxlength ");
   // used for sorted bytes
+  final static BytesRef FIXEDLENGTH = new BytesRef("  fixedlength ");
   final static BytesRef NUMVALUES = new BytesRef("  numvalues ");
   final static BytesRef ORDPATTERN = new BytesRef("  ordpattern ");
   
@@ -101,8 +100,7 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
    *  for bytes this is also a "fixed-width" file, for example:
    *  <pre>
    *  field myField
-   *    fixedlength false
-   *    maxlength 8
+   *    maxlength 6
    *    pattern 0
    *  length 6
    *  foobar[space][space]
@@ -221,15 +219,16 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
     }
 
     @Override
-    public BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, final int maxLength) throws IOException {
+    public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {
       assert fieldSeen(field.name);
       assert DocValues.isBytes(field.getDocValuesType());
       assert !isNorms;
+      int maxLength = 0;
+      for(BytesRef value : values) {
+        maxLength = Math.max(maxLength, value.length);
+      }
       writeFieldEntry(field);
-      // write fixedlength
-      SimpleTextUtil.write(data, FIXEDLENGTH);
-      SimpleTextUtil.write(data, Boolean.toString(fixedLength), scratch);
-      SimpleTextUtil.writeNewline(data);
+
       // write maxLength
       SimpleTextUtil.write(data, MAXLENGTH);
       SimpleTextUtil.write(data, Integer.toString(maxLength), scratch);
@@ -245,34 +244,27 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
       SimpleTextUtil.write(data, sb.toString(), scratch);
       SimpleTextUtil.writeNewline(data);
       final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));
-      
-      return new BinaryDocValuesConsumer() {
-        int numDocsWritten = 0;
-        
-        @Override
-        public void add(BytesRef value) throws IOException {
-          // write length
-          SimpleTextUtil.write(data, LENGTH);
-          SimpleTextUtil.write(data, encoder.format(value.length), scratch);
-          SimpleTextUtil.writeNewline(data);
+
+      int numDocsWritten = 0;
+      for(BytesRef value : values) {
+        // write length
+        SimpleTextUtil.write(data, LENGTH);
+        SimpleTextUtil.write(data, encoder.format(value.length), scratch);
+        SimpleTextUtil.writeNewline(data);
           
-          // write bytes -- don't use SimpleText.write
-          // because it escapes:
-          data.writeBytes(value.bytes, value.offset, value.length);
+        // write bytes -- don't use SimpleText.write
+        // because it escapes:
+        data.writeBytes(value.bytes, value.offset, value.length);
 
-          // pad to fit
-          for (int i = value.length; i < maxLength; i++) {
-            data.writeByte((byte)' ');
-          }
-          SimpleTextUtil.writeNewline(data);
-          numDocsWritten++;
+        // pad to fit
+        for (int i = value.length; i < maxLength; i++) {
+          data.writeByte((byte)' ');
         }
+        SimpleTextUtil.writeNewline(data);
+        numDocsWritten++;
+      }
 
-        @Override
-        public void finish() throws IOException {
-          assert numDocs == numDocsWritten;
-        }
-      };
+      assert numDocs == numDocsWritten;
     }
     
     @Override
@@ -446,9 +438,6 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
           data.seek(data.getFilePointer() + (1+field.pattern.length()) * maxDoc);
         } else if (DocValues.isBytes(dvType)) {
           readLine();
-          assert startsWith(FIXEDLENGTH);
-          field.fixedLength = Boolean.parseBoolean(stripPrefix(FIXEDLENGTH));
-          readLine();
           assert startsWith(MAXLENGTH);
           field.maxLength = Integer.parseInt(stripPrefix(MAXLENGTH));
           readLine();
@@ -574,16 +563,6 @@ public class SimpleTextSimpleDocValuesFormat extends SimpleDocValuesFormat {
         public int size() {
           return maxDoc;
         }
-
-        @Override
-        public boolean isFixedLength() {
-          return field.fixedLength;
-        }
-
-        @Override
-        public int maxLength() {
-          return field.maxLength;
-        }
       };
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/BinaryDocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/BinaryDocValuesConsumer.java
deleted file mode 100644
index a012c4c..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/BinaryDocValuesConsumer.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package org.apache.lucene.codecs;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.index.AtomicReader;
-import org.apache.lucene.index.BinaryDocValues;
-import org.apache.lucene.index.MergeState;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-
-public abstract class BinaryDocValuesConsumer {
-  public abstract void add(BytesRef value) throws IOException;
-  public abstract void finish() throws IOException;
-  
-  public int merge(MergeState mergeState, List<BinaryDocValues> toMerge) throws IOException {
-    int docCount = 0;
-    final BytesRef bytes = new BytesRef();
-    for (int readerIDX=0;readerIDX<toMerge.size();readerIDX++) {
-      AtomicReader reader = mergeState.readers.get(readerIDX);
-      int maxDoc = reader.maxDoc();
-      Bits liveDocs = reader.getLiveDocs();
-
-      BinaryDocValues values = toMerge.get(readerIDX);
-      for (int i = 0; i < maxDoc; i++) {
-        if (liveDocs == null || liveDocs.get(i)) {
-          values.get(i, bytes);
-          add(bytes);
-        }
-        docCount++;
-        mergeState.checkAbort.work(300);
-      }
-    }
-    finish();
-    return docCount;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer.java
index 1c0b14a..b9a34ac 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/SimpleDVConsumer.java
@@ -40,7 +40,8 @@ public abstract class SimpleDVConsumer implements Closeable {
   // nocommit should we pass SegmentWriteState...?
   public abstract void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException;    
 
-  public abstract BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, int maxLength) throws IOException;
+  public abstract void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException;
+
   // nocommit: figure out whats fair here.
   public abstract SortedDocValuesConsumer addSortedField(FieldInfo field, int valueCount, boolean fixedLength, int maxLength) throws IOException;
 
@@ -114,34 +115,72 @@ public abstract class SimpleDVConsumer implements Closeable {
   }
   
   // dead simple impl: codec can optimize
-  public void mergeBinaryField(FieldInfo fieldInfo, MergeState mergeState, List<BinaryDocValues> toMerge) throws IOException {
-    // first compute fixedLength and maxLength of live ones to be merged.
-    // nocommit: messy, and can be simplified by using docValues.maxLength/fixedLength in many cases.
-    boolean fixedLength = true;
-    int maxLength = -1;
-    BytesRef bytes = new BytesRef();
-    for (int readerIDX=0;readerIDX<toMerge.size();readerIDX++) {
-      AtomicReader reader = mergeState.readers.get(readerIDX);      
-      int maxDoc = reader.maxDoc();
-      Bits liveDocs = reader.getLiveDocs();
-      BinaryDocValues values = toMerge.get(readerIDX);
-      for (int i = 0; i < maxDoc; i++) {
-        if (liveDocs == null || liveDocs.get(i)) {
-          values.get(i, bytes);
-          if (maxLength == -1) {
-            maxLength = bytes.length;
-          } else {
-            fixedLength &= bytes.length == maxLength;
-            maxLength = Math.max(bytes.length, maxLength);
-          }
-        }
-        mergeState.checkAbort.work(300);
-      }
-    }
-    // now we can merge
-    assert maxLength >= 0; // could this happen (nothing to do?)
-    BinaryDocValuesConsumer field = addBinaryField(fieldInfo, fixedLength, maxLength);
-    field.merge(mergeState, toMerge);
+  public void mergeBinaryField(FieldInfo fieldInfo, final MergeState mergeState, final List<BinaryDocValues> toMerge) throws IOException {
+
+    addBinaryField(fieldInfo,
+                   new Iterable<BytesRef>() {
+                     @Override
+                     public Iterator<BytesRef> iterator() {
+                       return new Iterator<BytesRef>() {
+                         int readerUpto = -1;
+                         int docIDUpto;
+                         BytesRef nextValue = new BytesRef();
+                         AtomicReader currentReader;
+                         BinaryDocValues currentValues;
+                         Bits currentLiveDocs;
+                         boolean nextIsSet;
+
+                         @Override
+                         public boolean hasNext() {
+                           return nextIsSet || setNext();
+                         }
+
+                         @Override
+                         public void remove() {
+                           throw new UnsupportedOperationException();
+                         }
+
+                         @Override
+                         public BytesRef next() {
+                           if (!hasNext()) {
+                             throw new NoSuchElementException();
+                           }
+                           assert nextIsSet;
+                           nextIsSet = false;
+                           // nocommit make a mutable number
+                           return nextValue;
+                         }
+
+                         private boolean setNext() {
+                           while (true) {
+                             if (readerUpto == toMerge.size()) {
+                               return false;
+                             }
+
+                             if (currentReader == null || docIDUpto == currentReader.maxDoc()) {
+                               readerUpto++;
+                               if (readerUpto < toMerge.size()) {
+                                 currentReader = mergeState.readers.get(readerUpto);
+                                 currentValues = toMerge.get(readerUpto);
+                                 currentLiveDocs = currentReader.getLiveDocs();
+                               }
+                               docIDUpto = 0;
+                               continue;
+                             }
+
+                             if (currentLiveDocs == null || currentLiveDocs.get(docIDUpto)) {
+                               nextIsSet = true;
+                               currentValues.get(docIDUpto, nextValue);
+                               docIDUpto++;
+                               return true;
+                             }
+
+                             docIDUpto++;
+                           }
+                         }
+                       };
+                     }
+                   });
   }
 
   public void mergeSortedField(FieldInfo fieldInfo, MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.java
index 7b154a1..f264b61 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41SimpleDocValuesFormat.java
@@ -21,7 +21,6 @@ import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.SimpleDVConsumer;
 import org.apache.lucene.codecs.SimpleDVProducer;
@@ -108,23 +107,23 @@ public class Lucene41SimpleDocValuesFormat extends SimpleDocValuesFormat {
     }
 
     @Override
-    public BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, int maxLength) throws IOException {
+    public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {
       meta.writeVInt(field.number);
-      meta.writeByte(fixedLength ? (byte)1 : 0);
-      meta.writeVInt(maxLength);
+      // nocommit handle var length too!!
+      int length = -1;
+      for(BytesRef v : values) {
+        if (length == -1) {
+          length = v.length;
+        } else if (length != v.length) {
+          throw new UnsupportedOperationException();
+        }
+      }
+      // nocommit don't hardwire fixedLength to 1:
+      meta.writeByte((byte) 1);
+      meta.writeVInt(length);
       meta.writeLong(data.getFilePointer());
-      if (fixedLength) {
-        return new BinaryDocValuesConsumer() {
-          @Override
-          public void add(BytesRef value) throws IOException {
-            data.writeBytes(value.bytes, value.offset, value.length);
-          }
-
-          @Override
-          public void finish() throws IOException {}
-        };
-      } else {
-        throw new UnsupportedOperationException();
+      for(BytesRef value : values) {
+        data.writeBytes(value.bytes, value.offset, value.length);
       }
     }
 
@@ -267,16 +266,6 @@ public class Lucene41SimpleDocValuesFormat extends SimpleDocValuesFormat {
         }
 
         @Override
-        public boolean isFixedLength() {
-          return entry.fixedLength;
-        }
-
-        @Override
-        public int maxLength() {
-          return entry.maxLength;
-        }
-        
-        @Override
         public int size() {
           return maxDoc;
         }
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValues.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValues.java
deleted file mode 100644
index 1c4f4fe..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValues.java
+++ /dev/null
@@ -1,165 +0,0 @@
-package org.apache.lucene.codecs.lucene41.values;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.lucene41.values.Lucene41DocValuesProducer.DocValuesFactory;
-import org.apache.lucene.index.BinaryDocValues;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.PagedBytes;
-import org.apache.lucene.util.packed.PackedInts;
-
-import static org.apache.lucene.codecs.lucene41.values.Lucene41BinaryDocValuesConsumer.*;
-
-public final class Lucene41BinaryDocValues extends BinaryDocValues {
-  private final PackedInts.Reader index;
-  private final IndexInput data;
-  private final long baseOffset;
-  private final int size;
-  private int maxLength;
-  private final DocValuesFactory<BinaryDocValues> factory;
-  
-  public Lucene41BinaryDocValues(IndexInput dataIn, long dataOffset, int size,
-      int maxLength, PackedInts.Reader index, DocValuesFactory<BinaryDocValues> factory) throws IOException {
-    this.data = dataIn;
-    
-    this.size = size;
-    this.maxLength = maxLength;
-    this.baseOffset = dataOffset;
-    this.index = index;
-    this.factory = factory;
-  }
-  
-  public void get(int docId, BytesRef result) {
-    try {
-      final long offset;
-      final int length;
-      if (index == null) {
-        offset = size * ((long) docId);
-        length = size;
-      } else {
-        offset = index.get(docId);
-        data.seek(baseOffset + offset);
-        // Safe to do 1+docID because we write sentinel at the end:
-        final long nextOffset = index.get(1 + docId);
-        length = (int) (nextOffset - offset);
-      }
-      result.offset = 0;
-      result.grow(length);
-      data.readBytes(result.bytes, 0, length);
-      result.length = length;
-    } catch (IOException ex) {
-      throw new IllegalStateException(
-          "failed to get value for docID: " + docId, ex);
-    }
-  }
-  
-  @Override
-  public int size() {
-    return size;
-  }
-  
-  @Override
-  public boolean isFixedLength() {
-    return index == null;
-  }
-  
-  @Override
-  public int maxLength() {
-    return maxLength;
-  }
-
-  public static final class Factory extends DocValuesFactory<BinaryDocValues> {
-    private final IndexInput datIn;
-    private final IndexInput indexIn;
-    private final PackedInts.Header indexHeader;
-    private int size;
-    private int maxLength;
-    private long baseOffset;
-    private final int valueCount;
-    
-    public Factory(Directory dir,
-        SegmentInfo segmentInfo, FieldInfo field, IOContext context
-        ) throws IOException {
-      boolean success = false;
-      this.valueCount = segmentInfo.getDocCount();
-      IndexInput datIn = null;
-      IndexInput indexIn = null;
-      try {
-        datIn = dir.openInput(Lucene41DocValuesConsumer.getDocValuesFileName(
-            segmentInfo, field, Lucene41DocValuesConsumer.DATA_EXTENSION),
-            context);
-        CodecUtil.checkHeader(datIn, CODEC_NAME, VERSION_START, VERSION_START);
-        
-        this.size = datIn.readInt();
-        this.maxLength = datIn.readInt();
-        this.baseOffset = datIn.getFilePointer();
-        
-        if (size == VALUE_SIZE_VAR) {
-          indexIn = dir.openInput(Lucene41DocValuesConsumer
-              .getDocValuesFileName(segmentInfo, field,
-                  Lucene41DocValuesConsumer.INDEX_EXTENSION), context);
-          CodecUtil.checkHeader(indexIn, CODEC_NAME, VERSION_START,
-              VERSION_START);
-          indexHeader = PackedInts.readHeader(indexIn);
-        } else {
-          indexIn = null;
-          indexHeader = null;
-        }
-        this.indexIn = indexIn;
-        this.datIn = datIn;
-        success = true;
-      } finally {
-        if (!success) {
-          IOUtils.closeWhileHandlingException(datIn, indexIn);
-        }
-      }
-    }
-    
-    public BinaryDocValues getDirect() throws IOException {
-      return new Lucene41BinaryDocValues(datIn.clone(), this.baseOffset, size,
-          maxLength,
-          indexHeader == null ? null : PackedInts.getDirectReaderNoHeader(
-              indexIn.clone(), indexHeader), this);
-    }
-    
-    public BinaryDocValues getInMemory() throws IOException {
-      // nocommit simple in memory impl
-      PackedInts.Reader indexReader = indexHeader == null ? null : PackedInts
-          .getReaderNoHeader(indexIn.clone(), indexHeader);
-      PagedBytes bytes = new PagedBytes(15);
-      bytes.copy(datIn.clone(), indexReader == null ? size * valueCount
-          : indexReader.get(indexReader.size() - 1));
-      bytes.freeze(true);
-      return new Lucene41BinaryDocValues(bytes.getDataInput(), 0, size,
-          maxLength, indexReader, null);
-    }
-    
-    @Override
-    public void close() throws IOException {
-      IOUtils.close(datIn, indexIn);
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValuesConsumer.java
deleted file mode 100644
index a266a8d..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41BinaryDocValuesConsumer.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package org.apache.lucene.codecs.lucene41.values;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.packed.AppendingLongBuffer;
-import org.apache.lucene.util.packed.AppendingLongBuffer.Iterator;
-import org.apache.lucene.util.packed.PackedInts;
-
-public class Lucene41BinaryDocValuesConsumer extends BinaryDocValuesConsumer {
-  
-  private final IndexOutput dataOut;
-  private final IndexOutput indexOut;
-  // nocommit: remove buffering!
-  private final AppendingLongBuffer buffer;
-  private long offset = 0;
-  private long prevOffset = 0;
-  static final int VERSION_START = -1;
-  static final String CODEC_NAME = "Lucene41Binary";
-  static final int VALUE_SIZE_VAR = -1;
-
-  public Lucene41BinaryDocValuesConsumer(IndexOutput dataOut, IndexOutput indexOut, boolean fixedLength, int maxLength) throws IOException {
-    this.dataOut = dataOut;
-    this.indexOut = indexOut;
-    CodecUtil.writeHeader(dataOut, CODEC_NAME, VERSION_START);
-    dataOut.writeInt(fixedLength ? maxLength: VALUE_SIZE_VAR);
-    dataOut.writeInt(maxLength);
-    CodecUtil.writeHeader(indexOut, CODEC_NAME, VERSION_START);
-    buffer = fixedLength ? null : new AppendingLongBuffer();
-    
-  }
-  
-  @Override
-  public void finish() throws IOException {
-    try {
-      if (buffer != null) {
-        Iterator iterator = buffer.iterator();
-        PackedInts.Writer writer = PackedInts.getWriter(indexOut,
-            buffer.size() + 1, PackedInts.bitsRequired(offset),
-            PackedInts.FASTEST);
-        long previous = 0;
-        while (iterator.hasNext()) {
-          long next = iterator.next() + previous;
-          previous = next;
-          writer.add(next);
-        }
-        writer.add(offset);
-        writer.finish();
-      }
-    } finally {
-      IOUtils.close(indexOut, dataOut);
-    }
-  }
-
-  @Override
-  public void add(BytesRef value) throws IOException {
-    dataOut.writeBytes(value.bytes, value.offset, value.length);
-    if (buffer != null) {
-      buffer.add(offset-prevOffset);
-      prevOffset = offset;
-    }
-    offset += value.length;
-  }
-  
-}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesConsumer.java
index e3a7f2b..bbc7124 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesConsumer.java
@@ -18,7 +18,6 @@ package org.apache.lucene.codecs.lucene41.values;
  */
 import java.io.IOException;
 
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
 import org.apache.lucene.codecs.SimpleDVConsumer;
 import org.apache.lucene.codecs.SortedDocValuesConsumer;
 import org.apache.lucene.index.FieldInfo;
@@ -29,6 +28,7 @@ import org.apache.lucene.store.CompoundFileDirectory;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 
 public class Lucene41DocValuesConsumer extends SimpleDVConsumer {
@@ -86,25 +86,8 @@ public class Lucene41DocValuesConsumer extends SimpleDVConsumer {
   }
   
   @Override
-  public BinaryDocValuesConsumer addBinaryField(FieldInfo field,
-      boolean fixedLength, int maxLength) throws IOException {
-    String nameData = getDocValuesFileName(info, field, DATA_EXTENSION);
-    String idxOut = getDocValuesFileName(info, field, INDEX_EXTENSION);
-    boolean success = false;
-    IndexOutput dataOut = null;
-    IndexOutput indexOut = null;
-    try {
-      dataOut = getDirectory().createOutput(nameData, context);
-      indexOut = getDirectory().createOutput(idxOut, context);
-      Lucene41BinaryDocValuesConsumer consumer = new Lucene41BinaryDocValuesConsumer(
-          dataOut, indexOut, fixedLength, maxLength);
-      success = true;
-      return consumer;
-    } finally {
-      if (!success) {
-        IOUtils.close(dataOut, indexOut);
-      }
-    }
+  public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) {
+    // ncommit
   }
   
   // nocommit: bogus to put segmentName in here. think about copySegmentAsIs!!!!!!
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesProducer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesProducer.java
index 3282b92..22ecbfd 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesProducer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41DocValuesProducer.java
@@ -72,11 +72,8 @@ public class Lucene41DocValuesProducer extends SimpleDVProducer {
   
   @Override
   public BinaryDocValues getBinary(FieldInfo field) throws IOException {
-    if (DocValues.isBytes(field.getDocValuesType()) || DocValues.isSortedBytes(field.getDocValuesType())) {
-      return new Lucene41BinaryDocValues.Factory(this.cfs, this.info, field, context).getDirect();
-    } else {
-      return null;
-    }
+    // nocommit
+    return null;
   }
   
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41SortedDocValues.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41SortedDocValues.java
index 3da8a26..72a4b0e 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41SortedDocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene41/values/Lucene41SortedDocValues.java
@@ -146,7 +146,8 @@ public class Lucene41SortedDocValues extends SortedDocValues {
         this.valueCount = datIn.readInt();
         this.baseOffset = datIn.getFilePointer();
         
-        if (size == Lucene41BinaryDocValuesConsumer.VALUE_SIZE_VAR) {
+        //if (size == Lucene41BinaryDocValuesConsumer.VALUE_SIZE_VAR) {
+        if (size == -1) {
           offsetIn = dir.openInput(Lucene41DocValuesConsumer
               .getDocValuesFileName(segmentInfo, field,
                   Lucene41DocValuesConsumer.OFFSET_EXTENSION), context);
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java b/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java
index fe7c138..e63331a 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java
@@ -25,7 +25,6 @@ import java.util.Map;
 import java.util.ServiceLoader; // javadocs
 import java.util.TreeMap;
 
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.SimpleDVConsumer;
 import org.apache.lucene.codecs.SimpleDVProducer;
@@ -37,6 +36,7 @@ import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 
 /**
@@ -106,8 +106,8 @@ public abstract class PerFieldDocValuesFormat extends SimpleDocValuesFormat {
     }
 
     @Override
-    public BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, int maxLength) throws IOException {
-      return getInstance(field).addBinaryField(field, fixedLength, maxLength);
+    public void addBinaryField(FieldInfo field, Iterable<BytesRef> values) throws IOException {
+      getInstance(field).addBinaryField(field, values);
     }
 
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java b/lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java
index 4f5d6b0..c8edf0c 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java
@@ -27,9 +27,6 @@ public abstract class BinaryDocValues {
   
   public abstract int size();
   
-  public abstract boolean isFixedLength();
-  public abstract int maxLength();
-  
   public static class EMPTY extends BinaryDocValues {
     private final int size;
     
@@ -46,15 +43,5 @@ public abstract class BinaryDocValues {
     public int size() {
       return size;
     }
-
-    @Override
-    public boolean isFixedLength() {
-      return true;
-    }
-
-    @Override
-    public int maxLength() {
-      return 0;
-    }
   };
 }
diff --git a/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java b/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
index f737ca6..1e0fad8 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
@@ -18,8 +18,8 @@ package org.apache.lucene.index;
  */
 
 import java.io.IOException;
+import java.util.Iterator;
 
-import org.apache.lucene.codecs.BinaryDocValuesConsumer;
 import org.apache.lucene.codecs.SimpleDVConsumer;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefArray;
@@ -37,16 +37,9 @@ class BytesDVWriter extends DocValuesWriter {
   private int addedValues = 0;
   private final BytesRef emptyBytesRef = new BytesRef();
 
-  // -2 means not set yet; -1 means length isn't fixed;
-  // -otherwise it's the fixed length seen so far:
-  int fixedLength = -2;
-  int maxLength;
-  int totalSize;
-
   public BytesDVWriter(FieldInfo fieldInfo, Counter counter) {
     this.fieldInfo = fieldInfo;
     this.bytesRefArray = new BytesRefArray(counter);
-    this.totalSize = 0;
   }
 
   public void addValue(int docID, BytesRef value) {
@@ -57,54 +50,60 @@ class BytesDVWriter extends DocValuesWriter {
       // nocommit improve message
       throw new IllegalArgumentException("null binaryValue not allowed (field=" + fieldInfo.name + ")");
     }
-    mergeLength(value.length);
     
     // Fill in any holes:
     while(addedValues < docID) {
       addedValues++;
       bytesRefArray.append(emptyBytesRef);
-      mergeLength(0);
     }
     addedValues++;
     bytesRefArray.append(value);
   }
 
-  private void mergeLength(int length) {
-    if (fixedLength == -2) {
-      fixedLength = length;
-    } else if (fixedLength != length) {
-      fixedLength = -1;
-    }
-    maxLength = Math.max(maxLength, length);
-    totalSize += length;
-  }
-
   @Override
   public void finish(int maxDoc) {
-    if (addedValues < maxDoc) {
-      mergeLength(0);
-    }
   }
 
   @Override
   public void flush(SegmentWriteState state, SimpleDVConsumer dvConsumer) throws IOException {
-    BinaryDocValuesConsumer consumer = dvConsumer.addBinaryField(fieldInfo,
-                                                                 fixedLength >= 0,
-                                                                 maxLength);
-    final int bufferedDocCount = addedValues;
-    BytesRef value = new BytesRef();
-    for(int docID=0;docID<bufferedDocCount;docID++) {
-      bytesRefArray.get(value, docID);
-      consumer.add(value);
-    }
     final int maxDoc = state.segmentInfo.getDocCount();
-    value.length = 0;
-    for(int docID=bufferedDocCount;docID<maxDoc;docID++) {
-      consumer.add(value);
-    }
-    consumer.finish();
+
+    dvConsumer.addBinaryField(fieldInfo,
+                              new Iterable<BytesRef>() {
+
+                                @Override
+                                public Iterator<BytesRef> iterator() {
+                                   return new Iterator<BytesRef>() {
+                                     BytesRef value = new BytesRef();
+                                     int upto;
+
+                                     @Override
+                                     public boolean hasNext() {
+                                       return upto < maxDoc;
+                                     }
+
+                                     @Override
+                                     public void remove() {
+                                       throw new UnsupportedOperationException();
+                                     }
+
+                                     @Override
+                                     public BytesRef next() {
+                                       // nocommit make
+                                       // mutable Number:
+                                       if (upto < bytesRefArray.size()) {
+                                         bytesRefArray.get(value, upto);
+                                       } else {
+                                         value.length = 0;
+                                       }
+                                       upto++;
+                                       return value;
+                                     }
+                                   };
+                                 }
+                               });
+
     reset();
-    //System.out.println("FLUSH");
   }
 
   public void abort() {
@@ -113,7 +112,5 @@ class BytesDVWriter extends DocValuesWriter {
 
   private void reset() {
     bytesRefArray.clear();
-    fixedLength = -2;
-    maxLength = 0;
   }
 }
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
index c6205a6..7afd99e 100644
--- a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
@@ -1378,25 +1378,10 @@ public class CheckIndex {
     if (dv == null) {
       return;
     }
-    final boolean fixed = dv.isFixedLength();
-    final int maxLength = dv.maxLength();
-    boolean fixed2 = true;
-    int maxLength2 = -1;
+    // nocommit what else to check ...
     BytesRef scratch = new BytesRef();
     for (int i = 0; i < reader.maxDoc(); i++) {
       dv.get(i, scratch);
-      if (maxLength2 == -1) {
-        maxLength2 = scratch.length;
-      } else {
-        fixed2 &= scratch.length == maxLength2;
-        maxLength2 = Math.max(maxLength2, scratch.length);
-      }
-    }
-    if (fixed != fixed2) {
-      throw new RuntimeException("dv for field: " + fieldName + " reports fixed=" + fixed + " but this is not the case!");
-    }
-    if (maxLength != maxLength2) {
-      throw new RuntimeException("dv for field: " + fieldName + " reports maxLength=" + maxLength + " but this is not the case: " + maxLength2);
     }
   }
   
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java b/lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java
index 55daae6..060d15d 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java
@@ -30,6 +30,10 @@ public abstract class SortedDocValues extends BinaryDocValues {
 
   public abstract int getValueCount();
 
+  public abstract boolean isFixedLength();
+
+  public abstract int maxLength();
+
   @Override
   public void get(int docID, BytesRef result) {
     int ord = getOrd(docID);
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java b/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
index 21d2a36..dce92ef 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
@@ -1290,16 +1290,6 @@ class FieldCacheImpl implements FieldCache {
         bytes.fill(ret, pointer);
       }
     }
-
-    @Override
-    public boolean isFixedLength() {
-      return isFixedLength;
-    }
-
-    @Override
-    public int maxLength() {
-      return maxLength;
-    }
   }
 
   // TODO: this if DocTermsIndex was already created, we
diff --git a/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java b/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
index b25c51b..3acc401 100644
--- a/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
+++ b/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
@@ -480,7 +480,6 @@ public class TestDemoDocValue extends LuceneTestCase {
     IndexReader ireader = DirectoryReader.open(directory); // read-only=true
     assert ireader.leaves().size() == 1;
     BinaryDocValues dv = ireader.leaves().get(0).reader().getBinaryDocValues("dv");
-    assertFalse(dv.isFixedLength());
     BytesRef scratch = new BytesRef();
     for(int i=0;i<2;i++) {
       StoredDocument doc2 = ireader.leaves().get(0).reader().document(i);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs.java b/lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs.java
index af84853..f6c24af 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDuelingCodecs.java
@@ -636,8 +636,6 @@ public class TestDuelingCodecs extends LuceneTestCase {
         BinaryDocValues rightValues = MultiSimpleDocValues.simpleBinaryValues(rightReader, field);
         if (leftValues != null && rightValues != null) {
           assertEquals(leftValues.size(), rightValues.size());
-          assertEquals(leftValues.maxLength(), rightValues.maxLength());
-          assertEquals(leftValues.isFixedLength(), rightValues.isFixedLength());
           BytesRef scratchLeft = new BytesRef();
           BytesRef scratchRight = new BytesRef();
           for(int docID=0;docID<leftValues.size();docID++) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java b/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
index 41c4d2a..3e81fc2 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFieldCache.java
@@ -428,46 +428,4 @@ public class TestFieldCache extends LuceneTestCase {
     }
     assertFalse(failed.get());
   }
-
-  public void testMaxFixedLength() throws Exception {
-    Directory d = newDirectory();
-    RandomIndexWriter w = new RandomIndexWriter(random(), d, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
-    int fixedLength = random().nextBoolean() ? -1 : _TestUtil.nextInt(random(), 1, 10);
-    int numTerms = atLeast(10);
-    int actualFixedLength = -2;
-    int actualMaxLength = -1;
-    for(int termIDX=0;termIDX<numTerms;termIDX++) {
-      Document doc = new Document();
-      String termString;
-      if (fixedLength == -1) {
-        termString = _TestUtil.randomRealisticUnicodeString(random());
-      } else {
-        termString = _TestUtil.randomRealisticUnicodeString(random(), fixedLength, fixedLength);
-      }
-      BytesRef term = new BytesRef(termString);
-      actualMaxLength = Math.max(actualMaxLength, term.length);
-      if (actualFixedLength == -2) {
-        actualFixedLength = term.length;
-      } else if (actualFixedLength != term.length) {
-        actualFixedLength = -1;
-      }
-      doc.add(newField("term", termString, StringField.TYPE_NOT_STORED));
-      w.addDocument(doc);
-    }
-    w.forceMerge(1);
-    IndexReader r = w.getReader();
-    w.close();
-    AtomicReader subR = r.leaves().get(0).reader();
-    BinaryDocValues values = FieldCache.DEFAULT.getTerms(subR, "term");
-    assertEquals(actualFixedLength >= 0, values.isFixedLength());
-    assertEquals(actualMaxLength, values.maxLength());
-
-    SortedDocValues sortedValues = FieldCache.DEFAULT.getTermsIndex(subR, "term");
-    assertEquals(actualFixedLength >= 0, sortedValues.isFixedLength());
-    assertEquals(actualMaxLength, sortedValues.maxLength());
-
-    // No field cache insanity because close purges FC entries:
-    r.close();
-    d.close();
-  }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/MultiSimpleDocValues.java b/lucene/test-framework/src/java/org/apache/lucene/index/MultiSimpleDocValues.java
index 9fb6ba9..b057fd8 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/MultiSimpleDocValues.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/MultiSimpleDocValues.java
@@ -109,7 +109,6 @@ public class MultiSimpleDocValues {
   public static BinaryDocValues simpleBinaryValues(final IndexReader r, final String field) throws IOException {
     final List<AtomicReaderContext> leaves = r.leaves();
     boolean anyReal = false;
-    int maxLength = -1;
 
     for(AtomicReaderContext ctx : leaves) {
       BinaryDocValues values = ctx.reader().getBinaryDocValues(field);
@@ -119,14 +118,11 @@ public class MultiSimpleDocValues {
       } else {
         anyReal = true;
       }
-      
-      maxLength = Math.max(maxLength, values.maxLength());
     }
 
     if (!anyReal) {
       return null;
     } else {
-      final int finalMaxLength = maxLength;
 
       return new BinaryDocValues() {
         @Override
@@ -150,17 +146,6 @@ public class MultiSimpleDocValues {
         public int size() {
           return r.maxDoc();
         }
-
-        @Override
-        public boolean isFixedLength() {
-          // Harmless lie?
-          return false;
-        }
-
-        @Override
-        public int maxLength() {
-          return finalMaxLength;
-        }
       };
     }
   }

