GitDiffStart: bf82fb19707abe2e27615914d9bd5e4ae981e937 | Thu Feb 2 22:06:28 2006 +0000
diff --git a/src/java/org/apache/solr/schema/BCDIntField.java b/src/java/org/apache/solr/schema/BCDIntField.java
index f3a4102..b7a8bc6 100644
--- a/src/java/org/apache/solr/schema/BCDIntField.java
+++ b/src/java/org/apache/solr/schema/BCDIntField.java
@@ -17,7 +17,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
+import org.apache.solr.search.function.ValueSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.util.BCDUtils;
 import org.apache.solr.request.XMLWriter;
diff --git a/src/java/org/apache/solr/schema/BoolField.java b/src/java/org/apache/solr/schema/BoolField.java
index c4665eb..08bb379 100644
--- a/src/java/org/apache/solr/schema/BoolField.java
+++ b/src/java/org/apache/solr/schema/BoolField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
diff --git a/src/java/org/apache/solr/schema/DateField.java b/src/java/org/apache/solr/schema/DateField.java
index f7e3855..f9a9f2b 100644
--- a/src/java/org/apache/solr/schema/DateField.java
+++ b/src/java/org/apache/solr/schema/DateField.java
@@ -20,8 +20,8 @@ import org.apache.solr.core.SolrException;
 import org.apache.solr.request.XMLWriter;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/DoubleField.java b/src/java/org/apache/solr/schema/DoubleField.java
index b54cc28..f6af438 100644
--- a/src/java/org/apache/solr/schema/DoubleField.java
+++ b/src/java/org/apache/solr/schema/DoubleField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FloatFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/src/java/org/apache/solr/schema/FieldType.java b/src/java/org/apache/solr/schema/FieldType.java
index 3fcc143..ce8320e 100644
--- a/src/java/org/apache/solr/schema/FieldType.java
+++ b/src/java/org/apache/solr/schema/FieldType.java
@@ -22,8 +22,8 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 import org.apache.solr.search.Sorting;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/src/java/org/apache/solr/schema/FloatField.java b/src/java/org/apache/solr/schema/FloatField.java
index f8137d7..75de65a 100644
--- a/src/java/org/apache/solr/schema/FloatField.java
+++ b/src/java/org/apache/solr/schema/FloatField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FloatFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/src/java/org/apache/solr/schema/IntField.java b/src/java/org/apache/solr/schema/IntField.java
index 3a04f9c..1b1d276 100644
--- a/src/java/org/apache/solr/schema/IntField.java
+++ b/src/java/org/apache/solr/schema/IntField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.IntFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/src/java/org/apache/solr/schema/LongField.java b/src/java/org/apache/solr/schema/LongField.java
index 897431e..1b4a331 100644
--- a/src/java/org/apache/solr/schema/LongField.java
+++ b/src/java/org/apache/solr/schema/LongField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.IntFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/src/java/org/apache/solr/schema/SortableDoubleField.java b/src/java/org/apache/solr/schema/SortableDoubleField.java
index 566d0ee..d7f61fa 100644
--- a/src/java/org/apache/solr/schema/SortableDoubleField.java
+++ b/src/java/org/apache/solr/schema/SortableDoubleField.java
@@ -18,9 +18,9 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/src/java/org/apache/solr/schema/SortableFloatField.java b/src/java/org/apache/solr/schema/SortableFloatField.java
index 6ce103c..068dbdb 100644
--- a/src/java/org/apache/solr/schema/SortableFloatField.java
+++ b/src/java/org/apache/solr/schema/SortableFloatField.java
@@ -18,9 +18,9 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/src/java/org/apache/solr/schema/SortableIntField.java b/src/java/org/apache/solr/schema/SortableIntField.java
index dd8ff86..a9fbb4e 100644
--- a/src/java/org/apache/solr/schema/SortableIntField.java
+++ b/src/java/org/apache/solr/schema/SortableIntField.java
@@ -18,9 +18,9 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/src/java/org/apache/solr/schema/SortableLongField.java b/src/java/org/apache/solr/schema/SortableLongField.java
index 9bd8db1..4fce602 100644
--- a/src/java/org/apache/solr/schema/SortableLongField.java
+++ b/src/java/org/apache/solr/schema/SortableLongField.java
@@ -18,9 +18,9 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java b/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java
new file mode 100644
index 0000000..edff093
--- /dev/null
+++ b/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java
@@ -0,0 +1,81 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ConstantScoreQuery;
+
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id: ConstantScorePrefixQuery.java,v 1.2 2005/09/15 14:32:41 yonik Exp $
+ */
+public class ConstantScorePrefixQuery extends Query {
+  private final Term prefix;
+
+  public ConstantScorePrefixQuery(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  /** Returns the prefix  for this query */
+  public Term getPrefix() { return prefix; }
+
+  public Query rewrite(IndexReader reader) throws IOException {
+    // TODO: if number of terms are low enough, rewrite to a BooleanQuery
+    // for potentially faster execution.
+    // TODO: cache the bitset somewhere instead of regenerating it
+    Query q = new ConstantScoreQuery(new PrefixFilter(prefix));
+    q.setBoost(getBoost());
+    return q;
+  }
+
+  /** Prints a user-readable version of this query. */
+  public String toString(String field)
+  {
+    StringBuffer buffer = new StringBuffer();
+    if (!prefix.field().equals(field)) {
+      buffer.append(prefix.field());
+      buffer.append(":");
+    }
+    buffer.append(prefix.text());
+    buffer.append('*');
+    if (getBoost() != 1.0f) {
+      buffer.append("^");
+      buffer.append(Float.toString(getBoost()));
+    }
+    return buffer.toString();
+  }
+
+    /** Returns true if <code>o</code> is equal to this. */
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof ConstantScorePrefixQuery)) return false;
+      ConstantScorePrefixQuery other = (ConstantScorePrefixQuery) o;
+      return this.prefix.equals(other.prefix) && this.getBoost()==other.getBoost();
+    }
+
+    /** Returns a hash code value for this object.*/
+    public int hashCode() {
+      int h = prefix.hashCode() ^ Float.floatToIntBits(getBoost());
+      h ^= (h << 14) | (h >>> 19);  // reversible (1 to 1) transformation unique to ConstantScorePrefixQuery
+      return h;
+    }
+
+}
diff --git a/src/java/org/apache/solr/search/PrefixFilter.java b/src/java/org/apache/solr/search/PrefixFilter.java
new file mode 100644
index 0000000..bc94f05
--- /dev/null
+++ b/src/java/org/apache/solr/search/PrefixFilter.java
@@ -0,0 +1,79 @@
+package org.apache.solr.search;
+
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.TermEnum;
+import org.apache.lucene.index.TermDocs;
+
+import java.util.BitSet;
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id: PrefixFilter.java,v 1.1 2005/06/10 05:47:32 yonik Exp $
+ */
+public class PrefixFilter extends Filter {
+  protected final Term prefix;
+
+  PrefixFilter(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  Term getPrefix() { return prefix; }
+
+  public BitSet bits(IndexReader reader) throws IOException {
+    final BitSet bitSet = new BitSet(reader.maxDoc());
+    new PrefixGenerator(prefix) {
+      public void handleDoc(int doc) {
+        bitSet.set(doc);
+      }
+    }.generate(reader);
+    return bitSet;
+  }
+}
+
+// keep this protected until I decide if it's a good way
+// to separate id generation from collection (or should
+// I just reuse hitcollector???)
+interface IdGenerator {
+  public void generate(IndexReader reader) throws IOException;
+  public void handleDoc(int doc);
+}
+
+
+abstract class PrefixGenerator implements IdGenerator {
+  protected final Term prefix;
+
+  PrefixGenerator(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  public void generate(IndexReader reader) throws IOException {
+    TermEnum enumerator = reader.terms(prefix);
+    TermDocs termDocs = reader.termDocs();
+
+    try {
+
+      String prefixText = prefix.text();
+      String prefixField = prefix.field();
+      do {
+        Term term = enumerator.term();
+        if (term != null &&
+            term.text().startsWith(prefixText) &&
+            term.field() == prefixField)
+        {
+          termDocs.seek(term);
+          while (termDocs.next()) {
+            handleDoc(termDocs.doc());
+          }
+        } else {
+          break;
+        }
+      } while (enumerator.next());
+    } finally {
+      termDocs.close();
+      enumerator.close();
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/search/QueryParsing.java b/src/java/org/apache/solr/search/QueryParsing.java
index 24f0c41..e41fac8 100644
--- a/src/java/org/apache/solr/search/QueryParsing.java
+++ b/src/java/org/apache/solr/search/QueryParsing.java
@@ -17,7 +17,7 @@
 package org.apache.solr.search;
 
 import org.apache.lucene.search.*;
-import org.apache.lucene.search.function.*;
+import org.apache.solr.search.function.*;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.Term;
diff --git a/src/java/org/apache/solr/search/function/DocValues.java b/src/java/org/apache/solr/search/function/DocValues.java
new file mode 100644
index 0000000..739b813
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/DocValues.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.search.Explanation;
+
+/**
+ * Represents field values as different types.
+ * Normally created via a {@link ValueSource} for a particular field and reader.
+ * <br>
+ * Often used by {@link FunctionFactory} implementations.
+ *
+ * @author yonik
+ * @version $Id: DocValues.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
+ */
+
+// DocValues is distinct from ValueSource because
+// there needs to be an object created at query evaluation time that
+// is not referenced by the query itself because:
+// - Query objects should be MT safe
+// - For caching, Query objects are often used as keys... you don't
+//   want the Query carrying around big objects
+public abstract class DocValues {
+  public float floatVal(int doc) { throw new UnsupportedOperationException(); }
+  public int intVal(int doc) { throw new UnsupportedOperationException(); }
+  public long longVal(int doc) { throw new UnsupportedOperationException(); }
+  public double doubleVal(int doc) { throw new UnsupportedOperationException(); }
+  public String strVal(int doc) { throw new UnsupportedOperationException(); }
+  public abstract String toString(int doc);
+  public Explanation explain(int doc) {
+    return new Explanation(floatVal(doc), toString(doc));
+  }
+}
diff --git a/src/java/org/apache/solr/search/function/FieldCacheSource.java b/src/java/org/apache/solr/search/function/FieldCacheSource.java
new file mode 100644
index 0000000..371d6ab
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/FieldCacheSource.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.search.FieldCache;
+
+/**
+ * A base class for ValueSource implementations that retrieve values for
+ * a single field from the {@link org.apache.lucene.search.FieldCache}.
+ *
+ * @author yonik
+ * @version $Id: FieldCacheSource.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
+ */
+public abstract class FieldCacheSource extends ValueSource {
+  protected String field;
+  protected FieldCache cache = FieldCache.DEFAULT;
+
+  public FieldCacheSource(String field) {
+    this.field=field;
+  }
+
+  public void setFieldCache(FieldCache cache) {
+    this.cache = cache;
+  }
+
+  public FieldCache getFieldCache() {
+    return cache;
+  }
+
+  public String description() {
+    return field;
+  }
+
+  public boolean equals(Object o) {
+    if (!(o instanceof FieldCacheSource)) return false;
+    FieldCacheSource other = (FieldCacheSource)o;
+    return this.field.equals(other.field)
+           && this.cache == other.cache;
+  }
+
+  public int hashCode() {
+    return cache.hashCode() + field.hashCode();
+  };
+
+}
diff --git a/src/java/org/apache/solr/search/function/FloatFieldSource.java b/src/java/org/apache/solr/search/function/FloatFieldSource.java
new file mode 100644
index 0000000..9043e19
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/FloatFieldSource.java
@@ -0,0 +1,95 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getFloats()</code>
+ * and makes those values available as other numeric types, casting as needed.
+ *
+ * @author yonik
+ * @version $Id: FloatFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
+ */
+
+public class FloatFieldSource extends FieldCacheSource {
+  protected FieldCache.FloatParser parser;
+
+  public FloatFieldSource(String field) {
+    this(field, null);
+  }
+
+  public FloatFieldSource(String field, FieldCache.FloatParser parser) {
+    super(field);
+    this.parser = parser;
+  }
+
+  public String description() {
+    return "float(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final float[] arr = (parser==null) ?
+            cache.getFloats(reader, field) :
+            cache.getFloats(reader, field, parser);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        return Float.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + floatVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  FloatFieldSource.class) return false;
+    FloatFieldSource other = (FloatFieldSource)o;
+    return super.equals(other)
+           && this.parser==null ? other.parser==null :
+              this.parser.getClass() == other.parser.getClass();
+  }
+
+  public int hashCode() {
+    int h = parser==null ? Float.class.hashCode() : parser.getClass().hashCode();
+    h += super.hashCode();
+    return h;
+  };
+
+}
\ No newline at end of file
diff --git a/src/java/org/apache/solr/search/function/FunctionQuery.java b/src/java/org/apache/solr/search/function/FunctionQuery.java
new file mode 100644
index 0000000..d319986
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/FunctionQuery.java
@@ -0,0 +1,173 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.*;
+import java.io.IOException;
+
+
+/**
+ * Returns a score for each document based on a ValueSource,
+ * often some function of the value of a field.
+ *
+ * @author yonik
+ * @version $Id: FunctionQuery.java,v 1.4 2005/11/23 04:22:20 yonik Exp $
+ */
+public class FunctionQuery extends Query {
+  ValueSource func;
+
+  /**
+   *
+   * @param func defines the function to be used for scoring
+   */
+  public FunctionQuery(ValueSource func) {
+    this.func=func;
+  }
+
+  public Query rewrite(IndexReader reader) throws IOException {
+    return this;
+  }
+
+  protected class FunctionWeight implements Weight {
+    Searcher searcher;
+    float queryNorm;
+    float queryWeight;
+
+    public FunctionWeight(Searcher searcher) {
+      this.searcher = searcher;
+    }
+
+    public Query getQuery() {
+      return FunctionQuery.this;
+    }
+
+    public float getValue() {
+      return queryWeight;
+    }
+
+    public float sumOfSquaredWeights() throws IOException {
+      queryWeight = getBoost();
+      return queryWeight * queryWeight;
+    }
+
+    public void normalize(float norm) {
+      this.queryNorm = norm;
+      queryWeight *= this.queryNorm;
+    }
+
+    public Scorer scorer(IndexReader reader) throws IOException {
+      return new AllScorer(getSimilarity(searcher), reader, this);
+    }
+
+    public Explanation explain(IndexReader reader, int doc) throws IOException {
+      return scorer(reader).explain(doc);
+    }
+  }
+
+  protected class AllScorer extends Scorer {
+    final IndexReader reader;
+    final FunctionWeight weight;
+    final int maxDoc;
+    final float qWeight;
+    int doc=-1;
+    final DocValues vals;
+
+    public AllScorer(Similarity similarity, IndexReader reader, FunctionWeight w) throws IOException {
+      super(similarity);
+      this.weight = w;
+      this.qWeight = w.getValue();
+      this.reader = reader;
+      this.maxDoc = reader.maxDoc();
+      vals = func.getValues(reader);
+    }
+
+    // instead of matching all docs, we could also embed a query.
+    // the score could either ignore the subscore, or boost it.
+    // Containment:  floatline(foo:myTerm, "myFloatField", 1.0, 0.0f)
+    // Boost:        foo:myTerm^floatline("myFloatField",1.0,0.0f)
+    public boolean next() throws IOException {
+      for(;;) {
+        ++doc;
+        if (doc>=maxDoc) {
+          return false;
+        }
+        if (reader.isDeleted(doc)) continue;
+        // todo: maybe allow score() to throw a specific exception
+        // and continue on to the next document if it is thrown...
+        // that may be useful, but exceptions aren't really good
+        // for flow control.
+        return true;
+      }
+    }
+
+    public int doc() {
+      return doc;
+    }
+
+    public float score() throws IOException {
+      return qWeight * vals.floatVal(doc);
+    }
+
+    public boolean skipTo(int target) throws IOException {
+      doc=target-1;
+      return next();
+    }
+
+    public Explanation explain(int doc) throws IOException {
+      float sc = qWeight * vals.floatVal(doc);
+
+      Explanation result = new Explanation();
+      result.setDescription("FunctionQuery(" + func
+        + "), product of:");
+      result.setValue(sc);
+      result.addDetail(vals.explain(doc));
+      result.addDetail(new Explanation(getBoost(), "boost"));
+      result.addDetail(new Explanation(weight.queryNorm,"queryNorm"));
+      return result;
+    }
+  }
+
+
+  protected Weight createWeight(Searcher searcher) {
+    return new FunctionQuery.FunctionWeight(searcher);
+  }
+
+
+  /** Prints a user-readable version of this query. */
+  public String toString(String field)
+  {
+    float boost = getBoost();
+    return (boost!=1.0?"(":"") + func.toString()
+            + (getBoost()==0 ? "" : ")^"+getBoost());
+  }
+
+
+  /** Returns true if <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (FunctionQuery.class != o.getClass()) return false;
+    FunctionQuery other = (FunctionQuery)o;
+    return this.getBoost() == other.getBoost()
+            && this.func.equals(other.func);
+  }
+
+  /** Returns a hash code value for this object. */
+  public int hashCode() {
+    return func.hashCode() ^ Float.floatToIntBits(getBoost());
+  }
+
+}
diff --git a/src/java/org/apache/solr/search/function/IntFieldSource.java b/src/java/org/apache/solr/search/function/IntFieldSource.java
new file mode 100644
index 0000000..476717e
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/IntFieldSource.java
@@ -0,0 +1,95 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getInts()</code>
+ * and makes those values available as other numeric types, casting as needed. *
+ * @author yonik
+ * @version $Id: IntFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
+ */
+
+public class IntFieldSource extends FieldCacheSource {
+  FieldCache.IntParser parser;
+
+  public IntFieldSource(String field) {
+    this(field, null);
+  }
+
+  public IntFieldSource(String field, FieldCache.IntParser parser) {
+    super(field);
+    this.parser = parser;
+  }
+
+  public String description() {
+    return "int(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final int[] arr = (parser==null) ?
+            cache.getInts(reader, field) :
+            cache.getInts(reader, field, parser);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        return Float.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + intVal(doc);
+      }
+
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  IntFieldSource.class) return false;
+    IntFieldSource other = (IntFieldSource)o;
+    return super.equals(other)
+           && this.parser==null ? other.parser==null :
+              this.parser.getClass() == other.parser.getClass();
+  }
+
+  public int hashCode() {
+    int h = parser==null ? Integer.class.hashCode() : parser.getClass().hashCode();
+    h += super.hashCode();
+    return h;
+  };
+
+}
diff --git a/src/java/org/apache/solr/search/function/LinearFloatFunction.java b/src/java/org/apache/solr/search/function/LinearFloatFunction.java
new file mode 100644
index 0000000..1b022a1
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/LinearFloatFunction.java
@@ -0,0 +1,86 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+/**
+ * <code>LinearFloatFunction</code> implements a linear function over
+ * another {@link ValueSource}.
+ * <br>
+ * Normally Used as an argument to a {@link FunctionQuery}
+ *
+ * @author yonik
+ * @version $Id: LinearFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+public class LinearFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float slope;
+  protected final float intercept;
+
+  public LinearFloatFunction(ValueSource source, float slope, float intercept) {
+    this.source = source;
+    this.slope = slope;
+    this.intercept = intercept;
+  }
+  
+  public String description() {
+    return slope + "*float(" + source.description() + ")+" + intercept;
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final DocValues vals =  source.getValues(reader);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return vals.floatVal(doc) * slope + intercept;
+      }
+      public int intVal(int doc) {
+        return (int)floatVal(doc);
+      }
+      public long longVal(int doc) {
+        return (long)floatVal(doc);
+      }
+      public double doubleVal(int doc) {
+        return (double)floatVal(doc);
+      }
+      public String strVal(int doc) {
+        return Float.toString(floatVal(doc));
+      }
+      public String toString(int doc) {
+        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
+      }
+    };
+  }
+
+  public int hashCode() {
+    int h = Float.floatToIntBits(slope);
+    h = (h >>> 2) | (h << 30);
+    h += Float.floatToIntBits(intercept);
+    h ^= (h << 14) | (h >>> 19);
+    return h + source.hashCode();
+  }
+
+  public boolean equals(Object o) {
+    if (LinearFloatFunction.class != o.getClass()) return false;
+    LinearFloatFunction other = (LinearFloatFunction)o;
+    return  this.slope == other.slope
+         && this.intercept == other.intercept
+         && this.source.equals(other.source);
+  }
+}
diff --git a/src/java/org/apache/solr/search/function/OrdFieldSource.java b/src/java/org/apache/solr/search/function/OrdFieldSource.java
new file mode 100644
index 0000000..3d88420
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/OrdFieldSource.java
@@ -0,0 +1,94 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex().
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example:<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then ord("apple")=1, ord("banana")=2, ord("pear")=3
+ * <p>
+ * WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * @author yonik
+ * @version $Id: OrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+
+public class OrdFieldSource extends ValueSource {
+  protected String field;
+
+  public OrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  public String description() {
+    return "ord(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        // the string value of the ordinal, not the string itself
+        return Integer.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + intVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  OrdFieldSource.class) return false;
+    OrdFieldSource other = (OrdFieldSource)o;
+    return this.field.equals(field);
+  }
+
+  private static final int hcode = OrdFieldSource.class.hashCode();
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java b/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
new file mode 100644
index 0000000..68ceb7c
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+/**
+ * <code>ReciprocalFloatFunction</code> implements a reciprocal function f(x) = a/(mx+b), based on
+ * the float value of a field as exported by {@link org.apache.solr.search.function.ValueSource}.
+ * <br>
+ *
+ * When a and b are equal, and x>=0, this function has a maximum value of 1 that drops as x increases.
+ * Increasing the value of a and b together results in a movement of the entire function to a flatter part of the curve.
+ * <br>These properties make this an idea function for boosting more recent documents.
+ * <br>Example:<code>ReciprocalFloatFunction(new ReverseOrdFieldSource("my_date"),1,1000,1000)</code>
+ *
+ * @see FunctionQuery
+ *
+ *
+ * @author yonik
+ * @version $Id: ReciprocalFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+public class ReciprocalFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float m;
+  protected final float a;
+  protected final float b;
+
+  /**
+   *  f(source) = a/(m*float(source)+b)
+   */
+  public ReciprocalFloatFunction(ValueSource source, float m, float a, float b) {
+    this.source=source;
+    this.m=m;
+    this.a=a;
+    this.b=b;
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final DocValues vals = source.getValues(reader);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return a/(m*vals.floatVal(doc) + b);
+      }
+      public int intVal(int doc) {
+        return (int)floatVal(doc);
+      }
+      public long longVal(int doc) {
+        return (long)floatVal(doc);
+      }
+      public double doubleVal(int doc) {
+        return (double)floatVal(doc);
+      }
+      public String strVal(int doc) {
+        return Float.toString(floatVal(doc));
+      }
+      public String toString(int doc) {
+        return Float.toString(a) + "/("
+                + m + "*float(" + vals.toString(doc) + ')'
+                + '+' + b + ')';
+      }
+    };
+  }
+
+  public String description() {
+    return Float.toString(a) + "/("
+           + m + "*float(" + source.description() + ")"
+           + "+" + b + ')';
+  }
+
+  public int hashCode() {
+    int h = Float.floatToIntBits(a) + Float.floatToIntBits(m);
+    h ^= (h << 13) | (h >>> 20);
+    return h + (Float.floatToIntBits(b)) + source.hashCode();
+  }
+
+  public boolean equals(Object o) {
+    if (ReciprocalFloatFunction.class != o.getClass()) return false;
+    ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;
+    return this.m == other.m
+            && this.a == other.a
+            && this.b == other.b
+            && this.source.equals(other.source);
+  }
+}
diff --git a/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java b/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
new file mode 100644
index 0000000..aa19c3d
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
@@ -0,0 +1,99 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex()
+ * and reverses the order.
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example of reverse ordinal (rord):<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then rord("apple")=3, rord("banana")=2, ord("pear")=1
+ * <p>
+ *  WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * @author yonik
+ * @version $Id: ReverseOrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+
+public class ReverseOrdFieldSource extends ValueSource {
+  public String field;
+
+  public ReverseOrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  public String description() {
+    return "rord("+field+')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final FieldCache.StringIndex sindex = FieldCache.DEFAULT.getStringIndex(reader, field);
+
+    final int arr[] = sindex.order;
+    final int end = sindex.lookup.length;
+
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)(end - arr[doc]);
+      }
+
+      public int intVal(int doc) {
+        return (int)(end - arr[doc]);
+      }
+
+      public long longVal(int doc) {
+        return (long)(end - arr[doc]);
+      }
+
+      public double doubleVal(int doc) {
+        return (double)(end - arr[doc]);
+      }
+
+      public String strVal(int doc) {
+        // the string value of the ordinal, not the string itself
+        return Integer.toString((end - arr[doc]));
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + strVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
+    ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
+    return this.field.equals(field);
+  }
+
+  private static final int hcode = ReverseOrdFieldSource.class.hashCode();
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/src/java/org/apache/solr/search/function/ValueSource.java b/src/java/org/apache/solr/search/function/ValueSource.java
new file mode 100644
index 0000000..65fc3cb
--- /dev/null
+++ b/src/java/org/apache/solr/search/function/ValueSource.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * Instantiates {@link org.apache.solr.search.function.DocValues} for a particular reader.
+ * <br>
+ * Often used when creating a {@link FunctionQuery}.
+ *
+ * @author yonik
+ * @version $Id: ValueSource.java,v 1.2 2005/11/30 19:31:01 yonik Exp $
+ */
+public abstract class ValueSource implements Serializable {
+
+  public abstract DocValues getValues(IndexReader reader) throws IOException;
+
+  public abstract boolean equals(Object o);
+
+  public abstract int hashCode();
+
+  /** description of field, used in explain() */
+  public abstract String description();
+
+  public String toString() {
+    return getClass().getName() + ":" + description();
+  }
+
+}
diff --git a/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java b/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java
deleted file mode 100644
index bc95d35..0000000
--- a/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id: ConstantScorePrefixQuery.java,v 1.2 2005/09/15 14:32:41 yonik Exp $
- */
-public class ConstantScorePrefixQuery extends Query {
-  private final Term prefix;
-
-  public ConstantScorePrefixQuery(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  /** Returns the prefix  for this query */
-  public Term getPrefix() { return prefix; }
-
-  public Query rewrite(IndexReader reader) throws IOException {
-    // TODO: if number of terms are low enough, rewrite to a BooleanQuery
-    // for potentially faster execution.
-    // TODO: cache the bitset somewhere instead of regenerating it
-    Query q = new ConstantScoreQuery(new PrefixFilter(prefix));
-    q.setBoost(getBoost());
-    return q;
-  }
-
-  /** Prints a user-readable version of this query. */
-  public String toString(String field)
-  {
-    StringBuffer buffer = new StringBuffer();
-    if (!prefix.field().equals(field)) {
-      buffer.append(prefix.field());
-      buffer.append(":");
-    }
-    buffer.append(prefix.text());
-    buffer.append('*');
-    if (getBoost() != 1.0f) {
-      buffer.append("^");
-      buffer.append(Float.toString(getBoost()));
-    }
-    return buffer.toString();
-  }
-
-    /** Returns true if <code>o</code> is equal to this. */
-    public boolean equals(Object o) {
-      if (this == o) return true;
-      if (!(o instanceof ConstantScorePrefixQuery)) return false;
-      ConstantScorePrefixQuery other = (ConstantScorePrefixQuery) o;
-      return this.prefix.equals(other.prefix) && this.getBoost()==other.getBoost();
-    }
-
-    /** Returns a hash code value for this object.*/
-    public int hashCode() {
-      int h = prefix.hashCode() ^ Float.floatToIntBits(getBoost());
-      h ^= (h << 14) | (h >>> 19);  // reversible (1 to 1) transformation unique to ConstantScorePrefixQuery
-      return h;
-    }
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java b/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java
deleted file mode 100644
index 363bc61..0000000
--- a/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.index.TermEnum;
-
-import java.util.BitSet;
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id: PrefixFilter.java,v 1.1 2005/06/10 05:47:32 yonik Exp $
- */
-public class PrefixFilter extends Filter {
-  protected final Term prefix;
-
-  PrefixFilter(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  Term getPrefix() { return prefix; }
-
-  public BitSet bits(IndexReader reader) throws IOException {
-    final BitSet bitSet = new BitSet(reader.maxDoc());
-    new PrefixGenerator(prefix) {
-      public void handleDoc(int doc) {
-        bitSet.set(doc);
-      }
-    }.generate(reader);
-    return bitSet;
-  }
-}
-
-
-// keep this protected until I decide if it's a good way
-// to separate id generation from collection (or should
-// I just reuse hitcollector???)
-interface IdGenerator {
-  public void generate(IndexReader reader) throws IOException;
-  public void handleDoc(int doc);
-}
-
-
-abstract class PrefixGenerator implements IdGenerator {
-  protected final Term prefix;
-
-  PrefixGenerator(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  public void generate(IndexReader reader) throws IOException {
-    TermEnum enumerator = reader.terms(prefix);
-    TermDocs termDocs = reader.termDocs();
-
-    try {
-
-      String prefixText = prefix.text();
-      String prefixField = prefix.field();
-      do {
-        Term term = enumerator.term();
-        if (term != null &&
-            term.text().startsWith(prefixText) &&
-            term.field() == prefixField)
-        {
-          termDocs.seek(term);
-          while (termDocs.next()) {
-            handleDoc(termDocs.doc());
-          }
-        } else {
-          break;
-        }
-      } while (enumerator.next());
-    } finally {
-      termDocs.close();
-      enumerator.close();
-    }
-  }
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/DocValues.java b/src/lucene_extras/org/apache/lucene/search/function/DocValues.java
deleted file mode 100644
index 21f62ab..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/DocValues.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.search.Explanation;
-
-/**
- * Represents field values as different types.
- * Normally created via a {@link ValueSource} for a particular field and reader.
- * <br>
- * Often used by {@link FunctionFactory} implementations.
- *
- * @author yonik
- * @version $Id: DocValues.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
- */
-
-// DocValues is distinct from ValueSource because
-// there needs to be an object created at query evaluation time that
-// is not referenced by the query itself because:
-// - Query objects should be MT safe
-// - For caching, Query objects are often used as keys... you don't
-//   want the Query carrying around big objects
-public abstract class DocValues {
-  public float floatVal(int doc) { throw new UnsupportedOperationException(); }
-  public int intVal(int doc) { throw new UnsupportedOperationException(); }
-  public long longVal(int doc) { throw new UnsupportedOperationException(); }
-  public double doubleVal(int doc) { throw new UnsupportedOperationException(); }
-  public String strVal(int doc) { throw new UnsupportedOperationException(); }
-  public abstract String toString(int doc);
-  public Explanation explain(int doc) {
-    return new Explanation(floatVal(doc), toString(doc));
-  }
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/FieldCacheSource.java b/src/lucene_extras/org/apache/lucene/search/function/FieldCacheSource.java
deleted file mode 100644
index fe233b6..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/FieldCacheSource.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.search.FieldCache;
-
-/**
- * A base class for ValueSource implementations that retrieve values for
- * a single field from the {@link org.apache.lucene.search.FieldCache}.
- *
- * @author yonik
- * @version $Id: FieldCacheSource.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
- */
-public abstract class FieldCacheSource extends ValueSource {
-  protected String field;
-  protected FieldCache cache = FieldCache.DEFAULT;
-
-  public FieldCacheSource(String field) {
-    this.field=field;
-  }
-
-  public void setFieldCache(FieldCache cache) {
-    this.cache = cache;
-  }
-
-  public FieldCache getFieldCache() {
-    return cache;
-  }
-
-  public String description() {
-    return field;
-  }
-
-  public boolean equals(Object o) {
-    if (!(o instanceof FieldCacheSource)) return false;
-    FieldCacheSource other = (FieldCacheSource)o;
-    return this.field.equals(other.field)
-           && this.cache == other.cache;
-  }
-
-  public int hashCode() {
-    return cache.hashCode() + field.hashCode();
-  };
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/FloatFieldSource.java b/src/lucene_extras/org/apache/lucene/search/function/FloatFieldSource.java
deleted file mode 100644
index 88e35ab..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/FloatFieldSource.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.function.DocValues;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-
-import java.io.IOException;
-
-/**
- * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getFloats()</code>
- * and makes those values available as other numeric types, casting as needed.
- *
- * @author yonik
- * @version $Id: FloatFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
- */
-
-public class FloatFieldSource extends FieldCacheSource {
-  protected FieldCache.FloatParser parser;
-
-  public FloatFieldSource(String field) {
-    this(field, null);
-  }
-
-  public FloatFieldSource(String field, FieldCache.FloatParser parser) {
-    super(field);
-    this.parser = parser;
-  }
-
-  public String description() {
-    return "float(" + field + ')';
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final float[] arr = (parser==null) ?
-            cache.getFloats(reader, field) :
-            cache.getFloats(reader, field, parser);
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return arr[doc];
-      }
-
-      public int intVal(int doc) {
-        return (int)arr[doc];
-      }
-
-      public long longVal(int doc) {
-        return (long)arr[doc];
-      }
-
-      public double doubleVal(int doc) {
-        return (double)arr[doc];
-      }
-
-      public String strVal(int doc) {
-        return Float.toString(arr[doc]);
-      }
-
-      public String toString(int doc) {
-        return description() + '=' + floatVal(doc);
-      }
-    };
-  }
-
-  public boolean equals(Object o) {
-    if (o.getClass() !=  FloatFieldSource.class) return false;
-    FloatFieldSource other = (FloatFieldSource)o;
-    return super.equals(other)
-           && this.parser==null ? other.parser==null :
-              this.parser.getClass() == other.parser.getClass();
-  }
-
-  public int hashCode() {
-    int h = parser==null ? Float.class.hashCode() : parser.getClass().hashCode();
-    h += super.hashCode();
-    return h;
-  };
-
-}
\ No newline at end of file
diff --git a/src/lucene_extras/org/apache/lucene/search/function/FunctionQuery.java b/src/lucene_extras/org/apache/lucene/search/function/FunctionQuery.java
deleted file mode 100644
index 8bf5bf8..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/FunctionQuery.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.*;
-import java.io.IOException;
-
-
-/**
- * Returns a score for each document based on a ValueSource,
- * often some function of the value of a field.
- *
- * @author yonik
- * @version $Id: FunctionQuery.java,v 1.4 2005/11/23 04:22:20 yonik Exp $
- */
-public class FunctionQuery extends Query {
-  ValueSource func;
-
-  /**
-   *
-   * @param func defines the function to be used for scoring
-   */
-  public FunctionQuery(ValueSource func) {
-    this.func=func;
-  }
-
-  public Query rewrite(IndexReader reader) throws IOException {
-    return this;
-  }
-
-  protected class FunctionWeight implements Weight {
-    Searcher searcher;
-    float queryNorm;
-    float queryWeight;
-
-    public FunctionWeight(Searcher searcher) {
-      this.searcher = searcher;
-    }
-
-    public Query getQuery() {
-      return FunctionQuery.this;
-    }
-
-    public float getValue() {
-      return queryWeight;
-    }
-
-    public float sumOfSquaredWeights() throws IOException {
-      queryWeight = getBoost();
-      return queryWeight * queryWeight;
-    }
-
-    public void normalize(float norm) {
-      this.queryNorm = norm;
-      queryWeight *= this.queryNorm;
-    }
-
-    public Scorer scorer(IndexReader reader) throws IOException {
-      return new AllScorer(getSimilarity(searcher), reader, this);
-    }
-
-    public Explanation explain(IndexReader reader, int doc) throws IOException {
-      return scorer(reader).explain(doc);
-    }
-  }
-
-  protected class AllScorer extends Scorer {
-    final IndexReader reader;
-    final FunctionWeight weight;
-    final int maxDoc;
-    final float qWeight;
-    int doc=-1;
-    final DocValues vals;
-
-    public AllScorer(Similarity similarity, IndexReader reader, FunctionWeight w) throws IOException {
-      super(similarity);
-      this.weight = w;
-      this.qWeight = w.getValue();
-      this.reader = reader;
-      this.maxDoc = reader.maxDoc();
-      vals = func.getValues(reader);
-    }
-
-    // instead of matching all docs, we could also embed a query.
-    // the score could either ignore the subscore, or boost it.
-    // Containment:  floatline(foo:myTerm, "myFloatField", 1.0, 0.0f)
-    // Boost:        foo:myTerm^floatline("myFloatField",1.0,0.0f)
-    public boolean next() throws IOException {
-      for(;;) {
-        ++doc;
-        if (doc>=maxDoc) {
-          return false;
-        }
-        if (reader.isDeleted(doc)) continue;
-        // todo: maybe allow score() to throw a specific exception
-        // and continue on to the next document if it is thrown...
-        // that may be useful, but exceptions aren't really good
-        // for flow control.
-        return true;
-      }
-    }
-
-    public int doc() {
-      return doc;
-    }
-
-    public float score() throws IOException {
-      return qWeight * vals.floatVal(doc);
-    }
-
-    public boolean skipTo(int target) throws IOException {
-      doc=target-1;
-      return next();
-    }
-
-    public Explanation explain(int doc) throws IOException {
-      float sc = qWeight * vals.floatVal(doc);
-
-      Explanation result = new Explanation();
-      result.setDescription("FunctionQuery(" + func
-        + "), product of:");
-      result.setValue(sc);
-      result.addDetail(vals.explain(doc));
-      result.addDetail(new Explanation(getBoost(), "boost"));
-      result.addDetail(new Explanation(weight.queryNorm,"queryNorm"));
-      return result;
-    }
-  }
-
-
-  protected Weight createWeight(Searcher searcher) {
-    return new FunctionQuery.FunctionWeight(searcher);
-  }
-
-
-  /** Prints a user-readable version of this query. */
-  public String toString(String field)
-  {
-    float boost = getBoost();
-    return (boost!=1.0?"(":"") + func.toString()
-            + (getBoost()==0 ? "" : ")^"+getBoost());
-  }
-
-
-  /** Returns true if <code>o</code> is equal to this. */
-  public boolean equals(Object o) {
-    if (FunctionQuery.class != o.getClass()) return false;
-    FunctionQuery other = (FunctionQuery)o;
-    return this.getBoost() == other.getBoost()
-            && this.func.equals(other.func);
-  }
-
-  /** Returns a hash code value for this object. */
-  public int hashCode() {
-    return func.hashCode() ^ Float.floatToIntBits(getBoost());
-  }
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/IntFieldSource.java b/src/lucene_extras/org/apache/lucene/search/function/IntFieldSource.java
deleted file mode 100644
index 310346f..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/IntFieldSource.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.function.DocValues;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-
-import java.io.IOException;
-
-/**
- * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
- * using <code>getInts()</code>
- * and makes those values available as other numeric types, casting as needed. *
- * @author yonik
- * @version $Id: IntFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
- */
-
-public class IntFieldSource extends FieldCacheSource {
-  FieldCache.IntParser parser;
-
-  public IntFieldSource(String field) {
-    this(field, null);
-  }
-
-  public IntFieldSource(String field, FieldCache.IntParser parser) {
-    super(field);
-    this.parser = parser;
-  }
-
-  public String description() {
-    return "int(" + field + ')';
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final int[] arr = (parser==null) ?
-            cache.getInts(reader, field) :
-            cache.getInts(reader, field, parser);
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return (float)arr[doc];
-      }
-
-      public int intVal(int doc) {
-        return (int)arr[doc];
-      }
-
-      public long longVal(int doc) {
-        return (long)arr[doc];
-      }
-
-      public double doubleVal(int doc) {
-        return (double)arr[doc];
-      }
-
-      public String strVal(int doc) {
-        return Float.toString(arr[doc]);
-      }
-
-      public String toString(int doc) {
-        return description() + '=' + intVal(doc);
-      }
-
-    };
-  }
-
-  public boolean equals(Object o) {
-    if (o.getClass() !=  IntFieldSource.class) return false;
-    IntFieldSource other = (IntFieldSource)o;
-    return super.equals(other)
-           && this.parser==null ? other.parser==null :
-              this.parser.getClass() == other.parser.getClass();
-  }
-
-  public int hashCode() {
-    int h = parser==null ? Integer.class.hashCode() : parser.getClass().hashCode();
-    h += super.hashCode();
-    return h;
-  };
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/LinearFloatFunction.java b/src/lucene_extras/org/apache/lucene/search/function/LinearFloatFunction.java
deleted file mode 100644
index df769fb..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/LinearFloatFunction.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-
-import java.io.IOException;
-
-/**
- * <code>LinearFloatFunction</code> implements a linear function over
- * another {@link ValueSource}.
- * <br>
- * Normally Used as an argument to a {@link FunctionQuery}
- *
- * @author yonik
- * @version $Id: LinearFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
- */
-public class LinearFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float slope;
-  protected final float intercept;
-
-  public LinearFloatFunction(ValueSource source, float slope, float intercept) {
-    this.source = source;
-    this.slope = slope;
-    this.intercept = intercept;
-  }
-  
-  public String description() {
-    return slope + "*float(" + source.description() + ")+" + intercept;
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final DocValues vals =  source.getValues(reader);
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return vals.floatVal(doc) * slope + intercept;
-      }
-      public int intVal(int doc) {
-        return (int)floatVal(doc);
-      }
-      public long longVal(int doc) {
-        return (long)floatVal(doc);
-      }
-      public double doubleVal(int doc) {
-        return (double)floatVal(doc);
-      }
-      public String strVal(int doc) {
-        return Float.toString(floatVal(doc));
-      }
-      public String toString(int doc) {
-        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
-      }
-    };
-  }
-
-  public int hashCode() {
-    int h = Float.floatToIntBits(slope);
-    h = (h >>> 2) | (h << 30);
-    h += Float.floatToIntBits(intercept);
-    h ^= (h << 14) | (h >>> 19);
-    return h + source.hashCode();
-  }
-
-  public boolean equals(Object o) {
-    if (LinearFloatFunction.class != o.getClass()) return false;
-    LinearFloatFunction other = (LinearFloatFunction)o;
-    return  this.slope == other.slope
-         && this.intercept == other.intercept
-         && this.source.equals(other.source);
-  }
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/OrdFieldSource.java b/src/lucene_extras/org/apache/lucene/search/function/OrdFieldSource.java
deleted file mode 100644
index c471ba7..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/OrdFieldSource.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.function.DocValues;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-
-import java.io.IOException;
-
-/**
- * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex().
- * <br>
- * The native lucene index order is used to assign an ordinal value for each field value.
- * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
- * <br>
- * Example:<br>
- *  If there were only three field values: "apple","banana","pear"
- * <br>then ord("apple")=1, ord("banana")=2, ord("pear")=3
- * <p>
- * WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
- *  or if a MultiSearcher is used.
- * @author yonik
- * @version $Id: OrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
- */
-
-public class OrdFieldSource extends ValueSource {
-  protected String field;
-
-  public OrdFieldSource(String field) {
-    this.field = field;
-  }
-
-  public String description() {
-    return "ord(" + field + ')';
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return (float)arr[doc];
-      }
-
-      public int intVal(int doc) {
-        return (int)arr[doc];
-      }
-
-      public long longVal(int doc) {
-        return (long)arr[doc];
-      }
-
-      public double doubleVal(int doc) {
-        return (double)arr[doc];
-      }
-
-      public String strVal(int doc) {
-        // the string value of the ordinal, not the string itself
-        return Integer.toString(arr[doc]);
-      }
-
-      public String toString(int doc) {
-        return description() + '=' + intVal(doc);
-      }
-    };
-  }
-
-  public boolean equals(Object o) {
-    if (o.getClass() !=  OrdFieldSource.class) return false;
-    OrdFieldSource other = (OrdFieldSource)o;
-    return this.field.equals(field);
-  }
-
-  private static final int hcode = OrdFieldSource.class.hashCode();
-  public int hashCode() {
-    return hcode + field.hashCode();
-  };
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/ReciprocalFloatFunction.java b/src/lucene_extras/org/apache/lucene/search/function/ReciprocalFloatFunction.java
deleted file mode 100644
index a995776..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/ReciprocalFloatFunction.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-
-import java.io.IOException;
-
-/**
- * <code>ReciprocalFloatFunction</code> implements a reciprocal function f(x) = a/(mx+b), based on
- * the float value of a field as exported by {@link org.apache.lucene.search.function.ValueSource}.
- * <br>
- *
- * When a and b are equal, and x>=0, this function has a maximum value of 1 that drops as x increases.
- * Increasing the value of a and b together results in a movement of the entire function to a flatter part of the curve.
- * <br>These properties make this an idea function for boosting more recent documents.
- * <br>Example:<code>ReciprocalFloatFunction(new ReverseOrdFieldSource("my_date"),1,1000,1000)</code>
- *
- * @see FunctionQuery
- *
- *
- * @author yonik
- * @version $Id: ReciprocalFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
- */
-public class ReciprocalFloatFunction extends ValueSource {
-  protected final ValueSource source;
-  protected final float m;
-  protected final float a;
-  protected final float b;
-
-  /**
-   *  f(source) = a/(m*float(source)+b)
-   */
-  public ReciprocalFloatFunction(ValueSource source, float m, float a, float b) {
-    this.source=source;
-    this.m=m;
-    this.a=a;
-    this.b=b;
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final DocValues vals = source.getValues(reader);
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return a/(m*vals.floatVal(doc) + b);
-      }
-      public int intVal(int doc) {
-        return (int)floatVal(doc);
-      }
-      public long longVal(int doc) {
-        return (long)floatVal(doc);
-      }
-      public double doubleVal(int doc) {
-        return (double)floatVal(doc);
-      }
-      public String strVal(int doc) {
-        return Float.toString(floatVal(doc));
-      }
-      public String toString(int doc) {
-        return Float.toString(a) + "/("
-                + m + "*float(" + vals.toString(doc) + ')'
-                + '+' + b + ')';
-      }
-    };
-  }
-
-  public String description() {
-    return Float.toString(a) + "/("
-           + m + "*float(" + source.description() + ")"
-           + "+" + b + ')';
-  }
-
-  public int hashCode() {
-    int h = Float.floatToIntBits(a) + Float.floatToIntBits(m);
-    h ^= (h << 13) | (h >>> 20);
-    return h + (Float.floatToIntBits(b)) + source.hashCode();
-  }
-
-  public boolean equals(Object o) {
-    if (ReciprocalFloatFunction.class != o.getClass()) return false;
-    ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;
-    return this.m == other.m
-            && this.a == other.a
-            && this.b == other.b
-            && this.source.equals(other.source);
-  }
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/ReverseOrdFieldSource.java b/src/lucene_extras/org/apache/lucene/search/function/ReverseOrdFieldSource.java
deleted file mode 100644
index 7f59e62..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/ReverseOrdFieldSource.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.function.DocValues;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.FieldCache;
-
-import java.io.IOException;
-
-/**
- * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex()
- * and reverses the order.
- * <br>
- * The native lucene index order is used to assign an ordinal value for each field value.
- * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
- * <br>
- * Example of reverse ordinal (rord):<br>
- *  If there were only three field values: "apple","banana","pear"
- * <br>then rord("apple")=3, rord("banana")=2, ord("pear")=1
- * <p>
- *  WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
- *  or if a MultiSearcher is used.
- * @author yonik
- * @version $Id: ReverseOrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
- */
-
-public class ReverseOrdFieldSource extends ValueSource {
-  public String field;
-
-  public ReverseOrdFieldSource(String field) {
-    this.field = field;
-  }
-
-  public String description() {
-    return "rord("+field+')';
-  }
-
-  public DocValues getValues(IndexReader reader) throws IOException {
-    final FieldCache.StringIndex sindex = FieldCache.DEFAULT.getStringIndex(reader, field);
-
-    final int arr[] = sindex.order;
-    final int end = sindex.lookup.length;
-
-    return new DocValues() {
-      public float floatVal(int doc) {
-        return (float)(end - arr[doc]);
-      }
-
-      public int intVal(int doc) {
-        return (int)(end - arr[doc]);
-      }
-
-      public long longVal(int doc) {
-        return (long)(end - arr[doc]);
-      }
-
-      public double doubleVal(int doc) {
-        return (double)(end - arr[doc]);
-      }
-
-      public String strVal(int doc) {
-        // the string value of the ordinal, not the string itself
-        return Integer.toString((end - arr[doc]));
-      }
-
-      public String toString(int doc) {
-        return description() + '=' + strVal(doc);
-      }
-    };
-  }
-
-  public boolean equals(Object o) {
-    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
-    ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
-    return this.field.equals(field);
-  }
-
-  private static final int hcode = ReverseOrdFieldSource.class.hashCode();
-  public int hashCode() {
-    return hcode + field.hashCode();
-  };
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/ValueSource.java b/src/lucene_extras/org/apache/lucene/search/function/ValueSource.java
deleted file mode 100644
index 312e11c..0000000
--- a/src/lucene_extras/org/apache/lucene/search/function/ValueSource.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search.function;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.function.DocValues;
-
-import java.io.IOException;
-import java.io.Serializable;
-
-/**
- * Instantiates {@link org.apache.lucene.search.function.DocValues} for a particular reader.
- * <br>
- * Often used when creating a {@link FunctionQuery}.
- *
- * @author yonik
- * @version $Id: ValueSource.java,v 1.2 2005/11/30 19:31:01 yonik Exp $
- */
-public abstract class ValueSource implements Serializable {
-
-  public abstract DocValues getValues(IndexReader reader) throws IOException;
-
-  public abstract boolean equals(Object o);
-
-  public abstract int hashCode();
-
-  /** description of field, used in explain() */
-  public abstract String description();
-
-  public String toString() {
-    return getClass().getName() + ":" + description();
-  }
-
-}
diff --git a/src/lucene_extras/org/apache/lucene/search/function/function.zip b/src/lucene_extras/org/apache/lucene/search/function/function.zip
deleted file mode 100755
index 1f05cb8..0000000
Binary files a/src/lucene_extras/org/apache/lucene/search/function/function.zip and /dev/null differ

