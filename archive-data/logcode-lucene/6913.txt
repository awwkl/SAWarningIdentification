GitDiffStart: 7f6a40e15782d97dfedddcf6cc2b42f9c811654d | Mon Feb 24 15:45:07 2014 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java
new file mode 100644
index 0000000..eb0aa1a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java
@@ -0,0 +1,192 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+import java.util.Arrays;
+import java.util.Comparator;
+
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.ByteBlockPool;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefIterator;
+import org.apache.lucene.util.Counter;
+import org.apache.lucene.util.IntroSorter;
+import org.apache.lucene.util.RamUsageEstimator;
+
+/**
+ * A simple append only random-access {@link BytesRef} array that stores full
+ * copies of the appended bytes in a {@link ByteBlockPool}.
+ * 
+ * 
+ * <b>Note: This class is not Thread-Safe!</b>
+ * 
+ * @lucene.internal
+ * @lucene.experimental
+ */
+public final class BytesRefArray {
+  private final ByteBlockPool pool;
+  private int[] offsets = new int[1];
+  private int lastElement = 0;
+  private int currentOffset = 0;
+  private final Counter bytesUsed;
+  
+  /**
+   * Creates a new {@link BytesRefArray} with a counter to track allocated bytes
+   */
+  public BytesRefArray(Counter bytesUsed) {
+    this.pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(
+        bytesUsed));
+    pool.nextBuffer();
+    bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_ARRAY_HEADER
+        + RamUsageEstimator.NUM_BYTES_INT);
+    this.bytesUsed = bytesUsed;
+  }
+ 
+  /**
+   * Clears this {@link BytesRefArray}
+   */
+  public void clear() {
+    lastElement = 0;
+    currentOffset = 0;
+    Arrays.fill(offsets, 0);
+    pool.reset(false, true); // no need to 0 fill the buffers we control the allocator
+  }
+  
+  /**
+   * Appends a copy of the given {@link BytesRef} to this {@link BytesRefArray}.
+   * @param bytes the bytes to append
+   * @return the index of the appended bytes
+   */
+  public int append(BytesRef bytes) {
+    if (lastElement >= offsets.length) {
+      int oldLen = offsets.length;
+      offsets = ArrayUtil.grow(offsets, offsets.length + 1);
+      bytesUsed.addAndGet((offsets.length - oldLen)
+          * RamUsageEstimator.NUM_BYTES_INT);
+    }
+    pool.append(bytes);
+    offsets[lastElement++] = currentOffset;
+    currentOffset += bytes.length;
+    return lastElement-1;
+  }
+  
+  /**
+   * Returns the current size of this {@link BytesRefArray}
+   * @return the current size of this {@link BytesRefArray}
+   */
+  public int size() {
+    return lastElement;
+  }
+  
+  /**
+   * Returns the <i>n'th</i> element of this {@link BytesRefArray}
+   * @param spare a spare {@link BytesRef} instance
+   * @param index the elements index to retrieve 
+   * @return the <i>n'th</i> element of this {@link BytesRefArray}
+   */
+  public BytesRef get(BytesRef spare, int index) {
+    if (lastElement > index) {
+      int offset = offsets[index];
+      int length = index == lastElement - 1 ? currentOffset - offset
+          : offsets[index + 1] - offset;
+      assert spare.offset == 0;
+      spare.grow(length);
+      spare.length = length;
+      pool.readBytes(offset, spare.bytes, spare.offset, spare.length);
+      return spare;
+    }
+    throw new IndexOutOfBoundsException("index " + index
+        + " must be less than the size: " + lastElement);
+    
+  }
+  
+  private int[] sort(final Comparator<BytesRef> comp) {
+    final int[] orderedEntries = new int[size()];
+    for (int i = 0; i < orderedEntries.length; i++) {
+      orderedEntries[i] = i;
+    }
+    new IntroSorter() {
+      @Override
+      protected void swap(int i, int j) {
+        final int o = orderedEntries[i];
+        orderedEntries[i] = orderedEntries[j];
+        orderedEntries[j] = o;
+      }
+      
+      @Override
+      protected int compare(int i, int j) {
+        final int idx1 = orderedEntries[i], idx2 = orderedEntries[j];
+        return comp.compare(get(scratch1, idx1), get(scratch2, idx2));
+      }
+      
+      @Override
+      protected void setPivot(int i) {
+        final int index = orderedEntries[i];
+        get(pivot, index);
+      }
+      
+      @Override
+      protected int comparePivot(int j) {
+        final int index = orderedEntries[j];
+        return comp.compare(pivot, get(scratch2, index));
+      }
+      
+      private final BytesRef pivot = new BytesRef(), scratch1 = new BytesRef(),
+          scratch2 = new BytesRef();
+    }.sort(0, size());
+    return orderedEntries;
+  }
+  
+  /**
+   * sugar for {@link #iterator(Comparator)} with a <code>null</code> comparator
+   */
+  public BytesRefIterator iterator() {
+    return iterator(null);
+  }
+  
+  /**
+   * <p>
+   * Returns a {@link BytesRefIterator} with point in time semantics. The
+   * iterator provides access to all so far appended {@link BytesRef} instances.
+   * </p>
+   * <p>
+   * If a non <code>null</code> {@link Comparator} is provided the iterator will
+   * iterate the byte values in the order specified by the comparator. Otherwise
+   * the order is the same as the values were appended.
+   * </p>
+   * <p>
+   * This is a non-destructive operation.
+   * </p>
+   */
+  public BytesRefIterator iterator(final Comparator<BytesRef> comp) {
+    final BytesRef spare = new BytesRef();
+    final int size = size();
+    final int[] indices = comp == null ? null : sort(comp);
+    return new BytesRefIterator() {
+      int pos = 0;
+      
+      @Override
+      public BytesRef next() {
+        if (pos < size) {
+          return get(spare, indices == null ? pos++ : indices[pos++]);
+        }
+        return null;
+      }
+    };
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java b/lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java
new file mode 100644
index 0000000..76781f8
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java
@@ -0,0 +1,572 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.Closeable;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * On-disk sorting of byte arrays. Each byte array (entry) is a composed of the following
+ * fields:
+ * <ul>
+ *   <li>(two bytes) length of the following byte array,
+ *   <li>exactly the above count of bytes for the sequence to be sorted.
+ * </ul>
+ * 
+ * @see #sort(File, File)
+ * @lucene.experimental
+ * @lucene.internal
+ */
+public final class OfflineSorter {
+  /** Convenience constant for megabytes */
+  public final static long MB = 1024 * 1024;
+  /** Convenience constant for gigabytes */
+  public final static long GB = MB * 1024;
+  
+  /**
+   * Minimum recommended buffer size for sorting.
+   */
+  public final static long MIN_BUFFER_SIZE_MB = 32;
+
+  /**
+   * Absolute minimum required buffer size for sorting.
+   */
+  public static final long ABSOLUTE_MIN_SORT_BUFFER_SIZE = MB / 2;
+  private static final String MIN_BUFFER_SIZE_MSG = "At least 0.5MB RAM buffer is needed";
+
+  /**
+   * Maximum number of temporary files before doing an intermediate merge.
+   */
+  public final static int MAX_TEMPFILES = 128;
+
+  /** 
+   * A bit more descriptive unit for constructors.
+   * 
+   * @see #automatic()
+   * @see #megabytes(long)
+   */
+  public static final class BufferSize {
+    final int bytes;
+  
+    private BufferSize(long bytes) {
+      if (bytes > Integer.MAX_VALUE) {
+        throw new IllegalArgumentException("Buffer too large for Java ("
+            + (Integer.MAX_VALUE / MB) + "mb max): " + bytes);
+      }
+      
+      if (bytes < ABSOLUTE_MIN_SORT_BUFFER_SIZE) {
+        throw new IllegalArgumentException(MIN_BUFFER_SIZE_MSG + ": " + bytes);
+      }
+  
+      this.bytes = (int) bytes;
+    }
+    
+    /**
+     * Creates a {@link BufferSize} in MB. The given 
+     * values must be $gt; 0 and &lt; 2048.
+     */
+    public static BufferSize megabytes(long mb) {
+      return new BufferSize(mb * MB);
+    }
+  
+    /** 
+     * Approximately half of the currently available free heap, but no less
+     * than {@link #ABSOLUTE_MIN_SORT_BUFFER_SIZE}. However if current heap allocation 
+     * is insufficient or if there is a large portion of unallocated heap-space available 
+     * for sorting consult with max allowed heap size. 
+     */
+    public static BufferSize automatic() {
+      Runtime rt = Runtime.getRuntime();
+      
+      // take sizes in "conservative" order
+      final long max = rt.maxMemory(); // max allocated
+      final long total = rt.totalMemory(); // currently allocated
+      final long free = rt.freeMemory(); // unused portion of currently allocated
+      final long totalAvailableBytes = max - total + free;
+      
+      // by free mem (attempting to not grow the heap for this)
+      long sortBufferByteSize = free/2;
+      final long minBufferSizeBytes = MIN_BUFFER_SIZE_MB*MB;
+      if (sortBufferByteSize <  minBufferSizeBytes
+          || totalAvailableBytes > 10 * minBufferSizeBytes) { // lets see if we need/should to grow the heap 
+        if (totalAvailableBytes/2 > minBufferSizeBytes){ // there is enough mem for a reasonable buffer
+          sortBufferByteSize = totalAvailableBytes/2; // grow the heap
+        } else {
+          //heap seems smallish lets be conservative fall back to the free/2 
+          sortBufferByteSize = Math.max(ABSOLUTE_MIN_SORT_BUFFER_SIZE, sortBufferByteSize);
+        }
+      }
+      return new BufferSize(Math.min((long)Integer.MAX_VALUE, sortBufferByteSize));
+    }
+  }
+  
+  /**
+   * Sort info (debugging mostly).
+   */
+  public class SortInfo {
+    /** number of temporary files created when merging partitions */
+    public int tempMergeFiles;
+    /** number of partition merges */
+    public int mergeRounds;
+    /** number of lines of data read */
+    public int lines;
+    /** time spent merging sorted partitions (in milliseconds) */
+    public long mergeTime;
+    /** time spent sorting data (in milliseconds) */
+    public long sortTime;
+    /** total time spent (in milliseconds) */
+    public long totalTime;
+    /** time spent in i/o read (in milliseconds) */
+    public long readTime;
+    /** read buffer size (in bytes) */
+    public final long bufferSize = ramBufferSize.bytes;
+    
+    /** create a new SortInfo (with empty statistics) for debugging */
+    public SortInfo() {}
+    
+    @Override
+    public String toString() {
+      return String.format(Locale.ROOT,
+          "time=%.2f sec. total (%.2f reading, %.2f sorting, %.2f merging), lines=%d, temp files=%d, merges=%d, soft ram limit=%.2f MB",
+          totalTime / 1000.0d, readTime / 1000.0d, sortTime / 1000.0d, mergeTime / 1000.0d,
+          lines, tempMergeFiles, mergeRounds,
+          (double) bufferSize / MB);
+    }
+  }
+
+  private final BufferSize ramBufferSize;
+  private final File tempDirectory;
+  
+  private final Counter bufferBytesUsed = Counter.newCounter();
+  private final BytesRefArray buffer = new BytesRefArray(bufferBytesUsed);
+  private SortInfo sortInfo;
+  private int maxTempFiles;
+  private final Comparator<BytesRef> comparator;
+  
+  /** Default comparator: sorts in binary (codepoint) order */
+  public static final Comparator<BytesRef> DEFAULT_COMPARATOR = BytesRef.getUTF8SortedAsUnicodeComparator();
+
+  /**
+   * Defaults constructor.
+   * 
+   * @see #defaultTempDir()
+   * @see BufferSize#automatic()
+   */
+  public OfflineSorter() throws IOException {
+    this(DEFAULT_COMPARATOR, BufferSize.automatic(), defaultTempDir(), MAX_TEMPFILES);
+  }
+  
+  /**
+   * Defaults constructor with a custom comparator.
+   * 
+   * @see #defaultTempDir()
+   * @see BufferSize#automatic()
+   */
+  public OfflineSorter(Comparator<BytesRef> comparator) throws IOException {
+    this(comparator, BufferSize.automatic(), defaultTempDir(), MAX_TEMPFILES);
+  }
+
+  /**
+   * All-details constructor.
+   */
+  public OfflineSorter(Comparator<BytesRef> comparator, BufferSize ramBufferSize, File tempDirectory, int maxTempfiles) {
+    if (ramBufferSize.bytes < ABSOLUTE_MIN_SORT_BUFFER_SIZE) {
+      throw new IllegalArgumentException(MIN_BUFFER_SIZE_MSG + ": " + ramBufferSize.bytes);
+    }
+    
+    if (maxTempfiles < 2) {
+      throw new IllegalArgumentException("maxTempFiles must be >= 2");
+    }
+
+    this.ramBufferSize = ramBufferSize;
+    this.tempDirectory = tempDirectory;
+    this.maxTempFiles = maxTempfiles;
+    this.comparator = comparator;
+  }
+
+  /** 
+   * Sort input to output, explicit hint for the buffer size. The amount of allocated
+   * memory may deviate from the hint (may be smaller or larger).  
+   */
+  public SortInfo sort(File input, File output) throws IOException {
+    sortInfo = new SortInfo();
+    sortInfo.totalTime = System.currentTimeMillis();
+
+    output.delete();
+
+    ArrayList<File> merges = new ArrayList<File>();
+    boolean success2 = false;
+    try {
+      ByteSequencesReader is = new ByteSequencesReader(input);
+      boolean success = false;
+      try {
+        int lines = 0;
+        while ((lines = readPartition(is)) > 0) {
+          merges.add(sortPartition(lines));
+          sortInfo.tempMergeFiles++;
+          sortInfo.lines += lines;
+
+          // Handle intermediate merges.
+          if (merges.size() == maxTempFiles) {
+            File intermediate = File.createTempFile("sort", "intermediate", tempDirectory);
+            try {
+              mergePartitions(merges, intermediate);
+            } finally {
+              for (File file : merges) {
+                file.delete();
+              }
+              merges.clear();
+              merges.add(intermediate);
+            }
+            sortInfo.tempMergeFiles++;
+          }
+        }
+        success = true;
+      } finally {
+        if (success)
+          IOUtils.close(is);
+        else
+          IOUtils.closeWhileHandlingException(is);
+      }
+
+      // One partition, try to rename or copy if unsuccessful.
+      if (merges.size() == 1) {     
+        File single = merges.get(0);
+        // If simple rename doesn't work this means the output is
+        // on a different volume or something. Copy the input then.
+        if (!single.renameTo(output)) {
+          copy(single, output);
+        }
+      } else { 
+        // otherwise merge the partitions with a priority queue.
+        mergePartitions(merges, output);
+      }
+      success2 = true;
+    } finally {
+      for (File file : merges) {
+        file.delete();
+      }
+      if (!success2) {
+        output.delete();
+      }
+    }
+
+    sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); 
+    return sortInfo;
+  }
+
+  /**
+   * Returns the default temporary directory. By default, java.io.tmpdir. If not accessible
+   * or not available, an IOException is thrown
+   */
+  public static File defaultTempDir() throws IOException {
+    String tempDirPath = System.getProperty("java.io.tmpdir");
+    if (tempDirPath == null) 
+      throw new IOException("Java has no temporary folder property (java.io.tmpdir)?");
+
+    File tempDirectory = new File(tempDirPath);
+    if (!tempDirectory.exists() || !tempDirectory.canWrite()) {
+      throw new IOException("Java's temporary folder not present or writeable?: " 
+          + tempDirectory.getAbsolutePath());
+    }
+    return tempDirectory;
+  }
+
+  /**
+   * Copies one file to another.
+   */
+  private static void copy(File file, File output) throws IOException {
+    // 64kb copy buffer (empirical pick).
+    byte [] buffer = new byte [16 * 1024];
+    InputStream is = null;
+    OutputStream os = null;
+    try {
+      is = new FileInputStream(file);
+      os = new FileOutputStream(output);
+      int length;
+      while ((length = is.read(buffer)) > 0) {
+        os.write(buffer, 0, length);
+      }
+    } finally {
+      IOUtils.close(is, os);
+    }
+  }
+
+  /** Sort a single partition in-memory. */
+  protected File sortPartition(int len) throws IOException {
+    BytesRefArray data = this.buffer;
+    File tempFile = File.createTempFile("sort", "partition", tempDirectory);
+
+    long start = System.currentTimeMillis();
+    sortInfo.sortTime += (System.currentTimeMillis() - start);
+    
+    final ByteSequencesWriter out = new ByteSequencesWriter(tempFile);
+    BytesRef spare;
+    try {
+      BytesRefIterator iter = buffer.iterator(comparator);
+      while((spare = iter.next()) != null) {
+        assert spare.length <= Short.MAX_VALUE;
+        out.write(spare);
+      }
+      
+      out.close();
+
+      // Clean up the buffer for the next partition.
+      data.clear();
+      return tempFile;
+    } finally {
+      IOUtils.close(out);
+    }
+  }
+
+  /** Merge a list of sorted temporary files (partitions) into an output file */
+  void mergePartitions(List<File> merges, File outputFile) throws IOException {
+    long start = System.currentTimeMillis();
+
+    ByteSequencesWriter out = new ByteSequencesWriter(outputFile);
+
+    PriorityQueue<FileAndTop> queue = new PriorityQueue<FileAndTop>(merges.size()) {
+      @Override
+      protected boolean lessThan(FileAndTop a, FileAndTop b) {
+        return comparator.compare(a.current, b.current) < 0;
+      }
+    };
+
+    ByteSequencesReader [] streams = new ByteSequencesReader [merges.size()];
+    try {
+      // Open streams and read the top for each file
+      for (int i = 0; i < merges.size(); i++) {
+        streams[i] = new ByteSequencesReader(merges.get(i));
+        byte line[] = streams[i].read();
+        if (line != null) {
+          queue.insertWithOverflow(new FileAndTop(i, line));
+        }
+      }
+  
+      // Unix utility sort() uses ordered array of files to pick the next line from, updating
+      // it as it reads new lines. The PQ used here is a more elegant solution and has 
+      // a nicer theoretical complexity bound :) The entire sorting process is I/O bound anyway
+      // so it shouldn't make much of a difference (didn't check).
+      FileAndTop top;
+      while ((top = queue.top()) != null) {
+        out.write(top.current);
+        if (!streams[top.fd].read(top.current)) {
+          queue.pop();
+        } else {
+          queue.updateTop();
+        }
+      }
+  
+      sortInfo.mergeTime += System.currentTimeMillis() - start;
+      sortInfo.mergeRounds++;
+    } finally {
+      // The logic below is: if an exception occurs in closing out, it has a priority over exceptions
+      // happening in closing streams.
+      try {
+        IOUtils.close(streams);
+      } finally {
+        IOUtils.close(out);
+      }
+    }
+  }
+
+  /** Read in a single partition of data */
+  int readPartition(ByteSequencesReader reader) throws IOException {
+    long start = System.currentTimeMillis();
+    final BytesRef scratch = new BytesRef();
+    while ((scratch.bytes = reader.read()) != null) {
+      scratch.length = scratch.bytes.length; 
+      buffer.append(scratch);
+      // Account for the created objects.
+      // (buffer slots do not account to buffer size.) 
+      if (ramBufferSize.bytes < bufferBytesUsed.get()) {
+        break;
+      }
+    }
+    sortInfo.readTime += (System.currentTimeMillis() - start);
+    return buffer.size();
+  }
+
+  static class FileAndTop {
+    final int fd;
+    final BytesRef current;
+
+    FileAndTop(int fd, byte [] firstLine) {
+      this.fd = fd;
+      this.current = new BytesRef(firstLine);
+    }
+  }
+
+  /**
+   * Utility class to emit length-prefixed byte[] entries to an output stream for sorting.
+   * Complementary to {@link ByteSequencesReader}.
+   */
+  public static class ByteSequencesWriter implements Closeable {
+    private final DataOutput os;
+
+    /** Constructs a ByteSequencesWriter to the provided File */
+    public ByteSequencesWriter(File file) throws IOException {
+      this(new DataOutputStream(
+          new BufferedOutputStream(
+              new FileOutputStream(file))));
+    }
+
+    /** Constructs a ByteSequencesWriter to the provided DataOutput */
+    public ByteSequencesWriter(DataOutput os) {
+      this.os = os;
+    }
+
+    /**
+     * Writes a BytesRef.
+     * @see #write(byte[], int, int)
+     */
+    public void write(BytesRef ref) throws IOException {
+      assert ref != null;
+      write(ref.bytes, ref.offset, ref.length);
+    }
+
+    /**
+     * Writes a byte array.
+     * @see #write(byte[], int, int)
+     */
+    public void write(byte [] bytes) throws IOException {
+      write(bytes, 0, bytes.length);
+    }
+
+    /**
+     * Writes a byte array.
+     * <p>
+     * The length is written as a <code>short</code>, followed
+     * by the bytes.
+     */
+    public void write(byte [] bytes, int off, int len) throws IOException {
+      assert bytes != null;
+      assert off >= 0 && off + len <= bytes.length;
+      assert len >= 0;
+      os.writeShort(len);
+      os.write(bytes, off, len);
+    }        
+    
+    /**
+     * Closes the provided {@link DataOutput} if it is {@link Closeable}.
+     */
+    @Override
+    public void close() throws IOException {
+      if (os instanceof Closeable) {
+        ((Closeable) os).close();
+      }
+    }    
+  }
+
+  /**
+   * Utility class to read length-prefixed byte[] entries from an input.
+   * Complementary to {@link ByteSequencesWriter}.
+   */
+  public static class ByteSequencesReader implements Closeable {
+    private final DataInput is;
+
+    /** Constructs a ByteSequencesReader from the provided File */
+    public ByteSequencesReader(File file) throws IOException {
+      this(new DataInputStream(
+          new BufferedInputStream(
+              new FileInputStream(file))));
+    }
+
+    /** Constructs a ByteSequencesReader from the provided DataInput */
+    public ByteSequencesReader(DataInput is) {
+      this.is = is;
+    }
+
+    /**
+     * Reads the next entry into the provided {@link BytesRef}. The internal
+     * storage is resized if needed.
+     * 
+     * @return Returns <code>false</code> if EOF occurred when trying to read
+     * the header of the next sequence. Returns <code>true</code> otherwise.
+     * @throws EOFException if the file ends before the full sequence is read.
+     */
+    public boolean read(BytesRef ref) throws IOException {
+      short length;
+      try {
+        length = is.readShort();
+      } catch (EOFException e) {
+        return false;
+      }
+
+      ref.grow(length);
+      ref.offset = 0;
+      ref.length = length;
+      is.readFully(ref.bytes, 0, length);
+      return true;
+    }
+
+    /**
+     * Reads the next entry and returns it if successful.
+     * 
+     * @see #read(BytesRef)
+     * 
+     * @return Returns <code>null</code> if EOF occurred before the next entry
+     * could be read.
+     * @throws EOFException if the file ends before the full sequence is read.
+     */
+    public byte[] read() throws IOException {
+      short length;
+      try {
+        length = is.readShort();
+      } catch (EOFException e) {
+        return null;
+      }
+
+      assert length >= 0 : "Sanity: sequence length < 0: " + length;
+      byte [] result = new byte [length];
+      is.readFully(result);
+      return result;
+    }
+
+    /**
+     * Closes the provided {@link DataInput} if it is {@link Closeable}.
+     */
+    @Override
+    public void close() throws IOException {
+      if (is instanceof Closeable) {
+        ((Closeable) is).close();
+      }
+    }
+  }
+
+  /** Returns the comparator in use to sort entries */
+  public Comparator<BytesRef> getComparator() {
+    return comparator;
+  }  
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java
new file mode 100644
index 0000000..9fcd6a1
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/TestBytesRefArray.java
@@ -0,0 +1,109 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with this
+ * work for additional information regarding copyright ownership. The ASF
+ * licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+import java.io.IOException;
+import java.util.*;
+
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefIterator;
+import org.apache.lucene.util.Counter;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+public class TestBytesRefArray extends LuceneTestCase {
+
+  public void testAppend() throws IOException {
+    Random random = random();
+    BytesRefArray list = new BytesRefArray(Counter.newCounter());
+    List<String> stringList = new ArrayList<String>();
+    for (int j = 0; j < 2; j++) {
+      if (j > 0 && random.nextBoolean()) {
+        list.clear();
+        stringList.clear();
+      }
+      int entries = atLeast(500);
+      BytesRef spare = new BytesRef();
+      int initSize = list.size();
+      for (int i = 0; i < entries; i++) {
+        String randomRealisticUnicodeString = TestUtil
+            .randomRealisticUnicodeString(random);
+        spare.copyChars(randomRealisticUnicodeString);
+        assertEquals(i+initSize, list.append(spare));
+        stringList.add(randomRealisticUnicodeString);
+      }
+      for (int i = 0; i < entries; i++) {
+        assertNotNull(list.get(spare, i));
+        assertEquals("entry " + i + " doesn't match", stringList.get(i),
+            spare.utf8ToString());
+      }
+      
+      // check random
+      for (int i = 0; i < entries; i++) {
+        int e = random.nextInt(entries);
+        assertNotNull(list.get(spare, e));
+        assertEquals("entry " + i + " doesn't match", stringList.get(e),
+            spare.utf8ToString());
+      }
+      for (int i = 0; i < 2; i++) {
+        
+        BytesRefIterator iterator = list.iterator();
+        for (String string : stringList) {
+          assertEquals(string, iterator.next().utf8ToString());
+        }
+      }
+    }
+  }
+
+  public void testSort() throws IOException {
+    Random random = random();
+    BytesRefArray list = new BytesRefArray(Counter.newCounter());
+    List<String> stringList = new ArrayList<String>();
+
+    for (int j = 0; j < 2; j++) {
+      if (j > 0 && random.nextBoolean()) {
+        list.clear();
+        stringList.clear();
+      }
+      int entries = atLeast(500);
+      BytesRef spare = new BytesRef();
+      final int initSize = list.size();
+      for (int i = 0; i < entries; i++) {
+        String randomRealisticUnicodeString = TestUtil
+            .randomRealisticUnicodeString(random);
+        spare.copyChars(randomRealisticUnicodeString);
+        assertEquals(initSize + i, list.append(spare));
+        stringList.add(randomRealisticUnicodeString);
+      }
+      
+      Collections.sort(stringList);
+      BytesRefIterator iter = list.iterator(BytesRef
+          .getUTF8SortedAsUTF16Comparator());
+      int i = 0;
+      while ((spare = iter.next()) != null) {
+        assertEquals("entry " + i + " doesn't match", stringList.get(i),
+            spare.utf8ToString());
+        i++;
+      }
+      assertNull(iter.next());
+      assertEquals(i, stringList.size());
+    }
+    
+  }
+  
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java b/lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java
new file mode 100644
index 0000000..b7f14d0
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java
@@ -0,0 +1,186 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.OfflineSorter;
+import org.apache.lucene.util.OfflineSorter.BufferSize;
+import org.apache.lucene.util.OfflineSorter.ByteSequencesWriter;
+import org.apache.lucene.util.OfflineSorter.SortInfo;
+import org.apache.lucene.util.TestUtil;
+
+/**
+ * Tests for on-disk merge sorting.
+ */
+public class TestOfflineSorter extends LuceneTestCase {
+  private File tempDir;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    tempDir = TestUtil.getTempDir("mergesort");
+    TestUtil.rmDir(tempDir);
+    tempDir.mkdirs();
+  }
+  
+  @Override
+  public void tearDown() throws Exception {
+    if (tempDir != null)
+      TestUtil.rmDir(tempDir);
+    super.tearDown();
+  }
+
+  public void testEmpty() throws Exception {
+    checkSort(new OfflineSorter(), new byte [][] {});
+  }
+
+  public void testSingleLine() throws Exception {
+    checkSort(new OfflineSorter(), new byte [][] {
+        "Single line only.".getBytes("UTF-8")
+    });
+  }
+
+  public void testIntermediateMerges() throws Exception {
+    // Sort 20 mb worth of data with 1mb buffer, binary merging.
+    SortInfo info = checkSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARATOR, BufferSize.megabytes(1), OfflineSorter.defaultTempDir(), 2), 
+        generateRandom((int)OfflineSorter.MB * 20));
+    assertTrue(info.mergeRounds > 10);
+  }
+
+  public void testSmallRandom() throws Exception {
+    // Sort 20 mb worth of data with 1mb buffer.
+    SortInfo sortInfo = checkSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARATOR, BufferSize.megabytes(1), OfflineSorter.defaultTempDir(), OfflineSorter.MAX_TEMPFILES), 
+        generateRandom((int)OfflineSorter.MB * 20));
+    assertEquals(1, sortInfo.mergeRounds);
+  }
+
+  @Nightly
+  public void testLargerRandom() throws Exception {
+    // Sort 100MB worth of data with 15mb buffer.
+    checkSort(new OfflineSorter(OfflineSorter.DEFAULT_COMPARATOR, BufferSize.megabytes(16), OfflineSorter.defaultTempDir(), OfflineSorter.MAX_TEMPFILES), 
+        generateRandom((int)OfflineSorter.MB * 100));
+  }
+
+  private byte[][] generateRandom(int howMuchData) {
+    ArrayList<byte[]> data = new ArrayList<byte[]>(); 
+    while (howMuchData > 0) {
+      byte [] current = new byte [random().nextInt(256)];
+      random().nextBytes(current);
+      data.add(current);
+      howMuchData -= current.length;
+    }
+    byte [][] bytes = data.toArray(new byte[data.size()][]);
+    return bytes;
+  }
+  
+  static final Comparator<byte[]> unsignedByteOrderComparator = new Comparator<byte[]>() {
+    @Override
+    public int compare(byte[] left, byte[] right) {
+      final int max = Math.min(left.length, right.length);
+      for (int i = 0, j = 0; i < max; i++, j++) {
+        int diff = (left[i]  & 0xff) - (right[j] & 0xff); 
+        if (diff != 0) 
+          return diff;
+      }
+      return left.length - right.length;
+    }
+  };
+  /**
+   * Check sorting data on an instance of {@link OfflineSorter}.
+   */
+  private SortInfo checkSort(OfflineSorter sort, byte[][] data) throws IOException {
+    File unsorted = writeAll("unsorted", data);
+
+    Arrays.sort(data, unsignedByteOrderComparator);
+    File golden = writeAll("golden", data);
+
+    File sorted = new File(tempDir, "sorted");
+    SortInfo sortInfo = sort.sort(unsorted, sorted);
+    //System.out.println("Input size [MB]: " + unsorted.length() / (1024 * 1024));
+    //System.out.println(sortInfo);
+
+    assertFilesIdentical(golden, sorted);
+    return sortInfo;
+  }
+
+  /**
+   * Make sure two files are byte-byte identical.
+   */
+  private void assertFilesIdentical(File golden, File sorted) throws IOException {
+    assertEquals(golden.length(), sorted.length());
+
+    byte [] buf1 = new byte [64 * 1024];
+    byte [] buf2 = new byte [64 * 1024];
+    int len;
+    DataInputStream is1 = new DataInputStream(new FileInputStream(golden));
+    DataInputStream is2 = new DataInputStream(new FileInputStream(sorted));
+    while ((len = is1.read(buf1)) > 0) {
+      is2.readFully(buf2, 0, len);
+      for (int i = 0; i < len; i++) {
+        assertEquals(buf1[i], buf2[i]);
+      }
+    }
+    IOUtils.close(is1, is2);
+  }
+
+  private File writeAll(String name, byte[][] data) throws IOException {
+    File file = new File(tempDir, name);
+    ByteSequencesWriter w = new OfflineSorter.ByteSequencesWriter(file);
+    for (byte [] datum : data) {
+      w.write(datum);
+    }
+    w.close();
+    return file;
+  }
+  
+  public void testRamBuffer() {
+    int numIters = atLeast(10000);
+    for (int i = 0; i < numIters; i++) {
+      BufferSize.megabytes(1+random().nextInt(2047));
+    }
+    BufferSize.megabytes(2047);
+    BufferSize.megabytes(1);
+    
+    try {
+      BufferSize.megabytes(2048);
+      fail("max mb is 2047");
+    } catch (IllegalArgumentException e) {
+    }
+    
+    try {
+      BufferSize.megabytes(0);
+      fail("min mb is 0.5");
+    } catch (IllegalArgumentException e) {
+    }
+    
+    try {
+      BufferSize.megabytes(-1);
+      fail("min mb is 0.5");
+    } catch (IllegalArgumentException e) {
+    }
+  }
+}
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/BufferedInputIterator.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/BufferedInputIterator.java
index b9772fa..96c7cf8 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/BufferedInputIterator.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/BufferedInputIterator.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefArray;
 import org.apache.lucene.util.Counter;
 
 /**
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/BytesRefArray.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/BytesRefArray.java
deleted file mode 100644
index e7a44fc..0000000
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/BytesRefArray.java
+++ /dev/null
@@ -1,192 +0,0 @@
-package org.apache.lucene.search.suggest;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-import java.util.Arrays;
-import java.util.Comparator;
-
-import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.ByteBlockPool;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.BytesRefIterator;
-import org.apache.lucene.util.Counter;
-import org.apache.lucene.util.IntroSorter;
-import org.apache.lucene.util.RamUsageEstimator;
-
-/**
- * A simple append only random-access {@link BytesRef} array that stores full
- * copies of the appended bytes in a {@link ByteBlockPool}.
- * 
- * 
- * <b>Note: This class is not Thread-Safe!</b>
- * 
- * @lucene.internal
- * @lucene.experimental
- */
-public final class BytesRefArray {
-  private final ByteBlockPool pool;
-  private int[] offsets = new int[1];
-  private int lastElement = 0;
-  private int currentOffset = 0;
-  private final Counter bytesUsed;
-  
-  /**
-   * Creates a new {@link BytesRefArray} with a counter to track allocated bytes
-   */
-  public BytesRefArray(Counter bytesUsed) {
-    this.pool = new ByteBlockPool(new ByteBlockPool.DirectTrackingAllocator(
-        bytesUsed));
-    pool.nextBuffer();
-    bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_ARRAY_HEADER
-        + RamUsageEstimator.NUM_BYTES_INT);
-    this.bytesUsed = bytesUsed;
-  }
- 
-  /**
-   * Clears this {@link BytesRefArray}
-   */
-  public void clear() {
-    lastElement = 0;
-    currentOffset = 0;
-    Arrays.fill(offsets, 0);
-    pool.reset(false, true); // no need to 0 fill the buffers we control the allocator
-  }
-  
-  /**
-   * Appends a copy of the given {@link BytesRef} to this {@link BytesRefArray}.
-   * @param bytes the bytes to append
-   * @return the index of the appended bytes
-   */
-  public int append(BytesRef bytes) {
-    if (lastElement >= offsets.length) {
-      int oldLen = offsets.length;
-      offsets = ArrayUtil.grow(offsets, offsets.length + 1);
-      bytesUsed.addAndGet((offsets.length - oldLen)
-          * RamUsageEstimator.NUM_BYTES_INT);
-    }
-    pool.append(bytes);
-    offsets[lastElement++] = currentOffset;
-    currentOffset += bytes.length;
-    return lastElement-1;
-  }
-  
-  /**
-   * Returns the current size of this {@link BytesRefArray}
-   * @return the current size of this {@link BytesRefArray}
-   */
-  public int size() {
-    return lastElement;
-  }
-  
-  /**
-   * Returns the <i>n'th</i> element of this {@link BytesRefArray}
-   * @param spare a spare {@link BytesRef} instance
-   * @param index the elements index to retrieve 
-   * @return the <i>n'th</i> element of this {@link BytesRefArray}
-   */
-  public BytesRef get(BytesRef spare, int index) {
-    if (lastElement > index) {
-      int offset = offsets[index];
-      int length = index == lastElement - 1 ? currentOffset - offset
-          : offsets[index + 1] - offset;
-      assert spare.offset == 0;
-      spare.grow(length);
-      spare.length = length;
-      pool.readBytes(offset, spare.bytes, spare.offset, spare.length);
-      return spare;
-    }
-    throw new IndexOutOfBoundsException("index " + index
-        + " must be less than the size: " + lastElement);
-    
-  }
-  
-  private int[] sort(final Comparator<BytesRef> comp) {
-    final int[] orderedEntries = new int[size()];
-    for (int i = 0; i < orderedEntries.length; i++) {
-      orderedEntries[i] = i;
-    }
-    new IntroSorter() {
-      @Override
-      protected void swap(int i, int j) {
-        final int o = orderedEntries[i];
-        orderedEntries[i] = orderedEntries[j];
-        orderedEntries[j] = o;
-      }
-      
-      @Override
-      protected int compare(int i, int j) {
-        final int idx1 = orderedEntries[i], idx2 = orderedEntries[j];
-        return comp.compare(get(scratch1, idx1), get(scratch2, idx2));
-      }
-      
-      @Override
-      protected void setPivot(int i) {
-        final int index = orderedEntries[i];
-        get(pivot, index);
-      }
-      
-      @Override
-      protected int comparePivot(int j) {
-        final int index = orderedEntries[j];
-        return comp.compare(pivot, get(scratch2, index));
-      }
-      
-      private final BytesRef pivot = new BytesRef(), scratch1 = new BytesRef(),
-          scratch2 = new BytesRef();
-    }.sort(0, size());
-    return orderedEntries;
-  }
-  
-  /**
-   * sugar for {@link #iterator(Comparator)} with a <code>null</code> comparator
-   */
-  public BytesRefIterator iterator() {
-    return iterator(null);
-  }
-  
-  /**
-   * <p>
-   * Returns a {@link BytesRefIterator} with point in time semantics. The
-   * iterator provides access to all so far appended {@link BytesRef} instances.
-   * </p>
-   * <p>
-   * If a non <code>null</code> {@link Comparator} is provided the iterator will
-   * iterate the byte values in the order specified by the comparator. Otherwise
-   * the order is the same as the values were appended.
-   * </p>
-   * <p>
-   * This is a non-destructive operation.
-   * </p>
-   */
-  public BytesRefIterator iterator(final Comparator<BytesRef> comp) {
-    final BytesRef spare = new BytesRef();
-    final int size = size();
-    final int[] indices = comp == null ? null : sort(comp);
-    return new BytesRefIterator() {
-      int pos = 0;
-      
-      @Override
-      public BytesRef next() {
-        if (pos < size) {
-          return get(spare, indices == null ? pos++ : indices[pos++]);
-        }
-        return null;
-      }
-    };
-  }
-}
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/InMemorySorter.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/InMemorySorter.java
index 0efc3a5..42e19a8 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/InMemorySorter.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/InMemorySorter.java
@@ -21,6 +21,7 @@ import java.util.Comparator;
 
 import org.apache.lucene.search.suggest.fst.BytesRefSorter;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefArray;
 import org.apache.lucene.util.BytesRefIterator;
 import org.apache.lucene.util.Counter;
 
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/Sort.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/Sort.java
deleted file mode 100644
index 8c6c20f..0000000
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/Sort.java
+++ /dev/null
@@ -1,559 +0,0 @@
-package org.apache.lucene.search.suggest;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.*;
-import java.util.*;
-
-import org.apache.lucene.util.*;
-import org.apache.lucene.util.PriorityQueue;
-
-/**
- * On-disk sorting of byte arrays. Each byte array (entry) is a composed of the following
- * fields:
- * <ul>
- *   <li>(two bytes) length of the following byte array,
- *   <li>exactly the above count of bytes for the sequence to be sorted.
- * </ul>
- * 
- * @see #sort(File, File)
- * @lucene.experimental
- * @lucene.internal
- */
-public final class Sort {
-  /** Convenience constant for megabytes */
-  public final static long MB = 1024 * 1024;
-  /** Convenience constant for gigabytes */
-  public final static long GB = MB * 1024;
-  
-  /**
-   * Minimum recommended buffer size for sorting.
-   */
-  public final static long MIN_BUFFER_SIZE_MB = 32;
-
-  /**
-   * Absolute minimum required buffer size for sorting.
-   */
-  public static final long ABSOLUTE_MIN_SORT_BUFFER_SIZE = MB / 2;
-  private static final String MIN_BUFFER_SIZE_MSG = "At least 0.5MB RAM buffer is needed";
-
-  /**
-   * Maximum number of temporary files before doing an intermediate merge.
-   */
-  public final static int MAX_TEMPFILES = 128;
-
-  /** 
-   * A bit more descriptive unit for constructors.
-   * 
-   * @see #automatic()
-   * @see #megabytes(long)
-   */
-  public static final class BufferSize {
-    final int bytes;
-  
-    private BufferSize(long bytes) {
-      if (bytes > Integer.MAX_VALUE) {
-        throw new IllegalArgumentException("Buffer too large for Java ("
-            + (Integer.MAX_VALUE / MB) + "mb max): " + bytes);
-      }
-      
-      if (bytes < ABSOLUTE_MIN_SORT_BUFFER_SIZE) {
-        throw new IllegalArgumentException(MIN_BUFFER_SIZE_MSG + ": " + bytes);
-      }
-  
-      this.bytes = (int) bytes;
-    }
-    
-    /**
-     * Creates a {@link BufferSize} in MB. The given 
-     * values must be $gt; 0 and &lt; 2048.
-     */
-    public static BufferSize megabytes(long mb) {
-      return new BufferSize(mb * MB);
-    }
-  
-    /** 
-     * Approximately half of the currently available free heap, but no less
-     * than {@link #ABSOLUTE_MIN_SORT_BUFFER_SIZE}. However if current heap allocation 
-     * is insufficient or if there is a large portion of unallocated heap-space available 
-     * for sorting consult with max allowed heap size. 
-     */
-    public static BufferSize automatic() {
-      Runtime rt = Runtime.getRuntime();
-      
-      // take sizes in "conservative" order
-      final long max = rt.maxMemory(); // max allocated
-      final long total = rt.totalMemory(); // currently allocated
-      final long free = rt.freeMemory(); // unused portion of currently allocated
-      final long totalAvailableBytes = max - total + free;
-      
-      // by free mem (attempting to not grow the heap for this)
-      long sortBufferByteSize = free/2;
-      final long minBufferSizeBytes = MIN_BUFFER_SIZE_MB*MB;
-      if (sortBufferByteSize <  minBufferSizeBytes
-          || totalAvailableBytes > 10 * minBufferSizeBytes) { // lets see if we need/should to grow the heap 
-        if (totalAvailableBytes/2 > minBufferSizeBytes){ // there is enough mem for a reasonable buffer
-          sortBufferByteSize = totalAvailableBytes/2; // grow the heap
-        } else {
-          //heap seems smallish lets be conservative fall back to the free/2 
-          sortBufferByteSize = Math.max(ABSOLUTE_MIN_SORT_BUFFER_SIZE, sortBufferByteSize);
-        }
-      }
-      return new BufferSize(Math.min((long)Integer.MAX_VALUE, sortBufferByteSize));
-    }
-  }
-  
-  /**
-   * Sort info (debugging mostly).
-   */
-  public class SortInfo {
-    /** number of temporary files created when merging partitions */
-    public int tempMergeFiles;
-    /** number of partition merges */
-    public int mergeRounds;
-    /** number of lines of data read */
-    public int lines;
-    /** time spent merging sorted partitions (in milliseconds) */
-    public long mergeTime;
-    /** time spent sorting data (in milliseconds) */
-    public long sortTime;
-    /** total time spent (in milliseconds) */
-    public long totalTime;
-    /** time spent in i/o read (in milliseconds) */
-    public long readTime;
-    /** read buffer size (in bytes) */
-    public final long bufferSize = ramBufferSize.bytes;
-    
-    /** create a new SortInfo (with empty statistics) for debugging */
-    public SortInfo() {}
-    
-    @Override
-    public String toString() {
-      return String.format(Locale.ROOT,
-          "time=%.2f sec. total (%.2f reading, %.2f sorting, %.2f merging), lines=%d, temp files=%d, merges=%d, soft ram limit=%.2f MB",
-          totalTime / 1000.0d, readTime / 1000.0d, sortTime / 1000.0d, mergeTime / 1000.0d,
-          lines, tempMergeFiles, mergeRounds,
-          (double) bufferSize / MB);
-    }
-  }
-
-  private final BufferSize ramBufferSize;
-  private final File tempDirectory;
-  
-  private final Counter bufferBytesUsed = Counter.newCounter();
-  private final BytesRefArray buffer = new BytesRefArray(bufferBytesUsed);
-  private SortInfo sortInfo;
-  private int maxTempFiles;
-  private final Comparator<BytesRef> comparator;
-  
-  /** Default comparator: sorts in binary (codepoint) order */
-  public static final Comparator<BytesRef> DEFAULT_COMPARATOR = BytesRef.getUTF8SortedAsUnicodeComparator();
-
-  /**
-   * Defaults constructor.
-   * 
-   * @see #defaultTempDir()
-   * @see BufferSize#automatic()
-   */
-  public Sort() throws IOException {
-    this(DEFAULT_COMPARATOR, BufferSize.automatic(), defaultTempDir(), MAX_TEMPFILES);
-  }
-  
-  /**
-   * Defaults constructor with a custom comparator.
-   * 
-   * @see #defaultTempDir()
-   * @see BufferSize#automatic()
-   */
-  public Sort(Comparator<BytesRef> comparator) throws IOException {
-    this(comparator, BufferSize.automatic(), defaultTempDir(), MAX_TEMPFILES);
-  }
-
-  /**
-   * All-details constructor.
-   */
-  public Sort(Comparator<BytesRef> comparator, BufferSize ramBufferSize, File tempDirectory, int maxTempfiles) {
-    if (ramBufferSize.bytes < ABSOLUTE_MIN_SORT_BUFFER_SIZE) {
-      throw new IllegalArgumentException(MIN_BUFFER_SIZE_MSG + ": " + ramBufferSize.bytes);
-    }
-    
-    if (maxTempfiles < 2) {
-      throw new IllegalArgumentException("maxTempFiles must be >= 2");
-    }
-
-    this.ramBufferSize = ramBufferSize;
-    this.tempDirectory = tempDirectory;
-    this.maxTempFiles = maxTempfiles;
-    this.comparator = comparator;
-  }
-
-  /** 
-   * Sort input to output, explicit hint for the buffer size. The amount of allocated
-   * memory may deviate from the hint (may be smaller or larger).  
-   */
-  public SortInfo sort(File input, File output) throws IOException {
-    sortInfo = new SortInfo();
-    sortInfo.totalTime = System.currentTimeMillis();
-
-    output.delete();
-
-    ArrayList<File> merges = new ArrayList<File>();
-    boolean success2 = false;
-    try {
-      ByteSequencesReader is = new ByteSequencesReader(input);
-      boolean success = false;
-      try {
-        int lines = 0;
-        while ((lines = readPartition(is)) > 0) {
-          merges.add(sortPartition(lines));
-          sortInfo.tempMergeFiles++;
-          sortInfo.lines += lines;
-
-          // Handle intermediate merges.
-          if (merges.size() == maxTempFiles) {
-            File intermediate = File.createTempFile("sort", "intermediate", tempDirectory);
-            try {
-              mergePartitions(merges, intermediate);
-            } finally {
-              for (File file : merges) {
-                file.delete();
-              }
-              merges.clear();
-              merges.add(intermediate);
-            }
-            sortInfo.tempMergeFiles++;
-          }
-        }
-        success = true;
-      } finally {
-        if (success)
-          IOUtils.close(is);
-        else
-          IOUtils.closeWhileHandlingException(is);
-      }
-
-      // One partition, try to rename or copy if unsuccessful.
-      if (merges.size() == 1) {     
-        File single = merges.get(0);
-        // If simple rename doesn't work this means the output is
-        // on a different volume or something. Copy the input then.
-        if (!single.renameTo(output)) {
-          copy(single, output);
-        }
-      } else { 
-        // otherwise merge the partitions with a priority queue.
-        mergePartitions(merges, output);
-      }
-      success2 = true;
-    } finally {
-      for (File file : merges) {
-        file.delete();
-      }
-      if (!success2) {
-        output.delete();
-      }
-    }
-
-    sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); 
-    return sortInfo;
-  }
-
-  /**
-   * Returns the default temporary directory. By default, java.io.tmpdir. If not accessible
-   * or not available, an IOException is thrown
-   */
-  public static File defaultTempDir() throws IOException {
-    String tempDirPath = System.getProperty("java.io.tmpdir");
-    if (tempDirPath == null) 
-      throw new IOException("Java has no temporary folder property (java.io.tmpdir)?");
-
-    File tempDirectory = new File(tempDirPath);
-    if (!tempDirectory.exists() || !tempDirectory.canWrite()) {
-      throw new IOException("Java's temporary folder not present or writeable?: " 
-          + tempDirectory.getAbsolutePath());
-    }
-    return tempDirectory;
-  }
-
-  /**
-   * Copies one file to another.
-   */
-  private static void copy(File file, File output) throws IOException {
-    // 64kb copy buffer (empirical pick).
-    byte [] buffer = new byte [16 * 1024];
-    InputStream is = null;
-    OutputStream os = null;
-    try {
-      is = new FileInputStream(file);
-      os = new FileOutputStream(output);
-      int length;
-      while ((length = is.read(buffer)) > 0) {
-        os.write(buffer, 0, length);
-      }
-    } finally {
-      IOUtils.close(is, os);
-    }
-  }
-
-  /** Sort a single partition in-memory. */
-  protected File sortPartition(int len) throws IOException {
-    BytesRefArray data = this.buffer;
-    File tempFile = File.createTempFile("sort", "partition", tempDirectory);
-
-    long start = System.currentTimeMillis();
-    sortInfo.sortTime += (System.currentTimeMillis() - start);
-    
-    final ByteSequencesWriter out = new ByteSequencesWriter(tempFile);
-    BytesRef spare;
-    try {
-      BytesRefIterator iter = buffer.iterator(comparator);
-      while((spare = iter.next()) != null) {
-        assert spare.length <= Short.MAX_VALUE;
-        out.write(spare);
-      }
-      
-      out.close();
-
-      // Clean up the buffer for the next partition.
-      data.clear();
-      return tempFile;
-    } finally {
-      IOUtils.close(out);
-    }
-  }
-
-  /** Merge a list of sorted temporary files (partitions) into an output file */
-  void mergePartitions(List<File> merges, File outputFile) throws IOException {
-    long start = System.currentTimeMillis();
-
-    ByteSequencesWriter out = new ByteSequencesWriter(outputFile);
-
-    PriorityQueue<FileAndTop> queue = new PriorityQueue<FileAndTop>(merges.size()) {
-      @Override
-      protected boolean lessThan(FileAndTop a, FileAndTop b) {
-        return comparator.compare(a.current, b.current) < 0;
-      }
-    };
-
-    ByteSequencesReader [] streams = new ByteSequencesReader [merges.size()];
-    try {
-      // Open streams and read the top for each file
-      for (int i = 0; i < merges.size(); i++) {
-        streams[i] = new ByteSequencesReader(merges.get(i));
-        byte line[] = streams[i].read();
-        if (line != null) {
-          queue.insertWithOverflow(new FileAndTop(i, line));
-        }
-      }
-  
-      // Unix utility sort() uses ordered array of files to pick the next line from, updating
-      // it as it reads new lines. The PQ used here is a more elegant solution and has 
-      // a nicer theoretical complexity bound :) The entire sorting process is I/O bound anyway
-      // so it shouldn't make much of a difference (didn't check).
-      FileAndTop top;
-      while ((top = queue.top()) != null) {
-        out.write(top.current);
-        if (!streams[top.fd].read(top.current)) {
-          queue.pop();
-        } else {
-          queue.updateTop();
-        }
-      }
-  
-      sortInfo.mergeTime += System.currentTimeMillis() - start;
-      sortInfo.mergeRounds++;
-    } finally {
-      // The logic below is: if an exception occurs in closing out, it has a priority over exceptions
-      // happening in closing streams.
-      try {
-        IOUtils.close(streams);
-      } finally {
-        IOUtils.close(out);
-      }
-    }
-  }
-
-  /** Read in a single partition of data */
-  int readPartition(ByteSequencesReader reader) throws IOException {
-    long start = System.currentTimeMillis();
-    final BytesRef scratch = new BytesRef();
-    while ((scratch.bytes = reader.read()) != null) {
-      scratch.length = scratch.bytes.length; 
-      buffer.append(scratch);
-      // Account for the created objects.
-      // (buffer slots do not account to buffer size.) 
-      if (ramBufferSize.bytes < bufferBytesUsed.get()) {
-        break;
-      }
-    }
-    sortInfo.readTime += (System.currentTimeMillis() - start);
-    return buffer.size();
-  }
-
-  static class FileAndTop {
-    final int fd;
-    final BytesRef current;
-
-    FileAndTop(int fd, byte [] firstLine) {
-      this.fd = fd;
-      this.current = new BytesRef(firstLine);
-    }
-  }
-
-  /**
-   * Utility class to emit length-prefixed byte[] entries to an output stream for sorting.
-   * Complementary to {@link ByteSequencesReader}.
-   */
-  public static class ByteSequencesWriter implements Closeable {
-    private final DataOutput os;
-
-    /** Constructs a ByteSequencesWriter to the provided File */
-    public ByteSequencesWriter(File file) throws IOException {
-      this(new DataOutputStream(
-          new BufferedOutputStream(
-              new FileOutputStream(file))));
-    }
-
-    /** Constructs a ByteSequencesWriter to the provided DataOutput */
-    public ByteSequencesWriter(DataOutput os) {
-      this.os = os;
-    }
-
-    /**
-     * Writes a BytesRef.
-     * @see #write(byte[], int, int)
-     */
-    public void write(BytesRef ref) throws IOException {
-      assert ref != null;
-      write(ref.bytes, ref.offset, ref.length);
-    }
-
-    /**
-     * Writes a byte array.
-     * @see #write(byte[], int, int)
-     */
-    public void write(byte [] bytes) throws IOException {
-      write(bytes, 0, bytes.length);
-    }
-
-    /**
-     * Writes a byte array.
-     * <p>
-     * The length is written as a <code>short</code>, followed
-     * by the bytes.
-     */
-    public void write(byte [] bytes, int off, int len) throws IOException {
-      assert bytes != null;
-      assert off >= 0 && off + len <= bytes.length;
-      assert len >= 0;
-      os.writeShort(len);
-      os.write(bytes, off, len);
-    }        
-    
-    /**
-     * Closes the provided {@link DataOutput} if it is {@link Closeable}.
-     */
-    @Override
-    public void close() throws IOException {
-      if (os instanceof Closeable) {
-        ((Closeable) os).close();
-      }
-    }    
-  }
-
-  /**
-   * Utility class to read length-prefixed byte[] entries from an input.
-   * Complementary to {@link ByteSequencesWriter}.
-   */
-  public static class ByteSequencesReader implements Closeable {
-    private final DataInput is;
-
-    /** Constructs a ByteSequencesReader from the provided File */
-    public ByteSequencesReader(File file) throws IOException {
-      this(new DataInputStream(
-          new BufferedInputStream(
-              new FileInputStream(file))));
-    }
-
-    /** Constructs a ByteSequencesReader from the provided DataInput */
-    public ByteSequencesReader(DataInput is) {
-      this.is = is;
-    }
-
-    /**
-     * Reads the next entry into the provided {@link BytesRef}. The internal
-     * storage is resized if needed.
-     * 
-     * @return Returns <code>false</code> if EOF occurred when trying to read
-     * the header of the next sequence. Returns <code>true</code> otherwise.
-     * @throws EOFException if the file ends before the full sequence is read.
-     */
-    public boolean read(BytesRef ref) throws IOException {
-      short length;
-      try {
-        length = is.readShort();
-      } catch (EOFException e) {
-        return false;
-      }
-
-      ref.grow(length);
-      ref.offset = 0;
-      ref.length = length;
-      is.readFully(ref.bytes, 0, length);
-      return true;
-    }
-
-    /**
-     * Reads the next entry and returns it if successful.
-     * 
-     * @see #read(BytesRef)
-     * 
-     * @return Returns <code>null</code> if EOF occurred before the next entry
-     * could be read.
-     * @throws EOFException if the file ends before the full sequence is read.
-     */
-    public byte[] read() throws IOException {
-      short length;
-      try {
-        length = is.readShort();
-      } catch (EOFException e) {
-        return null;
-      }
-
-      assert length >= 0 : "Sanity: sequence length < 0: " + length;
-      byte [] result = new byte [length];
-      is.readFully(result);
-      return result;
-    }
-
-    /**
-     * Closes the provided {@link DataInput} if it is {@link Closeable}.
-     */
-    @Override
-    public void close() throws IOException {
-      if (is instanceof Closeable) {
-        ((Closeable) is).close();
-      }
-    }
-  }
-
-  /** Returns the comparator in use to sort entries */
-  public Comparator<BytesRef> getComparator() {
-    return comparator;
-  }  
-}
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator.java
index d804f38..d7011d4 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/SortedInputIterator.java
@@ -21,13 +21,14 @@ import java.io.File;
 import java.io.IOException;
 import java.util.Comparator;
 
-import org.apache.lucene.search.suggest.Sort.ByteSequencesReader;
-import org.apache.lucene.search.suggest.Sort.ByteSequencesWriter;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.OfflineSorter;
+import org.apache.lucene.util.OfflineSorter.ByteSequencesReader;
+import org.apache.lucene.util.OfflineSorter.ByteSequencesWriter;
 
 /**
  * This wrapper buffers incoming elements and makes sure they are sorted based on given comparator.
@@ -141,13 +142,13 @@ public class SortedInputIterator implements InputIterator {
     }
   };
   
-  private Sort.ByteSequencesReader sort() throws IOException {
+  private ByteSequencesReader sort() throws IOException {
     String prefix = getClass().getSimpleName();
-    File directory = Sort.defaultTempDir();
+    File directory = OfflineSorter.defaultTempDir();
     tempInput = File.createTempFile(prefix, ".input", directory);
     tempSorted = File.createTempFile(prefix, ".sorted", directory);
     
-    final Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);
+    final OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);
     boolean success = false;
     try {
       BytesRef spare;
@@ -158,8 +159,8 @@ public class SortedInputIterator implements InputIterator {
         encode(writer, output, buffer, spare, source.payload(), source.weight());
       }
       writer.close();
-      new Sort(tieBreakByCostComparator).sort(tempInput, tempSorted);
-      ByteSequencesReader reader = new Sort.ByteSequencesReader(tempSorted);
+      new OfflineSorter(tieBreakByCostComparator).sort(tempInput, tempSorted);
+      ByteSequencesReader reader = new OfflineSorter.ByteSequencesReader(tempSorted);
       success = true;
       return reader;
       
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
index 6b2c1f6..5dad351 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
@@ -31,7 +31,6 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.TokenStreamToAutomaton;
 import org.apache.lucene.search.suggest.InputIterator;
 import org.apache.lucene.search.suggest.Lookup;
-import org.apache.lucene.search.suggest.Sort;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.store.DataInput;
@@ -56,6 +55,7 @@ import org.apache.lucene.util.fst.PairOutputs;
 import org.apache.lucene.util.fst.PositiveIntOutputs;
 import org.apache.lucene.util.fst.Util.MinResult;
 import org.apache.lucene.util.fst.Util;
+import org.apache.lucene.util.OfflineSorter;
 
 /**
  * Suggester that first analyzes the surface form, adds the
@@ -380,14 +380,14 @@ public class AnalyzingSuggester extends Lookup {
   @Override
   public void build(InputIterator iterator) throws IOException {
     String prefix = getClass().getSimpleName();
-    File directory = Sort.defaultTempDir();
+    File directory = OfflineSorter.defaultTempDir();
     File tempInput = File.createTempFile(prefix, ".input", directory);
     File tempSorted = File.createTempFile(prefix, ".sorted", directory);
 
     hasPayloads = iterator.hasPayloads();
 
-    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);
-    Sort.ByteSequencesReader reader = null;
+    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);
+    OfflineSorter.ByteSequencesReader reader = null;
     BytesRef scratch = new BytesRef();
 
     TokenStreamToAutomaton ts2a = getTokenStreamToAutomaton();
@@ -463,12 +463,12 @@ public class AnalyzingSuggester extends Lookup {
       writer.close();
 
       // Sort all input/output pairs (required by FST.Builder):
-      new Sort(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);
+      new OfflineSorter(new AnalyzingComparator(hasPayloads)).sort(tempInput, tempSorted);
 
       // Free disk space:
       tempInput.delete();
 
-      reader = new Sort.ByteSequencesReader(tempSorted);
+      reader = new OfflineSorter.ByteSequencesReader(tempSorted);
      
       PairOutputs<Long,BytesRef> outputs = new PairOutputs<Long,BytesRef>(PositiveIntOutputs.getSingleton(), ByteSequenceOutputs.getSingleton());
       Builder<Pair<Long,BytesRef>> builder = new Builder<Pair<Long,BytesRef>>(FST.INPUT_TYPE.BYTE1, outputs);
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java
index db33247..f425235 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search.suggest.analyzing;
 // TODO
 //   - test w/ syns
 //   - add pruning of low-freq ngrams?
+
 import java.io.File;
 import java.io.IOException;
 //import java.io.PrintWriter;
@@ -54,7 +55,6 @@ import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.suggest.InputIterator;
 import org.apache.lucene.search.suggest.Lookup;
-import org.apache.lucene.search.suggest.Sort;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
@@ -74,6 +74,7 @@ import org.apache.lucene.util.fst.Outputs;
 import org.apache.lucene.util.fst.PositiveIntOutputs;
 import org.apache.lucene.util.fst.Util.MinResult;
 import org.apache.lucene.util.fst.Util;
+import org.apache.lucene.util.OfflineSorter;
 
 /**
  * Builds an ngram model from the text sent to {@link
@@ -287,7 +288,7 @@ public class FreeTextSuggester extends Lookup {
     }
 
     String prefix = getClass().getSimpleName();
-    File directory = Sort.defaultTempDir();
+    File directory = OfflineSorter.defaultTempDir();
     // TODO: messy ... java7 has Files.createTempDirectory
     // ... but 4.x is java6:
     File tempIndexPath = null;
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/ExternalRefSorter.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/ExternalRefSorter.java
index 0a06b86..8ceb937 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/ExternalRefSorter.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/ExternalRefSorter.java
@@ -17,14 +17,15 @@ package org.apache.lucene.search.suggest.fst;
  * limitations under the License.
  */
 
-import java.io.*;
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
 import java.util.Comparator;
 
-import org.apache.lucene.search.suggest.Sort;
-import org.apache.lucene.search.suggest.Sort.ByteSequencesReader;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefIterator;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.OfflineSorter;
 
 /**
  * Builds and iterates over sequences stored on disk.
@@ -32,19 +33,19 @@ import org.apache.lucene.util.IOUtils;
  * @lucene.internal
  */
 public class ExternalRefSorter implements BytesRefSorter, Closeable {
-  private final Sort sort;
-  private Sort.ByteSequencesWriter writer;
+  private final OfflineSorter sort;
+  private OfflineSorter.ByteSequencesWriter writer;
   private File input;
   private File sorted;
   
   /**
    * Will buffer all sequences to a temporary file and then sort (all on-disk).
    */
-  public ExternalRefSorter(Sort sort) throws IOException {
+  public ExternalRefSorter(OfflineSorter sort) throws IOException {
     this.sort = sort;
     this.input = File.createTempFile("RefSorter-", ".raw",
-        Sort.defaultTempDir());
-    this.writer = new Sort.ByteSequencesWriter(input);
+        OfflineSorter.defaultTempDir());
+    this.writer = new OfflineSorter.ByteSequencesWriter(input);
   }
   
   @Override
@@ -59,14 +60,14 @@ public class ExternalRefSorter implements BytesRefSorter, Closeable {
       closeWriter();
       
       sorted = File.createTempFile("RefSorter-", ".sorted",
-          Sort.defaultTempDir());
+          OfflineSorter.defaultTempDir());
       sort.sort(input, sorted);
       
       input.delete();
       input = null;
     }
     
-    return new ByteSequenceIterator(new Sort.ByteSequencesReader(sorted));
+    return new ByteSequenceIterator(new OfflineSorter.ByteSequencesReader(sorted));
   }
   
   private void closeWriter() throws IOException {
@@ -93,10 +94,10 @@ public class ExternalRefSorter implements BytesRefSorter, Closeable {
    * Iterate over byte refs in a file.
    */
   class ByteSequenceIterator implements BytesRefIterator {
-    private final ByteSequencesReader reader;
+    private final OfflineSorter.ByteSequencesReader reader;
     private BytesRef scratch = new BytesRef();
     
-    public ByteSequenceIterator(ByteSequencesReader reader) {
+    public ByteSequenceIterator(OfflineSorter.ByteSequencesReader reader) {
       this.reader = reader;
     }
     
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup.java
index 38132ca..704c1fb 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/FSTCompletionLookup.java
@@ -19,26 +19,27 @@ package org.apache.lucene.search.suggest.fst;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.search.suggest.InputIterator;
 import org.apache.lucene.search.suggest.Lookup;
-import org.apache.lucene.search.suggest.Sort.SortInfo;
-import org.apache.lucene.search.suggest.Sort;
 import org.apache.lucene.search.suggest.fst.FSTCompletion.Completion;
 import org.apache.lucene.search.suggest.tst.TSTLookup;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
-import org.apache.lucene.store.InputStreamDataInput;
-import org.apache.lucene.store.OutputStreamDataOutput;
-import org.apache.lucene.util.*;
 import org.apache.lucene.util.fst.FST;
 import org.apache.lucene.util.fst.NoOutputs;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.CharsRef;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.OfflineSorter;
+import org.apache.lucene.util.OfflineSorter.SortInfo;
+import org.apache.lucene.util.RamUsageEstimator;
+import org.apache.lucene.util.UnicodeUtil;
 
 /**
  * An adapter from {@link Lookup} API to {@link FSTCompletion}.
@@ -150,12 +151,12 @@ public class FSTCompletionLookup extends Lookup {
       throw new IllegalArgumentException("this suggester doesn't support payloads");
     }
     File tempInput = File.createTempFile(
-        FSTCompletionLookup.class.getSimpleName(), ".input", Sort.defaultTempDir());
+        FSTCompletionLookup.class.getSimpleName(), ".input", OfflineSorter.defaultTempDir());
     File tempSorted = File.createTempFile(
-        FSTCompletionLookup.class.getSimpleName(), ".sorted", Sort.defaultTempDir());
+        FSTCompletionLookup.class.getSimpleName(), ".sorted", OfflineSorter.defaultTempDir());
 
-    Sort.ByteSequencesWriter writer = new Sort.ByteSequencesWriter(tempInput);
-    Sort.ByteSequencesReader reader = null;
+    OfflineSorter.ByteSequencesWriter writer = new OfflineSorter.ByteSequencesWriter(tempInput);
+    OfflineSorter.ByteSequencesReader reader = null;
     ExternalRefSorter sorter = null;
 
     // Push floats up front before sequences to sort them. For now, assume they are non-negative.
@@ -180,13 +181,13 @@ public class FSTCompletionLookup extends Lookup {
 
       // We don't know the distribution of scores and we need to bucket them, so we'll sort
       // and divide into equal buckets.
-      SortInfo info = new Sort().sort(tempInput, tempSorted);
+      SortInfo info = new OfflineSorter().sort(tempInput, tempSorted);
       tempInput.delete();
       FSTCompletionBuilder builder = new FSTCompletionBuilder(
-          buckets, sorter = new ExternalRefSorter(new Sort()), sharedTailLength);
+          buckets, sorter = new ExternalRefSorter(new OfflineSorter()), sharedTailLength);
 
       final int inputLines = info.lines;
-      reader = new Sort.ByteSequencesReader(tempSorted);
+      reader = new OfflineSorter.ByteSequencesReader(tempSorted);
       long line = 0;
       int previousBucket = 0;
       int previousScore = 0;
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java
index ab66841..d654f18 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/fst/WFSTCompletionLookup.java
@@ -25,7 +25,6 @@ import java.util.List;
 
 import org.apache.lucene.search.suggest.InputIterator;
 import org.apache.lucene.search.suggest.Lookup;
-import org.apache.lucene.search.suggest.Sort.ByteSequencesWriter;
 import org.apache.lucene.search.suggest.SortedInputIterator;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ByteArrayDataOutput;
@@ -43,6 +42,7 @@ import org.apache.lucene.util.fst.FST;
 import org.apache.lucene.util.fst.PositiveIntOutputs;
 import org.apache.lucene.util.fst.Util.MinResult;
 import org.apache.lucene.util.fst.Util;
+import org.apache.lucene.util.OfflineSorter.ByteSequencesWriter;
 
 /**
  * Suggester based on a weighted FST: it first traverses the prefix, 
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestBytesRefArray.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestBytesRefArray.java
deleted file mode 100644
index 935b71b..0000000
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/TestBytesRefArray.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.apache.lucene.search.suggest;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-import java.io.IOException;
-import java.util.*;
-
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.BytesRefIterator;
-import org.apache.lucene.util.Counter;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-
-public class TestBytesRefArray extends LuceneTestCase {
-
-  public void testAppend() throws IOException {
-    Random random = random();
-    BytesRefArray list = new BytesRefArray(Counter.newCounter());
-    List<String> stringList = new ArrayList<String>();
-    for (int j = 0; j < 2; j++) {
-      if (j > 0 && random.nextBoolean()) {
-        list.clear();
-        stringList.clear();
-      }
-      int entries = atLeast(500);
-      BytesRef spare = new BytesRef();
-      int initSize = list.size();
-      for (int i = 0; i < entries; i++) {
-        String randomRealisticUnicodeString = TestUtil
-            .randomRealisticUnicodeString(random);
-        spare.copyChars(randomRealisticUnicodeString);
-        assertEquals(i+initSize, list.append(spare));
-        stringList.add(randomRealisticUnicodeString);
-      }
-      for (int i = 0; i < entries; i++) {
-        assertNotNull(list.get(spare, i));
-        assertEquals("entry " + i + " doesn't match", stringList.get(i),
-            spare.utf8ToString());
-      }
-      
-      // check random
-      for (int i = 0; i < entries; i++) {
-        int e = random.nextInt(entries);
-        assertNotNull(list.get(spare, e));
-        assertEquals("entry " + i + " doesn't match", stringList.get(e),
-            spare.utf8ToString());
-      }
-      for (int i = 0; i < 2; i++) {
-        
-        BytesRefIterator iterator = list.iterator();
-        for (String string : stringList) {
-          assertEquals(string, iterator.next().utf8ToString());
-        }
-      }
-    }
-  }
-
-  public void testSort() throws IOException {
-    Random random = random();
-    BytesRefArray list = new BytesRefArray(Counter.newCounter());
-    List<String> stringList = new ArrayList<String>();
-
-    for (int j = 0; j < 2; j++) {
-      if (j > 0 && random.nextBoolean()) {
-        list.clear();
-        stringList.clear();
-      }
-      int entries = atLeast(500);
-      BytesRef spare = new BytesRef();
-      final int initSize = list.size();
-      for (int i = 0; i < entries; i++) {
-        String randomRealisticUnicodeString = TestUtil
-            .randomRealisticUnicodeString(random);
-        spare.copyChars(randomRealisticUnicodeString);
-        assertEquals(initSize + i, list.append(spare));
-        stringList.add(randomRealisticUnicodeString);
-      }
-      
-      Collections.sort(stringList);
-      BytesRefIterator iter = list.iterator(BytesRef
-          .getUTF8SortedAsUTF16Comparator());
-      int i = 0;
-      while ((spare = iter.next()) != null) {
-        assertEquals("entry " + i + " doesn't match", stringList.get(i),
-            spare.utf8ToString());
-        i++;
-      }
-      assertNull(iter.next());
-      assertEquals(i, stringList.size());
-    }
-    
-  }
-  
-}
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/BytesRefSortersTest.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/BytesRefSortersTest.java
index f8ccd35..8277589 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/BytesRefSortersTest.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/BytesRefSortersTest.java
@@ -18,16 +18,16 @@ package org.apache.lucene.search.suggest.fst;
  */
 
 import org.apache.lucene.search.suggest.InMemorySorter;
-import org.apache.lucene.search.suggest.Sort;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefIterator;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.OfflineSorter;
 import org.junit.Test;
 
 public class BytesRefSortersTest extends LuceneTestCase {
   @Test
   public void testExternalRefSorter() throws Exception {
-    ExternalRefSorter s = new ExternalRefSorter(new Sort());
+    ExternalRefSorter s = new ExternalRefSorter(new OfflineSorter());
     check(s);
     s.close();
   }
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/LargeInputFST.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/LargeInputFST.java
index 48a1409..0cb6c66 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/LargeInputFST.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/LargeInputFST.java
@@ -17,10 +17,15 @@ package org.apache.lucene.search.suggest.fst;
  * limitations under the License.
  */
 
-import java.io.*;
 
-import org.apache.lucene.search.suggest.Sort;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.OfflineSorter;
 
 /**
  * Try to build a suggester from a large data set. The input is a simple text
@@ -33,7 +38,7 @@ public class LargeInputFST {
     int buckets = 20;
     int shareMaxTail = 10;
 
-    ExternalRefSorter sorter = new ExternalRefSorter(new Sort());
+    ExternalRefSorter sorter = new ExternalRefSorter(new OfflineSorter());
     FSTCompletionBuilder builder = new FSTCompletionBuilder(buckets, sorter, shareMaxTail);
 
     BufferedReader reader = new BufferedReader(
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/TestSort.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/TestSort.java
deleted file mode 100644
index 540fade..0000000
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/fst/TestSort.java
+++ /dev/null
@@ -1,184 +0,0 @@
-package org.apache.lucene.search.suggest.fst;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-
-import org.apache.lucene.search.suggest.Sort;
-import org.apache.lucene.search.suggest.Sort.BufferSize;
-import org.apache.lucene.search.suggest.Sort.ByteSequencesWriter;
-import org.apache.lucene.search.suggest.Sort.SortInfo;
-import org.apache.lucene.util.*;
-import org.junit.*;
-
-/**
- * Tests for on-disk merge sorting.
- */
-public class TestSort extends LuceneTestCase {
-  private File tempDir;
-
-  @Before
-  public void prepareTempDir() throws IOException {
-    tempDir = TestUtil.getTempDir("mergesort");
-    TestUtil.rmDir(tempDir);
-    tempDir.mkdirs();
-  }
-  
-  @After
-  public void cleanup() throws IOException {
-    if (tempDir != null)
-      TestUtil.rmDir(tempDir);
-  }
-
-  @Test
-  public void testEmpty() throws Exception {
-    checkSort(new Sort(), new byte [][] {});
-  }
-
-  @Test
-  public void testSingleLine() throws Exception {
-    checkSort(new Sort(), new byte [][] {
-        "Single line only.".getBytes("UTF-8")
-    });
-  }
-
-  @Test
-  public void testIntermediateMerges() throws Exception {
-    // Sort 20 mb worth of data with 1mb buffer, binary merging.
-    SortInfo info = checkSort(new Sort(Sort.DEFAULT_COMPARATOR, BufferSize.megabytes(1), Sort.defaultTempDir(), 2), 
-        generateRandom((int)Sort.MB * 20));
-    assertTrue(info.mergeRounds > 10);
-  }
-
-  @Test
-  public void testSmallRandom() throws Exception {
-    // Sort 20 mb worth of data with 1mb buffer.
-    SortInfo sortInfo = checkSort(new Sort(Sort.DEFAULT_COMPARATOR, BufferSize.megabytes(1), Sort.defaultTempDir(), Sort.MAX_TEMPFILES), 
-        generateRandom((int)Sort.MB * 20));
-    assertEquals(1, sortInfo.mergeRounds);
-  }
-
-  @Test @Nightly
-  public void testLargerRandom() throws Exception {
-    // Sort 100MB worth of data with 15mb buffer.
-    checkSort(new Sort(Sort.DEFAULT_COMPARATOR, BufferSize.megabytes(16), Sort.defaultTempDir(), Sort.MAX_TEMPFILES), 
-        generateRandom((int)Sort.MB * 100));
-  }
-
-  private byte[][] generateRandom(int howMuchData) {
-    ArrayList<byte[]> data = new ArrayList<byte[]>(); 
-    while (howMuchData > 0) {
-      byte [] current = new byte [random().nextInt(256)];
-      random().nextBytes(current);
-      data.add(current);
-      howMuchData -= current.length;
-    }
-    byte [][] bytes = data.toArray(new byte[data.size()][]);
-    return bytes;
-  }
-  
-  static final Comparator<byte[]> unsignedByteOrderComparator = new Comparator<byte[]>() {
-    @Override
-    public int compare(byte[] left, byte[] right) {
-      final int max = Math.min(left.length, right.length);
-      for (int i = 0, j = 0; i < max; i++, j++) {
-        int diff = (left[i]  & 0xff) - (right[j] & 0xff); 
-        if (diff != 0) 
-          return diff;
-      }
-      return left.length - right.length;
-    }
-  };
-  /**
-   * Check sorting data on an instance of {@link Sort}.
-   */
-  private SortInfo checkSort(Sort sort, byte[][] data) throws IOException {
-    File unsorted = writeAll("unsorted", data);
-
-    Arrays.sort(data, unsignedByteOrderComparator);
-    File golden = writeAll("golden", data);
-
-    File sorted = new File(tempDir, "sorted");
-    SortInfo sortInfo = sort.sort(unsorted, sorted);
-    //System.out.println("Input size [MB]: " + unsorted.length() / (1024 * 1024));
-    //System.out.println(sortInfo);
-
-    assertFilesIdentical(golden, sorted);
-    return sortInfo;
-  }
-
-  /**
-   * Make sure two files are byte-byte identical.
-   */
-  private void assertFilesIdentical(File golden, File sorted) throws IOException {
-    assertEquals(golden.length(), sorted.length());
-
-    byte [] buf1 = new byte [64 * 1024];
-    byte [] buf2 = new byte [64 * 1024];
-    int len;
-    DataInputStream is1 = new DataInputStream(new FileInputStream(golden));
-    DataInputStream is2 = new DataInputStream(new FileInputStream(sorted));
-    while ((len = is1.read(buf1)) > 0) {
-      is2.readFully(buf2, 0, len);
-      for (int i = 0; i < len; i++) {
-        assertEquals(buf1[i], buf2[i]);
-      }
-    }
-    IOUtils.close(is1, is2);
-  }
-
-  private File writeAll(String name, byte[][] data) throws IOException {
-    File file = new File(tempDir, name);
-    ByteSequencesWriter w = new Sort.ByteSequencesWriter(file);
-    for (byte [] datum : data) {
-      w.write(datum);
-    }
-    w.close();
-    return file;
-  }
-  
-  public void testRamBuffer() {
-    int numIters = atLeast(10000);
-    for (int i = 0; i < numIters; i++) {
-      BufferSize.megabytes(1+random().nextInt(2047));
-    }
-    BufferSize.megabytes(2047);
-    BufferSize.megabytes(1);
-    
-    try {
-      BufferSize.megabytes(2048);
-      fail("max mb is 2047");
-    } catch (IllegalArgumentException e) {
-    }
-    
-    try {
-      BufferSize.megabytes(0);
-      fail("min mb is 0.5");
-    } catch (IllegalArgumentException e) {
-    }
-    
-    try {
-      BufferSize.megabytes(-1);
-      fail("min mb is 0.5");
-    } catch (IllegalArgumentException e) {
-    }
-  }
-}

