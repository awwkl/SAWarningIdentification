GitDiffStart: 00f4efde1fe23f1190e322adb20b8065c591e5d6 | Tue Oct 27 22:29:41 2009 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 2cdee08..684682e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -125,6 +125,9 @@ API Changes
 * LUCENE-1973: Un-deprecate IndexSearcher.setDefaultFieldSortScoring,
   to allow controlling per-IndexSearcher whether scores are computed
   when sorting by field.  (Uwe Schindler, Mike McCandless)
+  
+* LUCENE-2011: Remove deprecated Scorer.explain(int).
+  (Uwe Schindler, Mark Miller)
    
 Bug fixes
 
diff --git a/common-build.xml b/common-build.xml
index fcf8261..5944591 100644
--- a/common-build.xml
+++ b/common-build.xml
@@ -42,7 +42,7 @@
   <property name="Name" value="Lucene"/>
   <property name="dev.version" value="3.0-dev"/>
   <property name="version" value="${dev.version}"/>
-  <property name="compatibility.tag" value="lucene_2_9_back_compat_tests_20091023a"/>
+  <property name="compatibility.tag" value="lucene_2_9_back_compat_tests_20091027"/>
   <property name="spec.version" value="${version}"/>	
   <property name="year" value="2000-${current.year}"/>
   <property name="final.name" value="lucene-${name}-${version}"/>
diff --git a/src/java/org/apache/lucene/search/BooleanScorer.java b/src/java/org/apache/lucene/search/BooleanScorer.java
index cdfc637..cb1c1b7 100644
--- a/src/java/org/apache/lucene/search/BooleanScorer.java
+++ b/src/java/org/apache/lucene/search/BooleanScorer.java
@@ -66,6 +66,8 @@ final class BooleanScorer extends Scorer {
       this.mask = mask;
       this.bucketTable = bucketTable;
     }
+    
+    @Override
     public final void collect(final int doc) throws IOException {
       final BucketTable table = bucketTable;
       final int i = doc & BucketTable.MASK;
@@ -88,14 +90,17 @@ final class BooleanScorer extends Scorer {
       }
     }
     
+    @Override
     public void setNextReader(IndexReader reader, int docBase) {
       // not needed by this implementation
     }
     
+    @Override
     public void setScorer(Scorer scorer) throws IOException {
       this.scorer = scorer;
     }
     
+    @Override
     public boolean acceptsDocsOutOfOrder() {
       return true;
     }
@@ -113,14 +118,16 @@ final class BooleanScorer extends Scorer {
     
     public BucketScorer() { super(null); }
     
+    @Override
     public int advance(int target) throws IOException { return NO_MORE_DOCS; }
 
+    @Override
     public int docID() { return doc; }
 
-    public Explanation explain(int doc) throws IOException { return null; }
-    
+    @Override
     public int nextDoc() throws IOException { return NO_MORE_DOCS; }
     
+    @Override
     public float score() throws IOException { return score; }
     
   }
@@ -213,6 +220,7 @@ final class BooleanScorer extends Scorer {
   }
 
   // firstDocID is ignored since nextDoc() initializes 'current'
+  @Override
   protected boolean score(Collector collector, int max, int firstDocID) throws IOException {
     boolean more;
     Bucket tmp;
@@ -268,18 +276,17 @@ final class BooleanScorer extends Scorer {
     return false;
   }
   
+  @Override
   public int advance(int target) throws IOException {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int docID() {
     return doc;
   }
 
-  public Explanation explain(int doc) {
-    throw new UnsupportedOperationException();
-  }
-
+  @Override
   public int nextDoc() throws IOException {
     boolean more;
     do {
@@ -313,14 +320,17 @@ final class BooleanScorer extends Scorer {
     return doc = NO_MORE_DOCS;
   }
 
+  @Override
   public float score() {
     return current.score * coordFactors[current.coord];
   }
 
+  @Override
   public void score(Collector collector) throws IOException {
     score(collector, Integer.MAX_VALUE, nextDoc());
   }
   
+  @Override
   public String toString() {
     StringBuilder buffer = new StringBuilder();
     buffer.append("boolean(");
diff --git a/src/java/org/apache/lucene/search/BooleanScorer2.java b/src/java/org/apache/lucene/search/BooleanScorer2.java
index d2f1c41..6a3ab2c 100644
--- a/src/java/org/apache/lucene/search/BooleanScorer2.java
+++ b/src/java/org/apache/lucene/search/BooleanScorer2.java
@@ -113,6 +113,8 @@ class BooleanScorer2 extends Scorer {
       super(scorer.getSimilarity());
       this.scorer = scorer;
     }
+
+    @Override
     public float score() throws IOException {
       int doc = docID();
       if (doc >= lastScoredDoc) {
@@ -124,18 +126,21 @@ class BooleanScorer2 extends Scorer {
       }
       return lastDocScore;
     }
+
+    @Override
     public int docID() {
       return scorer.docID();
     }
+
+    @Override
     public int nextDoc() throws IOException {
       return scorer.nextDoc();
     }
+
+    @Override
     public int advance(int target) throws IOException {
       return scorer.advance(target);
     }
-    public Explanation explain(int docNr) throws IOException {
-      return scorer.explain(docNr);
-    }
   }
 
   private Scorer countingDisjunctionSumScorer(final List<Scorer> scorers,
@@ -146,7 +151,7 @@ class BooleanScorer2 extends Scorer {
       // Save the score of lastScoredDoc, so that we don't compute it more than
       // once in score().
       private float lastDocScore = Float.NaN;
-      public float score() throws IOException {
+      @Override public float score() throws IOException {
         int doc = docID();
         if (doc >= lastScoredDoc) {
           if (doc > lastScoredDoc) {
@@ -170,7 +175,7 @@ class BooleanScorer2 extends Scorer {
       // Save the score of lastScoredDoc, so that we don't compute it more than
       // once in score().
       private float lastDocScore = Float.NaN;
-      public float score() throws IOException {
+      @Override public float score() throws IOException {
         int doc = docID();
         if (doc >= lastScoredDoc) {
           if (doc > lastScoredDoc) {
@@ -262,8 +267,8 @@ class BooleanScorer2 extends Scorer {
 
   /** Scores and collects all matching documents.
    * @param collector The collector to which all matching documents are passed through.
-   * <br>When this method is used the {@link #explain(int)} method should not be used.
    */
+  @Override
   public void score(Collector collector) throws IOException {
     collector.setScorer(this);
     while ((doc = countingSumScorer.nextDoc()) != NO_MORE_DOCS) {
@@ -271,6 +276,7 @@ class BooleanScorer2 extends Scorer {
     }
   }
   
+  @Override
   protected boolean score(Collector collector, int max, int firstDocID) throws IOException {
     doc = firstDocID;
     collector.setScorer(this);
@@ -281,36 +287,27 @@ class BooleanScorer2 extends Scorer {
     return doc != NO_MORE_DOCS;
   }
 
+  @Override
   public int docID() {
     return doc;
   }
   
+  @Override
   public int nextDoc() throws IOException {
     return doc = countingSumScorer.nextDoc();
   }
   
+  @Override
   public float score() throws IOException {
     coordinator.nrMatchers = 0;
     float sum = countingSumScorer.score();
     return sum * coordinator.coordFactors[coordinator.nrMatchers];
   }
 
+  @Override
   public int advance(int target) throws IOException {
     return doc = countingSumScorer.advance(target);
   }
-  
-  /** Throws an UnsupportedOperationException.
-   * TODO: Implement an explanation of the coordination factor.
-   * @param doc The document number for the explanation.
-   * @throws UnsupportedOperationException
-   */
-  public Explanation explain(int doc) {
-    throw new UnsupportedOperationException();
- /* How to explain the coordination factor?
-    initCountingSumScorer();
-    return countingSumScorer.explain(doc); // misses coord factor. 
-  */
-  }
 }
 
 
diff --git a/src/java/org/apache/lucene/search/ConjunctionScorer.java b/src/java/org/apache/lucene/search/ConjunctionScorer.java
index 256ea9d..e30e5dc 100644
--- a/src/java/org/apache/lucene/search/ConjunctionScorer.java
+++ b/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -100,6 +100,7 @@ class ConjunctionScorer extends Scorer {
     return doc;
   }
   
+  @Override
   public int advance(int target) throws IOException {
     if (lastDoc == NO_MORE_DOCS) {
       return lastDoc;
@@ -109,14 +110,12 @@ class ConjunctionScorer extends Scorer {
     return lastDoc = doNext();
   }
 
+  @Override
   public int docID() {
     return lastDoc;
   }
   
-  public Explanation explain(int doc) {
-    throw new UnsupportedOperationException();
-  }
-
+  @Override
   public int nextDoc() throws IOException {
     if (lastDoc == NO_MORE_DOCS) {
       return lastDoc;
@@ -127,6 +126,7 @@ class ConjunctionScorer extends Scorer {
     return lastDoc = doNext();
   }
   
+  @Override
   public float score() throws IOException {
     float sum = 0.0f;
     for (int i = 0; i < scorers.length; i++) {
diff --git a/src/java/org/apache/lucene/search/ConstantScoreQuery.java b/src/java/org/apache/lucene/search/ConstantScoreQuery.java
index 84874e9..3f2ade7 100644
--- a/src/java/org/apache/lucene/search/ConstantScoreQuery.java
+++ b/src/java/org/apache/lucene/search/ConstantScoreQuery.java
@@ -39,10 +39,12 @@ public class ConstantScoreQuery extends Query {
     return filter;
   }
 
+  @Override
   public Query rewrite(IndexReader reader) throws IOException {
     return this;
   }
 
+  @Override
   public void extractTerms(Set<Term> terms) {
     // OK to not add any terms when used for MultiSearcher,
     // but may not be OK for highlighting
@@ -57,28 +59,34 @@ public class ConstantScoreQuery extends Query {
       this.similarity = getSimilarity(searcher);
     }
 
+    @Override
     public Query getQuery() {
       return ConstantScoreQuery.this;
     }
 
+    @Override
     public float getValue() {
       return queryWeight;
     }
 
+    @Override
     public float sumOfSquaredWeights() throws IOException {
       queryWeight = getBoost();
       return queryWeight * queryWeight;
     }
 
+    @Override
     public void normalize(float norm) {
       this.queryNorm = norm;
       queryWeight *= this.queryNorm;
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       return new ConstantScorer(similarity, reader, this);
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc) throws IOException {
       
       ConstantScorer cs = new ConstantScorer(similarity, reader, this);
@@ -124,38 +132,41 @@ public class ConstantScoreQuery extends Query {
       }
     }
 
+    @Override
     public int nextDoc() throws IOException {
       return docIdSetIterator.nextDoc();
     }
     
+    @Override
     public int docID() {
       return docIdSetIterator.docID();
     }
 
+    @Override
     public float score() throws IOException {
       return theScore;
     }
 
+    @Override
     public int advance(int target) throws IOException {
       return docIdSetIterator.advance(target);
     }
-    
-    public Explanation explain(int doc) throws IOException {
-      throw new UnsupportedOperationException();
-    }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) {
     return new ConstantScoreQuery.ConstantWeight(searcher);
   }
 
   /** Prints a user-readable version of this query. */
+  @Override
   public String toString(String field) {
     return "ConstantScore(" + filter.toString()
       + (getBoost()==1.0 ? ")" : "^" + getBoost());
   }
 
   /** Returns true if <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (this == o) return true;
     if (!(o instanceof ConstantScoreQuery)) return false;
@@ -164,6 +175,7 @@ public class ConstantScoreQuery extends Query {
   }
 
   /** Returns a hash code value for this object. */
+  @Override
   public int hashCode() {
     // Simple add is OK since no existing filter hashcode has a float component.
     return filter.hashCode() + Float.floatToIntBits(getBoost());
diff --git a/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java b/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
index 7d3d556..a870e92 100644
--- a/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
+++ b/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
@@ -62,6 +62,7 @@ class DisjunctionMaxScorer extends Scorer {
     heapify();
   }
 
+  @Override
   public int nextDoc() throws IOException {
     if (numScorers == 0) return doc = NO_MORE_DOCS;
     while (subScorers[0].docID() == doc) {
@@ -78,6 +79,7 @@ class DisjunctionMaxScorer extends Scorer {
     return doc = subScorers[0].docID();
   }
 
+  @Override
   public int docID() {
     return doc;
   }
@@ -85,6 +87,7 @@ class DisjunctionMaxScorer extends Scorer {
   /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
    * @return the score of the current generated document
    */
+  @Override
   public float score() throws IOException {
     int doc = subScorers[0].docID();
     float[] sum = { subScorers[0].score() }, max = { sum[0] };
@@ -105,6 +108,7 @@ class DisjunctionMaxScorer extends Scorer {
     }
   }
 
+  @Override
   public int advance(int target) throws IOException {
     if (numScorers == 0) return doc = NO_MORE_DOCS;
     while (subScorers[0].docID() < target) {
@@ -120,14 +124,6 @@ class DisjunctionMaxScorer extends Scorer {
     return doc = subScorers[0].docID();
   }
 
-  /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.
-   * @param doc the number of a document we scored
-   * @return the Explanation for our score
-   */
-  public Explanation explain(int doc) throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
   // Organize subScorers into a min heap with scorers generating the earliest document on top.
   private void heapify() {
     for (int i = (numScorers >> 1) - 1; i >= 0; i--) {
diff --git a/src/java/org/apache/lucene/search/DisjunctionSumScorer.java b/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
index c30e7b8..f2c0656 100644
--- a/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
+++ b/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
@@ -106,7 +106,6 @@ class DisjunctionSumScorer extends Scorer {
 
   /** Scores and collects all matching documents.
    * @param collector The collector to which all matching documents are passed through.
-   * <br>When this method is used the {@link #explain(int)} method should not be used.
    */
   @Override
   public void score(Collector collector) throws IOException {
@@ -209,8 +208,6 @@ class DisjunctionSumScorer extends Scorer {
   /**
    * Advances to the first match beyond the current whose document number is
    * greater than or equal to a given target. <br>
-   * When this method is used the {@link #explain(int)} method should not be
-   * used. <br>
    * The implementation uses the skipTo() method on the subscorers.
    * 
    * @param target
@@ -236,31 +233,4 @@ class DisjunctionSumScorer extends Scorer {
       }
     } while (true);
   }
-  
-  /** @return An explanation for the score of a given document. */
-  @Override
-  public Explanation explain(int doc) throws IOException {
-    Explanation res = new Explanation();
-    float sumScore = 0.0f;
-    int nrMatches = 0;
-    for (Scorer se : subScorers) {
-      Explanation es = se.explain(doc);
-      if (es.getValue() > 0.0f) { // indicates match
-        sumScore += es.getValue();
-        nrMatches++;
-      }
-      res.addDetail(es);
-    }
-    if (nrMatchers >= minimumNrMatchers) {
-      res.setValue(sumScore);
-      res.setDescription("sum over at least " + minimumNrMatchers
-                         + " of " + subScorers.size() + ":");
-    } else {
-      res.setValue(0.0f);
-      res.setDescription(nrMatches + " match(es) but at least "
-                         + minimumNrMatchers + " of "
-                         + subScorers.size() + " needed");
-    }
-    return res;
-  }
 }
diff --git a/src/java/org/apache/lucene/search/FilteredQuery.java b/src/java/org/apache/lucene/search/FilteredQuery.java
index 2b814b3..1884135 100644
--- a/src/java/org/apache/lucene/search/FilteredQuery.java
+++ b/src/java/org/apache/lucene/search/FilteredQuery.java
@@ -65,14 +65,21 @@ extends Query {
       private float value;
         
       // pass these methods through to enclosed query's weight
+      @Override
       public float getValue() { return value; }
+      
+      @Override
       public float sumOfSquaredWeights() throws IOException { 
         return weight.sumOfSquaredWeights() * getBoost() * getBoost(); 
       }
+
+      @Override
       public void normalize (float v) { 
         weight.normalize(v);
         value = weight.getValue() * getBoost();
       }
+
+      @Override
       public Explanation explain (IndexReader ir, int i) throws IOException {
         Explanation inner = weight.explain (ir, i);
         if (getBoost()!=1) {
@@ -98,9 +105,11 @@ extends Query {
       }
 
       // return this query
+      @Override
       public Query getQuery() { return FilteredQuery.this; }
 
       // return a filtering scorer
+      @Override
       public Scorer scorer(IndexReader indexReader, boolean scoreDocsInOrder, boolean topScorer)
           throws IOException {
         final Scorer scorer = weight.scorer(indexReader, true, false);
@@ -131,6 +140,7 @@ extends Query {
             return scorerDoc;
           }
 
+          @Override
           public int nextDoc() throws IOException {
             int scorerDoc, disiDoc;
             return doc = (disiDoc = docIdSetIterator.nextDoc()) != NO_MORE_DOCS
@@ -138,8 +148,10 @@ extends Query {
                 && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;
           }
           
+          @Override
           public int docID() { return doc; }
           
+          @Override
           public int advance(int target) throws IOException {
             int disiDoc, scorerDoc;
             return doc = (disiDoc = docIdSetIterator.advance(target)) != NO_MORE_DOCS
@@ -147,27 +159,15 @@ extends Query {
                 && advanceToCommon(scorerDoc, disiDoc) != NO_MORE_DOCS ? scorer.docID() : NO_MORE_DOCS;
           }
 
+          @Override
           public float score() throws IOException { return getBoost() * scorer.score(); }
-
-          // add an explanation about whether the document was filtered
-          public Explanation explain (int i) throws IOException {
-            Explanation exp = scorer.explain(i);
-            
-            if (docIdSetIterator.advance(i) == i) {
-              exp.setDescription ("allowed by filter: "+exp.getDescription());
-              exp.setValue(getBoost() * exp.getValue());
-            } else {
-              exp.setDescription ("removed by filter: "+exp.getDescription());
-              exp.setValue(0.0f);
-            }
-            return exp;
-          }
         };
       }
     };
   }
 
   /** Rewrites the wrapped query. */
+  @Override
   public Query rewrite(IndexReader reader) throws IOException {
     Query rewritten = query.rewrite(reader);
     if (rewritten != query) {
@@ -188,11 +188,13 @@ extends Query {
   }
 
   // inherit javadoc
+  @Override
   public void extractTerms(Set<Term> terms) {
       getQuery().extractTerms(terms);
   }
 
   /** Prints a user-readable version of this query. */
+  @Override
   public String toString (String s) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("filtered(");
@@ -204,6 +206,7 @@ extends Query {
   }
 
   /** Returns true iff <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (o instanceof FilteredQuery) {
       FilteredQuery fq = (FilteredQuery) o;
@@ -213,6 +216,7 @@ extends Query {
   }
 
   /** Returns a hash code value for this object. */
+  @Override
   public int hashCode() {
     return query.hashCode() ^ filter.hashCode() + Float.floatToRawIntBits(getBoost());
   }
diff --git a/src/java/org/apache/lucene/search/MatchAllDocsQuery.java b/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
index cc8957a..25323bc 100644
--- a/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
+++ b/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
@@ -58,22 +58,22 @@ public class MatchAllDocsQuery extends Query {
       this.norms = norms;
     }
 
-    public Explanation explain(int doc) {
-      return null; // not called... see MatchAllDocsWeight.explain()
-    }
-
+    @Override
     public int docID() {
       return doc;
     }
 
+    @Override
     public int nextDoc() throws IOException {
       return doc = termDocs.next() ? termDocs.doc() : NO_MORE_DOCS;
     }
     
+    @Override
     public float score() {
       return norms == null ? score : score * Similarity.decodeNorm(norms[docID()]);
     }
 
+    @Override
     public int advance(int target) throws IOException {
       return doc = termDocs.skipTo(target) ? termDocs.doc() : NO_MORE_DOCS;
     }
@@ -88,33 +88,40 @@ public class MatchAllDocsQuery extends Query {
       this.similarity = searcher.getSimilarity();
     }
 
+    @Override
     public String toString() {
       return "weight(" + MatchAllDocsQuery.this + ")";
     }
 
+    @Override
     public Query getQuery() {
       return MatchAllDocsQuery.this;
     }
 
+    @Override
     public float getValue() {
       return queryWeight;
     }
 
+    @Override
     public float sumOfSquaredWeights() {
       queryWeight = getBoost();
       return queryWeight * queryWeight;
     }
 
+    @Override
     public void normalize(float queryNorm) {
       this.queryNorm = queryNorm;
       queryWeight *= this.queryNorm;
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       return new MatchAllScorer(reader, similarity, this,
           normsField != null ? reader.norms(normsField) : null);
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc) {
       // explain query weight
       Explanation queryExpl = new ComplexExplanation
@@ -128,13 +135,16 @@ public class MatchAllDocsQuery extends Query {
     }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) {
     return new MatchAllDocsWeight(searcher);
   }
 
+  @Override
   public void extractTerms(Set<Term> terms) {
   }
 
+  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("*:*");
@@ -142,6 +152,7 @@ public class MatchAllDocsQuery extends Query {
     return buffer.toString();
   }
 
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof MatchAllDocsQuery))
       return false;
@@ -149,6 +160,7 @@ public class MatchAllDocsQuery extends Query {
     return this.getBoost() == other.getBoost();
   }
 
+  @Override
   public int hashCode() {
     return Float.floatToIntBits(getBoost()) ^ 0x1AA71190;
   }
diff --git a/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index 8e758a1..34ace55 100644
--- a/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -113,6 +113,7 @@ public class MultiPhraseQuery extends Query {
   }
 
   // inherit javadoc
+  @Override
   public void extractTerms(Set<Term> terms) {
     for (final Term[] arr : termArrays) {
       for (final Term term: arr) {
@@ -142,20 +143,26 @@ public class MultiPhraseQuery extends Query {
       }
     }
 
+    @Override
     public Query getQuery() { return MultiPhraseQuery.this; }
+
+    @Override
     public float getValue() { return value; }
 
+    @Override
     public float sumOfSquaredWeights() {
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
 
+    @Override
     public void normalize(float queryNorm) {
       this.queryNorm = queryNorm;
       queryWeight *= queryNorm;                   // normalize query weight
       value = queryWeight * idf;                  // idf for document 
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       if (termArrays.size() == 0)                  // optimize zero-term case
         return null;
@@ -184,6 +191,7 @@ public class MultiPhraseQuery extends Query {
                                       slop, reader.norms(field));
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc)
       throws IOException {
       ComplexExplanation result = new ComplexExplanation();
@@ -215,12 +223,16 @@ public class MultiPhraseQuery extends Query {
       fieldExpl.setDescription("fieldWeight("+getQuery()+" in "+doc+
                                "), product of:");
 
-      Scorer scorer = scorer(reader, true, false);
+      PhraseScorer scorer = (PhraseScorer) scorer(reader, true, false);
       if (scorer == null) {
         return new Explanation(0.0f, "no matching docs");
       }
-      Explanation tfExpl = scorer.explain(doc);
-      fieldExpl.addDetail(tfExpl);
+      Explanation tfExplanation = new Explanation();
+      int d = scorer.advance(doc);
+      float phraseFreq = (d == doc) ? scorer.currentFreq() : 0.0f;
+      tfExplanation.setValue(similarity.tf(phraseFreq));
+      tfExplanation.setDescription("tf(phraseFreq=" + phraseFreq + ")");
+      fieldExpl.addDetail(tfExplanation);
       fieldExpl.addDetail(idfExpl);
 
       Explanation fieldNormExpl = new Explanation();
@@ -231,8 +243,8 @@ public class MultiPhraseQuery extends Query {
       fieldNormExpl.setDescription("fieldNorm(field="+field+", doc="+doc+")");
       fieldExpl.addDetail(fieldNormExpl);
 
-      fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
-      fieldExpl.setValue(tfExpl.getValue() *
+      fieldExpl.setMatch(Boolean.valueOf(tfExplanation.isMatch()));
+      fieldExpl.setValue(tfExplanation.getValue() *
                          idfExpl.getValue() *
                          fieldNormExpl.getValue());
 
@@ -249,6 +261,7 @@ public class MultiPhraseQuery extends Query {
     }
   }
 
+  @Override
   public Query rewrite(IndexReader reader) {
     if (termArrays.size() == 1) {                 // optimize one-term case
       Term[] terms = termArrays.get(0);
@@ -263,11 +276,13 @@ public class MultiPhraseQuery extends Query {
     }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) throws IOException {
     return new MultiPhraseWeight(searcher);
   }
 
   /** Prints a user-readable version of this query. */
+  @Override
   public final String toString(String f) {
     StringBuilder buffer = new StringBuilder();
     if (!field.equals(f)) {
@@ -307,6 +322,7 @@ public class MultiPhraseQuery extends Query {
 
 
   /** Returns true if <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof MultiPhraseQuery)) return false;
     MultiPhraseQuery other = (MultiPhraseQuery)o;
@@ -317,6 +333,7 @@ public class MultiPhraseQuery extends Query {
   }
 
   /** Returns a hash code value for this object.*/
+  @Override
   public int hashCode() {
     return Float.floatToIntBits(getBoost())
       ^ slop
@@ -330,25 +347,11 @@ public class MultiPhraseQuery extends Query {
     int hashCode = 1;
     for (final Term[] termArray: termArrays) {
       hashCode = 31 * hashCode
-          + (termArray == null ? 0 : arraysHashCode(termArray));
+          + (termArray == null ? 0 : Arrays.hashCode(termArray));
     }
     return hashCode;
   }
 
-  private int arraysHashCode(Term[] termArray) {
-      if (termArray == null)
-          return 0;
-
-      int result = 1;
-
-      for (int i = 0; i < termArray.length; i++) {
-        Term term = termArray[i];
-        result = 31 * result + (term == null ? 0 : term.hashCode());
-      }
-
-      return result;
-  }
-
   // Breakout calculation of the termArrays equals
   private boolean termArraysEquals(List<Term[]> termArrays1, List<Term[]> termArrays2) {
     if (termArrays1.size() != termArrays2.size()) {
diff --git a/src/java/org/apache/lucene/search/PhraseQuery.java b/src/java/org/apache/lucene/search/PhraseQuery.java
index 76c43c6..c25cc9e 100644
--- a/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -123,22 +123,29 @@ public class PhraseQuery extends Query {
       idf = idfExp.getIdf();
     }
 
+    @Override
     public String toString() { return "weight(" + PhraseQuery.this + ")"; }
 
+    @Override
     public Query getQuery() { return PhraseQuery.this; }
+
+    @Override
     public float getValue() { return value; }
 
+    @Override
     public float sumOfSquaredWeights() {
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
 
+    @Override
     public void normalize(float queryNorm) {
       this.queryNorm = queryNorm;
       queryWeight *= queryNorm;                   // normalize query weight
       value = queryWeight * idf;                  // idf for document 
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       if (terms.size() == 0)			  // optimize zero-term case
         return null;
@@ -161,6 +168,7 @@ public class PhraseQuery extends Query {
 
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc)
       throws IOException {
 
@@ -208,12 +216,17 @@ public class PhraseQuery extends Query {
       fieldExpl.setDescription("fieldWeight("+field+":"+query+" in "+doc+
                                "), product of:");
 
-      Scorer scorer = scorer(reader, true, false);
+      PhraseScorer scorer = (PhraseScorer) scorer(reader, true, false);
       if (scorer == null) {
         return new Explanation(0.0f, "no matching docs");
       }
-      Explanation tfExpl = scorer.explain(doc);
-      fieldExpl.addDetail(tfExpl);
+      Explanation tfExplanation = new Explanation();
+      int d = scorer.advance(doc);
+      float phraseFreq = (d == doc) ? scorer.currentFreq() : 0.0f;
+      tfExplanation.setValue(similarity.tf(phraseFreq));
+      tfExplanation.setDescription("tf(phraseFreq=" + phraseFreq + ")");
+      
+      fieldExpl.addDetail(tfExplanation);
       fieldExpl.addDetail(idfExpl);
 
       Explanation fieldNormExpl = new Explanation();
@@ -224,7 +237,7 @@ public class PhraseQuery extends Query {
       fieldNormExpl.setDescription("fieldNorm(field="+field+", doc="+doc+")");
       fieldExpl.addDetail(fieldNormExpl);
 
-      fieldExpl.setValue(tfExpl.getValue() *
+      fieldExpl.setValue(tfExplanation.getValue() *
                          idfExpl.getValue() *
                          fieldNormExpl.getValue());
 
@@ -240,6 +253,7 @@ public class PhraseQuery extends Query {
     }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) throws IOException {
     if (terms.size() == 1) {			  // optimize one-term case
       Term term = terms.get(0);
@@ -253,11 +267,13 @@ public class PhraseQuery extends Query {
   /**
    * @see org.apache.lucene.search.Query#extractTerms(Set)
    */
+  @Override
   public void extractTerms(Set<Term> queryTerms) {
     queryTerms.addAll(terms);
   }
 
   /** Prints a user-readable version of this query. */
+  @Override
   public String toString(String f) {
     StringBuilder buffer = new StringBuilder();
     if (field != null && !field.equals(f)) {
@@ -301,6 +317,7 @@ public class PhraseQuery extends Query {
   }
 
   /** Returns true iff <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof PhraseQuery))
       return false;
@@ -312,6 +329,7 @@ public class PhraseQuery extends Query {
   }
 
   /** Returns a hash code value for this object.*/
+  @Override
   public int hashCode() {
     return Float.floatToIntBits(getBoost())
       ^ slop
diff --git a/src/java/org/apache/lucene/search/PhraseScorer.java b/src/java/org/apache/lucene/search/PhraseScorer.java
index 541daf0..303e2d1 100644
--- a/src/java/org/apache/lucene/search/PhraseScorer.java
+++ b/src/java/org/apache/lucene/search/PhraseScorer.java
@@ -69,8 +69,10 @@ abstract class PhraseScorer extends Scorer {
     first.doc = -1;
   }
 
+  @Override
   public int docID() { return first.doc; }
 
+  @Override
   public int nextDoc() throws IOException {
     if (firstTime) {
       init();
@@ -104,12 +106,14 @@ abstract class PhraseScorer extends Scorer {
     return false;                                 // no more matches
   }
 
+  @Override
   public float score() throws IOException {
     //System.out.println("scoring " + first.doc);
     float raw = getSimilarity().tf(freq) * value; // raw score
     return norms == null ? raw : raw * Similarity.decodeNorm(norms[first.doc]); // normalize
   }
 
+  @Override
   public int advance(int target) throws IOException {
     firstTime = false;
     for (PhrasePositions pp = first; more && pp != null; pp = pp.next) {
@@ -125,6 +129,11 @@ abstract class PhraseScorer extends Scorer {
   }
   
   /**
+   * phrase frequency in current doc as computed by phraseFreq().
+   */
+  public final float currentFreq() { return freq; }
+  
+  /**
    * For a document containing all the phrase query terms, compute the
    * frequency of the phrase in that document. 
    * A non zero frequency means a match.
@@ -170,17 +179,7 @@ abstract class PhraseScorer extends Scorer {
     last.next = null;
   }
 
-  public Explanation explain(final int doc) throws IOException {
-    Explanation tfExplanation = new Explanation();
-
-    int d = advance(doc);
-    float phraseFreq = (d == doc) ? freq : 0.0f;
-    tfExplanation.setValue(getSimilarity().tf(phraseFreq));
-    tfExplanation.setDescription("tf(phraseFreq=" + phraseFreq + ")");
-
-    return tfExplanation;
-  }
-
+  @Override
   public String toString() { return "scorer(" + weight + ")"; }
 
 }
diff --git a/src/java/org/apache/lucene/search/ReqExclScorer.java b/src/java/org/apache/lucene/search/ReqExclScorer.java
index d3307bf..0ebaef1 100644
--- a/src/java/org/apache/lucene/search/ReqExclScorer.java
+++ b/src/java/org/apache/lucene/search/ReqExclScorer.java
@@ -41,6 +41,7 @@ class ReqExclScorer extends Scorer {
     this.exclDisi = exclDisi;
   }
 
+  @Override
   public int nextDoc() throws IOException {
     if (reqScorer == null) {
       return doc;
@@ -88,6 +89,7 @@ class ReqExclScorer extends Scorer {
     return NO_MORE_DOCS;
   }
 
+  @Override
   public int docID() {
     return doc;
   }
@@ -96,10 +98,12 @@ class ReqExclScorer extends Scorer {
    * Initially invalid, until {@link #next()} is called the first time.
    * @return The score of the required scorer.
    */
+  @Override
   public float score() throws IOException {
     return reqScorer.score(); // reqScorer may be null when next() or skipTo() already return false
   }
   
+  @Override
   public int advance(int target) throws IOException {
     if (reqScorer == null) {
       return doc = NO_MORE_DOCS;
@@ -113,15 +117,4 @@ class ReqExclScorer extends Scorer {
     }
     return doc = toNonExcluded();
   }
-  
-  public Explanation explain(int doc) throws IOException {
-    Explanation res = new Explanation();
-    if (exclDisi.advance(doc) == doc) {
-      res.setDescription("excluded");
-    } else {
-      res.setDescription("not excluded");
-      res.addDetail(reqScorer.explain(doc));
-    }
-    return res;
-  }
 }
diff --git a/src/java/org/apache/lucene/search/ReqOptSumScorer.java b/src/java/org/apache/lucene/search/ReqOptSumScorer.java
index bf0eca3..db4fc37 100644
--- a/src/java/org/apache/lucene/search/ReqOptSumScorer.java
+++ b/src/java/org/apache/lucene/search/ReqOptSumScorer.java
@@ -43,14 +43,17 @@ class ReqOptSumScorer extends Scorer {
     this.optScorer = optScorer;
   }
 
+  @Override
   public int nextDoc() throws IOException {
     return reqScorer.nextDoc();
   }
   
+  @Override
   public int advance(int target) throws IOException {
     return reqScorer.advance(target);
   }
   
+  @Override
   public int docID() {
     return reqScorer.docID();
   }
@@ -60,6 +63,7 @@ class ReqOptSumScorer extends Scorer {
    * @return The score of the required scorer, eventually increased by the score
    * of the optional scorer when it also matches the current document.
    */
+  @Override
   public float score() throws IOException {
     int curDoc = reqScorer.docID();
     float reqScore = reqScorer.score();
@@ -76,16 +80,5 @@ class ReqOptSumScorer extends Scorer {
     return optScorerDoc == curDoc ? reqScore + optScorer.score() : reqScore;
   }
 
-  /** Explain the score of a document.
-   * TODO: Also show the total score.
-   * See BooleanScorer.explain() on how to do this.
-   */
-  public Explanation explain(int doc) throws IOException {
-    Explanation res = new Explanation();
-    res.setDescription("required, optional");
-    res.addDetail(reqScorer.explain(doc));
-    res.addDetail(optScorer.explain(doc));
-    return res;
-  }
 }
 
diff --git a/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java b/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
index 5b8c4b1..a3e982f 100644
--- a/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
+++ b/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
@@ -42,18 +42,17 @@ public class ScoreCachingWrappingScorer extends Scorer {
     this.scorer = scorer;
   }
 
+  @Override
   protected boolean score(Collector collector, int max, int firstDocID) throws IOException {
     return scorer.score(collector, max, firstDocID);
   }
 
+  @Override
   public Similarity getSimilarity() {
     return scorer.getSimilarity();
   }
   
-  public Explanation explain(int doc) throws IOException {
-    return scorer.explain(doc);
-  }
-
+  @Override
   public float score() throws IOException {
     int doc = scorer.docID();
     if (doc != curDoc) {
@@ -64,18 +63,22 @@ public class ScoreCachingWrappingScorer extends Scorer {
     return curScore;
   }
 
+  @Override
   public int docID() {
     return scorer.docID();
   }
 
+  @Override
   public int nextDoc() throws IOException {
     return scorer.nextDoc();
   }
   
+  @Override
   public void score(Collector collector) throws IOException {
     scorer.score(collector);
   }
   
+  @Override
   public int advance(int target) throws IOException {
     return scorer.advance(target);
   }
diff --git a/src/java/org/apache/lucene/search/Scorer.java b/src/java/org/apache/lucene/search/Scorer.java
index d84342d..5adee3f 100644
--- a/src/java/org/apache/lucene/search/Scorer.java
+++ b/src/java/org/apache/lucene/search/Scorer.java
@@ -56,7 +56,6 @@ public abstract class Scorer extends DocIdSetIterator {
 
   /** Scores and collects all matching documents.
    * @param collector The collector to which all matching documents are passed.
-   * <br>When this method is used the {@link #explain(int)} method should not be used.
    */
   public void score(Collector collector) throws IOException {
     collector.setScorer(this);
@@ -97,16 +96,4 @@ public abstract class Scorer extends DocIdSetIterator {
    */
   public abstract float score() throws IOException;
 
-  /** Returns an explanation of the score for a document.
-   * <br>When this method is used, the {@link #next()}, {@link #skipTo(int)} and
-   * {@link #score(HitCollector)} methods should not be used.
-   * @param doc The document number for the explanation.
-   *
-   * @deprecated Please use {@link IndexSearcher#explain}
-   * or {@link Weight#explain} instead.
-   */
-  public Explanation explain(int doc) throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
 }
diff --git a/src/java/org/apache/lucene/search/TermQuery.java b/src/java/org/apache/lucene/search/TermQuery.java
index cc9d2b9..0ab9517 100644
--- a/src/java/org/apache/lucene/search/TermQuery.java
+++ b/src/java/org/apache/lucene/search/TermQuery.java
@@ -47,22 +47,29 @@ public class TermQuery extends Query {
       idf = idfExp.getIdf();
     }
 
+    @Override
     public String toString() { return "weight(" + TermQuery.this + ")"; }
 
+    @Override
     public Query getQuery() { return TermQuery.this; }
+
+    @Override
     public float getValue() { return value; }
 
+    @Override
     public float sumOfSquaredWeights() {
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
 
+    @Override
     public void normalize(float queryNorm) {
       this.queryNorm = queryNorm;
       queryWeight *= queryNorm;                   // normalize query weight
       value = queryWeight * idf;                  // idf for document
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       TermDocs termDocs = reader.termDocs(term);
 
@@ -72,6 +79,7 @@ public class TermQuery extends Query {
       return new TermScorer(this, termDocs, similarity, reader.norms(term.field()));
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc)
       throws IOException {
 
@@ -104,8 +112,24 @@ public class TermQuery extends Query {
       fieldExpl.setDescription("fieldWeight("+term+" in "+doc+
                                "), product of:");
 
-      Explanation tfExpl = scorer(reader, true, false).explain(doc);
-      fieldExpl.addDetail(tfExpl);
+      Explanation tfExplanation = new Explanation();
+      int tf = 0;
+      TermDocs termDocs = reader.termDocs(term);
+      if (termDocs != null) {
+        try {
+          if (termDocs.skipTo(doc) && termDocs.doc() == doc) {
+            tf = termDocs.freq();
+          }
+        } finally {
+          termDocs.close();
+        }
+        tfExplanation.setValue(similarity.tf(tf));
+        tfExplanation.setDescription("tf(termFreq("+term+")="+tf+")");
+      } else {
+        tfExplanation.setValue(0.0f);
+        tfExplanation.setDescription("no matching term");
+      }
+      fieldExpl.addDetail(tfExplanation);
       fieldExpl.addDetail(expl);
 
       Explanation fieldNormExpl = new Explanation();
@@ -116,8 +140,8 @@ public class TermQuery extends Query {
       fieldNormExpl.setDescription("fieldNorm(field="+field+", doc="+doc+")");
       fieldExpl.addDetail(fieldNormExpl);
       
-      fieldExpl.setMatch(Boolean.valueOf(tfExpl.isMatch()));
-      fieldExpl.setValue(tfExpl.getValue() *
+      fieldExpl.setMatch(Boolean.valueOf(tfExplanation.isMatch()));
+      fieldExpl.setValue(tfExplanation.getValue() *
                          expl.getValue() *
                          fieldNormExpl.getValue());
 
@@ -142,15 +166,18 @@ public class TermQuery extends Query {
   /** Returns the term of this query. */
   public Term getTerm() { return term; }
 
+  @Override
   public Weight createWeight(Searcher searcher) throws IOException {
     return new TermWeight(searcher);
   }
 
+  @Override
   public void extractTerms(Set<Term> terms) {
     terms.add(getTerm());
   }
 
   /** Prints a user-readable version of this query. */
+  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     if (!term.field().equals(field)) {
@@ -163,6 +190,7 @@ public class TermQuery extends Query {
   }
 
   /** Returns true iff <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof TermQuery))
       return false;
@@ -172,6 +200,7 @@ public class TermQuery extends Query {
   }
 
   /** Returns a hash code value for this object.*/
+  @Override
   public int hashCode() {
     return Float.floatToIntBits(getBoost()) ^ term.hashCode();
   }
diff --git a/src/java/org/apache/lucene/search/TermScorer.java b/src/java/org/apache/lucene/search/TermScorer.java
index d3bed92..b690e31 100644
--- a/src/java/org/apache/lucene/search/TermScorer.java
+++ b/src/java/org/apache/lucene/search/TermScorer.java
@@ -65,11 +65,13 @@ final class TermScorer extends Scorer {
       scoreCache[i] = getSimilarity().tf(i) * weightValue;
   }
 
+  @Override
   public void score(Collector c) throws IOException {
     score(c, Integer.MAX_VALUE, nextDoc());
   }
 
   // firstDocID is ignored since nextDoc() sets 'doc'
+  @Override
   protected boolean score(Collector c, int end, int firstDocID) throws IOException {
     c.setScorer(this);
     while (doc < end) {                           // for docs in window
@@ -90,6 +92,7 @@ final class TermScorer extends Scorer {
     return true;
   }
 
+  @Override
   public int docID() { return doc; }
 
   /**
@@ -99,6 +102,7 @@ final class TermScorer extends Scorer {
    * 
    * @return the document matching the query or -1 if there are no more documents.
    */
+  @Override
   public int nextDoc() throws IOException {
     pointer++;
     if (pointer >= pointerMax) {
@@ -114,6 +118,7 @@ final class TermScorer extends Scorer {
     return doc;
   }
   
+  @Override
   public float score() {
     assert doc != -1;
     int f = freqs[pointer];
@@ -134,6 +139,7 @@ final class TermScorer extends Scorer {
    *          The target document number.
    * @return the matching document or -1 if none exist.
    */
+  @Override
   public int advance(int target) throws IOException {
     // first scan in cache
     for (pointer++; pointer < pointerMax; pointer++) {
@@ -155,34 +161,7 @@ final class TermScorer extends Scorer {
     return doc;
   }
   
-  /** Returns an explanation of the score for a document.
-   * @param doc The document number for the explanation.
-   */
-  public Explanation explain(int doc) throws IOException {
-    TermQuery query = (TermQuery) weight.getQuery();
-    Explanation tfExplanation = new Explanation();
-    int tf = 0;
-    while (pointer < pointerMax) {
-      if (docs[pointer] == doc)
-        tf = freqs[pointer];
-      pointer++;
-    }
-    if (tf == 0) {
-        if (termDocs.skipTo(doc))
-        {
-            if (termDocs.doc() == doc)
-            {
-                tf = termDocs.freq();
-            }
-        }
-    }
-    termDocs.close();
-    tfExplanation.setValue(getSimilarity().tf(tf));
-    tfExplanation.setDescription("tf(termFreq("+query.getTerm()+")="+tf+")");
-    
-    return tfExplanation;
-  }
-
   /** Returns a string representation of this <code>TermScorer</code>. */
+  @Override
   public String toString() { return "scorer(" + weight + ")"; }
 }
diff --git a/src/java/org/apache/lucene/search/function/CustomScoreQuery.java b/src/java/org/apache/lucene/search/function/CustomScoreQuery.java
index b9b8932..3d522cd 100755
--- a/src/java/org/apache/lucene/search/function/CustomScoreQuery.java
+++ b/src/java/org/apache/lucene/search/function/CustomScoreQuery.java
@@ -90,6 +90,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
+  @Override
   public Query rewrite(IndexReader reader) throws IOException {
     subQuery = subQuery.rewrite(reader);
     for(int i = 0; i < valSrcQueries.length; i++) {
@@ -99,6 +100,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
+  @Override
   public void extractTerms(Set<Term> terms) {
     subQuery.extractTerms(terms);
     for(int i = 0; i < valSrcQueries.length; i++) {
@@ -107,6 +109,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#clone() */
+  @Override
   public Object clone() {
     CustomScoreQuery clone = (CustomScoreQuery)super.clone();
     clone.subQuery = (Query) subQuery.clone();
@@ -118,6 +121,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /* (non-Javadoc) @see org.apache.lucene.search.Query#toString(java.lang.String) */
+  @Override
   public String toString(String field) {
     StringBuilder sb = new StringBuilder(name()).append("(");
     sb.append(subQuery.toString(field));
@@ -130,6 +134,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /** Returns true if <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (getClass() != o.getClass()) {
       return false;
@@ -149,6 +154,7 @@ public class CustomScoreQuery extends Query {
   }
 
   /** Returns a hash code value for this object. */
+  @Override
   public int hashCode() {
     int valSrcHash = 0;
     for (int i=0; i<valSrcQueries.length; i++) { //TODO simplify with Arrays.deepHashcode() once moving to Java 1.5
@@ -289,16 +295,19 @@ public class CustomScoreQuery extends Query {
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#getQuery() */
+    @Override
     public Query getQuery() {
       return CustomScoreQuery.this;
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#getValue() */
+    @Override
     public float getValue() {
       return getBoost();
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#sumOfSquaredWeights() */
+    @Override
     public float sumOfSquaredWeights() throws IOException {
       float sum = subQueryWeight.sumOfSquaredWeights();
       for(int i = 0; i < valSrcWeights.length; i++) {
@@ -313,6 +322,7 @@ public class CustomScoreQuery extends Query {
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#normalize(float) */
+    @Override
     public void normalize(float norm) {
       norm *= getBoost(); // incorporate boost
       subQueryWeight.normalize(norm);
@@ -325,6 +335,7 @@ public class CustomScoreQuery extends Query {
       }
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       // Pass true for "scoresDocsInOrder", because we
       // require in-order scoring, even if caller does not,
@@ -342,24 +353,21 @@ public class CustomScoreQuery extends Query {
       return new CustomScorer(similarity, reader, this, subQueryScorer, valSrcScorers);
     }
 
+    @Override
     public Explanation explain(IndexReader reader, int doc) throws IOException {
       Explanation explain = doExplain(reader, doc);
       return explain == null ? new Explanation(0.0f, "no matching docs") : doExplain(reader, doc);
     }
     
     private Explanation doExplain(IndexReader reader, int doc) throws IOException {
-      Scorer[] valSrcScorers = new Scorer[valSrcWeights.length];
-      for(int i = 0; i < valSrcScorers.length; i++) {
-         valSrcScorers[i] = valSrcWeights[i].scorer(reader, true, false);
-      }
       Explanation subQueryExpl = subQueryWeight.explain(reader, doc);
       if (!subQueryExpl.isMatch()) {
         return subQueryExpl;
       }
       // match
-      Explanation[] valSrcExpls = new Explanation[valSrcScorers.length];
-      for(int i = 0; i < valSrcScorers.length; i++) {
-        valSrcExpls[i] = valSrcScorers[i].explain(doc);
+      Explanation[] valSrcExpls = new Explanation[valSrcWeights.length];
+      for(int i = 0; i < valSrcWeights.length; i++) {
+        valSrcExpls[i] = valSrcWeights[i].explain(reader, doc);
       }
       Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpls);
       float sc = getValue() * customExp.getValue();
@@ -370,6 +378,7 @@ public class CustomScoreQuery extends Query {
       return res;
     }
 
+    @Override
     public boolean scoresDocsOutOfOrder() {
       return false;
     }
@@ -402,6 +411,7 @@ public class CustomScoreQuery extends Query {
       this.vScores = new float[valSrcScorers.length];
     }
 
+    @Override
     public int nextDoc() throws IOException {
       int doc = subQueryScorer.nextDoc();
       if (doc != NO_MORE_DOCS) {
@@ -412,11 +422,13 @@ public class CustomScoreQuery extends Query {
       return doc;
     }
 
+    @Override
     public int docID() {
       return subQueryScorer.docID();
     }
     
     /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */
+    @Override
     public float score() throws IOException {
       for (int i = 0; i < valSrcScorers.length; i++) {
         vScores[i] = valSrcScorers[i].score();
@@ -424,6 +436,7 @@ public class CustomScoreQuery extends Query {
       return qWeight * customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
     }
 
+    @Override
     public int advance(int target) throws IOException {
       int doc = subQueryScorer.advance(target);
       if (doc != NO_MORE_DOCS) {
@@ -433,29 +446,9 @@ public class CustomScoreQuery extends Query {
       }
       return doc;
     }
-    
-    // TODO: remove in 3.0
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#explain(int) */
-    public Explanation explain(int doc) throws IOException {
-      Explanation subQueryExpl = weight.subQueryWeight.explain(reader,doc);
-      if (!subQueryExpl.isMatch()) {
-        return subQueryExpl;
-      }
-      // match
-      Explanation[] valSrcExpls = new Explanation[valSrcScorers.length];
-      for(int i = 0; i < valSrcScorers.length; i++) {
-        valSrcExpls[i] = valSrcScorers[i].explain(doc);
-      }
-      Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpls);
-      float sc = qWeight * customExp.getValue();
-      Explanation res = new ComplexExplanation(
-        true, sc, CustomScoreQuery.this.toString() + ", product of:");
-      res.addDetail(customExp);
-      res.addDetail(new Explanation(qWeight, "queryBoost")); // actually using the q boost as q weight (== weight value)
-      return res;
-    }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) throws IOException {
     return new CustomWeight(searcher);
   }
diff --git a/src/java/org/apache/lucene/search/function/ValueSourceQuery.java b/src/java/org/apache/lucene/search/function/ValueSourceQuery.java
index 3826b81..c777c3d 100644
--- a/src/java/org/apache/lucene/search/function/ValueSourceQuery.java
+++ b/src/java/org/apache/lucene/search/function/ValueSourceQuery.java
@@ -54,11 +54,13 @@ public class ValueSourceQuery extends Query {
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
+  @Override
   public Query rewrite(IndexReader reader) throws IOException {
     return this;
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
+  @Override
   public void extractTerms(Set<Term> terms) {
     // no terms involved here
   }
@@ -73,34 +75,49 @@ public class ValueSourceQuery extends Query {
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#getQuery() */
+    @Override
     public Query getQuery() {
       return ValueSourceQuery.this;
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#getValue() */
+    @Override
     public float getValue() {
       return queryWeight;
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#sumOfSquaredWeights() */
+    @Override
     public float sumOfSquaredWeights() throws IOException {
       queryWeight = getBoost();
       return queryWeight * queryWeight;
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#normalize(float) */
+    @Override
     public void normalize(float norm) {
       this.queryNorm = norm;
       queryWeight *= this.queryNorm;
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
       return new ValueSourceScorer(similarity, reader, this);
     }
 
     /*(non-Javadoc) @see org.apache.lucene.search.Weight#explain(org.apache.lucene.index.IndexReader, int) */
+    @Override
     public Explanation explain(IndexReader reader, int doc) throws IOException {
-      return new ValueSourceScorer(similarity, reader, this).explain(doc);
+      DocValues vals = valSrc.getValues(reader);
+      float sc = queryWeight * vals.floatVal(doc);
+
+      Explanation result = new ComplexExplanation(
+        true, sc, ValueSourceQuery.this.toString() + ", product of:");
+
+      result.addDetail(vals.explain(doc));
+      result.addDetail(new Explanation(getBoost(), "boost"));
+      result.addDetail(new Explanation(queryNorm,"queryNorm"));
+      return result;
     }
   }
 
@@ -127,46 +144,40 @@ public class ValueSourceQuery extends Query {
       termDocs = reader.termDocs(null);
     }
 
+    @Override
     public int nextDoc() throws IOException {
       return doc = termDocs.next() ? termDocs.doc() : NO_MORE_DOCS;
     }
     
+    @Override
     public int docID() {
       return doc;
     }
     
+    @Override
     public int advance(int target) throws IOException {
       return doc = termDocs.skipTo(target) ? termDocs.doc() : NO_MORE_DOCS;
     }
     
     /*(non-Javadoc) @see org.apache.lucene.search.Scorer#score() */
+    @Override
     public float score() throws IOException {
       return qWeight * vals.floatVal(termDocs.doc());
     }
-
-    /*(non-Javadoc) @see org.apache.lucene.search.Scorer#explain(int) */
-    public Explanation explain(int doc) throws IOException {
-      float sc = qWeight * vals.floatVal(doc);
-
-      Explanation result = new ComplexExplanation(
-        true, sc, ValueSourceQuery.this.toString() + ", product of:");
-
-      result.addDetail(vals.explain(doc));
-      result.addDetail(new Explanation(getBoost(), "boost"));
-      result.addDetail(new Explanation(weight.queryNorm,"queryNorm"));
-      return result;
-    }
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) {
     return new ValueSourceQuery.ValueSourceWeight(searcher);
   }
 
+  @Override
   public String toString(String field) {
     return valSrc.toString() + ToStringUtils.boost(getBoost());
   }
 
   /** Returns true if <code>o</code> is equal to this. */
+  @Override
   public boolean equals(Object o) {
     if (getClass() != o.getClass()) {
       return false;
@@ -177,6 +188,7 @@ public class ValueSourceQuery extends Query {
   }
 
   /** Returns a hash code value for this object. */
+  @Override
   public int hashCode() {
     return (getClass().hashCode() + valSrc.hashCode()) ^ Float.floatToIntBits(getBoost());
   }
diff --git a/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java b/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
index 162d59e..d3f79e9 100644
--- a/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
+++ b/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
@@ -223,7 +223,7 @@ public class PayloadNearQuery extends SpanNearQuery {
     }
 
     @Override
-    public Explanation explain(int doc) throws IOException {
+    protected Explanation explain(int doc) throws IOException {
       Explanation result = new Explanation();
       Explanation nonPayloadExpl = super.explain(doc);
       result.addDetail(nonPayloadExpl);
diff --git a/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java b/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
index abbc27f..5ca45e9 100644
--- a/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
+++ b/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
@@ -60,6 +60,7 @@ public class PayloadTermQuery extends SpanTermQuery {
     this.includeSpanScore = includeSpanScore;
   }
 
+  @Override
   public Weight createWeight(Searcher searcher) throws IOException {
     return new PayloadTermWeight(this, searcher);
   }
@@ -71,6 +72,7 @@ public class PayloadTermQuery extends SpanTermQuery {
       super(query, searcher);
     }
 
+    @Override
     public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder,
         boolean topScorer) throws IOException {
       return new PayloadTermSpanScorer((TermSpans) query.getSpans(reader),
@@ -90,6 +92,7 @@ public class PayloadTermQuery extends SpanTermQuery {
         positions = spans.getPositions();
       }
 
+      @Override
       protected boolean setFreqCurrentDoc() throws IOException {
         if (!more) {
           return false;
@@ -130,6 +133,7 @@ public class PayloadTermQuery extends SpanTermQuery {
        * @return {@link #getSpanScore()} * {@link #getPayloadScore()}
        * @throws IOException
        */
+      @Override
       public float score() throws IOException {
 
         return includeSpanScore ? getSpanScore() * getPayloadScore()
@@ -160,7 +164,8 @@ public class PayloadTermQuery extends SpanTermQuery {
         return function.docScore(doc, term.field(), payloadsSeen, payloadScore);
       }
 
-      public Explanation explain(final int doc) throws IOException {
+      @Override
+      protected Explanation explain(final int doc) throws IOException {
         ComplexExplanation result = new ComplexExplanation();
         Explanation nonPayloadExpl = super.explain(doc);
         result.addDetail(nonPayloadExpl);
@@ -184,6 +189,7 @@ public class PayloadTermQuery extends SpanTermQuery {
     }
   }
 
+  @Override
   public int hashCode() {
     final int prime = 31;
     int result = super.hashCode();
@@ -192,6 +198,7 @@ public class PayloadTermQuery extends SpanTermQuery {
     return result;
   }
 
+  @Override
   public boolean equals(Object obj) {
     if (this == obj)
       return true;
diff --git a/src/java/org/apache/lucene/search/spans/SpanScorer.java b/src/java/org/apache/lucene/search/spans/SpanScorer.java
index 9b35df0..6ac9a18 100644
--- a/src/java/org/apache/lucene/search/spans/SpanScorer.java
+++ b/src/java/org/apache/lucene/search/spans/SpanScorer.java
@@ -53,6 +53,7 @@ public class SpanScorer extends Scorer {
     }
   }
 
+  @Override
   public int nextDoc() throws IOException {
     if (!setFreqCurrentDoc()) {
       doc = NO_MORE_DOCS;
@@ -60,6 +61,7 @@ public class SpanScorer extends Scorer {
     return doc;
   }
 
+  @Override
   public int advance(int target) throws IOException {
     if (!more) {
       return doc = NO_MORE_DOCS;
@@ -87,14 +89,18 @@ public class SpanScorer extends Scorer {
     return true;
   }
 
+  @Override
   public int docID() { return doc; }
 
+  @Override
   public float score() throws IOException {
     float raw = getSimilarity().tf(freq) * value; // raw score
     return norms == null? raw : raw * Similarity.decodeNorm(norms[doc]); // normalize
   }
 
-  public Explanation explain(final int doc) throws IOException {
+  /** This method is no longer an official member of {@link Scorer},
+   * but it is needed by SpanWeight to build an explanation. */
+  protected Explanation explain(final int doc) throws IOException {
     Explanation tfExplanation = new Explanation();
 
     int expDoc = advance(doc);
diff --git a/src/java/org/apache/lucene/search/spans/SpanWeight.java b/src/java/org/apache/lucene/search/spans/SpanWeight.java
index b8b5bd9..3a3992b 100644
--- a/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ b/src/java/org/apache/lucene/search/spans/SpanWeight.java
@@ -52,25 +52,32 @@ public class SpanWeight extends Weight {
     idf = idfExp.getIdf();
   }
 
+  @Override
   public Query getQuery() { return query; }
+
+  @Override
   public float getValue() { return value; }
 
+  @Override
   public float sumOfSquaredWeights() throws IOException {
     queryWeight = idf * query.getBoost();         // compute query weight
     return queryWeight * queryWeight;             // square it
   }
 
+  @Override
   public void normalize(float queryNorm) {
     this.queryNorm = queryNorm;
     queryWeight *= queryNorm;                     // normalize query weight
     value = queryWeight * idf;                    // idf for document
   }
 
+  @Override
   public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder, boolean topScorer) throws IOException {
     return new SpanScorer(query.getSpans(reader), this, similarity, reader
         .norms(query.getField()));
   }
 
+  @Override
   public Explanation explain(IndexReader reader, int doc)
     throws IOException {
 
@@ -104,7 +111,7 @@ public class SpanWeight extends Weight {
     fieldExpl.setDescription("fieldWeight("+field+":"+query.toString(field)+
                              " in "+doc+"), product of:");
 
-    Explanation tfExpl = scorer(reader, true, false).explain(doc);
+    Explanation tfExpl = ((SpanScorer)scorer(reader, true, false)).explain(doc);
     fieldExpl.addDetail(tfExpl);
     fieldExpl.addDetail(idfExpl);
 
diff --git a/src/test/org/apache/lucene/search/JustCompileSearch.java b/src/test/org/apache/lucene/search/JustCompileSearch.java
index e1e8afa..858631d 100644
--- a/src/test/org/apache/lucene/search/JustCompileSearch.java
+++ b/src/test/org/apache/lucene/search/JustCompileSearch.java
@@ -308,10 +308,6 @@ final class JustCompileSearch {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
     
-    public Explanation explain(int doc) throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
     public float score() throws IOException {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
diff --git a/src/test/org/apache/lucene/search/TestBooleanScorer.java b/src/test/org/apache/lucene/search/TestBooleanScorer.java
index 556e552..9366469 100644
--- a/src/test/org/apache/lucene/search/TestBooleanScorer.java
+++ b/src/test/org/apache/lucene/search/TestBooleanScorer.java
@@ -80,15 +80,14 @@ public class TestBooleanScorer extends LuceneTestCase
     Similarity sim = Similarity.getDefault();
     Scorer[] scorers = new Scorer[] {new Scorer(sim) {
       private int doc = -1;
-      public Explanation explain(int doc) throws IOException { return null; }
-      public float score() throws IOException { return 0; }
-      public int docID() { return doc; }
+      @Override public float score() throws IOException { return 0; }
+      @Override public int docID() { return doc; }
       
-      public int nextDoc() throws IOException {
+      @Override public int nextDoc() throws IOException {
         return doc = doc == -1 ? 3000 : NO_MORE_DOCS;
       }
 
-      public int advance(int target) throws IOException {
+      @Override public int advance(int target) throws IOException {
         return doc = target <= 3000 ? 3000 : NO_MORE_DOCS;
       }
       
diff --git a/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java b/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
index 0d7df11..0aa2fe3 100644
--- a/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
+++ b/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
@@ -30,19 +30,17 @@ public class TestPositiveScoresOnlyCollector extends LuceneTestCase {
       super(null);
     }
     
-    public Explanation explain(int doc) throws IOException { return null; }
-
-    public float score() throws IOException {
+    @Override public float score() throws IOException {
       return idx == scores.length ? Float.NaN : scores[idx];
     }
 
-    public int docID() { return idx; }
+    @Override public int docID() { return idx; }
 
-    public int nextDoc() throws IOException {
+    @Override public int nextDoc() throws IOException {
       return ++idx != scores.length ? idx : NO_MORE_DOCS;
     }
     
-    public int advance(int target) throws IOException {
+    @Override public int advance(int target) throws IOException {
       idx = target;
       return idx < scores.length ? idx : NO_MORE_DOCS;
     }
diff --git a/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java b/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
index 8c16472..69ae819 100644
--- a/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
+++ b/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
@@ -32,9 +32,7 @@ public class TestScoreCachingWrappingScorer extends LuceneTestCase {
       super(null);
     }
     
-    public Explanation explain(int doc) throws IOException { return null; }
-
-    public float score() throws IOException {
+    @Override public float score() throws IOException {
       // advance idx on purpose, so that consecutive calls to score will get
       // different results. This is to emulate computation of a score. If
       // ScoreCachingWrappingScorer is used, this should not be called more than
@@ -42,13 +40,13 @@ public class TestScoreCachingWrappingScorer extends LuceneTestCase {
       return idx == scores.length ? Float.NaN : scores[idx++];
     }
 
-    public int docID() { return doc; }
+    @Override public int docID() { return doc; }
 
-    public int nextDoc() throws IOException {
+    @Override public int nextDoc() throws IOException {
       return ++doc < scores.length ? doc : NO_MORE_DOCS;
     }
     
-    public int advance(int target) throws IOException {
+    @Override public int advance(int target) throws IOException {
       doc = target;
       return doc < scores.length ? doc : NO_MORE_DOCS;
     }
@@ -65,7 +63,7 @@ public class TestScoreCachingWrappingScorer extends LuceneTestCase {
       mscores = new float[numToCollect];
     }
     
-    public void collect(int doc) throws IOException {
+    @Override public void collect(int doc) throws IOException {
       // just a sanity check to avoid IOOB.
       if (idx == mscores.length) {
         return; 
@@ -78,15 +76,15 @@ public class TestScoreCachingWrappingScorer extends LuceneTestCase {
       ++idx;
     }
 
-    public void setNextReader(IndexReader reader, int docBase)
+    @Override public void setNextReader(IndexReader reader, int docBase)
         throws IOException {
     }
 
-    public void setScorer(Scorer scorer) throws IOException {
+    @Override public void setScorer(Scorer scorer) throws IOException {
       this.scorer = new ScoreCachingWrappingScorer(scorer);
     }
     
-    public boolean acceptsDocsOutOfOrder() {
+    @Override public boolean acceptsDocsOutOfOrder() {
       return true;
     }
 
diff --git a/src/test/org/apache/lucene/search/TestTermScorer.java b/src/test/org/apache/lucene/search/TestTermScorer.java
index 46f5462..9e2b0cc 100644
--- a/src/test/org/apache/lucene/search/TestTermScorer.java
+++ b/src/test/org/apache/lucene/search/TestTermScorer.java
@@ -158,49 +158,6 @@ public class TestTermScorer extends LuceneTestCase
         assertTrue("doc should be number 5", ts.docID() == 5);
     }
 
-    public void testExplain() throws Exception
-    {
-        Term allTerm = new Term(FIELD, "all");
-        TermQuery termQuery = new TermQuery(allTerm);
-
-        Weight weight = termQuery.weight(indexSearcher);
-
-        TermScorer ts = new TermScorer(weight,
-                                       indexReader.termDocs(allTerm), indexSearcher.getSimilarity(),
-                                       indexReader.norms(FIELD));
-        Explanation explanation = ts.explain(0);
-        assertTrue("explanation is null and it shouldn't be", explanation != null);
-        //System.out.println("Explanation: " + explanation.toString());
-        //All this Explain does is return the term frequency
-        assertTrue("term frq is not 1", explanation.getValue() == 1);
-        explanation = ts.explain(1);
-        assertTrue("explanation is null and it shouldn't be", explanation != null);
-        //System.out.println("Explanation: " + explanation.toString());
-        //All this Explain does is return the term frequency
-        assertTrue("term frq is not 0", explanation.getValue() == 0);
-
-        Term dogsTerm = new Term(FIELD, "dogs");
-        termQuery = new TermQuery(dogsTerm);
-        weight = termQuery.weight(indexSearcher);
-
-        ts = new TermScorer(weight, indexReader.termDocs(dogsTerm), indexSearcher.getSimilarity(),
-                                       indexReader.norms(FIELD));
-        explanation = ts.explain(1);
-        assertTrue("explanation is null and it shouldn't be", explanation != null);
-        //System.out.println("Explanation: " + explanation.toString());
-        //All this Explain does is return the term frequency
-        float sqrtTwo = (float)Math.sqrt(2.0f);
-        assertTrue("term frq: " + explanation.getValue() + " is not the square root of 2", explanation.getValue() == sqrtTwo);
-
-        explanation = ts.explain(10);//try a doc out of range
-        assertTrue("explanation is null and it shouldn't be", explanation != null);
-        //System.out.println("Explanation: " + explanation.toString());
-        //All this Explain does is return the term frequency
-
-        assertTrue("term frq: " + explanation.getValue() + " is not 0", explanation.getValue() == 0);
-
-    }
-
     private class TestHit {
         public int doc;
         public float score;
diff --git a/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index 820540d..b5875dd 100644
--- a/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -169,9 +169,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
    */
   public void testSpanNearScorerExplain() throws Exception {
     SpanNearQuery q = makeQuery();
-    Weight w = q.weight(searcher);
-    Scorer s = w.scorer(searcher.getIndexReader(), true, false);
-    Explanation e = s.explain(1);
+    Explanation e = q.weight(searcher).explain(searcher.getIndexReader(), 1);
     assertTrue("Scorer explanation value for doc#1 isn't positive: "
                + e.toString(),
                0.0f < e.getValue());

