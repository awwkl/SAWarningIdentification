GitDiffStart: 06bf9a0857e997e7c5251ca8546556d1cdadf80f | Tue Jan 22 06:36:52 2013 +0000
diff --git a/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java
deleted file mode 100644
index 9805924..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInfo;
-
-/**
- * <p>
- * Field that stores a per-document <code>byte</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new ByteDocValuesField(name, (byte) 22));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-public class ByteDocValuesField extends StoredField {
-
-  /**
-   * Type for 8-bit byte DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
-  }
-
-  /** 
-   * Creates a new DocValues field with the specified 8-bit byte value 
-   * @param name field name
-   * @param value 8-bit byte value
-   * @throws IllegalArgumentException if the field name is null.
-   */
-  public ByteDocValuesField(String name, byte value) {
-    super(name, TYPE);
-    fieldsData = Byte.valueOf(value);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java
deleted file mode 100644
index e600fe9..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * <p>
- * Field that stores
- * a per-document {@link BytesRef} value.  The values are
- * stored indirectly, such that many documents sharing the
- * same value all point to a single copy of the value, which
- * is a good fit when the fields share values.  If values
- * are (mostly) unique it's better to use {@link
- * StraightBytesDocValuesField}.  Here's an example usage: 
- * 
- * <pre class="prettyprint">
- *   document.add(new DerefBytesDocValuesField(name, new BytesRef("hello")));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-@Deprecated
-public class DerefBytesDocValuesField extends SortedBytesDocValuesField {
-
-  /**
-   * Create a new variable-length indirect DocValues field.
-   * <p>
-   * This calls 
-   * {@link DerefBytesDocValuesField#DerefBytesDocValuesField(String, BytesRef, boolean)
-   *  DerefBytesDocValuesField(name, bytes, false}, meaning by default
-   * it allows for values of different lengths. If your values are all 
-   * the same length, use that constructor instead.
-   * @param name field name
-   * @param bytes binary content
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public DerefBytesDocValuesField(String name, BytesRef bytes) {
-    super(name, bytes);
-  }
-
-  /**
-   * Create a new fixed or variable length indirect DocValues field.
-   * <p>
-   * @param name field name
-   * @param bytes binary content
-   * @param isFixedLength true if all values have the same length.
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public DerefBytesDocValuesField(String name, BytesRef bytes, boolean isFixedLength) {
-    super(name, bytes);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
index cfd1227..f4d173d 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
@@ -1,5 +1,8 @@
 package org.apache.lucene.document;
 
+import org.apache.lucene.index.AtomicReader; // javadocs
+import org.apache.lucene.search.FieldCache; // javadocs
+
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -17,42 +20,30 @@ package org.apache.lucene.document;
  * limitations under the License.
  */
 
-import org.apache.lucene.index.FieldInfo;
-
 /**
+ * Syntactic sugar for encoding doubles as NumericDocValues
+ * via {@link Double#doubleToRawLongBits(double)}.
  * <p>
- * Field that stores a per-document <code>double</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new DoubleDocValuesField(name, 22.0));
- * </pre>
- * 
+ * Per-document double values can be retrieved via
+ * {@link FieldCache#getDoubles(AtomicReader, String, boolean)}.
  * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-public class DoubleDocValuesField extends StoredField {
+ * <b>NOTE</b>: In most all cases this will be rather inefficient,
+ * requiring eight bytes per document. Consider encoding double
+ * values yourself with only as much precision as you require.
+ */
+public class DoubleDocValuesField extends NumericDocValuesField {
 
-  /**
-   * Type for 64-bit double DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
+  public DoubleDocValuesField(String name, double value) {
+    super(name, Double.doubleToRawLongBits(value));
   }
 
-  /** 
-   * Creates a new DocValues field with the specified 64-bit double value 
-   * @param name field name
-   * @param value 64-bit double value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public DoubleDocValuesField(String name, double value) {
-    super(name, TYPE);
-    fieldsData = value;
+  @Override
+  public void setDoubleValue(double value) {
+    super.setLongValue(Double.doubleToRawLongBits(value));
+  }
+  
+  @Override
+  public void setLongValue(long value) {
+    throw new IllegalArgumentException("cannot change value type from Double to Long");
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/document/Field.java b/lucene/core/src/java/org/apache/lucene/document/Field.java
index 7843034..ad6bf94 100644
--- a/lucene/core/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/core/src/java/org/apache/lucene/document/Field.java
@@ -37,13 +37,8 @@ import org.apache.lucene.index.FieldInvertState; // javadocs
  * Expert: directly create a field for a document.  Most
  * users should use one of the sugar subclasses: {@link
  * IntField}, {@link LongField}, {@link FloatField}, {@link
- * DoubleField}, {@link ByteDocValuesField}, {@link
- * ShortDocValuesField}, {@link IntDocValuesField}, {@link
- * LongDocValuesField}, {@link PackedLongDocValuesField},
- * {@link FloatDocValuesField}, {@link
- * DoubleDocValuesField}, {@link SortedBytesDocValuesField},
- * {@link DerefBytesDocValuesField}, {@link
- * StraightBytesDocValuesField}, {@link
+ * DoubleField}, {@link BinaryDocValuesField}, {@link
+ * NumericDocValuesField}, {@link SortedDocValuesField}, {@link
  * StringField}, {@link TextField}, {@link StoredField}.
  *
  * <p/> A field is a section of a Document. Each field has three
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
index e6b85a3..655fb35 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
@@ -1,5 +1,7 @@
 package org.apache.lucene.document;
 
+import org.apache.lucene.search.FieldCache;
+
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -17,41 +19,30 @@ package org.apache.lucene.document;
  * limitations under the License.
  */
 
-import org.apache.lucene.index.FieldInfo;
-
 /**
+ * Syntactic sugar for encoding floats as NumericDocValues
+ * via {@link Float#floatToRawIntBits(float)}.
  * <p>
- * Field that stores a per-document <code>float</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new FloatDocValuesField(name, 22f));
- * </pre>
- * 
+ * Per-document floating point values can be retrieved via
+ * {@link FieldCache#getFloats(org.apache.lucene.index.AtomicReader, String, boolean)}.
  * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * */
-
-public class FloatDocValuesField extends StoredField {
+ * <b>NOTE</b>: In most all cases this will be rather inefficient,
+ * requiring four bytes per document. Consider encoding floating
+ * point values yourself with only as much precision as you require.
+ */
+public class FloatDocValuesField extends NumericDocValuesField {
 
-  /**
-   * Type for 32-bit float DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
+  public FloatDocValuesField(String name, float value) {
+    super(name, Float.floatToRawIntBits(value));
   }
 
-  /** 
-   * Creates a new DocValues field with the specified 32-bit float value 
-   * @param name field name
-   * @param value 32-bit float value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public FloatDocValuesField(String name, float value) {
-    super(name, TYPE);
-    fieldsData = value;
+  @Override
+  public void setFloatValue(float value) {
+    super.setLongValue(Float.floatToRawIntBits(value));
+  }
+  
+  @Override
+  public void setLongValue(long value) {
+    throw new IllegalArgumentException("cannot change value type from Float to Long");
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java
deleted file mode 100644
index 7454185..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInfo;
-
-/**
- * <p>
- * Field that stores a per-document <code>int</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new IntDocValuesField(name, 22));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * */
-
-public class IntDocValuesField extends StoredField {
-
-  /**
-   * Type for 32-bit integer DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
-  }
-
-  /** 
-   * Creates a new DocValues field with the specified 32-bit integer value 
-   * @param name field name
-   * @param value 32-bit integer value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public IntDocValuesField(String name, int value) {
-    super(name, TYPE);
-    fieldsData = Integer.valueOf(value);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java
deleted file mode 100644
index 8367542..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInfo;
-
-/**
- * <p>
- * Field that stores a per-document <code>long</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new LongDocValuesField(name, 22L));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * */
-
-public class LongDocValuesField extends StoredField {
-
-  /**
-   * Type for 64-bit long DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
-  }
-
-  /** 
-   * Creates a new DocValues field with the specified 64-bit long value 
-   * @param name field name
-   * @param value 64-bit long value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public LongDocValuesField(String name, long value) {
-    super(name, TYPE);
-    fieldsData = Long.valueOf(value);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/NumericDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/NumericDocValuesField.java
new file mode 100644
index 0000000..708926f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/NumericDocValuesField.java
@@ -0,0 +1,57 @@
+package org.apache.lucene.document;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.FieldInfo;
+
+/**
+ * <p>
+ * Field that stores a per-document <code>long</code> value for scoring, 
+ * sorting or value retrieval. Here's an example usage:
+ * 
+ * <pre class="prettyprint">
+ *   document.add(new LongDocValuesField(name, 22L));
+ * </pre>
+ * 
+ * <p>
+ * If you also need to store the value, you should add a
+ * separate {@link StoredField} instance.
+ * */
+
+public class NumericDocValuesField extends StoredField {
+
+  /**
+   * Type for numeric DocValues.
+   */
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
+    TYPE.freeze();
+  }
+
+  /** 
+   * Creates a new DocValues field with the specified 64-bit long value 
+   * @param name field name
+   * @param value 64-bit long value
+   * @throws IllegalArgumentException if the field name is null
+   */
+  public NumericDocValuesField(String name, long value) {
+    super(name, TYPE);
+    fieldsData = Long.valueOf(value);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java
deleted file mode 100644
index 40c919f..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.AtomicReader;      // javadocs
-
-/**
- * <p>
- * Field that stores a per-document <code>long</code> value 
- * for scoring, sorting or value retrieval.  The values are 
- * encoded in the index an in RAM (when loaded via 
- * {@link AtomicReader#getNumericDocValues(String)})
- * using packed ints. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new PackedLongDocValuesField(name, 22L));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-@Deprecated
-public class PackedLongDocValuesField extends LongDocValuesField {
-
-  /** 
-   * Creates a new DocValues field with the specified long value 
-   * @param name field name
-   * @param value 64-bit long value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public PackedLongDocValuesField(String name, long value) {
-    super(name, value);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java
deleted file mode 100644
index ec0feff..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInfo;
-
-/**
- * <p>
- * Field that stores a per-document <code>short</code> value for scoring, 
- * sorting or value retrieval. Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new ShortDocValuesField(name, (short) 22));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-public class ShortDocValuesField extends StoredField {
-
-  /**
-   * Type for 16-bit short DocValues.
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.NUMERIC);
-    TYPE.freeze();
-  }
-
-  /** 
-   * Creates a new DocValues field with the specified 16-bit short value 
-   * @param name field name
-   * @param value 16-bit short value
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public ShortDocValuesField(String name, short value) {
-    super(name, TYPE);
-    fieldsData = Short.valueOf(value);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java
deleted file mode 100644
index 3e66d63..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * <p>
- * Field that stores
- * a per-document {@link BytesRef} value, indexed for
- * sorting.  Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new SortedBytesDocValuesField(name, new BytesRef("hello")));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-public class SortedBytesDocValuesField extends StoredField {
-
-  /**
-   * Type for sorted bytes DocValues: all with the same length
-   */
-  public static final FieldType TYPE = new FieldType();
-  static {
-    TYPE.setDocValueType(FieldInfo.DocValuesType.SORTED);
-    TYPE.freeze();
-  }
-
-  /**
-   * Create a new sorted DocValues field.
-   * @param name field name
-   * @param bytes binary content
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public SortedBytesDocValuesField(String name, BytesRef bytes) {
-    super(name, TYPE);
-    fieldsData = bytes;
-  }
-
-  /**
-   * Create a new fixed or variable length sorted DocValues field.
-   * @param name field name
-   * @param bytes binary content
-   * @param isFixedLength true if all values have the same length.
-   * @throws IllegalArgumentException if the field name is null
-   */
-  @Deprecated
-  public SortedBytesDocValuesField(String name, BytesRef bytes, boolean isFixedLength) {
-    super(name, TYPE);
-    fieldsData = bytes;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/document/SortedDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/SortedDocValuesField.java
new file mode 100644
index 0000000..b433289
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/SortedDocValuesField.java
@@ -0,0 +1,60 @@
+package org.apache.lucene.document;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * <p>
+ * Field that stores
+ * a per-document {@link BytesRef} value, indexed for
+ * sorting.  Here's an example usage:
+ * 
+ * <pre class="prettyprint">
+ *   document.add(new SortedBytesDocValuesField(name, new BytesRef("hello")));
+ * </pre>
+ * 
+ * <p>
+ * If you also need to store the value, you should add a
+ * separate {@link StoredField} instance.
+ * 
+ * */
+
+public class SortedDocValuesField extends StoredField {
+
+  /**
+   * Type for sorted bytes DocValues
+   */
+  public static final FieldType TYPE = new FieldType();
+  static {
+    TYPE.setDocValueType(FieldInfo.DocValuesType.SORTED);
+    TYPE.freeze();
+  }
+
+  /**
+   * Create a new sorted DocValues field.
+   * @param name field name
+   * @param bytes binary content
+   * @throws IllegalArgumentException if the field name is null
+   */
+  public SortedDocValuesField(String name, BytesRef bytes) {
+    super(name, TYPE);
+    fieldsData = bytes;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java
deleted file mode 100644
index 8c52c44..0000000
--- a/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package org.apache.lucene.document;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * <p>
- * Field that stores
- * a per-document {@link BytesRef} value.  The values are
- * stored directly with no sharing, which is a good fit when
- * the fields don't share (many) values, such as a title
- * field.  If values may be shared it's better to use {@link
- * DerefBytesDocValuesField}.  Here's an example usage:
- * 
- * <pre class="prettyprint">
- *   document.add(new StraightBytesDocValuesField(name, new BytesRef("hello")));
- * </pre>
- * 
- * <p>
- * If you also need to store the value, you should add a
- * separate {@link StoredField} instance.
- * 
- * */
-
-@Deprecated
-public class StraightBytesDocValuesField extends BinaryDocValuesField {
-
-
-  /**
-   * Create a new variable-length direct DocValues field.
-   * <p>
-   * This calls 
-   * {@link StraightBytesDocValuesField#StraightBytesDocValuesField(String, BytesRef, boolean)
-   *  StraightBytesDocValuesField(name, bytes, false}, meaning by default
-   * it allows for values of different lengths. If your values are all 
-   * the same length, use that constructor instead.
-   * @param name field name
-   * @param bytes binary content
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public StraightBytesDocValuesField(String name, BytesRef bytes) {
-    super(name, bytes);
-  }
-
-  /**
-   * Create a new fixed or variable length direct DocValues field.
-   * <p>
-   * @param name field name
-   * @param bytes binary content
-   * @param isFixedLength true if all values have the same length.
-   * @throws IllegalArgumentException if the field name is null
-   */
-  public StraightBytesDocValuesField(String name, BytesRef bytes, boolean isFixedLength) {
-    super(name, bytes);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java b/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
index 7ab8623..16c9267 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BytesDVWriter.java
@@ -17,6 +17,8 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
+import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_SIZE;
+
 import java.io.IOException;
 import java.util.Iterator;
 
@@ -50,6 +52,9 @@ class BytesDVWriter extends DocValuesWriter {
       // nocommit improve message
       throw new IllegalArgumentException("null binaryValue not allowed (field=" + fieldInfo.name + ")");
     }
+    if (value.length > (BYTE_BLOCK_SIZE - 2)) {
+      throw new IllegalArgumentException("DocValuesField \"" + fieldInfo.name + "\" is too large, must be <= " + (BYTE_BLOCK_SIZE - 2));
+    }
     
     // Fill in any holes:
     while(addedValues < docID) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java b/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
index f9a109b..0a035e8 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValuesProcessor.java
@@ -64,12 +64,10 @@ final class DocValuesProcessor extends StoredFieldsConsumer {
         addBinaryField(fieldInfo, docID, field.binaryValue());
       } else if (dvType == DocValuesType.SORTED) {
         addSortedField(fieldInfo, docID, field.binaryValue());
-        // nocommit: hack
-      } else if (dvType == DocValuesType.NUMERIC && field.numericValue() instanceof Float) {
-        addNumericField(fieldInfo, docID, field.numericValue().floatValue());
-      } else if (dvType == DocValuesType.NUMERIC && field.numericValue() instanceof Double) {
-        addNumericField(fieldInfo, docID, field.numericValue().doubleValue());
       } else if (dvType == DocValuesType.NUMERIC) {
+        if (!(field.numericValue() instanceof Long)) {
+          throw new IllegalArgumentException("illegal type " + field.numericValue().getClass() + ": DocValues types must be Long");
+        }
         addNumericField(fieldInfo, docID, field.numericValue().longValue());
       } else {
         assert false: "unrecognized DocValues.Type: " + dvType;
@@ -142,34 +140,6 @@ final class DocValuesProcessor extends StoredFieldsConsumer {
     numericWriter.addValue(docID, value);
   }
 
-  void addNumericField(FieldInfo fieldInfo, int docID, float value) {
-    DocValuesWriter writer = writers.get(fieldInfo.name);
-    NumberDVWriter numericWriter;
-    if (writer == null) {
-      numericWriter = new NumberDVWriter(fieldInfo, bytesUsed);
-      writers.put(fieldInfo.name, numericWriter);
-    } else if (!(writer instanceof NumberDVWriter)) {
-      throw new IllegalArgumentException("Incompatible DocValues type: field \"" + fieldInfo.name + "\" changed from " + getTypeDesc(writer) + " to numeric");
-    } else {
-      numericWriter = (NumberDVWriter) writer;
-    }
-    numericWriter.addValue(docID, Float.floatToRawIntBits(value));
-  }
-
-  void addNumericField(FieldInfo fieldInfo, int docID, double value) {
-    DocValuesWriter writer = writers.get(fieldInfo.name);
-    NumberDVWriter numericWriter;
-    if (writer == null) {
-      numericWriter = new NumberDVWriter(fieldInfo, bytesUsed);
-      writers.put(fieldInfo.name, numericWriter);
-    } else if (!(writer instanceof NumberDVWriter)) {
-      throw new IllegalArgumentException("Incompatible DocValues type: field \"" + fieldInfo.name + "\" changed from " + getTypeDesc(writer) + " to numeric");
-    } else {
-      numericWriter = (NumberDVWriter) writer;
-    }
-    numericWriter.addValue(docID, Double.doubleToRawLongBits(value));
-  }
-
   private String getTypeDesc(DocValuesWriter obj) {
     if (obj instanceof BytesDVWriter) {
       return "binary";
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortedBytesDVWriter.java b/lucene/core/src/java/org/apache/lucene/index/SortedBytesDVWriter.java
index 8e335eb..5205fe3 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortedBytesDVWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortedBytesDVWriter.java
@@ -17,6 +17,8 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
+import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_SIZE;
+
 import java.io.IOException;
 import java.util.Iterator;
 
@@ -63,6 +65,9 @@ class SortedBytesDVWriter extends DocValuesWriter {
       // nocommit improve message
       throw new IllegalArgumentException("null sortedValue not allowed (field=" + fieldInfo.name + ")");
     }
+    if (value.length > (BYTE_BLOCK_SIZE - 2)) {
+      throw new IllegalArgumentException("DocValuesField \"" + fieldInfo.name + "\" is too large, must be <= " + (BYTE_BLOCK_SIZE - 2));
+    }
 
     // Fill in any holes:
     while(pendingIndex < docID) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
index d805cc0..16435e5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
@@ -19,8 +19,6 @@ package org.apache.lucene.search.similarities;
 
 import java.io.IOException;
 
-import org.apache.lucene.document.ByteDocValuesField; // javadoc
-import org.apache.lucene.document.FloatDocValuesField; // javadoc
 import org.apache.lucene.index.AtomicReader; // javadoc
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.FieldInvertState;
@@ -68,8 +66,7 @@ import org.apache.lucene.util.SmallFloat; // javadoc
  * depending upon whether the average should reflect field sparsity.
  * <p>
  * Additional scoring factors can be stored in named
- * <code>*DocValuesField</code>s (such as {@link
- * ByteDocValuesField} or {@link FloatDocValuesField}), and accessed
+ * <code>NumericDocValuesField</code>s and accessed
  * at query-time with {@link AtomicReader#getNumericDocValues(String)}.
  * <p>
  * Finally, using index-time boosts (either via folding into the normalization byte or
diff --git a/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java b/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
index 5793277..19ad07e 100644
--- a/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
+++ b/lucene/core/src/test/org/apache/lucene/TestDemoDocValue.java
@@ -27,8 +27,8 @@ import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FloatDocValuesField;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DirectoryReader;
@@ -62,7 +62,7 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new LongDocValuesField("dv", 5));
+    doc.add(new NumericDocValuesField("dv", 5));
     iwriter.addDocument(doc);
     iwriter.close();
     
@@ -132,8 +132,8 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new LongDocValuesField("dv1", 5));
-    doc.add(new LongDocValuesField("dv2", 17));
+    doc.add(new NumericDocValuesField("dv1", 5));
+    doc.add(new NumericDocValuesField("dv2", 17));
     iwriter.addDocument(doc);
     iwriter.close();
     
@@ -170,7 +170,7 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new LongDocValuesField("dv1", 5));
+    doc.add(new NumericDocValuesField("dv1", 5));
     doc.add(new BinaryDocValuesField("dv2", new BytesRef("hello world")));
     iwriter.addDocument(doc);
     iwriter.close();
@@ -210,8 +210,8 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new SortedBytesDocValuesField("dv1", new BytesRef("hello hello")));
-    doc.add(new LongDocValuesField("dv2", 5));
+    doc.add(new SortedDocValuesField("dv1", new BytesRef("hello hello")));
+    doc.add(new NumericDocValuesField("dv2", 5));
     doc.add(new BinaryDocValuesField("dv3", new BytesRef("hello world")));
     iwriter.addDocument(doc);
     iwriter.close();
@@ -256,8 +256,8 @@ public class TestDemoDocValue extends LuceneTestCase {
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
     doc.add(new BinaryDocValuesField("dv1", new BytesRef("hello world")));
-    doc.add(new SortedBytesDocValuesField("dv2", new BytesRef("hello hello")));
-    doc.add(new LongDocValuesField("dv3", 5));
+    doc.add(new SortedDocValuesField("dv2", new BytesRef("hello hello")));
+    doc.add(new NumericDocValuesField("dv3", 5));
     iwriter.addDocument(doc);
     iwriter.close();
     
@@ -299,10 +299,10 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new LongDocValuesField("dv", 1));
+    doc.add(new NumericDocValuesField("dv", 1));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new LongDocValuesField("dv", 2));
+    doc.add(new NumericDocValuesField("dv", 2));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -328,12 +328,12 @@ public class TestDemoDocValue extends LuceneTestCase {
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
     doc.add(newField("id", "0", StringField.TYPE_STORED));
-    doc.add(new LongDocValuesField("dv", -10));
+    doc.add(new NumericDocValuesField("dv", -10));
     iwriter.addDocument(doc);
     iwriter.commit();
     doc = new Document();
     doc.add(newField("id", "1", StringField.TYPE_STORED));
-    doc.add(new LongDocValuesField("dv", 99));
+    doc.add(new NumericDocValuesField("dv", 99));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -366,10 +366,10 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new LongDocValuesField("dv", Long.MIN_VALUE));
+    doc.add(new NumericDocValuesField("dv", Long.MIN_VALUE));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new LongDocValuesField("dv", Long.MAX_VALUE));
+    doc.add(new NumericDocValuesField("dv", Long.MAX_VALUE));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -394,10 +394,10 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new LongDocValuesField("dv", -8841491950446638677L));
+    doc.add(new NumericDocValuesField("dv", -8841491950446638677L));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new LongDocValuesField("dv", 9062230939892376225L));
+    doc.add(new NumericDocValuesField("dv", 9062230939892376225L));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -501,7 +501,7 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world")));
     iwriter.addDocument(doc);
     iwriter.close();
     
@@ -537,10 +537,10 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 1")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 1")));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 2")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 2")));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -568,13 +568,13 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 1")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 1")));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 2")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 2")));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 1")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 1")));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -607,12 +607,12 @@ public class TestDemoDocValue extends LuceneTestCase {
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
     doc.add(newField("id", "0", StringField.TYPE_STORED));
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 1")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 1")));
     iwriter.addDocument(doc);
     iwriter.commit();
     doc = new Document();
     doc.add(newField("id", "1", StringField.TYPE_STORED));
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 2")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 2")));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -677,7 +677,7 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("hello world 2")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("hello world 2")));
     iwriter.addDocument(doc);
     // 2nd doc missing the DV field
     iwriter.addDocument(new Document());
@@ -721,7 +721,7 @@ public class TestDemoDocValue extends LuceneTestCase {
     String longTerm = "longtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongtermlongterm";
     String text = "This is the text to be indexed. " + longTerm;
     doc.add(newTextField("fieldname", text, Field.Store.YES));
-    doc.add(new LongDocValuesField("dv1", 5));
+    doc.add(new NumericDocValuesField("dv1", 5));
     doc.add(new BinaryDocValuesField("dv2", new BytesRef("hello world")));
     iwriter.addDocument(doc);
     iwriter.close();
@@ -760,10 +760,10 @@ public class TestDemoDocValue extends LuceneTestCase {
     iwc.setMergePolicy(newLogMergePolicy());
     IndexWriter iwriter = new IndexWriter(directory, iwc);
     Document doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("")));
     iwriter.addDocument(doc);
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("dv", new BytesRef("")));
+    doc.add(new SortedDocValuesField("dv", new BytesRef("")));
     iwriter.addDocument(doc);
     iwriter.forceMerge(1);
     iwriter.close();
@@ -812,4 +812,53 @@ public class TestDemoDocValue extends LuceneTestCase {
     ireader.close();
     directory.close();
   }
+  
+  // nocommit: test exactly 32766, also add field-level check so you get exc faster
+  // same for sorted bytes
+  public void testTooLargeBytes() throws IOException {
+    Analyzer analyzer = new MockAnalyzer(random());
+
+    Directory directory = newDirectory();
+    // we don't use RandomIndexWriter because it might add more docvalues than we expect !!!!1
+    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);
+    iwc.setMergePolicy(newLogMergePolicy());
+    IndexWriter iwriter = new IndexWriter(directory, iwc);
+    Document doc = new Document();
+    byte bytes[] = new byte[100000];
+    BytesRef b = new BytesRef(bytes);
+    random().nextBytes(bytes);
+    doc.add(new BinaryDocValuesField("dv", b));
+    try {
+      iwriter.addDocument(doc);
+      fail("did not get expected exception");
+    } catch (IllegalArgumentException expected) {
+      // expected
+    }
+    iwriter.close();
+
+    directory.close();
+  }
+  
+  public void testTooLargeSortedBytes() throws IOException {
+    Analyzer analyzer = new MockAnalyzer(random());
+
+    Directory directory = newDirectory();
+    // we don't use RandomIndexWriter because it might add more docvalues than we expect !!!!1
+    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer);
+    iwc.setMergePolicy(newLogMergePolicy());
+    IndexWriter iwriter = new IndexWriter(directory, iwc);
+    Document doc = new Document();
+    byte bytes[] = new byte[100000];
+    BytesRef b = new BytesRef(bytes);
+    random().nextBytes(bytes);
+    doc.add(new SortedDocValuesField("dv", b));
+    try {
+      iwriter.addDocument(doc);
+      fail("did not get expected exception");
+    } catch (IllegalArgumentException expected) {
+      // expected
+    }
+    iwriter.close();
+    directory.close();
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestField.java b/lucene/core/src/test/org/apache/lucene/document/TestField.java
index b9464d1..41aac61 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestField.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestField.java
@@ -29,44 +29,6 @@ import org.apache.lucene.util.LuceneTestCase;
 // sanity check some basics of fields
 public class TestField extends LuceneTestCase {
   
-  public void testByteDocValuesField() throws Exception {
-    ByteDocValuesField field = new ByteDocValuesField("foo", (byte) 5);
-
-    trySetBoost(field);
-    field.setByteValue((byte) 6); // ok
-    trySetBytesValue(field);
-    trySetBytesRefValue(field);
-    trySetDoubleValue(field);
-    trySetIntValue(field);
-    trySetFloatValue(field);
-    trySetLongValue(field);
-    trySetReaderValue(field);
-    trySetShortValue(field);
-    trySetStringValue(field);
-    trySetTokenStreamValue(field);
-    
-    assertEquals(6, field.numericValue().byteValue());
-  }
-  
-  public void testDerefBytesDocValuesField() throws Exception {
-    DerefBytesDocValuesField field = new DerefBytesDocValuesField("foo", new BytesRef("bar"));
-
-    trySetBoost(field);
-    trySetByteValue(field);
-    field.setBytesValue("fubar".getBytes("UTF-8"));
-    field.setBytesValue(new BytesRef("baz"));
-    trySetDoubleValue(field);
-    trySetIntValue(field);
-    trySetFloatValue(field);
-    trySetLongValue(field);
-    trySetReaderValue(field);
-    trySetShortValue(field);
-    trySetStringValue(field);
-    trySetTokenStreamValue(field);
-    
-    assertEquals(new BytesRef("baz"), field.binaryValue());
-  }
-  
   public void testDoubleField() throws Exception {
     Field fields[] = new Field[] {
         new DoubleField("foo", 5d, Field.Store.NO),
@@ -107,7 +69,7 @@ public class TestField extends LuceneTestCase {
     trySetStringValue(field);
     trySetTokenStreamValue(field);
     
-    assertEquals(6d, field.numericValue().doubleValue(), 0.0d);
+    assertEquals(6d, Double.longBitsToDouble(field.numericValue().longValue()), 0.0d);
   }
   
   public void testFloatDocValuesField() throws Exception {
@@ -126,7 +88,7 @@ public class TestField extends LuceneTestCase {
     trySetStringValue(field);
     trySetTokenStreamValue(field);
     
-    assertEquals(6f, field.numericValue().floatValue(), 0.0f);
+    assertEquals(6f, Float.intBitsToFloat(field.numericValue().intValue()), 0.0f);
   }
   
   public void testFloatField() throws Exception {
@@ -153,25 +115,6 @@ public class TestField extends LuceneTestCase {
     }
   }
   
-  public void testIntDocValuesField() throws Exception {
-    IntDocValuesField field = new IntDocValuesField("foo", 5);
-
-    trySetBoost(field);
-    trySetByteValue(field);
-    trySetBytesValue(field);
-    trySetBytesRefValue(field);
-    trySetDoubleValue(field);
-    field.setIntValue(6); // ok
-    trySetFloatValue(field);
-    trySetLongValue(field);
-    trySetReaderValue(field);
-    trySetShortValue(field);
-    trySetStringValue(field);
-    trySetTokenStreamValue(field);
-    
-    assertEquals(6, field.numericValue().intValue());
-  }
-  
   public void testIntField() throws Exception {
     Field fields[] = new Field[] {
         new IntField("foo", 5, Field.Store.NO),
@@ -196,8 +139,8 @@ public class TestField extends LuceneTestCase {
     }
   }
   
-  public void testLongDocValuesField() throws Exception {
-    LongDocValuesField field = new LongDocValuesField("foo", 5L);
+  public void testNumericDocValuesField() throws Exception {
+    NumericDocValuesField field = new NumericDocValuesField("foo", 5L);
 
     trySetBoost(field);
     trySetByteValue(field);
@@ -239,46 +182,8 @@ public class TestField extends LuceneTestCase {
     }
   }
   
-  public void testPackedLongDocValuesField() throws Exception {
-    PackedLongDocValuesField field = new PackedLongDocValuesField("foo", 5L);
-
-    trySetBoost(field);
-    trySetByteValue(field);
-    trySetBytesValue(field);
-    trySetBytesRefValue(field);
-    trySetDoubleValue(field);
-    trySetIntValue(field);
-    trySetFloatValue(field);
-    field.setLongValue(6); // ok
-    trySetReaderValue(field);
-    trySetShortValue(field);
-    trySetStringValue(field);
-    trySetTokenStreamValue(field);
-    
-    assertEquals(6L, field.numericValue().longValue());
-  }
-  
-  public void testShortDocValuesField() throws Exception {
-    ShortDocValuesField field = new ShortDocValuesField("foo", (short)5);
-
-    trySetBoost(field);
-    trySetByteValue(field);
-    trySetBytesValue(field);
-    trySetBytesRefValue(field);
-    trySetDoubleValue(field);
-    trySetIntValue(field);
-    trySetFloatValue(field);
-    trySetLongValue(field);
-    trySetReaderValue(field);
-    field.setShortValue((short) 6); // ok
-    trySetStringValue(field);
-    trySetTokenStreamValue(field);
-    
-    assertEquals((short)6, field.numericValue().shortValue());
-  }
-  
   public void testSortedBytesDocValuesField() throws Exception {
-    SortedBytesDocValuesField field = new SortedBytesDocValuesField("foo", new BytesRef("bar"));
+    SortedDocValuesField field = new SortedDocValuesField("foo", new BytesRef("bar"));
 
     trySetBoost(field);
     trySetByteValue(field);
@@ -296,8 +201,8 @@ public class TestField extends LuceneTestCase {
     assertEquals(new BytesRef("baz"), field.binaryValue());
   }
   
-  public void testStraightBytesDocValuesField() throws Exception {
-    StraightBytesDocValuesField field = new StraightBytesDocValuesField("foo", new BytesRef("bar"));
+  public void testBinaryDocValuesField() throws Exception {
+    BinaryDocValuesField field = new BinaryDocValuesField("foo", new BytesRef("bar"));
 
     trySetBoost(field);
     trySetByteValue(field);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java b/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
index 4a56af6..c4f28eb 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
@@ -30,21 +30,16 @@ import java.util.Map;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.ByteDocValuesField;
-import org.apache.lucene.document.DerefBytesDocValuesField;
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.DoubleDocValuesField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.FloatDocValuesField;
-import org.apache.lucene.document.IntDocValuesField;
 import org.apache.lucene.document.IntField;
-import org.apache.lucene.document.LongDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.LongField;
-import org.apache.lucene.document.PackedLongDocValuesField;
-import org.apache.lucene.document.ShortDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
-import org.apache.lucene.document.StraightBytesDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -697,23 +692,23 @@ public class TestBackwardsCompatibility extends LuceneTestCase {
     doc.add(new IntField("trieInt", id, Field.Store.NO));
     doc.add(new LongField("trieLong", (long) id, Field.Store.NO));
     // add docvalues fields
-    doc.add(new ByteDocValuesField("dvByte", (byte) id));
+    doc.add(new NumericDocValuesField("dvByte", (byte) id));
     byte bytes[] = new byte[] {
       (byte)(id >>> 24), (byte)(id >>> 16),(byte)(id >>> 8),(byte)id
     };
     BytesRef ref = new BytesRef(bytes);
-    doc.add(new DerefBytesDocValuesField("dvBytesDerefFixed", ref, true));
-    doc.add(new DerefBytesDocValuesField("dvBytesDerefVar", ref, false));
-    doc.add(new SortedBytesDocValuesField("dvBytesSortedFixed", ref, true));
-    doc.add(new SortedBytesDocValuesField("dvBytesSortedVar", ref, false));
-    doc.add(new StraightBytesDocValuesField("dvBytesStraightFixed", ref, true));
-    doc.add(new StraightBytesDocValuesField("dvBytesStraightVar", ref, false));
+    doc.add(new SortedDocValuesField("dvBytesDerefFixed", ref));
+    doc.add(new SortedDocValuesField("dvBytesDerefVar", ref));
+    doc.add(new SortedDocValuesField("dvBytesSortedFixed", ref));
+    doc.add(new SortedDocValuesField("dvBytesSortedVar", ref));
+    doc.add(new BinaryDocValuesField("dvBytesStraightFixed", ref));
+    doc.add(new BinaryDocValuesField("dvBytesStraightVar", ref));
     doc.add(new DoubleDocValuesField("dvDouble", (double)id));
     doc.add(new FloatDocValuesField("dvFloat", (float)id));
-    doc.add(new IntDocValuesField("dvInt", id));
-    doc.add(new LongDocValuesField("dvLong", id));
-    doc.add(new PackedLongDocValuesField("dvPacked", id));
-    doc.add(new ShortDocValuesField("dvShort", (short)id));
+    doc.add(new NumericDocValuesField("dvInt", id));
+    doc.add(new NumericDocValuesField("dvLong", id));
+    doc.add(new NumericDocValuesField("dvPacked", id));
+    doc.add(new NumericDocValuesField("dvShort", (short)id));
     // a field with both offsets and term vectors for a cross-check
     FieldType customType3 = new FieldType(TextField.TYPE_STORED);
     customType3.setStoreTermVectors(true);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
index c3f3b52..78a2f00 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
@@ -33,18 +33,11 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.ByteDocValuesField;
-import org.apache.lucene.document.DerefBytesDocValuesField;
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.DoubleDocValuesField;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FloatDocValuesField;
-import org.apache.lucene.document.IntDocValuesField;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.PackedLongDocValuesField;
-import org.apache.lucene.document.ShortDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
-import org.apache.lucene.document.StraightBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
@@ -83,7 +76,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     IndexWriter writer = new IndexWriter(dir, writerConfig(false));
     for (int i = 0; i < 5; i++) {
       Document doc = new Document();
-      doc.add(new PackedLongDocValuesField("docId", i));
+      doc.add(new NumericDocValuesField("docId", i));
       doc.add(new TextField("docId", "" + i, Field.Store.NO));
       writer.addDocument(doc);
     }
@@ -137,7 +130,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     RandomIndexWriter w = new RandomIndexWriter(random(), d1);
     Document doc = new Document();
     doc.add(newStringField("id", "1", Field.Store.YES));
-    doc.add(new PackedLongDocValuesField("dv", 1));
+    doc.add(new NumericDocValuesField("dv", 1));
     w.addDocument(doc);
     IndexReader r1 = w.getReader();
     w.close();
@@ -146,7 +139,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     w = new RandomIndexWriter(random(), d2);
     doc = new Document();
     doc.add(newStringField("id", "2", Field.Store.YES));
-    doc.add(new PackedLongDocValuesField("dv", 2));
+    doc.add(new NumericDocValuesField("dv", 2));
     w.addDocument(doc);
     IndexReader r2 = w.getReader();
     w.close();
@@ -739,7 +732,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory d = newDirectory();
     RandomIndexWriter w = new RandomIndexWriter(random(), d);
     Document doc = new Document();
-    Field f = new PackedLongDocValuesField("field", 17);
+    Field f = new NumericDocValuesField("field", 17);
     // Index doc values are single-valued so we should not
     // be able to add same field more than once:
     doc.add(f);
@@ -769,8 +762,8 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     // Index doc values are single-valued so we should not
     // be able to add same field more than once:
     Field f;
-    doc.add(f = new PackedLongDocValuesField("field", 17));
-    doc.add(new FloatDocValuesField("field", 22.0f));
+    doc.add(f = new NumericDocValuesField("field", 17));
+    doc.add(new BinaryDocValuesField("field", new BytesRef("blah")));
     try {
       w.addDocument(doc);
       fail("didn't hit expected exception");
@@ -795,9 +788,9 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Document doc = new Document();
     // Index doc values are single-valued so we should not
     // be able to add same field more than once:
-    Field f = new PackedLongDocValuesField("field", 17);
+    Field f = new NumericDocValuesField("field", 17);
     doc.add(f);
-    doc.add(new SortedBytesDocValuesField("field", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("field", new BytesRef("hello")));
     try {
       w.addDocument(doc);
       fail("didn't hit expected exception");
@@ -830,7 +823,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
         doc.add(newTextField("id", "" + i, Field.Store.YES));
         String string = _TestUtil.randomRealisticUnicodeString(random(), 1, len);
         BytesRef br = new BytesRef(string);
-        doc.add(new SortedBytesDocValuesField("field", br));
+        doc.add(new SortedDocValuesField("field", br));
         hash.add(br);
         docToString.put("" + i, string);
         w.addDocument(doc);
@@ -857,7 +850,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
         BytesRef br = new BytesRef(string);
         hash.add(br);
         docToString.put(id, string);
-        doc.add(new SortedBytesDocValuesField("field", br));
+        doc.add(new SortedDocValuesField("field", br));
         w.addDocument(doc);
       }
       w.commit();
@@ -933,8 +926,8 @@ public class TestDocValuesIndexing extends LuceneTestCase {
       }
       
       final Document doc = new Document();
-      doc.add(new SortedBytesDocValuesField("stringdv", br));
-      doc.add(new PackedLongDocValuesField("id", numDocs));
+      doc.add(new SortedDocValuesField("stringdv", br));
+      doc.add(new NumericDocValuesField("id", numDocs));
       docValues.add(br);
       writer.addDocument(doc);
       numDocs++;
@@ -1002,7 +995,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     BytesRef b = new BytesRef();
     b.bytes = bytes;
     b.length = bytes.length;
-    doc.add(new DerefBytesDocValuesField("field", b));
+    doc.add(new SortedDocValuesField("field", b));
     w.addDocument(doc);
     bytes[0] = 1;
     w.addDocument(doc);
@@ -1024,23 +1017,6 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     w.close();
     d.close();
   }
-  
-  public void testFixedLengthNotReallyFixed() throws IOException {
-    Directory d = newDirectory();
-    IndexWriter w = new IndexWriter(d, new IndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
-    Document doc = new Document();
-    doc.add(new DerefBytesDocValuesField("foo", new BytesRef("bar"), true));
-    w.addDocument(doc);
-    doc = new Document();
-    doc.add(new DerefBytesDocValuesField("foo", new BytesRef("bazz"), true));
-    try {
-      w.addDocument(doc);
-    } catch (IllegalArgumentException expected) {
-      // expected
-    }
-    w.close();
-    d.close();
-  }
 
   public void testDocValuesUnstored() throws IOException {
     //nocommit convert!
@@ -1050,7 +1026,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     IndexWriter writer = new IndexWriter(dir, iwconfig);
     for (int i = 0; i < 50; i++) {
       Document doc = new Document();
-      doc.add(new PackedLongDocValuesField("dv", i));
+      doc.add(new NumericDocValuesField("dv", i));
       doc.add(new TextField("docId", "" + i, Field.Store.YES));
       writer.addDocument(doc);
     }
@@ -1077,8 +1053,8 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new NumericDocValuesField("foo", 0));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     try {
       w.addDocument(doc);
     } catch (IllegalArgumentException iae) {
@@ -1093,11 +1069,11 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
+    doc.add(new NumericDocValuesField("foo", 0));
     w.addDocument(doc);
 
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     try {
       w.addDocument(doc);
     } catch (IllegalArgumentException iae) {
@@ -1112,12 +1088,12 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
+    doc.add(new NumericDocValuesField("foo", 0));
     w.addDocument(doc);
     w.commit();
 
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     try {
       w.addDocument(doc);
     } catch (IllegalArgumentException iae) {
@@ -1132,12 +1108,12 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
+    doc.add(new NumericDocValuesField("foo", 0));
     w.addDocument(doc);
     w.deleteAll();
 
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     w.addDocument(doc);
     w.close();
     dir.close();
@@ -1148,7 +1124,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
+    doc.add(new NumericDocValuesField("foo", 0));
     w.addDocument(doc);
     w.close();
 
@@ -1156,7 +1132,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);
     w = new IndexWriter(dir, iwc);
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     w.addDocument(doc);
     w.close();
     dir.close();
@@ -1174,11 +1150,11 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     for(int i=0;i<3;i++) {
       Field field;
       if (i == 0) {
-        field = new SortedBytesDocValuesField("foo", new BytesRef("hello"));
+        field = new SortedDocValuesField("foo", new BytesRef("hello"));
       } else if (i == 1) {
-        field = new IntDocValuesField("foo", 0);
+        field = new NumericDocValuesField("foo", 0);
       } else {
-        field = new DerefBytesDocValuesField("foo", new BytesRef("bazz"), true);
+        field = new BinaryDocValuesField("foo", new BytesRef("bazz"));
       }
       final Document doc = new Document();
       doc.add(field);
@@ -1215,14 +1191,14 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     Document doc = new Document();
-    doc.add(new IntDocValuesField("foo", 0));
+    doc.add(new NumericDocValuesField("foo", 0));
     w.addDocument(doc);
 
     // Make 2nd index w/ inconsistent field
     Directory dir2 = newDirectory();
     IndexWriter w2 = new IndexWriter(dir2, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
     doc = new Document();
-    doc.add(new SortedBytesDocValuesField("foo", new BytesRef("hello")));
+    doc.add(new SortedDocValuesField("foo", new BytesRef("hello")));
     w2.addDocument(doc);
     w2.close();
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesWithThreads.java b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesWithThreads.java
index 056b903..a4827d3 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocValuesWithThreads.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocValuesWithThreads.java
@@ -25,8 +25,8 @@ import java.util.concurrent.CountDownLatch;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -46,12 +46,12 @@ public class TestDocValuesWithThreads extends LuceneTestCase {
     for(int i=0;i<numDocs;i++) {
       Document d = new Document();
       long number = random().nextLong();
-      d.add(new LongDocValuesField("number", number));
+      d.add(new NumericDocValuesField("number", number));
       BytesRef bytes = new BytesRef(_TestUtil.randomRealisticUnicodeString(random()));
       d.add(new BinaryDocValuesField("bytes", bytes));
       binary.add(bytes);
       bytes = new BytesRef(_TestUtil.randomRealisticUnicodeString(random()));
-      d.add(new SortedBytesDocValuesField("sorted", bytes));
+      d.add(new SortedDocValuesField("sorted", bytes));
       sorted.add(bytes);
       w.addDocument(d);
       numbers.add(number);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
index 4ccb494..3a73ba2 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
@@ -38,8 +38,8 @@ import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
@@ -1021,15 +1021,15 @@ public class TestIndexWriter extends LuceneTestCase {
       doc.add(newStringField(random, "id", "500", Field.Store.NO));
       doc.add(newField(random, "field", "some prepackaged text contents", storedTextType));
       doc.add(new BinaryDocValuesField("binarydv", new BytesRef("500")));
-      doc.add(new LongDocValuesField("numericdv", 500));
-      doc.add(new SortedBytesDocValuesField("sorteddv", new BytesRef("500")));
+      doc.add(new NumericDocValuesField("numericdv", 500));
+      doc.add(new SortedDocValuesField("sorteddv", new BytesRef("500")));
       w.addDocument(doc);
       doc = new Document();
       doc.add(newStringField(random, "id", "501", Field.Store.NO));
       doc.add(newField(random, "field", "some more contents", storedTextType));
       doc.add(new BinaryDocValuesField("binarydv", new BytesRef("501")));
-      doc.add(new LongDocValuesField("numericdv", 501));
-      doc.add(new SortedBytesDocValuesField("sorteddv", new BytesRef("501")));
+      doc.add(new NumericDocValuesField("numericdv", 501));
+      doc.add(new SortedDocValuesField("sorteddv", new BytesRef("501")));
       w.addDocument(doc);
       w.deleteDocuments(new Term("id", "500"));
       w.close();
@@ -1055,8 +1055,8 @@ public class TestIndexWriter extends LuceneTestCase {
             Document doc = new Document();
             Field idField = newStringField(random, "id", "", Field.Store.NO);
             Field binaryDVField = new BinaryDocValuesField("binarydv", new BytesRef());
-            Field numericDVField = new LongDocValuesField("numericdv", 0);
-            Field sortedDVField = new SortedBytesDocValuesField("sorteddv", new BytesRef());
+            Field numericDVField = new NumericDocValuesField("numericdv", 0);
+            Field sortedDVField = new SortedDocValuesField("sorteddv", new BytesRef());
             doc.add(idField);
             doc.add(newField(random, "field", "some text contents", storedTextType));
             doc.add(binaryDVField);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete.java
index fe31660..9798932 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete.java
@@ -32,7 +32,7 @@ import org.apache.lucene.analysis.*;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.LongDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.ScoreDoc;
@@ -390,7 +390,7 @@ public class TestIndexWriterDelete extends LuceneTestCase {
     doc.add(newTextField("content", "aaa", Field.Store.NO));
     doc.add(newStringField("id", String.valueOf(id), Field.Store.YES));
     doc.add(newStringField("value", String.valueOf(value), Field.Store.NO));
-    doc.add(new LongDocValuesField("dv", value));
+    doc.add(new NumericDocValuesField("dv", value));
     modifier.updateDocument(new Term("id", String.valueOf(id)), doc);
   }
 
@@ -401,7 +401,7 @@ public class TestIndexWriterDelete extends LuceneTestCase {
     doc.add(newTextField("content", "aaa", Field.Store.NO));
     doc.add(newStringField("id", String.valueOf(id), Field.Store.YES));
     doc.add(newStringField("value", String.valueOf(value), Field.Store.NO));
-    doc.add(new LongDocValuesField("dv", value));
+    doc.add(new NumericDocValuesField("dv", value));
     modifier.addDocument(doc);
   }
 
@@ -440,7 +440,7 @@ public class TestIndexWriterDelete extends LuceneTestCase {
       Document d = new Document();
       d.add(newStringField("id", Integer.toString(i), Field.Store.YES));
       d.add(newTextField("content", "aaa " + i, Field.Store.NO));
-      d.add(new LongDocValuesField("dv", i));
+      d.add(new NumericDocValuesField("dv", i));
       writer.addDocument(d);
     }
     writer.close();
@@ -519,7 +519,7 @@ public class TestIndexWriterDelete extends LuceneTestCase {
                 Document d = new Document();
                 d.add(newStringField("id", Integer.toString(i), Field.Store.YES));
                 d.add(newTextField("content", "bbb " + i, Field.Store.NO));
-                d.add(new LongDocValuesField("dv", i));
+                d.add(new NumericDocValuesField("dv", i));
                 modifier.updateDocument(new Term("id", Integer.toString(docId)), d);
               } else { // deletes
                 modifier.deleteDocuments(new Term("id", Integer.toString(docId)));
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
index 8a582ca..6bf5feb 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java
@@ -31,8 +31,8 @@ import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
@@ -140,9 +140,9 @@ public class TestIndexWriterExceptions extends LuceneTestCase {
 
       doc.add(newTextField(r, "content4", "aaa bbb ccc ddd", Field.Store.NO));
       doc.add(newStringField(r, "content5", "aaa bbb ccc ddd", Field.Store.NO));
-      doc.add(new LongDocValuesField("numericdv", 5));
+      doc.add(new NumericDocValuesField("numericdv", 5));
       doc.add(new BinaryDocValuesField("binarydv", new BytesRef("hello")));
-      doc.add(new SortedBytesDocValuesField("sorteddv", new BytesRef("world")));
+      doc.add(new SortedDocValuesField("sorteddv", new BytesRef("world")));
 
       doc.add(newField(r, "content7", "aaa bbb ccc ddd", DocCopyIterator.custom4));
 
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnDiskFull.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnDiskFull.java
index e000deb..1928e29 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnDiskFull.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnDiskFull.java
@@ -24,7 +24,7 @@ import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.LongDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.IndexSearcher;
@@ -558,7 +558,7 @@ public class TestIndexWriterOnDiskFull extends LuceneTestCase {
   {
       Document doc = new Document();
       doc.add(newTextField("content", "aaa", Field.Store.NO));
-      doc.add(new LongDocValuesField("numericdv", 1));
+      doc.add(new NumericDocValuesField("numericdv", 1));
       writer.addDocument(doc);
   }
   
@@ -567,7 +567,7 @@ public class TestIndexWriterOnDiskFull extends LuceneTestCase {
       Document doc = new Document();
       doc.add(newTextField("content", "aaa " + index, Field.Store.NO));
       doc.add(newTextField("id", "" + index, Field.Store.NO));
-      doc.add(new LongDocValuesField("numericdv", 1));
+      doc.add(new NumericDocValuesField("numericdv", 1));
       writer.addDocument(doc);
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
index f7ac765..a9f1710 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
@@ -28,7 +28,7 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.LongDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -75,7 +75,7 @@ public class TestIndexWriterWithThreads extends LuceneTestCase {
       customType.setStoreTermVectorOffsets(true);
       
       doc.add(newField("field", "aaa bbb ccc ddd eee fff ggg hhh iii jjj", customType));
-      doc.add(new LongDocValuesField("dv", 5));
+      doc.add(new NumericDocValuesField("dv", 5));
 
       int idUpto = 0;
       int fullCount = 0;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
index 8090754..5df6a43 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesScoring.java
@@ -31,7 +31,6 @@ import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -49,7 +48,7 @@ public class TestDocValuesScoring extends LuceneTestCase {
     Document doc = new Document();
     Field field = newTextField("foo", "", Field.Store.NO);
     doc.add(field);
-    Field dvField = new FloatDocValuesField("foo_boost", 0.0f);
+    Field dvField = new FloatDocValuesField("foo_boost", 0.0F);
     doc.add(dvField);
     Field field2 = newTextField("bar", "", Field.Store.NO);
     doc.add(field2);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
index d6b0b28..0bd23cb 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
@@ -19,16 +19,16 @@ package org.apache.lucene.search;
 
 import java.util.Arrays;
 
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FloatDocValuesField;
 import org.apache.lucene.document.FloatField;
-import org.apache.lucene.document.IntDocValuesField;
 import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.LongField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
-import org.apache.lucene.document.StraightBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
@@ -67,11 +67,11 @@ public class TestSearchAfter extends LuceneTestCase {
       document.add(newStringField("bytesval", _TestUtil.randomRealisticUnicodeString(random()), Field.Store.NO));
       document.add(new DoubleField("double", random().nextDouble(), Field.Store.NO));
 
-      document.add(new IntDocValuesField("intdocvalues", random().nextInt()));
+      document.add(new NumericDocValuesField("intdocvalues", random().nextInt()));
       document.add(new FloatDocValuesField("floatdocvalues", random().nextFloat()));
-      document.add(new SortedBytesDocValuesField("sortedbytesdocvalues", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
-      document.add(new SortedBytesDocValuesField("sortedbytesdocvaluesval", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
-      document.add(new StraightBytesDocValuesField("straightbytesdocvalues", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
+      document.add(new SortedDocValuesField("sortedbytesdocvalues", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
+      document.add(new SortedDocValuesField("sortedbytesdocvaluesval", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
+      document.add(new BinaryDocValuesField("straightbytesdocvalues", new BytesRef(_TestUtil.randomRealisticUnicodeString(random()))));
 
       iw.addDocument(document);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSort.java b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
index 8fea59a..7217e20 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
@@ -31,15 +31,12 @@ import java.util.concurrent.TimeUnit;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.BinaryDocValuesField;
-import org.apache.lucene.document.DerefBytesDocValuesField;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.DoubleDocValuesField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.FloatDocValuesField;
-import org.apache.lucene.document.PackedLongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
-import org.apache.lucene.document.StraightBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.AtomicReaderContext;
@@ -61,7 +58,6 @@ import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.DocIdBitSet;
 import org.apache.lucene.util.FixedBitSet;
-import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util._TestUtil;
@@ -156,7 +152,7 @@ public class TestSort extends LuceneTestCase {
         doc.add(new TextField("contents", data[i][1], Field.Store.NO));
         if (data[i][2] != null) {
           doc.add(new StringField("int", data[i][2], Field.Store.NO));
-          doc.add(new PackedLongDocValuesField("int_dv", Integer.parseInt(data[i][2])));
+          doc.add(new NumericDocValuesField("int_dv", Integer.parseInt(data[i][2])));
         }
         if (data[i][3] != null) {
           doc.add(new StringField("float", data[i][3], Field.Store.NO));
@@ -166,7 +162,7 @@ public class TestSort extends LuceneTestCase {
           doc.add(new StringField("string", data[i][4], Field.Store.NO));
           switch(stringDVType) {
             case SORTED:
-              doc.add(new SortedBytesDocValuesField("string_dv", new BytesRef(data[i][4])));
+              doc.add(new SortedDocValuesField("string_dv", new BytesRef(data[i][4])));
               break;
             case BINARY:
               doc.add(new BinaryDocValuesField("string_dv", new BytesRef(data[i][4])));
@@ -180,7 +176,7 @@ public class TestSort extends LuceneTestCase {
         if (data[i][7] != null) doc.add(new StringField("long",     data[i][7], Field.Store.NO));
         if (data[i][8] != null) {
           doc.add(new StringField("double", data[i][8], Field.Store.NO));
-          doc.add(new DoubleDocValuesField("double_dv", Double.parseDouble(data[i][8])));
+          doc.add(new NumericDocValuesField("double_dv", Double.doubleToRawLongBits(Double.parseDouble(data[i][8]))));
         }
         if (data[i][9] != null) doc.add(new StringField("short",     data[i][9], Field.Store.NO));
         if (data[i][10] != null) doc.add(new StringField("byte",     data[i][10], Field.Store.NO));
@@ -225,16 +221,16 @@ public class TestSort extends LuceneTestCase {
       //doc.add(new Field("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string", num, Field.Store.NO));
       if (dvStringSorted) {
-        doc.add(new SortedBytesDocValuesField("string_dv", new BytesRef(num)));
+        doc.add(new SortedDocValuesField("string_dv", new BytesRef(num)));
       } else {
-        doc.add(new DerefBytesDocValuesField("string_dv", new BytesRef(num)));
+        doc.add(new BinaryDocValuesField("string_dv", new BytesRef(num)));
       }
       String num2 = getRandomCharString(getRandomNumber(1, 4), 48, 50);
       doc.add(new StringField("string2", num2, Field.Store.NO));
       if (dvStringSorted) {
-        doc.add(new SortedBytesDocValuesField("string2_dv", new BytesRef(num2)));
+        doc.add(new SortedDocValuesField("string2_dv", new BytesRef(num2)));
       } else {
-        doc.add(new DerefBytesDocValuesField("string2_dv", new BytesRef(num2)));
+        doc.add(new BinaryDocValuesField("string2_dv", new BytesRef(num2)));
       }
       doc.add(new Field("tracer2", num2, onlyStored));
       for(IndexableField f2 : doc.getFields()) {
@@ -248,16 +244,16 @@ public class TestSort extends LuceneTestCase {
       //doc.add(new Field("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string_fixed", numFixed, Field.Store.NO));
       if (dvStringSorted) {
-        doc.add(new SortedBytesDocValuesField("string_fixed_dv", new BytesRef(numFixed), true));
+        doc.add(new SortedDocValuesField("string_fixed_dv", new BytesRef(numFixed)));
       } else {
-        doc.add(new DerefBytesDocValuesField("string_fixed_dv", new BytesRef(numFixed), true));
+        doc.add(new BinaryDocValuesField("string_fixed_dv", new BytesRef(numFixed)));
       }
       String num2Fixed = getRandomCharString(fixedLen2, 48, 52);
       doc.add(new StringField("string2_fixed", num2Fixed, Field.Store.NO));
       if (dvStringSorted) {
-        doc.add(new SortedBytesDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed), true));
+        doc.add(new SortedDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed)));
       } else {
-        doc.add(new DerefBytesDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed), true));
+        doc.add(new BinaryDocValuesField("string2_fixed_dv", new BytesRef(num2Fixed)));
       }
       doc.add(new Field("tracer2_fixed", num2Fixed, onlyStored));
 
@@ -1423,9 +1419,9 @@ public class TestSort extends LuceneTestCase {
       }
       
       final Document doc = new Document();
-      doc.add(new SortedBytesDocValuesField("stringdv", br));
+      doc.add(new SortedDocValuesField("stringdv", br));
       doc.add(newStringField("string", s, Field.Store.NO));
-      doc.add(new PackedLongDocValuesField("id", numDocs));
+      doc.add(new NumericDocValuesField("id", numDocs));
       docValues.add(br);
       writer.addDocument(doc);
       numDocs++;
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java b/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
index db6c595..a17265e 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/index/FacetFields.java
@@ -8,10 +8,10 @@ import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.StraightBytesDocValuesField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
@@ -154,7 +154,7 @@ public class FacetFields {
    */
   protected void addCountingListData(Document doc, Map<String,BytesRef> categoriesData, String field) {
     for (Entry<String,BytesRef> entry : categoriesData.entrySet()) {
-      doc.add(new StraightBytesDocValuesField(field + entry.getKey(), entry.getValue()));
+      doc.add(new BinaryDocValuesField(field + entry.getKey(), entry.getValue()));
     }
   }
   
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/search/CategoryListIteratorTest.java b/lucene/facet/src/test/org/apache/lucene/facet/search/CategoryListIteratorTest.java
index 9f3c977..26f1cd5 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/search/CategoryListIteratorTest.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/search/CategoryListIteratorTest.java
@@ -5,8 +5,8 @@ import java.util.Set;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.StraightBytesDocValuesField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -57,7 +57,7 @@ public class CategoryListIteratorTest extends LuceneTestCase {
     for (int i = 0; i < data.length; i++) {
       Document doc = new Document();
       encoder.encode(IntsRef.deepCopyOf(data[i]), buf);
-      doc.add(new StraightBytesDocValuesField("f", buf));
+      doc.add(new BinaryDocValuesField("f", buf));
       writer.addDocument(doc);
     }
     IndexReader reader = writer.getReader();
@@ -100,9 +100,9 @@ public class CategoryListIteratorTest extends LuceneTestCase {
       if (i == 0) {
         BytesRef buf = new BytesRef();
         encoder.encode(IntsRef.deepCopyOf(data[i]), buf );
-        doc.add(new StraightBytesDocValuesField("f", buf));
+        doc.add(new BinaryDocValuesField("f", buf));
       } else {
-        doc.add(new StraightBytesDocValuesField("f", new BytesRef()));
+        doc.add(new BinaryDocValuesField("f", new BytesRef()));
       }
       writer.addDocument(doc);
       writer.commit();
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
index 0aad4ee..da985d7 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
@@ -212,10 +212,10 @@ public class AllGroupHeadsCollectorTest extends LuceneTestCase {
       if (canUseIDV) {
         switch(valueType) {
         case BINARY:
-          valuesField = new StraightBytesDocValuesField("group_dv", new BytesRef());
+          valuesField = new BinaryDocValuesField("group_dv", new BytesRef());
           break;
         case SORTED:
-          valuesField = new SortedBytesDocValuesField("group_dv", new BytesRef());
+          valuesField = new SortedDocValuesField("group_dv", new BytesRef());
           break;
         default:
           fail("unhandled type");
@@ -537,10 +537,10 @@ public class AllGroupHeadsCollectorTest extends LuceneTestCase {
       Field valuesField = null;
       switch(valueType) {
       case BINARY:
-        valuesField = new StraightBytesDocValuesField(groupField + "_dv", new BytesRef(value));
+        valuesField = new BinaryDocValuesField(groupField + "_dv", new BytesRef(value));
         break;
       case SORTED:
-        valuesField = new SortedBytesDocValuesField(groupField + "_dv", new BytesRef(value));
+        valuesField = new SortedDocValuesField(groupField + "_dv", new BytesRef(value));
         break;
       default:
         fail("unhandled type");
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
index 74ee3ae..57cc566 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
@@ -121,7 +121,7 @@ public class AllGroupsCollectorTest extends LuceneTestCase {
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
     doc.add(new TextField(groupField, value, Field.Store.YES));
     if (canUseIDV) {
-      doc.add(new SortedBytesDocValuesField(groupField, new BytesRef(value)));
+      doc.add(new SortedDocValuesField(groupField, new BytesRef(value)));
     }
   }
 
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/DistinctValuesCollectorTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/DistinctValuesCollectorTest.java
index ac0d3f9..43f843c 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/DistinctValuesCollectorTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/DistinctValuesCollectorTest.java
@@ -354,16 +354,16 @@ public class DistinctValuesCollectorTest extends AbstractGroupingTestCase {
     Field valuesField = null;
     switch (type) {
       case NUMERIC:
-        valuesField = new PackedLongDocValuesField(dvField, Integer.parseInt(value));
+        valuesField = new NumericDocValuesField(dvField, Integer.parseInt(value));
         break;
       /* nocommit: case FLOAT_64:
         valuesField = new DoubleDocValuesField(dvField, Double.parseDouble(value));
         break; */
       case BINARY:
-        valuesField = new StraightBytesDocValuesField(dvField, new BytesRef(value));
+        valuesField = new BinaryDocValuesField(dvField, new BytesRef(value));
         break;
       case SORTED:
-        valuesField = new SortedBytesDocValuesField(dvField, new BytesRef(value));
+        valuesField = new SortedDocValuesField(dvField, new BytesRef(value));
         break;
     }
     doc.add(valuesField);
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java
index 2f0dd52..1b0ac64 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupFacetCollectorTest.java
@@ -332,7 +332,7 @@ public class GroupFacetCollectorTest extends AbstractGroupingTestCase {
   private void addField(Document doc, String field, String value, boolean canUseIDV) {
     doc.add(new StringField(field, value, Field.Store.NO));
     if (canUseIDV) {
-      doc.add(new SortedBytesDocValuesField(field + "_dv", new BytesRef(value)));
+      doc.add(new SortedDocValuesField(field + "_dv", new BytesRef(value)));
     }
   }
 
@@ -488,7 +488,7 @@ public class GroupFacetCollectorTest extends AbstractGroupingTestCase {
     Document docNoFacet = new Document();
     Document docNoGroupNoFacet = new Document();
     Field group = newStringField("group", "", Field.Store.NO);
-    Field groupDc = new SortedBytesDocValuesField("group_dv", new BytesRef());
+    Field groupDc = new SortedDocValuesField("group_dv", new BytesRef());
     if (useDv) {
       doc.add(groupDc);
       docNoFacet.add(groupDc);
@@ -502,7 +502,7 @@ public class GroupFacetCollectorTest extends AbstractGroupingTestCase {
       facetFields[0] = newStringField("facet", "", Field.Store.NO);
       doc.add(facetFields[0]);
       docNoGroup.add(facetFields[0]);
-      facetFields[1] = new SortedBytesDocValuesField("facet_dv", new BytesRef());
+      facetFields[1] = new SortedDocValuesField("facet_dv", new BytesRef());
       doc.add(facetFields[1]);
       docNoGroup.add(facetFields[1]);
     } else {
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupingSearchTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupingSearchTest.java
index 194fd46..067673d 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupingSearchTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/GroupingSearchTest.java
@@ -21,7 +21,7 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -176,7 +176,7 @@ public class GroupingSearchTest extends LuceneTestCase {
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
     doc.add(new TextField(groupField, value, Field.Store.YES));
     if (canUseIDV) {
-      doc.add(new SortedBytesDocValuesField(groupField, new BytesRef(value)));
+      doc.add(new SortedDocValuesField(groupField, new BytesRef(value)));
     }
   }
 
diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index 44d4bfd..7cb69ce 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -175,7 +175,7 @@ public class TestGrouping extends LuceneTestCase {
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
     doc.add(new TextField(groupField, value, Field.Store.YES));
     if (canUseIDV) {
-      doc.add(new SortedBytesDocValuesField(groupField + "_dv", new BytesRef(value)));
+      doc.add(new SortedDocValuesField(groupField + "_dv", new BytesRef(value)));
     }
   }
 
@@ -677,7 +677,7 @@ public class TestGrouping extends LuceneTestCase {
 
       Document doc = new Document();
       Document docNoGroup = new Document();
-      Field idvGroupField = new SortedBytesDocValuesField("group_dv", new BytesRef());
+      Field idvGroupField = new SortedDocValuesField("group_dv", new BytesRef());
       if (canUseIDV) {
         doc.add(idvGroupField);
         docNoGroup.add(idvGroupField);
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
index 9da4aef..398c959 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestDocValuesFieldSources.java
@@ -23,9 +23,8 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.IntDocValuesField;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
@@ -49,17 +48,17 @@ public class TestDocValuesFieldSources extends LuceneTestCase {
     Directory d = newDirectory();
     IndexWriterConfig iwConfig = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));
     final int nDocs = atLeast(50);
-    final Field id = new IntDocValuesField("id", 0);
+    final Field id = new NumericDocValuesField("id", 0);
     final Field f;
     switch (type) {
       case BINARY:
         f = new BinaryDocValuesField("dv", new BytesRef());
         break;
       case SORTED:
-        f = new SortedBytesDocValuesField("dv", new BytesRef());
+        f = new SortedDocValuesField("dv", new BytesRef());
         break;
       case NUMERIC:
-        f = new LongDocValuesField("dv", 0);
+        f = new NumericDocValuesField("dv", 0);
         break;
       default:
         throw new AssertionError();
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java b/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
index 38e49a2..eb50843 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter.java
@@ -26,18 +26,10 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.document.BinaryDocValuesField;
-import org.apache.lucene.document.ByteDocValuesField; 
-import org.apache.lucene.document.DerefBytesDocValuesField; 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.DoubleDocValuesField; 
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FloatDocValuesField; 
-import org.apache.lucene.document.IntDocValuesField; 
-import org.apache.lucene.document.LongDocValuesField; 
-import org.apache.lucene.document.PackedLongDocValuesField; 
-import org.apache.lucene.document.ShortDocValuesField; 
-import org.apache.lucene.document.SortedBytesDocValuesField; 
-import org.apache.lucene.document.StraightBytesDocValuesField; 
+import org.apache.lucene.document.NumericDocValuesField; 
+import org.apache.lucene.document.SortedDocValuesField; 
 import org.apache.lucene.index.FieldInfo.DocValuesType;
 import org.apache.lucene.index.IndexWriter; // javadoc
 import org.apache.lucene.search.Query;
@@ -234,10 +226,10 @@ public class RandomIndexWriter implements Closeable {
       f = new BinaryDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));
       break;
     case SORTED:
-      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));
+      f = new SortedDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));
       break;
     case NUMERIC:
-      f = new LongDocValuesField(name, r.nextLong());
+      f = new NumericDocValuesField(name, r.nextLong());
       break;
     default:
       throw new IllegalArgumentException("no such type: " + type);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java b/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
index c0c721f..93f1f24 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LineFileDocs.java
@@ -36,7 +36,7 @@ import java.util.zip.GZIPInputStream;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 
@@ -184,7 +184,7 @@ public class LineFileDocs implements Closeable {
       doc.add(date);
 
       if (useDocValues) {
-        titleDV = new SortedBytesDocValuesField("titleDV", new BytesRef());
+        titleDV = new SortedDocValuesField("titleDV", new BytesRef());
         doc.add(titleDV);
       } else {
         titleDV = null;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/RunListenerPrintReproduceInfo.java b/lucene/test-framework/src/java/org/apache/lucene/util/RunListenerPrintReproduceInfo.java
index 1422992..fa7754e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/RunListenerPrintReproduceInfo.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/RunListenerPrintReproduceInfo.java
@@ -150,6 +150,7 @@ public final class RunListenerPrintReproduceInfo extends RunListener {
     // Codec, postings, directories.
     if (!TEST_CODEC.equals("random")) addVmOpt(b, "tests.codec", TEST_CODEC);
     if (!TEST_POSTINGSFORMAT.equals("random")) addVmOpt(b, "tests.postingsformat", TEST_POSTINGSFORMAT);
+    if (!TEST_DOCVALUESFORMAT.equals("random")) addVmOpt(b, "tests.docvaluesformat", TEST_DOCVALUESFORMAT);
     if (!TEST_DIRECTORY.equals("random")) addVmOpt(b, "tests.directory", TEST_DIRECTORY);
 
     // Environment.
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
index 6cd78fd..f93251e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleSetupAndRestoreClassEnv.java
@@ -151,11 +151,12 @@ final class TestRuleSetupAndRestoreClassEnv extends AbstractBeforeAfterRule {
       codec = Codec.forName("Lucene41");
       assert codec instanceof Lucene41RWCodec : "fix your classpath to have tests-framework.jar before lucene-core.jar";
     } else if (("random".equals(TEST_POSTINGSFORMAT) == false) || ("random".equals(TEST_DOCVALUESFORMAT) == false)) {
-      // the user wired postings or DV
+      // the user wired postings or DV: this is messy
+      // refactor into RandomCodec....
       
       final PostingsFormat format;
-      if ("MockRandom".equals(TEST_POSTINGSFORMAT) || "random".equals(TEST_POSTINGSFORMAT)) {
-        format = new MockRandomPostingsFormat(random);
+      if ("random".equals(TEST_POSTINGSFORMAT)) {
+        format = PostingsFormat.forName("Lucene41");
       } else {
         format = PostingsFormat.forName(TEST_POSTINGSFORMAT);
       }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
index 599e7fc..da7bff0 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
@@ -47,12 +47,10 @@ import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.lucene42.Lucene42Codec;
 import org.apache.lucene.codecs.perfield.PerFieldPostingsFormat;
 import org.apache.lucene.document.BinaryDocValuesField;
-import org.apache.lucene.document.ByteDocValuesField;
-import org.apache.lucene.document.DerefBytesDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.LongDocValuesField;
-import org.apache.lucene.document.SortedBytesDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.CheckIndex;
 import org.apache.lucene.index.CheckIndex.Status.DocValuesStatus;
@@ -863,13 +861,13 @@ public class _TestUtil {
         switch(dvType) {
           // nocommit: not quite right!
         case NUMERIC:
-          field2 = new LongDocValuesField(field1.name(), field1.numericValue().longValue());
+          field2 = new NumericDocValuesField(field1.name(), field1.numericValue().longValue());
           break;
         case BINARY:
           field2 = new BinaryDocValuesField(field1.name(), field1.binaryValue());
           break;
         case SORTED:
-          field2 = new SortedBytesDocValuesField(field1.name(), field1.binaryValue());
+          field2 = new SortedDocValuesField(field1.name(), field1.binaryValue());
           break;
         default:
           throw new IllegalStateException("unknown Type: " + dvType);

