GitDiffStart: b36bfbf73311e9b52d66a9af458a773c7db53b11 | Wed Sep 26 01:11:52 2012 +0000
diff --git a/solr/core/src/java/org/apache/solr/util/SuggestMissingFactories.java b/solr/core/src/java/org/apache/solr/util/SuggestMissingFactories.java
deleted file mode 100644
index fe2a5ce..0000000
--- a/solr/core/src/java/org/apache/solr/util/SuggestMissingFactories.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.io.Reader;
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.net.MalformedURLException;
-import java.util.Collection;
-import java.util.Map;
-import java.util.HashSet;
-import java.util.HashMap;
-import java.util.Enumeration;
-import java.util.jar.*;
-
-/**
- * Given a list of Jar files, suggest missing analysis factories.
- *
- *
- */
-public class SuggestMissingFactories {
-
-    public static void main(String[] args) throws ClassNotFoundException, IOException, NoSuchMethodException {
-
-        final File[] files = new File[args.length];
-        for (int i = 0; i < args.length; i++) {
-            files[i] = new File(args[i]);
-        }
-        final FindClasses finder = new FindClasses(files);
-        final ClassLoader cl = finder.getClassLoader();
-
-        final Class TOKENSTREAM
-            = cl.loadClass("org.apache.lucene.analysis.TokenStream");
-        final Class TOKENIZER
-            = cl.loadClass("org.apache.lucene.analysis.Tokenizer");
-        final Class TOKENFILTER
-            = cl.loadClass("org.apache.lucene.analysis.TokenFilter");
-        final Class TOKENIZERFACTORY
-            = cl.loadClass("org.apache.solr.analysis.TokenizerFactory");
-        final Class TOKENFILTERFACTORY
-            = cl.loadClass("org.apache.solr.analysis.TokenFilterFactory");
-        
-        
-        final HashSet<Class> result
-            = new HashSet<Class>(finder.findExtends(TOKENIZER));
-        result.addAll(finder.findExtends(TOKENFILTER));
-        
-        result.removeAll(finder.findMethodReturns
-                         (finder.findExtends(TOKENIZERFACTORY),
-                          "create",
-                          Reader.class).values());
-        result.removeAll(finder.findMethodReturns
-                         (finder.findExtends(TOKENFILTERFACTORY),
-                          "create",
-                          TOKENSTREAM).values());
-        
-        for (final Class c : result) {
-            System.out.println(c.getName());
-        }
-    }
-    
-}
-
-/**
- * Takes in a clazz name and a jar and finds
- * all classes in that jar that extend clazz.
- */
-class FindClasses {
-
-  /**
-   * Simple command line test method
-   */
-  public static void main(String[] args)
-    throws ClassNotFoundException, IOException, NoSuchMethodException {
-
-    FindClasses finder = new FindClasses(new File(args[1]));
-    ClassLoader cl = finder.getClassLoader();
-    Class clazz = cl.loadClass(args[0]);
-    if (args.length == 2) {
-            
-      System.out.println("Finding all extenders of " + clazz.getName());
-      for (Class c : finder.findExtends(clazz)) {
-        System.out.println(c.getName());
-      }
-    } else {
-      String methName = args[2];
-      System.out.println("Finding all extenders of " + clazz.getName() +
-                         " with method: " + methName);
-            
-      Class[] methArgs = new Class[args.length-3];
-      for (int i = 3; i < args.length; i++) {
-        methArgs[i-3] = cl.loadClass(args[i]);
-      }
-      Map<Class,Class> map = finder.findMethodReturns
-        (finder.findExtends(clazz),methName, methArgs);
-
-      for (Class key : map.keySet()) {
-        System.out.println(key.getName() + " => " + map.get(key).getName());
-      }
-           
-
-    }
-  }
-
-  private JarFile[] jarFiles;
-  private ClassLoader cl;
-  public FindClasses(File... jars) throws IOException {
-
-        
-    jarFiles = new JarFile[jars.length];
-    URL[] urls = new URL[jars.length];
-    try {
-      for (int i =0; i < jars.length; i++) {
-        jarFiles[i] = new JarFile(jars[i]);
-        urls[i] = jars[i].toURI().toURL();
-      }
-    } catch (MalformedURLException e) {
-      throw new RuntimeException
-        ("WTF, how can JarFile.toURL() be malformed?", e);
-    }
-        
-    this.cl = new URLClassLoader(urls, this.getClass().getClassLoader());
-  }
-
-  /**
-   * returns a class loader that includes the jar used to
-   * construct this instance
-   */
-  public ClassLoader getClassLoader() {
-    return this.cl;
-  }
-    
-  /**
-   * Find useful concrete (ie: not anonymous, not abstract, not an interface)
-   * classes that extend clazz
-   */
-  public Collection<Class> findExtends(Class<?> clazz)
-    throws ClassNotFoundException {
-        
-    HashSet<Class> results = new HashSet<Class>();
-
-    for (JarFile jarFile : jarFiles) {
-      for (Enumeration<JarEntry> e = jarFile.entries();
-           e.hasMoreElements() ;) {
-                
-        String n = e.nextElement().getName();
-        if (n.endsWith(".class")) {
-          String cn = n.replace("/",".").substring(0,n.length()-6);
-          Class<?> target;
-          try {
-            target = cl.loadClass(cn);
-          } catch (NoClassDefFoundError e1) {
-            throw new ClassNotFoundException
-              ("Can't load: " + cn, e1);
-          }
-                                                        
-          if (clazz.isAssignableFrom(target)
-              && !target.isAnonymousClass()) {
-                        
-            int mods = target.getModifiers();
-            if (!(Modifier.isAbstract(mods) ||
-                  Modifier.isInterface(mods))) {
-              results.add(target);
-            }
-          }
-        }
-      }
-    }
-    return results;
-  }
-
-  /**
-   * Given a collection of classes, returns a Map containing the
-   * subset of those classes that impliment the method specified,
-   * where the value in the map is the return type of the method
-   */
-  public Map<Class,Class> findMethodReturns(Collection<Class> clazzes,
-                                            String methodName,
-                                            Class... parameterTypes)
-    throws NoSuchMethodException{
-
-    HashMap<Class,Class> results = new HashMap<Class,Class>();
-    for (Class clazz : clazzes) {
-      try {
-        Method m = clazz.getMethod(methodName, parameterTypes);
-        results.put(clazz, m.getReturnType());
-      } catch (NoSuchMethodException e) {
-        /* :NOOP: we expect this and skip clazz */
-      }
-    }
-    return results;
-  }
-}
-
diff --git a/solr/dev-tools/stub-analysis-factory-maker.pl b/solr/dev-tools/stub-analysis-factory-maker.pl
deleted file mode 100755
index b83ae17..0000000
--- a/solr/dev-tools/stub-analysis-factory-maker.pl
+++ /dev/null
@@ -1,166 +0,0 @@
-#!/usr/bin/perl
-my $ASL = q{
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-};
-
-# $Id:$
-# $URL:$
-#
-# What this script does...
-#
-# 1) reads a list of fully qualified package.ClassNames from STDIN
-# 2) gets a list of src dirs from command line
-# 3) crawl the source dirs, looking for .java files corrisponding to 
-#    the ClassNames, if a match is found, creates a factory for it in
-#    the current working directory using info about the constructor
-#    in the orriginal .java file
-#
-# Note...
-#  * any ClassNames not found will be logged to stdout
-#  * script assumes generated factorories in "org.apache.solr.analysis package
-#  * factories will be compilable only if orriginal class had no special
-#    constructor args.  otherwise it will have an abstract init method that
-#    needs filled in.
-
-use strict;
-use warnings;
-use File::Find;
-
-
-my $errors = 0;
-
-my %classes = ();
-while (<STDIN>) {
-    chomp;
-    # skip anonymous classes
-    if (!/\$/) {
-	$classes{$_} = 1;
-    }
-}
-
-find({wanted => \&wanted,
-      no_chdir => 1,
-      }, 
-     @ARGV);
-
-sub wanted {
-
-    my $file = $File::Find::name;
-    
-    return unless $file =~ m{/([^/]*)\.java$};
-    my $class = $1;
-    
-    open(my $f, "<", $file) or die "can't open $file: $!";
-    my $data;
-    {
-	local $/; # slurp
-	$data = <$f>;
-    }
-    close $f;
-
-    # skip abstract classes
-    return if ($data =~ m{abstract\s+(\w+\s+)*class\s+$class});
-    
-    my $pack = "EMPTYPACKAGE";
-    if ($data =~ m/package\s+(.*);/) {
-	$pack = $1;
-    }
-
-    my $fullname = "${pack}.${class}";
-    # only looking for certain classes
-    return unless $classes{$fullname};
-
-    print STDERR "$file\n";
-
-    my @imports = $data =~ m/import\s+.*;/g;
-    
-    if ($data =~ m{public \s+ ((?:\w+\s+)*) $class \s*\(\s* ([^\)]*) \) }sx) {
-	my $modifiers = $1;
-	my $argline = $2;
-	
-	my $mainArgType;
-	my $mainArg;
-	my @orderedArgs;
-	
-	my %args = map { my ($v,$k) = split /\s+/;
-			 push @orderedArgs, $k;
-			 if ($v =~ m/^(Reader|TokenStream)/) {
-			     $mainArgType=$v;
-			     $mainArg=$k;
-			 }
-			 ($k, $v)
-			 } split /\s*,\s*/, $argline;
-	
-	# wacky, doesn't use Reader or TokenStream ... skip (maybe a Sink?)
-	unless (defined $mainArgType) {
-	    warn "$class doesn't have a constructor with a Reader or TokenStream\n";
-	    return;
-	}
-
-	my $type = ("Reader" eq $mainArgType) ? "Tokenizer" : "TokenFilter";
-
-	my $facClass = "${class}Factory";
-	my $facFile = "${facClass}.java";
-
-	if (-e $facFile) {
-	    warn "$facFile already exists (maybe the return type isn't specific?)";
-	    $errors++;
-	    return;
-	}
-	open my $o, ">", $facFile
-	    or die "can't write to $facFile: $!";
-
-	print $o "$ASL\n";
-	print $o "package org.apache.solr.analysis;\n";
-	print $o "import ${pack}.*;\n";
-	print $o "$_\n" foreach @imports;
-	print $o "import java.util.Map;\n";
-	print $o "public class ${facClass} extends Base${type}Factory {\n";
-	foreach my $arg (@orderedArgs) {
-	    print $o "  private $args{$arg} $arg;\n" unless $arg eq $mainArg;
-	}
-	if (1 < @orderedArgs) {
-	    # we need to init something, stub it out
-	    print $o "  public abstract void init(Map<String, String> args) {\n";
-	    print $o "    super.init(args);\n";
-	    print $o "    // ABSTRACT BECAUSE IT'S A STUB .. FILL IT IN\n";
-	    print $o "  }\n";
-	}
-	print $o "  public $class create($mainArgType $mainArg) {\n";
-	print $o "    return new $class(", join(",", @orderedArgs), ");\n";
-	print $o "  }\n";
-	print $o "}\n\n";
-	close $o;
-	
-	delete $classes{$fullname}; # we're done with this one
-    } else {
-	print STDERR "can't stub $class (no public constructor?)\n";
-	$errors++;
-    }
-}
-    
-if (keys %classes) {
-    print STDERR "Can't stub (or find java files) for...\n";
-    foreach (keys %classes) {
-	print STDERR "$_\n";
-    }
-    $errors++;
-}
-exit -1 if $errors;
-

