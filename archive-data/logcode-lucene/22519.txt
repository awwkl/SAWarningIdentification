GitDiffStart: b4d1694ef7c991b6043150e774bce306cc47f184 | Thu Jun 14 03:26:18 2007 +0000
diff --git a/build.xml b/build.xml
index 6a1ab9b3..f6dd57c 100644
--- a/build.xml
+++ b/build.xml
@@ -95,6 +95,43 @@
   <available property="junitPresent"
              classname="junit.framework.TestCase" />
 
+  <!-- Macro for compilation -->
+  <macrodef name="solr-javac">
+    <attribute name="destdir" />
+    <attribute name="classpathref" />
+    <element name="nested" optional="true" implicit="true" />
+    <sequential>
+      <mkdir dir="@{destdir}" />
+      <javac destdir="@{destdir}"
+             target="${java.compat.version}"
+             source="${java.compat.version}"
+             debug="on"
+             encoding="utf8"
+             classpathref="@{classpathref}">
+         <nested />
+      </javac>
+    </sequential>
+  </macrodef>
+
+  <!-- Macro for building Jars -->
+  <macrodef name="solr-jar">
+    <attribute name="destfile" />
+    <attribute name="basedir" />
+    <attribute name="includes" default="org/apache/**" />
+    <attribute name="manifest" default="${dest}/META-INF/MANIFEST.MF" />
+    <element name="nested" optional="true" implicit="true" />
+    <sequential>
+      <jar destfile="@{destfile}"
+           basedir="@{basedir}"
+           includes="@{includes}"
+           filesetmanifest="skip"
+           manifest="@{manifest}">
+        <metainf dir="${basedir}" includes="LICENSE.txt,NOTICE.txt"/>
+        <nested />
+      </jar>
+    </sequential>
+  </macrodef>
+                 
   <!-- Macro for building checksum files
        This is only needed until the "format" option is supported
        by ant's built in checksum task
@@ -158,31 +195,37 @@
   <!-- ===================== COMPILATION-RELATED TASKS ========================= -->
   <!-- ========================================================================= -->
 
+  <!-- Compile common classes. -->
+  <target name="compile-common"
+          description="Compile the source code."
+          depends="init-forrest-entities,checkJunitPresence">
+
+    <solr-javac destdir="${dest}/common"
+                classpathref="compile.classpath">
+      <src path="${src}/java" />
+      <include name="org/apache/solr/common/**" />
+    </solr-javac>
+  </target>
 
   <!-- The compilation classpath -->
   <path id="compile.classpath">
     <fileset dir="${lib}">
       <include name="*.jar" />
     </fileset>
+    <pathelement location="${dest}/common"/>
   </path>
 
   <!-- Compile the project. -->
   <target name="compile"
           description="Compile the source code."
-          depends="init-forrest-entities,checkJunitPresence">
-
-    <mkdir dir="${dest}" />
+          depends="compile-common,init-forrest-entities,checkJunitPresence">
 
-    <javac destdir="${dest}"
-           target="${java.compat.version}"
-           source="${java.compat.version}"
-           debug="on"
-           encoding="utf8"
-           classpathref="compile.classpath">
+    <solr-javac destdir="${dest}/core"
+                classpathref="compile.classpath">
       <src path="${src}/java" />
       <src path="${src}/webapp/src" />
-
-    </javac>
+      <exclude name="org/apache/solr/common/**" />
+    </solr-javac>
   </target>
 
 
@@ -237,7 +280,8 @@
   <!-- For now, it's the same as main classpath.  Later it will have JUnit, Clover, etc. -->
   <path id="test.compile.classpath">
     <path refid="compile.classpath" />
-    <pathelement location="${dest}"/>
+    <pathelement location="${dest}/common"/>
+    <pathelement location="${dest}/core"/>
   </path>
 
   <path id="test.run.classpath">
@@ -263,15 +307,11 @@
           depends="compile,checkJunitPresence">
 
     <mkdir dir="${dest}/tests" />
-    <javac 
+    <solr-javac 
        destdir="${dest}/tests"
-       target="${java.compat.version}"
-       source="${java.compat.version}"
-       debug="on"
-       encoding="utf8"
        classpathref="test.compile.classpath">
       <src path="${src}/test" />
-    </javac>
+    </solr-javac>
   </target>
 
   <!-- Run unit tests. -->
@@ -399,6 +439,7 @@
        </lib>
        <lib dir="${dist}">
          <include name="${fullnamever}.jar" />
+         <include name="${fullnamever}-common.jar" />
        </lib>
        <fileset dir="${src}/webapp/resources" />
        <metainf dir="${basedir}" includes="LICENSE.txt,NOTICE.txt"/>
@@ -410,13 +451,15 @@
           description="Creates the Solr JAR Distribution file."
           depends="compile, make-manifest">
     <mkdir dir="${dist}" />
-    <jar destfile="${dist}/${fullnamever}.jar"
-         basedir="${dest}"
-         includes="org/apache/**"
-         filesetmanifest="skip"
-         manifest="${dest}/META-INF/MANIFEST.MF">
-	 <metainf dir="${basedir}" includes="LICENSE.txt,NOTICE.txt"/>
-    </jar>
+    <solr-jar
+         destfile="${dist}/${fullnamever}.jar"
+         basedir="${dest}/core" />
+
+    <!-- package the common classes together -->
+    <solr-jar
+         destfile="${dist}/${fullnamever}-common.jar"
+         basedir="${dest}/common" />
+    
   </target>
 
   <target name="example" 
@@ -425,13 +468,15 @@
     <copy file="${dist}/${fullnamever}.war"
           tofile="${example}/webapps/${ant.project.name}.war"/>
     <jar destfile="${example}/exampledocs/post.jar"
-         basedir="${dest}"
+         basedir="${dest}/core"
+         filesetmanifest="skip"
          includes="org/apache/solr/util/SimplePostTool*.class">
        <manifest>
           <attribute name="Main-Class"
                      value="org.apache.solr.util.SimplePostTool"/>
        </manifest>
     </jar>
+    
     <copy todir="${example}/solr/bin">
       <fileset dir="${src}/scripts">
         <exclude name="scripts.conf"/>
diff --git a/src/java/org/apache/solr/analysis/PatternTokenizerFactory.java b/src/java/org/apache/solr/analysis/PatternTokenizerFactory.java
index 3aaf738..43b5586 100644
--- a/src/java/org/apache/solr/analysis/PatternTokenizerFactory.java
+++ b/src/java/org/apache/solr/analysis/PatternTokenizerFactory.java
@@ -20,7 +20,7 @@ package org.apache.solr.analysis;
 import org.apache.commons.io.IOUtils;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 
 import java.io.IOException;
 import java.io.Reader;
diff --git a/src/java/org/apache/solr/analysis/PhoneticFilterFactory.java b/src/java/org/apache/solr/analysis/PhoneticFilterFactory.java
index 0c4296d..c8cb79b 100644
--- a/src/java/org/apache/solr/analysis/PhoneticFilterFactory.java
+++ b/src/java/org/apache/solr/analysis/PhoneticFilterFactory.java
@@ -26,7 +26,7 @@ import org.apache.commons.codec.language.Metaphone;
 import org.apache.commons.codec.language.RefinedSoundex;
 import org.apache.commons.codec.language.Soundex;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 
 /**
  * Create tokens based on phonetic encoders
diff --git a/src/java/org/apache/solr/analysis/TrimFilterFactory.java b/src/java/org/apache/solr/analysis/TrimFilterFactory.java
index 001353a..426ef78 100644
--- a/src/java/org/apache/solr/analysis/TrimFilterFactory.java
+++ b/src/java/org/apache/solr/analysis/TrimFilterFactory.java
@@ -20,7 +20,7 @@ package org.apache.solr.analysis;
 import java.util.Map;
 
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 
 /**
  * @version $Id:$
diff --git a/src/java/org/apache/solr/common/SolrDocument.java b/src/java/org/apache/solr/common/SolrDocument.java
new file mode 100644
index 0000000..e063d3d
--- /dev/null
+++ b/src/java/org/apache/solr/common/SolrDocument.java
@@ -0,0 +1,221 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * A concrete representation of a document within a Solr index.  Unlike a lucene
+ * Document, a SolrDocument may have an Object value matching the type defined in
+ * schema.xml
+ * 
+ * For indexing documents, use the SolrInputDocumet that contains extra information
+ * for document and field boosting.
+ * 
+ * @author ryan
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrDocument 
+{
+  private Map<String,Collection<Object>> _fields = null;
+  
+  public SolrDocument()
+  {
+    _fields = new HashMap<String,Collection<Object>>();
+  }
+
+  /**
+   * Let sub classes return something other then a List.  
+   * Perhaps a Set or LinkedHashSet
+   */
+  protected Collection<Object> getEmptyCollection( String name )
+  {
+    return new ArrayList<Object>();
+  }
+
+  /**
+   * @return a list of fields defined in this document
+   */
+  public Collection<String> getFieldNames() {
+    return _fields.keySet();
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Add / Set / Remove Fields
+  ///////////////////////////////////////////////////////////////////
+
+  /**
+   * Remove all fields from the document
+   */
+  public void clear()
+  {
+    _fields.clear();
+  }
+  
+  
+  /**
+   * Remove all fields with the name
+   */
+  public boolean removeFields(String name) 
+  {
+    return _fields.remove( name ) != null;
+  }
+
+  /**
+   * Set a field with the given object.  If the object is an Array or Iterable, it will 
+   * set multiple fields with the included contents.  This will replace any existing 
+   * field with the given name
+   */
+  public void setField(String name, Object value) 
+  {
+    Collection<Object> existing = _fields.get( name );
+    if( existing != null ) {
+      existing.clear();
+    }
+    this.addField(name, value);
+  }
+
+  /**
+   * This will add a field to the document.  If fields already exist with this name
+   * it will append the collection
+   */
+  public void addField(String name, Object value) 
+  { 
+    Collection<Object> existing = _fields.get( name );
+    if( existing == null ) {
+      existing = getEmptyCollection(name);
+      _fields.put( name, existing );
+    }
+    
+    // Arrays are iterable?  They appear to be, but not in the docs...
+    if( value instanceof Iterable ) {
+      for( Object o : (Iterable)value ) {
+        this.addField( name, o );  
+      }
+    }
+    else if( value instanceof Object[] ) {
+      for( Object o : (Object[])value ) {
+        this.addField( name, o );  
+      }
+    }
+    else {
+      existing.add( value );
+    }
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Get the field values
+  ///////////////////////////////////////////////////////////////////
+
+  /**
+   * returns the first value for this field
+   */
+  public Object getFieldValue(String name) {
+    Collection v = _fields.get( name );
+    if( v != null && v.size() > 0 ) {
+      return v.iterator().next();
+    }
+    return null;
+  }
+
+  /**
+   * Get a collection or all the values for a given field name
+   */
+  public Collection<Object> getFieldValues(String name) {
+    return _fields.get( name );
+  }
+  
+// TODO? should this be in the API?
+//  /**
+//   * Return a named list version
+//   */
+//  public NamedList<Object> toNamedList()
+//  {
+//    NamedList<Object> nl = new NamedList<Object>();
+//    for( Map.Entry<String, Collection<Object>> entry : _fields.entrySet() ) {
+//      Collection<Object> v = entry.getValue();
+//      if( v.size() == 0 ) {
+//        nl.add( entry.getKey(), null );
+//      }
+//      else if( v.size() > 1 ) {
+//        nl.add( entry.getKey(), v );
+//      }
+//      else { // Add a single value
+//        nl.add( entry.getKey(), v.iterator().next() );
+//      }
+//    }
+//    return nl;
+//  }
+  
+  @Override
+  public String toString()
+  {
+    return "SolrDocument["+getFieldNames()+"]";
+  }
+  
+  /**
+   * Expose a Map interface to the solr field value collection.
+   */
+  public Map<String,Collection<Object>> getFieldValuesMap()
+  {
+    return _fields;
+  }
+
+  /**
+   * Expose a Map interface to the solr fields.  This function is useful for JSTL
+   */
+  public Map<String,Object> getFieldValueMap() {
+    return new Map<String,Object>() {
+      /** Get the field Value */
+      public Object get(Object key) { 
+        return getFieldValue( (String)key ); 
+      }
+      
+      /** Set the field Value */
+      public Object put(String key, Object value) {
+        setField( key, value );
+        return null;
+      }
+
+      /** Remove the field Value */
+      public Object remove(Object key) {
+        removeFields( (String)key ); 
+        return null;
+      }
+      
+      // Easily Supported methods
+      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
+      public Set<String>  keySet()           { return _fields.keySet();  }
+      public int          size()             { return _fields.size();    }
+      public boolean      isEmpty()          { return _fields.isEmpty(); }
+
+      // Unsupported operations.  These are not necessary for JSTL
+      public void clear() { throw new UnsupportedOperationException(); }
+      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
+      public Set<java.util.Map.Entry<String, Object>> entrySet() {throw new UnsupportedOperationException();}
+      public void putAll(Map<? extends String, ? extends Object> t) {throw new UnsupportedOperationException();}
+      public Collection<Object> values() {throw new UnsupportedOperationException();}
+    };
+  }
+}
diff --git a/src/java/org/apache/solr/common/SolrException.java b/src/java/org/apache/solr/common/SolrException.java
new file mode 100644
index 0000000..5642371
--- /dev/null
+++ b/src/java/org/apache/solr/common/SolrException.java
@@ -0,0 +1,161 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.util.logging.Logger;
+import java.io.CharArrayWriter;
+import java.io.PrintWriter;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class SolrException extends RuntimeException {
+  
+  /**
+   * @since solr 1.2
+   */
+  public enum ErrorCode {
+    BAD_REQUEST( 400 ),
+    UNAUTHORIZED( 401 ),
+    FORBIDDEN( 403 ),
+    NOT_FOUND( 404 ),
+    SERVER_ERROR( 500 ),
+    SERVICE_UNAVAILABLE( 503 ); 
+    
+    final int code;
+    
+    private ErrorCode( int c )
+    {
+      code = c;
+    }
+  };
+  
+  public boolean logged=false;
+
+  public SolrException(ErrorCode code, String msg) {
+    super(msg);
+    this.code=code.code;
+  }
+  
+  public SolrException(ErrorCode code, String msg, boolean alreadyLogged) {
+    super(msg);
+    this.code=code.code;
+    this.logged=alreadyLogged;
+  }
+
+  public SolrException(ErrorCode code, String msg, Throwable th, boolean alreadyLogged) {
+    super(msg,th);
+    this.code=code.code;
+    logged=alreadyLogged;
+  }
+
+  public SolrException(ErrorCode code, String msg, Throwable th) {
+    this(code,msg,th,true);
+  }
+
+  public SolrException(ErrorCode code, Throwable th) {
+    super(th);
+    this.code=code.code;
+    logged=true;
+  }
+  
+  @Deprecated
+  public SolrException(int code, String msg) {
+    super(msg);
+    this.code=code;
+  }
+  
+  @Deprecated
+  public SolrException(int code, String msg, boolean alreadyLogged) {
+    super(msg);
+    this.code=code;
+    this.logged=alreadyLogged;
+  }
+
+  @Deprecated
+  public SolrException(int code, String msg, Throwable th, boolean alreadyLogged) {
+    super(msg,th);
+    this.code=code;
+    logged=alreadyLogged;
+  }
+
+  @Deprecated
+  public SolrException(int code, String msg, Throwable th) {
+    this(code,msg,th,true);
+  }
+
+  @Deprecated
+  public SolrException(int code, Throwable th) {
+    super(th);
+    this.code=code;
+    logged=true;
+  }
+
+  int code=0;
+  public int code() { return code; }
+
+
+
+
+  public void log(Logger log) { log(log,this); }
+  public static void log(Logger log, Throwable e) {
+    log.severe(toStr(e));
+    if (e instanceof SolrException) {
+      ((SolrException)e).logged = true;
+    }
+  }
+
+  public static void log(Logger log, String msg, Throwable e) {
+    log.severe(msg + ':' + toStr(e));
+    if (e instanceof SolrException) {
+      ((SolrException)e).logged = true;
+    }
+  }
+
+  public static void logOnce(Logger log, String msg, Throwable e) {
+    if (e instanceof SolrException) {
+      if(((SolrException)e).logged) return;
+    }
+    if (msg!=null) log(log,msg,e);
+    else log(log,e);
+  }
+
+
+  // public String toString() { return toStr(this); }  // oops, inf loop
+  @Override
+  public String toString() { return super.toString(); }
+
+  public static String toStr(Throwable e) {
+    CharArrayWriter cw = new CharArrayWriter();
+    PrintWriter pw = new PrintWriter(cw);
+    e.printStackTrace(pw);
+    pw.flush();
+    return cw.toString();
+
+/** This doesn't work for some reason!!!!!
+    StringWriter sw = new StringWriter();
+    PrintWriter pw = new PrintWriter(sw);
+    e.printStackTrace(pw);
+    pw.flush();
+    System.out.println("The STRING:" + sw.toString());
+    return sw.toString();
+**/
+  }
+
+}
diff --git a/src/java/org/apache/solr/common/SolrInputDocument.java b/src/java/org/apache/solr/common/SolrInputDocument.java
new file mode 100644
index 0000000..47e392e
--- /dev/null
+++ b/src/java/org/apache/solr/common/SolrInputDocument.java
@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Represent the field and boost information needed to construct and index
+ * a Lucene Document.  Like the SolrDocument, the field values need to
+ * match those specified in schema.xml 
+ * 
+ * @author ryan
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrInputDocument extends SolrDocument
+{
+  private Map<String,Float> _boost = null;
+
+  /**
+   * Remove all fields and boosts from the document
+   */
+  @Override
+  public void clear()
+  {
+    super.clear();
+    if( _boost != null ) {
+      _boost.clear();
+    }
+  }
+  
+  /**
+   * Set the document boost.  null will remove the boost
+   */
+  public void setDocumentBoost( Float v )
+  {
+    this.setBoost( null, v );
+  }
+  
+  /**
+   * @return the document boost.  or null if not set
+   */
+  public Float getDocumentBoost()
+  {
+    return this.getBoost( null );
+  }
+  
+  /**
+   * Get the lucene document boost for a field.  Passing in <code>null</code> returns the
+   * document boost, not a field boost.  
+   */
+  public void setBoost(String name, Float boost) {
+    if( _boost == null ) {
+      _boost = new HashMap<String, Float>();
+    }
+    if( boost == null ) {
+      _boost.remove( name );
+    }
+    else {
+      _boost.put( name, boost );
+    }
+  }
+
+  /**
+   * Set the field boost.  All fields with the name will have the same boost.  
+   * Passing in <code>null</code> sets the document boost.
+   * @param boost
+   */
+  public Float getBoost(String name) {
+    if( _boost == null ) {
+      return null;
+    }
+    return _boost.get( name );
+  }
+}
diff --git a/src/java/org/apache/solr/common/params/AppendedSolrParams.java b/src/java/org/apache/solr/common/params/AppendedSolrParams.java
new file mode 100644
index 0000000..b413418
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/AppendedSolrParams.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * SolrParams wrapper which acts similar to DefaultSolrParams except that
+ * it "appends" the values of multi-value params from both sub instances, so
+ * that all of the values are returned. 
+ */
+public class AppendedSolrParams extends DefaultSolrParams {
+  public AppendedSolrParams(SolrParams main, SolrParams extra) {
+    super(main, extra);
+  }
+
+  public String[] getParams(String param) {
+    String[] main = params.getParams(param);
+    String[] extra = defaults.getParams(param);
+    if (null == extra || 0 == extra.length) {
+      return main;
+    }
+    if (null == main || 0 == main.length) {
+      return extra;
+    }
+    String[] result = new String[main.length + extra.length];
+    System.arraycopy(main,0,result,0,main.length);
+    System.arraycopy(extra,0,result,main.length,extra.length);
+    return result;
+  }
+
+  public String toString() {
+    return "{main("+params+"),extra("+defaults+")}";
+  }
+}
diff --git a/src/java/org/apache/solr/common/params/CommonParams.java b/src/java/org/apache/solr/common/params/CommonParams.java
new file mode 100755
index 0000000..5c1e2f6
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/CommonParams.java
@@ -0,0 +1,132 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.SolrCore;
+
+
+
+
+/**
+ * A collection on common params, both for Plugin initialization and
+ * for Requests.
+ */
+@Deprecated
+public class CommonParams {
+
+  @Deprecated
+  public static String FL = "fl";
+  /** default query field */
+  @Deprecated
+  public static String DF = "df";
+  /** whether to include debug data */
+  @Deprecated
+  public static String DEBUG_QUERY = "debugQuery";
+  /** another query to explain against */
+  @Deprecated
+  public static String EXPLAIN_OTHER = "explainOther";
+
+
+  /** the default field list to be used */
+  public String fl = null;
+  /** the default field to query */
+  public String df = null;
+  /** do not debug by default **/
+  public String debugQuery = null;
+  /** no default other explanation query **/
+  public String explainOther = null;
+  /** whether to highlight */
+  public boolean highlight = false;
+  /** fields to highlight */
+  public String highlightFields = null;
+  /** maximum highlight fragments to return */
+  public int maxSnippets = 1;
+  /** override default highlight Formatter class */
+  public String highlightFormatterClass = null;
+
+
+  public CommonParams() {
+    /* :NOOP: */
+  }
+
+  /** @see #setValues */
+  public CommonParams(NamedList args) {
+    this();
+    setValues(args);
+  }
+
+  /**
+   * Sets the params using values from a NamedList, usefull in the
+   * init method for your handler.
+   *
+   * <p>
+   * If any param is not of the expected type, a severe error is
+   * logged,and the param is skipped.
+   * </p>
+   *
+   * <p>
+   * If any param is not of in the NamedList, it is skipped and the
+   * old value is left alone.
+   * </p>
+   *
+   */
+  public void setValues(NamedList args) {
+
+    Object tmp;
+
+    tmp = args.get(SolrParams.FL);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        fl = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + SolrParams.FL);
+      }
+    }
+
+    tmp = args.get(SolrParams.DF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        df = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + SolrParams.DF);
+      }
+    }
+
+    tmp = args.get(SolrParams.DEBUG_QUERY);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        debugQuery = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + SolrParams.DEBUG_QUERY);
+      }
+    }
+
+    tmp = args.get(SolrParams.EXPLAIN_OTHER);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        explainOther = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + SolrParams.EXPLAIN_OTHER);
+      }
+    }
+
+  }
+
+}
+
diff --git a/src/java/org/apache/solr/common/params/DefaultSolrParams.java b/src/java/org/apache/solr/common/params/DefaultSolrParams.java
new file mode 100644
index 0000000..60d1a02
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/DefaultSolrParams.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import java.util.Iterator;
+
+import org.apache.solr.common.util.IteratorChain;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class DefaultSolrParams extends SolrParams {
+  protected final SolrParams params;
+  protected final SolrParams defaults;
+
+  public DefaultSolrParams(SolrParams params, SolrParams defaults) {
+    this.params = params;
+    this.defaults = defaults;
+  }
+
+  public String get(String param) {
+    String val = params.get(param);
+    return val!=null ? val : defaults.get(param);
+  }
+
+  public String[] getParams(String param) {
+    String[] vals = params.getParams(param);
+    return vals!=null ? vals : defaults.getParams(param);
+  }
+  
+  public Iterator<String> getParameterNamesIterator() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(defaults.getParameterNamesIterator());
+    c.addIterator(params.getParameterNamesIterator());
+    return c;
+  }
+
+  public String toString() {
+    return "{params("+params+"),defaults("+defaults+")}";
+  }
+}
diff --git a/src/java/org/apache/solr/common/params/DisMaxParams.java b/src/java/org/apache/solr/common/params/DisMaxParams.java
new file mode 100755
index 0000000..d44882c
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/DisMaxParams.java
@@ -0,0 +1,222 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.core.SolrInfoMBean;
+
+import org.apache.solr.util.StrUtils;
+
+import java.util.logging.Logger;
+import java.util.logging.Level;
+import java.util.logging.Handler;
+
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Collection;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.regex.Pattern;
+import java.io.IOException;
+
+    
+
+/**
+ * A collection of params used in DisMaxRequestHandler,
+ * both for Plugin initialization and for Requests.
+ */
+public class DisMaxParams extends CommonParams {
+  
+  /** query and init param for tiebreaker value */
+  public static String TIE = "tie";
+  /** query and init param for query fields */
+  public static String QF = "qf";
+  /** query and init param for phrase boost fields */
+  public static String PF = "pf";
+  /** query and init param for MinShouldMatch specification */
+  public static String MM = "mm";
+  /**
+   * query and init param for Phrase Slop value in phrase
+   * boost query (in pf fields)
+   */
+  public static String PS = "ps";
+  /**
+   * query and init param for phrase Slop value in phrases
+   * explicitly included in the user's query string ( in qf fields)
+   */
+  public static String QS = "qs";
+  /** query and init param for boosting query */
+  public static String BQ = "bq";
+  /** query and init param for boosting functions */
+  public static String BF = "bf";
+  /**
+   * Alternate query (expressed in Solr QuerySyntax)
+   * to use if main query (q) is empty
+   */
+  public static String ALTQ = "q.alt";
+  /** query and init param for filtering query
+   * @deprecated use SolrParams.FQ or SolrPluginUtils.parseFilterQueries
+   */
+  public static String FQ = "fq";
+  /** query and init param for field list */
+  public static String GEN = "gen";
+        
+  /**
+   * the default tie breaker to use in DisjunctionMaxQueries
+   * @deprecated - use explicit default with SolrParams.getFloat
+   */
+  public float tiebreaker = 0.0f;
+  /**
+   * the default query fields to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String qf = null;
+  /**
+   * the default phrase boosting fields to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String pf = null;
+  /**
+   * the default min should match to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String mm = "100%";
+  /**
+   * the default phrase slop to be used 
+   * @deprecated - use explicit default with SolrParams.getInt
+   */
+  public int pslop = 0;
+  /**
+   * the default boosting query to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String bq = null;
+  /**
+   * the default boosting functions to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String bf = null;
+  /**
+   * the default filtering query to be used
+   * @deprecated - use explicit default with SolrParams.get
+   */
+  public String fq = null;
+
+
+  /**
+   * Sets the params using values from a NamedList, usefull in the
+   * init method for your handler.
+   *
+   * <p>
+   * If any param is not of the expected type, a severe error is
+   * logged,and the param is skipped.
+   * </p>
+   *
+   * <p>
+   * If any param is not of in the NamedList, it is skipped and the
+   * old value is left alone.
+   * </p>
+   * @deprecated use SolrParams.toSolrParams
+   */
+  public void setValues(NamedList args) {
+
+    super.setValues(args);
+
+    Object tmp;
+
+    tmp = args.get(TIE);
+    if (null != tmp) {
+      if (tmp instanceof Float) {
+        tiebreaker = ((Float)tmp).floatValue();
+      } else {
+        SolrCore.log.severe("init param is not a float: " + TIE);
+      }
+    }
+
+    tmp = args.get(QF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        qf = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + QF);
+      }
+    }
+
+    tmp = args.get(PF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        pf = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + PF);
+      }
+    }
+
+        
+    tmp = args.get(MM);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        mm = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + MM);
+      }
+    }
+        
+    tmp = args.get(PS);
+    if (null != tmp) {
+      if (tmp instanceof Integer) {
+        pslop = ((Integer)tmp).intValue();
+      } else {
+        SolrCore.log.severe("init param is not an int: " + PS);
+      }
+    }
+
+    tmp = args.get(BQ);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        bq = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + BQ);
+      }
+    }
+ 
+    tmp = args.get(BF);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        bf = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + BF);
+      }
+    }
+ 
+    tmp = args.get(FQ);
+    if (null != tmp) {
+      if (tmp instanceof String) {
+        fq = tmp.toString();
+      } else {
+        SolrCore.log.severe("init param is not a str: " + FQ);
+      }
+    }
+                
+  }
+
+}
diff --git a/src/java/org/apache/solr/common/params/MapSolrParams.java b/src/java/org/apache/solr/common/params/MapSolrParams.java
new file mode 100644
index 0000000..141433c
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/MapSolrParams.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.util.StrUtils;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class MapSolrParams extends SolrParams {
+  protected final Map<String,String> map;
+
+  public MapSolrParams(Map<String,String> map) {
+    this.map = map;
+  }
+
+  public String get(String name) {
+    return map.get(name);
+  }
+
+  public String[] getParams(String name) {
+    String val = map.get(name);
+    return val==null ? null : new String[]{val};
+  }
+  
+  public Iterator<String> getParameterNamesIterator() {
+    return map.keySet().iterator();
+  }
+
+  public Map<String,String> getMap() { return map; }
+
+  public String toString() {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      boolean first=true;
+
+      for (Map.Entry<String,String> entry : map.entrySet()) {
+        String key = entry.getKey();
+        String val = entry.getValue();
+
+        if (!first) sb.append('&');
+        first=false;
+        sb.append(key);
+        sb.append('=');
+        StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+
+    return sb.toString();
+  }
+}
diff --git a/src/java/org/apache/solr/common/params/MultiMapSolrParams.java b/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
new file mode 100644
index 0000000..9ff5d23
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.util.StrUtils;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class MultiMapSolrParams extends SolrParams {
+  protected final Map<String,String[]> map;
+
+  public static void addParam(String name, String val, Map<String,String[]> map) {
+      String[] arr = map.get(name);
+      if (arr ==null) {
+        arr =new String[]{val};
+      } else {
+        String[] newarr = new String[arr.length+1];
+        System.arraycopy(arr,0,newarr,0,arr.length);
+        newarr[arr.length]=val;
+        arr =newarr;
+      }
+      map.put(name, arr);
+  }
+
+  public MultiMapSolrParams(Map<String,String[]> map) {
+    this.map = map;
+  }
+
+  public String get(String name) {
+    String[] arr = map.get(name);
+    return arr==null ? null : arr[0];
+  }
+
+  public String[] getParams(String name) {
+    return map.get(name);
+  }
+  
+  public Iterator<String> getParameterNamesIterator() {
+    return map.keySet().iterator();
+  }
+
+  public Map<String,String[]> getMap() { return map; }
+
+  public String toString() {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      boolean first=true;
+
+      for (Map.Entry<String,String[]> entry : map.entrySet()) {
+        String key = entry.getKey();
+        String[] valarr = entry.getValue();
+
+        for (String val : valarr) {
+          if (!first) sb.append('&');
+          first=false;
+          sb.append(key);
+          sb.append('=');
+          StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
+        }
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+
+    return sb.toString();
+  }
+
+
+}
diff --git a/src/java/org/apache/solr/common/params/RequiredSolrParams.java b/src/java/org/apache/solr/common/params/RequiredSolrParams.java
new file mode 100755
index 0000000..c30a3ab
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/RequiredSolrParams.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.SolrException;
+
+import java.util.Iterator;
+
+/**
+ * This is a simple wrapper to SolrParams that will throw a 400
+ * exception if you ask for a parameter that does not exist.  Fields
+ * specified with
+ * 
+ * In short, any value you for from a <code>RequiredSolrParams</code> 
+ * will return a valid non-null value or throw a 400 exception.  
+ * (If you pass in <code>null</code> as the default value, you can 
+ * get a null return value)
+ * 
+ * @author jjl
+ * @version $Id$
+ * @since solr 1.2
+ */
+public class RequiredSolrParams extends SolrParams {
+  protected final SolrParams params;
+  
+  public RequiredSolrParams(SolrParams params) {
+    this.params = params;
+  }
+
+  /** get the param from params, fail if not found **/
+  @Override
+  public String get(String param) {
+    String val = params.get(param);
+    if( val == null )  {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
+    }
+    return val;
+  }
+
+  @Override
+  public String[] getParams(String param) {
+    String[] vals = params.getParams(param);
+    if( vals == null || vals.length == 0 ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
+    }
+    return vals;
+  }
+  
+  /** returns an Iterator over the parameter names */
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    return params.getParameterNamesIterator();
+  }
+
+  @Override
+  public String toString() {
+    return "{required("+params+")}";  
+  }    
+
+  //----------------------------------------------------------
+  // Functions with a default value - pass directly to the
+  // wrapped SolrParams (they won't return null - unless its the default)
+  //----------------------------------------------------------
+
+  @Override
+  public String get(String param, String def) {
+    return params.get(param, def);
+  }
+
+  @Override
+  public int getInt(String param, int def) {
+    return params.getInt(param, def);
+  }
+
+  @Override
+  public float getFloat(String param, float def) {
+    return params.getFloat(param, def);
+  }
+  
+  @Override
+  public boolean getBool(String param, boolean def) {
+    return params.getBool(param, def);
+  }
+
+  @Override
+  public int getFieldInt(String field, String param, int def) {
+    return params.getFieldInt(field, param, def);
+  }
+  
+  @Override
+  public boolean getFieldBool(String field, String param, boolean def) {
+    return params.getFieldBool(field, param, def);
+  }
+
+  @Override
+  public float getFieldFloat(String field, String param, float def) {
+    return params.getFieldFloat(field, param, def);
+  }
+
+  @Override
+  public String getFieldParam(String field, String param, String def) {
+    return params.getFieldParam(field, param, def);
+  }
+}
diff --git a/src/java/org/apache/solr/common/params/SolrParams.java b/src/java/org/apache/solr/common/params/SolrParams.java
new file mode 100644
index 0000000..88e2270
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/SolrParams.java
@@ -0,0 +1,410 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+/**  SolrParams hold request parameters.
+ *
+ * @author yonik
+ * @version $Id$
+ */
+public abstract class SolrParams {
+  /** the query type - which query handler should handle the request */
+  public static final String QT ="qt";
+  /** the response writer type - the format of the response */
+  public static final String WT ="wt";
+  /** query string */
+  public static final String Q ="q";
+  /** sort order */
+  public static final String SORT ="sort";
+  /** Lucene query string(s) for filtering the results without affecting scoring */
+  public static final String FQ ="fq";
+  /** zero based offset of matching documents to retrieve */
+  public static final String START ="start";
+  /** number of documents to return starting at "start" */
+  public static final String ROWS ="rows";
+  /** stylesheet to apply to XML results */
+  public static final String XSL ="xsl";
+  /** stylesheet to apply to XML results */
+  public static final String VERSION ="version";
+  /** query and init param for field list */
+  public static final String FL = "fl";
+  /** default query field */
+  public static final String DF = "df";
+  /** whether to include debug data */
+  public static final String DEBUG_QUERY = "debugQuery";
+  /** another query to explain against */
+  public static final String EXPLAIN_OTHER = "explainOther";
+
+  /**
+   * Should facet counts be calculated?
+   */
+  public static final String FACET = "facet";
+  
+  /**
+   * Any lucene formated queries the user would like to use for
+   * Facet Contraint Counts (multi-value)
+   */
+  public static final String FACET_QUERY = "facet.query";
+  /**
+   * Any field whose terms the user wants to enumerate over for
+   * Facet Contraint Counts (multi-value)
+   */
+  public static final String FACET_FIELD = "facet.field";
+
+  /**
+   * The offset into the list of facets.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_OFFSET = "facet.offset";
+
+  /**
+   * Numeric option indicating the maximum number of facet field counts
+   * be included in the response for each field - in descending order of count.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_LIMIT = "facet.limit";
+
+  /**
+   * Numeric option indicating the minimum number of hits before a facet should
+   * be included in the response.  Can be overriden on a per field basis.
+   */
+  public static final String FACET_MINCOUNT = "facet.mincount";
+
+  /**
+   * Boolean option indicating whether facet field counts of "0" should 
+   * be included in the response.  Can be overriden on a per field basis.
+   */
+  public static final String FACET_ZEROS = "facet.zeros";
+
+  /**
+   * Boolean option indicating whether the response should include a 
+   * facet field count for all records which have no value for the 
+   * facet field. Can be overriden on a per field basis.
+   */
+  public static final String FACET_MISSING = "facet.missing";
+
+  /**
+   * Boolean option: true causes facets to be sorted
+   * by the count, false results in natural index order.
+   */
+  public static final String FACET_SORT = "facet.sort";
+
+  /**
+   * Only return constraints of a facet field with the given prefix.
+   */
+  public static final String FACET_PREFIX = "facet.prefix";
+
+ /**
+   * When faceting by enumerating the terms in a field,
+   * only use the filterCache for terms with a df >= to this parameter.
+   */
+  public static final String FACET_ENUM_CACHE_MINDF = "facet.enum.cache.minDf";
+
+
+  /** If the content stream should come from a URL (using URLConnection) */
+  public static final String STREAM_URL = "stream.url";
+
+  /** If the content stream should come from a File (using FileReader) */
+  public static final String STREAM_FILE = "stream.file";
+  
+  /** If the content stream should come directly from a field */
+  public static final String STREAM_BODY = "stream.body";
+  
+  /** 
+   * Explicity set the content type for the input stream
+   * If multiple streams are specified, the explicit contentType
+   * will be used for all of them.  
+   */
+  public static final String STREAM_CONTENTTYPE = "stream.contentType";
+    
+  /** 'true' if the header should include the handler name */
+  public static final String HEADER_ECHO_HANDLER = "echoHandler";
+  
+  /** include the parameters in the header **/
+  public static final String HEADER_ECHO_PARAMS = "echoParams";
+  
+  /** valid values for: <code>echoParams</code> */
+  public enum EchoParamStyle {
+    EXPLICIT,
+    ALL,
+    NONE;
+    
+    public static EchoParamStyle get( String v ) {
+      if( v != null ) {
+        v = v.toUpperCase();
+        if( v.equals( "EXPLICIT" ) ) {
+          return EXPLICIT;
+        }
+        if( v.equals( "ALL") ) {
+          return ALL;
+        }
+        if( v.equals( "NONE") ) {  // the same as nothing...
+          return NONE;
+        }
+      }
+      return null;
+    }
+  };
+  
+  /** returns the String value of a param, or null if not set */
+  public abstract String get(String param);
+
+  /** returns an array of the String values of a param, or null if none */
+  public abstract String[] getParams(String param);
+
+  /** returns an Iterator over the parameter names */
+  public abstract Iterator<String> getParameterNamesIterator();
+
+  /** returns the value of the param, or def if not set */
+  public String get(String param, String def) {
+    String val = get(param);
+    return val==null ? def : val;
+  }
+  
+  /** returns a RequiredSolrParams wrapping this */
+  public RequiredSolrParams required()
+  {
+    // TODO? should we want to stash a reference?
+    return new RequiredSolrParams(this);
+  }
+  
+  protected String fpname(String field, String param) {
+    return "f."+field+'.'+param;
+  }
+
+  /** returns the String value of the field parameter, "f.field.param", or
+   *  the value for "param" if that is not set.
+   */
+  public String getFieldParam(String field, String param) {
+    String val = get(fpname(field,param));
+    return val!=null ? val : get(param);
+  }
+
+  /** returns the String value of the field parameter, "f.field.param", or
+   *  the value for "param" if that is not set.  If that is not set, def
+   */
+  public String getFieldParam(String field, String param, String def) {
+    String val = get(fpname(field,param));
+    return val!=null ? val : get(param, def);
+  }
+  
+  /** returns the String values of the field parameter, "f.field.param", or
+   *  the values for "param" if that is not set.
+   */
+  public String[] getFieldParams(String field, String param) {
+    String[] val = getParams(fpname(field,param));
+    return val!=null ? val : getParams(param);
+  }
+
+  /** Returns the Boolean value of the param, or null if not set */
+  public Boolean getBool(String param) {
+    String val = get(param);
+    return val==null ? null : parseBool(val);
+  }
+
+  /** Returns the boolean value of the param, or def if not set */
+  public boolean getBool(String param, boolean def) {
+    String val = get(param);
+    return val==null ? def : parseBool(val);
+  }
+  
+  /** Returns the Boolean value of the field param, 
+      or the value for param, or null if neither is set. */
+  public Boolean getFieldBool(String field, String param) {
+    String val = getFieldParam(field, param);
+    return val==null ? null : parseBool(val);
+  }
+  
+  /** Returns the boolean value of the field param, 
+  or the value for param, or def if neither is set. */
+  public boolean getFieldBool(String field, String param, boolean def) {
+    String val = getFieldParam(field, param);
+    return val==null ? def : parseBool(val);
+  }
+
+  /** Returns the Integer value of the param, or null if not set */
+  public Integer getInt(String param) {
+    String val = get(param);
+    try {
+      return val==null ? null : Integer.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the int value of the param, or def if not set */
+  public int getInt(String param, int def) {
+    String val = get(param);
+    try {
+      return val==null ? def : Integer.parseInt(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** Returns the int value of the field param,
+  or the value for param, or def if neither is set. */
+  public Integer getFieldInt(String field, String param) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? null : Integer.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** Returns the int value of the field param, 
+  or the value for param, or def if neither is set. */
+  public int getFieldInt(String field, String param, int def) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? def : Integer.parseInt(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+
+  /** Returns the Float value of the param, or null if not set */
+  public Float getFloat(String param) {
+    String val = get(param);
+    try {
+      return val==null ? null : Float.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the param, or def if not set */
+  public float getFloat(String param, float def) {
+    String val = get(param);
+    try {
+      return val==null ? def : Float.parseFloat(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the field param. */
+  public Float getFieldFloat(String field, String param) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? null : Float.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the field param,
+  or the value for param, or def if neither is set. */
+  public float getFieldFloat(String field, String param, float def) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? def : Float.parseFloat(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** how to transform a String into a boolean... more flexible than
+   * Boolean.parseBoolean() to enable easier integration with html forms.
+   */
+  protected boolean parseBool(String s) {
+    if( s != null ) {
+      if( s.startsWith("true") || s.startsWith("on") || s.startsWith("yes") ) {
+        return true;
+      }
+      if( s.startsWith("false") || s.startsWith("off") || s.equals("no") ) {
+        return false;
+      }
+    }
+    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "invalid boolean value: "+s );
+  }
+
+  /** Create a Map<String,String> from a NamedList given no keys are repeated */
+  public static Map<String,String> toMap(NamedList params) {
+    HashMap<String,String> map = new HashMap<String,String>();
+    for (int i=0; i<params.size(); i++) {
+      map.put(params.getName(i), params.getVal(i).toString());
+    }
+    return map;
+  }
+
+  /** Create a Map<String,String[]> from a NamedList */
+  public static Map<String,String[]> toMultiMap(NamedList params) {
+    HashMap<String,String[]> map = new HashMap<String,String[]>();
+    for (int i=0; i<params.size(); i++) {
+      String name = params.getName(i);
+      String val = params.getVal(i).toString();
+      MultiMapSolrParams.addParam(name,val,map);
+    }
+    return map;
+  }
+
+  /** Create SolrParams from NamedList. */
+  public static SolrParams toSolrParams(NamedList params) {
+    // if no keys are repeated use the faster MapSolrParams
+    HashMap<String,String> map = new HashMap<String,String>();
+    for (int i=0; i<params.size(); i++) {
+      String prev = map.put(params.getName(i), params.getVal(i).toString());
+      if (prev!=null) return new MultiMapSolrParams(toMultiMap(params));
+    }
+    return new MapSolrParams(map);
+  }
+  
+  /** Convert this to a NamedList */
+  public NamedList<Object> toNamedList() {
+    final SimpleOrderedMap<Object> result = new SimpleOrderedMap<Object>();
+    
+    for(Iterator<String> it=getParameterNamesIterator(); it.hasNext(); ) {
+      final String name = it.next();
+      final String [] values = getParams(name);
+      if(values.length==1) {
+        result.add(name,values[0]);
+      } else {
+        // currently no reason not to use the same array
+        result.add(name,values);
+      }
+    }
+    return result;
+  }
+}
+
+
+
+
+
+
+
+
diff --git a/src/java/org/apache/solr/common/params/UpdateParams.java b/src/java/org/apache/solr/common/params/UpdateParams.java
new file mode 100644
index 0000000..916e01e
--- /dev/null
+++ b/src/java/org/apache/solr/common/params/UpdateParams.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * A collection of standard params used by Update handlers
+ *
+ * @author ryan
+ * @version $Id$
+ * @since solr 1.2
+ */
+public interface UpdateParams 
+{
+  /** wait till the command has flushed */
+  public static String WAIT_FLUSH = "waitFlush";
+  
+  /** wait for the search to warm up */
+  public static String WAIT_SEARCHER = "waitSearcher";
+  
+  /** overwrite indexing fields */
+  public static String OVERWRITE = "overwrite";
+  
+  /** Commit everything after the command completes */
+  public static String COMMIT = "commit";
+  
+  /** Commit everything after the command completes */
+  public static String OPTIMIZE = "optimize";
+}
diff --git a/src/java/org/apache/solr/common/util/ContentStream.java b/src/java/org/apache/solr/common/util/ContentStream.java
new file mode 100755
index 0000000..ee43812
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/ContentStream.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+
+import org.apache.commons.io.IOUtils;
+
+/**
+ * @author ryan
+ * @version $Id$
+ * @since solr 1.2
+ */
+public interface ContentStream {
+  String getName();
+  String getSourceInfo();
+  String getContentType();
+  
+  /**
+   * @return the stream size or <code>null</code> if not known
+   */
+  Long getSize(); // size if we know it, otherwise null
+  
+  /**
+   * Get an open stream.  You are responsible for closing it.  Consider using 
+   * something like:
+   * <pre>
+   *   InputStream stream = stream.getStream();
+   *   try {
+   *     // use the stream...
+   *   }
+   *   finally {
+   *     IOUtils.closeQuietly(reader);
+   *   }
+   *  </pre>
+   *  
+   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
+   * is gaurenteed to work.  The runtime behavior for aditional calls is undefined.
+   */
+  InputStream getStream() throws IOException;
+
+  /**
+   * Get an open stream.  You are responsible for closing it.  Consider using 
+   * something like:
+   * <pre>
+   *   Reader reader = stream.getReader();
+   *   try {
+   *     // use the reader...
+   *   }
+   *   finally {
+   *     IOUtils.closeQuietly(reader);
+   *   }
+   *  </pre>
+   *  
+   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
+   * is gaurenteed to work.  The runtime behavior for aditional calls is undefined.
+   */
+  Reader getReader() throws IOException;
+}
diff --git a/src/java/org/apache/solr/common/util/ContentStreamBase.java b/src/java/org/apache/solr/common/util/ContentStreamBase.java
new file mode 100755
index 0000000..289a2ac
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/ContentStreamBase.java
@@ -0,0 +1,203 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.net.URL;
+import java.net.URLConnection;
+
+
+/**
+ * Three concrete implementations for ContentStream - one for File/URL/String
+ * 
+ * @author ryan
+ * @version $Id$
+ * @since solr 1.2
+ */
+public abstract class ContentStreamBase implements ContentStream
+{
+  public static final String DEFAULT_CHARSET = "utf-8";
+  
+  protected String name;
+  protected String sourceInfo;
+  protected String contentType;
+  protected Long size;
+  
+  //---------------------------------------------------------------------
+  //---------------------------------------------------------------------
+  
+  public static String getCharsetFromContentType( String contentType )
+  {
+    if( contentType != null ) {
+      int idx = contentType.toLowerCase().indexOf( "charset=" );
+      if( idx > 0 ) {
+        return contentType.substring( idx + "charset=".length() ).trim();
+      }
+    }
+    return null;
+  }
+  
+  //------------------------------------------------------------------------
+  //------------------------------------------------------------------------
+  
+  /**
+   * Construct a <code>ContentStream</code> from a <code>URL</code>
+   * 
+   * This uses a <code>URLConnection</code> to get the content stream
+   * @see  URLConnection
+   */
+  public static class URLStream extends ContentStreamBase
+  {
+    private final URL url;
+    final URLConnection conn;
+    
+    public URLStream( URL url ) throws IOException {
+      this.url = url; 
+      this.conn = this.url.openConnection();
+      
+      contentType = conn.getContentType();
+      name = url.toExternalForm();
+      size = new Long( conn.getContentLength() );
+      sourceInfo = "url";
+    }
+
+    public InputStream getStream() throws IOException {
+      return conn.getInputStream();
+    }
+  }
+  
+  /**
+   * Construct a <code>ContentStream</code> from a <code>File</code>
+   */
+  public static class FileStream extends ContentStreamBase
+  {
+    private final File file;
+    
+    public FileStream( File f ) throws IOException {
+      file = f; 
+      
+      contentType = null; // ??
+      name = file.getName();
+      size = file.length();
+      sourceInfo = file.toURI().toString();
+    }
+
+    public InputStream getStream() throws IOException {
+      return new FileInputStream( file );
+    }
+
+    /**
+     * If an charset is defined (by the contentType) ues that, otherwise 
+     * use a file reader
+     */
+    public Reader getReader() throws IOException {
+      String charset = getCharsetFromContentType( contentType );
+      return charset == null 
+        ? new FileReader( file )
+        : new InputStreamReader( getStream(), charset );
+    }
+  }
+  
+
+  /**
+   * Construct a <code>ContentStream</code> from a <code>File</code>
+   */
+  public static class StringStream extends ContentStreamBase
+  {
+    private final String str;
+    
+    public StringStream( String str ) {
+      this.str = str; 
+      
+      contentType = null;
+      name = null;
+      size = new Long( str.length() );
+      sourceInfo = "string";
+    }
+
+    public InputStream getStream() throws IOException {
+      return new ByteArrayInputStream( str.getBytes() );
+    }
+
+    /**
+     * If an charset is defined (by the contentType) ues that, otherwise 
+     * use a StringReader
+     */
+    public Reader getReader() throws IOException {
+      String charset = getCharsetFromContentType( contentType );
+      return charset == null 
+        ? new StringReader( str )
+        : new InputStreamReader( getStream(), charset );
+    }
+  }
+
+  /**
+   * Base reader implementation.  If the contentType declares a 
+   * charset use it, otherwise use "utf-8".
+   */
+  public Reader getReader() throws IOException {
+    String charset = getCharsetFromContentType( getContentType() );
+    return charset == null 
+      ? new InputStreamReader( getStream(), DEFAULT_CHARSET )
+      : new InputStreamReader( getStream(), charset );
+  }
+
+  //------------------------------------------------------------------
+  // Getters / Setters for overrideable attributes
+  //------------------------------------------------------------------
+
+  public String getContentType() {
+    return contentType;
+  }
+
+  public void setContentType(String contentType) {
+    this.contentType = contentType;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  public Long getSize() {
+    return size;
+  }
+
+  public void setSize(Long size) {
+    this.size = size;
+  }
+
+  public String getSourceInfo() {
+    return sourceInfo;
+  }
+
+  public void setSourceInfo(String sourceInfo) {
+    this.sourceInfo = sourceInfo;
+  }
+}
diff --git a/src/java/org/apache/solr/common/util/DOMUtil.java b/src/java/org/apache/solr/common/util/DOMUtil.java
new file mode 100644
index 0000000..a86122f
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/DOMUtil.java
@@ -0,0 +1,365 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.apache.solr.common.SolrException;
+
+import java.util.Map;
+import java.util.HashMap;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.Iterator;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class DOMUtil {
+
+  public static Map<String,String> toMap(NamedNodeMap attrs) {
+    return toMapExcept(attrs);
+  }
+
+  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
+    Map<String,String> args = new HashMap<String,String>();
+    outer: for (int j=0; j<attrs.getLength(); j++) {
+      Node attr = attrs.item(j);
+      String attrName = attr.getNodeName();
+      for (String ex : exclusions)
+        if (ex.equals(attrName)) continue outer;
+      String val = attr.getNodeValue();
+      args.put(attrName, val);
+    }
+    return args;
+  }
+
+  public static Node getChild(Node node, String name) {
+    if (!node.hasChildNodes()) return null;
+    NodeList lst = node.getChildNodes();
+    if (lst == null) return null;
+    for (int i=0; i<lst.getLength(); i++) {
+      Node child = lst.item(i);
+      if (name.equals(child.getNodeName())) return child;
+    }
+    return null;
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name) {
+    return getAttr(attrs,name,null);
+  }
+
+  public static String getAttr(Node nd, String name) {
+    return getAttr(nd.getAttributes(), name);
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
+    Node attr = attrs==null? null : attrs.getNamedItem(name);
+    if (attr==null) {
+      if (missing_err==null) return null;
+      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
+    }
+    String val = attr.getNodeValue();
+    return val;
+  }
+
+  public static String getAttr(Node node, String name, String missing_err) {
+    return getAttr(node.getAttributes(), name, missing_err);
+  }
+
+  //////////////////////////////////////////////////////////
+  // Routines to parse XML in the syntax of the Solr query
+  // response schema.
+  // Should these be moved to Config?  Should all of these things?
+  //////////////////////////////////////////////////////////
+  public static NamedList childNodesToNamedList(Node nd) {
+    return nodesToNamedList(nd.getChildNodes());
+  }
+
+  public static List childNodesToList(Node nd) {
+    return nodesToList(nd.getChildNodes());
+  }
+
+  public static NamedList nodesToNamedList(NodeList nlst) {
+    NamedList clst = new NamedList();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), clst, null);
+    }
+    return clst;
+  }
+
+  public static List nodesToList(NodeList nlst) {
+    List lst = new ArrayList();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), null, lst);
+    }
+    return lst;
+  }
+
+
+  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
+    // Nodes often include whitespace, etc... so just return if this
+    // is not an Element.
+    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
+
+    String type = nd.getNodeName();
+
+    String name = null;
+    if (nd.hasAttributes()) {
+      NamedNodeMap attrs = nd.getAttributes();
+      Node nameNd = attrs.getNamedItem("name");
+      if (nameNd != null) name=nameNd.getNodeValue();
+    }
+
+    Object val=null;
+
+    if ("str".equals(type)) {
+      val = getText(nd);
+    } else if ("int".equals(type)) {
+      val = Integer.valueOf(getText(nd));
+    } else if ("long".equals(type)) {
+      val = Long.valueOf(getText(nd));
+    } else if ("float".equals(type)) {
+      val = Float.valueOf(getText(nd));
+    } else if ("double".equals(type)) {
+      val = Double.valueOf(getText(nd));
+    } else if ("bool".equals(type)) {
+      val = Boolean.valueOf(getText(nd));
+    } else if ("lst".equals(type)) {
+      val = childNodesToNamedList(nd);
+    } else if ("arr".equals(type)) {
+      val = childNodesToList(nd);
+    }
+
+    if (nlst != null) nlst.add(name,val);
+    if (arr != null) arr.add(val);
+  }
+
+  /**
+   * Drop in replacement for Node.getTextContent().
+   *
+   * <p>
+   * This method is provided to support the same functionality as
+   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
+   * </p>
+   *
+   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
+   */
+  public static String getText(Node nd) {
+
+    short type = nd.getNodeType();
+
+    // for most node types, we can defer to the recursive helper method,
+    // but when asked for the text of these types, we must return null
+    // (Not the empty string)
+    switch (type) {
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+      return null;
+    }
+
+    StringBuilder sb = new StringBuilder();
+    getText(nd, sb);
+    return sb.toString();
+  }
+
+  /** @see #getText(Node) */
+  private static void getText(Node nd, StringBuilder buf) {
+
+    short type = nd.getNodeType();
+
+    switch (type) {
+
+    case Node.ELEMENT_NODE: /* fall through */
+    case Node.ENTITY_NODE: /* fall through */
+    case Node.ENTITY_REFERENCE_NODE: /* fall through */
+    case Node.DOCUMENT_FRAGMENT_NODE:
+      NodeList childs = nd.getChildNodes();
+      for (int i = 0; i < childs.getLength(); i++) {
+        Node child = childs.item(i);
+        short childType = child.getNodeType();
+        if (childType != Node.COMMENT_NODE &&
+            childType != Node.PROCESSING_INSTRUCTION_NODE) {
+          getText(child, buf);
+        }
+      }
+      break;
+
+    case Node.ATTRIBUTE_NODE: /* fall through */
+      /* Putting Attribute nodes in this section does not exactly 
+         match the definition of how textContent should behave 
+         according to the DOM Level-3 Core documentation - which 
+         specifies that the Attr's children should have their 
+         textContent concated (Attr's can have a single child which 
+         is either Text node or an EntityRefrence).  In practice,
+         DOM implementations do not seem to use child nodes of 
+         Attributes, storing the "text" directly as the nodeValue.
+         Fortunately, the DOM Spec indicates that when Attr.nodeValue 
+         is read, it should return the nodeValue from the child Node, 
+         so this approach should work both for strict implementations, 
+         and implementations actually encountered.
+      */
+    case Node.TEXT_NODE: /* fall through */
+    case Node.CDATA_SECTION_NODE: /* fall through */
+    case Node.COMMENT_NODE: /* fall through */
+    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
+      buf.append(nd.getNodeValue());
+      break;
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+    default:
+      /* :NOOP: */
+
+    }
+  }
+
+  /**
+   * Replaces ${system.property[:default value]} references in all attributes
+   * and text nodes of supplied node.  If the system property is not defined and no
+   * default value is provided, a runtime exception is thrown.
+   *
+   * @param node DOM node to walk for substitutions
+   */
+  public static void substituteSystemProperties(Node node) {
+    // loop through child nodes
+    Node child;
+    Node next = node.getFirstChild();
+    while ((child = next) != null) {
+
+      // set next before we change anything
+      next = child.getNextSibling();
+
+      // handle child by node type
+      if (child.getNodeType() == Node.TEXT_NODE) {
+        child.setNodeValue(substituteSystemProperty(child.getNodeValue()));
+      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
+        // handle child elements with recursive call
+        NamedNodeMap attributes = child.getAttributes();
+        for (int i = 0; i < attributes.getLength(); i++) {
+          Node attribute = attributes.item(i);
+          attribute.setNodeValue(substituteSystemProperty(attribute.getNodeValue()));
+        }
+        substituteSystemProperties(child);
+      }
+    }
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.replaceProperties:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  private static String substituteSystemProperty(String value) {
+    if (value == null || value.indexOf('$') == -1) {
+      return value;
+    }
+
+    List<String> fragments = new ArrayList<String>();
+    List<String> propertyRefs = new ArrayList<String>();
+    parsePropertyString(value, fragments, propertyRefs);
+
+    StringBuffer sb = new StringBuffer();
+    Iterator<String> i = fragments.iterator();
+    Iterator<String> j = propertyRefs.iterator();
+
+    while (i.hasNext()) {
+      String fragment = i.next();
+      if (fragment == null) {
+        String propertyName = j.next();
+        String defaultValue = null;
+        int colon_index = propertyName.indexOf(':');
+        if (colon_index > -1) {
+          defaultValue = propertyName.substring(colon_index + 1);
+          propertyName = propertyName.substring(0,colon_index);
+        }
+        fragment = System.getProperty(propertyName,defaultValue);
+        if (fragment == null) {
+          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName);
+        }
+      }
+      sb.append(fragment);
+    }
+    return sb.toString();
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
+      int prev = 0;
+      int pos;
+      //search for the next instance of $ from the 'prev' position
+      while ((pos = value.indexOf("$", prev)) >= 0) {
+
+          //if there was any text before this, add it as a fragment
+          //TODO, this check could be modified to go if pos>prev;
+          //seems like this current version could stick empty strings
+          //into the list
+          if (pos > 0) {
+              fragments.add(value.substring(prev, pos));
+          }
+          //if we are at the end of the string, we tack on a $
+          //then move past it
+          if (pos == (value.length() - 1)) {
+              fragments.add("$");
+              prev = pos + 1;
+          } else if (value.charAt(pos + 1) != '{') {
+              //peek ahead to see if the next char is a property or not
+              //not a property: insert the char as a literal
+              /*
+              fragments.addElement(value.substring(pos + 1, pos + 2));
+              prev = pos + 2;
+              */
+              if (value.charAt(pos + 1) == '$') {
+                  //backwards compatibility two $ map to one mode
+                  fragments.add("$");
+                  prev = pos + 2;
+              } else {
+                  //new behaviour: $X maps to $X for all values of X!='$'
+                  fragments.add(value.substring(pos, pos + 2));
+                  prev = pos + 2;
+              }
+
+          } else {
+              //property found, extract its name or bail on a typo
+              int endName = value.indexOf('}', pos);
+              if (endName < 0) {
+                throw new RuntimeException("Syntax error in property: " + value);
+              }
+              String propertyName = value.substring(pos + 2, endName);
+              fragments.add(null);
+              propertyRefs.add(propertyName);
+              prev = endName + 1;
+          }
+      }
+      //no more $ signs found
+      //if there is any tail to the string, append it
+      if (prev < value.length()) {
+          fragments.add(value.substring(prev));
+      }
+  }
+
+}
diff --git a/src/java/org/apache/solr/common/util/IteratorChain.java b/src/java/org/apache/solr/common/util/IteratorChain.java
new file mode 100644
index 0000000..a477180
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/IteratorChain.java
@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/** Chain several Iterators, so that this iterates
+ *  over all of them in sequence.
+ */
+
+public class IteratorChain<E> implements Iterator<E> {
+
+  private final List<Iterator<E>> iterators = new ArrayList<Iterator<E>>();
+  private Iterator<Iterator<E>> itit;
+  private Iterator<E> current;
+ 
+  public void addIterator(Iterator<E> it) {
+    if(itit!=null) throw new RuntimeException("all Iterators must be added before calling hasNext()");
+    iterators.add(it);
+  }
+  
+  public boolean hasNext() {
+    if(itit==null) itit = iterators.iterator();
+    return recursiveHasNext();
+  }
+  
+  /** test if current iterator hasNext(), and if not try the next
+   *  one in sequence, recursively
+   */
+  private boolean recursiveHasNext() {
+    // return false if we have no more iterators
+    if(current==null) {
+      if(itit.hasNext()) {
+        current=itit.next();
+      } else {
+        return false;
+      }
+    }
+    
+    boolean result = current.hasNext();
+    if(!result) {
+      current = null;
+      result = recursiveHasNext();
+    }
+    
+    return result;
+  }
+
+  /** hasNext() must ALWAYS be called before calling this
+   *  otherwise it's a bit hard to keep track of what's happening
+   */
+  public E next() {
+    if(current==null) { 
+      throw new RuntimeException("For an IteratorChain, hasNext() MUST be called before calling next()");
+    }
+    return current.next();
+  }
+
+  public void remove() {
+    // we just need this class 
+    // to iterate in readonly mode
+    throw new UnsupportedOperationException();
+  }
+  
+}
diff --git a/src/java/org/apache/solr/common/util/MoreLikeThisParams.java b/src/java/org/apache/solr/common/util/MoreLikeThisParams.java
new file mode 100644
index 0000000..4d8193a
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/MoreLikeThisParams.java
@@ -0,0 +1,50 @@
+package org.apache.solr.common.util;
+
+public interface MoreLikeThisParams 
+{
+  // enable more like this -- this only applies to 'StandardRequestHandler' maybe DismaxRequestHandler
+  public final static String MLT = "mlt";
+  
+  public final static String PREFIX = "mlt.";
+  
+  public final static String SIMILARITY_FIELDS     = PREFIX + "fl";
+  public final static String MIN_TERM_FREQ         = PREFIX + "mintf";
+  public final static String MIN_DOC_FREQ          = PREFIX + "mindf";
+  public final static String MIN_WORD_LEN          = PREFIX + "minwl";
+  public final static String MAX_WORD_LEN          = PREFIX + "maxwl";
+  public final static String MAX_QUERY_TERMS       = PREFIX + "maxqt";
+  public final static String MAX_NUM_TOKENS_PARSED = PREFIX + "maxntp";
+  public final static String BOOST                 = PREFIX + "boost"; // boost or not?
+
+  // the /mlt request handler uses 'rows'
+  public final static String DOC_COUNT = PREFIX + "count";
+
+  // Do you want to include the original document in the results or not
+  public final static String MATCH_INCLUDE = PREFIX + "match.include";
+  
+  // If multiple docs are matched in the query, what offset do you want?
+  public final static String MATCH_OFFSET  = PREFIX + "match.offset";
+
+  // Do you want to include the original document in the results or not
+  public final static String INTERESTING_TERMS = PREFIX + "interestingTerms";  // false,details,(list or true)
+  
+  public enum TermStyle {
+    NONE,
+    LIST,
+    DETAILS;
+    
+    public static TermStyle get( String p )
+    {
+      if( p != null ) {
+        p = p.toUpperCase();
+        if( p.equals( "DETAILS" ) ) {
+          return DETAILS;
+        }
+        else if( p.equals( "LIST" ) ) {
+          return LIST;
+        }
+      }
+      return NONE; 
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/common/util/NamedList.java b/src/java/org/apache/solr/common/util/NamedList.java
new file mode 100644
index 0000000..a4a867b
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/NamedList.java
@@ -0,0 +1,264 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.*;
+import java.io.Serializable;
+
+
+
+/**
+ * A simple container class for modeling an ordered list of name/value pairs.
+ *
+ * <p>
+ * Unlike Maps:
+ * </p>
+ * <ul>
+ *  <li>Names may be repeated</li>
+ *  <li>Order of elements is maintained</li>
+ *  <li>Elements may be accessed by numeric index</li>
+ *  <li>Names and Values can both be null</li>
+ * </ul>
+ *
+ * <p>
+ * A NamedList provides fast access by element number, but not by name.
+ * </p>
+ * <p>
+ * When a NamedList is serialized, order is considered more important than access
+ * by key, so ResponseWriters that output to a format such as JSON will normally
+ * choose a data structure that allows order to be easily preserved in various
+ * clients (i.e. not a straight map).
+ * If access by key is more important, see {@link SimpleOrderedMap},
+ * or simply use a regular {@link Map}
+ * </p>
+ *
+ * @author yonik
+ * @version $Id$
+ */
+public class NamedList<T> implements Cloneable, Serializable, Iterable<Map.Entry<String,T>> {
+  protected final List nvPairs;
+
+  /** Creates an empty instance */
+  public NamedList() {
+    nvPairs = new ArrayList();
+  }
+
+  /**
+   * Creates an instance backed by an explicitly specified list of
+   * pairwise names/values.
+   *
+   * @param nameValuePairs underlying List which should be used to implement a NamedList; modifying this List will affect the NamedList.
+   */
+  public NamedList(List nameValuePairs) {
+    nvPairs=nameValuePairs;
+  }
+
+  /** The total number of name/value pairs */
+  public int size() {
+    return nvPairs.size() >> 1;
+  }
+
+  /**
+   * The name of the pair at the specified List index
+   *
+   * @return null if no name exists
+   */
+  public String getName(int idx) {
+    return (String)nvPairs.get(idx << 1);
+  }
+
+  /**
+   * The value of the pair at the specified List index
+   *
+   * @return may be null
+   */
+  @SuppressWarnings("unchecked")
+  public T getVal(int idx) {
+    return (T)nvPairs.get((idx << 1) + 1);
+  }
+  
+  /**
+   * Adds a name/value pair to the end of the list.
+   */
+  public void add(String name, T val) {
+    nvPairs.add(name);
+    nvPairs.add(val);
+  }
+
+  /**
+   * Modifies the name of the pair at the specified index.
+   */
+  public void setName(int idx, String name) {
+    nvPairs.set(idx<<1, name);
+  }
+
+  /**
+   * Modifies the value of the pair at the specified index.
+   * @return the value that used to be at index
+   */
+  public T setVal(int idx, T val) {
+    int index = (idx<<1)+1;
+    T old = (T)nvPairs.get( index );
+    nvPairs.set(index, val);
+    return old;
+  }
+
+  /**
+   * Scans the list sequentially beginning at the specified index and
+   * returns the index of the first pair with the specified name.
+   *
+   * @param name name to look for, may be null
+   * @param start index to begin searching from
+   * @return The index of the first matching pair, -1 if no match
+   */
+  public int indexOf(String name, int start) {
+    int sz = size();
+    for (int i=start; i<sz; i++) {
+      String n = getName(i);
+      if (name==null) {
+        if (n==null) return i; // matched null
+      } else if (name.equals(n)) {
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  /**
+   * Gets the value for the first instance of the specified name
+   * found.
+   * 
+   * @return null if not found or if the value stored was null.
+   * @see #indexOf
+   * @see #get(String,int)
+   */
+  public T get(String name) {
+    return get(name,0);
+  }
+
+  /**
+   * Gets the value for the first instance of the specified name
+   * found starting at the specified index.
+   * 
+   * @return null if not found or if the value stored was null.
+   * @see #indexOf
+   */
+  public T get(String name, int start) {
+    int sz = size();
+    for (int i=start; i<sz; i++) {
+      String n = getName(i);
+      if (name==null) {
+        if (n==null) return getVal(i);
+      } else if (name.equals(n)) {
+        return getVal(i);
+      }
+    }
+    return null;
+  }
+
+  public String toString() {
+    StringBuffer sb = new StringBuffer();
+    sb.append('{');
+    int sz = size();
+    for (int i=0; i<sz; i++) {
+      if (i != 0) sb.append(',');
+      sb.append(getName(i));
+      sb.append('=');
+      sb.append(getVal(i));
+    }
+    sb.append('}');
+
+    return sb.toString();
+  }
+
+  /**
+   * Iterates over the Map and sequentially adds it's key/value pairs
+   */
+  public boolean addAll(Map<String,T> args) {
+    for( Map.Entry<String, T> entry : args.entrySet() ) {
+      add( entry.getKey(), entry.getValue() );
+    }
+    return args.size()>0;
+  }
+
+  /** Appends the elements of the given NamedList to this one. */
+  public boolean addAll(NamedList<T> nl) {
+    nvPairs.addAll(nl.nvPairs);
+    return nl.size()>0;
+  }
+
+  /**
+   * Makes a <i>shallow copy</i> of the named list.
+   */
+  public NamedList<T> clone() {
+    ArrayList newList = new ArrayList(nvPairs.size());
+    newList.addAll(nvPairs);
+    return new NamedList<T>(newList);
+  }
+
+
+  //----------------------------------------------------------------------------
+  // Iterable interface
+  //----------------------------------------------------------------------------
+  
+  /**
+   * Support the Iterable interface
+   */
+  public Iterator<Map.Entry<String,T>> iterator() {
+    
+    final NamedList list = this;
+    
+    Iterator<Map.Entry<String,T>> iter = new Iterator<Map.Entry<String,T>>() {
+      
+      int idx = 0;
+      
+      public boolean hasNext() {
+        return idx < list.size();
+      }
+
+      public Map.Entry<String,T> next() {
+        final int index = idx++;
+        Map.Entry<String,T> nv = new Map.Entry<String,T>() {
+          public String getKey() {
+            return list.getName( index );
+          }
+
+          @SuppressWarnings("unchecked")
+		  public T getValue() {
+            return (T)list.getVal( index );
+          }
+          
+          public String toString()
+          {
+        	  return getKey()+"="+getValue();
+          }
+
+		  public T setValue(T value) {
+			return (T) list.setVal(index, value);
+		  }
+        };
+        return nv;
+      }
+
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+    return iter;
+  }
+}
diff --git a/src/java/org/apache/solr/common/util/SimpleOrderedMap.java b/src/java/org/apache/solr/common/util/SimpleOrderedMap.java
new file mode 100755
index 0000000..8b606c3
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/SimpleOrderedMap.java
@@ -0,0 +1,61 @@
+package org.apache.solr.common.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+
+/** <code>SimpleOrderedMap</code> is a {@link NamedList} where access by key is more
+ * important than maintaining order when it comes to representing the
+ * held data in other forms, as ResponseWriters normally do.
+ * It's normally not a good idea to repeat keys or use null keys, but this
+ * is not enforced.  If key uniqueness enforcement is desired, use a regular {@link Map}.
+ * <p>
+ * For example, a JSON response writer may choose to write a SimpleOrderedMap
+ * as {"foo":10,"bar":20} and may choose to write a NamedList as
+ * ["foo",10,"bar",20].  An XML response writer may choose to render both
+ * the same way.
+ * </p>
+ * <p>
+ * This class does not provide efficient lookup by key, it's main purpose is
+ * to hold data to be serialized.  It aims to minimize overhead and to be
+ * efficient at adding new elements.
+ * </p>
+ */
+public class SimpleOrderedMap<T> extends NamedList<T> {
+  /** Creates an empty instance */
+  public SimpleOrderedMap() {
+    super();
+  }
+
+  /**
+   * Creates an instance backed by an explicitly specified list of
+   * pairwise names/values.
+   *
+   * @param nameValuePairs underlying List which should be used to implement a SimpleOrderedMap; modifying this List will affect the SimpleOrderedMap.
+   */
+  public SimpleOrderedMap(List nameValuePairs) {
+    super(nameValuePairs);
+  }
+
+  public SimpleOrderedMap<T> clone() {
+    ArrayList newList = new ArrayList(nvPairs.size());
+    newList.addAll(nvPairs);
+    return new SimpleOrderedMap<T>(newList);
+  }
+}
diff --git a/src/java/org/apache/solr/common/util/XML.java b/src/java/org/apache/solr/common/util/XML.java
new file mode 100644
index 0000000..0e90fd6
--- /dev/null
+++ b/src/java/org/apache/solr/common/util/XML.java
@@ -0,0 +1,184 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.Writer;
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id$
+ */
+public class XML {
+
+  //
+  // copied from some of my personal code...  -YCS
+  // table created from python script.
+  // only have to escape quotes in attribute values, and don't really have to escape '>'
+  // many chars less than 0x20 are *not* valid XML, even when escaped!
+  // for example, <foo>&#0;<foo> is invalid XML.
+  private static final String[] chardata_escapes=
+  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,null,null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;",null,"&gt;"};
+
+  private static final String[] attribute_escapes=
+  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,"&quot;",null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;"};
+
+
+
+  /*****************************************
+   #Simple python script used to generate the escape table above.  -YCS
+   #
+   #use individual char arrays or one big char array for better efficiency
+   # or byte array?
+   #other={'&':'amp', '<':'lt', '>':'gt', "'":'apos', '"':'quot'}
+   #
+   other={'&':'amp', '<':'lt'}
+
+   maxi=ord(max(other.keys()))+1
+   table=[None] * maxi
+   #NOTE: invalid XML chars are "escaped" as #nn; *not* &#nn; because
+   #a real XML escape would cause many strict XML parsers to choke.
+   for i in range(0x20): table[i]='#%d;' % i
+   for i in '\n\r\t ': table[ord(i)]=None
+   for k,v in other.items():
+    table[ord(k)]='&%s;' % v
+
+   result=""
+   for i in range(maxi):
+     val=table[i]
+     if not val: val='null'
+     else: val='"%s"' % val
+     result += val + ','
+
+   print result
+   ****************************************/
+
+
+/*********
+ *
+ * @param str
+ * @param out
+ * @throws IOException
+ */
+  public static void escapeCharData(String str, Writer out) throws IOException {
+    escape(str, out, chardata_escapes);
+  }
+
+  public static void escapeAttributeValue(String str, Writer out) throws IOException {
+    escape(str, out, attribute_escapes);
+  }
+
+
+  public final static void writeXML(Writer out, String tag, String val) throws IOException {
+    out.write('<');
+    out.write(tag);
+    if (val == null) {
+      out.write("/>");
+    } else {
+      out.write('>');
+      escapeCharData(val,out);
+      out.write("</");
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+  /** does NOT escape character data in val, must already be valid XML */
+  public final static void writeUnescapedXML(Writer out, String tag, String val, Object... attrs) throws IOException {
+    out.write('<');
+    out.write(tag);
+    for (int i=0; i<attrs.length; i++) {
+      out.write(' ');
+      out.write(attrs[i++].toString());
+      out.write("=\"");
+      out.write(attrs[i].toString());
+      out.write("\"");
+    }
+    if (val == null) {
+      out.write("/>");
+    } else {
+      out.write('>');
+      out.write(val);
+      out.write("</");
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+  /** escapes character data in val */
+  public final static void writeXML(Writer out, String tag, String val, Object... attrs) throws IOException {
+    out.write('<');
+    out.write(tag);
+    for (int i=0; i<attrs.length; i++) {
+      out.write(' ');
+      out.write(attrs[i++].toString());
+      out.write("=\"");
+      escapeAttributeValue(attrs[i].toString(), out);
+      out.write("\"");
+    }
+    if (val == null) {
+      out.write("/>");
+    } else {
+      out.write('>');
+      escapeCharData(val,out);
+      out.write("</");
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+
+  private static void escape(String str, Writer out, String[] escapes) throws IOException {
+    int start=0;
+    // "n" was used for counting the chars added to out...
+    // removed cause it wasn't really useful so far.
+    // int n=0;
+
+    for (int i=start; i<str.length(); i++) {
+      char ch = str.charAt(i);
+      // since I already received the char, what if I put it into
+      // a char array and wrote that to the stream instead of the
+      // string? (would cause extra GC though)
+      String subst=null;
+      if (ch<escapes.length) {
+        subst=escapes[ch];
+      }
+      if (subst != null) {
+        if (start<i) {
+          out.write(str.substring(start,i));
+          // write(str,off,len) causes problems for Jetty with chars > 127
+          //out.write(str, start, i-start);
+          // n+=i-start;
+        }
+        out.write(subst);
+        // n+=subst.length();
+        start=i+1;
+      }
+    }
+    if (start==0) {
+      out.write(str);
+      // n += str.length();
+    } else if (start<str.length()) {
+      out.write(str.substring(start));
+      // write(str,off,len) causes problems for Jetty with chars > 127
+      // out.write(str, start, str.length()-start);
+      // n += str.length()-start;
+    }
+    // return n;
+  }
+}
diff --git a/src/java/org/apache/solr/core/AbstractSolrEventListener.java b/src/java/org/apache/solr/core/AbstractSolrEventListener.java
index e8840fc..aa692c6 100644
--- a/src/java/org/apache/solr/core/AbstractSolrEventListener.java
+++ b/src/java/org/apache/solr/core/AbstractSolrEventListener.java
@@ -17,8 +17,8 @@
 
 package org.apache.solr.core;
 
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.NamedList;
 
 /**
  * @author yonik
diff --git a/src/java/org/apache/solr/core/Config.java b/src/java/org/apache/solr/core/Config.java
index 0173c9e..fd48d5f 100644
--- a/src/java/org/apache/solr/core/Config.java
+++ b/src/java/org/apache/solr/core/Config.java
@@ -20,9 +20,9 @@ package org.apache.solr.core;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.xml.sax.SAXException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.util.DOMUtil;
 
 import javax.naming.Context;
 import javax.naming.InitialContext;
diff --git a/src/java/org/apache/solr/core/QuerySenderListener.java b/src/java/org/apache/solr/core/QuerySenderListener.java
index d44454e..88d775e 100644
--- a/src/java/org/apache/solr/core/QuerySenderListener.java
+++ b/src/java/org/apache/solr/core/QuerySenderListener.java
@@ -20,9 +20,9 @@ package org.apache.solr.core;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.DocIterator;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.NamedList;
 
 import java.util.List;
 
diff --git a/src/java/org/apache/solr/core/RequestHandlers.java b/src/java/org/apache/solr/core/RequestHandlers.java
index 16f075f..e298439 100644
--- a/src/java/org/apache/solr/core/RequestHandlers.java
+++ b/src/java/org/apache/solr/core/RequestHandlers.java
@@ -26,13 +26,14 @@ import java.util.logging.Logger;
 
 import javax.xml.xpath.XPathConstants;
 
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.handler.StandardRequestHandler;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.StandardRequestHandler;
-import org.apache.solr.util.DOMUtil;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
diff --git a/src/java/org/apache/solr/core/RunExecutableListener.java b/src/java/org/apache/solr/core/RunExecutableListener.java
index a1c9c09..c969384 100644
--- a/src/java/org/apache/solr/core/RunExecutableListener.java
+++ b/src/java/org/apache/solr/core/RunExecutableListener.java
@@ -17,7 +17,8 @@
 
 package org.apache.solr.core;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.SolrIndexSearcher;
 
 import java.io.File;
diff --git a/src/java/org/apache/solr/core/SolrConfig.java b/src/java/org/apache/solr/core/SolrConfig.java
index cd92e3b..f72c2d1 100644
--- a/src/java/org/apache/solr/core/SolrConfig.java
+++ b/src/java/org/apache/solr/core/SolrConfig.java
@@ -17,9 +17,9 @@
 
 package org.apache.solr.core;
 
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.util.NamedList;
 
 import org.xml.sax.SAXException;
 
diff --git a/src/java/org/apache/solr/core/SolrCore.java b/src/java/org/apache/solr/core/SolrCore.java
index b299181..0b1404a 100644
--- a/src/java/org/apache/solr/core/SolrCore.java
+++ b/src/java/org/apache/solr/core/SolrCore.java
@@ -36,26 +36,27 @@ import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.SolrParams.EchoParamStyle;
+import org.apache.solr.common.util.DOMUtil;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.JSONResponseWriter;
 import org.apache.solr.request.PythonResponseWriter;
 import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.RubyResponseWriter;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.request.XMLResponseWriter;
-import org.apache.solr.request.SolrParams.EchoParamStyle;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.update.DirectUpdateHandler;
 import org.apache.solr.update.SolrIndexConfig;
 import org.apache.solr.update.SolrIndexWriter;
 import org.apache.solr.update.UpdateHandler;
-import org.apache.solr.util.DOMUtil;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.RefCounted;
-import org.apache.solr.util.SimpleOrderedMap;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
diff --git a/src/java/org/apache/solr/core/SolrEventListener.java b/src/java/org/apache/solr/core/SolrEventListener.java
index 9a137a0..cfdc92a 100644
--- a/src/java/org/apache/solr/core/SolrEventListener.java
+++ b/src/java/org/apache/solr/core/SolrEventListener.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.core;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.SolrIndexSearcher;
 
 import java.util.logging.Logger;
diff --git a/src/java/org/apache/solr/core/SolrException.java b/src/java/org/apache/solr/core/SolrException.java
deleted file mode 100644
index 92b3d8d..0000000
--- a/src/java/org/apache/solr/core/SolrException.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.core;
-
-import java.util.logging.Logger;
-import java.io.CharArrayWriter;
-import java.io.PrintWriter;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class SolrException extends RuntimeException {
-  
-  /**
-   * @since solr 1.2
-   */
-  public enum ErrorCode {
-    BAD_REQUEST( 400 ),
-    UNAUTHORIZED( 401 ),
-    FORBIDDEN( 403 ),
-    NOT_FOUND( 404 ),
-    SERVER_ERROR( 500 ),
-    SERVICE_UNAVAILABLE( 503 ); 
-    
-    final int code;
-    
-    private ErrorCode( int c )
-    {
-      code = c;
-    }
-  };
-  
-  public boolean logged=false;
-
-  public SolrException(ErrorCode code, String msg) {
-    super(msg);
-    this.code=code.code;
-  }
-  
-  public SolrException(ErrorCode code, String msg, boolean alreadyLogged) {
-    super(msg);
-    this.code=code.code;
-    this.logged=alreadyLogged;
-  }
-
-  public SolrException(ErrorCode code, String msg, Throwable th, boolean alreadyLogged) {
-    super(msg,th);
-    this.code=code.code;
-    logged=alreadyLogged;
-  }
-
-  public SolrException(ErrorCode code, String msg, Throwable th) {
-    this(code,msg,th,true);
-  }
-
-  public SolrException(ErrorCode code, Throwable th) {
-    super(th);
-    this.code=code.code;
-    logged=true;
-  }
-  
-  @Deprecated
-  public SolrException(int code, String msg) {
-    super(msg);
-    this.code=code;
-  }
-  
-  @Deprecated
-  public SolrException(int code, String msg, boolean alreadyLogged) {
-    super(msg);
-    this.code=code;
-    this.logged=alreadyLogged;
-  }
-
-  @Deprecated
-  public SolrException(int code, String msg, Throwable th, boolean alreadyLogged) {
-    super(msg,th);
-    this.code=code;
-    logged=alreadyLogged;
-  }
-
-  @Deprecated
-  public SolrException(int code, String msg, Throwable th) {
-    this(code,msg,th,true);
-  }
-
-  @Deprecated
-  public SolrException(int code, Throwable th) {
-    super(th);
-    this.code=code;
-    logged=true;
-  }
-
-  int code=0;
-  public int code() { return code; }
-
-
-
-
-  public void log(Logger log) { log(log,this); }
-  public static void log(Logger log, Throwable e) {
-    log.severe(toStr(e));
-    if (e instanceof SolrException) {
-      ((SolrException)e).logged = true;
-    }
-  }
-
-  public static void log(Logger log, String msg, Throwable e) {
-    log.severe(msg + ':' + toStr(e));
-    if (e instanceof SolrException) {
-      ((SolrException)e).logged = true;
-    }
-  }
-
-  public static void logOnce(Logger log, String msg, Throwable e) {
-    if (e instanceof SolrException) {
-      if(((SolrException)e).logged) return;
-    }
-    if (msg!=null) log(log,msg,e);
-    else log(log,e);
-  }
-
-
-  // public String toString() { return toStr(this); }  // oops, inf loop
-  @Override
-  public String toString() { return super.toString(); }
-
-  public static String toStr(Throwable e) {
-    CharArrayWriter cw = new CharArrayWriter();
-    PrintWriter pw = new PrintWriter(cw);
-    e.printStackTrace(pw);
-    pw.flush();
-    return cw.toString();
-
-/** This doesn't work for some reason!!!!!
-    StringWriter sw = new StringWriter();
-    PrintWriter pw = new PrintWriter(sw);
-    e.printStackTrace(pw);
-    pw.flush();
-    System.out.println("The STRING:" + sw.toString());
-    return sw.toString();
-**/
-  }
-
-}
diff --git a/src/java/org/apache/solr/core/SolrInfoMBean.java b/src/java/org/apache/solr/core/SolrInfoMBean.java
index 93911ba..b6a806f 100644
--- a/src/java/org/apache/solr/core/SolrInfoMBean.java
+++ b/src/java/org/apache/solr/core/SolrInfoMBean.java
@@ -18,6 +18,8 @@
 package org.apache.solr.core;
 
 import java.net.URL;
+
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.util.*;
 
 /**
diff --git a/src/java/org/apache/solr/handler/CSVRequestHandler.java b/src/java/org/apache/solr/handler/CSVRequestHandler.java
index 3bf0278..ffe2549 100755
--- a/src/java/org/apache/solr/handler/CSVRequestHandler.java
+++ b/src/java/org/apache/solr/handler/CSVRequestHandler.java
@@ -18,10 +18,10 @@
 package org.apache.solr.handler;
 
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.util.StrUtils;
diff --git a/src/java/org/apache/solr/handler/DisMaxRequestHandler.java b/src/java/org/apache/solr/handler/DisMaxRequestHandler.java
new file mode 100644
index 0000000..fc93a08
--- /dev/null
+++ b/src/java/org/apache/solr/handler/DisMaxRequestHandler.java
@@ -0,0 +1,426 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.handler;
+
+import static org.apache.solr.common.params.SolrParams.FACET;
+import static org.apache.solr.common.params.SolrParams.FQ;
+import static org.apache.solr.common.params.SolrParams.Q;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.DisMaxParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.request.SimpleFacets;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.search.DocListAndSet;
+import org.apache.solr.search.DocSet;
+import org.apache.solr.search.QueryParsing;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.SolrQueryParser;
+import org.apache.solr.util.HighlightingUtils;
+import org.apache.solr.util.SolrPluginUtils;
+    
+/**
+ * <p>
+ * A Generic query plugin designed to be given a simple query expression
+ * from a user, which it will then query against a variety of
+ * pre-configured fields, in a variety of ways, using BooleanQueries,
+ * DisjunctionMaxQueries, and PhraseQueries.
+ * </p>
+ *
+ * <p>
+ * All of the following options may be configured for this plugin
+ * in the solrconfig as defaults, and may be overriden as request parameters
+ * </p>
+ *
+ * <ul>
+ * <li>q.alt - An alternate query to be used in cases where the main
+ *             query (q) is not specified (or blank).  This query should
+ *             be expressed in the Standard SolrQueryParser syntax (you
+ *             can use <code>q.alt=*:*</code> to denote that all documents
+ *             should be returned when no query is specified)
+ * </li>
+ * <li>tie - (Tie breaker) float value to use as tiebreaker in
+ *           DisjunctionMaxQueries (should be something much less than 1)
+ * </li>
+ * <li> qf - (Query Fields) fields and boosts to use when building
+ *           DisjunctionMaxQueries from the users query.  Format is:
+ *           "<code>fieldA^1.0 fieldB^2.2</code>".
+ *           This param can be specified multiple times, and the fields
+ *           are additive.
+ * </li>
+ * <li> mm - (Minimum Match) this supports a wide variety of
+ *           complex expressions.
+ *           read {@link SolrPluginUtils#setMinShouldMatch SolrPluginUtils.setMinShouldMatch} and <a href="http://lucene.apache.org/solr/api/org/apache/solr/util/doc-files/min-should-match.html">mm expression format</a> for details.
+ * </li>
+ * <li> pf - (Phrase Fields) fields/boosts to make phrase queries out
+ *           of, to boost the users query for exact matches on the specified fields.
+ *           Format is: "<code>fieldA^1.0 fieldB^2.2</code>".
+ *           This param can be specified multiple times, and the fields
+ *           are additive.
+ * </li>
+ * <li> ps - (Phrase Slop) amount of slop on phrase queries built for pf
+ *           fields.
+ * </li>
+ * <li> qs - (Query Slop) amount of slop on phrase queries explicitly
+ *           specified in the "q" for qf fields.
+ * </li>
+ * <li> bq - (Boost Query) a raw lucene query that will be included in the 
+ *           users query to influence the score.  If this is a BooleanQuery
+ *           with a default boost (1.0f), then the individual clauses will be
+ *           added directly to the main query.  Otherwise, the query will be
+ *           included as is.
+ *           This param can be specified multiple times, and the boosts are 
+ *           are additive.  NOTE: the behaviour listed above is only in effect
+ *           if a single <code>bq</code> paramter is specified.  Hence you can
+ *           disable it by specifying an additional, blank, <code>bq</code> 
+ *           parameter.
+ * </li>
+ * <li> bf - (Boost Functions) functions (with optional boosts) that will be
+ *           included in the users query to influence the score.
+ *           Format is: "<code>funcA(arg1,arg2)^1.2
+ *           funcB(arg3,arg4)^2.2</code>".  NOTE: Whitespace is not allowed
+ *           in the function arguments.
+ *           This param can be specified multiple times, and the functions
+ *           are additive.
+ * </li>
+ * <li> fq - (Filter Query) a raw lucene query that can be used
+ *           to restrict the super set of products we are interested in - more
+ *           efficient then using bq, but doesn't influence score.
+ *           This param can be specified multiple times, and the filters
+ *           are additive.
+ * </li>
+ * </ul>
+ *
+ * <p>
+ * The following options are only available as request params...
+ * </p>
+ *
+ * <ul>
+ * <li>   q - (Query) the raw unparsed, unescaped, query from the user.
+ * </li>
+ * <li>sort - (Order By) list of fields and direction to sort on.
+ * </li>
+ * </ul>
+ *
+ * <pre>
+ * :TODO: document facet param support
+ *
+ * </pre>
+ */
+public class DisMaxRequestHandler extends RequestHandlerBase  {
+
+  /**
+   * A field we can't ever find in any schema, so we can safely tell
+   * DisjunctionMaxQueryParser to use it as our defaultField, and
+   * map aliases from it to any field in our schema.
+   */
+  private static String IMPOSSIBLE_FIELD_NAME = "\uFFFC\uFFFC\uFFFC";
+    
+    
+  /** shorten the class references for utilities */
+  private static class U extends SolrPluginUtils {
+    /* :NOOP */
+  }
+  /** shorten the class references for utilities */
+  private static class DMP extends DisMaxParams {
+    /* :NOOP */
+  }
+
+  public DisMaxRequestHandler() {
+    super();
+  }
+  
+  /** Sets the default variables for any useful info it finds in the config.
+   * If a config option is not in the format expected, logs a warning
+   * and ignores it.
+   */
+  public void init(NamedList args) {
+	// Handle an old format
+    if (-1 == args.indexOf("defaults",0)) {
+      // no explict defaults list, use all args implicitly
+      // indexOf so "<null name="defaults"/> is valid indicator of no defaults
+      defaults = SolrParams.toSolrParams(args);
+    } else {
+      // otherwise use the new one.
+      super.init( args );
+    }
+  }
+
+  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception
+  {
+      SolrParams params = req.getParams();
+      
+      int flags = 0;
+      
+      SolrIndexSearcher s = req.getSearcher();
+      IndexSchema schema = req.getSchema();
+            
+      Map<String,Float> queryFields = U.parseFieldBoosts(params.getParams(DMP.QF));
+      Map<String,Float> phraseFields = U.parseFieldBoosts(params.getParams(DMP.PF));
+
+      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);
+            
+      int pslop = params.getInt(DMP.PS, 0);
+      int qslop = params.getInt(DMP.QS, 0);
+
+      /* a generic parser for parsing regular lucene queries */
+      QueryParser p = schema.getSolrQueryParser(null);
+
+      /* a parser for dealing with user input, which will convert
+       * things to DisjunctionMaxQueries
+       */
+      U.DisjunctionMaxQueryParser up =
+        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
+      up.addAlias(IMPOSSIBLE_FIELD_NAME,
+                  tiebreaker, queryFields);
+      up.setPhraseSlop(qslop);
+      
+      /* for parsing sloppy phrases using DisjunctionMaxQueries */
+      U.DisjunctionMaxQueryParser pp =
+        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
+      pp.addAlias(IMPOSSIBLE_FIELD_NAME,
+                  tiebreaker, phraseFields);
+      pp.setPhraseSlop(pslop);
+            
+            
+      /* the main query we will execute.  we disable the coord because
+       * this query is an artificial construct
+       */
+      BooleanQuery query = new BooleanQuery(true);
+
+      /* * * Main User Query * * */
+      Query parsedUserQuery = null;
+      String userQuery = params.get( Q );
+      Query altUserQuery = null;
+      if( userQuery == null || userQuery.trim().length() < 1 ) {
+        // If no query is specified, we may have an alternate
+        String altQ = params.get( DMP.ALTQ );
+        if (altQ != null) {
+          altUserQuery = p.parse(altQ);
+          query.add( altUserQuery , Occur.MUST );
+        } else {
+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "missing query string" );
+        }
+      }
+      else {
+        // There is a valid query string
+        userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();
+            
+        String minShouldMatch = params.get(DMP.MM, "100%");
+        Query dis = up.parse(userQuery);
+        parsedUserQuery = dis;
+  
+        if (dis instanceof BooleanQuery) {
+          BooleanQuery t = new BooleanQuery();
+          U.flattenBooleanQuery(t, (BooleanQuery)dis);
+          U.setMinShouldMatch(t, minShouldMatch);                
+          parsedUserQuery = t;
+        } 
+        query.add(parsedUserQuery, Occur.MUST);
+        
+
+        /* * * Add on Phrases for the Query * * */
+              
+        /* build up phrase boosting queries */
+
+        /* if the userQuery already has some quotes, stip them out.
+         * we've already done the phrases they asked for in the main
+         * part of the query, this is to boost docs that may not have
+         * matched those phrases but do match looser phrases.
+         */
+        String userPhraseQuery = userQuery.replace("\"","");
+        Query phrase = pp.parse("\"" + userPhraseQuery + "\"");
+        if (null != phrase) {
+          query.add(phrase, Occur.SHOULD);
+        }
+      }
+
+            
+      /* * * Boosting Query * * */
+      String[] boostParams = params.getParams(DMP.BQ);
+      List<Query> boostQueries = U.parseQueryStrings(req, boostParams);
+      if (null != boostQueries) {
+        if(1 == boostQueries.size() && 1 == boostParams.length) {
+          /* legacy logic */
+          Query f = boostQueries.get(0);
+          if (1.0f == f.getBoost() && f instanceof BooleanQuery) {
+            /* if the default boost was used, and we've got a BooleanQuery
+             * extract the subqueries out and use them directly
+             */
+            for (Object c : ((BooleanQuery)f).clauses()) {
+              query.add((BooleanClause)c);
+            }
+          } else {
+            query.add(f, BooleanClause.Occur.SHOULD);
+          }
+        } else {
+          for(Query f : boostQueries) {
+            query.add(f, BooleanClause.Occur.SHOULD);
+          }
+        }
+      }
+
+      /* * * Boosting Functions * * */
+
+      String[] boostFuncs = params.getParams(DMP.BF);
+      if (null != boostFuncs && 0 != boostFuncs.length) {
+        for (String boostFunc : boostFuncs) {
+          if(null == boostFunc || "".equals(boostFunc)) continue;
+          List<Query> funcs = U.parseFuncs(schema, boostFunc);
+          for (Query f : funcs) {
+            query.add(f, Occur.SHOULD);          
+          }
+        }
+      }
+            
+      /* * * Restrict Results * * */
+
+      List<Query> restrictions = U.parseFilterQueries(req);
+            
+      /* * * Generate Main Results * * */
+
+      flags |= U.setReturnFields(req,rsp);
+      
+      DocListAndSet results = new DocListAndSet();
+      NamedList facetInfo = null;
+      if (params.getBool(FACET,false)) {
+        results = s.getDocListAndSet(query, restrictions,
+                                     SolrPluginUtils.getSort(req),
+                                     req.getStart(), req.getLimit(),
+                                     flags);
+        facetInfo = getFacetInfo(req, rsp, results.docSet);
+      } else {
+        results.docList = s.getDocList(query, restrictions,
+                                       SolrPluginUtils.getSort(req),
+                                       req.getStart(), req.getLimit(),
+                                       flags);
+      }
+      rsp.add("response",results.docList);
+      // pre-fetch returned documents
+      U.optimizePreFetchDocs(results.docList, query, req, rsp);
+
+      
+      if (null != facetInfo) rsp.add("facet_counts", facetInfo);
+
+
+            
+      /* * * Debugging Info * * */
+
+      try {
+        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);
+        if (null != debug) {
+          debug.add("altquerystring", altUserQuery);
+          if (null != boostQueries) {
+            debug.add("boost_queries", boostParams);
+            debug.add("parsed_boost_queries", 
+                      QueryParsing.toString(boostQueries, req.getSchema()));
+          }
+          debug.add("boostfuncs", params.getParams(DMP.BF));
+          if (null != restrictions) {
+            debug.add("filter_queries", params.getParams(FQ));
+            debug.add("parsed_filter_queries", 
+                      QueryParsing.toString(restrictions, req.getSchema()));
+          }
+          rsp.add("debug", debug);
+        }
+
+      } catch (Exception e) {
+        SolrException.logOnce(SolrCore.log,
+                              "Exception during debug", e);
+        rsp.add("exception_during_debug", SolrException.toStr(e));
+      }
+
+      /* * * Highlighting/Summarizing  * * */
+      if(HighlightingUtils.isHighlightingEnabled(req) && parsedUserQuery != null) {
+        String[] highFields = queryFields.keySet().toArray(new String[0]);
+        NamedList sumData =
+          HighlightingUtils.doHighlighting(
+	       results.docList, 
+	       parsedUserQuery.rewrite(req.getSearcher().getReader()), 
+	       req, 
+	       highFields);
+        if(sumData != null)
+          rsp.add("highlighting", sumData);
+      }
+  }
+
+  /**
+   * Fetches information about Facets for this request.
+   *
+   * Subclasses may with to override this method to provide more 
+   * advanced faceting behavior.
+   * @see SimpleFacets#getFacetCounts
+   */
+  protected NamedList getFacetInfo(SolrQueryRequest req, 
+                                   SolrQueryResponse rsp, 
+                                   DocSet mainSet) {
+
+    SimpleFacets f = new SimpleFacets(req.getSearcher(), 
+                                      mainSet, 
+                                      req.getParams());
+    return f.getFacetCounts();
+  }
+  
+
+	//////////////////////// SolrInfoMBeans methods //////////////////////
+
+	@Override
+	public String getDescription() {
+	    return "DisjunctionMax Request Handler: Does relevancy based queries "
+	       + "across a variety of fields using configured boosts";
+	}
+
+	@Override
+	public String getVersion() {
+	    return "$Revision$";
+	}
+
+	@Override
+	public String getSourceId() {
+	  return "$Id$";
+	}
+
+	@Override
+	public String getSource() {
+	  return "$URL$";
+	}
+  
+  @Override
+  public URL[] getDocs() {
+    try {
+    return new URL[] { new URL("http://wiki.apache.org/solr/DisMaxRequestHandler") };
+    }
+    catch( MalformedURLException ex ) { return null; }
+  }
+}
diff --git a/src/java/org/apache/solr/handler/DumpRequestHandler.java b/src/java/org/apache/solr/handler/DumpRequestHandler.java
index d6d0658..a83fd1f 100644
--- a/src/java/org/apache/solr/handler/DumpRequestHandler.java
+++ b/src/java/org/apache/solr/handler/DumpRequestHandler.java
@@ -21,11 +21,11 @@ import java.io.IOException;
 import java.util.ArrayList;
 
 import org.apache.commons.io.IOUtils;
-import org.apache.solr.util.ContentStream;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 public class DumpRequestHandler extends RequestHandlerBase
 {
diff --git a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
index 88d93cc..bf27463 100644
--- a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
+++ b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
@@ -17,9 +17,9 @@
 
 package org.apache.solr.handler;
 
-import static org.apache.solr.request.SolrParams.DF;
-import static org.apache.solr.request.SolrParams.FACET;
-import static org.apache.solr.request.SolrParams.FQ;
+import static org.apache.solr.common.params.SolrParams.DF;
+import static org.apache.solr.common.params.SolrParams.FACET;
+import static org.apache.solr.common.params.SolrParams.FQ;
 
 import java.io.IOException;
 import java.io.Reader;
@@ -39,10 +39,15 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similar.MoreLikeThis;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.MoreLikeThisParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.common.util.MoreLikeThisParams.TermStyle;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.request.SimpleFacets;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
@@ -51,12 +56,7 @@ import org.apache.solr.search.DocIterator;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.QueryParsing;
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.util.MoreLikeThisParams;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 import org.apache.solr.util.SolrPluginUtils;
-import org.apache.solr.util.MoreLikeThisParams.TermStyle;
 
 /**
  * Solr MoreLikeThis --
diff --git a/src/java/org/apache/solr/handler/RequestHandlerBase.java b/src/java/org/apache/solr/handler/RequestHandlerBase.java
index b4a6450..09241d7 100644
--- a/src/java/org/apache/solr/handler/RequestHandlerBase.java
+++ b/src/java/org/apache/solr/handler/RequestHandlerBase.java
@@ -19,16 +19,16 @@ package org.apache.solr.handler;
 
 import java.net.URL;
 
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.core.SolrInfoMBean;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.SolrPluginUtils;
-import org.apache.solr.util.SimpleOrderedMap;
 
 /**
  *
diff --git a/src/java/org/apache/solr/handler/RequestHandlerUtils.java b/src/java/org/apache/solr/handler/RequestHandlerUtils.java
index 72c655e..5124cc3 100755
--- a/src/java/org/apache/solr/handler/RequestHandlerUtils.java
+++ b/src/java/org/apache/solr/handler/RequestHandlerUtils.java
@@ -20,12 +20,12 @@ package org.apache.solr.handler;
 import java.io.IOException;
 import java.util.HashMap;
 
-import org.apache.solr.request.MapSolrParams;
-import org.apache.solr.request.SolrParams;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.update.CommitUpdateCommand;
-import org.apache.solr.util.UpdateParams;
 
 /**
  * Common helper functions for RequestHandlers
diff --git a/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java b/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
index ec7ac6d..5b9cfc9 100644
--- a/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
+++ b/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
@@ -25,12 +25,12 @@ import org.apache.lucene.search.spell.SpellChecker;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.store.RAMDirectory;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 
 import java.io.File;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/handler/StandardRequestHandler.java b/src/java/org/apache/solr/handler/StandardRequestHandler.java
new file mode 100644
index 0000000..24ff0dc
--- /dev/null
+++ b/src/java/org/apache/solr/handler/StandardRequestHandler.java
@@ -0,0 +1,220 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.handler;
+
+import org.apache.lucene.search.*;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.solr.util.StrUtils;
+import org.apache.solr.util.HighlightingUtils;
+import org.apache.solr.util.SolrPluginUtils;
+import org.apache.solr.request.SimpleFacets;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.search.*;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.MoreLikeThisParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.SolrCore;
+
+import static org.apache.solr.common.params.SolrParams.*;
+
+/**
+ * @author yonik
+ * @version $Id$
+ *
+ * All of the following options may be configured for this handler
+ * in the solrconfig as defaults, and may be overriden as request parameters.
+ * (TODO: complete documentation of request parameters here, rather than only
+ * on the wiki).
+ * </p>
+ *
+ * <ul>
+ * <li> highlight - Set to any value not .equal() to "false" to enable highlight
+ * generation</li>
+ * <li> highlightFields - Set to a comma- or space-delimited list of fields to
+ * highlight.  If unspecified, uses the default query field</li>
+ * <li> maxSnippets - maximum number of snippets to generate per field-highlight.
+ * </li>
+ * </ul>
+ *
+ */
+public class StandardRequestHandler extends RequestHandlerBase {
+
+  /** shorten the class references for utilities */
+  private static class U extends SolrPluginUtils {
+    /* :NOOP */
+  }
+
+
+  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception
+  {
+    
+      SolrParams p = req.getParams();
+      String qstr = p.required().get(Q);
+
+      String defaultField = p.get(DF);
+
+      // find fieldnames to return (fieldlist)
+      String fl = p.get(SolrParams.FL);
+      int flags = 0; 
+      if (fl != null) {
+        flags |= U.setReturnFields(fl, rsp);
+      }
+      
+      String sortStr = p.get(SORT);
+      if( sortStr == null ) {  
+        // TODO? should we disable the ';' syntax with config?
+        // legacy mode, where sreq is query;sort
+        List<String> commands = StrUtils.splitSmart(qstr,';');
+        if( commands.size() == 2 ) {
+          // TODO? add a deprication warning to the response header
+          qstr = commands.get( 0 );
+          sortStr = commands.get( 1 );
+        }
+        else if( commands.size() == 1 ) {
+          // This is need to support the case where someone sends: "q=query;"
+          qstr = commands.get( 0 );
+        }
+        else if( commands.size() > 2 ) {
+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "If you want to use multiple ';' in the query, use the 'sort' param." );
+        }
+      }
+
+      Sort sort = null;
+      if( sortStr != null ) {
+        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(sortStr, req.getSchema());
+        if (sortSpec != null) {
+          sort = sortSpec.getSort();
+        }
+      }
+
+      // parse the query from the 'q' parameter (sort has been striped)
+      Query query = QueryParsing.parseQuery(qstr, defaultField, p, req.getSchema());
+      
+      DocListAndSet results = new DocListAndSet();
+      NamedList facetInfo = null;
+      List<Query> filters = U.parseFilterQueries(req);
+      SolrIndexSearcher s = req.getSearcher();
+
+      if (p.getBool(FACET,false)) {
+        results = s.getDocListAndSet(query, filters, sort,
+                                     p.getInt(START,0), p.getInt(ROWS,10),
+                                     flags);
+        facetInfo = getFacetInfo(req, rsp, results.docSet);
+      } else {
+        results.docList = s.getDocList(query, filters, sort,
+                                       p.getInt(START,0), p.getInt(ROWS,10),
+                                       flags);
+      }
+
+      // pre-fetch returned documents
+      U.optimizePreFetchDocs(results.docList, query, req, rsp);
+      
+      rsp.add("response",results.docList);
+
+      if (null != facetInfo) rsp.add("facet_counts", facetInfo);
+
+      // Include "More Like This" results for *each* result
+      if( p.getBool( MoreLikeThisParams.MLT, false ) ) {
+        MoreLikeThisHandler.MoreLikeThisHelper mlt 
+          = new MoreLikeThisHandler.MoreLikeThisHelper( p, s );
+        int mltcount = p.getInt( MoreLikeThisParams.DOC_COUNT, 5 );
+        rsp.add( "moreLikeThis", mlt.getMoreLikeThese(results.docList, mltcount, flags));
+      }
+      
+      try {
+        NamedList dbg = U.doStandardDebug(req, qstr, query, results.docList);
+        if (null != dbg) {
+          if (null != filters) {
+            dbg.add("filter_queries",req.getParams().getParams(FQ));
+            List<String> fqs = new ArrayList<String>(filters.size());
+            for (Query fq : filters) {
+              fqs.add(QueryParsing.toString(fq, req.getSchema()));
+            }
+            dbg.add("parsed_filter_queries",fqs);
+          }
+          rsp.add("debug", dbg);
+        }
+      } catch (Exception e) {
+        SolrException.logOnce(SolrCore.log, "Exception during debug", e);
+        rsp.add("exception_during_debug", SolrException.toStr(e));
+      }
+      
+      NamedList sumData = HighlightingUtils.doHighlighting(
+        results.docList, query.rewrite(req.getSearcher().getReader()), req, new String[]{defaultField});
+      if(sumData != null)
+        rsp.add("highlighting", sumData);
+  }
+
+  /**
+   * Fetches information about Facets for this request.
+   *
+   * Subclasses may with to override this method to provide more 
+   * advanced faceting behavior.
+   * @see SimpleFacets#getFacetCounts
+   */
+  protected NamedList getFacetInfo(SolrQueryRequest req, 
+                                   SolrQueryResponse rsp, 
+                                   DocSet mainSet) {
+
+    SimpleFacets f = new SimpleFacets(req.getSearcher(), 
+                                      mainSet, 
+                                      req.getParams());
+    return f.getFacetCounts();
+  }
+
+
+
+  //////////////////////// SolrInfoMBeans methods //////////////////////
+
+  public String getVersion() {
+    return "$Revision$";
+  }
+
+  public String getDescription() {
+    return "The standard Solr request handler";
+  }
+
+  public String getSourceId() {
+    return "$Id$";
+  }
+
+  public String getSource() {
+    return "$URL$";
+  }
+
+  public URL[] getDocs() {
+    try {
+      return new URL[] { new URL("http://wiki.apache.org/solr/StandardRequestHandler") };
+    }
+    catch( MalformedURLException ex ) { return null; }
+  }
+}
+
+
+
+
+
+
+
diff --git a/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java b/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
index f816199..8cd804e 100644
--- a/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
+++ b/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
@@ -25,9 +25,12 @@ import java.util.List;
 import java.util.logging.Logger;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.util.ContentStream;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
@@ -37,10 +40,7 @@ import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
 import org.apache.solr.update.DocumentBuilder;
 import org.apache.solr.update.UpdateHandler;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.StrUtils;
-import org.apache.solr.util.XML;
-import org.apache.solr.util.SimpleOrderedMap;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlPullParserFactory;
diff --git a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
index 1c0d5b1..d861ced 100644
--- a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
@@ -42,10 +42,12 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.PriorityQueue;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.schema.FieldType;
@@ -54,8 +56,6 @@ import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.SolrQueryParser;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 /**
  * This handler exposes the internal lucene index.  It is inspired by and 
diff --git a/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java b/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
index 800b081..f94528c 100644
--- a/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
+++ b/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
@@ -21,14 +21,14 @@ import java.net.URL;
 import java.util.ArrayList;
 import java.util.Map;
 
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.core.SolrInfoRegistry;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.SimpleOrderedMap;
 
 /**
  * similar to "admin/registry.jsp" 
diff --git a/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java b/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
index ac8cf2f..86ad85f 100644
--- a/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
@@ -20,11 +20,11 @@ package org.apache.solr.handler.admin;
 import java.io.IOException;
 import java.util.Properties;
 
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 /**
  * @author ryan
diff --git a/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java b/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
index 211eb6a..09381d6 100644
--- a/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
+++ b/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
@@ -31,6 +31,9 @@ import java.util.Date;
 import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.lucene.LucenePackage;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.core.Config;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.RequestHandlerBase;
@@ -38,9 +41,6 @@ import org.apache.solr.handler.RequestHandlerUtils;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
-import org.apache.solr.util.XML;
 
 
 /**
diff --git a/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java b/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
index c13ea4e..929f7fe 100644
--- a/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
+++ b/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
@@ -22,12 +22,12 @@ import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
 
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 /**
  * Copied from "admin/threaddump.jsp"
diff --git a/src/java/org/apache/solr/request/AppendedSolrParams.java b/src/java/org/apache/solr/request/AppendedSolrParams.java
deleted file mode 100644
index 612af1c..0000000
--- a/src/java/org/apache/solr/request/AppendedSolrParams.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-/**
- * SolrParams wrapper which acts similar to DefaultSolrParams except that
- * it "appends" the values of multi-value params from both sub instances, so
- * that all of the values are returned. 
- */
-public class AppendedSolrParams extends DefaultSolrParams {
-  public AppendedSolrParams(SolrParams main, SolrParams extra) {
-    super(main, extra);
-  }
-
-  public String[] getParams(String param) {
-    String[] main = params.getParams(param);
-    String[] extra = defaults.getParams(param);
-    if (null == extra || 0 == extra.length) {
-      return main;
-    }
-    if (null == main || 0 == main.length) {
-      return extra;
-    }
-    String[] result = new String[main.length + extra.length];
-    System.arraycopy(main,0,result,0,main.length);
-    System.arraycopy(extra,0,result,main.length,extra.length);
-    return result;
-  }
-
-  public String toString() {
-    return "{main("+params+"),extra("+defaults+")}";
-  }
-}
diff --git a/src/java/org/apache/solr/request/DefaultSolrParams.java b/src/java/org/apache/solr/request/DefaultSolrParams.java
deleted file mode 100644
index 8ad4480..0000000
--- a/src/java/org/apache/solr/request/DefaultSolrParams.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.util.Iterator;
-
-import org.apache.solr.util.IteratorChain;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class DefaultSolrParams extends SolrParams {
-  protected final SolrParams params;
-  protected final SolrParams defaults;
-
-  public DefaultSolrParams(SolrParams params, SolrParams defaults) {
-    this.params = params;
-    this.defaults = defaults;
-  }
-
-  public String get(String param) {
-    String val = params.get(param);
-    return val!=null ? val : defaults.get(param);
-  }
-
-  public String[] getParams(String param) {
-    String[] vals = params.getParams(param);
-    return vals!=null ? vals : defaults.getParams(param);
-  }
-  
-  public Iterator<String> getParameterNamesIterator() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(defaults.getParameterNamesIterator());
-    c.addIterator(params.getParameterNamesIterator());
-    return c;
-  }
-
-  public String toString() {
-    return "{params("+params+"),defaults("+defaults+")}";
-  }
-}
diff --git a/src/java/org/apache/solr/request/DisMaxRequestHandler.java b/src/java/org/apache/solr/request/DisMaxRequestHandler.java
deleted file mode 100644
index 4038a26..0000000
--- a/src/java/org/apache/solr/request/DisMaxRequestHandler.java
+++ /dev/null
@@ -1,423 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import static org.apache.solr.request.SolrParams.FACET;
-import static org.apache.solr.request.SolrParams.FQ;
-import static org.apache.solr.request.SolrParams.Q;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.handler.RequestHandlerBase;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.search.DocListAndSet;
-import org.apache.solr.search.DocSet;
-import org.apache.solr.search.QueryParsing;
-import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.search.SolrQueryParser;
-import org.apache.solr.util.DisMaxParams;
-import org.apache.solr.util.HighlightingUtils;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SolrPluginUtils;
-    
-/**
- * <p>
- * A Generic query plugin designed to be given a simple query expression
- * from a user, which it will then query against a variety of
- * pre-configured fields, in a variety of ways, using BooleanQueries,
- * DisjunctionMaxQueries, and PhraseQueries.
- * </p>
- *
- * <p>
- * All of the following options may be configured for this plugin
- * in the solrconfig as defaults, and may be overriden as request parameters
- * </p>
- *
- * <ul>
- * <li>q.alt - An alternate query to be used in cases where the main
- *             query (q) is not specified (or blank).  This query should
- *             be expressed in the Standard SolrQueryParser syntax (you
- *             can use <code>q.alt=*:*</code> to denote that all documents
- *             should be returned when no query is specified)
- * </li>
- * <li>tie - (Tie breaker) float value to use as tiebreaker in
- *           DisjunctionMaxQueries (should be something much less than 1)
- * </li>
- * <li> qf - (Query Fields) fields and boosts to use when building
- *           DisjunctionMaxQueries from the users query.  Format is:
- *           "<code>fieldA^1.0 fieldB^2.2</code>".
- *           This param can be specified multiple times, and the fields
- *           are additive.
- * </li>
- * <li> mm - (Minimum Match) this supports a wide variety of
- *           complex expressions.
- *           read {@link SolrPluginUtils#setMinShouldMatch SolrPluginUtils.setMinShouldMatch} and <a href="http://lucene.apache.org/solr/api/org/apache/solr/util/doc-files/min-should-match.html">mm expression format</a> for details.
- * </li>
- * <li> pf - (Phrase Fields) fields/boosts to make phrase queries out
- *           of, to boost the users query for exact matches on the specified fields.
- *           Format is: "<code>fieldA^1.0 fieldB^2.2</code>".
- *           This param can be specified multiple times, and the fields
- *           are additive.
- * </li>
- * <li> ps - (Phrase Slop) amount of slop on phrase queries built for pf
- *           fields.
- * </li>
- * <li> qs - (Query Slop) amount of slop on phrase queries explicitly
- *           specified in the "q" for qf fields.
- * </li>
- * <li> bq - (Boost Query) a raw lucene query that will be included in the 
- *           users query to influence the score.  If this is a BooleanQuery
- *           with a default boost (1.0f), then the individual clauses will be
- *           added directly to the main query.  Otherwise, the query will be
- *           included as is.
- *           This param can be specified multiple times, and the boosts are 
- *           are additive.  NOTE: the behaviour listed above is only in effect
- *           if a single <code>bq</code> paramter is specified.  Hence you can
- *           disable it by specifying an additional, blank, <code>bq</code> 
- *           parameter.
- * </li>
- * <li> bf - (Boost Functions) functions (with optional boosts) that will be
- *           included in the users query to influence the score.
- *           Format is: "<code>funcA(arg1,arg2)^1.2
- *           funcB(arg3,arg4)^2.2</code>".  NOTE: Whitespace is not allowed
- *           in the function arguments.
- *           This param can be specified multiple times, and the functions
- *           are additive.
- * </li>
- * <li> fq - (Filter Query) a raw lucene query that can be used
- *           to restrict the super set of products we are interested in - more
- *           efficient then using bq, but doesn't influence score.
- *           This param can be specified multiple times, and the filters
- *           are additive.
- * </li>
- * </ul>
- *
- * <p>
- * The following options are only available as request params...
- * </p>
- *
- * <ul>
- * <li>   q - (Query) the raw unparsed, unescaped, query from the user.
- * </li>
- * <li>sort - (Order By) list of fields and direction to sort on.
- * </li>
- * </ul>
- *
- * <pre>
- * :TODO: document facet param support
- *
- * </pre>
- */
-public class DisMaxRequestHandler extends RequestHandlerBase  {
-
-  /**
-   * A field we can't ever find in any schema, so we can safely tell
-   * DisjunctionMaxQueryParser to use it as our defaultField, and
-   * map aliases from it to any field in our schema.
-   */
-  private static String IMPOSSIBLE_FIELD_NAME = "\uFFFC\uFFFC\uFFFC";
-    
-    
-  /** shorten the class references for utilities */
-  private static class U extends SolrPluginUtils {
-    /* :NOOP */
-  }
-  /** shorten the class references for utilities */
-  private static class DMP extends DisMaxParams {
-    /* :NOOP */
-  }
-
-  public DisMaxRequestHandler() {
-    super();
-  }
-  
-  /** Sets the default variables for any useful info it finds in the config.
-   * If a config option is not in the format expected, logs a warning
-   * and ignores it.
-   */
-  public void init(NamedList args) {
-	// Handle an old format
-    if (-1 == args.indexOf("defaults",0)) {
-      // no explict defaults list, use all args implicitly
-      // indexOf so "<null name="defaults"/> is valid indicator of no defaults
-      defaults = SolrParams.toSolrParams(args);
-    } else {
-      // otherwise use the new one.
-      super.init( args );
-    }
-  }
-
-  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception
-  {
-      SolrParams params = req.getParams();
-      
-      int flags = 0;
-      
-      SolrIndexSearcher s = req.getSearcher();
-      IndexSchema schema = req.getSchema();
-            
-      Map<String,Float> queryFields = U.parseFieldBoosts(params.getParams(DMP.QF));
-      Map<String,Float> phraseFields = U.parseFieldBoosts(params.getParams(DMP.PF));
-
-      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);
-            
-      int pslop = params.getInt(DMP.PS, 0);
-      int qslop = params.getInt(DMP.QS, 0);
-
-      /* a generic parser for parsing regular lucene queries */
-      QueryParser p = schema.getSolrQueryParser(null);
-
-      /* a parser for dealing with user input, which will convert
-       * things to DisjunctionMaxQueries
-       */
-      U.DisjunctionMaxQueryParser up =
-        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
-      up.addAlias(IMPOSSIBLE_FIELD_NAME,
-                  tiebreaker, queryFields);
-      up.setPhraseSlop(qslop);
-      
-      /* for parsing sloppy phrases using DisjunctionMaxQueries */
-      U.DisjunctionMaxQueryParser pp =
-        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
-      pp.addAlias(IMPOSSIBLE_FIELD_NAME,
-                  tiebreaker, phraseFields);
-      pp.setPhraseSlop(pslop);
-            
-            
-      /* the main query we will execute.  we disable the coord because
-       * this query is an artificial construct
-       */
-      BooleanQuery query = new BooleanQuery(true);
-
-      /* * * Main User Query * * */
-      Query parsedUserQuery = null;
-      String userQuery = params.get( Q );
-      Query altUserQuery = null;
-      if( userQuery == null || userQuery.trim().length() < 1 ) {
-        // If no query is specified, we may have an alternate
-        String altQ = params.get( DMP.ALTQ );
-        if (altQ != null) {
-          altUserQuery = p.parse(altQ);
-          query.add( altUserQuery , Occur.MUST );
-        } else {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "missing query string" );
-        }
-      }
-      else {
-        // There is a valid query string
-        userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();
-            
-        String minShouldMatch = params.get(DMP.MM, "100%");
-        Query dis = up.parse(userQuery);
-        parsedUserQuery = dis;
-  
-        if (dis instanceof BooleanQuery) {
-          BooleanQuery t = new BooleanQuery();
-          U.flattenBooleanQuery(t, (BooleanQuery)dis);
-          U.setMinShouldMatch(t, minShouldMatch);                
-          parsedUserQuery = t;
-        } 
-        query.add(parsedUserQuery, Occur.MUST);
-        
-
-        /* * * Add on Phrases for the Query * * */
-              
-        /* build up phrase boosting queries */
-
-        /* if the userQuery already has some quotes, stip them out.
-         * we've already done the phrases they asked for in the main
-         * part of the query, this is to boost docs that may not have
-         * matched those phrases but do match looser phrases.
-         */
-        String userPhraseQuery = userQuery.replace("\"","");
-        Query phrase = pp.parse("\"" + userPhraseQuery + "\"");
-        if (null != phrase) {
-          query.add(phrase, Occur.SHOULD);
-        }
-      }
-
-            
-      /* * * Boosting Query * * */
-      String[] boostParams = params.getParams(DMP.BQ);
-      List<Query> boostQueries = U.parseQueryStrings(req, boostParams);
-      if (null != boostQueries) {
-        if(1 == boostQueries.size() && 1 == boostParams.length) {
-          /* legacy logic */
-          Query f = boostQueries.get(0);
-          if (1.0f == f.getBoost() && f instanceof BooleanQuery) {
-            /* if the default boost was used, and we've got a BooleanQuery
-             * extract the subqueries out and use them directly
-             */
-            for (Object c : ((BooleanQuery)f).clauses()) {
-              query.add((BooleanClause)c);
-            }
-          } else {
-            query.add(f, BooleanClause.Occur.SHOULD);
-          }
-        } else {
-          for(Query f : boostQueries) {
-            query.add(f, BooleanClause.Occur.SHOULD);
-          }
-        }
-      }
-
-      /* * * Boosting Functions * * */
-
-      String[] boostFuncs = params.getParams(DMP.BF);
-      if (null != boostFuncs && 0 != boostFuncs.length) {
-        for (String boostFunc : boostFuncs) {
-          if(null == boostFunc || "".equals(boostFunc)) continue;
-          List<Query> funcs = U.parseFuncs(schema, boostFunc);
-          for (Query f : funcs) {
-            query.add(f, Occur.SHOULD);          
-          }
-        }
-      }
-            
-      /* * * Restrict Results * * */
-
-      List<Query> restrictions = U.parseFilterQueries(req);
-            
-      /* * * Generate Main Results * * */
-
-      flags |= U.setReturnFields(req,rsp);
-      
-      DocListAndSet results = new DocListAndSet();
-      NamedList facetInfo = null;
-      if (params.getBool(FACET,false)) {
-        results = s.getDocListAndSet(query, restrictions,
-                                     SolrPluginUtils.getSort(req),
-                                     req.getStart(), req.getLimit(),
-                                     flags);
-        facetInfo = getFacetInfo(req, rsp, results.docSet);
-      } else {
-        results.docList = s.getDocList(query, restrictions,
-                                       SolrPluginUtils.getSort(req),
-                                       req.getStart(), req.getLimit(),
-                                       flags);
-      }
-      rsp.add("response",results.docList);
-      // pre-fetch returned documents
-      U.optimizePreFetchDocs(results.docList, query, req, rsp);
-
-      
-      if (null != facetInfo) rsp.add("facet_counts", facetInfo);
-
-
-            
-      /* * * Debugging Info * * */
-
-      try {
-        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);
-        if (null != debug) {
-          debug.add("altquerystring", altUserQuery);
-          if (null != boostQueries) {
-            debug.add("boost_queries", boostParams);
-            debug.add("parsed_boost_queries", 
-                      QueryParsing.toString(boostQueries, req.getSchema()));
-          }
-          debug.add("boostfuncs", params.getParams(DMP.BF));
-          if (null != restrictions) {
-            debug.add("filter_queries", params.getParams(FQ));
-            debug.add("parsed_filter_queries", 
-                      QueryParsing.toString(restrictions, req.getSchema()));
-          }
-          rsp.add("debug", debug);
-        }
-
-      } catch (Exception e) {
-        SolrException.logOnce(SolrCore.log,
-                              "Exception during debug", e);
-        rsp.add("exception_during_debug", SolrException.toStr(e));
-      }
-
-      /* * * Highlighting/Summarizing  * * */
-      if(HighlightingUtils.isHighlightingEnabled(req) && parsedUserQuery != null) {
-        String[] highFields = queryFields.keySet().toArray(new String[0]);
-        NamedList sumData =
-          HighlightingUtils.doHighlighting(
-	       results.docList, 
-	       parsedUserQuery.rewrite(req.getSearcher().getReader()), 
-	       req, 
-	       highFields);
-        if(sumData != null)
-          rsp.add("highlighting", sumData);
-      }
-  }
-
-  /**
-   * Fetches information about Facets for this request.
-   *
-   * Subclasses may with to override this method to provide more 
-   * advanced faceting behavior.
-   * @see SimpleFacets#getFacetCounts
-   */
-  protected NamedList getFacetInfo(SolrQueryRequest req, 
-                                   SolrQueryResponse rsp, 
-                                   DocSet mainSet) {
-
-    SimpleFacets f = new SimpleFacets(req.getSearcher(), 
-                                      mainSet, 
-                                      req.getParams());
-    return f.getFacetCounts();
-  }
-  
-
-	//////////////////////// SolrInfoMBeans methods //////////////////////
-
-	@Override
-	public String getDescription() {
-	    return "DisjunctionMax Request Handler: Does relevancy based queries "
-	       + "across a variety of fields using configured boosts";
-	}
-
-	@Override
-	public String getVersion() {
-	    return "$Revision$";
-	}
-
-	@Override
-	public String getSourceId() {
-	  return "$Id$";
-	}
-
-	@Override
-	public String getSource() {
-	  return "$URL$";
-	}
-  
-  @Override
-  public URL[] getDocs() {
-    try {
-    return new URL[] { new URL("http://wiki.apache.org/solr/DisMaxRequestHandler") };
-    }
-    catch( MalformedURLException ex ) { return null; }
-  }
-}
diff --git a/src/java/org/apache/solr/request/JSONResponseWriter.java b/src/java/org/apache/solr/request/JSONResponseWriter.java
index 9196235..ad52111 100644
--- a/src/java/org/apache/solr/request/JSONResponseWriter.java
+++ b/src/java/org/apache/solr/request/JSONResponseWriter.java
@@ -19,13 +19,13 @@ package org.apache.solr.request;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.schema.TextField;
 import org.apache.solr.search.DocIterator;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 import java.io.IOException;
 import java.io.Writer;
diff --git a/src/java/org/apache/solr/request/LocalSolrQueryRequest.java b/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
index 0fed104..89d1619 100644
--- a/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
+++ b/src/java/org/apache/solr/request/LocalSolrQueryRequest.java
@@ -17,7 +17,9 @@
 
 package org.apache.solr.request;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.params.MultiMapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/request/MapSolrParams.java b/src/java/org/apache/solr/request/MapSolrParams.java
deleted file mode 100644
index 683243a..0000000
--- a/src/java/org/apache/solr/request/MapSolrParams.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.solr.util.StrUtils;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class MapSolrParams extends SolrParams {
-  protected final Map<String,String> map;
-
-  public MapSolrParams(Map<String,String> map) {
-    this.map = map;
-  }
-
-  public String get(String name) {
-    return map.get(name);
-  }
-
-  public String[] getParams(String name) {
-    String val = map.get(name);
-    return val==null ? null : new String[]{val};
-  }
-  
-  public Iterator<String> getParameterNamesIterator() {
-    return map.keySet().iterator();
-  }
-
-  public Map<String,String> getMap() { return map; }
-
-  public String toString() {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      boolean first=true;
-
-      for (Map.Entry<String,String> entry : map.entrySet()) {
-        String key = entry.getKey();
-        String val = entry.getValue();
-
-        if (!first) sb.append('&');
-        first=false;
-        sb.append(key);
-        sb.append('=');
-        StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-
-    return sb.toString();
-  }
-}
diff --git a/src/java/org/apache/solr/request/MultiMapSolrParams.java b/src/java/org/apache/solr/request/MultiMapSolrParams.java
deleted file mode 100644
index 3678a5c..0000000
--- a/src/java/org/apache/solr/request/MultiMapSolrParams.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.solr.util.StrUtils;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class MultiMapSolrParams extends SolrParams {
-  protected final Map<String,String[]> map;
-
-  public static void addParam(String name, String val, Map<String,String[]> map) {
-      String[] arr = map.get(name);
-      if (arr ==null) {
-        arr =new String[]{val};
-      } else {
-        String[] newarr = new String[arr.length+1];
-        System.arraycopy(arr,0,newarr,0,arr.length);
-        newarr[arr.length]=val;
-        arr =newarr;
-      }
-      map.put(name, arr);
-  }
-
-  public MultiMapSolrParams(Map<String,String[]> map) {
-    this.map = map;
-  }
-
-  public String get(String name) {
-    String[] arr = map.get(name);
-    return arr==null ? null : arr[0];
-  }
-
-  public String[] getParams(String name) {
-    return map.get(name);
-  }
-  
-  public Iterator<String> getParameterNamesIterator() {
-    return map.keySet().iterator();
-  }
-
-  public Map<String,String[]> getMap() { return map; }
-
-  public String toString() {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      boolean first=true;
-
-      for (Map.Entry<String,String[]> entry : map.entrySet()) {
-        String key = entry.getKey();
-        String[] valarr = entry.getValue();
-
-        for (String val : valarr) {
-          if (!first) sb.append('&');
-          first=false;
-          sb.append(key);
-          sb.append('=');
-          StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
-        }
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-
-    return sb.toString();
-  }
-
-
-}
diff --git a/src/java/org/apache/solr/request/PythonResponseWriter.java b/src/java/org/apache/solr/request/PythonResponseWriter.java
index 50eea7a..b512f03 100644
--- a/src/java/org/apache/solr/request/PythonResponseWriter.java
+++ b/src/java/org/apache/solr/request/PythonResponseWriter.java
@@ -20,7 +20,7 @@ package org.apache.solr.request;
 import java.io.Writer;
 import java.io.IOException;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 
 public class PythonResponseWriter implements QueryResponseWriter {
   static String CONTENT_TYPE_PYTHON_ASCII="text/x-python;charset=US-ASCII";
diff --git a/src/java/org/apache/solr/request/QueryResponseWriter.java b/src/java/org/apache/solr/request/QueryResponseWriter.java
index c876786..ccd1039 100644
--- a/src/java/org/apache/solr/request/QueryResponseWriter.java
+++ b/src/java/org/apache/solr/request/QueryResponseWriter.java
@@ -20,7 +20,7 @@ package org.apache.solr.request;
 import java.io.Writer;
 import java.io.IOException;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 
 /**
  * Implementations of <code>QueryResponseWriter</code> are used to format responses to query requests.
diff --git a/src/java/org/apache/solr/request/RequiredSolrParams.java b/src/java/org/apache/solr/request/RequiredSolrParams.java
deleted file mode 100755
index 82d6059..0000000
--- a/src/java/org/apache/solr/request/RequiredSolrParams.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.solr.core.SolrException;
-
-import java.util.Iterator;
-
-/**
- * This is a simple wrapper to SolrParams that will throw a 400
- * exception if you ask for a parameter that does not exist.  Fields
- * specified with
- * 
- * In short, any value you for from a <code>RequiredSolrParams</code> 
- * will return a valid non-null value or throw a 400 exception.  
- * (If you pass in <code>null</code> as the default value, you can 
- * get a null return value)
- * 
- * @author jjl
- * @version $Id$
- * @since solr 1.2
- */
-public class RequiredSolrParams extends SolrParams {
-  protected final SolrParams params;
-  
-  public RequiredSolrParams(SolrParams params) {
-    this.params = params;
-  }
-
-  /** get the param from params, fail if not found **/
-  @Override
-  public String get(String param) {
-    String val = params.get(param);
-    if( val == null )  {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
-    }
-    return val;
-  }
-
-  @Override
-  public String[] getParams(String param) {
-    String[] vals = params.getParams(param);
-    if( vals == null || vals.length == 0 ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
-    }
-    return vals;
-  }
-  
-  /** returns an Iterator over the parameter names */
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    return params.getParameterNamesIterator();
-  }
-
-  @Override
-  public String toString() {
-    return "{required("+params+")}";  
-  }    
-
-  //----------------------------------------------------------
-  // Functions with a default value - pass directly to the
-  // wrapped SolrParams (they won't return null - unless its the default)
-  //----------------------------------------------------------
-
-  @Override
-  public String get(String param, String def) {
-    return params.get(param, def);
-  }
-
-  @Override
-  public int getInt(String param, int def) {
-    return params.getInt(param, def);
-  }
-
-  @Override
-  public float getFloat(String param, float def) {
-    return params.getFloat(param, def);
-  }
-  
-  @Override
-  public boolean getBool(String param, boolean def) {
-    return params.getBool(param, def);
-  }
-
-  @Override
-  public int getFieldInt(String field, String param, int def) {
-    return params.getFieldInt(field, param, def);
-  }
-  
-  @Override
-  public boolean getFieldBool(String field, String param, boolean def) {
-    return params.getFieldBool(field, param, def);
-  }
-
-  @Override
-  public float getFieldFloat(String field, String param, float def) {
-    return params.getFieldFloat(field, param, def);
-  }
-
-  @Override
-  public String getFieldParam(String field, String param, String def) {
-    return params.getFieldParam(field, param, def);
-  }
-}
diff --git a/src/java/org/apache/solr/request/RubyResponseWriter.java b/src/java/org/apache/solr/request/RubyResponseWriter.java
index ba44c7a..00f1432 100644
--- a/src/java/org/apache/solr/request/RubyResponseWriter.java
+++ b/src/java/org/apache/solr/request/RubyResponseWriter.java
@@ -19,7 +19,7 @@ package org.apache.solr.request;
 import java.io.Writer;
 import java.io.IOException;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 
 public class RubyResponseWriter implements QueryResponseWriter {
   static String CONTENT_TYPE_RUBY_UTF8="text/x-ruby;charset=UTF-8";
diff --git a/src/java/org/apache/solr/request/ServletSolrParams.java b/src/java/org/apache/solr/request/ServletSolrParams.java
index b954da0..1d86c11 100644
--- a/src/java/org/apache/solr/request/ServletSolrParams.java
+++ b/src/java/org/apache/solr/request/ServletSolrParams.java
@@ -19,6 +19,8 @@ package org.apache.solr.request;
 
 import javax.servlet.ServletRequest;
 
+import org.apache.solr.common.params.MultiMapSolrParams;
+
 /**
  * @author yonik
  * @version $Id$
diff --git a/src/java/org/apache/solr/request/SimpleFacets.java b/src/java/org/apache/solr/request/SimpleFacets.java
index 0ca28ec..c1b1838 100644
--- a/src/java/org/apache/solr/request/SimpleFacets.java
+++ b/src/java/org/apache/solr/request/SimpleFacets.java
@@ -23,18 +23,18 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.*;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.core.SolrConfig;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.schema.BoolField;
 import org.apache.solr.search.*;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.BoundedTreeSet;
-import org.apache.solr.util.SimpleOrderedMap;
 
 import java.io.IOException;
 import java.util.Arrays;
diff --git a/src/java/org/apache/solr/request/SolrParams.java b/src/java/org/apache/solr/request/SolrParams.java
deleted file mode 100644
index a8fe6de..0000000
--- a/src/java/org/apache/solr/request/SolrParams.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.solr.core.SolrException;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
-
-/**  SolrParams hold request parameters.
- *
- * @author yonik
- * @version $Id$
- */
-public abstract class SolrParams {
-  /** the query type - which query handler should handle the request */
-  public static final String QT ="qt";
-  /** the response writer type - the format of the response */
-  public static final String WT ="wt";
-  /** query string */
-  public static final String Q ="q";
-  /** sort order */
-  public static final String SORT ="sort";
-  /** Lucene query string(s) for filtering the results without affecting scoring */
-  public static final String FQ ="fq";
-  /** zero based offset of matching documents to retrieve */
-  public static final String START ="start";
-  /** number of documents to return starting at "start" */
-  public static final String ROWS ="rows";
-  /** stylesheet to apply to XML results */
-  public static final String XSL ="xsl";
-  /** stylesheet to apply to XML results */
-  public static final String VERSION ="version";
-  /** query and init param for field list */
-  public static final String FL = "fl";
-  /** default query field */
-  public static final String DF = "df";
-  /** whether to include debug data */
-  public static final String DEBUG_QUERY = "debugQuery";
-  /** another query to explain against */
-  public static final String EXPLAIN_OTHER = "explainOther";
-
-  /**
-   * Should facet counts be calculated?
-   */
-  public static final String FACET = "facet";
-  
-  /**
-   * Any lucene formated queries the user would like to use for
-   * Facet Contraint Counts (multi-value)
-   */
-  public static final String FACET_QUERY = "facet.query";
-  /**
-   * Any field whose terms the user wants to enumerate over for
-   * Facet Contraint Counts (multi-value)
-   */
-  public static final String FACET_FIELD = "facet.field";
-
-  /**
-   * The offset into the list of facets.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_OFFSET = "facet.offset";
-
-  /**
-   * Numeric option indicating the maximum number of facet field counts
-   * be included in the response for each field - in descending order of count.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_LIMIT = "facet.limit";
-
-  /**
-   * Numeric option indicating the minimum number of hits before a facet should
-   * be included in the response.  Can be overriden on a per field basis.
-   */
-  public static final String FACET_MINCOUNT = "facet.mincount";
-
-  /**
-   * Boolean option indicating whether facet field counts of "0" should 
-   * be included in the response.  Can be overriden on a per field basis.
-   */
-  public static final String FACET_ZEROS = "facet.zeros";
-
-  /**
-   * Boolean option indicating whether the response should include a 
-   * facet field count for all records which have no value for the 
-   * facet field. Can be overriden on a per field basis.
-   */
-  public static final String FACET_MISSING = "facet.missing";
-
-  /**
-   * Boolean option: true causes facets to be sorted
-   * by the count, false results in natural index order.
-   */
-  public static final String FACET_SORT = "facet.sort";
-
-  /**
-   * Only return constraints of a facet field with the given prefix.
-   */
-  public static final String FACET_PREFIX = "facet.prefix";
-
- /**
-   * When faceting by enumerating the terms in a field,
-   * only use the filterCache for terms with a df >= to this parameter.
-   */
-  public static final String FACET_ENUM_CACHE_MINDF = "facet.enum.cache.minDf";
-
-
-  /** If the content stream should come from a URL (using URLConnection) */
-  public static final String STREAM_URL = "stream.url";
-
-  /** If the content stream should come from a File (using FileReader) */
-  public static final String STREAM_FILE = "stream.file";
-  
-  /** If the content stream should come directly from a field */
-  public static final String STREAM_BODY = "stream.body";
-  
-  /** 
-   * Explicity set the content type for the input stream
-   * If multiple streams are specified, the explicit contentType
-   * will be used for all of them.  
-   */
-  public static final String STREAM_CONTENTTYPE = "stream.contentType";
-    
-  /** 'true' if the header should include the handler name */
-  public static final String HEADER_ECHO_HANDLER = "echoHandler";
-  
-  /** include the parameters in the header **/
-  public static final String HEADER_ECHO_PARAMS = "echoParams";
-  
-  /** valid values for: <code>echoParams</code> */
-  public enum EchoParamStyle {
-    EXPLICIT,
-    ALL,
-    NONE;
-    
-    public static EchoParamStyle get( String v ) {
-      if( v != null ) {
-        v = v.toUpperCase();
-        if( v.equals( "EXPLICIT" ) ) {
-          return EXPLICIT;
-        }
-        if( v.equals( "ALL") ) {
-          return ALL;
-        }
-        if( v.equals( "NONE") ) {  // the same as nothing...
-          return NONE;
-        }
-      }
-      return null;
-    }
-  };
-  
-  /** returns the String value of a param, or null if not set */
-  public abstract String get(String param);
-
-  /** returns an array of the String values of a param, or null if none */
-  public abstract String[] getParams(String param);
-
-  /** returns an Iterator over the parameter names */
-  public abstract Iterator<String> getParameterNamesIterator();
-
-  /** returns the value of the param, or def if not set */
-  public String get(String param, String def) {
-    String val = get(param);
-    return val==null ? def : val;
-  }
-  
-  /** returns a RequiredSolrParams wrapping this */
-  public RequiredSolrParams required()
-  {
-    // TODO? should we want to stash a reference?
-    return new RequiredSolrParams(this);
-  }
-  
-  protected String fpname(String field, String param) {
-    return "f."+field+'.'+param;
-  }
-
-  /** returns the String value of the field parameter, "f.field.param", or
-   *  the value for "param" if that is not set.
-   */
-  public String getFieldParam(String field, String param) {
-    String val = get(fpname(field,param));
-    return val!=null ? val : get(param);
-  }
-
-  /** returns the String value of the field parameter, "f.field.param", or
-   *  the value for "param" if that is not set.  If that is not set, def
-   */
-  public String getFieldParam(String field, String param, String def) {
-    String val = get(fpname(field,param));
-    return val!=null ? val : get(param, def);
-  }
-  
-  /** returns the String values of the field parameter, "f.field.param", or
-   *  the values for "param" if that is not set.
-   */
-  public String[] getFieldParams(String field, String param) {
-    String[] val = getParams(fpname(field,param));
-    return val!=null ? val : getParams(param);
-  }
-
-  /** Returns the Boolean value of the param, or null if not set */
-  public Boolean getBool(String param) {
-    String val = get(param);
-    return val==null ? null : parseBool(val);
-  }
-
-  /** Returns the boolean value of the param, or def if not set */
-  public boolean getBool(String param, boolean def) {
-    String val = get(param);
-    return val==null ? def : parseBool(val);
-  }
-  
-  /** Returns the Boolean value of the field param, 
-      or the value for param, or null if neither is set. */
-  public Boolean getFieldBool(String field, String param) {
-    String val = getFieldParam(field, param);
-    return val==null ? null : parseBool(val);
-  }
-  
-  /** Returns the boolean value of the field param, 
-  or the value for param, or def if neither is set. */
-  public boolean getFieldBool(String field, String param, boolean def) {
-    String val = getFieldParam(field, param);
-    return val==null ? def : parseBool(val);
-  }
-
-  /** Returns the Integer value of the param, or null if not set */
-  public Integer getInt(String param) {
-    String val = get(param);
-    try {
-      return val==null ? null : Integer.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the int value of the param, or def if not set */
-  public int getInt(String param, int def) {
-    String val = get(param);
-    try {
-      return val==null ? def : Integer.parseInt(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** Returns the int value of the field param,
-  or the value for param, or def if neither is set. */
-  public Integer getFieldInt(String field, String param) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? null : Integer.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** Returns the int value of the field param, 
-  or the value for param, or def if neither is set. */
-  public int getFieldInt(String field, String param, int def) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? def : Integer.parseInt(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-
-  /** Returns the Float value of the param, or null if not set */
-  public Float getFloat(String param) {
-    String val = get(param);
-    try {
-      return val==null ? null : Float.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the param, or def if not set */
-  public float getFloat(String param, float def) {
-    String val = get(param);
-    try {
-      return val==null ? def : Float.parseFloat(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the field param. */
-  public Float getFieldFloat(String field, String param) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? null : Float.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the field param,
-  or the value for param, or def if neither is set. */
-  public float getFieldFloat(String field, String param, float def) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? def : Float.parseFloat(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** how to transform a String into a boolean... more flexible than
-   * Boolean.parseBoolean() to enable easier integration with html forms.
-   */
-  protected boolean parseBool(String s) {
-    if( s != null ) {
-      if( s.startsWith("true") || s.startsWith("on") || s.startsWith("yes") ) {
-        return true;
-      }
-      if( s.startsWith("false") || s.startsWith("off") || s.equals("no") ) {
-        return false;
-      }
-    }
-    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "invalid boolean value: "+s );
-  }
-
-  /** Create a Map<String,String> from a NamedList given no keys are repeated */
-  public static Map<String,String> toMap(NamedList params) {
-    HashMap<String,String> map = new HashMap<String,String>();
-    for (int i=0; i<params.size(); i++) {
-      map.put(params.getName(i), params.getVal(i).toString());
-    }
-    return map;
-  }
-
-  /** Create a Map<String,String[]> from a NamedList */
-  public static Map<String,String[]> toMultiMap(NamedList params) {
-    HashMap<String,String[]> map = new HashMap<String,String[]>();
-    for (int i=0; i<params.size(); i++) {
-      String name = params.getName(i);
-      String val = params.getVal(i).toString();
-      MultiMapSolrParams.addParam(name,val,map);
-    }
-    return map;
-  }
-
-  /** Create SolrParams from NamedList. */
-  public static SolrParams toSolrParams(NamedList params) {
-    // if no keys are repeated use the faster MapSolrParams
-    HashMap<String,String> map = new HashMap<String,String>();
-    for (int i=0; i<params.size(); i++) {
-      String prev = map.put(params.getName(i), params.getVal(i).toString());
-      if (prev!=null) return new MultiMapSolrParams(toMultiMap(params));
-    }
-    return new MapSolrParams(map);
-  }
-  
-  /** Convert this to a NamedList */
-  public NamedList<Object> toNamedList() {
-    final SimpleOrderedMap<Object> result = new SimpleOrderedMap<Object>();
-    
-    for(Iterator<String> it=getParameterNamesIterator(); it.hasNext(); ) {
-      final String name = it.next();
-      final String [] values = getParams(name);
-      if(values.length==1) {
-        result.add(name,values[0]);
-      } else {
-        // currently no reason not to use the same array
-        result.add(name,values);
-      }
-    }
-    return result;
-  }
-}
-
-
-
-
-
-
-
-
diff --git a/src/java/org/apache/solr/request/SolrQueryRequest.java b/src/java/org/apache/solr/request/SolrQueryRequest.java
index 705bba9..687f0cf 100644
--- a/src/java/org/apache/solr/request/SolrQueryRequest.java
+++ b/src/java/org/apache/solr/request/SolrQueryRequest.java
@@ -19,7 +19,8 @@ package org.apache.solr.request;
 
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.util.ContentStream;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrCore;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/request/SolrQueryRequestBase.java b/src/java/org/apache/solr/request/SolrQueryRequestBase.java
index 738bd48..441e155 100644
--- a/src/java/org/apache/solr/request/SolrQueryRequestBase.java
+++ b/src/java/org/apache/solr/request/SolrQueryRequestBase.java
@@ -18,11 +18,12 @@
 package org.apache.solr.request;
 
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.ContentStream;
 import org.apache.solr.util.RefCounted;
 import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 
 import java.util.Iterator;
 import java.util.Map;
diff --git a/src/java/org/apache/solr/request/SolrQueryResponse.java b/src/java/org/apache/solr/request/SolrQueryResponse.java
index e94de51..fea14e9 100644
--- a/src/java/org/apache/solr/request/SolrQueryResponse.java
+++ b/src/java/org/apache/solr/request/SolrQueryResponse.java
@@ -17,8 +17,8 @@
 
 package org.apache.solr.request;
 
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 
 import java.util.*;
 
diff --git a/src/java/org/apache/solr/request/SolrRequestHandler.java b/src/java/org/apache/solr/request/SolrRequestHandler.java
index 4fe2581..87a3b62 100644
--- a/src/java/org/apache/solr/request/SolrRequestHandler.java
+++ b/src/java/org/apache/solr/request/SolrRequestHandler.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.request;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrInfoMBean;
 
 /**
diff --git a/src/java/org/apache/solr/request/StandardRequestHandler.java b/src/java/org/apache/solr/request/StandardRequestHandler.java
deleted file mode 100644
index 1ce5dea..0000000
--- a/src/java/org/apache/solr/request/StandardRequestHandler.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.lucene.search.*;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.solr.util.MoreLikeThisParams;
-import org.apache.solr.util.StrUtils;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.HighlightingUtils;
-import org.apache.solr.util.SolrPluginUtils;
-import org.apache.solr.search.*;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.handler.MoreLikeThisHandler;
-import org.apache.solr.handler.RequestHandlerBase;
-
-import static org.apache.solr.request.SolrParams.*;
-
-/**
- * @author yonik
- * @version $Id$
- *
- * All of the following options may be configured for this handler
- * in the solrconfig as defaults, and may be overriden as request parameters.
- * (TODO: complete documentation of request parameters here, rather than only
- * on the wiki).
- * </p>
- *
- * <ul>
- * <li> highlight - Set to any value not .equal() to "false" to enable highlight
- * generation</li>
- * <li> highlightFields - Set to a comma- or space-delimited list of fields to
- * highlight.  If unspecified, uses the default query field</li>
- * <li> maxSnippets - maximum number of snippets to generate per field-highlight.
- * </li>
- * </ul>
- *
- */
-public class StandardRequestHandler extends RequestHandlerBase {
-
-  /** shorten the class references for utilities */
-  private static class U extends SolrPluginUtils {
-    /* :NOOP */
-  }
-
-
-  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception
-  {
-    
-      SolrParams p = req.getParams();
-      String qstr = p.required().get(Q);
-
-      String defaultField = p.get(DF);
-
-      // find fieldnames to return (fieldlist)
-      String fl = p.get(SolrParams.FL);
-      int flags = 0; 
-      if (fl != null) {
-        flags |= U.setReturnFields(fl, rsp);
-      }
-      
-      String sortStr = p.get(SORT);
-      if( sortStr == null ) {  
-        // TODO? should we disable the ';' syntax with config?
-        // legacy mode, where sreq is query;sort
-        List<String> commands = StrUtils.splitSmart(qstr,';');
-        if( commands.size() == 2 ) {
-          // TODO? add a deprication warning to the response header
-          qstr = commands.get( 0 );
-          sortStr = commands.get( 1 );
-        }
-        else if( commands.size() == 1 ) {
-          // This is need to support the case where someone sends: "q=query;"
-          qstr = commands.get( 0 );
-        }
-        else if( commands.size() > 2 ) {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "If you want to use multiple ';' in the query, use the 'sort' param." );
-        }
-      }
-
-      Sort sort = null;
-      if( sortStr != null ) {
-        QueryParsing.SortSpec sortSpec = QueryParsing.parseSort(sortStr, req.getSchema());
-        if (sortSpec != null) {
-          sort = sortSpec.getSort();
-        }
-      }
-
-      // parse the query from the 'q' parameter (sort has been striped)
-      Query query = QueryParsing.parseQuery(qstr, defaultField, p, req.getSchema());
-      
-      DocListAndSet results = new DocListAndSet();
-      NamedList facetInfo = null;
-      List<Query> filters = U.parseFilterQueries(req);
-      SolrIndexSearcher s = req.getSearcher();
-
-      if (p.getBool(FACET,false)) {
-        results = s.getDocListAndSet(query, filters, sort,
-                                     p.getInt(START,0), p.getInt(ROWS,10),
-                                     flags);
-        facetInfo = getFacetInfo(req, rsp, results.docSet);
-      } else {
-        results.docList = s.getDocList(query, filters, sort,
-                                       p.getInt(START,0), p.getInt(ROWS,10),
-                                       flags);
-      }
-
-      // pre-fetch returned documents
-      U.optimizePreFetchDocs(results.docList, query, req, rsp);
-      
-      rsp.add("response",results.docList);
-
-      if (null != facetInfo) rsp.add("facet_counts", facetInfo);
-
-      // Include "More Like This" results for *each* result
-      if( p.getBool( MoreLikeThisParams.MLT, false ) ) {
-        MoreLikeThisHandler.MoreLikeThisHelper mlt 
-          = new MoreLikeThisHandler.MoreLikeThisHelper( p, s );
-        int mltcount = p.getInt( MoreLikeThisParams.DOC_COUNT, 5 );
-        rsp.add( "moreLikeThis", mlt.getMoreLikeThese(results.docList, mltcount, flags));
-      }
-      
-      try {
-        NamedList dbg = U.doStandardDebug(req, qstr, query, results.docList);
-        if (null != dbg) {
-          if (null != filters) {
-            dbg.add("filter_queries",req.getParams().getParams(FQ));
-            List<String> fqs = new ArrayList<String>(filters.size());
-            for (Query fq : filters) {
-              fqs.add(QueryParsing.toString(fq, req.getSchema()));
-            }
-            dbg.add("parsed_filter_queries",fqs);
-          }
-          rsp.add("debug", dbg);
-        }
-      } catch (Exception e) {
-        SolrException.logOnce(SolrCore.log, "Exception during debug", e);
-        rsp.add("exception_during_debug", SolrException.toStr(e));
-      }
-      
-      NamedList sumData = HighlightingUtils.doHighlighting(
-        results.docList, query.rewrite(req.getSearcher().getReader()), req, new String[]{defaultField});
-      if(sumData != null)
-        rsp.add("highlighting", sumData);
-  }
-
-  /**
-   * Fetches information about Facets for this request.
-   *
-   * Subclasses may with to override this method to provide more 
-   * advanced faceting behavior.
-   * @see SimpleFacets#getFacetCounts
-   */
-  protected NamedList getFacetInfo(SolrQueryRequest req, 
-                                   SolrQueryResponse rsp, 
-                                   DocSet mainSet) {
-
-    SimpleFacets f = new SimpleFacets(req.getSearcher(), 
-                                      mainSet, 
-                                      req.getParams());
-    return f.getFacetCounts();
-  }
-
-
-
-  //////////////////////// SolrInfoMBeans methods //////////////////////
-
-  public String getVersion() {
-    return "$Revision$";
-  }
-
-  public String getDescription() {
-    return "The standard Solr request handler";
-  }
-
-  public String getSourceId() {
-    return "$Id$";
-  }
-
-  public String getSource() {
-    return "$URL$";
-  }
-
-  public URL[] getDocs() {
-    try {
-      return new URL[] { new URL("http://wiki.apache.org/solr/StandardRequestHandler") };
-    }
-    catch( MalformedURLException ex ) { return null; }
-  }
-}
-
-
-
-
-
-
-
diff --git a/src/java/org/apache/solr/request/TextResponseWriter.java b/src/java/org/apache/solr/request/TextResponseWriter.java
index d2cf4a4..9c678d9 100644
--- a/src/java/org/apache/solr/request/TextResponseWriter.java
+++ b/src/java/org/apache/solr/request/TextResponseWriter.java
@@ -18,10 +18,10 @@
 package org.apache.solr.request;
 
 import org.apache.lucene.document.Document;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.NamedList;
 
 import java.io.IOException;
 import java.io.Writer;
diff --git a/src/java/org/apache/solr/request/XMLResponseWriter.java b/src/java/org/apache/solr/request/XMLResponseWriter.java
index cdc43fa..203d852 100644
--- a/src/java/org/apache/solr/request/XMLResponseWriter.java
+++ b/src/java/org/apache/solr/request/XMLResponseWriter.java
@@ -20,7 +20,7 @@ package org.apache.solr.request;
 import java.io.Writer;
 import java.io.IOException;
 
-import org.apache.solr.util.NamedList;
+import org.apache.solr.common.util.NamedList;
 
 /**
  * @author yonik
diff --git a/src/java/org/apache/solr/request/XMLWriter.java b/src/java/org/apache/solr/request/XMLWriter.java
index b97095a..9c33e62 100644
--- a/src/java/org/apache/solr/request/XMLWriter.java
+++ b/src/java/org/apache/solr/request/XMLWriter.java
@@ -17,8 +17,8 @@
 
 package org.apache.solr.request;
 
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.XML;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.DocIterator;
diff --git a/src/java/org/apache/solr/request/XSLTResponseWriter.java b/src/java/org/apache/solr/request/XSLTResponseWriter.java
index 034d978..2b22394 100644
--- a/src/java/org/apache/solr/request/XSLTResponseWriter.java
+++ b/src/java/org/apache/solr/request/XSLTResponseWriter.java
@@ -31,8 +31,9 @@ import javax.xml.transform.TransformerException;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
 
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrConfig;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.xslt.TransformerProvider;
 
 /** QueryResponseWriter which captures the output of the XMLWriter
diff --git a/src/java/org/apache/solr/schema/CompressableField.java b/src/java/org/apache/solr/schema/CompressableField.java
index 43c1d66..88d1a03 100644
--- a/src/java/org/apache/solr/schema/CompressableField.java
+++ b/src/java/org/apache/solr/schema/CompressableField.java
@@ -20,6 +20,8 @@ package org.apache.solr.schema;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
 
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.request.*;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/schema/DateField.java b/src/java/org/apache/solr/schema/DateField.java
index f1f61d5..31a498d 100644
--- a/src/java/org/apache/solr/schema/DateField.java
+++ b/src/java/org/apache/solr/schema/DateField.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.schema;
 
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 import org.apache.solr.request.XMLWriter;
 import org.apache.solr.request.TextResponseWriter;
 import org.apache.lucene.document.Fieldable;
diff --git a/src/java/org/apache/solr/schema/FieldType.java b/src/java/org/apache/solr/schema/FieldType.java
index ff1f336..437cac6 100644
--- a/src/java/org/apache/solr/schema/FieldType.java
+++ b/src/java/org/apache/solr/schema/FieldType.java
@@ -30,7 +30,7 @@ import org.apache.solr.search.Sorting;
 import org.apache.solr.request.XMLWriter;
 import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.analysis.SolrAnalyzer;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 
 import java.util.logging.Logger;
 import java.util.Map;
diff --git a/src/java/org/apache/solr/schema/IndexSchema.java b/src/java/org/apache/solr/schema/IndexSchema.java
index 61b2873..84bf336 100644
--- a/src/java/org/apache/solr/schema/IndexSchema.java
+++ b/src/java/org/apache/solr/schema/IndexSchema.java
@@ -23,14 +23,14 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.DefaultSimilarity;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.queryParser.QueryParser;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
 import org.apache.solr.core.SolrConfig;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.core.Config;
 import org.apache.solr.analysis.TokenFilterFactory;
 import org.apache.solr.analysis.TokenizerChain;
 import org.apache.solr.analysis.TokenizerFactory;
 import org.apache.solr.search.SolrQueryParser;
-import org.apache.solr.util.DOMUtil;
 import org.w3c.dom.Document;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
diff --git a/src/java/org/apache/solr/search/CacheConfig.java b/src/java/org/apache/solr/search/CacheConfig.java
index 430ddec..d979f4a 100644
--- a/src/java/org/apache/solr/search/CacheConfig.java
+++ b/src/java/org/apache/solr/search/CacheConfig.java
@@ -22,8 +22,8 @@ import org.w3c.dom.NodeList;
 
 import java.util.Map;
 
-import org.apache.solr.util.DOMUtil;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.Config;
 
diff --git a/src/java/org/apache/solr/search/DocSet.java b/src/java/org/apache/solr/search/DocSet.java
index 9eb19b1..1887e1d 100644
--- a/src/java/org/apache/solr/search/DocSet.java
+++ b/src/java/org/apache/solr/search/DocSet.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.search;
 
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 import org.apache.solr.util.OpenBitSet;
 
 import java.util.BitSet;
diff --git a/src/java/org/apache/solr/search/LRUCache.java b/src/java/org/apache/solr/search/LRUCache.java
index f2f84c5..50a6f41 100644
--- a/src/java/org/apache/solr/search/LRUCache.java
+++ b/src/java/org/apache/solr/search/LRUCache.java
@@ -17,10 +17,10 @@
 
 package org.apache.solr.search;
 
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 
 import java.util.*;
 import java.util.concurrent.atomic.AtomicLong;
diff --git a/src/java/org/apache/solr/search/QueryParsing.java b/src/java/org/apache/solr/search/QueryParsing.java
index 26ea7ed..1134c83 100644
--- a/src/java/org/apache/solr/search/QueryParsing.java
+++ b/src/java/org/apache/solr/search/QueryParsing.java
@@ -23,12 +23,12 @@ import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.Term;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.schema.FieldType;
-import org.apache.solr.request.SolrParams;
 
 import java.util.ArrayList;
 import java.util.List;
diff --git a/src/java/org/apache/solr/search/SolrIndexSearcher.java b/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 9ed3528..236db9f 100644
--- a/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -25,15 +25,15 @@ import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.search.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.PriorityQueue;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.core.SolrInfoRegistry;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.OpenBitSet;
-import org.apache.solr.util.SimpleOrderedMap;
 
 import java.io.IOException;
 import java.net.URL;
diff --git a/src/java/org/apache/solr/tst/OldRequestHandler.java b/src/java/org/apache/solr/tst/OldRequestHandler.java
index a62fb94..2af3bfd 100644
--- a/src/java/org/apache/solr/tst/OldRequestHandler.java
+++ b/src/java/org/apache/solr/tst/OldRequestHandler.java
@@ -26,9 +26,9 @@ import java.io.IOException;
 import java.net.URL;
 
 import org.apache.solr.util.StrUtils;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.search.DocSlice;
 import org.apache.solr.search.QueryParsing;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.request.SolrQueryResponse;
diff --git a/src/java/org/apache/solr/tst/TestRequestHandler.java b/src/java/org/apache/solr/tst/TestRequestHandler.java
index 4a84c3a..5a0e07e 100644
--- a/src/java/org/apache/solr/tst/TestRequestHandler.java
+++ b/src/java/org/apache/solr/tst/TestRequestHandler.java
@@ -29,11 +29,11 @@ import java.util.logging.Level;
 import java.net.URL;
 
 import org.apache.solr.util.StrUtils;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.OpenBitSet;
 import org.apache.solr.search.*;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
diff --git a/src/java/org/apache/solr/update/DirectUpdateHandler.java b/src/java/org/apache/solr/update/DirectUpdateHandler.java
index e93cbf5..e4591a7 100644
--- a/src/java/org/apache/solr/update/DirectUpdateHandler.java
+++ b/src/java/org/apache/solr/update/DirectUpdateHandler.java
@@ -37,11 +37,11 @@ import java.net.URL;
 
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.QueryParsing;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
 import org.apache.solr.update.UpdateHandler;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 
 /**
  * <code>DirectUpdateHandler</code> implements an UpdateHandler where documents are added
diff --git a/src/java/org/apache/solr/update/DirectUpdateHandler2.java b/src/java/org/apache/solr/update/DirectUpdateHandler2.java
index 673c8b5..a5e1f69 100644
--- a/src/java/org/apache/solr/update/DirectUpdateHandler2.java
+++ b/src/java/org/apache/solr/update/DirectUpdateHandler2.java
@@ -47,11 +47,11 @@ import java.net.URL;
 
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.QueryParsing;
-import org.apache.solr.util.NamedList;
-import org.apache.solr.util.SimpleOrderedMap;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrConfig;
-import org.apache.solr.core.SolrException;
 
 /**
  * <code>DirectUpdateHandler2</code> implements an UpdateHandler where documents are added
diff --git a/src/java/org/apache/solr/update/DocumentBuilder.java b/src/java/org/apache/solr/update/DocumentBuilder.java
index bd4359e..dd4a3f0 100644
--- a/src/java/org/apache/solr/update/DocumentBuilder.java
+++ b/src/java/org/apache/solr/update/DocumentBuilder.java
@@ -23,7 +23,7 @@ import java.util.List;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 
diff --git a/src/java/org/apache/solr/update/UpdateHandler.java b/src/java/org/apache/solr/update/UpdateHandler.java
index e6892b7..5cc6835 100644
--- a/src/java/org/apache/solr/update/UpdateHandler.java
+++ b/src/java/org/apache/solr/update/UpdateHandler.java
@@ -31,10 +31,11 @@ import java.util.Vector;
 import java.io.IOException;
 
 import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.util.DOMUtil;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.schema.FieldType;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.DOMUtil;
 import org.apache.solr.core.*;
 
 import javax.xml.xpath.XPathConstants;
diff --git a/src/java/org/apache/solr/util/AbstractSolrTestCase.java b/src/java/org/apache/solr/util/AbstractSolrTestCase.java
index 30c99b0..1d7ceba 100644
--- a/src/java/org/apache/solr/util/AbstractSolrTestCase.java
+++ b/src/java/org/apache/solr/util/AbstractSolrTestCase.java
@@ -18,7 +18,8 @@
 
 package org.apache.solr.util;
 
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.request.*;
 import org.apache.solr.util.TestHarness;
 
diff --git a/src/java/org/apache/solr/util/CommonParams.java b/src/java/org/apache/solr/util/CommonParams.java
deleted file mode 100755
index 5e8a5df..0000000
--- a/src/java/org/apache/solr/util/CommonParams.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import org.apache.solr.core.SolrCore;
-
-import org.apache.solr.util.NamedList;
-import org.apache.solr.request.SolrParams;
-
-
-
-/**
- * A collection on common params, both for Plugin initialization and
- * for Requests.
- */
-@Deprecated
-public class CommonParams {
-
-  @Deprecated
-  public static String FL = "fl";
-  /** default query field */
-  @Deprecated
-  public static String DF = "df";
-  /** whether to include debug data */
-  @Deprecated
-  public static String DEBUG_QUERY = "debugQuery";
-  /** another query to explain against */
-  @Deprecated
-  public static String EXPLAIN_OTHER = "explainOther";
-
-
-  /** the default field list to be used */
-  public String fl = null;
-  /** the default field to query */
-  public String df = null;
-  /** do not debug by default **/
-  public String debugQuery = null;
-  /** no default other explanation query **/
-  public String explainOther = null;
-  /** whether to highlight */
-  public boolean highlight = false;
-  /** fields to highlight */
-  public String highlightFields = null;
-  /** maximum highlight fragments to return */
-  public int maxSnippets = 1;
-  /** override default highlight Formatter class */
-  public String highlightFormatterClass = null;
-
-
-  public CommonParams() {
-    /* :NOOP: */
-  }
-
-  /** @see #setValues */
-  public CommonParams(NamedList args) {
-    this();
-    setValues(args);
-  }
-
-  /**
-   * Sets the params using values from a NamedList, usefull in the
-   * init method for your handler.
-   *
-   * <p>
-   * If any param is not of the expected type, a severe error is
-   * logged,and the param is skipped.
-   * </p>
-   *
-   * <p>
-   * If any param is not of in the NamedList, it is skipped and the
-   * old value is left alone.
-   * </p>
-   *
-   */
-  public void setValues(NamedList args) {
-
-    Object tmp;
-
-    tmp = args.get(SolrParams.FL);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        fl = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + SolrParams.FL);
-      }
-    }
-
-    tmp = args.get(SolrParams.DF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        df = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + SolrParams.DF);
-      }
-    }
-
-    tmp = args.get(SolrParams.DEBUG_QUERY);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        debugQuery = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + SolrParams.DEBUG_QUERY);
-      }
-    }
-
-    tmp = args.get(SolrParams.EXPLAIN_OTHER);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        explainOther = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + SolrParams.EXPLAIN_OTHER);
-      }
-    }
-
-  }
-
-}
-
diff --git a/src/java/org/apache/solr/util/ContentStream.java b/src/java/org/apache/solr/util/ContentStream.java
deleted file mode 100755
index f200680..0000000
--- a/src/java/org/apache/solr/util/ContentStream.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-import org.apache.commons.io.IOUtils;
-
-/**
- * @author ryan
- * @version $Id$
- * @since solr 1.2
- */
-public interface ContentStream {
-  String getName();
-  String getSourceInfo();
-  String getContentType();
-  
-  /**
-   * @return the stream size or <code>null</code> if not known
-   */
-  Long getSize(); // size if we know it, otherwise null
-  
-  /**
-   * Get an open stream.  You are responsible for closing it.  Consider using 
-   * something like:
-   * <pre>
-   *   InputStream stream = stream.getStream();
-   *   try {
-   *     // use the stream...
-   *   }
-   *   finally {
-   *     IOUtils.closeQuietly(reader);
-   *   }
-   *  </pre>
-   *  
-   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
-   * is gaurenteed to work.  The runtime behavior for aditional calls is undefined.
-   */
-  InputStream getStream() throws IOException;
-
-  /**
-   * Get an open stream.  You are responsible for closing it.  Consider using 
-   * something like:
-   * <pre>
-   *   Reader reader = stream.getReader();
-   *   try {
-   *     // use the reader...
-   *   }
-   *   finally {
-   *     IOUtils.closeQuietly(reader);
-   *   }
-   *  </pre>
-   *  
-   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
-   * is gaurenteed to work.  The runtime behavior for aditional calls is undefined.
-   */
-  Reader getReader() throws IOException;
-}
diff --git a/src/java/org/apache/solr/util/ContentStreamBase.java b/src/java/org/apache/solr/util/ContentStreamBase.java
deleted file mode 100755
index 32f7c50..0000000
--- a/src/java/org/apache/solr/util/ContentStreamBase.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-import java.net.URL;
-import java.net.URLConnection;
-
-
-/**
- * Three concrete implementations for ContentStream - one for File/URL/String
- * 
- * @author ryan
- * @version $Id$
- * @since solr 1.2
- */
-public abstract class ContentStreamBase implements ContentStream
-{
-  public static final String DEFAULT_CHARSET = "utf-8";
-  
-  protected String name;
-  protected String sourceInfo;
-  protected String contentType;
-  protected Long size;
-  
-  //---------------------------------------------------------------------
-  //---------------------------------------------------------------------
-  
-  public static String getCharsetFromContentType( String contentType )
-  {
-    if( contentType != null ) {
-      int idx = contentType.toLowerCase().indexOf( "charset=" );
-      if( idx > 0 ) {
-        return contentType.substring( idx + "charset=".length() ).trim();
-      }
-    }
-    return null;
-  }
-  
-  //------------------------------------------------------------------------
-  //------------------------------------------------------------------------
-  
-  /**
-   * Construct a <code>ContentStream</code> from a <code>URL</code>
-   * 
-   * This uses a <code>URLConnection</code> to get the content stream
-   * @see  URLConnection
-   */
-  public static class URLStream extends ContentStreamBase
-  {
-    private final URL url;
-    final URLConnection conn;
-    
-    public URLStream( URL url ) throws IOException {
-      this.url = url; 
-      this.conn = this.url.openConnection();
-      
-      contentType = conn.getContentType();
-      name = url.toExternalForm();
-      size = new Long( conn.getContentLength() );
-      sourceInfo = "url";
-    }
-
-    public InputStream getStream() throws IOException {
-      return conn.getInputStream();
-    }
-  }
-  
-  /**
-   * Construct a <code>ContentStream</code> from a <code>File</code>
-   */
-  public static class FileStream extends ContentStreamBase
-  {
-    private final File file;
-    
-    public FileStream( File f ) throws IOException {
-      file = f; 
-      
-      contentType = null; // ??
-      name = file.getName();
-      size = file.length();
-      sourceInfo = file.toURI().toString();
-    }
-
-    public InputStream getStream() throws IOException {
-      return new FileInputStream( file );
-    }
-
-    /**
-     * If an charset is defined (by the contentType) ues that, otherwise 
-     * use a file reader
-     */
-    public Reader getReader() throws IOException {
-      String charset = getCharsetFromContentType( contentType );
-      return charset == null 
-        ? new FileReader( file )
-        : new InputStreamReader( getStream(), charset );
-    }
-  }
-  
-
-  /**
-   * Construct a <code>ContentStream</code> from a <code>File</code>
-   */
-  public static class StringStream extends ContentStreamBase
-  {
-    private final String str;
-    
-    public StringStream( String str ) {
-      this.str = str; 
-      
-      contentType = null;
-      name = null;
-      size = new Long( str.length() );
-      sourceInfo = "string";
-    }
-
-    public InputStream getStream() throws IOException {
-      return new ByteArrayInputStream( str.getBytes() );
-    }
-
-    /**
-     * If an charset is defined (by the contentType) ues that, otherwise 
-     * use a StringReader
-     */
-    public Reader getReader() throws IOException {
-      String charset = getCharsetFromContentType( contentType );
-      return charset == null 
-        ? new StringReader( str )
-        : new InputStreamReader( getStream(), charset );
-    }
-  }
-
-  /**
-   * Base reader implementation.  If the contentType declares a 
-   * charset use it, otherwise use "utf-8".
-   */
-  public Reader getReader() throws IOException {
-    String charset = getCharsetFromContentType( getContentType() );
-    return charset == null 
-      ? new InputStreamReader( getStream(), DEFAULT_CHARSET )
-      : new InputStreamReader( getStream(), charset );
-  }
-
-  //------------------------------------------------------------------
-  // Getters / Setters for overrideable attributes
-  //------------------------------------------------------------------
-
-  public String getContentType() {
-    return contentType;
-  }
-
-  public void setContentType(String contentType) {
-    this.contentType = contentType;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public void setName(String name) {
-    this.name = name;
-  }
-
-  public Long getSize() {
-    return size;
-  }
-
-  public void setSize(Long size) {
-    this.size = size;
-  }
-
-  public String getSourceInfo() {
-    return sourceInfo;
-  }
-
-  public void setSourceInfo(String sourceInfo) {
-    this.sourceInfo = sourceInfo;
-  }
-}
diff --git a/src/java/org/apache/solr/util/DOMUtil.java b/src/java/org/apache/solr/util/DOMUtil.java
deleted file mode 100644
index 3266267..0000000
--- a/src/java/org/apache/solr/util/DOMUtil.java
+++ /dev/null
@@ -1,365 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import org.w3c.dom.Element;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.apache.solr.core.SolrException;
-
-import java.util.Map;
-import java.util.HashMap;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.Iterator;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class DOMUtil {
-
-  public static Map<String,String> toMap(NamedNodeMap attrs) {
-    return toMapExcept(attrs);
-  }
-
-  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
-    Map<String,String> args = new HashMap<String,String>();
-    outer: for (int j=0; j<attrs.getLength(); j++) {
-      Node attr = attrs.item(j);
-      String attrName = attr.getNodeName();
-      for (String ex : exclusions)
-        if (ex.equals(attrName)) continue outer;
-      String val = attr.getNodeValue();
-      args.put(attrName, val);
-    }
-    return args;
-  }
-
-  public static Node getChild(Node node, String name) {
-    if (!node.hasChildNodes()) return null;
-    NodeList lst = node.getChildNodes();
-    if (lst == null) return null;
-    for (int i=0; i<lst.getLength(); i++) {
-      Node child = lst.item(i);
-      if (name.equals(child.getNodeName())) return child;
-    }
-    return null;
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name) {
-    return getAttr(attrs,name,null);
-  }
-
-  public static String getAttr(Node nd, String name) {
-    return getAttr(nd.getAttributes(), name);
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
-    Node attr = attrs==null? null : attrs.getNamedItem(name);
-    if (attr==null) {
-      if (missing_err==null) return null;
-      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
-    }
-    String val = attr.getNodeValue();
-    return val;
-  }
-
-  public static String getAttr(Node node, String name, String missing_err) {
-    return getAttr(node.getAttributes(), name, missing_err);
-  }
-
-  //////////////////////////////////////////////////////////
-  // Routines to parse XML in the syntax of the Solr query
-  // response schema.
-  // Should these be moved to Config?  Should all of these things?
-  //////////////////////////////////////////////////////////
-  public static NamedList childNodesToNamedList(Node nd) {
-    return nodesToNamedList(nd.getChildNodes());
-  }
-
-  public static List childNodesToList(Node nd) {
-    return nodesToList(nd.getChildNodes());
-  }
-
-  public static NamedList nodesToNamedList(NodeList nlst) {
-    NamedList clst = new NamedList();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), clst, null);
-    }
-    return clst;
-  }
-
-  public static List nodesToList(NodeList nlst) {
-    List lst = new ArrayList();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), null, lst);
-    }
-    return lst;
-  }
-
-
-  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
-    // Nodes often include whitespace, etc... so just return if this
-    // is not an Element.
-    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
-
-    String type = nd.getNodeName();
-
-    String name = null;
-    if (nd.hasAttributes()) {
-      NamedNodeMap attrs = nd.getAttributes();
-      Node nameNd = attrs.getNamedItem("name");
-      if (nameNd != null) name=nameNd.getNodeValue();
-    }
-
-    Object val=null;
-
-    if ("str".equals(type)) {
-      val = getText(nd);
-    } else if ("int".equals(type)) {
-      val = Integer.valueOf(getText(nd));
-    } else if ("long".equals(type)) {
-      val = Long.valueOf(getText(nd));
-    } else if ("float".equals(type)) {
-      val = Float.valueOf(getText(nd));
-    } else if ("double".equals(type)) {
-      val = Double.valueOf(getText(nd));
-    } else if ("bool".equals(type)) {
-      val = Boolean.valueOf(getText(nd));
-    } else if ("lst".equals(type)) {
-      val = childNodesToNamedList(nd);
-    } else if ("arr".equals(type)) {
-      val = childNodesToList(nd);
-    }
-
-    if (nlst != null) nlst.add(name,val);
-    if (arr != null) arr.add(val);
-  }
-
-  /**
-   * Drop in replacement for Node.getTextContent().
-   *
-   * <p>
-   * This method is provided to support the same functionality as
-   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
-   * </p>
-   *
-   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
-   */
-  public static String getText(Node nd) {
-
-    short type = nd.getNodeType();
-
-    // for most node types, we can defer to the recursive helper method,
-    // but when asked for the text of these types, we must return null
-    // (Not the empty string)
-    switch (type) {
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-      return null;
-    }
-
-    StringBuilder sb = new StringBuilder();
-    getText(nd, sb);
-    return sb.toString();
-  }
-
-  /** @see #getText(Node) */
-  private static void getText(Node nd, StringBuilder buf) {
-
-    short type = nd.getNodeType();
-
-    switch (type) {
-
-    case Node.ELEMENT_NODE: /* fall through */
-    case Node.ENTITY_NODE: /* fall through */
-    case Node.ENTITY_REFERENCE_NODE: /* fall through */
-    case Node.DOCUMENT_FRAGMENT_NODE:
-      NodeList childs = nd.getChildNodes();
-      for (int i = 0; i < childs.getLength(); i++) {
-        Node child = childs.item(i);
-        short childType = child.getNodeType();
-        if (childType != Node.COMMENT_NODE &&
-            childType != Node.PROCESSING_INSTRUCTION_NODE) {
-          getText(child, buf);
-        }
-      }
-      break;
-
-    case Node.ATTRIBUTE_NODE: /* fall through */
-      /* Putting Attribute nodes in this section does not exactly 
-         match the definition of how textContent should behave 
-         according to the DOM Level-3 Core documentation - which 
-         specifies that the Attr's children should have their 
-         textContent concated (Attr's can have a single child which 
-         is either Text node or an EntityRefrence).  In practice,
-         DOM implementations do not seem to use child nodes of 
-         Attributes, storing the "text" directly as the nodeValue.
-         Fortunately, the DOM Spec indicates that when Attr.nodeValue 
-         is read, it should return the nodeValue from the child Node, 
-         so this approach should work both for strict implementations, 
-         and implementations actually encountered.
-      */
-    case Node.TEXT_NODE: /* fall through */
-    case Node.CDATA_SECTION_NODE: /* fall through */
-    case Node.COMMENT_NODE: /* fall through */
-    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
-      buf.append(nd.getNodeValue());
-      break;
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-    default:
-      /* :NOOP: */
-
-    }
-  }
-
-  /**
-   * Replaces ${system.property[:default value]} references in all attributes
-   * and text nodes of supplied node.  If the system property is not defined and no
-   * default value is provided, a runtime exception is thrown.
-   *
-   * @param node DOM node to walk for substitutions
-   */
-  public static void substituteSystemProperties(Node node) {
-    // loop through child nodes
-    Node child;
-    Node next = node.getFirstChild();
-    while ((child = next) != null) {
-
-      // set next before we change anything
-      next = child.getNextSibling();
-
-      // handle child by node type
-      if (child.getNodeType() == Node.TEXT_NODE) {
-        child.setNodeValue(substituteSystemProperty(child.getNodeValue()));
-      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
-        // handle child elements with recursive call
-        NamedNodeMap attributes = child.getAttributes();
-        for (int i = 0; i < attributes.getLength(); i++) {
-          Node attribute = attributes.item(i);
-          attribute.setNodeValue(substituteSystemProperty(attribute.getNodeValue()));
-        }
-        substituteSystemProperties(child);
-      }
-    }
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.replaceProperties:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  private static String substituteSystemProperty(String value) {
-    if (value == null || value.indexOf('$') == -1) {
-      return value;
-    }
-
-    List<String> fragments = new ArrayList<String>();
-    List<String> propertyRefs = new ArrayList<String>();
-    parsePropertyString(value, fragments, propertyRefs);
-
-    StringBuffer sb = new StringBuffer();
-    Iterator<String> i = fragments.iterator();
-    Iterator<String> j = propertyRefs.iterator();
-
-    while (i.hasNext()) {
-      String fragment = i.next();
-      if (fragment == null) {
-        String propertyName = j.next();
-        String defaultValue = null;
-        int colon_index = propertyName.indexOf(':');
-        if (colon_index > -1) {
-          defaultValue = propertyName.substring(colon_index + 1);
-          propertyName = propertyName.substring(0,colon_index);
-        }
-        fragment = System.getProperty(propertyName,defaultValue);
-        if (fragment == null) {
-          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName);
-        }
-      }
-      sb.append(fragment);
-    }
-    return sb.toString();
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
-      int prev = 0;
-      int pos;
-      //search for the next instance of $ from the 'prev' position
-      while ((pos = value.indexOf("$", prev)) >= 0) {
-
-          //if there was any text before this, add it as a fragment
-          //TODO, this check could be modified to go if pos>prev;
-          //seems like this current version could stick empty strings
-          //into the list
-          if (pos > 0) {
-              fragments.add(value.substring(prev, pos));
-          }
-          //if we are at the end of the string, we tack on a $
-          //then move past it
-          if (pos == (value.length() - 1)) {
-              fragments.add("$");
-              prev = pos + 1;
-          } else if (value.charAt(pos + 1) != '{') {
-              //peek ahead to see if the next char is a property or not
-              //not a property: insert the char as a literal
-              /*
-              fragments.addElement(value.substring(pos + 1, pos + 2));
-              prev = pos + 2;
-              */
-              if (value.charAt(pos + 1) == '$') {
-                  //backwards compatibility two $ map to one mode
-                  fragments.add("$");
-                  prev = pos + 2;
-              } else {
-                  //new behaviour: $X maps to $X for all values of X!='$'
-                  fragments.add(value.substring(pos, pos + 2));
-                  prev = pos + 2;
-              }
-
-          } else {
-              //property found, extract its name or bail on a typo
-              int endName = value.indexOf('}', pos);
-              if (endName < 0) {
-                throw new RuntimeException("Syntax error in property: " + value);
-              }
-              String propertyName = value.substring(pos + 2, endName);
-              fragments.add(null);
-              propertyRefs.add(propertyName);
-              prev = endName + 1;
-          }
-      }
-      //no more $ signs found
-      //if there is any tail to the string, append it
-      if (prev < value.length()) {
-          fragments.add(value.substring(prev));
-      }
-  }
-
-}
diff --git a/src/java/org/apache/solr/util/DisMaxParams.java b/src/java/org/apache/solr/util/DisMaxParams.java
deleted file mode 100755
index 0c056bd..0000000
--- a/src/java/org/apache/solr/util/DisMaxParams.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrInfoMBean;
-import org.apache.solr.core.SolrException;
-
-import org.apache.solr.util.StrUtils;
-import org.apache.solr.util.NamedList;
-
-import java.util.logging.Logger;
-import java.util.logging.Level;
-import java.util.logging.Handler;
-
-import java.util.Arrays;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Collection;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.regex.Pattern;
-import java.io.IOException;
-
-    
-
-/**
- * A collection of params used in DisMaxRequestHandler,
- * both for Plugin initialization and for Requests.
- */
-public class DisMaxParams extends CommonParams {
-  
-  /** query and init param for tiebreaker value */
-  public static String TIE = "tie";
-  /** query and init param for query fields */
-  public static String QF = "qf";
-  /** query and init param for phrase boost fields */
-  public static String PF = "pf";
-  /** query and init param for MinShouldMatch specification */
-  public static String MM = "mm";
-  /**
-   * query and init param for Phrase Slop value in phrase
-   * boost query (in pf fields)
-   */
-  public static String PS = "ps";
-  /**
-   * query and init param for phrase Slop value in phrases
-   * explicitly included in the user's query string ( in qf fields)
-   */
-  public static String QS = "qs";
-  /** query and init param for boosting query */
-  public static String BQ = "bq";
-  /** query and init param for boosting functions */
-  public static String BF = "bf";
-  /**
-   * Alternate query (expressed in Solr QuerySyntax)
-   * to use if main query (q) is empty
-   */
-  public static String ALTQ = "q.alt";
-  /** query and init param for filtering query
-   * @deprecated use SolrParams.FQ or SolrPluginUtils.parseFilterQueries
-   */
-  public static String FQ = "fq";
-  /** query and init param for field list */
-  public static String GEN = "gen";
-        
-  /**
-   * the default tie breaker to use in DisjunctionMaxQueries
-   * @deprecated - use explicit default with SolrParams.getFloat
-   */
-  public float tiebreaker = 0.0f;
-  /**
-   * the default query fields to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String qf = null;
-  /**
-   * the default phrase boosting fields to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String pf = null;
-  /**
-   * the default min should match to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String mm = "100%";
-  /**
-   * the default phrase slop to be used 
-   * @deprecated - use explicit default with SolrParams.getInt
-   */
-  public int pslop = 0;
-  /**
-   * the default boosting query to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String bq = null;
-  /**
-   * the default boosting functions to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String bf = null;
-  /**
-   * the default filtering query to be used
-   * @deprecated - use explicit default with SolrParams.get
-   */
-  public String fq = null;
-
-
-  /**
-   * Sets the params using values from a NamedList, usefull in the
-   * init method for your handler.
-   *
-   * <p>
-   * If any param is not of the expected type, a severe error is
-   * logged,and the param is skipped.
-   * </p>
-   *
-   * <p>
-   * If any param is not of in the NamedList, it is skipped and the
-   * old value is left alone.
-   * </p>
-   * @deprecated use SolrParams.toSolrParams
-   */
-  public void setValues(NamedList args) {
-
-    super.setValues(args);
-
-    Object tmp;
-
-    tmp = args.get(TIE);
-    if (null != tmp) {
-      if (tmp instanceof Float) {
-        tiebreaker = ((Float)tmp).floatValue();
-      } else {
-        SolrCore.log.severe("init param is not a float: " + TIE);
-      }
-    }
-
-    tmp = args.get(QF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        qf = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + QF);
-      }
-    }
-
-    tmp = args.get(PF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        pf = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + PF);
-      }
-    }
-
-        
-    tmp = args.get(MM);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        mm = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + MM);
-      }
-    }
-        
-    tmp = args.get(PS);
-    if (null != tmp) {
-      if (tmp instanceof Integer) {
-        pslop = ((Integer)tmp).intValue();
-      } else {
-        SolrCore.log.severe("init param is not an int: " + PS);
-      }
-    }
-
-    tmp = args.get(BQ);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        bq = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + BQ);
-      }
-    }
- 
-    tmp = args.get(BF);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        bf = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + BF);
-      }
-    }
- 
-    tmp = args.get(FQ);
-    if (null != tmp) {
-      if (tmp instanceof String) {
-        fq = tmp.toString();
-      } else {
-        SolrCore.log.severe("init param is not a str: " + FQ);
-      }
-    }
-                
-  }
-
-}
diff --git a/src/java/org/apache/solr/util/HighlightingUtils.java b/src/java/org/apache/solr/util/HighlightingUtils.java
index 3de90bb..8249191 100644
--- a/src/java/org/apache/solr/util/HighlightingUtils.java
+++ b/src/java/org/apache/solr/util/HighlightingUtils.java
@@ -27,6 +27,11 @@ import java.util.LinkedList;
 import java.util.ArrayList;
 import java.util.ListIterator;
 
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.*;
 import org.apache.solr.search.DocIterator;
 import org.apache.solr.search.DocList;
diff --git a/src/java/org/apache/solr/util/IteratorChain.java b/src/java/org/apache/solr/util/IteratorChain.java
deleted file mode 100644
index 3bb7cf9..0000000
--- a/src/java/org/apache/solr/util/IteratorChain.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/** Chain several Iterators, so that this iterates
- *  over all of them in sequence.
- */
-
-public class IteratorChain<E> implements Iterator<E> {
-
-  private final List<Iterator<E>> iterators = new ArrayList<Iterator<E>>();
-  private Iterator<Iterator<E>> itit;
-  private Iterator<E> current;
- 
-  public void addIterator(Iterator<E> it) {
-    if(itit!=null) throw new RuntimeException("all Iterators must be added before calling hasNext()");
-    iterators.add(it);
-  }
-  
-  public boolean hasNext() {
-    if(itit==null) itit = iterators.iterator();
-    return recursiveHasNext();
-  }
-  
-  /** test if current iterator hasNext(), and if not try the next
-   *  one in sequence, recursively
-   */
-  private boolean recursiveHasNext() {
-    // return false if we have no more iterators
-    if(current==null) {
-      if(itit.hasNext()) {
-        current=itit.next();
-      } else {
-        return false;
-      }
-    }
-    
-    boolean result = current.hasNext();
-    if(!result) {
-      current = null;
-      result = recursiveHasNext();
-    }
-    
-    return result;
-  }
-
-  /** hasNext() must ALWAYS be called before calling this
-   *  otherwise it's a bit hard to keep track of what's happening
-   */
-  public E next() {
-    if(current==null) { 
-      throw new RuntimeException("For an IteratorChain, hasNext() MUST be called before calling next()");
-    }
-    return current.next();
-  }
-
-  public void remove() {
-    // we just need this class 
-    // to iterate in readonly mode
-    throw new UnsupportedOperationException();
-  }
-  
-}
diff --git a/src/java/org/apache/solr/util/MoreLikeThisParams.java b/src/java/org/apache/solr/util/MoreLikeThisParams.java
deleted file mode 100644
index 509e197..0000000
--- a/src/java/org/apache/solr/util/MoreLikeThisParams.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.apache.solr.util;
-
-public interface MoreLikeThisParams 
-{
-  // enable more like this -- this only applies to 'StandardRequestHandler' maybe DismaxRequestHandler
-  public final static String MLT = "mlt";
-  
-  public final static String PREFIX = "mlt.";
-  
-  public final static String SIMILARITY_FIELDS     = PREFIX + "fl";
-  public final static String MIN_TERM_FREQ         = PREFIX + "mintf";
-  public final static String MIN_DOC_FREQ          = PREFIX + "mindf";
-  public final static String MIN_WORD_LEN          = PREFIX + "minwl";
-  public final static String MAX_WORD_LEN          = PREFIX + "maxwl";
-  public final static String MAX_QUERY_TERMS       = PREFIX + "maxqt";
-  public final static String MAX_NUM_TOKENS_PARSED = PREFIX + "maxntp";
-  public final static String BOOST                 = PREFIX + "boost"; // boost or not?
-
-  // the /mlt request handler uses 'rows'
-  public final static String DOC_COUNT = PREFIX + "count";
-
-  // Do you want to include the original document in the results or not
-  public final static String MATCH_INCLUDE = PREFIX + "match.include";
-  
-  // If multiple docs are matched in the query, what offset do you want?
-  public final static String MATCH_OFFSET  = PREFIX + "match.offset";
-
-  // Do you want to include the original document in the results or not
-  public final static String INTERESTING_TERMS = PREFIX + "interestingTerms";  // false,details,(list or true)
-  
-  public enum TermStyle {
-    NONE,
-    LIST,
-    DETAILS;
-    
-    public static TermStyle get( String p )
-    {
-      if( p != null ) {
-        p = p.toUpperCase();
-        if( p.equals( "DETAILS" ) ) {
-          return DETAILS;
-        }
-        else if( p.equals( "LIST" ) ) {
-          return LIST;
-        }
-      }
-      return NONE; 
-    }
-  }
-}
diff --git a/src/java/org/apache/solr/util/NamedList.java b/src/java/org/apache/solr/util/NamedList.java
deleted file mode 100644
index e93593d..0000000
--- a/src/java/org/apache/solr/util/NamedList.java
+++ /dev/null
@@ -1,263 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.*;
-import java.io.Serializable;
-
-
-/**
- * A simple container class for modeling an ordered list of name/value pairs.
- *
- * <p>
- * Unlike Maps:
- * </p>
- * <ul>
- *  <li>Names may be repeated</li>
- *  <li>Order of elements is maintained</li>
- *  <li>Elements may be accessed by numeric index</li>
- *  <li>Names and Values can both be null</li>
- * </ul>
- *
- * <p>
- * A NamedList provides fast access by element number, but not by name.
- * </p>
- * <p>
- * When a NamedList is serialized, order is considered more important than access
- * by key, so ResponseWriters that output to a format such as JSON will normally
- * choose a data structure that allows order to be easily preserved in various
- * clients (i.e. not a straight map).
- * If access by key is more important, see {@link SimpleOrderedMap},
- * or simply use a regular {@link Map}
- * </p>
- *
- * @author yonik
- * @version $Id$
- */
-public class NamedList<T> implements Cloneable, Serializable, Iterable<Map.Entry<String,T>> {
-  protected final List nvPairs;
-
-  /** Creates an empty instance */
-  public NamedList() {
-    nvPairs = new ArrayList();
-  }
-
-  /**
-   * Creates an instance backed by an explicitly specified list of
-   * pairwise names/values.
-   *
-   * @param nameValuePairs underlying List which should be used to implement a NamedList; modifying this List will affect the NamedList.
-   */
-  public NamedList(List nameValuePairs) {
-    nvPairs=nameValuePairs;
-  }
-
-  /** The total number of name/value pairs */
-  public int size() {
-    return nvPairs.size() >> 1;
-  }
-
-  /**
-   * The name of the pair at the specified List index
-   *
-   * @return null if no name exists
-   */
-  public String getName(int idx) {
-    return (String)nvPairs.get(idx << 1);
-  }
-
-  /**
-   * The value of the pair at the specified List index
-   *
-   * @return may be null
-   */
-  @SuppressWarnings("unchecked")
-  public T getVal(int idx) {
-    return (T)nvPairs.get((idx << 1) + 1);
-  }
-  
-  /**
-   * Adds a name/value pair to the end of the list.
-   */
-  public void add(String name, T val) {
-    nvPairs.add(name);
-    nvPairs.add(val);
-  }
-
-  /**
-   * Modifies the name of the pair at the specified index.
-   */
-  public void setName(int idx, String name) {
-    nvPairs.set(idx<<1, name);
-  }
-
-  /**
-   * Modifies the value of the pair at the specified index.
-   * @return the value that used to be at index
-   */
-  public T setVal(int idx, T val) {
-    int index = (idx<<1)+1;
-    T old = (T)nvPairs.get( index );
-    nvPairs.set(index, val);
-    return old;
-  }
-
-  /**
-   * Scans the list sequentially beginning at the specified index and
-   * returns the index of the first pair with the specified name.
-   *
-   * @param name name to look for, may be null
-   * @param start index to begin searching from
-   * @return The index of the first matching pair, -1 if no match
-   */
-  public int indexOf(String name, int start) {
-    int sz = size();
-    for (int i=start; i<sz; i++) {
-      String n = getName(i);
-      if (name==null) {
-        if (n==null) return i; // matched null
-      } else if (name.equals(n)) {
-        return i;
-      }
-    }
-    return -1;
-  }
-
-  /**
-   * Gets the value for the first instance of the specified name
-   * found.
-   * 
-   * @return null if not found or if the value stored was null.
-   * @see #indexOf
-   * @see #get(String,int)
-   */
-  public T get(String name) {
-    return get(name,0);
-  }
-
-  /**
-   * Gets the value for the first instance of the specified name
-   * found starting at the specified index.
-   * 
-   * @return null if not found or if the value stored was null.
-   * @see #indexOf
-   */
-  public T get(String name, int start) {
-    int sz = size();
-    for (int i=start; i<sz; i++) {
-      String n = getName(i);
-      if (name==null) {
-        if (n==null) return getVal(i);
-      } else if (name.equals(n)) {
-        return getVal(i);
-      }
-    }
-    return null;
-  }
-
-  public String toString() {
-    StringBuffer sb = new StringBuffer();
-    sb.append('{');
-    int sz = size();
-    for (int i=0; i<sz; i++) {
-      if (i != 0) sb.append(',');
-      sb.append(getName(i));
-      sb.append('=');
-      sb.append(getVal(i));
-    }
-    sb.append('}');
-
-    return sb.toString();
-  }
-
-  /**
-   * Iterates over the Map and sequentially adds it's key/value pairs
-   */
-  public boolean addAll(Map<String,T> args) {
-    for( Map.Entry<String, T> entry : args.entrySet() ) {
-      add( entry.getKey(), entry.getValue() );
-    }
-    return args.size()>0;
-  }
-
-  /** Appends the elements of the given NamedList to this one. */
-  public boolean addAll(NamedList<T> nl) {
-    nvPairs.addAll(nl.nvPairs);
-    return nl.size()>0;
-  }
-
-  /**
-   * Makes a <i>shallow copy</i> of the named list.
-   */
-  public NamedList<T> clone() {
-    ArrayList newList = new ArrayList(nvPairs.size());
-    newList.addAll(nvPairs);
-    return new NamedList<T>(newList);
-  }
-
-
-  //----------------------------------------------------------------------------
-  // Iterable interface
-  //----------------------------------------------------------------------------
-  
-  /**
-   * Support the Iterable interface
-   */
-  public Iterator<Map.Entry<String,T>> iterator() {
-    
-    final NamedList list = this;
-    
-    Iterator<Map.Entry<String,T>> iter = new Iterator<Map.Entry<String,T>>() {
-      
-      int idx = 0;
-      
-      public boolean hasNext() {
-        return idx < list.size();
-      }
-
-      public Map.Entry<String,T> next() {
-        final int index = idx++;
-        Map.Entry<String,T> nv = new Map.Entry<String,T>() {
-          public String getKey() {
-            return list.getName( index );
-          }
-
-          @SuppressWarnings("unchecked")
-		  public T getValue() {
-            return (T)list.getVal( index );
-          }
-          
-          public String toString()
-          {
-        	  return getKey()+"="+getValue();
-          }
-
-		  public T setValue(T value) {
-			return (T) list.setVal(index, value);
-		  }
-        };
-        return nv;
-      }
-
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-    return iter;
-  }
-}
diff --git a/src/java/org/apache/solr/util/SimpleOrderedMap.java b/src/java/org/apache/solr/util/SimpleOrderedMap.java
deleted file mode 100755
index 6f1d233..0000000
--- a/src/java/org/apache/solr/util/SimpleOrderedMap.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.apache.solr.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.*;
-
-/** <code>SimpleOrderedMap</code> is a {@link NamedList} where access by key is more
- * important than maintaining order when it comes to representing the
- * held data in other forms, as ResponseWriters normally do.
- * It's normally not a good idea to repeat keys or use null keys, but this
- * is not enforced.  If key uniqueness enforcement is desired, use a regular {@link Map}.
- * <p>
- * For example, a JSON response writer may choose to write a SimpleOrderedMap
- * as {"foo":10,"bar":20} and may choose to write a NamedList as
- * ["foo",10,"bar",20].  An XML response writer may choose to render both
- * the same way.
- * </p>
- * <p>
- * This class does not provide efficient lookup by key, it's main purpose is
- * to hold data to be serialized.  It aims to minimize overhead and to be
- * efficient at adding new elements.
- * </p>
- */
-public class SimpleOrderedMap<T> extends NamedList<T> {
-  /** Creates an empty instance */
-  public SimpleOrderedMap() {
-    super();
-  }
-
-  /**
-   * Creates an instance backed by an explicitly specified list of
-   * pairwise names/values.
-   *
-   * @param nameValuePairs underlying List which should be used to implement a SimpleOrderedMap; modifying this List will affect the SimpleOrderedMap.
-   */
-  public SimpleOrderedMap(List nameValuePairs) {
-    super(nameValuePairs);
-  }
-
-  public SimpleOrderedMap<T> clone() {
-    ArrayList newList = new ArrayList(nvPairs.size());
-    newList.addAll(nvPairs);
-    return new SimpleOrderedMap<T>(newList);
-  }
-}
diff --git a/src/java/org/apache/solr/util/SolrDocument.java b/src/java/org/apache/solr/util/SolrDocument.java
deleted file mode 100644
index cfae9a6..0000000
--- a/src/java/org/apache/solr/util/SolrDocument.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-
-/**
- * A concrete representation of a document within a Solr index.  Unlike a lucene
- * Document, a SolrDocument may have an Object value matching the type defined in
- * schema.xml
- * 
- * For indexing documents, use the SolrInputDocumet that contains extra information
- * for document and field boosting.
- * 
- * @author ryan
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrDocument 
-{
-  private Map<String,Collection<Object>> _fields = null;
-  
-  public SolrDocument()
-  {
-    _fields = new HashMap<String,Collection<Object>>();
-  }
-
-  /**
-   * Let sub classes return something other then a List.  
-   * Perhaps a Set or LinkedHashSet
-   */
-  protected Collection<Object> getEmptyCollection( String name )
-  {
-    return new ArrayList<Object>();
-  }
-
-  /**
-   * @return a list of fields defined in this document
-   */
-  public Collection<String> getFieldNames() {
-    return _fields.keySet();
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Add / Set / Remove Fields
-  ///////////////////////////////////////////////////////////////////
-
-  /**
-   * Remove all fields from the document
-   */
-  public void clear()
-  {
-    _fields.clear();
-  }
-  
-  
-  /**
-   * Remove all fields with the name
-   */
-  public boolean removeFields(String name) 
-  {
-    return _fields.remove( name ) != null;
-  }
-
-  /**
-   * Set a field with the given object.  If the object is an Array or Iterable, it will 
-   * set multiple fields with the included contents.  This will replace any existing 
-   * field with the given name
-   */
-  public void setField(String name, Object value) 
-  {
-    Collection<Object> existing = _fields.get( name );
-    if( existing != null ) {
-      existing.clear();
-    }
-    this.addField(name, value);
-  }
-
-  /**
-   * This will add a field to the document.  If fields already exist with this name
-   * it will append the collection
-   */
-  public void addField(String name, Object value) 
-  { 
-    Collection<Object> existing = _fields.get( name );
-    if( existing == null ) {
-      existing = getEmptyCollection(name);
-      _fields.put( name, existing );
-    }
-    
-    // Arrays are iterable?  They appear to be, but not in the docs...
-    if( value instanceof Iterable ) {
-      for( Object o : (Iterable)value ) {
-        this.addField( name, o );  
-      }
-    }
-    else if( value instanceof Object[] ) {
-      for( Object o : (Object[])value ) {
-        this.addField( name, o );  
-      }
-    }
-    else {
-      existing.add( value );
-    }
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Get the field values
-  ///////////////////////////////////////////////////////////////////
-
-  /**
-   * returns the first value for this field
-   */
-  public Object getFieldValue(String name) {
-    Collection v = _fields.get( name );
-    if( v != null && v.size() > 0 ) {
-      return v.iterator().next();
-    }
-    return null;
-  }
-
-  /**
-   * Get a collection or all the values for a given field name
-   */
-  public Collection<Object> getFieldValues(String name) {
-    return _fields.get( name );
-  }
-  
-// TODO? should this be in the API?
-//  /**
-//   * Return a named list version
-//   */
-//  public NamedList<Object> toNamedList()
-//  {
-//    NamedList<Object> nl = new NamedList<Object>();
-//    for( Map.Entry<String, Collection<Object>> entry : _fields.entrySet() ) {
-//      Collection<Object> v = entry.getValue();
-//      if( v.size() == 0 ) {
-//        nl.add( entry.getKey(), null );
-//      }
-//      else if( v.size() > 1 ) {
-//        nl.add( entry.getKey(), v );
-//      }
-//      else { // Add a single value
-//        nl.add( entry.getKey(), v.iterator().next() );
-//      }
-//    }
-//    return nl;
-//  }
-  
-  @Override
-  public String toString()
-  {
-    return "SolrDocument["+getFieldNames()+"]";
-  }
-  
-  /**
-   * Expose a Map interface to the solr field value collection.
-   */
-  public Map<String,Collection<Object>> getFieldValuesMap()
-  {
-    return _fields;
-  }
-
-  /**
-   * Expose a Map interface to the solr fields.  This function is useful for JSTL
-   */
-  public Map<String,Object> getFieldValueMap() {
-    return new Map<String,Object>() {
-      /** Get the field Value */
-      public Object get(Object key) { 
-        return getFieldValue( (String)key ); 
-      }
-      
-      /** Set the field Value */
-      public Object put(String key, Object value) {
-        setField( key, value );
-        return null;
-      }
-
-      /** Remove the field Value */
-      public Object remove(Object key) {
-        removeFields( (String)key ); 
-        return null;
-      }
-      
-      // Easily Supported methods
-      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
-      public Set<String>  keySet()           { return _fields.keySet();  }
-      public int          size()             { return _fields.size();    }
-      public boolean      isEmpty()          { return _fields.isEmpty(); }
-
-      // Unsupported operations.  These are not necessary for JSTL
-      public void clear() { throw new UnsupportedOperationException(); }
-      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
-      public Set<java.util.Map.Entry<String, Object>> entrySet() {throw new UnsupportedOperationException();}
-      public void putAll(Map<? extends String, ? extends Object> t) {throw new UnsupportedOperationException();}
-      public Collection<Object> values() {throw new UnsupportedOperationException();}
-    };
-  }
-}
diff --git a/src/java/org/apache/solr/util/SolrInputDocument.java b/src/java/org/apache/solr/util/SolrInputDocument.java
deleted file mode 100644
index a1ae28f..0000000
--- a/src/java/org/apache/solr/util/SolrInputDocument.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Represent the field and boost information needed to construct and index
- * a Lucene Document.  Like the SolrDocument, the field values need to
- * match those specified in schema.xml 
- * 
- * @author ryan
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrInputDocument extends SolrDocument
-{
-  private Map<String,Float> _boost = null;
-
-  /**
-   * Remove all fields and boosts from the document
-   */
-  @Override
-  public void clear()
-  {
-    super.clear();
-    if( _boost != null ) {
-      _boost.clear();
-    }
-  }
-  
-  /**
-   * Set the document boost.  null will remove the boost
-   */
-  public void setDocumentBoost( Float v )
-  {
-    this.setBoost( null, v );
-  }
-  
-  /**
-   * @return the document boost.  or null if not set
-   */
-  public Float getDocumentBoost()
-  {
-    return this.getBoost( null );
-  }
-  
-  /**
-   * Get the lucene document boost for a field.  Passing in <code>null</code> returns the
-   * document boost, not a field boost.  
-   */
-  public void setBoost(String name, Float boost) {
-    if( _boost == null ) {
-      _boost = new HashMap<String, Float>();
-    }
-    if( boost == null ) {
-      _boost.remove( name );
-    }
-    else {
-      _boost.put( name, boost );
-    }
-  }
-
-  /**
-   * Set the field boost.  All fields with the name will have the same boost.  
-   * Passing in <code>null</code> sets the document boost.
-   * @param boost
-   */
-  public Float getBoost(String name) {
-    if( _boost == null ) {
-      return null;
-    }
-    return _boost.get( name );
-  }
-}
diff --git a/src/java/org/apache/solr/util/SolrPluginUtils.java b/src/java/org/apache/solr/util/SolrPluginUtils.java
index 506b151..1279f7a 100644
--- a/src/java/org/apache/solr/util/SolrPluginUtils.java
+++ b/src/java/org/apache/solr/util/SolrPluginUtils.java
@@ -23,13 +23,16 @@ import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.AppendedSolrParams;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.request.DefaultSolrParams;
-import org.apache.solr.request.AppendedSolrParams;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.*;
diff --git a/src/java/org/apache/solr/util/TestHarness.java b/src/java/org/apache/solr/util/TestHarness.java
index e4b7fbb..d8f3a7e 100644
--- a/src/java/org/apache/solr/util/TestHarness.java
+++ b/src/java/org/apache/solr/util/TestHarness.java
@@ -17,6 +17,8 @@
 
 package org.apache.solr.util;
 
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
diff --git a/src/java/org/apache/solr/util/UpdateParams.java b/src/java/org/apache/solr/util/UpdateParams.java
deleted file mode 100644
index 5f639e5..0000000
--- a/src/java/org/apache/solr/util/UpdateParams.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-/**
- * A collection of standard params used by Update handlers
- *
- * @author ryan
- * @version $Id$
- * @since solr 1.2
- */
-public interface UpdateParams 
-{
-  /** wait till the command has flushed */
-  public static String WAIT_FLUSH = "waitFlush";
-  
-  /** wait for the search to warm up */
-  public static String WAIT_SEARCHER = "waitSearcher";
-  
-  /** overwrite indexing fields */
-  public static String OVERWRITE = "overwrite";
-  
-  /** Commit everything after the command completes */
-  public static String COMMIT = "commit";
-  
-  /** Commit everything after the command completes */
-  public static String OPTIMIZE = "optimize";
-}
diff --git a/src/java/org/apache/solr/util/XML.java b/src/java/org/apache/solr/util/XML.java
deleted file mode 100644
index a533a5a..0000000
--- a/src/java/org/apache/solr/util/XML.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.io.Writer;
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id$
- */
-public class XML {
-
-  //
-  // copied from some of my personal code...  -YCS
-  // table created from python script.
-  // only have to escape quotes in attribute values, and don't really have to escape '>'
-  // many chars less than 0x20 are *not* valid XML, even when escaped!
-  // for example, <foo>&#0;<foo> is invalid XML.
-  private static final String[] chardata_escapes=
-  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,null,null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;",null,"&gt;"};
-
-  private static final String[] attribute_escapes=
-  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,"&quot;",null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;"};
-
-
-
-  /*****************************************
-   #Simple python script used to generate the escape table above.  -YCS
-   #
-   #use individual char arrays or one big char array for better efficiency
-   # or byte array?
-   #other={'&':'amp', '<':'lt', '>':'gt', "'":'apos', '"':'quot'}
-   #
-   other={'&':'amp', '<':'lt'}
-
-   maxi=ord(max(other.keys()))+1
-   table=[None] * maxi
-   #NOTE: invalid XML chars are "escaped" as #nn; *not* &#nn; because
-   #a real XML escape would cause many strict XML parsers to choke.
-   for i in range(0x20): table[i]='#%d;' % i
-   for i in '\n\r\t ': table[ord(i)]=None
-   for k,v in other.items():
-    table[ord(k)]='&%s;' % v
-
-   result=""
-   for i in range(maxi):
-     val=table[i]
-     if not val: val='null'
-     else: val='"%s"' % val
-     result += val + ','
-
-   print result
-   ****************************************/
-
-
-/*********
- *
- * @param str
- * @param out
- * @throws IOException
- */
-  public static void escapeCharData(String str, Writer out) throws IOException {
-    escape(str, out, chardata_escapes);
-  }
-
-  public static void escapeAttributeValue(String str, Writer out) throws IOException {
-    escape(str, out, attribute_escapes);
-  }
-
-
-  public final static void writeXML(Writer out, String tag, String val) throws IOException {
-    out.write('<');
-    out.write(tag);
-    if (val == null) {
-      out.write("/>");
-    } else {
-      out.write('>');
-      escapeCharData(val,out);
-      out.write("</");
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-  /** does NOT escape character data in val, must already be valid XML */
-  public final static void writeUnescapedXML(Writer out, String tag, String val, Object... attrs) throws IOException {
-    out.write('<');
-    out.write(tag);
-    for (int i=0; i<attrs.length; i++) {
-      out.write(' ');
-      out.write(attrs[i++].toString());
-      out.write("=\"");
-      out.write(attrs[i].toString());
-      out.write("\"");
-    }
-    if (val == null) {
-      out.write("/>");
-    } else {
-      out.write('>');
-      out.write(val);
-      out.write("</");
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-  /** escapes character data in val */
-  public final static void writeXML(Writer out, String tag, String val, Object... attrs) throws IOException {
-    out.write('<');
-    out.write(tag);
-    for (int i=0; i<attrs.length; i++) {
-      out.write(' ');
-      out.write(attrs[i++].toString());
-      out.write("=\"");
-      escapeAttributeValue(attrs[i].toString(), out);
-      out.write("\"");
-    }
-    if (val == null) {
-      out.write("/>");
-    } else {
-      out.write('>');
-      escapeCharData(val,out);
-      out.write("</");
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-
-  private static void escape(String str, Writer out, String[] escapes) throws IOException {
-    int start=0;
-    // "n" was used for counting the chars added to out...
-    // removed cause it wasn't really useful so far.
-    // int n=0;
-
-    for (int i=start; i<str.length(); i++) {
-      char ch = str.charAt(i);
-      // since I already received the char, what if I put it into
-      // a char array and wrote that to the stream instead of the
-      // string? (would cause extra GC though)
-      String subst=null;
-      if (ch<escapes.length) {
-        subst=escapes[ch];
-      }
-      if (subst != null) {
-        if (start<i) {
-          out.write(str.substring(start,i));
-          // write(str,off,len) causes problems for Jetty with chars > 127
-          //out.write(str, start, i-start);
-          // n+=i-start;
-        }
-        out.write(subst);
-        // n+=subst.length();
-        start=i+1;
-      }
-    }
-    if (start==0) {
-      out.write(str);
-      // n += str.length();
-    } else if (start<str.length()) {
-      out.write(str.substring(start));
-      // write(str,off,len) causes problems for Jetty with chars > 127
-      // out.write(str, start, str.length()-start);
-      // n += str.length()-start;
-    }
-    // return n;
-  }
-}
diff --git a/src/test/org/apache/solr/BasicFunctionalityTest.java b/src/test/org/apache/solr/BasicFunctionalityTest.java
index 962ef96..fac438b 100644
--- a/src/test/org/apache/solr/BasicFunctionalityTest.java
+++ b/src/test/org/apache/solr/BasicFunctionalityTest.java
@@ -20,6 +20,11 @@ package org.apache.solr;
 import org.apache.lucene.document.*;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.BooleanQuery;
+import org.apache.solr.common.params.AppendedSolrParams;
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.search.*;
 import org.apache.solr.handler.*;
diff --git a/src/test/org/apache/solr/EchoParamsTest.java b/src/test/org/apache/solr/EchoParamsTest.java
index c678da7..3648aaa 100644
--- a/src/test/org/apache/solr/EchoParamsTest.java
+++ b/src/test/org/apache/solr/EchoParamsTest.java
@@ -61,7 +61,7 @@ public class EchoParamsTest extends AbstractSolrTestCase {
        );
 
     assertQ(req("foo"),HEADER_XPATH + "/lst[@name='params']/str[@name='fl'][.='implicit']");
-    assertQ(req("foo"),HEADER_XPATH + "/str[@name='handler'][.='org.apache.solr.request.StandardRequestHandler']");
+    assertQ(req("foo"),HEADER_XPATH + "/str[@name='handler'][.='org.apache.solr.handler.StandardRequestHandler']");
   }
 
 }
diff --git a/src/test/org/apache/solr/OutputWriterTest.java b/src/test/org/apache/solr/OutputWriterTest.java
index c94a8ee..7ef6e47 100644
--- a/src/test/org/apache/solr/OutputWriterTest.java
+++ b/src/test/org/apache/solr/OutputWriterTest.java
@@ -19,11 +19,12 @@ package org.apache.solr;
 
 import java.io.IOException;
 import java.io.Writer;
+
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.TestHarness;
 
 /** Tests the ability to configure multiple query output writers, and select those
diff --git a/src/test/org/apache/solr/common/SolrDocumentTest.java b/src/test/org/apache/solr/common/SolrDocumentTest.java
new file mode 100644
index 0000000..f9f1d18
--- /dev/null
+++ b/src/test/org/apache/solr/common/SolrDocumentTest.java
@@ -0,0 +1,127 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+
+import junit.framework.TestCase;
+
+/**
+ * @author ryan
+ */
+public class SolrDocumentTest extends TestCase 
+{
+  public void testSimple() 
+  {
+    Float fval = new Float( 10.01f );
+    Boolean bval = Boolean.TRUE;
+    String sval = "12qwaszx";
+    
+    // Set up a simple document
+    SolrDocument doc = new SolrDocument();
+    doc.addField( "f", fval );
+    doc.addField( "b", bval );
+    doc.addField( "s", sval );
+    doc.addField( "f", 100 ); // again, but something else
+
+    // make sure we can pull values out of it
+    assertEquals( fval, doc.getFieldValue( "f" ) );
+    assertEquals( bval, doc.getFieldValue( "b" ) );
+    assertEquals( sval, doc.getFieldValue( "s" ) );
+    assertEquals( 2, doc.getFieldValues( "f" ).size() );
+    assertNull( doc.getFieldValue( "xxxxx" ) );
+    assertNull( doc.getFieldValues( "xxxxx" ) );
+    
+    List<String> keys = new ArrayList<String>();
+    for( String s : doc.getFieldNames() ) {
+      keys.add( s );
+    }
+    Collections.sort( keys );
+    assertEquals( 3, keys.size() );
+    assertEquals( "[b, f, s]", keys.toString() );
+    
+    // set field replaced existing values:
+    doc.setField( "f", fval );
+    assertEquals( 1, doc.getFieldValues( "f" ).size() );
+    assertEquals( fval, doc.getFieldValue( "f" ) );
+    
+    doc.setField( "n", null );
+    assertEquals( null, doc.getFieldValue( "n" ) );
+    
+    // now remove some fields
+    assertEquals( true, doc.removeFields( "f" ) );
+    assertEquals( false, doc.removeFields( "asdgsadgas" ) );
+    assertNull( doc.getFieldValue( "f" ) );
+    assertNull( doc.getFieldValues( "f" ) );
+  }
+  
+  public void testDocumentBoosts()
+  {
+    SolrInputDocument doc = new SolrInputDocument();
+    assertEquals( null, doc.getBoost( "aaa" ) );
+    doc.setBoost( "aaa", 10.0f );
+    assertEquals( 10.0f, doc.getBoost( "aaa" ) );
+    doc.setBoost( "aaa", null );
+    assertEquals( null, doc.getBoost( "aaa" ) );
+  }
+  
+  public void testUnsupportedStuff()
+  {
+    SolrDocument doc = new SolrDocument();
+
+    try { doc.getFieldValueMap().clear();               fail( "should be unsupported!" ); } catch( Exception ex ){}
+    try { doc.getFieldValueMap().containsValue( null ); fail( "should be unsupported!" ); } catch( Exception ex ){}
+    try { doc.getFieldValueMap().entrySet();            fail( "should be unsupported!" ); } catch( Exception ex ){}
+    try { doc.getFieldValueMap().putAll( null );        fail( "should be unsupported!" ); } catch( Exception ex ){}
+    try { doc.getFieldValueMap().values();              fail( "should be unsupported!" ); } catch( Exception ex ){}
+
+    assertEquals( null, doc.getFieldValueMap().get( "aaa" ) );
+    doc.setField( "aaa", "bbb" );
+    assertEquals( "bbb", doc.getFieldValueMap().get( "aaa" ) );
+    doc.getFieldValueMap().remove( "aaa" );
+    assertEquals( null, doc.getFieldValueMap().get( "aaa" ) );
+  }
+  
+  public void testAddCollections()
+  {
+    List<String> c0 = new ArrayList<String>();
+    c0.add( "aaa" );
+    c0.add( "aaa" );
+    c0.add( "aaa" );
+    c0.add( "bbb" );
+    c0.add( "ccc" );
+    
+    SolrDocument doc = new SolrDocument();
+    doc.addField( "v", c0 );
+    assertEquals( c0.size(), doc.getFieldValues("v").size() );
+    
+    // Same thing with an array
+    Object[] arr = new Object[] { "aaa", "aaa", "aaa", 10, 'b' };
+    doc = new SolrDocument();
+    doc.addField( "v", c0 );
+    assertEquals( arr.length, doc.getFieldValues("v").size() );
+  }
+}
+
+
+
diff --git a/src/test/org/apache/solr/common/params/SolrParamTest.java b/src/test/org/apache/solr/common/params/SolrParamTest.java
new file mode 100755
index 0000000..9b8f994
--- /dev/null
+++ b/src/test/org/apache/solr/common/params/SolrParamTest.java
@@ -0,0 +1,186 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import junit.framework.TestCase;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+
+/**
+ * @author ryan
+ */
+public class SolrParamTest extends TestCase 
+{  
+  public void testGetParams() {
+    Map<String,String> pmap = new HashMap<String, String>();
+    pmap.put( "str"        , "string"   );
+    pmap.put( "bool"       , "true"     );
+    pmap.put( "true-0"     , "true"     );
+    pmap.put( "true-1"     , "yes"      );
+    pmap.put( "true-2"     , "on"       );
+    pmap.put( "false-0"    , "false"    );
+    pmap.put( "false-1"    , "off"      );
+    pmap.put( "false-2"    , "no"       );
+    pmap.put( "int"        , "100"      );
+    pmap.put( "float"      , "10.6"     );
+    pmap.put( "f.fl.str"   , "string"   );
+    pmap.put( "f.fl.bool"  , "true"     );
+    pmap.put( "f.fl.int"   , "100"      );
+    pmap.put( "f.fl.float" , "10.6"     );
+    pmap.put( "f.bad.bool" , "notbool"  );
+    pmap.put( "f.bad.int"  , "notint"   );
+    pmap.put( "f.bad.float", "notfloat" );
+    final SolrParams params = new MapSolrParams( pmap );
+    
+    // Test the string values we put in directly
+    assertEquals(  "string"   , params.get( "str"       ) );
+    assertEquals(  "true"     , params.get( "bool"      ) );
+    assertEquals(  "100"      , params.get( "int"       ) );
+    assertEquals(  "10.6"     , params.get( "float"     ) );
+    assertEquals(  "string"   , params.get( "f.fl.str"    ) );
+    assertEquals(  "true"     , params.get( "f.fl.bool"   ) );
+    assertEquals(  "100"      , params.get( "f.fl.int"    ) );
+    assertEquals(  "10.6"     , params.get( "f.fl.float"  ) );
+    assertEquals(  "notbool"  , params.get( "f.bad.bool"  ) );
+    assertEquals(  "notint"   , params.get( "f.bad.int"   ) );
+    assertEquals(  "notfloat" , params.get( "f.bad.float" ) );
+    
+    final String  pstr = "string";
+    final Boolean pbool = Boolean.TRUE;
+    final Integer pint = new Integer( 100 );
+    final Float   pfloat = new Float( 10.6f );
+    
+    // Make sure they parse ok
+    assertEquals( pstr   , params.get(      "str"      ) );
+    assertEquals( pbool  , params.getBool(  "bool"     ) );
+    assertEquals( pint   , params.getInt(   "int"      ) );
+    assertEquals( pfloat , params.getFloat( "float"    ) );
+    assertEquals( pbool  , params.getBool(  "f.fl.bool"  ) );
+    assertEquals( pint   , params.getInt(   "f.fl.int"   ) );
+    assertEquals( pfloat , params.getFloat( "f.fl.float" ) );
+    assertEquals( pstr   , params.getFieldParam( "fl", "str"  ) );
+    assertEquals( pbool  , params.getFieldBool(  "fl", "bool" ) );
+    assertEquals( pint   , params.getFieldInt(   "fl", "int"  ) );
+    assertEquals( pfloat , params.getFieldFloat( "fl", "float" ) );
+    
+    // Test field defaulting (fall through to non-field-specific value)
+    assertEquals( pint   , params.getFieldInt( "fff",  "int"      ) );
+    
+    // test boolean parsing
+    for( int i=0; i<3; i++ ) {
+      // Must use Boolean rather than boolean reference value to prevent
+      // auto-unboxing ambiguity
+      assertEquals( Boolean.TRUE,  params.getBool( "true-"+i  ) );
+      assertEquals( Boolean.FALSE, params.getBool( "false-"+i ) );
+    }
+    
+    // Malformed params: These should throw a 400
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getInt(   "f.bad.int" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getBool(  "f.bad.bool" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFloat( "f.bad.float" ); } } ) );
+    
+    // Ask for params that arent there
+    assertNull( params.get( "asagdsaga" ) );
+    assertNull( params.getBool( "asagdsaga" ) );
+    assertNull( params.getInt( "asagdsaga" ) );
+    assertNull( params.getFloat( "asagdsaga" ) );
+    
+    // Get things with defaults
+    assertEquals( pstr                  , params.get(          "xxx", pstr   ) );
+    assertEquals( pbool.booleanValue()  , params.getBool(      "xxx", pbool   ) );
+    assertEquals( pint.intValue()       , params.getInt(       "xxx", pint   ) );
+    assertEquals( pfloat.floatValue()   , params.getFloat(     "xxx", pfloat  ) );
+    assertEquals( pbool.booleanValue()  , params.getFieldBool( "xxx", "bool", pbool ) );
+    assertEquals( pint.intValue()       , params.getFieldInt(  "xxx", "int", pint  ) );
+    assertEquals( pfloat.floatValue()   , params.getFieldFloat("xxx", "float", pfloat  ) );
+    assertEquals( pstr                  , params.getFieldParam("xxx", "str", pstr  ) );
+
+    // Required params testing uses decorator
+    final SolrParams required = params.required();
+    
+    // Required params which are present should test same as above
+    assertEquals( pstr   , required.get(      "str"      ) );
+    assertEquals( pbool  , required.getBool(  "bool"     ) );
+    assertEquals( pint   , required.getInt(   "int"      ) );
+    assertEquals( pfloat , required.getFloat( "float"    ) );
+    
+    // field value present
+    assertEquals( pbool  , required.getFieldBool(  "fl", "bool" ) );
+    // field defaulting (fall through to non-field-specific value)
+    //assertEquals( pint   , required.getFieldInt( "fff",  "int"      ) );
+    
+    // Required params which are missing: These should throw a 400
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.get( "aaaa" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getInt(   "f.bad.int" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getBool(  "f.bad.bool" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getFloat( "f.bad.float" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getInt(   "aaa" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getBool(  "aaa" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getFloat( "aaa" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFieldBool(  "bad", "bool" ); } } ) );
+    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFieldInt(   "bad", "int"  ); } } ) );
+
+    // Fields with default use their parent value:
+    assertEquals(
+        params.get(   "aaaa", "str" ), 
+        required.get( "aaaa", "str" ) );
+    assertEquals(
+        params.getInt(   "f.bad.nnnn", pint ), 
+        required.getInt( "f.bad.nnnn", pint ) );
+    
+    // Check default SolrParams
+    Map<String,String> dmap = new HashMap<String, String>();
+    // these are not defined in params
+    dmap.put( "dstr"               , "default"   );
+    dmap.put( "dint"               , "123"       );
+    // these are defined in params
+    dmap.put( "int"                , "456"       );
+    SolrParams defaults = new DefaultSolrParams( params, new MapSolrParams( dmap ) );
+  
+    // in params, not in default
+    assertEquals( pstr                  , defaults.get( "str"      ) );
+    // in default, not in params
+    assertEquals( "default"             , defaults.get( "dstr"      ) );
+    assertEquals( new Integer(123)      , defaults.getInt(  "dint"     ) );
+    // in params, overriding defaults
+    assertEquals( pint                  , defaults.getInt(   "int"      ) );
+    // in neither params nor defaults
+    assertNull( defaults.get( "asagdsaga" ) );
+  }
+  
+  public static int getReturnCode( Runnable runnable )
+  {
+    try {
+      runnable.run();
+    }
+    catch( SolrException sx ) {
+      return sx.code();
+    }
+    catch( Exception ex ) {
+      ex.printStackTrace();
+      return 500;
+    }
+    return 200;
+  }
+}
diff --git a/src/test/org/apache/solr/common/util/ContentStreamTest.java b/src/test/org/apache/solr/common/util/ContentStreamTest.java
new file mode 100755
index 0000000..4f52d3a
--- /dev/null
+++ b/src/test/org/apache/solr/common/util/ContentStreamTest.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.StringReader;
+import java.net.URL;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.solr.common.util.ContentStreamBase;
+
+import junit.framework.TestCase;
+
+/**
+ * @author ryan
+ */
+public class ContentStreamTest extends TestCase 
+{  
+  public void testStringStream() throws IOException 
+  {
+    String input = "aads ghaskdgasgldj asl sadg ajdsg &jag # @ hjsakg hsakdg hjkas s";
+    ContentStreamBase stream = new ContentStreamBase.StringStream( input );
+    assertEquals( input.length(), stream.getSize().intValue() );
+    assertEquals( input, IOUtils.toString( stream.getStream() ) );
+    assertEquals( input, IOUtils.toString( stream.getReader() ) );
+  }
+
+  public void testFileStream() throws IOException 
+  {
+    File file = new File( "README" );
+    assertTrue( file.exists() ); // "make sure you are running from: solr\src\test\test-files"
+    
+    ContentStreamBase stream = new ContentStreamBase.FileStream( file );
+    assertEquals( file.length(), stream.getSize().intValue() );
+    assertTrue( IOUtils.contentEquals( new FileInputStream( file ), stream.getStream() ) );
+    assertTrue( IOUtils.contentEquals( new FileReader(      file ), stream.getReader() ) );
+  }
+  
+
+  public void testURLStream() throws IOException 
+  {
+    String content = null;
+    URL url = new URL( "http://svn.apache.org/repos/asf/lucene/solr/trunk/" );
+    InputStream in = url.openStream();
+    try {
+      content = IOUtils.toString( in );
+    } 
+    finally {
+      IOUtils.closeQuietly(in);
+    }
+    
+    assertTrue( content.length() > 10 ); // found something...
+    
+    ContentStreamBase stream = new ContentStreamBase.URLStream( url );
+    assertEquals( content.length(), stream.getSize().intValue() );
+    
+    // Test the stream
+    in = stream.getStream();
+    try {
+      assertTrue( IOUtils.contentEquals( 
+          new ByteArrayInputStream( content.getBytes() ), in ) );
+    } 
+    finally {
+      IOUtils.closeQuietly(in);
+    }
+
+    // Re-open the stream and this time use a reader
+    stream = new ContentStreamBase.URLStream( url );
+    assertTrue( IOUtils.contentEquals( new StringReader( content ), stream.getReader() ) );
+  }
+}
diff --git a/src/test/org/apache/solr/common/util/IteratorChainTest.java b/src/test/org/apache/solr/common/util/IteratorChainTest.java
new file mode 100644
index 0000000..d6708cc
--- /dev/null
+++ b/src/test/org/apache/solr/common/util/IteratorChainTest.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.solr.common.util.IteratorChain;
+
+import junit.framework.TestCase;
+
+public class IteratorChainTest extends TestCase {
+  
+  private Iterator<String> makeIterator(String marker,int howMany) {
+    final List<String> c = new ArrayList<String>();
+    for(int i = 1; i <= howMany; i++) {
+      c.add(marker + i);
+    }
+    return c.iterator();
+  }
+  
+  public void testNoIterator() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    assertFalse("Empty IteratorChain.hastNext() is false",c.hasNext());
+    assertEquals("",getString(c));
+  }
+  
+  public void testCallNextTooEarly() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(makeIterator("a",3));
+    try {
+      c.next();
+      fail("Calling next() before hasNext() should throw RuntimeException");
+    } catch(RuntimeException asExpected) {
+      // we're fine
+    }
+  }
+  
+  public void testCallAddTooLate() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.hasNext();
+    try {
+      c.addIterator(makeIterator("a",3));
+      fail("Calling addIterator after hasNext() should throw RuntimeException");
+    } catch(RuntimeException asExpected) {
+      // we're fine
+    }
+  }
+  
+  public void testRemove() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    try {
+      c.remove();
+      fail("Calling remove should throw UnsupportedOperationException");
+    } catch(UnsupportedOperationException asExpected) {
+      // we're fine
+    }
+  }
+  
+  public void testOneIterator() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(makeIterator("a",3));
+    assertEquals("a1a2a3",getString(c));
+  }
+  
+  public void testTwoIterators() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(makeIterator("a",3));
+    c.addIterator(makeIterator("b",2));
+    assertEquals("a1a2a3b1b2",getString(c));
+  }
+  
+  public void testEmptyIteratorsInTheMiddle() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(makeIterator("a",3));
+    c.addIterator(makeIterator("b",0));
+    c.addIterator(makeIterator("c",1));
+    assertEquals("a1a2a3c1",getString(c));
+  }
+  
+  /** dump the contents of it to a String */
+  private String getString(Iterator<String> it) {
+    final StringBuffer sb = new StringBuffer();
+    sb.append("");
+    while(it.hasNext()) {
+      sb.append(it.next());
+    }
+    return sb.toString();
+  }
+}
diff --git a/src/test/org/apache/solr/common/util/TestXMLEscaping.java b/src/test/org/apache/solr/common/util/TestXMLEscaping.java
new file mode 100644
index 0000000..5787e1e
--- /dev/null
+++ b/src/test/org/apache/solr/common/util/TestXMLEscaping.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import junit.framework.TestCase;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.Random;
+import java.util.BitSet;
+
+import org.apache.solr.common.util.XML;
+
+/** Test (some of the) character escaping functions of the XML class
+ *  $Id$
+ */
+
+public class TestXMLEscaping extends TestCase {
+  private void doSimpleTest(String input,String expectedOutput) throws IOException {
+    final StringWriter sw = new StringWriter();
+    XML.escapeCharData(input, sw);
+    final String result = sw.toString();
+    assertEquals("Escaped output matches '" + expectedOutput + "'",result,expectedOutput);
+  }
+  
+  public void testNoEscape() throws IOException {
+    doSimpleTest("Bonnie","Bonnie");
+  }
+  
+  public void testAmpAscii() throws IOException {
+    doSimpleTest("Bonnie & Clyde","Bonnie &amp; Clyde");
+  }
+
+  public void testAmpAndTagAscii() throws IOException {
+    doSimpleTest("Bonnie & Cl<em>y</em>de","Bonnie &amp; Cl&lt;em&gt;y&lt;/em&gt;de");
+  }
+
+  public void testAmpWithAccents() throws IOException {
+    // 00e9 is unicode eacute
+    doSimpleTest("Les \u00e9v\u00e9nements chez Bonnie & Clyde","Les \u00e9v\u00e9nements chez Bonnie &amp; Clyde");
+  }
+
+  public void testAmpDotWithAccents() throws IOException {
+    // 00e9 is unicode eacute
+    doSimpleTest("Les \u00e9v\u00e9nements chez Bonnie & Clyde.","Les \u00e9v\u00e9nements chez Bonnie &amp; Clyde.");
+  }
+
+  public void testAmpAndTagWithAccents() throws IOException {
+    // 00e9 is unicode eacute
+    doSimpleTest("Les \u00e9v\u00e9nements <chez/> Bonnie & Clyde","Les \u00e9v\u00e9nements &lt;chez/&gt; Bonnie &amp; Clyde");
+  }
+
+  public void testGt() throws IOException {
+    doSimpleTest("a ]]> b","a ]]&gt; b");
+  }
+}
+
+
+
diff --git a/src/test/org/apache/solr/core/RequestHandlersTest.java b/src/test/org/apache/solr/core/RequestHandlersTest.java
index ccce407..96c4814 100755
--- a/src/test/org/apache/solr/core/RequestHandlersTest.java
+++ b/src/test/org/apache/solr/core/RequestHandlersTest.java
@@ -17,8 +17,8 @@
 
 package org.apache.solr.core;
 
+import org.apache.solr.handler.StandardRequestHandler;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.StandardRequestHandler;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 public class RequestHandlersTest extends AbstractSolrTestCase {
diff --git a/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java b/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
index 9fc8fa0..0b5aff1 100644
--- a/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
+++ b/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
@@ -21,14 +21,14 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.solr.common.params.MultiMapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.request.MultiMapSolrParams;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequestBase;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.util.ContentStreamBase;
 
 
 /**
diff --git a/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java b/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
index b1f9c2f..e713262 100644
--- a/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
+++ b/src/test/org/apache/solr/handler/StandardRequestHandlerTest.java
@@ -20,10 +20,10 @@ package org.apache.solr.handler;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.MapSolrParams;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.util.AbstractSolrTestCase;
 
diff --git a/src/test/org/apache/solr/handler/TestCSVLoader.java b/src/test/org/apache/solr/handler/TestCSVLoader.java
index 01426ed..42fbe4f 100755
--- a/src/test/org/apache/solr/handler/TestCSVLoader.java
+++ b/src/test/org/apache/solr/handler/TestCSVLoader.java
@@ -18,11 +18,11 @@
 package org.apache.solr.handler;
 
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.util.ContentStreamBase;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
 
 import java.io.*;
 import java.util.List;
diff --git a/src/test/org/apache/solr/handler/admin/SystemInfoHandlerTest.java b/src/test/org/apache/solr/handler/admin/SystemInfoHandlerTest.java
index 3a827e1..9bab324 100644
--- a/src/test/org/apache/solr/handler/admin/SystemInfoHandlerTest.java
+++ b/src/test/org/apache/solr/handler/admin/SystemInfoHandlerTest.java
@@ -22,7 +22,7 @@ import java.lang.management.OperatingSystemMXBean;
 
 import junit.framework.TestCase;
 
-import org.apache.solr.util.SimpleOrderedMap;
+import org.apache.solr.common.util.SimpleOrderedMap;
 
 
 public class SystemInfoHandlerTest extends TestCase {
diff --git a/src/test/org/apache/solr/schema/IndexSchemaTest.java b/src/test/org/apache/solr/schema/IndexSchemaTest.java
index ddb1b24..8b9fd25 100644
--- a/src/test/org/apache/solr/schema/IndexSchemaTest.java
+++ b/src/test/org/apache/solr/schema/IndexSchemaTest.java
@@ -20,10 +20,10 @@ package org.apache.solr.schema;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.MapSolrParams;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.util.AbstractSolrTestCase;
 
diff --git a/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java b/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
index 688d692..3a12036 100644
--- a/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
+++ b/src/test/org/apache/solr/servlet/DirectSolrConnectionTest.java
@@ -17,7 +17,7 @@
 
 package org.apache.solr.servlet;
 
-import org.apache.solr.request.SolrParams;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 
diff --git a/src/test/org/apache/solr/servlet/SolrRequestParserTest.java b/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
index d6fe9fc..c22af0b 100644
--- a/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
+++ b/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
@@ -31,12 +31,12 @@ import java.util.Map;
 import javax.servlet.http.HttpServletRequest;
 
 import org.apache.commons.io.IOUtils;
+import org.apache.solr.common.params.MultiMapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.request.MultiMapSolrParams;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.ContentStream;
 
 public class SolrRequestParserTest extends AbstractSolrTestCase {
 
diff --git a/src/test/org/apache/solr/update/AutoCommitTest.java b/src/test/org/apache/solr/update/AutoCommitTest.java
index 14acd05..0d6a1d5 100644
--- a/src/test/org/apache/solr/update/AutoCommitTest.java
+++ b/src/test/org/apache/solr/update/AutoCommitTest.java
@@ -21,14 +21,14 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.request.MapSolrParams;
 import org.apache.solr.request.SolrQueryRequestBase;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.ContentStreamBase;
 
 /**
  * 
diff --git a/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java b/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java
index 1935d8c..8ef7956 100644
--- a/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java
+++ b/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java
@@ -28,14 +28,14 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Field.Index;
 import org.apache.lucene.document.Field.Store;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
-import org.apache.solr.request.MapSolrParams;
 import org.apache.solr.request.SolrQueryRequestBase;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
-import org.apache.solr.util.ContentStream;
 
 /**
  * 
diff --git a/src/test/org/apache/solr/util/ContentStreamTest.java b/src/test/org/apache/solr/util/ContentStreamTest.java
deleted file mode 100755
index e106daf..0000000
--- a/src/test/org/apache/solr/util/ContentStreamTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.StringReader;
-import java.net.URL;
-
-import org.apache.commons.io.IOUtils;
-
-import junit.framework.TestCase;
-
-/**
- * @author ryan
- */
-public class ContentStreamTest extends TestCase 
-{  
-  public void testStringStream() throws IOException 
-  {
-    String input = "aads ghaskdgasgldj asl sadg ajdsg &jag # @ hjsakg hsakdg hjkas s";
-    ContentStreamBase stream = new ContentStreamBase.StringStream( input );
-    assertEquals( input.length(), stream.getSize().intValue() );
-    assertEquals( input, IOUtils.toString( stream.getStream() ) );
-    assertEquals( input, IOUtils.toString( stream.getReader() ) );
-  }
-
-  public void testFileStream() throws IOException 
-  {
-    File file = new File( "README" );
-    assertTrue( file.exists() ); // "make sure you are running from: solr\src\test\test-files"
-    
-    ContentStreamBase stream = new ContentStreamBase.FileStream( file );
-    assertEquals( file.length(), stream.getSize().intValue() );
-    assertTrue( IOUtils.contentEquals( new FileInputStream( file ), stream.getStream() ) );
-    assertTrue( IOUtils.contentEquals( new FileReader(      file ), stream.getReader() ) );
-  }
-  
-
-  public void testURLStream() throws IOException 
-  {
-    String content = null;
-    URL url = new URL( "http://svn.apache.org/repos/asf/lucene/solr/trunk/" );
-    InputStream in = url.openStream();
-    try {
-      content = IOUtils.toString( in );
-    } 
-    finally {
-      IOUtils.closeQuietly(in);
-    }
-    
-    assertTrue( content.length() > 10 ); // found something...
-    
-    ContentStreamBase stream = new ContentStreamBase.URLStream( url );
-    assertEquals( content.length(), stream.getSize().intValue() );
-    
-    // Test the stream
-    in = stream.getStream();
-    try {
-      assertTrue( IOUtils.contentEquals( 
-          new ByteArrayInputStream( content.getBytes() ), in ) );
-    } 
-    finally {
-      IOUtils.closeQuietly(in);
-    }
-
-    // Re-open the stream and this time use a reader
-    stream = new ContentStreamBase.URLStream( url );
-    assertTrue( IOUtils.contentEquals( new StringReader( content ), stream.getReader() ) );
-  }
-}
diff --git a/src/test/org/apache/solr/util/IteratorChainTest.java b/src/test/org/apache/solr/util/IteratorChainTest.java
deleted file mode 100644
index 01733e1..0000000
--- a/src/test/org/apache/solr/util/IteratorChainTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-public class IteratorChainTest extends TestCase {
-  
-  private Iterator<String> makeIterator(String marker,int howMany) {
-    final List<String> c = new ArrayList<String>();
-    for(int i = 1; i <= howMany; i++) {
-      c.add(marker + i);
-    }
-    return c.iterator();
-  }
-  
-  public void testNoIterator() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    assertFalse("Empty IteratorChain.hastNext() is false",c.hasNext());
-    assertEquals("",getString(c));
-  }
-  
-  public void testCallNextTooEarly() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(makeIterator("a",3));
-    try {
-      c.next();
-      fail("Calling next() before hasNext() should throw RuntimeException");
-    } catch(RuntimeException asExpected) {
-      // we're fine
-    }
-  }
-  
-  public void testCallAddTooLate() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.hasNext();
-    try {
-      c.addIterator(makeIterator("a",3));
-      fail("Calling addIterator after hasNext() should throw RuntimeException");
-    } catch(RuntimeException asExpected) {
-      // we're fine
-    }
-  }
-  
-  public void testRemove() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    try {
-      c.remove();
-      fail("Calling remove should throw UnsupportedOperationException");
-    } catch(UnsupportedOperationException asExpected) {
-      // we're fine
-    }
-  }
-  
-  public void testOneIterator() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(makeIterator("a",3));
-    assertEquals("a1a2a3",getString(c));
-  }
-  
-  public void testTwoIterators() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(makeIterator("a",3));
-    c.addIterator(makeIterator("b",2));
-    assertEquals("a1a2a3b1b2",getString(c));
-  }
-  
-  public void testEmptyIteratorsInTheMiddle() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(makeIterator("a",3));
-    c.addIterator(makeIterator("b",0));
-    c.addIterator(makeIterator("c",1));
-    assertEquals("a1a2a3c1",getString(c));
-  }
-  
-  /** dump the contents of it to a String */
-  private String getString(Iterator<String> it) {
-    final StringBuffer sb = new StringBuffer();
-    sb.append("");
-    while(it.hasNext()) {
-      sb.append(it.next());
-    }
-    return sb.toString();
-  }
-}
diff --git a/src/test/org/apache/solr/util/SolrDocumentTest.java b/src/test/org/apache/solr/util/SolrDocumentTest.java
deleted file mode 100644
index 1472abe..0000000
--- a/src/test/org/apache/solr/util/SolrDocumentTest.java
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import junit.framework.TestCase;
-
-/**
- * @author ryan
- */
-public class SolrDocumentTest extends TestCase 
-{
-  public void testSimple() 
-  {
-    Float fval = new Float( 10.01f );
-    Boolean bval = Boolean.TRUE;
-    String sval = "12qwaszx";
-    
-    // Set up a simple document
-    SolrDocument doc = new SolrDocument();
-    doc.addField( "f", fval );
-    doc.addField( "b", bval );
-    doc.addField( "s", sval );
-    doc.addField( "f", 100 ); // again, but something else
-
-    // make sure we can pull values out of it
-    assertEquals( fval, doc.getFieldValue( "f" ) );
-    assertEquals( bval, doc.getFieldValue( "b" ) );
-    assertEquals( sval, doc.getFieldValue( "s" ) );
-    assertEquals( 2, doc.getFieldValues( "f" ).size() );
-    assertNull( doc.getFieldValue( "xxxxx" ) );
-    assertNull( doc.getFieldValues( "xxxxx" ) );
-    
-    List<String> keys = new ArrayList<String>();
-    for( String s : doc.getFieldNames() ) {
-      keys.add( s );
-    }
-    Collections.sort( keys );
-    assertEquals( 3, keys.size() );
-    assertEquals( "[b, f, s]", keys.toString() );
-    
-    // set field replaced existing values:
-    doc.setField( "f", fval );
-    assertEquals( 1, doc.getFieldValues( "f" ).size() );
-    assertEquals( fval, doc.getFieldValue( "f" ) );
-    
-    doc.setField( "n", null );
-    assertEquals( null, doc.getFieldValue( "n" ) );
-    
-    // now remove some fields
-    assertEquals( true, doc.removeFields( "f" ) );
-    assertEquals( false, doc.removeFields( "asdgsadgas" ) );
-    assertNull( doc.getFieldValue( "f" ) );
-    assertNull( doc.getFieldValues( "f" ) );
-  }
-  
-  public void testDocumentBoosts()
-  {
-    SolrInputDocument doc = new SolrInputDocument();
-    assertEquals( null, doc.getBoost( "aaa" ) );
-    doc.setBoost( "aaa", 10.0f );
-    assertEquals( 10.0f, doc.getBoost( "aaa" ) );
-    doc.setBoost( "aaa", null );
-    assertEquals( null, doc.getBoost( "aaa" ) );
-  }
-  
-  public void testUnsupportedStuff()
-  {
-    SolrDocument doc = new SolrDocument();
-
-    try { doc.getFieldValueMap().clear();               fail( "should be unsupported!" ); } catch( Exception ex ){}
-    try { doc.getFieldValueMap().containsValue( null ); fail( "should be unsupported!" ); } catch( Exception ex ){}
-    try { doc.getFieldValueMap().entrySet();            fail( "should be unsupported!" ); } catch( Exception ex ){}
-    try { doc.getFieldValueMap().putAll( null );        fail( "should be unsupported!" ); } catch( Exception ex ){}
-    try { doc.getFieldValueMap().values();              fail( "should be unsupported!" ); } catch( Exception ex ){}
-
-    assertEquals( null, doc.getFieldValueMap().get( "aaa" ) );
-    doc.setField( "aaa", "bbb" );
-    assertEquals( "bbb", doc.getFieldValueMap().get( "aaa" ) );
-    doc.getFieldValueMap().remove( "aaa" );
-    assertEquals( null, doc.getFieldValueMap().get( "aaa" ) );
-  }
-  
-  public void testAddCollections()
-  {
-    List<String> c0 = new ArrayList<String>();
-    c0.add( "aaa" );
-    c0.add( "aaa" );
-    c0.add( "aaa" );
-    c0.add( "bbb" );
-    c0.add( "ccc" );
-    
-    SolrDocument doc = new SolrDocument();
-    doc.addField( "v", c0 );
-    assertEquals( c0.size(), doc.getFieldValues("v").size() );
-    
-    // Same thing with an array
-    Object[] arr = new Object[] { "aaa", "aaa", "aaa", 10, 'b' };
-    doc = new SolrDocument();
-    doc.addField( "v", c0 );
-    assertEquals( arr.length, doc.getFieldValues("v").size() );
-  }
-}
-
-
-
diff --git a/src/test/org/apache/solr/util/SolrParamTest.java b/src/test/org/apache/solr/util/SolrParamTest.java
deleted file mode 100755
index 1ed0b8f..0000000
--- a/src/test/org/apache/solr/util/SolrParamTest.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import junit.framework.TestCase;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.solr.core.SolrException;
-import org.apache.solr.request.SolrParams;
-import org.apache.solr.request.MapSolrParams;
-import org.apache.solr.request.DefaultSolrParams;
-
-/**
- * @author ryan
- */
-public class SolrParamTest extends TestCase 
-{  
-  public void testGetParams() {
-    Map<String,String> pmap = new HashMap<String, String>();
-    pmap.put( "str"        , "string"   );
-    pmap.put( "bool"       , "true"     );
-    pmap.put( "true-0"     , "true"     );
-    pmap.put( "true-1"     , "yes"      );
-    pmap.put( "true-2"     , "on"       );
-    pmap.put( "false-0"    , "false"    );
-    pmap.put( "false-1"    , "off"      );
-    pmap.put( "false-2"    , "no"       );
-    pmap.put( "int"        , "100"      );
-    pmap.put( "float"      , "10.6"     );
-    pmap.put( "f.fl.str"   , "string"   );
-    pmap.put( "f.fl.bool"  , "true"     );
-    pmap.put( "f.fl.int"   , "100"      );
-    pmap.put( "f.fl.float" , "10.6"     );
-    pmap.put( "f.bad.bool" , "notbool"  );
-    pmap.put( "f.bad.int"  , "notint"   );
-    pmap.put( "f.bad.float", "notfloat" );
-    final SolrParams params = new MapSolrParams( pmap );
-    
-    // Test the string values we put in directly
-    assertEquals(  "string"   , params.get( "str"       ) );
-    assertEquals(  "true"     , params.get( "bool"      ) );
-    assertEquals(  "100"      , params.get( "int"       ) );
-    assertEquals(  "10.6"     , params.get( "float"     ) );
-    assertEquals(  "string"   , params.get( "f.fl.str"    ) );
-    assertEquals(  "true"     , params.get( "f.fl.bool"   ) );
-    assertEquals(  "100"      , params.get( "f.fl.int"    ) );
-    assertEquals(  "10.6"     , params.get( "f.fl.float"  ) );
-    assertEquals(  "notbool"  , params.get( "f.bad.bool"  ) );
-    assertEquals(  "notint"   , params.get( "f.bad.int"   ) );
-    assertEquals(  "notfloat" , params.get( "f.bad.float" ) );
-    
-    final String  pstr = "string";
-    final Boolean pbool = Boolean.TRUE;
-    final Integer pint = new Integer( 100 );
-    final Float   pfloat = new Float( 10.6f );
-    
-    // Make sure they parse ok
-    assertEquals( pstr   , params.get(      "str"      ) );
-    assertEquals( pbool  , params.getBool(  "bool"     ) );
-    assertEquals( pint   , params.getInt(   "int"      ) );
-    assertEquals( pfloat , params.getFloat( "float"    ) );
-    assertEquals( pbool  , params.getBool(  "f.fl.bool"  ) );
-    assertEquals( pint   , params.getInt(   "f.fl.int"   ) );
-    assertEquals( pfloat , params.getFloat( "f.fl.float" ) );
-    assertEquals( pstr   , params.getFieldParam( "fl", "str"  ) );
-    assertEquals( pbool  , params.getFieldBool(  "fl", "bool" ) );
-    assertEquals( pint   , params.getFieldInt(   "fl", "int"  ) );
-    assertEquals( pfloat , params.getFieldFloat( "fl", "float" ) );
-    
-    // Test field defaulting (fall through to non-field-specific value)
-    assertEquals( pint   , params.getFieldInt( "fff",  "int"      ) );
-    
-    // test boolean parsing
-    for( int i=0; i<3; i++ ) {
-      // Must use Boolean rather than boolean reference value to prevent
-      // auto-unboxing ambiguity
-      assertEquals( Boolean.TRUE,  params.getBool( "true-"+i  ) );
-      assertEquals( Boolean.FALSE, params.getBool( "false-"+i ) );
-    }
-    
-    // Malformed params: These should throw a 400
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getInt(   "f.bad.int" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getBool(  "f.bad.bool" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFloat( "f.bad.float" ); } } ) );
-    
-    // Ask for params that arent there
-    assertNull( params.get( "asagdsaga" ) );
-    assertNull( params.getBool( "asagdsaga" ) );
-    assertNull( params.getInt( "asagdsaga" ) );
-    assertNull( params.getFloat( "asagdsaga" ) );
-    
-    // Get things with defaults
-    assertEquals( pstr                  , params.get(          "xxx", pstr   ) );
-    assertEquals( pbool.booleanValue()  , params.getBool(      "xxx", pbool   ) );
-    assertEquals( pint.intValue()       , params.getInt(       "xxx", pint   ) );
-    assertEquals( pfloat.floatValue()   , params.getFloat(     "xxx", pfloat  ) );
-    assertEquals( pbool.booleanValue()  , params.getFieldBool( "xxx", "bool", pbool ) );
-    assertEquals( pint.intValue()       , params.getFieldInt(  "xxx", "int", pint  ) );
-    assertEquals( pfloat.floatValue()   , params.getFieldFloat("xxx", "float", pfloat  ) );
-    assertEquals( pstr                  , params.getFieldParam("xxx", "str", pstr  ) );
-
-    // Required params testing uses decorator
-    final SolrParams required = params.required();
-    
-    // Required params which are present should test same as above
-    assertEquals( pstr   , required.get(      "str"      ) );
-    assertEquals( pbool  , required.getBool(  "bool"     ) );
-    assertEquals( pint   , required.getInt(   "int"      ) );
-    assertEquals( pfloat , required.getFloat( "float"    ) );
-    
-    // field value present
-    assertEquals( pbool  , required.getFieldBool(  "fl", "bool" ) );
-    // field defaulting (fall through to non-field-specific value)
-    //assertEquals( pint   , required.getFieldInt( "fff",  "int"      ) );
-    
-    // Required params which are missing: These should throw a 400
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.get( "aaaa" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getInt(   "f.bad.int" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getBool(  "f.bad.bool" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getFloat( "f.bad.float" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getInt(   "aaa" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getBool(  "aaa" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { required.getFloat( "aaa" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFieldBool(  "bad", "bool" ); } } ) );
-    assertEquals( 400, getReturnCode( new Runnable() { public void run() { params.getFieldInt(   "bad", "int"  ); } } ) );
-
-    // Fields with default use their parent value:
-    assertEquals(
-        params.get(   "aaaa", "str" ), 
-        required.get( "aaaa", "str" ) );
-    assertEquals(
-        params.getInt(   "f.bad.nnnn", pint ), 
-        required.getInt( "f.bad.nnnn", pint ) );
-    
-    // Check default SolrParams
-    Map<String,String> dmap = new HashMap<String, String>();
-    // these are not defined in params
-    dmap.put( "dstr"               , "default"   );
-    dmap.put( "dint"               , "123"       );
-    // these are defined in params
-    dmap.put( "int"                , "456"       );
-    SolrParams defaults = new DefaultSolrParams( params, new MapSolrParams( dmap ) );
-  
-    // in params, not in default
-    assertEquals( pstr                  , defaults.get( "str"      ) );
-    // in default, not in params
-    assertEquals( "default"             , defaults.get( "dstr"      ) );
-    assertEquals( new Integer(123)      , defaults.getInt(  "dint"     ) );
-    // in params, overriding defaults
-    assertEquals( pint                  , defaults.getInt(   "int"      ) );
-    // in neither params nor defaults
-    assertNull( defaults.get( "asagdsaga" ) );
-  }
-  
-  public static int getReturnCode( Runnable runnable )
-  {
-    try {
-      runnable.run();
-    }
-    catch( SolrException sx ) {
-      return sx.code();
-    }
-    catch( Exception ex ) {
-      ex.printStackTrace();
-      return 500;
-    }
-    return 200;
-  }
-}
diff --git a/src/test/org/apache/solr/util/SolrPluginUtilsTest.java b/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
index 2413517..e3d91fe 100644
--- a/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
+++ b/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
@@ -17,8 +17,8 @@
 
 package org.apache.solr.util;
 
+import org.apache.solr.common.util.NamedList;
 import org.apache.solr.search.SolrQueryParser;
-import org.apache.solr.util.NamedList;
 import org.apache.solr.util.SolrPluginUtils;
 import org.apache.solr.util.SolrPluginUtils.DisjunctionMaxQueryParser;
 
diff --git a/src/test/org/apache/solr/util/TestXMLEscaping.java b/src/test/org/apache/solr/util/TestXMLEscaping.java
deleted file mode 100644
index 4637d31..0000000
--- a/src/test/org/apache/solr/util/TestXMLEscaping.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.util;
-
-import junit.framework.TestCase;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.Random;
-import java.util.BitSet;
-
-/** Test (some of the) character escaping functions of the XML class
- *  $Id$
- */
-
-public class TestXMLEscaping extends TestCase {
-  private void doSimpleTest(String input,String expectedOutput) throws IOException {
-    final StringWriter sw = new StringWriter();
-    XML.escapeCharData(input, sw);
-    final String result = sw.toString();
-    assertEquals("Escaped output matches '" + expectedOutput + "'",result,expectedOutput);
-  }
-  
-  public void testNoEscape() throws IOException {
-    doSimpleTest("Bonnie","Bonnie");
-  }
-  
-  public void testAmpAscii() throws IOException {
-    doSimpleTest("Bonnie & Clyde","Bonnie &amp; Clyde");
-  }
-
-  public void testAmpAndTagAscii() throws IOException {
-    doSimpleTest("Bonnie & Cl<em>y</em>de","Bonnie &amp; Cl&lt;em&gt;y&lt;/em&gt;de");
-  }
-
-  public void testAmpWithAccents() throws IOException {
-    // 00e9 is unicode eacute
-    doSimpleTest("Les \u00e9v\u00e9nements chez Bonnie & Clyde","Les \u00e9v\u00e9nements chez Bonnie &amp; Clyde");
-  }
-
-  public void testAmpDotWithAccents() throws IOException {
-    // 00e9 is unicode eacute
-    doSimpleTest("Les \u00e9v\u00e9nements chez Bonnie & Clyde.","Les \u00e9v\u00e9nements chez Bonnie &amp; Clyde.");
-  }
-
-  public void testAmpAndTagWithAccents() throws IOException {
-    // 00e9 is unicode eacute
-    doSimpleTest("Les \u00e9v\u00e9nements <chez/> Bonnie & Clyde","Les \u00e9v\u00e9nements &lt;chez/&gt; Bonnie &amp; Clyde");
-  }
-
-  public void testGt() throws IOException {
-    doSimpleTest("a ]]> b","a ]]&gt; b");
-  }
-}
-
-
-
diff --git a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
index 94a0732..417fde7 100644
--- a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
+++ b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
@@ -23,19 +23,19 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.MapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.Config;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.request.MapSolrParams;
 import org.apache.solr.request.QueryResponseWriter;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.util.ContentStreamBase;
 
 /**
  * DirectSolrConnection provides an interface to solr that is similar to 
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
index 665cab0..e1dcd8c 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
@@ -32,11 +32,11 @@ import javax.servlet.ServletResponse;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.request.QueryResponseWriter;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java b/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
index e127af4..ea6de1b 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrRequestParsers.java
@@ -39,17 +39,17 @@ import javax.servlet.http.HttpServletRequest;
 import org.apache.commons.fileupload.FileItem;
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
 import org.apache.commons.fileupload.servlet.ServletFileUpload;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.MultiMapSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.Config;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
-import org.apache.solr.util.ContentStream;
-import org.apache.solr.request.MultiMapSolrParams;
 import org.apache.solr.request.ServletSolrParams;
-import org.apache.solr.request.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequestBase;
-import org.apache.solr.util.ContentStreamBase;
 
 
 public class SolrRequestParsers 
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrServlet.java b/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
index 85cdd2e..0f0b40e 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
@@ -26,8 +26,8 @@ import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
+import org.apache.solr.common.SolrException;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.core.SolrException;
 import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java b/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
index a750960..33dac22 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
@@ -25,11 +25,11 @@ import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-import org.apache.solr.core.SolrException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.XML;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
 import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.XMLResponseWriter;
-import org.apache.solr.util.XML;
 
 /**
  * @author yonik

