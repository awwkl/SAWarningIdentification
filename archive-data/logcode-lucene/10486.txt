GitDiffStart: 26e0f022148d937aeb90bb8ee6340e5513fae305 | Mon Nov 19 16:23:50 2012 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 98c9b2e..2da5115 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -230,6 +230,11 @@ Other Changes
 
 * SOLR-4067: ZkStateReader#getLeaderProps should not return props for a leader
   that it does not think is live. (Mark Miller)
+  
+* SOLR-4086: DIH refactor of VariableResolver and Evaluator.  VariableResolver
+  and each built-in Evaluator are separate concrete classes.  DateFormatEvaluator
+  now defaults with the ROOT Locale. However, users may specify a different 
+  Locale using an optional new third parameter. (James Dyer) 
 
 ==================  4.0.0 ==================
 
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java
index bc70136..c06401b 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/ContextImpl.java
@@ -38,7 +38,7 @@ public class ContextImpl extends Context {
 
   private ContextImpl parent;
 
-  private VariableResolverImpl resolver;
+  private VariableResolver resolver;
 
   private DataSource ds;
 
@@ -55,7 +55,7 @@ public class ContextImpl extends Context {
   DocBuilder docBuilder;
 
 
-  public ContextImpl(EntityProcessorWrapper epw, VariableResolverImpl resolver,
+  public ContextImpl(EntityProcessorWrapper epw, VariableResolver resolver,
                      DataSource ds, String currProcess,
                      Map<String, Object> global, ContextImpl parentContext, DocBuilder docBuilder) {
     this.epw = epw;
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
index 5daf08d..1eff924 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
@@ -34,6 +34,10 @@ import org.apache.solr.handler.dataimport.config.Script;
 
 import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
 import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+import static org.apache.solr.handler.dataimport.DocBuilder.loadClass;
+import static org.apache.solr.handler.dataimport.config.ConfigNameConstants.CLASS;
+import static org.apache.solr.handler.dataimport.config.ConfigNameConstants.NAME;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -511,6 +515,30 @@ public class DataImporter {
   DocBuilder getDocBuilder() {
     return docBuilder;
   }
+  
+  Map<String, Evaluator> getEvaluators() {
+    return getEvaluators(config.getFunctions());
+  }
+  
+  /**
+   * used by tests.
+   */
+  Map<String, Evaluator> getEvaluators(List<Map<String,String>> fn) {
+    Map<String, Evaluator> evaluators = new HashMap<String, Evaluator>();
+    evaluators.put(Evaluator.DATE_FORMAT_EVALUATOR, new DateFormatEvaluator());
+    evaluators.put(Evaluator.SQL_ESCAPE_EVALUATOR, new SqlEscapingEvaluator());
+    evaluators.put(Evaluator.URL_ENCODE_EVALUATOR, new UrlEvaluator());
+    evaluators.put(Evaluator.ESCAPE_SOLR_QUERY_CHARS, new SolrQueryEscapingEvaluator());
+    SolrCore core = docBuilder == null ? null : docBuilder.dataImporter.getCore();
+    for (Map<String, String> map : fn) {
+      try {
+        evaluators.put(map.get(NAME), (Evaluator) loadClass(map.get(CLASS), core).newInstance());
+      } catch (Exception e) {
+        wrapAndThrow(SEVERE, e, "Unable to instantiate evaluator: " + map.get(CLASS));
+      }
+    }
+    return evaluators;    
+  }
 
   static final ThreadLocal<AtomicLong> QUERY_COUNT = new ThreadLocal<AtomicLong>() {
     @Override
@@ -519,12 +547,7 @@ public class DataImporter {
     }
   };
 
-  static final ThreadLocal<SimpleDateFormat> DATE_TIME_FORMAT = new ThreadLocal<SimpleDateFormat>() {
-    @Override
-    protected SimpleDateFormat initialValue() {
-      return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
-    }
-  };
+  
 
   static final class MSG {
     public static final String NO_CONFIG_FOUND = "Configuration not found";
@@ -598,4 +621,5 @@ public class DataImporter {
   public static final String RELOAD_CONF_CMD = "reload-config";
 
   public static final String SHOW_CONF_CMD = "show-config";
+  
 }
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DateFormatEvaluator.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DateFormatEvaluator.java
new file mode 100644
index 0000000..fb60c6f
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DateFormatEvaluator.java
@@ -0,0 +1,147 @@
+package org.apache.solr.handler.dataimport;
+
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.WeakHashMap;
+
+import org.apache.solr.handler.dataimport.config.EntityField;
+import org.apache.solr.util.DateMathParser;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <p>Formats values using a given date format. </p>
+ * <p>Pass three parameters:
+ * <ul>
+ *  <li>An {@link EntityField} or a date expression to be parsed with 
+ *      the {@link DateMathParser} class  If the value is in a String, 
+ *      then it is assumed to be a datemath expression, otherwise it 
+ *      resolved using a {@link VariableResolver} instance</li>
+ *  <li>A date format see {@link SimpleDateFormat} for the syntax.</li>
+ *  <li>The {@link Locale} to parse.  
+ *      (optional. Defaults to the Root Locale) </li>
+ * </ul>
+ * </p>
+ */
+public class DateFormatEvaluator extends Evaluator {
+  
+  public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
+  Map<DateFormatCacheKey, SimpleDateFormat> cache = new WeakHashMap<DateFormatCacheKey, SimpleDateFormat>();
+  Map<String, Locale> availableLocales = new HashMap<String, Locale>();
+  
+  class DateFormatCacheKey {
+    DateFormatCacheKey(Locale l, String df) {
+      this.locale = l;
+      this.dateFormat = df;
+    }
+    Locale locale;
+    String dateFormat;
+  }
+  
+  public DateFormatEvaluator() {  
+    for (Locale locale : Locale.getAvailableLocales()) {
+      availableLocales.put(locale.toString(), locale);
+    }
+  }
+  
+  
+  @Override
+  public String evaluate(String expression, Context context) {
+    List<Object> l = parseParams(expression, context.getVariableResolver());
+    if (l.size() < 2 || l.size() > 3) {
+      throw new DataImportHandlerException(SEVERE, "'formatDate()' must have two or three parameters ");
+    }
+    Object o = l.get(0);
+    Object format = l.get(1);
+    if (format instanceof VariableWrapper) {
+      VariableWrapper wrapper = (VariableWrapper) format;
+      o = wrapper.resolve();
+      format = o.toString();
+    }
+    Locale locale = Locale.ROOT;
+    if(l.size()==3) {
+      Object localeObj = l.get(2);
+      String localeStr = null;
+      if (localeObj  instanceof VariableWrapper) {
+        VariableWrapper wrapper = (VariableWrapper) localeObj;
+        o = wrapper.resolve();
+        localeStr = o.toString();
+      } else {
+        localeStr = localeObj.toString();
+      }
+      availableLocales.get(localeStr);
+      if(locale==null) {
+        throw new DataImportHandlerException(SEVERE, "Unsupported locale: " + localeStr);
+      }
+    }
+    String dateFmt = format.toString();
+    DateFormatCacheKey dfck = new DateFormatCacheKey(locale, dateFmt);
+    SimpleDateFormat sdf = cache.get(dfck);
+    if(sdf==null) {
+      sdf = new SimpleDateFormat(dateFmt, locale);
+      cache.put(dfck, sdf);
+    }
+    Date date = null;
+    if (o instanceof VariableWrapper) {
+      VariableWrapper variableWrapper = (VariableWrapper) o;
+      Object variableval = variableWrapper.resolve();
+      if (variableval instanceof Date) {
+        date = (Date) variableval;
+      } else {
+        String s = variableval.toString();
+        try {
+          dfck = new DateFormatCacheKey(locale, DEFAULT_DATE_FORMAT);
+          sdf = cache.get(dfck);
+          if(sdf==null) {
+            sdf = new SimpleDateFormat(dfck.dateFormat, dfck.locale);
+            cache.put(dfck, sdf);
+          }
+          date = new SimpleDateFormat(DEFAULT_DATE_FORMAT, locale).parse(s);
+        } catch (ParseException exp) {
+          wrapAndThrow(SEVERE, exp, "Invalid expression for date");
+        }
+      }
+    } else {
+      String datemathfmt = o.toString();
+      datemathfmt = datemathfmt.replaceAll("NOW", "");
+      try {
+        date = getDateMathParser().parseMath(datemathfmt);
+      } catch (ParseException e) {
+        wrapAndThrow(SEVERE, e, "Invalid expression for date");
+      }
+    }
+    return sdf.format(date);
+  }
+  static DateMathParser getDateMathParser() {
+    return new DateMathParser(TimeZone.getDefault(), Locale.getDefault()) {
+      @Override
+      public Date getNow() {
+        return new Date();
+      }
+    };
+  }
+}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
index 7f34c60..02d6d53 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java
@@ -31,6 +31,7 @@ import org.apache.solr.schema.SchemaField;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.text.SimpleDateFormat;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
@@ -67,7 +68,7 @@ public class DocBuilder {
   Map<String, Object> session = new HashMap<String, Object>();
 
   static final ThreadLocal<DocBuilder> INSTANCE = new ThreadLocal<DocBuilder>();
-  private Map<String, Object> functionsNamespace;
+  //private Map<String, Object> functionsNamespace;
   private Map<String, Object> persistedProperties;
   
   private DIHProperties propWriter;
@@ -85,8 +86,7 @@ public class DocBuilder {
     DataImporter.QUERY_COUNT.set(importStatistics.queryCount);
     verboseDebug = reqParams.isDebug() && reqParams.getDebugInfo().verbose;
     persistedProperties = propWriter.readIndexerProperties();
-    functionsNamespace = EvaluatorBag.getFunctionsNamespace(this.dataImporter.getConfig().getFunctions(), this, getVariableResolver());
-    
+     
     String writerClassStr = null;
     if(reqParams!=null && reqParams.getRawParams() != null) {
       writerClassStr = (String) reqParams.getRawParams().get(PARAM_WRITER_IMPL);
@@ -113,13 +113,16 @@ public class DocBuilder {
     return debugLogger;
   }
 
-  public VariableResolverImpl getVariableResolver() {
+  private VariableResolver getVariableResolver() {
     try {
-      VariableResolverImpl resolver = null;
+      VariableResolver resolver = null;
       if(dataImporter != null && dataImporter.getCore() != null
           && dataImporter.getCore().getResourceLoader().getCoreProperties() != null){
-        resolver =  new VariableResolverImpl(dataImporter.getCore().getResourceLoader().getCoreProperties());
-      } else resolver = new VariableResolverImpl();
+        resolver =  new VariableResolver(dataImporter.getCore().getResourceLoader().getCoreProperties());
+      } else {
+        resolver = new VariableResolver();
+      }
+      resolver.setEvaluators(dataImporter.getEvaluators());
       Map<String, Object> indexerNamespace = new HashMap<String, Object>();
       if (persistedProperties.get(LAST_INDEX_TIME) != null) {
         indexerNamespace.put(LAST_INDEX_TIME, persistedProperties.get(LAST_INDEX_TIME));
@@ -129,7 +132,6 @@ public class DocBuilder {
       }
       indexerNamespace.put(INDEX_START_TIME, dataImporter.getIndexStartTime());
       indexerNamespace.put("request", reqParams.getRawParams());
-      indexerNamespace.put("functions", functionsNamespace);
       for (Entity entity : dataImporter.getConfig().getEntities()) {
         String key = entity.getName() + "." + SolrWriter.LAST_INDEX_KEY;
         Object lastIndex = persistedProperties.get(key);
@@ -149,12 +151,6 @@ public class DocBuilder {
     }
   }
   
-  private Map<String,Object> getFunctionsNamespace() {
-    if(functionsNamespace==null) {
-      
-    }
-    return functionsNamespace;
-  }
 
   private void invokeEventListener(String className) {
     try {
@@ -241,7 +237,7 @@ public class DocBuilder {
 
       if (stop.get()) {
         // Dont commit if aborted using command=abort
-        statusMessages.put("Aborted", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));
+        statusMessages.put("Aborted", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).format(new Date()));
         rollback();
       } else {
         // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted
@@ -327,7 +323,7 @@ public class DocBuilder {
   @SuppressWarnings("unchecked")
   private void doDelta() {
     addStatusMessage("Delta Dump started");
-    VariableResolverImpl resolver = getVariableResolver();
+    VariableResolver resolver = getVariableResolver();
 
     if (config.getDeleteQuery() != null) {
       writer.deleteByQuery(config.getDeleteQuery());
@@ -350,7 +346,7 @@ public class DocBuilder {
     writer.setDeltaKeys(allPks);
 
     statusMessages.put("Total Changed Documents", allPks.size());
-    VariableResolverImpl vri = getVariableResolver();
+    VariableResolver vri = getVariableResolver();
     Iterator<Map<String, Object>> pkIter = allPks.iterator();
     while (pkIter.hasNext()) {
       Map<String, Object> map = pkIter.next();
@@ -390,7 +386,7 @@ public class DocBuilder {
   
   @SuppressWarnings("unchecked")
   public void addStatusMessage(String msg) {
-    statusMessages.put(msg, DataImporter.DATE_TIME_FORMAT.get().format(new Date()));
+    statusMessages.put(msg, new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).format(new Date()));
   }
 
   private void resetEntity(EntityProcessorWrapper epw) {
@@ -401,7 +397,7 @@ public class DocBuilder {
     
   }
   
-  private void buildDocument(VariableResolverImpl vr, DocWrapper doc,
+  private void buildDocument(VariableResolver vr, DocWrapper doc,
       Map<String,Object> pk, EntityProcessorWrapper epw, boolean isRoot,
       ContextImpl parentCtx) {
     List<EntityProcessorWrapper> entitiesToDestroy = new ArrayList<EntityProcessorWrapper>();
@@ -418,7 +414,7 @@ public class DocBuilder {
   }
 
   @SuppressWarnings("unchecked")
-  private void buildDocument(VariableResolverImpl vr, DocWrapper doc,
+  private void buildDocument(VariableResolver vr, DocWrapper doc,
                              Map<String, Object> pk, EntityProcessorWrapper epw, boolean isRoot,
                              ContextImpl parentCtx, List<EntityProcessorWrapper> entitiesToDestroy) {
 
@@ -734,7 +730,7 @@ public class DocBuilder {
    * @return an iterator to the list of keys for which Solr documents should be updated.
    */
   @SuppressWarnings("unchecked")
-  public Set<Map<String, Object>> collectDelta(EntityProcessorWrapper epw, VariableResolverImpl resolver,
+  public Set<Map<String, Object>> collectDelta(EntityProcessorWrapper epw, VariableResolver resolver,
                                                Set<Map<String, Object>> deletedRows) {
     //someone called abort
     if (stop.get())
@@ -816,14 +812,16 @@ public class DocBuilder {
       // identifying deleted rows with deltas
 
       for (Map<String, Object> row : myModifiedPks) {
-        getModifiedParentRows(resolver.addNamespace(epw.getEntity().getName(), row), epw.getEntity().getName(), epw, parentKeyList);
+        resolver.addNamespace(epw.getEntity().getName(), row);
+        getModifiedParentRows(resolver, epw.getEntity().getName(), epw, parentKeyList);
         // check for abort
         if (stop.get())
           return new HashSet();
       }
       // running the same for deletedrows
       for (Map<String, Object> row : deletedSet) {
-        getModifiedParentRows(resolver.addNamespace(epw.getEntity().getName(), row), epw.getEntity().getName(), epw, parentKeyList);
+        resolver.addNamespace(epw.getEntity().getName(), row);
+        getModifiedParentRows(resolver, epw.getEntity().getName(), epw, parentKeyList);
         // check for abort
         if (stop.get())
           return new HashSet();
@@ -838,7 +836,7 @@ public class DocBuilder {
         myModifiedPks : new HashSet<Map<String, Object>>(parentKeyList);
   }
 
-  private void getModifiedParentRows(VariableResolverImpl resolver,
+  private void getModifiedParentRows(VariableResolver resolver,
                                      String entity, EntityProcessor entityProcessor,
                                      Set<Map<String, Object>> parentKeyList) {
     try {
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EntityProcessorWrapper.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EntityProcessorWrapper.java
index f514138..682e08a 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EntityProcessorWrapper.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EntityProcessorWrapper.java
@@ -48,7 +48,7 @@ public class EntityProcessorWrapper extends EntityProcessor {
   private boolean initalized;
   private String onError;
   private Context context;
-  private VariableResolverImpl resolver;
+  private VariableResolver resolver;
   private String entityName;
 
   protected List<Transformer> transformers;
@@ -65,7 +65,7 @@ public class EntityProcessorWrapper extends EntityProcessor {
   public void init(Context context) {
     rowcache = null;
     this.context = context;
-    resolver = (VariableResolverImpl) context.getVariableResolver();
+    resolver = (VariableResolver) context.getVariableResolver();
     if (entityName == null) {
       onError = resolver.replaceTokens(context.getEntityAttribute(ON_ERROR));
       if (onError == null) onError = ABORT;
@@ -171,7 +171,7 @@ public class EntityProcessorWrapper extends EntityProcessor {
     Map<String, Object> transformedRow = row;
     List<Map<String, Object>> rows = null;
     boolean stopTransform = checkStopTransform(row);
-    VariableResolverImpl resolver = (VariableResolverImpl) context.getVariableResolver();
+    VariableResolver resolver = (VariableResolver) context.getVariableResolver();
     for (Transformer t : transformers) {
       if (stopTransform) break;
       try {
@@ -288,8 +288,8 @@ public class EntityProcessorWrapper extends EntityProcessor {
     delegate.destroy();
   }
 
-  public VariableResolverImpl getVariableResolver() {
-    return (VariableResolverImpl) context.getVariableResolver();
+  public VariableResolver getVariableResolver() {
+    return (VariableResolver) context.getVariableResolver();
   }
 
   public Context getContext() {
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/Evaluator.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/Evaluator.java
index edf7534..2801167 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/Evaluator.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/Evaluator.java
@@ -16,6 +16,18 @@
  */
 package org.apache.solr.handler.dataimport;
 
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.regex.Pattern;
+
+import org.apache.solr.util.DateMathParser;
+
 /**
  * <p>
  * Pluggable functions for resolving variables
@@ -43,4 +55,88 @@ public abstract class Evaluator {
    * @return the value of the given expression evaluated using the resolver
    */
   public abstract String evaluate(String expression, Context context);
+  
+  /**
+   * Parses a string of expression into separate params. The values are separated by commas. each value will be
+   * translated into one of the following:
+   * &lt;ol&gt;
+   * &lt;li&gt;If it is in single quotes the value will be translated to a String&lt;/li&gt;
+   * &lt;li&gt;If is is not in quotes and is a number a it will be translated into a Double&lt;/li&gt;
+   * &lt;li&gt;else it is a variable which can be resolved and it will be put in as an instance of VariableWrapper&lt;/li&gt;
+   * &lt;/ol&gt;
+   *
+   * @param expression the expression to be parsed
+   * @param vr the VariableResolver instance for resolving variables
+   *
+   * @return a List of objects which can either be a string, number or a variable wrapper
+   */
+  List<Object> parseParams(String expression, VariableResolver vr) {
+    List<Object> result = new ArrayList<Object>();
+    expression = expression.trim();
+    String[] ss = expression.split(",");
+    for (int i = 0; i < ss.length; i++) {
+      ss[i] = ss[i].trim();
+      if (ss[i].startsWith("'")) {//a string param has started
+        StringBuilder sb = new StringBuilder();
+        while (true) {
+          sb.append(ss[i]);
+          if (ss[i].endsWith("'")) break;
+          i++;
+          if (i >= ss.length)
+            throw new DataImportHandlerException(SEVERE, "invalid string at " + ss[i - 1] + " in function params: " + expression);
+          sb.append(",");
+        }
+        String s = sb.substring(1, sb.length() - 1);
+        s = s.replaceAll("\\\\'", "'");
+        result.add(s);
+      } else {
+        if (Character.isDigit(ss[i].charAt(0))) {
+          try {
+            Double doub = Double.parseDouble(ss[i]);
+            result.add(doub);
+          } catch (NumberFormatException e) {
+            if (vr.resolve(ss[i]) == null) {
+              wrapAndThrow(
+                      SEVERE, e, "Invalid number :" + ss[i] +
+                              "in parameters  " + expression);
+            }
+          }
+        } else {
+          result.add(new VariableWrapper(ss[i], vr));
+        }
+      }
+    }
+    return result;
+  }
+
+  static class VariableWrapper {
+    String varName;
+    VariableResolver vr;
+
+    public VariableWrapper(String s, VariableResolver vr) {
+      this.varName = s;
+      this.vr = vr;
+    }
+
+    public Object resolve() {
+      return vr.resolve(varName);
+
+    }
+
+    @Override
+    public String toString() {
+      Object o = vr.resolve(varName);
+      return o == null ? null : o.toString();
+    }
+  }
+
+  static Pattern IN_SINGLE_QUOTES = Pattern.compile("^'(.*?)'$");
+  
+  public static final String DATE_FORMAT_EVALUATOR = "formatDate";
+
+  public static final String URL_ENCODE_EVALUATOR = "encodeUrl";
+
+  public static final String ESCAPE_SOLR_QUERY_CHARS = "escapeQueryChars";
+
+  public static final String SQL_ESCAPE_EVALUATOR = "escapeSql";
 }
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EvaluatorBag.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EvaluatorBag.java
deleted file mode 100644
index f477a37..0000000
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/EvaluatorBag.java
+++ /dev/null
@@ -1,314 +0,0 @@
-package org.apache.solr.handler.dataimport;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.solr.core.SolrCore;
-import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
-import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
-import static org.apache.solr.handler.dataimport.DocBuilder.loadClass;
-import static org.apache.solr.handler.dataimport.config.ConfigNameConstants.CLASS;
-import static org.apache.solr.handler.dataimport.config.ConfigNameConstants.NAME;
-
-import org.apache.solr.util.DateMathParser;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.net.URLEncoder;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * <p> Holds definitions for evaluators provided by DataImportHandler </p> <p/> <p> Refer to <a
- * href="http://wiki.apache.org/solr/DataImportHandler">http://wiki.apache.org/solr/DataImportHandler</a> for more
- * details. </p>
- * <p/>
- * <b>This API is experimental and may change in the future.</b>
- *
- * @since solr 1.3
- */
-public class EvaluatorBag {
-  private static final Logger LOG = LoggerFactory.getLogger(EvaluatorBag.class);
-  
-  public static final String DATE_FORMAT_EVALUATOR = "formatDate";
-
-  public static final String URL_ENCODE_EVALUATOR = "encodeUrl";
-
-  public static final String ESCAPE_SOLR_QUERY_CHARS = "escapeQueryChars";
-
-  public static final String SQL_ESCAPE_EVALUATOR = "escapeSql";
-  static final Pattern FORMAT_METHOD = Pattern
-          .compile("^(\\w*?)\\((.*?)\\)$");
-
-  /**
-   * <p/> Returns an <code>Evaluator</code> instance meant to be used for escaping values in SQL queries. </p> <p/> It
-   * escapes the value of the given expression by replacing all occurrences of single-quotes by two single-quotes and
-   * similarily for double-quotes </p>
-   *
-   * @return an <code>Evaluator</code> instance capable of SQL-escaping expressions.
-   */
-  public static Evaluator getSqlEscapingEvaluator() {
-    return new Evaluator() {
-      @Override
-      public String evaluate(String expression, Context context) {
-        List l = parseParams(expression, context.getVariableResolver());
-        if (l.size() != 1) {
-          throw new DataImportHandlerException(SEVERE, "'escapeSql' must have at least one parameter ");
-        }
-        String s = l.get(0).toString();
-        // escape single quote with two single quotes, double quote
-        // with two doule quotes, and backslash with double backslash.
-        // See:  http://dev.mysql.com/doc/refman/4.1/en/mysql-real-escape-string.html
-        return s.replaceAll("'", "''").replaceAll("\"", "\"\"").replaceAll("\\\\", "\\\\\\\\");
-      }
-    };
-  }
-
-  /**
-   * <p/>Returns an <code>Evaluator</code> instance meant to be used for escaping reserved characters in Solr
-   * queries</p>
-   *
-   * @return an <code>Evaluator</code> instance capable of escaping reserved characters in solr queries.
-   *
-   * @see org.apache.solr.client.solrj.util.ClientUtils#escapeQueryChars(String)
-   */
-  public static Evaluator getSolrQueryEscapingEvaluator() {
-    return new Evaluator() {
-      @Override
-      public String evaluate(String expression, Context context) {
-        List l = parseParams(expression, context.getVariableResolver());
-        if (l.size() != 1) {
-          throw new DataImportHandlerException(SEVERE, "'escapeQueryChars' must have at least one parameter ");
-        }
-        String s = l.get(0).toString();
-        return ClientUtils.escapeQueryChars(s);
-      }
-    };
-  }
-
-  /**
-   * <p/> Returns an <code>Evaluator</code> instance capable of URL-encoding expressions. The expressions are evaluated
-   * using a <code>VariableResolver</code> </p>
-   *
-   * @return an <code>Evaluator</code> instance capable of URL-encoding expressions.
-   */
-  public static Evaluator getUrlEvaluator() {
-    return new Evaluator() {
-      @Override
-      public String evaluate(String expression, Context context) {
-        List l = parseParams(expression, context.getVariableResolver());
-        if (l.size() != 1) {
-          throw new DataImportHandlerException(SEVERE, "'encodeUrl' must have at least one parameter ");
-        }
-        String s = l.get(0).toString();
-
-        try {
-          return URLEncoder.encode(s.toString(), "UTF-8");
-        } catch (Exception e) {
-          wrapAndThrow(SEVERE, e, "Unable to encode expression: " + expression + " with value: " + s);
-          return null;
-        }
-      }
-    };
-  }
-
-  /**
-   * <p/> Returns an <code>Evaluator</code> instance capable of formatting values using a given date format. </p> <p/>
-   * The value to be formatted can be a entity.field or a date expression parsed with <code>DateMathParser</code> class.
-   * If the value is in a String, then it is assumed to be a datemath expression, otherwise it resolved using a
-   * <code>VariableResolver</code> instance </p>
-   *
-   * @return an Evaluator instance capable of formatting values to a given date format
-   *
-   * @see DateMathParser
-   */
-  public static Evaluator getDateFormatEvaluator() {
-    return new Evaluator() {
-      @Override
-      public String evaluate(String expression, Context context) {
-        List l = parseParams(expression, context.getVariableResolver());
-        if (l.size() != 2) {
-          throw new DataImportHandlerException(SEVERE, "'formatDate()' must have two parameters ");
-        }
-        Object o = l.get(0);
-        Object format = l.get(1);
-        if (format instanceof VariableWrapper) {
-          VariableWrapper wrapper = (VariableWrapper) format;
-          o = wrapper.resolve();
-          if (o == null)  {
-            format = wrapper.varName;
-            LOG.warn("Deprecated syntax used. The syntax of formatDate has been changed to formatDate(<var>, '<date_format_string>'). " +
-                    "The old syntax will stop working in Solr 1.5");
-          } else  {
-            format = o.toString();
-          }
-        }
-        String dateFmt = format.toString();
-        SimpleDateFormat fmt = new SimpleDateFormat(dateFmt);
-        Date date = null;
-        if (o instanceof VariableWrapper) {
-          VariableWrapper variableWrapper = (VariableWrapper) o;
-          Object variableval = variableWrapper.resolve();
-          if (variableval instanceof Date) {
-            date = (Date) variableval;
-          } else {
-            String s = variableval.toString();
-            try {
-              date = DataImporter.DATE_TIME_FORMAT.get().parse(s);
-            } catch (ParseException exp) {
-              wrapAndThrow(SEVERE, exp, "Invalid expression for date");
-            }
-          }
-        } else {
-          String datemathfmt = o.toString();
-          datemathfmt = datemathfmt.replaceAll("NOW", "");
-          try {
-            date = dateMathParser.parseMath(datemathfmt);
-          } catch (ParseException e) {
-            wrapAndThrow(SEVERE, e, "Invalid expression for date");
-          }
-        }
-        return fmt.format(date);
-      }
-
-    };
-  }
-
-  static Map<String, Object> getFunctionsNamespace(final List<Map<String, String>> fn, DocBuilder docBuilder, final VariableResolverImpl vr) {
-    final Map<String, Evaluator> evaluators = new HashMap<String, Evaluator>();
-    evaluators.put(DATE_FORMAT_EVALUATOR, getDateFormatEvaluator());
-    evaluators.put(SQL_ESCAPE_EVALUATOR, getSqlEscapingEvaluator());
-    evaluators.put(URL_ENCODE_EVALUATOR, getUrlEvaluator());
-    evaluators.put(ESCAPE_SOLR_QUERY_CHARS, getSolrQueryEscapingEvaluator());
-    SolrCore core = docBuilder == null ? null : docBuilder.dataImporter.getCore();
-    for (Map<String, String> map : fn) {
-      try {
-        evaluators.put(map.get(NAME), (Evaluator) loadClass(map.get(CLASS), core).newInstance());
-      } catch (Exception e) {
-        wrapAndThrow(SEVERE, e, "Unable to instantiate evaluator: " + map.get(CLASS));
-      }
-    }
-
-    return new HashMap<String, Object>() {
-      @Override
-      public String get(Object key) {
-        if (key == null)
-          return null;
-        Matcher m = FORMAT_METHOD.matcher((String) key);
-        if (!m.find())
-          return null;
-        String fname = m.group(1);
-        Evaluator evaluator = evaluators.get(fname);
-        if (evaluator == null)
-          return null;
-        ContextImpl ctx = new ContextImpl(null, vr, null, null, null, null, null);
-        String g2 = m.group(2);
-        return evaluator.evaluate(g2, ctx);
-      }
-
-    };
-  }
-
-  /**
-   * Parses a string of expression into separate params. The values are separated by commas. each value will be
-   * translated into one of the following:
-   * &lt;ol&gt;
-   * &lt;li&gt;If it is in single quotes the value will be translated to a String&lt;/li&gt;
-   * &lt;li&gt;If is is not in quotes and is a number a it will be translated into a Double&lt;/li&gt;
-   * &lt;li&gt;else it is a variable which can be resolved and it will be put in as an instance of VariableWrapper&lt;/li&gt;
-   * &lt;/ol&gt;
-   *
-   * @param expression the expression to be parsed
-   * @param vr the VariableResolver instance for resolving variables
-   *
-   * @return a List of objects which can either be a string, number or a variable wrapper
-   */
-  public static List parseParams(String expression, VariableResolver vr) {
-    List result = new ArrayList();
-    expression = expression.trim();
-    String[] ss = expression.split(",");
-    for (int i = 0; i < ss.length; i++) {
-      ss[i] = ss[i].trim();
-      if (ss[i].startsWith("'")) {//a string param has started
-        StringBuilder sb = new StringBuilder();
-        while (true) {
-          sb.append(ss[i]);
-          if (ss[i].endsWith("'")) break;
-          i++;
-          if (i >= ss.length)
-            throw new DataImportHandlerException(SEVERE, "invalid string at " + ss[i - 1] + " in function params: " + expression);
-          sb.append(",");
-        }
-        String s = sb.substring(1, sb.length() - 1);
-        s = s.replaceAll("\\\\'", "'");
-        result.add(s);
-      } else {
-        if (Character.isDigit(ss[i].charAt(0))) {
-          try {
-            Double doub = Double.parseDouble(ss[i]);
-            result.add(doub);
-          } catch (NumberFormatException e) {
-            if (vr.resolve(ss[i]) == null) {
-              wrapAndThrow(
-                      SEVERE, e, "Invalid number :" + ss[i] +
-                              "in parameters  " + expression);
-            }
-          }
-        } else {
-          result.add(new VariableWrapper(ss[i], vr));
-        }
-      }
-    }
-    return result;
-  }
-
-  public static class VariableWrapper {
-    String varName;
-    VariableResolver vr;
-
-    public VariableWrapper(String s, VariableResolver vr) {
-      this.varName = s;
-      this.vr = vr;
-    }
-
-    public Object resolve() {
-      return vr.resolve(varName);
-
-    }
-
-    @Override
-    public String toString() {
-      Object o = vr.resolve(varName);
-      return o == null ? null : o.toString();
-
-    }
-  }
-
-  static Pattern IN_SINGLE_QUOTES = Pattern.compile("^'(.*?)'$");
-
-  static DateMathParser dateMathParser = new DateMathParser(TimeZone
-          .getDefault(), Locale.getDefault()){
-    @Override
-    public Date getNow() {
-      return new Date();
-    }
-  };
-
-}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor.java
index fd9a207..4f36a36 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/FileListEntityProcessor.java
@@ -19,6 +19,7 @@ package org.apache.solr.handler.dataimport;
 import java.io.File;
 import java.io.FilenameFilter;
 import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -151,19 +152,19 @@ public class FileListEntityProcessor extends EntityProcessorBase {
     } else  {
       dateStr = context.replaceTokens(dateStr);
     }
-    m = EvaluatorBag.IN_SINGLE_QUOTES.matcher(dateStr);
+    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);
     if (m.find()) {
       String expr = null;
       expr = m.group(1).replaceAll("NOW", "");
       try {
-        return EvaluatorBag.dateMathParser.parseMath(expr);
+        return DateFormatEvaluator.getDateMathParser().parseMath(expr);
       } catch (ParseException exp) {
         throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
                 "Invalid expression for date", exp);
       }
     }
     try {
-      return DataImporter.DATE_TIME_FORMAT.get().parse(dateStr);
+      return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).parse(dateStr);
     } catch (ParseException exp) {
       throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
               "Invalid expression for date", exp);
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SolrQueryEscapingEvaluator.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SolrQueryEscapingEvaluator.java
new file mode 100644
index 0000000..8468c36
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SolrQueryEscapingEvaluator.java
@@ -0,0 +1,35 @@
+package org.apache.solr.handler.dataimport;
+
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+
+import java.util.List;
+
+import org.apache.solr.client.solrj.util.ClientUtils;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class SolrQueryEscapingEvaluator extends Evaluator {
+  public String evaluate(String expression, Context context) {
+    List<Object> l = parseParams(expression, context.getVariableResolver());
+    if (l.size() != 1) {
+      throw new DataImportHandlerException(SEVERE, "'escapeQueryChars' must have at least one parameter ");
+    }
+    String s = l.get(0).toString();
+    return ClientUtils.escapeQueryChars(s);
+  }
+}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SqlEscapingEvaluator.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SqlEscapingEvaluator.java
new file mode 100644
index 0000000..2ecd277
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SqlEscapingEvaluator.java
@@ -0,0 +1,42 @@
+package org.apache.solr.handler.dataimport;
+
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+
+import java.util.List;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <p> Escapes values in SQL queries.  It escapes the value of the given expression 
+ * by replacing all occurrences of single-quotes by two single-quotes and similarily 
+ * for double-quotes </p>
+ */
+public class SqlEscapingEvaluator extends Evaluator {
+  @Override
+  public String evaluate(String expression, Context context) {
+    List<Object> l = parseParams(expression, context.getVariableResolver());
+    if (l.size() != 1) {
+      throw new DataImportHandlerException(SEVERE, "'escapeSql' must have at least one parameter ");
+    }
+    String s = l.get(0).toString();
+    // escape single quote with two single quotes, double quote
+    // with two doule quotes, and backslash with double backslash.
+    // See:  http://dev.mysql.com/doc/refman/4.1/en/mysql-real-escape-string.html
+    return s.replaceAll("'", "''").replaceAll("\"", "\"\"").replaceAll("\\\\", "\\\\\\\\");
+  }
+}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateString.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateString.java
deleted file mode 100644
index 60249e2..0000000
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateString.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * <p>
- * Provides functionality for replacing variables in a templatized string. It
- * can also be used to get the place-holders (variables) in a templatized
- * string.
- * </p>
- * <p/>
- * <b>This API is experimental and may change in the future.</b>
- *
- *
- * @since solr 1.3
- */
-public class TemplateString {
-  private List<String> variables = new ArrayList<String>();
-
-  private List<String> pcs = new ArrayList<String>();
-
-  private Map<String, TemplateString> cache;
-
-  public TemplateString() {
-    cache = new ConcurrentHashMap<String, TemplateString>();
-  }
-
-  private TemplateString(String s) {
-    Matcher m = WORD_PATTERN.matcher(s);
-    int idx = 0;
-    while (m.find()) {
-      String aparam = s.substring(m.start() + 2, m.end() - 1);
-      variables.add(aparam);
-      pcs.add(s.substring(idx, m.start()));
-      idx = m.end();
-    }
-    pcs.add(s.substring(idx));
-  }
-
-  /**
-   * Returns a string with all variables replaced by the known values. An
-   * unknown variable is replaced by an empty string.
-   *
-   * @param string the String to be resolved
-   * @param resolver the VariableResolver instance to be used for evaluation
-   * @return the string with all variables replaced
-   */
-  public String replaceTokens(String string, VariableResolver resolver) {
-    if (string == null)
-      return null;
-    TemplateString ts = cache.get(string);
-    if (ts == null) {
-      ts = new TemplateString(string);
-      cache.put(string, ts);
-    }
-    return ts.fillTokens(resolver);
-  }
-
-  private String fillTokens(VariableResolver resolver) {
-    String[] s = new String[variables.size()];
-    for (int i = 0; i < variables.size(); i++) {
-      Object val = resolver.resolve(variables.get(i));
-      s[i] = val == null ? "" : val.toString();
-    }
-
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < pcs.size(); i++) {
-      sb.append(pcs.get(i));
-      if (i < s.length) {
-        sb.append(s[i]);
-      }
-    }
-
-    return sb.toString();
-  }
-
-  /**
-   * Returns the variables in the given string.
-   *
-   * @param s the templatized string
-   * @return the list of variables (strings) in the given templatized string.
-   */
-  public static List<String> getVariables(String s) {
-    return new TemplateString(s).variables;
-  }
-
-  static final Pattern WORD_PATTERN = Pattern.compile("(\\$\\{.*?\\})");
-}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateTransformer.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateTransformer.java
index b883436..4b7ca30 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateTransformer.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/TemplateTransformer.java
@@ -55,7 +55,7 @@ public class TemplateTransformer extends Transformer {
   @SuppressWarnings("unchecked")
   public Object transformRow(Map<String, Object> row, Context context) {
 
-    VariableResolverImpl resolver = (VariableResolverImpl) context
+    VariableResolver resolver = (VariableResolver) context
             .getVariableResolver();
     // Add current row to the copy of resolver map
 //    for (Map.Entry<String, Object> entry : row.entrySet())
@@ -69,7 +69,11 @@ public class TemplateTransformer extends Transformer {
 
       // Verify if all variables can be resolved or not
       boolean resolvable = true;
-      List<String> variables = getVars(expr);
+      List<String> variables = this.templateVsVars.get(expr);
+      if(variables == null){
+        variables = resolver.getVariables(expr);
+        this.templateVsVars.put(expr, variables);
+      }
       for (String v : variables) {
         if (resolver.resolve(v) == null) {
           LOG.warn("Unable to resolve variable: " + v
@@ -91,15 +95,5 @@ public class TemplateTransformer extends Transformer {
 
     return row;
   }
-
-  private List<String> getVars(String expr) {
-    List<String> result = this.templateVsVars.get(expr);
-    if(result == null){
-      result = TemplateString.getVariables(expr);
-      this.templateVsVars.put(expr, result);
-    }
-    return result;
-  }
-
   public static final String TEMPLATE = "template";
 }
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/UrlEvaluator.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/UrlEvaluator.java
new file mode 100644
index 0000000..2d8c199
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/UrlEvaluator.java
@@ -0,0 +1,47 @@
+package org.apache.solr.handler.dataimport;
+
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.SEVERE;
+import static org.apache.solr.handler.dataimport.DataImportHandlerException.wrapAndThrow;
+
+import java.net.URLEncoder;
+import java.util.List;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * <p>Escapes reserved characters in Solr queries</p>
+ *
+ * @see org.apache.solr.client.solrj.util.ClientUtils#escapeQueryChars(String)
+ */
+public class UrlEvaluator extends Evaluator {
+  @Override
+  public String evaluate(String expression, Context context) {
+    List<Object> l = parseParams(expression, context.getVariableResolver());
+    if (l.size() != 1) {
+      throw new DataImportHandlerException(SEVERE, "'encodeUrl' must have at least one parameter ");
+    }
+    String s = l.get(0).toString();
+
+    try {
+      return URLEncoder.encode(s.toString(), "UTF-8");
+    } catch (Exception e) {
+      wrapAndThrow(SEVERE, e, "Unable to encode expression: " + expression + " with value: " + s);
+      return null;
+    }
+  }
+}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolver.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolver.java
index 5e48a45..8bbd1b1 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolver.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolver.java
@@ -16,37 +16,205 @@
  */
 package org.apache.solr.handler.dataimport;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.WeakHashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 /**
  * <p>
- * This class is more or less like a Map. But has more intelligence to resolve
- * namespaces. Namespaces are delimited with '.' (period)
+ * A set of nested maps that can resolve variables by namespaces. Variables are
+ * enclosed with a dollar sign then an opening curly brace, ending with a
+ * closing curly brace. Namespaces are delimited with '.' (period).
+ * </p>
+ * <p>
+ * This class also has special logic to resolve evaluator calls by recognizing
+ * the reserved function namespace: dataimporter.functions.xxx
  * </p>
- * <p/>
  * <p>
- * Refer to <a
- * href="http://wiki.apache.org/solr/DataImportHandler">http://wiki.apache.org/solr/DataImportHandler</a>
- * for more details.
+ * This class caches strings that have already been resolved from the current
+ * dih import.
  * </p>
- * <p/>
  * <b>This API is experimental and may change in the future.</b>
- *
- *
+ * 
+ * 
  * @since solr 1.3
  */
-public abstract class VariableResolver {
-
+public class VariableResolver {
+  
+  private static final Pattern DOT_PATTERN = Pattern.compile("[.]");
+  private static final Pattern PLACEHOLDER_PATTERN = Pattern
+      .compile("[$][{](.*?)[}]");
+  private static final Pattern EVALUATOR_FORMAT_PATTERN = Pattern
+      .compile("^(\\w*?)\\((.*?)\\)$");
+  private Map<String,Object> rootNamespace;
+  private Map<String,Evaluator> evaluators;
+  private Map<String,Resolved> cache = new WeakHashMap<String,Resolved>();
+  
+  class Resolved {
+    List<Integer> startIndexes = new ArrayList<Integer>(2);
+    List<Integer> endOffsets = new ArrayList<Integer>(2);
+    List<String> variables = new ArrayList<String>(2);
+  }
+  
+  public static final String FUNCTIONS_NAMESPACE = "dataimporter.functions.";
+  
+  public VariableResolver() {
+    rootNamespace = new HashMap<String,Object>();
+  }
+  
+  public VariableResolver(Properties defaults) {
+    rootNamespace = new HashMap<String,Object>();
+    for (Map.Entry<Object,Object> entry : defaults.entrySet()) {
+      rootNamespace.put(entry.getKey().toString(), entry.getValue());
+    }
+  }
+  
+  public VariableResolver(Map<String,Object> defaults) {
+    rootNamespace = new HashMap<String,Object>(defaults);
+  }
+  
   /**
    * Resolves a given value with a name
-   *
-   * @param name the String to be resolved
+   * 
+   * @param name
+   *          the String to be resolved
    * @return an Object which is the result of evaluation of given name
    */
-  public abstract Object resolve(String name);
-
+  public Object resolve(String name) {
+    Object r = null;
+    if (name != null) {
+      String[] nameParts = DOT_PATTERN.split(name);
+      Map<String,Object> currentLevel = currentLevelMap(nameParts,
+          rootNamespace, false);
+      r = currentLevel.get(nameParts[nameParts.length - 1]);
+      if (r == null && name.startsWith(FUNCTIONS_NAMESPACE)
+          && name.length() > FUNCTIONS_NAMESPACE.length()) {
+        return resolveEvaluator(name);
+      }
+      if (r == null) {
+        r = System.getProperty(name);
+      }
+    }
+    return r == null ? "" : r;
+  }
+  
+  private Object resolveEvaluator(String name) {
+    if (evaluators == null) {
+      return "";
+    }
+    Matcher m = EVALUATOR_FORMAT_PATTERN.matcher(name
+        .substring(FUNCTIONS_NAMESPACE.length()));
+    if (m.find()) {
+      String fname = m.group(1);
+      Evaluator evaluator = evaluators.get(fname);
+      if (evaluator == null) return "";
+      ContextImpl ctx = new ContextImpl(null, this, null, null, null, null,
+          null);
+      String g2 = m.group(2);
+      return evaluator.evaluate(g2, ctx);
+    } else {
+      return "";
+    }
+  }
+  
   /**
    * Given a String with place holders, replace them with the value tokens.
-   *
+   * 
    * @return the string with the placeholders replaced with their values
    */
-  public abstract String replaceTokens(String template);
+  public String replaceTokens(String template) {
+    if (template == null) {
+      return null;
+    }
+    Resolved r = getResolved(template);
+    if (r.startIndexes != null) {
+      StringBuilder sb = new StringBuilder(template);
+      for (int i = r.startIndexes.size() - 1; i >= 0; i--) {
+        String replacement = resolve(r.variables.get(i)).toString();
+        sb.replace(r.startIndexes.get(i), r.endOffsets.get(i), replacement);
+      }
+      return sb.toString();
+    } else {
+      return template;
+    }
+  }
+  
+  private Resolved getResolved(String template) {
+    Resolved r = cache.get(template);
+    if (r == null) {
+      r = new Resolved();
+      Matcher m = PLACEHOLDER_PATTERN.matcher(template);
+      while (m.find()) {
+        String variable = m.group(1);
+        r.startIndexes.add(m.start(0));
+        r.endOffsets.add(m.end(0));
+        r.variables.add(variable);
+      }
+      cache.put(template, r);
+    }
+    return r;
+  }
+  /**
+   * Get a list of variables embedded in the template string.
+   */
+  public List<String> getVariables(String template) {
+    Resolved r = getResolved(template);
+    if (r == null) {
+      return Collections.emptyList();
+    }
+    return new ArrayList<String>(r.variables);
+  }
+  
+  public void addNamespace(String name, Map<String,Object> newMap) {
+    if (newMap != null) {
+      if (name != null) {
+        String[] nameParts = DOT_PATTERN.split(name);
+        Map<String,Object> nameResolveLevel = currentLevelMap(nameParts,
+            rootNamespace, false);
+        nameResolveLevel.put(nameParts[nameParts.length - 1], newMap);
+      } else {
+        for (Map.Entry<String,Object> entry : newMap.entrySet()) {
+          String[] keyParts = DOT_PATTERN.split(entry.getKey());
+          Map<String,Object> currentLevel = rootNamespace;
+          currentLevel = currentLevelMap(keyParts, currentLevel, false);
+          currentLevel.put(keyParts[keyParts.length - 1], entry.getValue());
+        }
+      }
+    }
+  }
+  
+  private Map<String,Object> currentLevelMap(String[] keyParts,
+      Map<String,Object> currentLevel, boolean includeLastLevel) {
+    int j = includeLastLevel ? keyParts.length : keyParts.length - 1;
+    for (int i = 0; i < j; i++) {
+      Object o = currentLevel.get(keyParts[i]);
+      if (o == null) {
+        Map<String,Object> nextLevel = new HashMap<String,Object>();
+        currentLevel.put(keyParts[i], nextLevel);
+        currentLevel = nextLevel;
+      } else if (o instanceof Map<?,?>) {
+        @SuppressWarnings("unchecked")
+        Map<String,Object> nextLevel = (Map<String,Object>) o;
+        currentLevel = nextLevel;
+      } else {
+        throw new AssertionError(
+            "Non-leaf nodes should be of type java.util.Map");
+      }
+    }
+    return currentLevel;
+  }
+  
+  public void removeNamespace(String name) {
+    rootNamespace.remove(name);
+  }
+  
+  public void setEvaluators(Map<String,Evaluator> evaluators) {
+    this.evaluators = evaluators;
+  }
 }
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolverImpl.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolverImpl.java
deleted file mode 100644
index cdd0ba7..0000000
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/VariableResolverImpl.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Collections;
-import java.util.regex.Pattern;
-
-/**
- * <p>
- * The default implementation of VariableResolver interface
- * </p>
- * <p/>
- * <b>This API is experimental and may change in the future.</b>
- *
- *
- * @see VariableResolver
- * @since solr 1.3
- */
-public class VariableResolverImpl extends VariableResolver {
-  private Map<String, Object> container = new HashMap<String, Object>();
-
-  private final TemplateString templateString = new TemplateString();
-
-  private final Map defaults ;
-
-  public VariableResolverImpl() {
-    defaults = Collections.emptyMap();
-  }
-
-  public VariableResolverImpl(Map defaults) {
-    this.defaults = defaults;
-  }
-
-  /**
-   * The current resolver instance
-   */
-  static final ThreadLocal<VariableResolverImpl> CURRENT_VARIABLE_RESOLVER = new ThreadLocal<VariableResolverImpl>();
-
-  @SuppressWarnings("unchecked")
-  public VariableResolverImpl addNamespace(String name, Map<String, Object> map) {
-    if (name != null) {
-      String[] parts = DOT_SPLIT.split(name, 0);
-      Map ns = container;
-      for (int i = 0; i < parts.length; i++) {
-        if (i == parts.length - 1) {
-          ns.put(parts[i], map);
-        }
-        if (ns.get(parts[i]) == null) {
-          ns.put(parts[i], new HashMap());
-          ns = (Map) ns.get(parts[i]);
-        } else {
-          if (ns.get(parts[i]) instanceof Map) {
-            ns = (Map) ns.get(parts[i]);
-          } else {
-            ns.put(parts[i], new HashMap());
-            ns = (Map) ns.get(parts[i]);
-          }
-        }
-      }
-
-    } else {
-      container.putAll(map);
-    }
-    return this;
-
-  }
-
-  public void removeNamespace(String name) {
-    if (name != null)
-      container.remove(name);
-  }
-
-  @Override
-  public String replaceTokens(String template) {
-    return templateString.replaceTokens(template, this);
-  }
-
-  @Override
-  @SuppressWarnings("unchecked")
-  public Object resolve(String name) {
-    if (name == null)
-      return container;
-    if ("".equals(name))
-      return null;
-    String[] parts = DOT_SPLIT.split(name, 0);
-    CURRENT_VARIABLE_RESOLVER.set(this);
-    try {
-      Map<String, Object> namespace = container;
-      for (int i = 0; i < parts.length; i++) {
-        String thePart = parts[i];
-        if (i == parts.length - 1) {
-          Object val = namespace.get(thePart);
-          return val == null ? getDefault(name): val ;
-        }
-        Object temp = namespace.get(thePart);
-        if (temp == null) {
-          Object val = namespace.get(mergeAll(parts, i));
-          return val == null ? getDefault(name): val ;
-        } else {
-          if (temp instanceof Map) {
-            namespace = (Map) temp;
-          } else {
-            return getDefault(name);
-          }
-        }
-      }
-    } finally {
-      CURRENT_VARIABLE_RESOLVER.remove();
-    }
-    return getDefault(name);
-  }
-
-  private Object getDefault(String name) {
-    Object val = defaults.get(name);
-    return val == null? System.getProperty(name) : val;
-  }
-
-  private String mergeAll(String[] parts, int i) {
-    if (i == parts.length - 1)
-      return parts[parts.length - 1];
-    StringBuilder sb = new StringBuilder();
-    for (int j = i; j < parts.length; j++) {
-      sb.append(parts[j]);
-      if (j < parts.length - 1)
-        sb.append(".");
-    }
-    return sb.toString();
-  }
-
-  static final Pattern DOT_SPLIT = Pattern.compile("\\.");
-}
diff --git a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
index 44bfe5a..1660bf0 100644
--- a/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathEntityProcessor.java
@@ -91,14 +91,14 @@ public class XPathEntityProcessor extends EntityProcessorBase {
   public void init(Context context) {
     super.init(context);
     if (xpathReader == null)
-      initXpathReader();
+      initXpathReader(context.getVariableResolver());
     pk = context.getEntityAttribute("pk");
     dataSource = context.getDataSource();
     rowIterator = null;
 
   }
 
-  private void initXpathReader() {
+  private void initXpathReader(VariableResolver resolver) {
     useSolrAddXml = Boolean.parseBoolean(context
             .getEntityAttribute(USE_SOLR_ADD_SCHEMA));
     streamRows = Boolean.parseBoolean(context
@@ -175,7 +175,7 @@ public class XPathEntityProcessor extends EntityProcessorBase {
       }
     }
     String url = context.getEntityAttribute(URL);
-    List<String> l = url == null ? Collections.EMPTY_LIST : TemplateString.getVariables(url);
+    List<String> l = url == null ? Collections.EMPTY_LIST : resolver.getVariables(url);
     for (String s : l) {
       if (s.startsWith(entityName + ".")) {
         if (placeHolderVariables == null)
@@ -259,7 +259,7 @@ public class XPathEntityProcessor extends EntityProcessorBase {
       Object val = context.getSessionAttribute(name, Context.SCOPE_ENTITY);
       if (val != null) namespace.put(name, val);
     }
-    ((VariableResolverImpl)context.getVariableResolver()).addNamespace(entityName, namespace);
+    ((VariableResolver)context.getVariableResolver()).addNamespace(entityName, namespace);
   }
 
   private void addCommonFields(Map<String, Object> r) {
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase.java
index 2d6648c..60521a6 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDIHCacheTestCase.java
@@ -226,7 +226,7 @@ public class AbstractDIHCacheTestCase {
   }
 
   public static Context getContext(final Map<String, String> entityAttrs) {
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     final Context delegate = new ContextImpl(null, resolver, null, null, new HashMap<String, Object>(), null, null);
     return new TestContext(entityAttrs, delegate, null, true);
   }
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDataImportHandlerTestCase.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDataImportHandlerTestCase.java
index bcbf6aa..a39d14d 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDataImportHandlerTestCase.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/AbstractDataImportHandlerTestCase.java
@@ -133,10 +133,10 @@ public abstract class AbstractDataImportHandlerTestCase extends
    */
   @SuppressWarnings("unchecked")
   public static TestContext getContext(EntityProcessorWrapper parent,
-                                   VariableResolverImpl resolver, DataSource parentDataSource,
+                                   VariableResolver resolver, DataSource parentDataSource,
                                    String currProcess, final List<Map<String, String>> entityFields,
                                    final Map<String, String> entityAttrs) {
-    if (resolver == null) resolver = new VariableResolverImpl();
+    if (resolver == null) resolver = new VariableResolver();
     final Context delegate = new ContextImpl(parent, resolver,
             parentDataSource, currProcess,
             new HashMap<String, Object>(), null, null);
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestBuiltInEvaluators.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestBuiltInEvaluators.java
new file mode 100644
index 0000000..3772623
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestBuiltInEvaluators.java
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.handler.dataimport;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.net.URLEncoder;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+/**
+ * <p> Test for EvaluatorBag </p>
+ *
+ *
+ * @since solr 1.3
+ */
+public class TestBuiltInEvaluators extends AbstractDataImportHandlerTestCase {
+  private static final String ENCODING = "UTF-8";
+
+  VariableResolver resolver;
+
+  Map<String, String> sqlTests;
+
+  Map<String, String> urlTests;
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    resolver = new VariableResolver();
+
+    sqlTests = new HashMap<String, String>();
+
+    sqlTests.put("foo\"", "foo\"\"");
+    sqlTests.put("foo\\", "foo\\\\");
+    sqlTests.put("foo'", "foo''");
+    sqlTests.put("foo''", "foo''''");
+    sqlTests.put("'foo\"", "''foo\"\"");
+    sqlTests.put("\"Albert D'souza\"", "\"\"Albert D''souza\"\"");
+
+    urlTests = new HashMap<String, String>();
+
+    urlTests.put("*:*", URLEncoder.encode("*:*", ENCODING));
+    urlTests.put("price:[* TO 200]", URLEncoder.encode("price:[* TO 200]",
+            ENCODING));
+    urlTests.put("review:\"hybrid sedan\"", URLEncoder.encode(
+            "review:\"hybrid sedan\"", ENCODING));
+  }
+
+  
+  @Test
+  public void testSqlEscapingEvaluator() {
+    Evaluator sqlEscaper = new SqlEscapingEvaluator();
+    runTests(sqlTests, sqlEscaper);
+  }
+
+  
+  @Test
+  public void testUrlEvaluator() throws Exception {
+    Evaluator urlEvaluator = new UrlEvaluator();
+    runTests(urlTests, urlEvaluator);
+  }
+
+  @Test
+  public void parseParams() {
+    Map<String,Object> m = new HashMap<String,Object>();
+    m.put("b","B");
+    VariableResolver vr = new VariableResolver();
+    vr.addNamespace("a",m);
+    List<Object> l = (new Evaluator() {      
+      @Override
+      public String evaluate(String expression, Context context) {
+        return null;
+      }
+    }).parseParams(" 1 , a.b, 'hello!', 'ds,o,u\'za',",vr);
+    assertEquals(new Double(1),l.get(0));
+    assertEquals("B",((Evaluator.VariableWrapper)l.get(1)).resolve());
+    assertEquals("hello!",l.get(2));
+    assertEquals("ds,o,u'za",l.get(3));
+  }
+
+  @Test
+  public void testEscapeSolrQueryFunction() {
+    final VariableResolver resolver = new VariableResolver();    
+    Map<String,Object> m= new HashMap<String,Object>();
+    m.put("query","c:t");
+    resolver.setEvaluators(new DataImporter().getEvaluators(Collections.<Map<String,String>>emptyList()));
+    
+    resolver.addNamespace("e",m);
+    String s = resolver
+            .replaceTokens("${dataimporter.functions.escapeQueryChars(e.query)}");
+    org.junit.Assert.assertEquals("c\\:t", s);
+    
+  }
+
+  
+  @Test
+  public void testDateFormatEvaluator() {
+    Evaluator dateFormatEval = new DateFormatEvaluator();
+    ContextImpl context = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.<String, Object>emptyMap(), null, null);
+    
+    Calendar calendar = new GregorianCalendar();
+    calendar.add(Calendar.DAY_OF_YEAR, -2);
+    
+    String currentLocale = Locale.getDefault().toString();
+
+    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.ROOT).format(calendar.getTime()),
+            dateFormatEval.evaluate("'NOW-2DAYS','yyyy-MM-dd HH:mm'", context));    
+    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault()).format(calendar.getTime()),
+        dateFormatEval.evaluate("'NOW-2DAYS','yyyy-MM-dd HH:mm','" + currentLocale + "'", context));
+    
+    calendar = new GregorianCalendar();
+    Date date = calendar.getTime();
+    
+    Map<String, Object> map = new HashMap<String, Object>();
+    map.put("key", date);
+    resolver.addNamespace("A", map);
+
+    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.ROOT).format(date),
+            dateFormatEval.evaluate("A.key, 'yyyy-MM-dd HH:mm'", context));
+    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm", Locale.getDefault()).format(date),
+       dateFormatEval.evaluate("A.key, 'yyyy-MM-dd HH:mm','" + currentLocale + "'", context));
+   
+  }
+
+  private void runTests(Map<String, String> tests, Evaluator evaluator) {
+    ContextImpl ctx = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.<String, Object>emptyMap(), null, null);    
+    for (Map.Entry<String, String> entry : tests.entrySet()) {
+      Map<String, Object> values = new HashMap<String, Object>();
+      values.put("key", entry.getKey());
+      resolver.addNamespace("A", values);
+
+      String expected = entry.getValue();
+      String actual = evaluator.evaluate("A.key", ctx);
+      assertEquals(expected, actual);
+    }
+    
+  }
+}
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestClobTransformer.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestClobTransformer.java
index 7ec575c..9b0587b 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestClobTransformer.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestClobTransformer.java
@@ -42,7 +42,7 @@ public class TestClobTransformer extends AbstractDataImportHandlerTestCase {
     f.put(ClobTransformer.CLOB, "true");
     f.put(DataImporter.NAME, "description");
     flds.add(f);
-    Context ctx = getContext(null, new VariableResolverImpl(), null, Context.FULL_DUMP, flds, Collections.EMPTY_MAP);
+    Context ctx = getContext(null, new VariableResolver(), null, Context.FULL_DUMP, flds, Collections.EMPTY_MAP);
     Transformer t = new ClobTransformer();
     Map<String, Object> row = new HashMap<String, Object>();
     Clob clob = (Clob) Proxy.newProxyInstance(this.getClass().getClassLoader(), new Class[]{Clob.class}, new InvocationHandler() {
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestContextImpl.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestContextImpl.java
index 2870d93..c8f7c1e 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestContextImpl.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestContextImpl.java
@@ -25,7 +25,7 @@ public class TestContextImpl extends AbstractDataImportHandlerTestCase {
   
   @Test
   public void testEntityScope() {
-    ContextImpl ctx = new ContextImpl(null, new VariableResolverImpl(), null, "something", new HashMap<String,Object>(), null, null);
+    ContextImpl ctx = new ContextImpl(null, new VariableResolver(), null, "something", new HashMap<String,Object>(), null, null);
     String lala = new String("lala");
     ctx.setSessionAttribute("huhu", lala, Context.SCOPE_ENTITY);
     Object got = ctx.getSessionAttribute("huhu", Context.SCOPE_ENTITY);
@@ -38,7 +38,7 @@ public class TestContextImpl extends AbstractDataImportHandlerTestCase {
     DataImporter di = new DataImporter();
     di.loadAndInit("<dataConfig><document /></dataConfig>");
     DocBuilder db = new DocBuilder(di, new SolrWriter(null, null),new SimplePropertiesWriter(), new RequestInfo(new HashMap<String,Object>(), null));
-    ContextImpl ctx = new ContextImpl(null, new VariableResolverImpl(), null, "something", new HashMap<String,Object>(), null, db);
+    ContextImpl ctx = new ContextImpl(null, new VariableResolver(), null, "something", new HashMap<String,Object>(), null, db);
     String lala = new String("lala");
     ctx.setSessionAttribute("huhu", lala, Context.SCOPE_SOLR_CORE);
     Object got = ctx.getSessionAttribute("huhu", Context.SCOPE_SOLR_CORE);
@@ -47,7 +47,7 @@ public class TestContextImpl extends AbstractDataImportHandlerTestCase {
   }
   @Test
   public void testDocumentScope() {
-    ContextImpl ctx = new ContextImpl(null, new VariableResolverImpl(), null, "something", new HashMap<String,Object>(), null, null);
+    ContextImpl ctx = new ContextImpl(null, new VariableResolver(), null, "something", new HashMap<String,Object>(), null, null);
     ctx.setDoc(new DocBuilder.DocWrapper());
     String lala = new String("lala");
     ctx.setSessionAttribute("huhu", lala, Context.SCOPE_DOC);
@@ -58,7 +58,7 @@ public class TestContextImpl extends AbstractDataImportHandlerTestCase {
   }
   @Test
   public void testGlobalScope() {
-    ContextImpl ctx = new ContextImpl(null, new VariableResolverImpl(), null, "something", new HashMap<String,Object>(), null, null);
+    ContextImpl ctx = new ContextImpl(null, new VariableResolver(), null, "something", new HashMap<String,Object>(), null, null);
     String lala = new String("lala");
     ctx.setSessionAttribute("huhu", lala, Context.SCOPE_GLOBAL);
     Object got = ctx.getSessionAttribute("huhu", Context.SCOPE_GLOBAL);
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDateFormatTransformer.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDateFormatTransformer.java
index 29bf2f5..2b96746 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDateFormatTransformer.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDateFormatTransformer.java
@@ -45,7 +45,7 @@ public class TestDateFormatTransformer extends AbstractDataImportHandlerTestCase
 
     Map row = createMap("lastModified", format.format(now));
 
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("e", row);
 
     Context context = getContext(null, resolver,
@@ -73,7 +73,7 @@ public class TestDateFormatTransformer extends AbstractDataImportHandlerTestCase
     list.add(format.format(now2));
     row.put("lastModified", list);
 
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("e", row);
 
     Context context = getContext(null, resolver,
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestEvaluatorBag.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestEvaluatorBag.java
deleted file mode 100644
index ec05696..0000000
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestEvaluatorBag.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.net.URLEncoder;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-/**
- * <p> Test for EvaluatorBag </p>
- *
- *
- * @since solr 1.3
- */
-public class TestEvaluatorBag extends AbstractDataImportHandlerTestCase {
-  private static final String ENCODING = "UTF-8";
-
-  VariableResolverImpl resolver;
-
-  Map<String, String> sqlTests;
-
-  Map<String, String> urlTests;
-
-  @Override
-  @Before
-  public void setUp() throws Exception {
-    super.setUp();
-    resolver = new VariableResolverImpl();
-
-    sqlTests = new HashMap<String, String>();
-
-    sqlTests.put("foo\"", "foo\"\"");
-    sqlTests.put("foo\\", "foo\\\\");
-    sqlTests.put("foo'", "foo''");
-    sqlTests.put("foo''", "foo''''");
-    sqlTests.put("'foo\"", "''foo\"\"");
-    sqlTests.put("\"Albert D'souza\"", "\"\"Albert D''souza\"\"");
-
-    urlTests = new HashMap<String, String>();
-
-    urlTests.put("*:*", URLEncoder.encode("*:*", ENCODING));
-    urlTests.put("price:[* TO 200]", URLEncoder.encode("price:[* TO 200]",
-            ENCODING));
-    urlTests.put("review:\"hybrid sedan\"", URLEncoder.encode(
-            "review:\"hybrid sedan\"", ENCODING));
-  }
-
-  /**
-   * Test method for {@link EvaluatorBag#getSqlEscapingEvaluator()}.
-   */
-  @Test
-  public void testGetSqlEscapingEvaluator() {
-    Evaluator sqlEscaper = EvaluatorBag.getSqlEscapingEvaluator();
-    runTests(sqlTests, sqlEscaper);
-  }
-
-  /**
-   * Test method for {@link EvaluatorBag#getUrlEvaluator()}.
-   */
-  @Test
-  public void testGetUrlEvaluator() throws Exception {
-    Evaluator urlEvaluator = EvaluatorBag.getUrlEvaluator();
-    runTests(urlTests, urlEvaluator);
-  }
-
-  @Test
-  public void parseParams() {
-    Map m = new HashMap();
-    m.put("b","B");
-    VariableResolverImpl vr = new VariableResolverImpl();
-    vr.addNamespace("a",m);
-    List l =  EvaluatorBag.parseParams(" 1 , a.b, 'hello!', 'ds,o,u\'za',",vr);
-    assertEquals(new Double(1),l.get(0));
-    assertEquals("B",((EvaluatorBag.VariableWrapper)l.get(1)).resolve());
-    assertEquals("hello!",l.get(2));
-    assertEquals("ds,o,u'za",l.get(3));
-  }
-
-  @Test
-  public void testEscapeSolrQueryFunction() {
-    final VariableResolverImpl resolver = new VariableResolverImpl();
-    ContextImpl context = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.EMPTY_MAP, null, null);
-    
-    Map m= new HashMap();
-    m.put("query","c:t");
-    resolver.addNamespace("dataimporter.functions", EvaluatorBag
-            .getFunctionsNamespace(Collections.EMPTY_LIST, null, resolver));
-    resolver.addNamespace("e",m);
-    String s = resolver
-            .replaceTokens("${dataimporter.functions.escapeQueryChars(e.query)}");
-    org.junit.Assert.assertEquals("c\\:t", s);
-    
-  }
-
-  /**
-   * Test method for {@link EvaluatorBag#getDateFormatEvaluator()}.
-   */
-  @Test
-  @Ignore("Known Locale/TZ problems: see https://issues.apache.org/jira/browse/SOLR-1916")
-  public void testGetDateFormatEvaluator() {
-    Evaluator dateFormatEval = EvaluatorBag.getDateFormatEvaluator();
-    ContextImpl context = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.EMPTY_MAP, null, null);
-    
-    Calendar calendar = new GregorianCalendar();
-    calendar.add(Calendar.DAY_OF_YEAR, -2);
-
-    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm").format(calendar.getTime()),
-            dateFormatEval.evaluate("'NOW-2DAYS','yyyy-MM-dd HH:mm'", context));
-
-    calendar = new GregorianCalendar();
-    Date date = calendar.getTime();
-    
-    Map<String, Object> map = new HashMap<String, Object>();
-    map.put("key", date);
-    resolver.addNamespace("A", map);
-
-    assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm").format(date),
-            dateFormatEval.evaluate("A.key, 'yyyy-MM-dd HH:mm'", context));
-   
-  }
-
-  private void runTests(Map<String, String> tests, Evaluator evaluator) {
-    ContextImpl ctx = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.EMPTY_MAP, null, null);    
-    for (Map.Entry<String, String> entry : tests.entrySet()) {
-      Map<String, Object> values = new HashMap<String, Object>();
-      values.put("key", entry.getKey());
-      resolver.addNamespace("A", values);
-
-      String expected = entry.getValue();
-      String actual = evaluator.evaluate("A.key", ctx);
-      assertEquals(expected, actual);
-    }
-    
-  }
-}
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestFileListEntityProcessor.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestFileListEntityProcessor.java
index b5c4e18..51cc945 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestFileListEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestFileListEntityProcessor.java
@@ -21,6 +21,7 @@ import org.junit.Test;
 
 import java.io.File;
 import java.io.IOException;
+import java.text.SimpleDateFormat;
 import java.util.*;
 
 /**
@@ -47,7 +48,7 @@ public class TestFileListEntityProcessor extends AbstractDataImportHandlerTestCa
             FileListEntityProcessor.FILE_NAME, "xml$",
             FileListEntityProcessor.BASE_DIR, tmpdir.getAbsolutePath());
     Context c = getContext(null,
-            new VariableResolverImpl(), null, Context.FULL_DUMP, Collections.EMPTY_LIST, attrs);
+            new VariableResolver(), null, Context.FULL_DUMP, Collections.EMPTY_LIST, attrs);
     FileListEntityProcessor fileListEntityProcessor = new FileListEntityProcessor();
     fileListEntityProcessor.init(c);
     List<String> fList = new ArrayList<String>();
@@ -108,14 +109,14 @@ public class TestFileListEntityProcessor extends AbstractDataImportHandlerTestCa
             FileListEntityProcessor.FILE_NAME, ".*",
             FileListEntityProcessor.BASE_DIR, tmpdir.getAbsolutePath(),
             FileListEntityProcessor.SMALLER_THAN, "${a.x}");
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("a", createMap("x", "4"));
     fList = getFiles(resolver, attrs);
     assertEquals(l, new HashSet<String>(fList));
   }
 
   @SuppressWarnings("unchecked")
-  static List<String> getFiles(VariableResolverImpl resolver, Map attrs) {
+  static List<String> getFiles(VariableResolver resolver, Map attrs) {
     Context c = getContext(null,
             resolver, null, Context.FULL_DUMP, Collections.EMPTY_LIST, attrs);
     FileListEntityProcessor fileListEntityProcessor = new FileListEntityProcessor();
@@ -158,8 +159,8 @@ public class TestFileListEntityProcessor extends AbstractDataImportHandlerTestCa
             FileListEntityProcessor.FILE_NAME, ".xml$",
             FileListEntityProcessor.BASE_DIR, tmpdir.getAbsolutePath(),
             FileListEntityProcessor.NEWER_THAN, "${a.x}");
-    VariableResolverImpl resolver = new VariableResolverImpl();
-    String lastMod = DataImporter.DATE_TIME_FORMAT.get().format(new Date(System.currentTimeMillis() - 50000));
+    VariableResolver resolver = new VariableResolver();
+    String lastMod = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).format(new Date(System.currentTimeMillis() - 50000));
     resolver.addNamespace("a", createMap("x", lastMod));
     createFile(tmpdir, "t.xml", "t.xml".getBytes(), false);
     fList = getFiles(resolver, attrs);
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestLineEntityProcessor.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestLineEntityProcessor.java
index 920ca4a..f79ed9a 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestLineEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestLineEntityProcessor.java
@@ -51,7 +51,7 @@ public class TestLineEntityProcessor extends AbstractDataImportHandlerTestCase {
 
     Context c = getContext(
             null,                          //parentEntity
-            new VariableResolverImpl(),  //resolver
+            new VariableResolver(),  //resolver
             getDataSource(filecontents),   //parentDataSource
             Context.FULL_DUMP,                             //currProcess
             Collections.EMPTY_LIST,        //entityFields
@@ -91,7 +91,7 @@ public class TestLineEntityProcessor extends AbstractDataImportHandlerTestCase {
 
     Context c = getContext(
             null,                          //parentEntity
-            new VariableResolverImpl(),  //resolver
+            new VariableResolver(),  //resolver
             getDataSource(filecontents),   //parentDataSource
             Context.FULL_DUMP,                             //currProcess
             Collections.EMPTY_LIST,        //entityFields
@@ -129,7 +129,7 @@ public class TestLineEntityProcessor extends AbstractDataImportHandlerTestCase {
 
     Context c = getContext(
             null,                          //parentEntity
-            new VariableResolverImpl(),  //resolver
+            new VariableResolver(),  //resolver
             getDataSource(filecontents),   //parentDataSource
             Context.FULL_DUMP,                             //currProcess
             Collections.EMPTY_LIST,        //entityFields
@@ -165,7 +165,7 @@ public class TestLineEntityProcessor extends AbstractDataImportHandlerTestCase {
 
     Context c = getContext(
             null,                          //parentEntity
-            new VariableResolverImpl(),  //resolver
+            new VariableResolver(),  //resolver
             getDataSource(filecontents),   //parentDataSource
             Context.FULL_DUMP,                             //currProcess
             Collections.EMPTY_LIST,        //entityFields
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNestedChildren.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNestedChildren.java
new file mode 100644
index 0000000..5353c92
--- /dev/null
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNestedChildren.java
@@ -0,0 +1,60 @@
+package org.apache.solr.handler.dataimport;
+
+import org.junit.Test;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestNestedChildren extends AbstractDIHJdbcTestCase {
+
+  @Test
+  public void test() throws Exception {
+    h.query("/dataimport", generateRequest());
+    assertQ(req("*:*"), "//*[@numFound='1']");
+    assertQ(req("third_s:CHICKEN"), "//*[@numFound='1']");
+  } 
+  
+  @Override
+  protected String generateConfig() {
+    StringBuilder sb = new StringBuilder();
+    sb.append("<dataConfig> \n");
+    sb.append("<dataSource name=\"derby\" driver=\"org.apache.derby.jdbc.EmbeddedDriver\" url=\"jdbc:derby:memory:derbyDB;\" /> \n");
+    sb.append("<document name=\"TestSimplePropertiesWriter\"> \n");
+    sb.append("<entity name=\"FIRST\" processor=\"SqlEntityProcessor\" dataSource=\"derby\" ");
+    sb.append(" query=\"select 1 as id, 'PORK' as FIRST_S from sysibm.sysdummy1 \" >\n");
+    sb.append("  <field column=\"FIRST_S\" name=\"first_s\" /> \n");
+    sb.append("  <entity name=\"SECOND\" processor=\"SqlEntityProcessor\" dataSource=\"derby\" ");
+    sb.append("   query=\"select 1 as id, 2 as SECOND_ID, 'BEEF' as SECOND_S from sysibm.sysdummy1 WHERE 1=${FIRST.ID}\" >\n");
+    sb.append("   <field column=\"SECOND_S\" name=\"second_s\" /> \n");
+    sb.append("   <entity name=\"SECOND\" processor=\"SqlEntityProcessor\" dataSource=\"derby\" ");
+    sb.append("    query=\"select 1 as id, 'CHICKEN' as THIRD_S from sysibm.sysdummy1 WHERE 2=${SECOND.SECOND_ID}\" >\n");
+    sb.append("    <field column=\"THIRD_S\" name=\"third_s\" /> \n");
+    sb.append("   </entity>\n");
+    sb.append("  </entity>\n");
+    sb.append("</entity>\n");
+    sb.append("</document> \n");
+    sb.append("</dataConfig> \n");
+    String config = sb.toString();
+    log.debug(config); 
+    return config;
+  }
+  
+  @Override
+  protected Database setAllowedDatabases() {
+    return Database.DERBY;
+  }   
+}
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNumberFormatTransformer.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNumberFormatTransformer.java
index d3dbc4d..1e45db1 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNumberFormatTransformer.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestNumberFormatTransformer.java
@@ -66,7 +66,7 @@ public class TestNumberFormatTransformer extends AbstractDataImportHandlerTestCa
     inputs.add("245" + GROUPING_SEP + "678");
     Map row = createMap("inputs", inputs);
 
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("e", row);
 
     Context context = getContext(null, resolver, null, Context.FULL_DUMP, fields, null);
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestRegexTransformer.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestRegexTransformer.java
index 4eb2ef4..bd7eccf 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestRegexTransformer.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestRegexTransformer.java
@@ -134,7 +134,7 @@ public class TestRegexTransformer extends AbstractDataImportHandlerTestCase {
     String s = "Fuel Economy Range: 26 mpg Hwy, 19 mpg City";
     row.put("rowdata", s);
 
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("e", row);
     Map<String, String> eAttrs = createMap("name", "e");
     Context context = getContext(null, resolver, null, Context.FULL_DUMP, fields, eAttrs);
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSqlEntityProcessor2.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSqlEntityProcessor2.java
index 6f72ae5..14acbfe 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSqlEntityProcessor2.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestSqlEntityProcessor2.java
@@ -23,6 +23,7 @@ import org.junit.Test;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Locale;
 import java.text.SimpleDateFormat;
 import java.text.ParseException;
 
@@ -70,15 +71,15 @@ public class TestSqlEntityProcessor2 extends AbstractDataImportHandlerTestCase {
   static class DateFormatValidatingEvaluator extends Evaluator {
     @Override
     public String evaluate(String expression, Context context) {
-      List l = EvaluatorBag.parseParams(expression, context.getVariableResolver());
+      List l = new DateFormatEvaluator().parseParams(expression, context.getVariableResolver());
       Object o = l.get(0);
       String dateStr = null;
-      if (o instanceof EvaluatorBag.VariableWrapper) {
-        EvaluatorBag.VariableWrapper wrapper = (EvaluatorBag.VariableWrapper) o;
+      if (o instanceof Evaluator.VariableWrapper) {
+        Evaluator.VariableWrapper wrapper = (Evaluator.VariableWrapper) o;
         o = wrapper.resolve();
         dateStr = o.toString();
       }
-      SimpleDateFormat formatter = DataImporter.DATE_TIME_FORMAT.get();
+      SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT);
       try {
         formatter.parse(dateStr);
       } catch (ParseException e) {
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateString.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateString.java
deleted file mode 100644
index 5c47ca7..0000000
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateString.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.handler.dataimport;
-
-import org.junit.Test;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Properties;
-import java.util.regex.Pattern;
-
-/**
- * <p>
- * Test for TemplateString
- * </p>
- *
- *
- * @since solr 1.3
- */
-public class TestTemplateString extends AbstractDataImportHandlerTestCase {
-  @Test
-  public void testSimple() {
-    VariableResolverImpl vri = new VariableResolverImpl();
-    Map<String, Object> ns = new HashMap<String, Object>();
-    ns.put("last_index_time", Long.valueOf(1199429363730l));
-    vri.addNamespace("indexer", ns);
-    assertEquals("select id from subject where last_modified > 1199429363730",
-                 new TemplateString().replaceTokens(
-                   "select id from subject where last_modified > ${indexer.last_index_time}",
-                   vri));
-  }
-
-  private static Properties EMPTY_PROPS = new Properties();
-
-  private static Pattern SELECT_WHERE_PATTERN = Pattern.compile(
-          "^\\s*(select\\b.*?\\b)(where).*", Pattern.CASE_INSENSITIVE);
-}
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateTransformer.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateTransformer.java
index 48fdeb0..2acdf61 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateTransformer.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestTemplateTransformer.java
@@ -58,7 +58,7 @@ public class TestTemplateTransformer extends AbstractDataImportHandlerTestCase {
             "lastName", "Mangar",
             "mail", mails);
 
-    VariableResolverImpl resolver = new VariableResolverImpl();
+    VariableResolver resolver = new VariableResolver();
     resolver.addNamespace("e", row);
     Map<String, String> entityAttrs = createMap("name", "e");
 
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestURLDataSource.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestURLDataSource.java
index ca14f94..7d8f1b8 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestURLDataSource.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestURLDataSource.java
@@ -27,7 +27,7 @@ import org.junit.Test;
 public class TestURLDataSource extends AbstractDataImportHandlerTestCase {
   private List<Map<String, String>> fields = new ArrayList<Map<String, String>>();
   private URLDataSource dataSource = new URLDataSource();
-  private VariableResolverImpl variableResolver = new VariableResolverImpl();
+  private VariableResolver variableResolver = new VariableResolver();
   private Context context = AbstractDataImportHandlerTestCase.getContext(null, variableResolver,
       dataSource, Context.FULL_DUMP, fields, null);
   private Properties initProps = new Properties();
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestVariableResolver.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestVariableResolver.java
index 926f559..f99a71f 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestVariableResolver.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestVariableResolver.java
@@ -34,7 +34,7 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void testSimpleNamespace() {
-    VariableResolverImpl vri = new VariableResolverImpl();
+    VariableResolver vri = new VariableResolver();
     Map<String, Object> ns = new HashMap<String, Object>();
     ns.put("world", "WORLD");
     vri.addNamespace("hello", ns);
@@ -47,9 +47,9 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
     System.setProperty(TestVariableResolver.class.getName(),"hello");
     // System.out.println("s.gP()"+ System.getProperty(TestVariableResolver.class.getName())); 
 
-    HashMap m = new HashMap();
-    m.put("hello","world");
-    VariableResolverImpl vri = new VariableResolverImpl(m);
+    Properties p = new Properties();
+    p.put("hello","world");
+    VariableResolver vri = new VariableResolver(p);
     Object val = vri.resolve(TestVariableResolver.class.getName());
     // System.out.println("val = " + val);
     assertEquals("hello", val);
@@ -58,7 +58,7 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void testNestedNamespace() {
-    VariableResolverImpl vri = new VariableResolverImpl();
+    VariableResolver vri = new VariableResolver();
     Map<String, Object> ns = new HashMap<String, Object>();
     ns.put("world", "WORLD");
     vri.addNamespace("hello", ns);
@@ -70,7 +70,7 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void test3LevelNestedNamespace() {
-    VariableResolverImpl vri = new VariableResolverImpl();
+    VariableResolver vri = new VariableResolver();
     Map<String, Object> ns = new HashMap<String, Object>();
     ns.put("world", "WORLD");
     vri.addNamespace("hello", ns);
@@ -82,9 +82,8 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void dateNamespaceWithValue() {
-    VariableResolverImpl vri = new VariableResolverImpl();
-    vri.addNamespace("dataimporter.functions", EvaluatorBag
-            .getFunctionsNamespace(Collections.EMPTY_LIST, null, vri));
+    VariableResolver vri = new VariableResolver();
+    vri.setEvaluators(new DataImporter().getEvaluators(Collections.<Map<String,String>>emptyList()));
     Map<String, Object> ns = new HashMap<String, Object>();
     Date d = new Date();
     ns.put("dt", d);
@@ -95,12 +94,10 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void dateNamespaceWithExpr() throws Exception {
-    VariableResolverImpl vri = new VariableResolverImpl();
-    vri.addNamespace("dataimporter.functions", EvaluatorBag
-            .getFunctionsNamespace(Collections.EMPTY_LIST,null, vri));
+    VariableResolver vri = new VariableResolver();
+    vri.setEvaluators(new DataImporter().getEvaluators(Collections.<Map<String,String>>emptyList()));
     SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
     format.setTimeZone(TimeZone.getTimeZone("UTC"));
-    resetEvaluatorBagDateMathParser();
     DateMathParser dmp = new DateMathParser(TimeZone.getDefault(), Locale.getDefault());
 
     String s = vri.replaceTokens("${dataimporter.functions.formatDate('NOW/DAY','yyyy-MM-dd HH:mm')}");
@@ -109,7 +106,7 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void testDefaultNamespace() {
-    VariableResolverImpl vri = new VariableResolverImpl();
+    VariableResolver vri = new VariableResolver();
     Map<String, Object> ns = new HashMap<String, Object>();
     ns.put("world", "WORLD");
     vri.addNamespace(null, ns);
@@ -118,7 +115,7 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void testDefaultNamespace1() {
-    VariableResolverImpl vri = new VariableResolverImpl();
+    VariableResolver vri = new VariableResolver();
     Map<String, Object> ns = new HashMap<String, Object>();
     ns.put("world", "WORLD");
     vri.addNamespace(null, ns);
@@ -127,22 +124,21 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
 
   @Test
   public void testFunctionNamespace1() throws Exception {
-    VariableResolverImpl resolver = new VariableResolverImpl();
-    ContextImpl context = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.EMPTY_MAP, null, null);
+    VariableResolver resolver = new VariableResolver();
     final List<Map<String ,String >> l = new ArrayList<Map<String, String>>();
     Map<String ,String > m = new HashMap<String, String>();
     m.put("name","test");
     m.put("class",E.class.getName());
     l.add(m);
+    resolver.setEvaluators(new DataImporter().getEvaluators(l));
+    ContextImpl context = new ContextImpl(null, resolver, null, Context.FULL_DUMP, Collections.EMPTY_MAP, null, null);
+    
 
     SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
     format.setTimeZone(TimeZone.getTimeZone("UTC"));
-    resetEvaluatorBagDateMathParser();
-    DateMathParser dmp = new DateMathParser(TimeZone.getDefault(), Locale.getDefault());
-
-    resolver.addNamespace("dataimporter.functions", EvaluatorBag
-            .getFunctionsNamespace(l,null, resolver));
-    String s = resolver
+     DateMathParser dmp = new DateMathParser(TimeZone.getDefault(), Locale.getDefault());
+		
+		String s = resolver
             .replaceTokens("${dataimporter.functions.formatDate('NOW/DAY','yyyy-MM-dd HH:mm')}");
     assertEquals(new SimpleDateFormat("yyyy-MM-dd HH:mm")
             .format(dmp.parseMath("/DAY")), s);
@@ -157,13 +153,5 @@ public class TestVariableResolver extends AbstractDataImportHandlerTestCase {
       }
   }
 
-  private void resetEvaluatorBagDateMathParser() {
-    EvaluatorBag.dateMathParser = new DateMathParser(TimeZone
-            .getDefault(), Locale.getDefault()){
-      @Override
-      public Date getNow() {
-        return new Date();
-      }
-    };
-  }
+  
 }
diff --git a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestXPathEntityProcessor.java b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestXPathEntityProcessor.java
index cfa4195..416dc20 100644
--- a/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestXPathEntityProcessor.java
+++ b/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestXPathEntityProcessor.java
@@ -54,7 +54,7 @@ public class TestXPathEntityProcessor extends AbstractDataImportHandlerTestCase
     fields.add(createMap("column", "artist", "xpath", "/catalog/cd/artist"));
     fields.add(createMap("column", "year", "xpath", "/catalog/cd/year"));
     Context c = getContext(null,
-            new VariableResolverImpl(), getDataSource(cdData), Context.FULL_DUMP, fields, entityAttrs);
+            new VariableResolver(), getDataSource(cdData), Context.FULL_DUMP, fields, entityAttrs);
     XPathEntityProcessor xPathEntityProcessor = new XPathEntityProcessor();
     xPathEntityProcessor.init(c);
     List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
@@ -77,7 +77,7 @@ public class TestXPathEntityProcessor extends AbstractDataImportHandlerTestCase
     List fields = new ArrayList();
     fields.add(createMap("column", "a", "xpath", "/root/a", DataImporter.MULTI_VALUED, "true"));
     Context c = getContext(null,
-            new VariableResolverImpl(), getDataSource(testXml), Context.FULL_DUMP, fields, entityAttrs);
+            new VariableResolver(), getDataSource(testXml), Context.FULL_DUMP, fields, entityAttrs);
     XPathEntityProcessor xPathEntityProcessor = new XPathEntityProcessor();
     xPathEntityProcessor.init(c);
     List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
@@ -101,7 +101,7 @@ public class TestXPathEntityProcessor extends AbstractDataImportHandlerTestCase
     List fields = new ArrayList();
     fields.add(createMap("column", "a", "xpath", "/root/a" ,"flatten","true"));
     Context c = getContext(null,
-            new VariableResolverImpl(), getDataSource(testXmlFlatten), Context.FULL_DUMP, fields, entityAttrs);
+            new VariableResolver(), getDataSource(testXmlFlatten), Context.FULL_DUMP, fields, entityAttrs);
     XPathEntityProcessor xPathEntityProcessor = new XPathEntityProcessor();
     xPathEntityProcessor.init(c);
     Map<String, Object> result = null;
@@ -126,7 +126,7 @@ public class TestXPathEntityProcessor extends AbstractDataImportHandlerTestCase
     fields.add(createMap("column", "artist", "xpath", "/catalog/cd/artist"));
     fields.add(createMap("column", "year", "xpath", "/catalog/cd/year"));
     Context c = getContext(null,
-        new VariableResolverImpl(), getDataSource(cdData), Context.FULL_DUMP, fields, entityAttrs);
+        new VariableResolver(), getDataSource(cdData), Context.FULL_DUMP, fields, entityAttrs);
     XPathEntityProcessor xPathEntityProcessor = new XPathEntityProcessor() {
       private int count;
       
@@ -221,7 +221,7 @@ public class TestXPathEntityProcessor extends AbstractDataImportHandlerTestCase
             XPathEntityProcessor.USE_SOLR_ADD_SCHEMA, "true", "xsl", ""
             + new File(tmpdir, "x.xsl").toURI(), "url", "cd.xml");
     Context c = getContext(null,
-            new VariableResolverImpl(), getDataSource(cdData), Context.FULL_DUMP, null, entityAttrs);
+            new VariableResolver(), getDataSource(cdData), Context.FULL_DUMP, null, entityAttrs);
     XPathEntityProcessor xPathEntityProcessor = new XPathEntityProcessor();
     xPathEntityProcessor.init(c);
     List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();

