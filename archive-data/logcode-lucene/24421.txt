GitDiffStart: 0ee1728e6d0ccf4bc4609dd9de8b34a1a95ff9db | Sun Feb 6 15:35:12 2005 +0000
diff --git a/contrib/javascript/queryConstructor/luceneQueryConstructor.html b/contrib/javascript/queryConstructor/luceneQueryConstructor.html
new file mode 100644
index 0000000..c595c20
--- /dev/null
+++ b/contrib/javascript/queryConstructor/luceneQueryConstructor.html
@@ -0,0 +1,194 @@
+<html>
+  <head>
+    <meta name="Author" content="Kelvin Tan">
+    <title>Lucene Query Constructor Demo and Introduction</title>
+    <script type="text/javascript" src="luceneQueryConstructor.js"></script>
+    <script type="text/javascript" src="../queryValidator/luceneQueryValidator.js"></script>
+    <script>
+      submitForm = false // necessary for luceneQueryConstructor not to submit the form upon query construction
+      function doSubmitForm(frm)
+      {
+        if(frm["noField-phrase-input"].value.length > 0)
+          frm["noField-phrase"].value = quote(frm["noField-phrase-input"].value)
+        else if(frm["noField-phrase"].value.length > 0)
+          frm["noField-phrase"].value = ''
+        doMakeQuery(frm.query);
+      }
+    </script>
+  </head>
+  
+  <body>
+  <h2>Lucene Javascript Query Constructor</h2>
+  <p>luceneQueryConstructor.js is a Javascript framework for constructing queries using the "advanced" search features of lucene, 
+  namely field-searching, boolean searching, phrase searching, group searching (via parentheses) and various combinations of the aforementioned.
+  <p>It also provides a convenient way to mimic a Google-like search, where all terms are ANDed, as opposed to Lucene's default OR modifier.
+  <p>
+  This HTML form provides examples on the usage of luceneQueryConstructor.js. 
+  An interface similar to <a href="http://www.google.com/advanced_search">Google's Advanced Search</a> form is shown here.
+    <form>
+  <table width="100%" border="0" cellspacing="1" cellpadding="5"> 
+    <tr>
+      <th></th>
+      <td width="25%"></td>    
+      <tr>
+        <th>
+          <input name="noField-andModifier" value="+|0" type="hidden"><b>Find results</b>
+        </th>
+        <td class="bodytext">With <b>all</b> of the words</td>
+        <td class="bodytext">
+          <input type="text" name="noField-and" size="25">
+          <select name="resultsPerPage">
+          <option value="10">10 results<option value="20">20 results
+          <option value="50" selected>50 results</select>    
+        </td>
+      </tr>
+      <tr>
+        <th>
+          <input name="noField-phraseModifier" value="+|+" type="hidden">
+        </th>
+        <td class="bodytext">With the <b>exact phrase</b></td>
+        <td class="bodytext">
+        <input type="text" name="noField-phrase-input" size="25">
+        <input type="hidden" name="noField-phrase">
+        </td>
+      </tr>
+      <tr>
+        <th>
+          <input name="noField-orModifier" value=" |+" type="hidden">
+        </th>
+        <td class="bodytext">With <b>at least</b> one of the words</td>
+        <td class="bodytext">
+          <input type="text" name="noField-or" size="25">
+        </td>
+      </tr>
+      <tr>
+        <th>
+          <input name="noField-notModifier" value="-|0" type="hidden">
+        </th>
+        <td class="bodytext"><b>Without</b> the words</td>
+        <td class="bodytext">
+          <input type="text" name="noField-not" size="25">
+        </td>
+      </tr>
+      <tr>
+        <th>
+          <b>File Format</b>
+        </th>
+        <td class="bodytext">
+        <select name="fileNameModifier"><option value="And" selected>Only</option><option value="Not">Don't</option></select>
+        return results of the file format</td>
+        <td class="bodytext">
+          <select name="fileName"><option value="" selected>any format<option value="pdf">Adobe Acrobat PDF (.pdf)
+          <option value="doc">Microsoft Word (.doc)<option value="xls">Microsoft Excel (.xls)<option value="ppt">Microsoft Powerpoint (.ppt)</select>
+        </td>
+      </tr>
+      <tr>
+        <th>
+          <b>Date</b>
+        </th>
+        <td class="bodytext">
+        Return results updated in the </td>
+        <td class="bodytext">
+          <select name="date"><option value="" selected>anytime<option value="3">past 3 months
+          <option value="6">past 6 months<option value="12">past year</select>
+          <input type="hidden" name="fromDate">
+          <input type="hidden" name="toDate">
+          <input type="hidden" name="dateRangeField" value="lastModifiedDate">    
+        </td>
+      </tr>
+      <tr>      
+      
+      <input type="hidden" name="query">
+      <tr><td>&nbsp;</tr>
+      <tr><th><p>Current Query:</th><td><pre id="curQuery"></pre><pre id="curQueryValid"></pre></td><td>
+            
+      <input type="button" name="Update" value="Update Query" onClick="doSubmitForm(this.form); document.getElementById('curQuery').innerHTML = this.form.query.value" />
+      <input type="button" name="Validate" value="Validate" onClick="doCheckLuceneQuery(this.form.query); getElementById('curQueryValid').innerHTML = 'Query is valid'" />      
+      </td>      
+    </table>
+    </form>
+    <p>luceneQueryConstructor works by assuming a certain naming convention of form fields to obtain the necessary information to construct the query.<br>
+    <b>NB:</b>Unless otherwise specified, all uses of the word <code>field</code> should be assumed to mean form input fields and not Lucene document fields.
+    <p>The input form field is expected to be the <b>same name as the Lucene Field</b>.  For example, if you have a Document with <i>fileName</i> as a Field, and 
+    you'd like to provide field-searching on this field, then introduce a form field like so:
+    <center>
+    <p><code>&lt;input type="text" name="fileName"&gt;</code>
+    </p>
+    </center>
+    You are also expected to provide another field known as 
+    this field's <b>modifier</b>. This modifier field tells luceneQueryConstructor how to convert the field and value into a Lucene query. The naming convention 
+    of the modifier is <b>&lt;name of input field/Lucene field&gt;&lt;modifier suffix as declared in luceneQueryConstructor.js&gt;</b>. So, for the <i>fileName</i> field 
+    we introduced above, it's modifier field would be:
+    <center>
+    <p><code>&lt;input type="hidden" name="fileNameModifier" value="+|+"&gt;</code>
+    </p>
+    </center>
+    <p>The value of the modifier field is in the form <b>&lt;term modifier&gt;|&lt;group modifier&gt;</b>. Let me explain.
+    <p>Looking at the form above, we see fields that provide
+    <ol>
+    <li>AND search
+    <li>OR search
+    <li>NOT search
+    <li>and others which are unrelated to this discussion
+    </ol>
+    Given a value of <b><i>foo bar</i></b>, the AND search field must be converted to <b><i>+foo +bar</i></b> (luceneQueryConstructor only supports 
+    using +/-, not AND/OR/NOT), the NOT search to <b><i>-foo -bar</i></b> and the OR search not at all.
+    <p>However, also consider the relationship <b>between</b> these groups of fields. Assuming Google's Advanced Search interface, 
+    we're effectively saying that we want all of the terms in the AND search field <b>AND</b> at least one of the 
+    terms in the OR search field <b>AND</b> none of the terms in the NOT search. 
+    <p>So, if the AND, OR and NOT search fields all have the values of <b><i>foo bar</i></b>, then an appropriate search query 
+    which fulfills the requirements would be
+    <center>
+    <p><code>+foo +bar +(foo bar) -foo -bar</code>
+    </p>
+    </center>
+    Well, to be more correct, it should be 
+    <center>
+    <p><code>+(+foo +bar) +(foo bar) -foo -bar</code>
+    </p>
+    </center>
+    Hmmmm...if you're sharp, you would have noticed that the NOT terms aren't grouped. 
+    You'll find that if you group them with an AND modifier, no results will be returned at all (though it's a valid query),
+    because the query constructed wouldn't make any sense at all. Lucene also implicitly ANDs NOT terms, it seems. In any case,
+    both queries as presented are correct, though I prefer the first one because it is less verbose.
+    <p>The following matrix provides modifiers and their effects on queries:<br><br>
+    <table border="1" align="center">
+    <tr>
+    <th>Boolean modifier
+    <th>Form value
+    <th>As term modifier
+    <th>As group modifier
+    </tr>
+    <tr align="center">
+    <td>AND
+    <td>+
+    <td>+term1 + term2 ...
+    <td>+(...)
+    </tr>
+    <tr align="center">
+    <td>OR
+    <td>(single space)
+    <td>term1  term2 ...
+    <td>(...)
+    </tr>
+    <tr align="center">
+    <td>NOT
+    <td>-
+    <td>-term1  -term2 ...
+    <td>-(...)
+    </tr>
+    <tr align="center">
+    <td>no modifier
+    <td>0
+    <td>term1  term2 ...
+    <td>no grouping
+    </tr>
+    </table>
+    <p>With this knowledge, we know that the value of the AND field modifier needs to be <b><i>+|0</i></b> for the first query and 
+    <b><i>+|+</i></b> for the second query, the values of the NOT field modifier and the 
+    OR field modifier are <b><i>-|0</i></b> and <b><i>&nbsp;|+</i></b> (it's an empty space before the |) in both queries respectively.
+    <p>
+    Well, that's all I have to say for now. There are more topics to be covered, such as construction of phrase searches, non-field searches, 
+    multiple list box selections, radio buttons etc, but right now I'm not even sure if anyone will read this much! :-) Anyway, there's always the code. 
+  </body>
+</html>
\ No newline at end of file
diff --git a/contrib/javascript/queryConstructor/luceneQueryConstructor.js b/contrib/javascript/queryConstructor/luceneQueryConstructor.js
new file mode 100644
index 0000000..32cfa7c
--- /dev/null
+++ b/contrib/javascript/queryConstructor/luceneQueryConstructor.js
@@ -0,0 +1,286 @@
+// Lucene Search Query Constructor
+// Author:  Kelvin Tan  (kelvint at apache.org)
+// Version: $Id$
+
+// Change this according to what you use to name the field modifiers in your form.
+// e.g. with the search field "name", the form element of its modifier 
+// will be "name<modifierSuffix>"
+var modifierSuffix = 'Modifier';
+
+// If not a field-specific search
+// e.g. with the arbitary form element 'foobar', its modifier will be 
+// <noFieldPrefix>foobarModifier and its form element 
+// will be <noFieldPrefix>foobar
+var noFieldPrefix = 'noField-';
+
+// Do you wish the query to be displayed as an alert box?
+var debug = false;
+
+// Do you wish the function to submit the form upon query construction?
+var submitForm = false;
+
+// prefix modifier for boolean AND queries
+var AND_MODIFIER = '+';
+
+// prefix modifier for boolean NOT queries
+var NOT_MODIFIER = '-';
+
+// prefix modifier for boolean OR queries
+var OR_MODIFIER  = ' ';
+
+var NO_MODIFIER = 0;
+
+// default modifier for terms
+var DEFAULT_TERM_MODIFIER = AND_MODIFIER;
+
+// default modifier for groups of terms (denoted by parantheses)
+var DEFAULT_GROUP_MODIFIER = AND_MODIFIER;
+
+// used to delimit multiple values from checkboxes and select lists
+var VALUE_DELIMITER = ' ';
+
+// Constructs the query
+// @param query Form field to represent the constructed query to be submitted
+// @param debug Turn on debugging?
+function doMakeQuery( query, dbg )
+{
+  if(typeof(dbg) != "undefined")
+    debug = dbg;
+    
+  var frm = query.form;
+  var formElements = frm.elements;
+  query.value = '';
+  
+  // keep track of the fields we've examined
+  var dict = new Array();
+  
+  for(var i=0; i<formElements.length; i++)
+  {
+    var element = formElements[i];
+    var elementName = element.name;
+    if(elementName != "" && !contains(dict, elementName))
+    {
+      dict[dict.length] = elementName;
+      
+      // ensure we get the whole group (of checkboxes, radio, etc), if applicable
+      var elementValue = getFieldValue(frm[element.name]);
+      if(elementValue.length > 0)
+      {
+        var subElement = frm[elementName + modifierSuffix];
+        if(typeof(subElement) != "undefined") // found a field/fieldModifier pair
+        {
+          var termMod, groupMod;
+          var modifier = getFieldValue(subElement);
+          // modifier field is in the form <termModifier>|<groupModifier>
+          if(modifier.indexOf('|') > -1)
+          {
+            var idx = modifier.indexOf('|');
+            termMod = modifier.substring(0, idx);
+            if(termMod == '') termMod = DEFAULT_TERM_MODIFIER;
+            groupMod = modifier.substring(idx + 1);
+            if(groupMod == '') groupMod = DEFAULT_GROUP_MODIFIER;
+          }
+          else
+          {
+            termMod = modifier;
+            if(termMod == '') termMod = DEFAULT_TERM_MODIFIER;
+            groupMod = DEFAULT_GROUP_MODIFIER;
+          }
+          appendTerms(query, termMod, elementValue, elementName, groupMod);
+        }
+      }
+    }
+  }
+
+  if(debug) {alert('Query:' + query.value);}
+  
+  if(submitForm)
+  {
+    frm.submit();
+  }
+  else
+  {
+    return query;
+  }
+}
+
+// Constructs a Google-like query (all terms are ANDed)
+// @param query Form field to represent the constructed query to be submitted
+// @return Submits the form if submitOnConstruction=true, else returns the query param
+function doANDTerms(query)
+{
+  var value = query.value;
+  query.value = "";
+  appendTerms(query, AND_MODIFIER,  value);
+  if(submitForm)
+  {
+    frm.submit();
+  }
+  else
+  {
+    return query;
+  }
+}
+
+function buildTerms(termModifier, fieldValue)
+{
+  fieldValue = trim(fieldValue);
+  var splitStr = fieldValue.split(" ");
+  fieldValue = '';
+  var inQuotes = false;
+  for(var i=0;i<splitStr.length;i++)
+  {
+    if(splitStr[i].length > 0)
+    {
+      if(!inQuotes)
+      {
+        fieldValue = fieldValue + termModifier + splitStr[i] + ' ';
+      }
+      else
+      { 
+        fieldValue = fieldValue + splitStr[i] + ' ';
+      }      
+      if(splitStr[i].indexOf('"') > -1) inQuotes = !inQuotes
+    }
+  }
+  fieldValue = trim(fieldValue);  
+  return fieldValue;
+}
+
+// Appends terms to a query. 
+// @param query Form field of query
+// @param termModifier Term modifier
+// @param value Value to be appended. Tokenized by spaces, 
+//    and termModifier will be applied to each token.
+// @param fieldName Name of search field. Omit if not a field-specific query.
+// @param groupModifier Modifier applied to each group of terms.
+// @return query form field
+function appendTerms(query, termModifier, value, fieldName, groupModifier)
+{
+  if(typeof(groupModifier) == "undefined")
+    groupModifier = DEFAULT_GROUP_MODIFIER;
+  
+  value = buildTerms(termModifier, value);
+  
+  // not a field-specific search
+  if(fieldName == null || fieldName.indexOf(noFieldPrefix) != -1 || fieldName.length == 0)
+  {
+    if(groupModifier == NO_MODIFIER)
+    {
+      if(query.value.length == 0)
+      {
+        query.value = value;
+      }
+      else
+      {
+        query.value = query.value + ' ' + value;
+      }  
+    }
+    else
+    { 
+      if(query.value.length == 0)
+      {
+        query.value = groupModifier + '(' + value + ')';
+      }
+      else
+      {
+        query.value = query.value + ' ' + groupModifier + '(' + value + ')';
+      }  
+    }
+  }
+  else
+  {
+  	if(groupModifier == NO_MODIFIER) groupModifier = ''
+    if(query.value.length == 0)
+    {
+      query.value = groupModifier + fieldName + ':(' + value + ')';
+    }
+    else
+    {
+      query.value = query.value + ' ' + groupModifier +fieldName + ':(' + value + ')';
+    }  
+  }
+  query.value = trim(query.value)
+  return query;
+}
+
+// Obtain the value of a form field.
+// @param field Form field
+// @return Array of values, or string value depending on field type, 
+//    or empty string if field param is undefined or null
+function getFieldValue(field)
+{
+  if(field == null || typeof(field) == "undefined")
+    return "";
+  if(typeof(field) != "undefined" && typeof(field[0]) != "undefined" && field[0].type=="checkbox")
+    return getCheckedValues(field);
+  if(typeof(field) != "undefined" && typeof(field[0]) != "undefined" && field[0].type=="radio")
+    return getRadioValue(field);
+  if(typeof(field) != "undefined" && field.type.match("select*")) 
+    return getSelectedValues(field);
+  if(typeof(field) != "undefined")
+    return field.value;
+}
+
+function getRadioValue(radio)
+{
+  for(var i=0; i<radio.length; i++)
+  {
+    if(radio[i].checked)
+      return radio[i].value;
+  }
+}
+
+function getCheckedValues(checkbox)
+{
+  var r = new Array();
+  for(var i = 0; i < checkbox.length; i++)
+  {
+    if(checkbox[i].checked)
+      r[r.length] = checkbox[i].value;
+  }
+  return r.join(VALUE_DELIMITER);
+}
+
+function getSelectedValues (select) {
+  var r = new Array();
+  for (var i = 0; i < select.options.length; i++)
+    if (select.options[i].selected)
+    {
+      r[r.length] = select.options[i].value;
+    }
+  return r.join(VALUE_DELIMITER);
+}
+
+function quote(value)
+{
+  return "\"" + trim(value) + "\"";
+}
+
+function contains(array, s)
+{
+  for(var i=0; i<array.length; i++)
+  {
+    if(s == array[i])
+      return true;
+  }
+  return false;
+}
+
+function trim(inputString) {
+   if (typeof inputString != "string") { return inputString; }
+   
+   var temp = inputString;
+   
+   // Replace whitespace with a single space
+   var pattern = /\s+/ig;
+   temp = temp.replace(pattern, " ");
+  
+   // Trim 
+   pattern = /^(\s*)([\w\W]*)(\b\s*$)/;
+   if (pattern.test(temp)) { temp = temp.replace(pattern, "$2"); }
+   // run it another time through for words which don't end with a character or a digit
+   pattern = /^(\s*)([\w\W]*)(\s*$)/;
+   if (pattern.test(temp)) { temp = temp.replace(pattern, "$2"); }
+   return temp; // Return the trimmed string back to the user
+}
\ No newline at end of file
diff --git a/contrib/javascript/queryConstructor/testQueryConstructor.html b/contrib/javascript/queryConstructor/testQueryConstructor.html
new file mode 100644
index 0000000..6644ef7
--- /dev/null
+++ b/contrib/javascript/queryConstructor/testQueryConstructor.html
@@ -0,0 +1,159 @@
+<html>
+
+<head>
+<script language="JavaScript" src="c:/market/jsunit/app/jsUnitCore.js"></script>
+<script language="JavaScript" src="luceneQueryConstructor.js"></script>
+</head>
+<body>
+<script>
+setAlertUser(false);
+
+// additions to jsUnit
+function assertTrue(comment, value)
+{
+  return assertEquals(comment, true, value);
+}
+
+function assertFalse(comment, value)
+{
+  return assertEquals(comment, false, value);
+}
+
+function testTrim()
+{
+  assertEquals("Not trimming", "foo bar", trim("  foo bar"));
+  assertEquals("Not trimming", "foo bar", trim("  foo bar  "));
+  assertEquals("Not trimming", "foo bar", trim("  foo   bar  "));
+  assertEquals("Not trimming", "foo bar", trim("  foo bar\n\t "));
+  assertEquals("Not trimming", "foo:(bar)", trim(" foo:(bar)"));
+}
+
+function testGetFieldValue()
+{
+  var frm = document.testQueryConstructor;
+  // test radio buttons
+  frm.fooRadio[0].checked = true;
+  assertEquals("Wrong value for radio button", frm.fooRadio[0].value, getFieldValue(frm.fooRadio));
+  frm.fooRadio[0].checked = false;
+  frm.fooRadio[1].checked = true;
+  assertEquals("Wrong value for radio button", frm.fooRadio[1].value, getFieldValue(frm.fooRadio));
+  
+  // test checkbox
+  frm.fooCheck[0].checked = true;
+  assertEquals("Wrong value for checkbox", frm.fooCheck[0].value, getFieldValue(frm.fooCheck));
+  frm.fooCheck[0].checked = false;
+  frm.fooCheck[1].checked = true;
+  assertEquals("Wrong value for checkbox", frm.fooCheck[1].value, getFieldValue(frm.fooCheck));
+  
+  // test select
+  frm.fooSelect.options[0].selected = true;
+  assertEquals("Wrong value for select", frm.fooSelect.options[0].value, getFieldValue(frm.fooSelect));
+  frm.fooSelect.options[0].selected = false;
+  frm.fooSelect.options[1].selected = true;
+  assertEquals("Wrong value for checkbox", frm.fooSelect.options[1].value, getFieldValue(frm.fooCheck));
+  
+  // test text field
+  assertEquals("Wrong value for text field", frm.fooText.value, getFieldValue(frm.fooText));
+  
+  // test hidden field
+  assertEquals("Wrong value for hidden field", frm.fooHidden.value, getFieldValue(frm.fooHidden));
+  
+  // test undefined field
+  assertEquals("Wrong value for undefined field", "", getFieldValue(frm.nonexistent)); 
+  assertEquals("Wrong value for undefined field", "", getFieldValue(null)); 
+}
+
+function testAppendTerms()
+{
+  var frm = document.testQueryConstructor;
+  assertEquals("Not appending AND terms correctly", "+fooText:(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
+  frm.query.value = ''
+  assertEquals("Not appending NOT terms correctly", "+fooText:(-1)", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value, frm.fooText.name).value);
+  frm.query.value = ''
+  assertEquals("Not appending OR terms correctly", "+fooText:(1)", appendTerms(frm.query, OR_MODIFIER, frm.fooText.value, frm.fooText.name).value);
+  frm.query.value = ''
+  
+  frm.fooText.value = "\"my foo bar\""
+  assertEquals("Not appending AND terms correctly", "+fooText:(+\"my foo bar\" )", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
+  frm.fooText.value = "1"
+  frm.query.value = ''
+  
+  assertEquals("Not appending terms correctly", "-fooText:(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER).value);
+  frm.query.value = ''
+  frm.fooText.value = "1 2 3"
+  assertEquals("Not appending terms correctly", "+fooText:(+1 +2 +3)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
+  frm.query.value = ''
+  assertEquals("Not appending terms correctly", "-fooText:(1 2 3)", appendTerms(frm.query, OR_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER).value);
+  frm.query.value = ''
+  assertEquals("Not appending terms correctly", "-fooText:(-1 -2 -3)", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER, NO_MODIFIER).value);
+  frm.query.value = ''
+  frm.fooText.value = "1"
+  
+  assertEquals("Not appending terms correctly(without fields)", "+(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value).value);
+  frm.query.value = ''
+  assertEquals("Not appending terms correctly(without fields)", "+(+1)", appendTerms(frm.query, AND_MODIFIER, frm["noField-fooText"].value, "noField-fooText").value);
+  frm.query.value = ''
+
+  frm.fooText.value = "1 2 3"
+  assertEquals("Not appending terms correctly(without fields)", "-1 -2 -3", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value,"", NO_MODIFIER).value);
+  frm.query.value = ''
+  assertEquals("Not appending terms correctly(without fields)", "+(+1 +2 +3)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value).value);
+  frm.fooText.value = "1"
+  frm.query.value = ''
+  
+}
+
+function testDoMakeQuery()
+{
+  var frm = document.testQueryConstructor;
+  frm.or.value = "orValue";
+  assertEquals("Wrong query constructed", "or:(orValue)", doMakeQuery(frm.query).value);
+  frm.orModifier.value = " |+";
+  assertEquals("Wrong query constructed", "+or:(orValue)", doMakeQuery(frm.query).value);
+  frm.orModifier.value = " | ";
+  assertEquals("Wrong query constructed", "or:(orValue)", doMakeQuery(frm.query).value);
+  frm.orModifier.value = "";
+  assertEquals("Wrong query constructed", DEFAULT_GROUP_MODIFIER + "or:(" + DEFAULT_TERM_MODIFIER + "orValue)", doMakeQuery(frm.query).value);
+}
+
+function doANDTerms()
+{
+  
+}
+</script>
+
+<form name="testQueryConstructor">
+<input type="radio" name="fooRadio" value="1">
+<input type="radio" name="fooRadio" value="2">
+
+<input type="checkbox" name="fooCheck" value="1">
+<input type="checkbox" name="fooCheck" value="2">
+
+<select name="fooSelect">
+<option value="1">
+<option value="2">
+</select>
+
+<input type="text" name="fooText" value="1">
+<input type="text" name="noField-fooText" value="1">
+<input type="text" name="foobarText" value="1">
+<input type="hidden" name="fooHidden" value="1">
+<input type="password" name="fooPassword">
+<input type="button" name="fooButton" value="I am a button">
+<input type="submit" name="fooSubmit">
+<input type="reset" name="fooReset">
+<input type="file" name="fooFile">
+
+<input type="hidden" name="andModifier" value="+">
+<input type="hidden" name="and">
+
+<input type="hidden" name="notModifier" value="-">
+<input type="hidden" name="not">
+
+<input type="hidden" name="orModifier" value=" | ">
+<input type="hidden" name="or">
+
+<input type="text" name="query">
+</form>
+</body>
+</html>
\ No newline at end of file
diff --git a/contrib/javascript/queryEscaper/luceneQueryEscaper.js b/contrib/javascript/queryEscaper/luceneQueryEscaper.js
new file mode 100644
index 0000000..c84d910
--- /dev/null
+++ b/contrib/javascript/queryEscaper/luceneQueryEscaper.js
@@ -0,0 +1,98 @@
+// Special characters are + - && || ! ( ) { } [ ] ^ " ~ * ? : \
+// Special words are (case-sensitive) AND NOT OR
+// We escape the common ones, i.e. ! ? * ( ) " :
+
+// escapes a lucene query.
+// @param Form field that contains the query, or the query string
+function doEscapeQuery(queryArg)
+{
+  var query = getQueryValue(queryArg);
+  query = escapeAsterisk(query);
+  query = escapeQuotes(query);
+  query = escapeColon(query);
+  query = escapeQuestionMark(query);
+  query = escapeExclamationMark(query);
+  query = escapeParentheses(query);  
+  query = escapeSquareBrackets(query);  
+  query = escapeBraces(query);  
+  query = escapeCaret(query);  
+  query = escapeSquiggle(query);  
+  query = escapeDoubleAmpersands(query);  
+  query = escapeDoubleBars(query);  
+  return query;
+}
+
+function getQueryValue(queryArg)
+{
+  var query;
+  // check if its a form field
+  if(typeof(queryArg.form) != "undefined")
+  {
+    query = queryArg.value;
+  }
+  else
+  {
+    query = queryArg;
+  }
+  return query;
+}
+
+function escapeAsterisk(query)
+{
+  return query.replace(/[\*]/g, "\\*");
+}
+
+function escapeQuotes(query)
+{
+  return query.replace(/[\"]/g, "\\\"");
+}
+
+function escapeColon(query)
+{
+  return query.replace(/[\:]/g, "\\:");
+}
+
+function escapeQuestionMark(query)
+{
+  return query.replace(/[?]/g, "\\?");
+}
+
+function escapeExclamationMark(query)
+{
+  return query.replace(/[!]/g, "\\!");
+}
+
+function escapeParentheses(query)
+{
+  return query.replace(/[(]/g, "\\(").replace(/[)]/g, "\\)");
+}
+
+function escapeSquareBrackets(query)
+{
+  return query.replace(/[\[]/g, "\\[").replace(/[\]]/g, "\\]");
+}
+
+function escapeBraces(query)
+{
+  return query.replace(/[{]/g, "\\{").replace(/[}]/g, "\\}");
+}
+
+function escapeCaret(query)
+{
+  return query.replace(/[\^]/g, "\\^");
+}
+
+function escapeSquiggle(query)
+{
+  return query.replace(/[~]/g, "\\~");
+}
+
+function escapeDoubleAmpersands(query)
+{
+  return query.replace(/[&]{2}/g, "\\&\\&");
+}
+
+function escapeDoubleBars(query)
+{
+  return query.replace(/[\|]{2}/g, "\\|\\|");
+}
\ No newline at end of file
diff --git a/contrib/javascript/queryEscaper/testQueryEscaper.html b/contrib/javascript/queryEscaper/testQueryEscaper.html
new file mode 100644
index 0000000..d455f4a
--- /dev/null
+++ b/contrib/javascript/queryEscaper/testQueryEscaper.html
@@ -0,0 +1,121 @@
+<html>
+
+<head>
+<!-- Change Me -->
+<script language="JavaScript" src="jsUnitCore.js"></script>
+<script language="JavaScript" src="luceneQueryEscaper.js"></script>
+</head>
+<body>
+<script>
+function testGetQueryValue()
+{
+  var str = "The quick brown fox jumped over the lazy dog";
+  document.test.foobar.value = str;
+  assertEquals("Not getting field value correctly", str, getQueryValue(document.test.foobar));
+  assertEquals("Not getting string value correctly", str, getQueryValue(str));
+}
+
+function testNormalString()
+{
+  var str = "The quick brown fox jumped over the lazy dog";
+  assertEquals("Should not be escaping", str, escapeAsterisk(str));
+  assertEquals("Should not be escaping", str, escapeQuotes(str));
+  assertEquals("Should not be escaping", str, escapeColon(str));
+  assertEquals("Should not be escaping", str, escapeQuestionMark(str));
+  assertEquals("Should not be escaping", str, escapeExclamationMark(str));
+}
+
+function testEscapeAsterisk()
+{
+  var str = "foo*";
+  assertEquals("Not escaping " + str, "foo\\*", escapeAsterisk(str));
+  
+  str = " foo bar *";
+  assertEquals("Not escaping " + str, " foo bar \\*", escapeAsterisk(str));
+  
+  str = "foo* bar*";
+  assertEquals("Not escaping " + str, "foo\\* bar\\*", escapeAsterisk(str));  
+}
+
+function testEscapeQuotes()
+{
+  var str = "\"foo\"";
+  assertEquals("Not escaping " + str, "\\\"foo\\\"", escapeQuotes(str));
+}
+
+function testEscapeColon()
+{
+  var str = "foo:bar zoo:zaa";
+  assertEquals("Not escaping " + str, "foo\\:bar zoo\\:zaa", escapeColon(str));
+}
+
+function testEscapeQuestionMark()
+{
+  var str = "foo? bar?";
+  assertEquals("Not escaping " + str, "foo\\? bar\\?", escapeQuestionMark(str));
+}
+
+function testEscapeExclamationMark()
+{
+  var str = "foo! bar!";
+  assertEquals("Not escaping " + str, "foo\\! bar\\!", escapeExclamationMark(str));
+}
+
+function testEscapeParentheses()
+{
+  var str = "foo (bar) (me)";
+  assertEquals("Not escaping " + str, "foo \\(bar\\) \\(me\\)", escapeParentheses(str));
+}
+
+function testEscapeSquareBrackets()
+{
+  var str = "foo [bar] [me]";
+  assertEquals("Not escaping " + str, "foo \\[bar\\] \\[me\\]", escapeSquareBrackets(str));
+}
+
+function testEscapeBraces()
+{
+  var str = "foo {bar} {me}";
+  assertEquals("Not escaping " + str, "foo \\{bar\\} \\{me\\}", escapeBraces(str));
+}
+
+function testEscapeCaret()
+{
+  var str = "f^oo bar^ me";
+  assertEquals("Not escaping " + str, "f\\^oo bar\\^ me", escapeCaret(str));
+}
+
+function testEscapeSquiggle()
+{
+  var str = "f~oo bar~ me";
+  assertEquals("Not escaping " + str, "f\\~oo bar\\~ me", escapeSquiggle(str));
+}
+
+function testEscapeDoubleAmpersands()
+{
+  var str = "foo && bar me";
+  assertEquals("Not escaping " + str, "foo \\&\\& bar me", escapeDoubleAmpersands(str));
+
+  str = "foo && bar& m&e";
+  assertEquals("Not escaping " + str, "foo \\&\\& bar& m&e", escapeDoubleAmpersands(str));
+}
+
+function testEscapeDoubleBars()
+{
+  var str = "foo || bar me";
+  assertEquals("Not escaping " + str, "foo \\|\\| bar me", escapeDoubleBars(str));
+}
+
+function testDoEscapeQuery()
+{
+  var str = "The: quick*} {~brown? ^fox! (jumped:[over] || me) \"the && lazy: dog\"";
+  assertEquals("Not escaping " + str, "The\\: quick\\*\\} \\{\\~brown\\? \\^fox\\! \\(jumped\\:\\[over\\] \\|\\| me\\) \\\"the \\&\\& lazy\\: dog\\\"", doEscapeQuery(str));
+}
+
+
+</script>
+<form name="test">
+<input type="text" name="foobar">
+</form>
+</body>
+</html>
diff --git a/contrib/javascript/queryValidator/luceneQueryValidator.js b/contrib/javascript/queryValidator/luceneQueryValidator.js
new file mode 100644
index 0000000..6c02c34
--- /dev/null
+++ b/contrib/javascript/queryValidator/luceneQueryValidator.js
@@ -0,0 +1,291 @@
+// Author: Kelvin Tan  (kelvint at apache.org)
+// JavaScript Lucene Query Validator
+// Version: $Id$
+// Tested: IE 6.0.2800 and Mozilla Firebird 0.7
+
+// Special characters are + - && || ! ( ) { } [ ] ^ " ~ * ? : \
+// Special words are (case-sensitive) AND NOT OR
+
+// Makes wildcard queries case-insensitive if true.
+// Refer to http://www.mail-archive.com/lucene-user@jakarta.apache.org/msg00646.html
+var wildcardCaseInsensitive = true;
+
+// Mutator method for wildcardCaseInsensitive.
+// @param Should wildcard queries be case-insensitive?
+function setWildcardCaseInsensitive(bool)
+{
+  wildcardCaseInsensitive = bool;
+}
+
+// Should the user be prompted with an alert box if validation fails?
+var alertUser = true;
+
+function setAlertUser(bool)
+{
+  alertUser = bool;
+}
+
+// validates a lucene query.
+// @param Form field that contains the query
+function doCheckLuceneQuery(queryField)
+{
+  return doCheckLuceneQueryValue(queryField.value)
+}
+
+// validates a lucene query.
+// @param query string
+function doCheckLuceneQueryValue(query)
+{
+  if(query != null && query.length > 0)
+  {
+    query = removeEscapes(query);
+    
+    // check for allowed characters
+    if(!checkAllowedCharacters(query)) return false;
+    
+    // check * is used properly
+    if(!checkAsterisk(query)) return false;
+    
+    // check for && usage
+    if(!checkAmpersands(query)) return false;
+    
+    // check ^ is used properly 
+    if(!checkCaret(query)) return false;
+    
+    // check ~ is used properly
+    if(!checkSquiggle(query)) return false;
+    
+    // check ! is used properly 
+    if(!checkExclamationMark(query)) return false;
+    
+    // check question marks are used properly
+    if(!checkQuestionMark(query)) return false;
+    
+    // check parentheses are used properly
+    if(!checkParentheses(query)) return false;
+    
+    // check '+' and '-' are used properly      
+    if(!checkPlusMinus(query)) return false;
+    
+    // check AND, OR and NOT are used properly
+    if(!checkANDORNOT(query)) return false;    
+    
+    // check that quote marks are closed
+    if(!checkQuotes(query)) return false;
+    
+    // check ':' is used properly
+    if(!checkColon(query)) return false;
+    
+    if(wildcardCaseInsensitive)
+    {
+      if(query.indexOf("*") != -1)
+      {
+        var i = query.indexOf(':');
+        if(i == -1)
+        {
+          query.value = query.toLowerCase();
+        }
+        else // found a wildcard field search
+        {
+          query.value = query.substring(0, i) + query.substring(i).toLowerCase();
+        }
+      }
+    }
+    return true;
+  }
+}
+
+// remove the escape character and the character immediately following it
+function removeEscapes(query)
+{
+  return query.replace(/\\./g, "");
+}
+
+function checkAllowedCharacters(query)
+{
+  matches = query.match(/[^a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'= ]/);
+  if(matches != null && matches.length > 0)
+  {
+    if(alertUser) alert("Invalid search query! The allowed characters are a-z A-Z 0-9.  _ + - : () \" & * ? | ! {} [ ] ^ ~ \\ @ = # % $ ' /. Please try again.")
+    return false;
+  }
+  return true;
+}
+
+function checkAsterisk(query)
+{
+  matches = query.match(/^[\*]*$|[\s]\*|^\*[^\s]/);
+  if(matches != null)
+  {
+    if(alertUser) alert("Invalid search query! The wildcard (*) character must be preceded by at least one alphabet or number. Please try again.")
+    return false;
+  }
+  return true;
+}
+
+function checkAmpersands(query)
+{
+  // NB: doesn't handle term1 && term2 && term3 in Firebird 0.7
+  matches = query.match(/[&]{2}/);
+  if(matches != null && matches.length > 0)
+  {
+    matches = query.match(/^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+( && )?[a-zA-Z0-9_+\-:.()\"*?|!{}\[\]\^~\\@#\/$%'=]+[ ]*)+$/); // note missing & in pattern
+    if(matches == null)
+    {
+      if(alertUser) alert("Invalid search query! Queries containing the special characters && must be in the form: term1 && term2. Please try again.")
+      return false;
+    }
+  }
+  return true;
+}
+
+function checkCaret(query)
+{
+  //matches = query.match(/^[^\^]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\~\\@#\/]+(\^[\d]+)?[ ]*)+$/); // note missing ^ in pattern
+  matches = query.match(/[^\\]\^([^\s]*[^0-9.]+)|[^\\]\^$/);
+  if(matches != null)
+  {
+    if(alertUser) alert("Invalid search query! The caret (^) character must be preceded by alphanumeric characters and followed by numbers. Please try again.")
+    return false;
+  }
+  return true;
+}
+
+function checkSquiggle(query)
+{
+  //matches = query.match(/^[^~]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^\\@#\/]+(~[\d.]+|[^\\]\\~)?[ ]*)+$/); // note missing ~ in pattern
+  matches = query.match(/[^\\]~[^\s]*[^0-9\s]+/);
+  if(matches != null)
+  {
+    if(alertUser) alert("Invalid search query! The tilde (~) character must be preceded by alphanumeric characters and followed by numbers. Please try again.")
+    return false;
+  }    
+  return true;
+}
+
+function checkExclamationMark(query)
+{
+  // foo! is not a query, but !foo is. hmmmm...
+  // NB: doesn't handle term1 ! term2 ! term3 or term1 !term2
+  matches = query.match(/^[^!]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+( ! )?[a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+[ ]*)+$/);
+  if(matches == null || matches.length == 0)
+  {
+    if(alertUser) alert("Invalid search query! Queries containing the special character ! must be in the form: term1 ! term2. Please try again.")
+    return false;
+  }
+  
+  
+  return true;
+}
+
+function checkQuestionMark(query)
+{
+  matches = query.match(/^(\?)|([^a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]\?+)/);
+  if(matches != null && matches.length > 0)
+  {
+      if(alertUser) alert("Invalid search query! The question mark (?) character must be preceded by at least one alphabet or number. Please try again.")
+    return false;
+  }
+  return true;
+}
+
+function checkParentheses(query)
+{
+  var hasLeft = false;
+  var hasRight = false;
+  matchLeft = query.match(/[(]/g);
+  if(matchLeft != null) hasLeft = true
+  matchRight = query.match(/[)]/g);
+  if(matchRight != null) hasRight = true;
+  
+  if(hasLeft || hasRight)
+  {
+    if(hasLeft && !hasRight || hasRight && !hasLeft)
+    {
+        if(alertUser) alert("Invalid search query! Parentheses must be closed. Please try again.")
+        return false;
+    }
+    else
+    {
+      var number = matchLeft.length + matchRight.length;
+      if((number % 2) > 0 || matchLeft.length != matchRight.length)
+      {
+        if(alertUser) alert("Invalid search query! Parentheses must be closed. Please try again.")
+        return false;
+      }    
+    }
+    matches = query.match(/\(\)/);
+    if(matches != null)
+    {
+      if(alertUser) alert("Invalid search query! Parentheses must contain at least one character. Please try again.")
+      return false;    
+    }
+  }  
+  return true;    
+}
+
+function checkPlusMinus(query)
+{
+  matches = query.match(/^[^\n+\-]*$|^([+-]?[a-zA-Z0-9_:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+[ ]?)+$/);
+  if(matches == null || matches.length == 0)
+  {
+    if(alertUser) alert("Invalid search query! '+' and '-' modifiers must be followed by at least one alphabet or number. Please try again.")
+    return false;
+  }
+  return true;
+}
+
+function checkANDORNOT(query)
+{
+  matches = query.match(/AND|OR|NOT/);
+  if(matches != null && matches.length > 0)
+  {
+    matches = query.match(/^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@\/#$%'=]+\s*((AND )|(OR )|(AND NOT )|(NOT ))?[a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@\/#$%'=]+[ ]*)+$/);       
+    if(matches == null || matches.length == 0)
+    {
+      if(alertUser) alert("Invalid search query!  Queries containing AND/OR/NOT must be in the form: term1 AND|OR|NOT|AND NOT term2 Please try again.")
+      return false;
+    }
+    
+    // its difficult to distinguish AND/OR/... from the usual [a-zA-Z] because they're...words!
+    matches = query.match(/^((AND )|(OR )|(AND NOT )|(NOT ))|((AND)|(OR)|(AND NOT )|(NOT))[ ]*$/)
+    if(matches != null && matches.length > 0)
+    {
+      if(alertUser) alert("Invalid search query!  Queries containing AND/OR/NOT must be in the form: term1 AND|OR|NOT|AND NOT term2 Please try again.")
+      return false;
+    }
+  }
+  return true;
+}
+
+function checkQuotes(query)
+{
+  matches = query.match(/\"/g);
+  if(matches != null && matches.length > 0)
+  {
+    var number = matches.length;
+    if((number % 2) > 0)
+    {
+      if(alertUser) alert("Invalid search query! Please close all quote (\") marks.");
+      return false;
+    }
+    matches = query.match(/""/);
+    if(matches != null)
+    {
+      if(alertUser) alert("Invalid search query! Quotes must contain at least one character. Please try again.")
+      return false;    
+    }    
+  }
+  return true;
+}
+
+function checkColon(query)
+{
+  matches = query.match(/[^\\\s]:[\s]|[^\\\s]:$|[\s][^\\]?:|^[^\\\s]?:/);
+  if(matches != null)
+  {
+    if(alertUser) alert("Invalid search query! Field declarations (:) must be preceded by at least one alphabet or number and followed by at least one alphabet or number. Please try again.")
+    return false;
+  }
+  return true;
+}
\ No newline at end of file
diff --git a/contrib/javascript/queryValidator/testQueryValidator.html b/contrib/javascript/queryValidator/testQueryValidator.html
new file mode 100644
index 0000000..09569a3
--- /dev/null
+++ b/contrib/javascript/queryValidator/testQueryValidator.html
@@ -0,0 +1,603 @@
+<html>
+
+<head>
+<script language="JavaScript" src="c:/market/jsunit/app/jsUnitCore.js"></script>
+<script language="JavaScript" src="luceneQueryValidator.js"></script>
+</head>
+<body>
+<script>
+setAlertUser(false);
+testCheckParentheses()
+// additions to jsUnit
+function assertTrue(comment, value)
+{
+  return assertEquals(comment, true, value);
+}
+
+function assertFalse(comment, value)
+{
+  return assertEquals(comment, false, value);
+}
+
+function testRemoveEscapes()
+{
+  var query = "\\* foo \\haha";
+  assertEquals(query, " foo aha", removeEscapes(query));
+  query = "\\\\foo";
+  assertEquals(query, "foo", removeEscapes(query));
+  query = "foo\\\"";
+  assertEquals(query, "foo", removeEscapes(query));
+}
+
+function testCheckAllowedCharacters()
+{
+  var query ="a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#/$%'= ";
+  assertTrue(query, checkAllowedCharacters(query));
+  
+  query = "foobar";
+  assertFalse(query, checkAllowedCharacters(query));
+}
+
+function testQueryParser()
+{
+  // taken from TestQueryParser.java
+  query = "a AND b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "(a AND b)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+a +b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "c OR (a AND b)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "c (+a +b)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a AND NOT b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+a -b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a AND -b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  //query = "a AND !b"; 
+  //assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a && b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  //query = "a && ! b";
+  //assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a OR b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a || b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  //query = "a OR !b";
+  //assertTrue(query, doCheckLuceneQueryValue(query));
+  //query = "a OR ! b";
+  //assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "a OR -b";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+term -term term";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "foo:term AND field:anotherTerm";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "term AND \"phrase phrase\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "\"hello there\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "germ term^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "(term)^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "term^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "(germ term)^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "term^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "term^2";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "\"germ term\"^2.0";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "\"term germ\"^2";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "(foo OR bar) AND (baz OR boo)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+(foo bar) +(baz boo)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "((a OR b) AND NOT c) OR d";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "(+(a b) -c) d";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+(apple \"steve jobs\") -(foo bar baz)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+(apple \"steve jobs\") -(foo bar baz)";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+title:(dog OR cat) -author:\"bob dole\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  query = "+(title:dog title:cat) -author:\"bob dole\"";    
+  assertTrue(query, doCheckLuceneQueryValue(query));
+}
+
+function testCheckAsterisk()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkAsterisk(query));
+  
+  query = "foo bar12* is ok*";
+  assertTrue(query, checkAsterisk(query));
+  
+  query = "foo bar12*sdsd";
+  assertTrue(query, checkAsterisk(query));
+
+  query = "foo bar12*sd**sd";
+  assertTrue(query, checkAsterisk(query));
+
+  query = "*bar12";
+  assertFalse(query, checkAsterisk(query));
+
+  query = "*ba12r*";
+  assertFalse(query, checkAsterisk(query));
+
+  query = "bar* *bar";
+  assertFalse(query, checkAsterisk(query));
+
+  query = "*";
+  assertFalse(query, checkAsterisk(query));  
+
+  query = "*bar";
+  assertFalse(query, checkAsterisk(query));  
+
+  // test with a space in front
+  query = " *bar";
+  assertFalse(query, checkAsterisk(query));  
+
+  // test the escaped case
+  query = "bar* \\*bar";
+  assertTrue(query, checkAsterisk(query));  
+
+  // try including other special characters
+  query = "foo:bar*ba?r";
+  assertTrue(query, checkAsterisk(query));
+
+  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
+  assertTrue(query, checkAsterisk(query));
+}
+
+function testCheckAmpersands()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkAmpersands(query));
+  
+  query = "foo & bar";
+  assertTrue(query, checkAmpersands(query));
+
+  query = "foo & bar& metoo &";
+  assertTrue(query, checkAmpersands(query));
+
+  query = "foo && bar12isok";
+  assertTrue(query, checkAmpersands(query));
+
+  query = "foo && ! bar";
+  assertTrue(query, checkAmpersands(query));
+
+  query = "bar12 &&";
+  assertFalse(query, checkAmpersands(query));
+  
+  query = "bar12 && bar12 &&";
+  assertFalse(query, checkAmpersands(query));
+  
+  query = "bar12 && ";
+  assertFalse(query, checkAmpersands(query));
+ }
+
+function testCheckCaret()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkCaret(query));
+  
+  var query = "foo bar12isok^1.0";
+  assertTrue(query, checkCaret(query));
+  
+  query = "\"jakarta apache\"^10";
+  assertTrue(query, checkCaret(query));
+
+  query = "bar12^";
+  assertFalse(query, checkCaret(query));
+  
+  query = "bar12^10 bar12^";
+  assertFalse(query, checkCaret(query));
+  
+  query = "bar12^ ";
+  assertFalse(query, checkCaret(query));
+
+  query = "bar12^ me too";
+  assertFalse(query, checkCaret(query));
+  
+  query = "bar12^foo";
+  assertFalse(query, checkCaret(query));
+
+  query = "bar12^1.foo";
+  assertFalse(query, checkCaret(query));
+  
+  // test the escaped case
+  query = "\\^";
+  assertTrue(query, checkCaret(query));  
+
+  query = "bar\\^";
+  assertTrue(query, checkCaret(query));  
+
+  // try including other special characters
+  query = "bar*ba?r^1.0";
+  assertTrue(query, checkCaret(query));
+}
+
+function testCheckSquiggle()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkSquiggle(query));
+  
+  var query = "foo bar12isok~10";
+  assertTrue(query, checkSquiggle(query));
+  
+  query = "\"jakarta apache\"~10";
+  assertTrue(query, checkSquiggle(query));
+
+  query = "bar12~";
+  assertTrue(query, checkSquiggle(query));
+  
+  query = "bar12~10 bar12~";
+  assertTrue(query, checkSquiggle(query));
+  
+  query = "bar12~ ";
+  assertTrue(query, checkSquiggle(query));
+
+  query = "bar12~foo";
+  assertFalse(query, checkSquiggle(query));
+  
+  query = "bar12~1f";
+  assertFalse(query, checkSquiggle(query))  
+
+  // test the escaped case
+  query = "\\~";
+  assertTrue(query, checkSquiggle(query));  
+
+  query = "bar\\~";
+  assertTrue(query, checkSquiggle(query));  
+
+  // try including other special characters
+  query = "bar*ba?r~10";
+  assertTrue(query, checkSquiggle(query));
+
+  // FIXME: how about floating point proximity searches, e.g. foo~2.5
+}
+
+function testCheckExclamationMark()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkExclamationMark(query));
+  
+  query = "foo ! bar";
+  assertTrue(query, checkExclamationMark(query));
+  
+  query = "\"foo\" ! \"bar\"";
+  assertTrue(query, checkExclamationMark(query));
+
+  query = "foo!";
+  assertTrue(query, checkExclamationMark(query));
+  
+  query = "foo && ! bar";
+  assertTrue(query, checkExclamationMark(query));  
+
+  query = "foo && !bar";
+  assertTrue(query, checkExclamationMark(query));  
+
+  query = "! bar";
+  assertFalse(query, checkExclamationMark(query));
+
+  query = "foo !";
+  assertFalse(query, checkExclamationMark(query));
+
+  query = "foo ! ";
+  assertFalse(query, checkExclamationMark(query));
+  
+  // test escaped case
+  query = "foo \\!";
+  assertTrue(query, checkExclamationMark(query));
+
+  query = "foo ! bar \\!";
+  assertTrue(query, checkExclamationMark(query));  
+  
+  query = "foo ! bar ! car";
+  assertTrue(query, checkExclamationMark(query));
+
+  query = "foo ! bar !";
+  assertFalse(query, checkExclamationMark(query));
+  
+  query = "foo ! bar !   ";
+  assertFalse(query, checkExclamationMark(query));
+
+  // try more complex queries
+  query = "(foo bar) ! (car:dog*)";
+  assertTrue(query, checkExclamationMark(query));
+}
+
+function testCheckQuestionMark()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkQuestionMark(query));
+
+  query = "foo bar12? is ok?";
+  assertTrue(query, checkQuestionMark(query));
+  
+  query = "foo bar12?sdsd";
+  assertTrue(query, checkQuestionMark(query));
+
+  query = "foo bar12?sd??sd";
+  assertTrue(query, checkQuestionMark(query));
+
+  query = "?bar12";
+  assertFalse(query, checkQuestionMark(query));
+
+  query = "?ba12r?";
+  assertFalse(query, checkQuestionMark(query));
+
+  query = "bar? ?bar";
+  assertFalse(query, checkQuestionMark(query));
+
+  // test with a space in front
+  query = " ?bar";
+  assertFalse(query, checkQuestionMark(query));  
+
+  // test the escaped case
+  query = "bar? \\?bar";
+  assertTrue(query, checkQuestionMark(query));  
+
+  // try including other special characters
+  query = "foo:bar*ba?r";
+  assertTrue(query, checkQuestionMark(query));
+
+  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
+  assertTrue(query, checkQuestionMark(query));
+}
+
+function testCheckParentheses()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkParentheses(query));
+
+  query = "(foobar12:isok)";
+  assertTrue(query, checkParentheses(query));
+  
+  query = "(foobar12):(sdsd* me too)";
+  assertTrue(query, checkParentheses(query));
+
+  query = "(bar12";
+  assertFalse(query, checkParentheses(query));
+
+  query = "ba12r)";
+  assertFalse(query, checkParentheses(query));
+
+  query = "()";
+  assertFalse(query, checkParentheses(query));
+
+  query = "))";
+  assertFalse(query, checkParentheses(query));
+
+  query = "(foo bar) (bar";
+  assertFalse(query, checkParentheses(query));
+
+  query = "(foo bar) bar) me too";
+  assertFalse(query, checkParentheses(query));
+
+  // test with a space in front
+  query = " (bar";
+  assertFalse(query, checkParentheses(query));  
+
+  // test the escaped case
+  query = "foo\\)";
+  assertTrue(query, doCheckLuceneQueryValue(query));  
+
+  query = "foo\\) (foo bar)";
+  assertTrue(query, doCheckLuceneQueryValue(query));  
+
+  // try including other special characters
+  query = "-(foo bar*ba?r)";
+  assertTrue(query, checkParentheses(query));
+
+  query = "+foo:(ba*ba?r zoo -(zaa zoo))";
+  assertTrue(query, checkParentheses(query));
+  
+  query = "((bar12";
+  assertFalse(query, checkParentheses(query));  
+  
+  query = "((bar12)";
+  assertFalse(query, checkParentheses(query));    
+}
+
+function testCheckPlusMinus()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkPlusMinus(query));
+  
+  query = "+bar -foo";
+  assertTrue(query, checkPlusMinus(query));   
+   
+  // is this allowed?
+  query = "baa+foo +foo-bar";
+  assertTrue(query, checkPlusMinus(query));  
+
+  query = "baa+";
+  assertFalse(query, checkPlusMinus(query));   
+  
+  query = "++baa";
+  assertFalse(query, checkPlusMinus(query));   
+
+  query = "+";
+  assertFalse(query, checkPlusMinus(query));   
+
+  query = "-";
+  assertFalse(query, checkPlusMinus(query));   
+  
+  // test the escaped case
+  query = "foo\\+";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+  
+  // try including other special characters
+  query = "-(foo bar*ba?r)";
+  assertTrue(query, checkParentheses(query));
+
+  query = "+foo:(ba*ba?r zoo -(zaa zoo))";
+  assertTrue(query, checkParentheses(query));  
+}
+
+function testCheckANDORNOT()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkANDORNOT(query));
+  
+  query = "foo AND bar";
+  assertTrue(query, checkANDORNOT(query));
+  
+  query = "foo OR bar";
+  assertTrue(query, checkANDORNOT(query));
+  
+  query = "foo NOT bar";
+  assertTrue(query, checkANDORNOT(query));
+
+  query = "foo AND NOT bar";
+  assertTrue(query, checkANDORNOT(query));
+
+  query = "foo NOT bar -foobar";
+  assertTrue(query, checkANDORNOT(query));
+
+  query = "foo AND bar dog AND NOT fox";
+  assertTrue(query, checkANDORNOT(query));
+
+  query = "foo and";
+  assertTrue(query, checkANDORNOT(query));
+
+  query = "and bar";
+  assertTrue(query, checkANDORNOT(query)); 
+
+  query = "fooAND bar";
+  assertTrue(query, checkANDORNOT(query)); 
+
+  query = "foo ANDbar";
+  assertTrue(query, checkANDORNOT(query)); 
+
+  query = "AND bar";
+  assertFalse(query, checkANDORNOT(query));
+
+  query = "OR bar";
+  assertFalse(query, checkANDORNOT(query));  
+
+  query = "NOT bar";
+  assertFalse(query, checkANDORNOT(query));  
+
+  query = "foo AND";
+  assertFalse(query, checkANDORNOT(query));  
+
+  query = "foo AND "; // note the space
+  assertFalse(query, checkANDORNOT(query));  
+
+  query = "AND AND";
+  assertFalse(query, checkANDORNOT(query));
+
+  query = "AND";
+  assertFalse(query, checkANDORNOT(query));
+}
+
+function testCheckQuotes()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkQuotes(query));
+
+  query = "\"foobar12:isok\"";
+  assertTrue(query, checkQuotes(query));
+  
+  query = "\"(foobar12)\":(sdsd* me too)";
+  assertTrue(query, checkQuotes(query));
+
+  query = "\"bar12";
+  assertFalse(query, checkQuotes(query));
+  
+  query = "\"\"";
+  assertFalse(query, checkQuotes(query));  
+
+  query = "ba12r\"";
+  assertFalse(query, checkQuotes(query));
+  
+  query = "\"foo bar\" \"bar";
+  assertFalse(query, checkQuotes(query));
+
+  query = "\"foo bar\" bar\" me too";
+  assertFalse(query, checkQuotes(query));
+
+  // test with a space in front
+  query = " \"bar";
+  assertFalse(query, checkQuotes(query));  
+
+  // test the escaped case
+  query = "foo\\\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));  
+
+  query = "foo\\\" \"foo bar\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));  
+
+  // try including other special characters
+  query = "\"foo bar*ba?r\"";
+  assertTrue(query, checkQuotes(query));
+
+  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
+  assertTrue(query, checkQuotes(query));
+
+  query = "\\\"\\\"bar12\\\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+
+  query = "\\\"\\\"bar12\\\"\\\"";
+  assertTrue(query, doCheckLuceneQueryValue(query));
+}
+
+function testCheckColon()
+{
+  var query = "foo bar is ok";
+  assertTrue(query, checkColon(query));
+
+  query = "foobar12:isok";
+  assertTrue(query, checkColon(query));
+  
+  query = "(foobar12):(sdsd* me too)";
+  assertTrue(query, checkColon(query));
+
+  query = "bar12:";
+  assertFalse(query, checkColon(query));
+
+  query = ":ba12r";
+  assertFalse(query, checkColon(query));
+
+  query = "foo:bar :bar";
+  assertFalse(query, checkColon(query));
+
+  query = "foo:bar bar: me too";
+  assertFalse(query, checkColon(query));
+
+  // test with a space in front
+  query = " :bar";
+  assertFalse(query, checkColon(query));  
+
+  // test the escaped case
+  query = "foo\\:";
+  assertTrue(query, checkColon(query));  
+
+  query = "foo\\: foo:bar";
+  assertTrue(query, checkColon(query));  
+
+  // try including other special characters
+  query = "foo:bar*ba?r";
+  assertTrue(query, checkColon(query));
+
+  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
+  assertTrue(query, checkColon(query));
+}
+</script>
+</body>
+</html>
diff --git a/contrib/lucli/META-INF/MANIFEST.MF b/contrib/lucli/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..bd81eaf
--- /dev/null
+++ b/contrib/lucli/META-INF/MANIFEST.MF
@@ -0,0 +1,2 @@
+Main-Class: lucli.Lucli
+Class-Path: lib/libreadline-java.jar lib/lucene.jar
diff --git a/contrib/lucli/README b/contrib/lucli/README
new file mode 100644
index 0000000..3b673f0
--- /dev/null
+++ b/contrib/lucli/README
@@ -0,0 +1,29 @@
+lucli (pronounced Luckily) is the Lucene Command Line Interface.
+
+INSTALLATION
+
+Edit the run.sh shell script
+	Edit JAVA_HOME to point to your java directory.
+	Edit LUCLI to point to where you installed lucli.
+	Edit LUCLI_MEMORY and set it to the maximum amount of memory you want to allocate to lucli
+	You can also replace the Lucene jar file that came with lucli with your own.
+
+
+ENABLING READLINE
+
+If you add the -r command line parameter lucli will try to use a shared library 
+to enable things like tab completion and history. Unfortunately Java doesn't support 
+this capability natively so you'll need a shared library for this. I'm including one
+that worked for me with Debian Linux.
+For more details about GNU readline and java see http://java-readline.sourceforge.net/
+which is the library that lucli uses.
+
+
+Documentation
+
+There is none :-). Type help at the command line or read the code.
+
+Enjoy
+
+Dror Matalon
+dror@zapatec.com.
diff --git a/contrib/lucli/build.xml b/contrib/lucli/build.xml
new file mode 100644
index 0000000..9e8a970
--- /dev/null
+++ b/contrib/lucli/build.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+
+<project name="lucli" default="default">
+
+  <description>
+    Lucene Command Line Interface
+  </description>
+
+
+  <path id="additional.dependencies">
+    <pathelement location="lib/libreadline-java.jar"/>
+  </path>
+
+  <pathconvert property="project.classpath"
+               targetos="unix"
+               refid="additional.dependencies"
+  />
+
+  <property name="src.dir" location="src"/>
+
+  <target name="dist" depends="compile" description="Create JAR">
+    <jar jarfile="${dist.dir}/${dist.name}.jar"
+         basedir="${build.classes.dir}"
+         manifest="META-INF/MANIFEST.MF"
+    />
+  </target>
+
+  <import file="../common.xml"/>
+</project>
diff --git a/contrib/lucli/lib/README b/contrib/lucli/lib/README
new file mode 100644
index 0000000..d3d6512
--- /dev/null
+++ b/contrib/lucli/lib/README
@@ -0,0 +1 @@
+Place libreadline-java.jar.
diff --git a/contrib/lucli/run.sh b/contrib/lucli/run.sh
new file mode 100755
index 0000000..cd0df9d
--- /dev/null
+++ b/contrib/lucli/run.sh
@@ -0,0 +1,12 @@
+LUCLI=.
+LUCLI_MEMORY=128M
+#JAVA_HOME=/home/dror/j2sdk1.4.1_03/
+CLASSPATH=${CLASSPATH}:$LUCLI/lib/libreadline-java.jar:$LUCLI/lib/lucene.jar:$LUCLI/dist/lucli-dev.jar
+PATH=${PATH}:$JAVA_HOME/bin
+LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$LUCLI
+export LD_LIBRARY_PATH
+export CLASSPATH
+$JAVA_HOME/bin/java -Xmx${LUCLI_MEMORY} lucli.Lucli
+#Use this line to enable tab completion. Depends on the Readline shares library
+#$JAVA_HOME/bin/java lucli.Lucli -r
+
diff --git a/contrib/lucli/src/lucli/Completer.java b/contrib/lucli/src/lucli/Completer.java
new file mode 100644
index 0000000..a726726
--- /dev/null
+++ b/contrib/lucli/src/lucli/Completer.java
@@ -0,0 +1,118 @@
+package lucli;
+
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+import org.gnu.readline.*;
+import java.util.Iterator;
+import java.util.TreeMap;
+
+/**
+ * Provide for tab completion
+ * When the user types a tab do the standard thing: complete the command
+ * Two tabs show all possible completions.
+ */
+
+
+public class Completer implements ReadlineCompleter {
+
+	String[] words; //list of words
+	int currentPosition = 0; //current position in the array
+
+	/**
+		Default constructor.
+		*/
+
+	public Completer (TreeMap wordMap) {
+		int size = wordMap.size();
+		words = new String[size];
+		Iterator wordIterator = wordMap.keySet().iterator();
+		for (int ii=0; wordIterator.hasNext(); ii++) {
+			words[ii] = (String) wordIterator.next();
+		}
+	}
+
+
+	/**
+		Return possible completion. Implements org.gnu.readline.ReadlineCompleter.
+		*/
+
+	public String completer (String text, int state) {
+
+		String ret = null; //what we're returning
+		for (int ii = currentPosition; ii < words.length; ii++) {
+			if (words[ii].startsWith(text)) {
+				int next = ii + 1;
+				if ((next < words.length) && words[next].startsWith(text)) {
+					//more than one word match
+					currentPosition = ii + 1; //next time start with next one
+					ret = words[ii];
+					break;
+				} else { //found the last one
+					if (state == 0) { //if it's the only one
+						ret = words[ii];
+						break;
+					} else {
+						ret = null; //there were previous ones
+						break;
+					}
+				}
+			}
+		}
+		if (ret == null)
+			currentPosition = 0; //for next search
+		//System.out.println("returned:" + ret);
+		return (ret); //no more matches
+	}
+}
diff --git a/contrib/lucli/src/lucli/LuceneMethods.java b/contrib/lucli/src/lucli/LuceneMethods.java
new file mode 100644
index 0000000..15bae4b
--- /dev/null
+++ b/contrib/lucli/src/lucli/LuceneMethods.java
@@ -0,0 +1,380 @@
+package lucli;
+
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+import java.io.IOException;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+
+import java.util.Hashtable;
+import java.util.Vector;
+import java.util.TreeMap;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Enumeration;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.Token;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermEnum;
+import org.apache.lucene.queryParser.MultiFieldQueryParser;
+import org.apache.lucene.queryParser.ParseException;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Hits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Searcher;
+
+/*
+ * Parts addapted from Lucene demo. Various methods that interact with
+ * Lucene and provide info about the index, search, etc.
+ */
+
+class LuceneMethods {
+
+  private int numDocs;
+  private String indexName; //directory of this index
+  java.util.Iterator fieldIterator;
+  Vector fields; //Fields as a vector
+  Vector indexedFields; //Fields as a vector
+  String fieldsArray[]; //Fields as an array
+  Searcher searcher;
+  Query query; //current query string
+
+  public LuceneMethods(String index) {
+    indexName = index;
+    message("Lucene CLI. Using directory '" + indexName + "'. Type 'help' for instructions.");
+  }
+
+
+  public void info() throws java.io.IOException {
+    IndexReader indexReader = IndexReader.open(indexName);
+
+
+    getFieldInfo();
+    numDocs = indexReader.numDocs();
+    message("Index has " + numDocs + " documents ");
+    message("All Fields:" + fields.toString());
+    message("Indexed Fields:" + indexedFields.toString());
+
+    if (IndexReader.isLocked(indexName)) {
+      message("Index is locked");
+    }
+    //IndexReader.getCurrentVersion(indexName);
+    //System.out.println("Version:" + version);
+
+    indexReader.close();
+  }
+
+
+  public void search(String queryString, boolean explain, boolean showTokens) throws java.io.IOException, org.apache.lucene.queryParser.ParseException {
+    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
+    Hits hits = initSearch(queryString);
+    System.out.println(hits.length() + " total matching documents");
+    if (explain) {
+      query = explainQuery(queryString);
+    }
+
+
+    final int HITS_PER_PAGE = 10;
+    message("--------------------------------------");
+    for (int start = 0; start < hits.length(); start += HITS_PER_PAGE) {
+      int end = Math.min(hits.length(), start + HITS_PER_PAGE);
+      for (int ii = start; ii < end; ii++) {
+        Document doc = hits.doc(ii);
+        message("---------------- " + (ii + 1) + " score:" + hits.score(ii) + "---------------------");
+        printHit(doc);
+        if (showTokens) {
+          invertDocument(doc);
+        }
+        if (explain) {
+          Explanation exp = searcher.explain(query, hits.id(ii));
+          message("Explanation:" + exp.toString());
+        }
+      }
+      message("#################################################");
+
+      if (hits.length() > end) {
+        System.out.print("more (y/n) ? ");
+        queryString = in.readLine();
+        if (queryString.length() == 0 || queryString.charAt(0) == 'n')
+          break;
+      }
+    }
+    searcher.close();
+  }
+
+  /**
+   * @todo Allow user to specify what field(s) to display
+   */
+  private void printHit(Document doc) {
+    for (int ii = 0; ii < fieldsArray.length; ii++) {
+      String currField = fieldsArray[ii];
+      String[] result = doc.getValues(currField);
+      if (result != null) {
+        for (int i = 0; i < result.length; i++) {
+          message(currField + ":" + result[i]);
+        }
+      } else {
+        message(currField + ": <not available>");
+      }
+    }
+    //another option is to just do message(doc);
+  }
+
+  public void optimize() throws IOException {
+    //open the index writer. False: don't create a new one
+    IndexWriter indexWriter = new IndexWriter(indexName, new StandardAnalyzer(), false);
+    message("Starting to optimize index.");
+    long start = System.currentTimeMillis();
+    indexWriter.optimize();
+    message("Done optimizing index. Took " + (System.currentTimeMillis() - start) + " msecs");
+    indexWriter.close();
+  }
+
+
+  private Query explainQuery(String queryString) throws IOException, ParseException {
+
+    searcher = new IndexSearcher(indexName);
+    Analyzer analyzer = new StandardAnalyzer();
+    getFieldInfo();
+
+    MultiFieldQueryParser parser = new MultiFieldQueryParser(queryString, analyzer);
+
+    int arraySize = indexedFields.size();
+    String indexedArray[] = new String[arraySize];
+    for (int ii = 0; ii < arraySize; ii++) {
+      indexedArray[ii] = (String) indexedFields.get(ii);
+    }
+    query = parser.parse(queryString, indexedArray, analyzer);
+    System.out.println("Searching for: " + query.toString());
+    return (query);
+
+  }
+
+  /**
+   * @todo Allow user to specify analyzer
+   */
+  private Hits initSearch(String queryString) throws IOException, ParseException {
+
+    searcher = new IndexSearcher(indexName);
+    Analyzer analyzer = new StandardAnalyzer();
+    getFieldInfo();
+
+    MultiFieldQueryParser parser = new MultiFieldQueryParser(queryString, analyzer);
+
+    int arraySize = fields.size();
+    fieldsArray = new String[arraySize];
+    for (int ii = 0; ii < arraySize; ii++) {
+      fieldsArray[ii] = (String) fields.get(ii);
+    }
+    query = parser.parse(queryString, fieldsArray, analyzer);
+    System.out.println("Searching for: " + query.toString());
+    Hits hits = searcher.search(query);
+    return (hits);
+
+  }
+
+  public void count(String queryString) throws java.io.IOException, ParseException {
+    Hits hits = initSearch(queryString);
+    System.out.println(hits.length() + " total documents");
+    searcher.close();
+  }
+
+  static public void message(String s) {
+    System.out.println(s);
+  }
+
+  private void getFieldInfo() throws IOException {
+    IndexReader indexReader = IndexReader.open(indexName);
+    fields = new Vector();
+    indexedFields = new Vector();
+
+    //get the list of all field names
+    fieldIterator = indexReader.getFieldNames().iterator();
+    while (fieldIterator.hasNext()) {
+      Object field = fieldIterator.next();
+      if (field != null && !field.equals(""))
+        fields.add(field.toString());
+    }
+    //
+    //get the list of indexed field names
+    fieldIterator = indexReader.getFieldNames(true).iterator();
+    while (fieldIterator.hasNext()) {
+      Object field = fieldIterator.next();
+      if (field != null && !field.equals(""))
+        indexedFields.add(field.toString());
+    }
+    indexReader.close();
+  }
+
+
+  // Copied from DocumentWriter
+  // Tokenizes the fields of a document into Postings.
+  private void invertDocument(Document doc)
+    throws IOException {
+
+    Hashtable tokenHash = new Hashtable();
+    final int maxFieldLength = 10000;
+
+    Analyzer analyzer = new StandardAnalyzer();
+    Enumeration fields = doc.fields();
+    while (fields.hasMoreElements()) {
+      Field field = (Field) fields.nextElement();
+      String fieldName = field.name();
+
+
+      if (field.isIndexed()) {
+        if (field.isTokenized()) {     // un-tokenized field
+          Reader reader;        // find or make Reader
+          if (field.readerValue() != null)
+            reader = field.readerValue();
+          else if (field.stringValue() != null)
+            reader = new StringReader(field.stringValue());
+          else
+            throw new IllegalArgumentException
+              ("field must have either String or Reader value");
+
+          int position = 0;
+          // Tokenize field and add to postingTable
+          TokenStream stream = analyzer.tokenStream(fieldName, reader);
+          try {
+            for (Token t = stream.next(); t != null; t = stream.next()) {
+              position += (t.getPositionIncrement() - 1);
+              position++;
+              String name = t.termText();
+              Integer Count = (Integer) tokenHash.get(name);
+              if (Count == null) { // not in there yet
+                tokenHash.put(name, new Integer(1)); //first one
+              } else {
+                int count = Count.intValue();
+                tokenHash.put(name, new Integer(count + 1));
+              }
+              if (position > maxFieldLength) break;
+            }
+          } finally {
+            stream.close();
+          }
+        }
+
+      }
+    }
+    Entry[] sortedHash = getSortedHashtableEntries(tokenHash);
+    for (int ii = 0; ii < sortedHash.length && ii < 10; ii++) {
+      Entry currentEntry = sortedHash[ii];
+      message((ii + 1) + ":" + currentEntry.getKey() + " " + currentEntry.getValue());
+    }
+  }
+
+
+  /** Provides a list of the top terms of the index.
+   *
+   * @param field  - the name of the command or null for all of them.
+   */
+  public void terms(String field) throws IOException {
+    TreeMap termMap = new TreeMap();
+    IndexReader indexReader = IndexReader.open(indexName);
+    TermEnum terms = indexReader.terms();
+    while (terms.next()) {
+      Term term = terms.term();
+      //message(term.field() + ":" + term.text() + " freq:" + terms.docFreq());
+      //if we're either not looking by field or we're matching the specific field
+      if ((field == null) || field.equals(term.field()))
+        termMap.put(term.field() + ":" + term.text(), new Integer((terms.docFreq())));
+    }
+
+    Iterator termIterator = termMap.keySet().iterator();
+    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {
+      String termDetails = (String) termIterator.next();
+      Integer termFreq = (Integer) termMap.get(termDetails);
+      message(termDetails + ": " + termFreq);
+    }
+    indexReader.close();
+  }
+
+  /** Sort Hashtable values
+   * @param h the hashtable we're sorting
+   * from http://developer.java.sun.com/developer/qow/archive/170/index.jsp
+   */
+
+  public static Entry[]
+    getSortedHashtableEntries(Hashtable h) {
+    Set set = h.entrySet();
+    Entry[] entries =
+      (Entry[]) set.toArray(
+        new Entry[set.size()]);
+    Arrays.sort(entries, new Comparator() {
+      public int compare(Object o1, Object o2) {
+        Object v1 = ((Entry) o1).getValue();
+        Object v2 = ((Entry) o2).getValue();
+        return ((Comparable) v2).compareTo(v1); //descending order
+      }
+    });
+    return entries;
+  }
+
+}
+
diff --git a/contrib/lucli/src/lucli/Lucli.java b/contrib/lucli/src/lucli/Lucli.java
new file mode 100644
index 0000000..dd551ef
--- /dev/null
+++ b/contrib/lucli/src/lucli/Lucli.java
@@ -0,0 +1,382 @@
+package lucli;
+
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+import java.io.*;
+import org.gnu.readline.*;
+import org.apache.lucene.queryParser.ParseException;
+import java.util.StringTokenizer;
+import java.util.TreeMap;
+import java.util.Iterator;
+
+/**
+ * lucli Main class for lucli: the Lucene Command Line Interface
+ * This class handles mostly the actual CLI part, command names, help, etc.
+ */
+
+public class Lucli {
+
+	final static String DEFAULT_INDEX = "index"; //directory "index" under the current directory
+	final static String HISTORYFILE = ".lucli"; //history file in user's home directory
+	public final static int MAX_TERMS = 100; //Maximum number of terms we're going to show
+
+	// List of commands
+	// To add another command, add it in here, in the list of addcomand(), and in the switch statement
+	final static int NOCOMMAND = -2;
+	final static int UNKOWN = -1;
+	final static int INFO = 0;
+	final static int SEARCH = 1;
+	final static int OPTIMIZE = 2;
+	final static int QUIT = 3;
+	final static int HELP = 4;
+	final static int COUNT = 5;
+	final static int TERMS = 6;
+	final static int INDEX = 7;
+	final static int TOKENS = 8;
+	final static int EXPLAIN = 9;
+
+	String fullPath;
+	TreeMap commandMap = new TreeMap();
+	LuceneMethods luceneMethods; //current cli class we're using
+	boolean enableReadline; //false: use plain java. True: shared library readline
+
+	/**
+		Main entry point. The first argument can be a filename with an
+		application initialization file.
+		*/
+
+	public Lucli(String[] args) throws ParseException, IOException {
+		String line;
+
+		fullPath = System.getProperty("user.home") +  System.getProperty("file.separator")
+			+ HISTORYFILE;
+
+		/*
+		 * Initialize the list of commands
+		 */
+
+		addCommand("info", INFO, "Display info about the current Lucene index. Example: info");
+		addCommand("search", SEARCH, "Search the current index. Example: search foo", 1);
+		addCommand("count", COUNT, "Return the number of hits for a search. Example: count foo", 1);
+		addCommand("optimize", OPTIMIZE, "Optimize the current index");
+		addCommand("quit", QUIT, "Quit/exit the program");
+		addCommand("help", HELP, "Display help about commands");
+		addCommand("terms", TERMS, "Show the first " + MAX_TERMS + " terms in this index. Supply a field name to only show terms in a specific field. Example: terms");
+		addCommand("index", INDEX, "Choose a different lucene index. Example index my_index", 1);
+		addCommand("tokens", TOKENS, "Does a search and shows the top 10 tokens for each document. Verbose! Example: tokens foo", 1);
+		addCommand("explain", EXPLAIN, "Explanation that describes how the document scored against query. Example: explain foo", 1);
+
+
+
+		//parse command line arguments
+		parseArgs(args);
+
+		if (enableReadline)
+			org.gnu.readline.Readline.load(ReadlineLibrary.GnuReadline  );
+		else
+			org.gnu.readline.Readline.load(ReadlineLibrary.PureJava  );
+
+		Readline.initReadline("lucli"); // init, set app name, read inputrc
+
+
+
+		Readline.readHistoryFile(fullPath);
+
+		// read history file, if available
+
+		File history = new File(".rltest_history");
+		try {
+			if (history.exists())
+				Readline.readHistoryFile(history.getName());
+		} catch (Exception e) {
+			System.err.println("Error reading history file!");
+		}
+
+		// Set word break characters
+		try {
+			Readline.setWordBreakCharacters(" \t;");
+		}
+		catch (UnsupportedEncodingException enc) {
+			System.err.println("Could not set word break characters");
+			System.exit(0);
+		}
+
+		// set completer with list of words
+
+		Readline.setCompleter(new Completer(commandMap));
+
+		// main input loop
+
+		luceneMethods = new LuceneMethods(DEFAULT_INDEX);
+
+		while (true) {
+			try {
+				line = Readline.readline("lucli> ");
+				if (line != null) {
+					handleCommand(line);
+				}
+			} catch (UnsupportedEncodingException enc) {
+				System.err.println("caught UnsupportedEncodingException");
+				break;
+			} catch (java.io.EOFException eof) {
+				System.out.println("");//new line
+				exit();
+			} catch (IOException ioe) {
+				ioe.printStackTrace(System.err);
+			}
+		}
+
+		exit();
+	}
+
+	public static void main(String[] args) throws ParseException, IOException {
+		new Lucli(args);
+	}
+
+
+	private void handleCommand(String line) throws IOException, ParseException {
+		String [] words = tokenizeCommand(line);
+		if (words.length == 0)
+			return; //white space
+		String query = "";
+		//Command name and number of arguments
+		switch (getCommandId(words[0], words.length - 1)) {
+			case INFO:
+				luceneMethods.info();
+				break;
+			case SEARCH:
+				for (int ii = 1; ii < words.length; ii++) {
+					query += words[ii] + " ";
+				}
+				luceneMethods.search(query, false, false);
+				break;
+			case COUNT:
+				for (int ii = 1; ii < words.length; ii++) {
+					query += words[ii] + " ";
+				}
+				luceneMethods.count(query);
+				break;
+			case QUIT:
+				exit();
+				break;
+			case TERMS:
+				if(words.length > 1)
+					luceneMethods.terms(words[1]);
+				else
+					luceneMethods.terms(null);
+				break;
+			case INDEX:
+				LuceneMethods newLm = new LuceneMethods(words[1]);
+				try {
+					newLm.info(); //will fail if can't open the index
+					luceneMethods = newLm; //OK, so we'll use the new one
+				} catch (IOException ioe) {
+					//problem we'll keep using the old one
+					error(ioe.toString());
+				}
+				break;
+			case OPTIMIZE:
+				luceneMethods.optimize();
+				break;
+			case TOKENS:
+				for (int ii = 1; ii < words.length; ii++) {
+					query += words[ii] + " ";
+				}
+				luceneMethods.search(query, false, true);
+				break;
+			case EXPLAIN:
+				for (int ii = 1; ii < words.length; ii++) {
+					query += words[ii] + " ";
+				}
+				luceneMethods.search(query, true, false);
+				break;
+			case HELP:
+				help();
+				break;
+			case NOCOMMAND: //do nothing
+				break;
+			case UNKOWN:
+				System.out.println("Unknown command:" + words[0] + ". Type help to get a list of commands.");
+				break;
+		}
+	}
+
+	private String [] tokenizeCommand(String line) {
+		StringTokenizer tokenizer = new StringTokenizer(line, " \t");
+		int size = tokenizer.countTokens();
+		String [] tokens = new String[size];
+		for (int ii = 0; tokenizer.hasMoreTokens(); ii++) {
+			tokens[ii]  = tokenizer.nextToken();
+		}
+		return tokens;
+	}
+
+	private void exit() {
+
+		try {
+			Readline.writeHistoryFile(fullPath);
+		} catch (IOException ioe) {
+			error("while saving history:" + ioe);
+		}
+		Readline.cleanup();
+		System.exit(0);
+	}
+
+	/**
+	 * Add a command to the list of commands for the interpreter for a
+	 * command that doesn't take any parameters.
+	 * @param name  - the name of the command
+	 * @param id  - the unique id of the command
+	 * @param help  - the help message for this command
+	 */
+	private void addCommand(String name, int id, String help) {
+		addCommand(name, id, help, 0);
+	}
+
+	/**
+	 * Add a command to the list of commands for the interpreter.
+	 * @param name  - the name of the command
+	 * @param id  - the unique id of the command
+	 * @param help  - the help message for this command
+	 * @param params  - the minimum number of required params if any
+	 */
+	private void addCommand(String name, int id, String help, int params) {
+		Command command = new Command(name, id, help, params);
+		commandMap.put(name, command);
+	}
+
+	private int getCommandId(String name, int params) {
+		name.toLowerCase(); //treat uppercase and lower case commands the same
+		Command command = (Command) commandMap.get(name);
+		if (command == null) {
+			return(UNKOWN);
+		}
+		else {
+			if(command.params > params) {
+				error(command.name + " needs at least " + command.params + " arguments.");
+				return (NOCOMMAND);
+			}
+			return (command.id);
+		}
+	}
+
+	private void help() {
+		Iterator commands = commandMap.keySet().iterator();
+		while (commands.hasNext()) {
+			Command command = (Command) commandMap.get(commands.next());
+			System.out.println("\t" + command.name + ": " + command.help);
+
+		}
+	}
+
+	private void error(String message) {
+		System.err.println("Error:" + message);
+	}
+
+	private void message(String text) {
+		System.out.println(text);
+	}
+
+
+	/*
+	 * Parse command line arguments
+	 * Code inspired by http://www.ecs.umass.edu/ece/wireless/people/emmanuel/java/java/cmdLineArgs/parsing.html
+	 */
+	private void parseArgs(String[] args) {
+		for (int ii = 0; ii < args.length; ii++) {
+			// a little overkill for now, but foundation
+			// for other args
+			if (args[ii].startsWith("-")) {
+				String arg = args[ii];
+				if (arg.equals("-r")) {
+					enableReadline = true;
+				}
+				else {
+					usage();
+					System.exit(1);
+				}
+			}
+		}
+	}
+
+	private void usage() {
+		message("Usage: lucli [-r]");
+		message("Arguments:");
+		message("\t-r: Provide tab completion and history using the GNU readline shared library ");
+	}
+
+	private class Command {
+		String name;
+		int id;
+		int numberArgs;
+		String help;
+		int params;
+
+		Command(String name, int id, String help, int params) {
+			this.name = name;
+			this.id = id;
+			this.help = help;
+			this.params = params;
+		}
+
+		/**
+		 * Prints out a usage message for this command.
+		 */
+		public String commandUsage() {
+			return (name + ":" + help + ". Command takes " + params + " params");
+		}
+
+	}
+}
diff --git a/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.html b/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.html
deleted file mode 100644
index c595c20..0000000
--- a/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.html
+++ /dev/null
@@ -1,194 +0,0 @@
-<html>
-  <head>
-    <meta name="Author" content="Kelvin Tan">
-    <title>Lucene Query Constructor Demo and Introduction</title>
-    <script type="text/javascript" src="luceneQueryConstructor.js"></script>
-    <script type="text/javascript" src="../queryValidator/luceneQueryValidator.js"></script>
-    <script>
-      submitForm = false // necessary for luceneQueryConstructor not to submit the form upon query construction
-      function doSubmitForm(frm)
-      {
-        if(frm["noField-phrase-input"].value.length > 0)
-          frm["noField-phrase"].value = quote(frm["noField-phrase-input"].value)
-        else if(frm["noField-phrase"].value.length > 0)
-          frm["noField-phrase"].value = ''
-        doMakeQuery(frm.query);
-      }
-    </script>
-  </head>
-  
-  <body>
-  <h2>Lucene Javascript Query Constructor</h2>
-  <p>luceneQueryConstructor.js is a Javascript framework for constructing queries using the "advanced" search features of lucene, 
-  namely field-searching, boolean searching, phrase searching, group searching (via parentheses) and various combinations of the aforementioned.
-  <p>It also provides a convenient way to mimic a Google-like search, where all terms are ANDed, as opposed to Lucene's default OR modifier.
-  <p>
-  This HTML form provides examples on the usage of luceneQueryConstructor.js. 
-  An interface similar to <a href="http://www.google.com/advanced_search">Google's Advanced Search</a> form is shown here.
-    <form>
-  <table width="100%" border="0" cellspacing="1" cellpadding="5"> 
-    <tr>
-      <th></th>
-      <td width="25%"></td>    
-      <tr>
-        <th>
-          <input name="noField-andModifier" value="+|0" type="hidden"><b>Find results</b>
-        </th>
-        <td class="bodytext">With <b>all</b> of the words</td>
-        <td class="bodytext">
-          <input type="text" name="noField-and" size="25">
-          <select name="resultsPerPage">
-          <option value="10">10 results<option value="20">20 results
-          <option value="50" selected>50 results</select>    
-        </td>
-      </tr>
-      <tr>
-        <th>
-          <input name="noField-phraseModifier" value="+|+" type="hidden">
-        </th>
-        <td class="bodytext">With the <b>exact phrase</b></td>
-        <td class="bodytext">
-        <input type="text" name="noField-phrase-input" size="25">
-        <input type="hidden" name="noField-phrase">
-        </td>
-      </tr>
-      <tr>
-        <th>
-          <input name="noField-orModifier" value=" |+" type="hidden">
-        </th>
-        <td class="bodytext">With <b>at least</b> one of the words</td>
-        <td class="bodytext">
-          <input type="text" name="noField-or" size="25">
-        </td>
-      </tr>
-      <tr>
-        <th>
-          <input name="noField-notModifier" value="-|0" type="hidden">
-        </th>
-        <td class="bodytext"><b>Without</b> the words</td>
-        <td class="bodytext">
-          <input type="text" name="noField-not" size="25">
-        </td>
-      </tr>
-      <tr>
-        <th>
-          <b>File Format</b>
-        </th>
-        <td class="bodytext">
-        <select name="fileNameModifier"><option value="And" selected>Only</option><option value="Not">Don't</option></select>
-        return results of the file format</td>
-        <td class="bodytext">
-          <select name="fileName"><option value="" selected>any format<option value="pdf">Adobe Acrobat PDF (.pdf)
-          <option value="doc">Microsoft Word (.doc)<option value="xls">Microsoft Excel (.xls)<option value="ppt">Microsoft Powerpoint (.ppt)</select>
-        </td>
-      </tr>
-      <tr>
-        <th>
-          <b>Date</b>
-        </th>
-        <td class="bodytext">
-        Return results updated in the </td>
-        <td class="bodytext">
-          <select name="date"><option value="" selected>anytime<option value="3">past 3 months
-          <option value="6">past 6 months<option value="12">past year</select>
-          <input type="hidden" name="fromDate">
-          <input type="hidden" name="toDate">
-          <input type="hidden" name="dateRangeField" value="lastModifiedDate">    
-        </td>
-      </tr>
-      <tr>      
-      
-      <input type="hidden" name="query">
-      <tr><td>&nbsp;</tr>
-      <tr><th><p>Current Query:</th><td><pre id="curQuery"></pre><pre id="curQueryValid"></pre></td><td>
-            
-      <input type="button" name="Update" value="Update Query" onClick="doSubmitForm(this.form); document.getElementById('curQuery').innerHTML = this.form.query.value" />
-      <input type="button" name="Validate" value="Validate" onClick="doCheckLuceneQuery(this.form.query); getElementById('curQueryValid').innerHTML = 'Query is valid'" />      
-      </td>      
-    </table>
-    </form>
-    <p>luceneQueryConstructor works by assuming a certain naming convention of form fields to obtain the necessary information to construct the query.<br>
-    <b>NB:</b>Unless otherwise specified, all uses of the word <code>field</code> should be assumed to mean form input fields and not Lucene document fields.
-    <p>The input form field is expected to be the <b>same name as the Lucene Field</b>.  For example, if you have a Document with <i>fileName</i> as a Field, and 
-    you'd like to provide field-searching on this field, then introduce a form field like so:
-    <center>
-    <p><code>&lt;input type="text" name="fileName"&gt;</code>
-    </p>
-    </center>
-    You are also expected to provide another field known as 
-    this field's <b>modifier</b>. This modifier field tells luceneQueryConstructor how to convert the field and value into a Lucene query. The naming convention 
-    of the modifier is <b>&lt;name of input field/Lucene field&gt;&lt;modifier suffix as declared in luceneQueryConstructor.js&gt;</b>. So, for the <i>fileName</i> field 
-    we introduced above, it's modifier field would be:
-    <center>
-    <p><code>&lt;input type="hidden" name="fileNameModifier" value="+|+"&gt;</code>
-    </p>
-    </center>
-    <p>The value of the modifier field is in the form <b>&lt;term modifier&gt;|&lt;group modifier&gt;</b>. Let me explain.
-    <p>Looking at the form above, we see fields that provide
-    <ol>
-    <li>AND search
-    <li>OR search
-    <li>NOT search
-    <li>and others which are unrelated to this discussion
-    </ol>
-    Given a value of <b><i>foo bar</i></b>, the AND search field must be converted to <b><i>+foo +bar</i></b> (luceneQueryConstructor only supports 
-    using +/-, not AND/OR/NOT), the NOT search to <b><i>-foo -bar</i></b> and the OR search not at all.
-    <p>However, also consider the relationship <b>between</b> these groups of fields. Assuming Google's Advanced Search interface, 
-    we're effectively saying that we want all of the terms in the AND search field <b>AND</b> at least one of the 
-    terms in the OR search field <b>AND</b> none of the terms in the NOT search. 
-    <p>So, if the AND, OR and NOT search fields all have the values of <b><i>foo bar</i></b>, then an appropriate search query 
-    which fulfills the requirements would be
-    <center>
-    <p><code>+foo +bar +(foo bar) -foo -bar</code>
-    </p>
-    </center>
-    Well, to be more correct, it should be 
-    <center>
-    <p><code>+(+foo +bar) +(foo bar) -foo -bar</code>
-    </p>
-    </center>
-    Hmmmm...if you're sharp, you would have noticed that the NOT terms aren't grouped. 
-    You'll find that if you group them with an AND modifier, no results will be returned at all (though it's a valid query),
-    because the query constructed wouldn't make any sense at all. Lucene also implicitly ANDs NOT terms, it seems. In any case,
-    both queries as presented are correct, though I prefer the first one because it is less verbose.
-    <p>The following matrix provides modifiers and their effects on queries:<br><br>
-    <table border="1" align="center">
-    <tr>
-    <th>Boolean modifier
-    <th>Form value
-    <th>As term modifier
-    <th>As group modifier
-    </tr>
-    <tr align="center">
-    <td>AND
-    <td>+
-    <td>+term1 + term2 ...
-    <td>+(...)
-    </tr>
-    <tr align="center">
-    <td>OR
-    <td>(single space)
-    <td>term1  term2 ...
-    <td>(...)
-    </tr>
-    <tr align="center">
-    <td>NOT
-    <td>-
-    <td>-term1  -term2 ...
-    <td>-(...)
-    </tr>
-    <tr align="center">
-    <td>no modifier
-    <td>0
-    <td>term1  term2 ...
-    <td>no grouping
-    </tr>
-    </table>
-    <p>With this knowledge, we know that the value of the AND field modifier needs to be <b><i>+|0</i></b> for the first query and 
-    <b><i>+|+</i></b> for the second query, the values of the NOT field modifier and the 
-    OR field modifier are <b><i>-|0</i></b> and <b><i>&nbsp;|+</i></b> (it's an empty space before the |) in both queries respectively.
-    <p>
-    Well, that's all I have to say for now. There are more topics to be covered, such as construction of phrase searches, non-field searches, 
-    multiple list box selections, radio buttons etc, but right now I'm not even sure if anyone will read this much! :-) Anyway, there's always the code. 
-  </body>
-</html>
\ No newline at end of file
diff --git a/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.js b/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.js
deleted file mode 100644
index 32cfa7c..0000000
--- a/sandbox/contributions/javascript/queryConstructor/luceneQueryConstructor.js
+++ /dev/null
@@ -1,286 +0,0 @@
-// Lucene Search Query Constructor
-// Author:  Kelvin Tan  (kelvint at apache.org)
-// Version: $Id$
-
-// Change this according to what you use to name the field modifiers in your form.
-// e.g. with the search field "name", the form element of its modifier 
-// will be "name<modifierSuffix>"
-var modifierSuffix = 'Modifier';
-
-// If not a field-specific search
-// e.g. with the arbitary form element 'foobar', its modifier will be 
-// <noFieldPrefix>foobarModifier and its form element 
-// will be <noFieldPrefix>foobar
-var noFieldPrefix = 'noField-';
-
-// Do you wish the query to be displayed as an alert box?
-var debug = false;
-
-// Do you wish the function to submit the form upon query construction?
-var submitForm = false;
-
-// prefix modifier for boolean AND queries
-var AND_MODIFIER = '+';
-
-// prefix modifier for boolean NOT queries
-var NOT_MODIFIER = '-';
-
-// prefix modifier for boolean OR queries
-var OR_MODIFIER  = ' ';
-
-var NO_MODIFIER = 0;
-
-// default modifier for terms
-var DEFAULT_TERM_MODIFIER = AND_MODIFIER;
-
-// default modifier for groups of terms (denoted by parantheses)
-var DEFAULT_GROUP_MODIFIER = AND_MODIFIER;
-
-// used to delimit multiple values from checkboxes and select lists
-var VALUE_DELIMITER = ' ';
-
-// Constructs the query
-// @param query Form field to represent the constructed query to be submitted
-// @param debug Turn on debugging?
-function doMakeQuery( query, dbg )
-{
-  if(typeof(dbg) != "undefined")
-    debug = dbg;
-    
-  var frm = query.form;
-  var formElements = frm.elements;
-  query.value = '';
-  
-  // keep track of the fields we've examined
-  var dict = new Array();
-  
-  for(var i=0; i<formElements.length; i++)
-  {
-    var element = formElements[i];
-    var elementName = element.name;
-    if(elementName != "" && !contains(dict, elementName))
-    {
-      dict[dict.length] = elementName;
-      
-      // ensure we get the whole group (of checkboxes, radio, etc), if applicable
-      var elementValue = getFieldValue(frm[element.name]);
-      if(elementValue.length > 0)
-      {
-        var subElement = frm[elementName + modifierSuffix];
-        if(typeof(subElement) != "undefined") // found a field/fieldModifier pair
-        {
-          var termMod, groupMod;
-          var modifier = getFieldValue(subElement);
-          // modifier field is in the form <termModifier>|<groupModifier>
-          if(modifier.indexOf('|') > -1)
-          {
-            var idx = modifier.indexOf('|');
-            termMod = modifier.substring(0, idx);
-            if(termMod == '') termMod = DEFAULT_TERM_MODIFIER;
-            groupMod = modifier.substring(idx + 1);
-            if(groupMod == '') groupMod = DEFAULT_GROUP_MODIFIER;
-          }
-          else
-          {
-            termMod = modifier;
-            if(termMod == '') termMod = DEFAULT_TERM_MODIFIER;
-            groupMod = DEFAULT_GROUP_MODIFIER;
-          }
-          appendTerms(query, termMod, elementValue, elementName, groupMod);
-        }
-      }
-    }
-  }
-
-  if(debug) {alert('Query:' + query.value);}
-  
-  if(submitForm)
-  {
-    frm.submit();
-  }
-  else
-  {
-    return query;
-  }
-}
-
-// Constructs a Google-like query (all terms are ANDed)
-// @param query Form field to represent the constructed query to be submitted
-// @return Submits the form if submitOnConstruction=true, else returns the query param
-function doANDTerms(query)
-{
-  var value = query.value;
-  query.value = "";
-  appendTerms(query, AND_MODIFIER,  value);
-  if(submitForm)
-  {
-    frm.submit();
-  }
-  else
-  {
-    return query;
-  }
-}
-
-function buildTerms(termModifier, fieldValue)
-{
-  fieldValue = trim(fieldValue);
-  var splitStr = fieldValue.split(" ");
-  fieldValue = '';
-  var inQuotes = false;
-  for(var i=0;i<splitStr.length;i++)
-  {
-    if(splitStr[i].length > 0)
-    {
-      if(!inQuotes)
-      {
-        fieldValue = fieldValue + termModifier + splitStr[i] + ' ';
-      }
-      else
-      { 
-        fieldValue = fieldValue + splitStr[i] + ' ';
-      }      
-      if(splitStr[i].indexOf('"') > -1) inQuotes = !inQuotes
-    }
-  }
-  fieldValue = trim(fieldValue);  
-  return fieldValue;
-}
-
-// Appends terms to a query. 
-// @param query Form field of query
-// @param termModifier Term modifier
-// @param value Value to be appended. Tokenized by spaces, 
-//    and termModifier will be applied to each token.
-// @param fieldName Name of search field. Omit if not a field-specific query.
-// @param groupModifier Modifier applied to each group of terms.
-// @return query form field
-function appendTerms(query, termModifier, value, fieldName, groupModifier)
-{
-  if(typeof(groupModifier) == "undefined")
-    groupModifier = DEFAULT_GROUP_MODIFIER;
-  
-  value = buildTerms(termModifier, value);
-  
-  // not a field-specific search
-  if(fieldName == null || fieldName.indexOf(noFieldPrefix) != -1 || fieldName.length == 0)
-  {
-    if(groupModifier == NO_MODIFIER)
-    {
-      if(query.value.length == 0)
-      {
-        query.value = value;
-      }
-      else
-      {
-        query.value = query.value + ' ' + value;
-      }  
-    }
-    else
-    { 
-      if(query.value.length == 0)
-      {
-        query.value = groupModifier + '(' + value + ')';
-      }
-      else
-      {
-        query.value = query.value + ' ' + groupModifier + '(' + value + ')';
-      }  
-    }
-  }
-  else
-  {
-  	if(groupModifier == NO_MODIFIER) groupModifier = ''
-    if(query.value.length == 0)
-    {
-      query.value = groupModifier + fieldName + ':(' + value + ')';
-    }
-    else
-    {
-      query.value = query.value + ' ' + groupModifier +fieldName + ':(' + value + ')';
-    }  
-  }
-  query.value = trim(query.value)
-  return query;
-}
-
-// Obtain the value of a form field.
-// @param field Form field
-// @return Array of values, or string value depending on field type, 
-//    or empty string if field param is undefined or null
-function getFieldValue(field)
-{
-  if(field == null || typeof(field) == "undefined")
-    return "";
-  if(typeof(field) != "undefined" && typeof(field[0]) != "undefined" && field[0].type=="checkbox")
-    return getCheckedValues(field);
-  if(typeof(field) != "undefined" && typeof(field[0]) != "undefined" && field[0].type=="radio")
-    return getRadioValue(field);
-  if(typeof(field) != "undefined" && field.type.match("select*")) 
-    return getSelectedValues(field);
-  if(typeof(field) != "undefined")
-    return field.value;
-}
-
-function getRadioValue(radio)
-{
-  for(var i=0; i<radio.length; i++)
-  {
-    if(radio[i].checked)
-      return radio[i].value;
-  }
-}
-
-function getCheckedValues(checkbox)
-{
-  var r = new Array();
-  for(var i = 0; i < checkbox.length; i++)
-  {
-    if(checkbox[i].checked)
-      r[r.length] = checkbox[i].value;
-  }
-  return r.join(VALUE_DELIMITER);
-}
-
-function getSelectedValues (select) {
-  var r = new Array();
-  for (var i = 0; i < select.options.length; i++)
-    if (select.options[i].selected)
-    {
-      r[r.length] = select.options[i].value;
-    }
-  return r.join(VALUE_DELIMITER);
-}
-
-function quote(value)
-{
-  return "\"" + trim(value) + "\"";
-}
-
-function contains(array, s)
-{
-  for(var i=0; i<array.length; i++)
-  {
-    if(s == array[i])
-      return true;
-  }
-  return false;
-}
-
-function trim(inputString) {
-   if (typeof inputString != "string") { return inputString; }
-   
-   var temp = inputString;
-   
-   // Replace whitespace with a single space
-   var pattern = /\s+/ig;
-   temp = temp.replace(pattern, " ");
-  
-   // Trim 
-   pattern = /^(\s*)([\w\W]*)(\b\s*$)/;
-   if (pattern.test(temp)) { temp = temp.replace(pattern, "$2"); }
-   // run it another time through for words which don't end with a character or a digit
-   pattern = /^(\s*)([\w\W]*)(\s*$)/;
-   if (pattern.test(temp)) { temp = temp.replace(pattern, "$2"); }
-   return temp; // Return the trimmed string back to the user
-}
\ No newline at end of file
diff --git a/sandbox/contributions/javascript/queryConstructor/testQueryConstructor.html b/sandbox/contributions/javascript/queryConstructor/testQueryConstructor.html
deleted file mode 100644
index 6644ef7..0000000
--- a/sandbox/contributions/javascript/queryConstructor/testQueryConstructor.html
+++ /dev/null
@@ -1,159 +0,0 @@
-<html>
-
-<head>
-<script language="JavaScript" src="c:/market/jsunit/app/jsUnitCore.js"></script>
-<script language="JavaScript" src="luceneQueryConstructor.js"></script>
-</head>
-<body>
-<script>
-setAlertUser(false);
-
-// additions to jsUnit
-function assertTrue(comment, value)
-{
-  return assertEquals(comment, true, value);
-}
-
-function assertFalse(comment, value)
-{
-  return assertEquals(comment, false, value);
-}
-
-function testTrim()
-{
-  assertEquals("Not trimming", "foo bar", trim("  foo bar"));
-  assertEquals("Not trimming", "foo bar", trim("  foo bar  "));
-  assertEquals("Not trimming", "foo bar", trim("  foo   bar  "));
-  assertEquals("Not trimming", "foo bar", trim("  foo bar\n\t "));
-  assertEquals("Not trimming", "foo:(bar)", trim(" foo:(bar)"));
-}
-
-function testGetFieldValue()
-{
-  var frm = document.testQueryConstructor;
-  // test radio buttons
-  frm.fooRadio[0].checked = true;
-  assertEquals("Wrong value for radio button", frm.fooRadio[0].value, getFieldValue(frm.fooRadio));
-  frm.fooRadio[0].checked = false;
-  frm.fooRadio[1].checked = true;
-  assertEquals("Wrong value for radio button", frm.fooRadio[1].value, getFieldValue(frm.fooRadio));
-  
-  // test checkbox
-  frm.fooCheck[0].checked = true;
-  assertEquals("Wrong value for checkbox", frm.fooCheck[0].value, getFieldValue(frm.fooCheck));
-  frm.fooCheck[0].checked = false;
-  frm.fooCheck[1].checked = true;
-  assertEquals("Wrong value for checkbox", frm.fooCheck[1].value, getFieldValue(frm.fooCheck));
-  
-  // test select
-  frm.fooSelect.options[0].selected = true;
-  assertEquals("Wrong value for select", frm.fooSelect.options[0].value, getFieldValue(frm.fooSelect));
-  frm.fooSelect.options[0].selected = false;
-  frm.fooSelect.options[1].selected = true;
-  assertEquals("Wrong value for checkbox", frm.fooSelect.options[1].value, getFieldValue(frm.fooCheck));
-  
-  // test text field
-  assertEquals("Wrong value for text field", frm.fooText.value, getFieldValue(frm.fooText));
-  
-  // test hidden field
-  assertEquals("Wrong value for hidden field", frm.fooHidden.value, getFieldValue(frm.fooHidden));
-  
-  // test undefined field
-  assertEquals("Wrong value for undefined field", "", getFieldValue(frm.nonexistent)); 
-  assertEquals("Wrong value for undefined field", "", getFieldValue(null)); 
-}
-
-function testAppendTerms()
-{
-  var frm = document.testQueryConstructor;
-  assertEquals("Not appending AND terms correctly", "+fooText:(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
-  frm.query.value = ''
-  assertEquals("Not appending NOT terms correctly", "+fooText:(-1)", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value, frm.fooText.name).value);
-  frm.query.value = ''
-  assertEquals("Not appending OR terms correctly", "+fooText:(1)", appendTerms(frm.query, OR_MODIFIER, frm.fooText.value, frm.fooText.name).value);
-  frm.query.value = ''
-  
-  frm.fooText.value = "\"my foo bar\""
-  assertEquals("Not appending AND terms correctly", "+fooText:(+\"my foo bar\" )", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
-  frm.fooText.value = "1"
-  frm.query.value = ''
-  
-  assertEquals("Not appending terms correctly", "-fooText:(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER).value);
-  frm.query.value = ''
-  frm.fooText.value = "1 2 3"
-  assertEquals("Not appending terms correctly", "+fooText:(+1 +2 +3)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value, frm.fooText.name).value);
-  frm.query.value = ''
-  assertEquals("Not appending terms correctly", "-fooText:(1 2 3)", appendTerms(frm.query, OR_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER).value);
-  frm.query.value = ''
-  assertEquals("Not appending terms correctly", "-fooText:(-1 -2 -3)", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value, frm.fooText.name, NOT_MODIFIER, NO_MODIFIER).value);
-  frm.query.value = ''
-  frm.fooText.value = "1"
-  
-  assertEquals("Not appending terms correctly(without fields)", "+(+1)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value).value);
-  frm.query.value = ''
-  assertEquals("Not appending terms correctly(without fields)", "+(+1)", appendTerms(frm.query, AND_MODIFIER, frm["noField-fooText"].value, "noField-fooText").value);
-  frm.query.value = ''
-
-  frm.fooText.value = "1 2 3"
-  assertEquals("Not appending terms correctly(without fields)", "-1 -2 -3", appendTerms(frm.query, NOT_MODIFIER, frm.fooText.value,"", NO_MODIFIER).value);
-  frm.query.value = ''
-  assertEquals("Not appending terms correctly(without fields)", "+(+1 +2 +3)", appendTerms(frm.query, AND_MODIFIER, frm.fooText.value).value);
-  frm.fooText.value = "1"
-  frm.query.value = ''
-  
-}
-
-function testDoMakeQuery()
-{
-  var frm = document.testQueryConstructor;
-  frm.or.value = "orValue";
-  assertEquals("Wrong query constructed", "or:(orValue)", doMakeQuery(frm.query).value);
-  frm.orModifier.value = " |+";
-  assertEquals("Wrong query constructed", "+or:(orValue)", doMakeQuery(frm.query).value);
-  frm.orModifier.value = " | ";
-  assertEquals("Wrong query constructed", "or:(orValue)", doMakeQuery(frm.query).value);
-  frm.orModifier.value = "";
-  assertEquals("Wrong query constructed", DEFAULT_GROUP_MODIFIER + "or:(" + DEFAULT_TERM_MODIFIER + "orValue)", doMakeQuery(frm.query).value);
-}
-
-function doANDTerms()
-{
-  
-}
-</script>
-
-<form name="testQueryConstructor">
-<input type="radio" name="fooRadio" value="1">
-<input type="radio" name="fooRadio" value="2">
-
-<input type="checkbox" name="fooCheck" value="1">
-<input type="checkbox" name="fooCheck" value="2">
-
-<select name="fooSelect">
-<option value="1">
-<option value="2">
-</select>
-
-<input type="text" name="fooText" value="1">
-<input type="text" name="noField-fooText" value="1">
-<input type="text" name="foobarText" value="1">
-<input type="hidden" name="fooHidden" value="1">
-<input type="password" name="fooPassword">
-<input type="button" name="fooButton" value="I am a button">
-<input type="submit" name="fooSubmit">
-<input type="reset" name="fooReset">
-<input type="file" name="fooFile">
-
-<input type="hidden" name="andModifier" value="+">
-<input type="hidden" name="and">
-
-<input type="hidden" name="notModifier" value="-">
-<input type="hidden" name="not">
-
-<input type="hidden" name="orModifier" value=" | ">
-<input type="hidden" name="or">
-
-<input type="text" name="query">
-</form>
-</body>
-</html>
\ No newline at end of file
diff --git a/sandbox/contributions/javascript/queryEscaper/luceneQueryEscaper.js b/sandbox/contributions/javascript/queryEscaper/luceneQueryEscaper.js
deleted file mode 100644
index c84d910..0000000
--- a/sandbox/contributions/javascript/queryEscaper/luceneQueryEscaper.js
+++ /dev/null
@@ -1,98 +0,0 @@
-// Special characters are + - && || ! ( ) { } [ ] ^ " ~ * ? : \
-// Special words are (case-sensitive) AND NOT OR
-// We escape the common ones, i.e. ! ? * ( ) " :
-
-// escapes a lucene query.
-// @param Form field that contains the query, or the query string
-function doEscapeQuery(queryArg)
-{
-  var query = getQueryValue(queryArg);
-  query = escapeAsterisk(query);
-  query = escapeQuotes(query);
-  query = escapeColon(query);
-  query = escapeQuestionMark(query);
-  query = escapeExclamationMark(query);
-  query = escapeParentheses(query);  
-  query = escapeSquareBrackets(query);  
-  query = escapeBraces(query);  
-  query = escapeCaret(query);  
-  query = escapeSquiggle(query);  
-  query = escapeDoubleAmpersands(query);  
-  query = escapeDoubleBars(query);  
-  return query;
-}
-
-function getQueryValue(queryArg)
-{
-  var query;
-  // check if its a form field
-  if(typeof(queryArg.form) != "undefined")
-  {
-    query = queryArg.value;
-  }
-  else
-  {
-    query = queryArg;
-  }
-  return query;
-}
-
-function escapeAsterisk(query)
-{
-  return query.replace(/[\*]/g, "\\*");
-}
-
-function escapeQuotes(query)
-{
-  return query.replace(/[\"]/g, "\\\"");
-}
-
-function escapeColon(query)
-{
-  return query.replace(/[\:]/g, "\\:");
-}
-
-function escapeQuestionMark(query)
-{
-  return query.replace(/[?]/g, "\\?");
-}
-
-function escapeExclamationMark(query)
-{
-  return query.replace(/[!]/g, "\\!");
-}
-
-function escapeParentheses(query)
-{
-  return query.replace(/[(]/g, "\\(").replace(/[)]/g, "\\)");
-}
-
-function escapeSquareBrackets(query)
-{
-  return query.replace(/[\[]/g, "\\[").replace(/[\]]/g, "\\]");
-}
-
-function escapeBraces(query)
-{
-  return query.replace(/[{]/g, "\\{").replace(/[}]/g, "\\}");
-}
-
-function escapeCaret(query)
-{
-  return query.replace(/[\^]/g, "\\^");
-}
-
-function escapeSquiggle(query)
-{
-  return query.replace(/[~]/g, "\\~");
-}
-
-function escapeDoubleAmpersands(query)
-{
-  return query.replace(/[&]{2}/g, "\\&\\&");
-}
-
-function escapeDoubleBars(query)
-{
-  return query.replace(/[\|]{2}/g, "\\|\\|");
-}
\ No newline at end of file
diff --git a/sandbox/contributions/javascript/queryEscaper/testQueryEscaper.html b/sandbox/contributions/javascript/queryEscaper/testQueryEscaper.html
deleted file mode 100644
index d455f4a..0000000
--- a/sandbox/contributions/javascript/queryEscaper/testQueryEscaper.html
+++ /dev/null
@@ -1,121 +0,0 @@
-<html>
-
-<head>
-<!-- Change Me -->
-<script language="JavaScript" src="jsUnitCore.js"></script>
-<script language="JavaScript" src="luceneQueryEscaper.js"></script>
-</head>
-<body>
-<script>
-function testGetQueryValue()
-{
-  var str = "The quick brown fox jumped over the lazy dog";
-  document.test.foobar.value = str;
-  assertEquals("Not getting field value correctly", str, getQueryValue(document.test.foobar));
-  assertEquals("Not getting string value correctly", str, getQueryValue(str));
-}
-
-function testNormalString()
-{
-  var str = "The quick brown fox jumped over the lazy dog";
-  assertEquals("Should not be escaping", str, escapeAsterisk(str));
-  assertEquals("Should not be escaping", str, escapeQuotes(str));
-  assertEquals("Should not be escaping", str, escapeColon(str));
-  assertEquals("Should not be escaping", str, escapeQuestionMark(str));
-  assertEquals("Should not be escaping", str, escapeExclamationMark(str));
-}
-
-function testEscapeAsterisk()
-{
-  var str = "foo*";
-  assertEquals("Not escaping " + str, "foo\\*", escapeAsterisk(str));
-  
-  str = " foo bar *";
-  assertEquals("Not escaping " + str, " foo bar \\*", escapeAsterisk(str));
-  
-  str = "foo* bar*";
-  assertEquals("Not escaping " + str, "foo\\* bar\\*", escapeAsterisk(str));  
-}
-
-function testEscapeQuotes()
-{
-  var str = "\"foo\"";
-  assertEquals("Not escaping " + str, "\\\"foo\\\"", escapeQuotes(str));
-}
-
-function testEscapeColon()
-{
-  var str = "foo:bar zoo:zaa";
-  assertEquals("Not escaping " + str, "foo\\:bar zoo\\:zaa", escapeColon(str));
-}
-
-function testEscapeQuestionMark()
-{
-  var str = "foo? bar?";
-  assertEquals("Not escaping " + str, "foo\\? bar\\?", escapeQuestionMark(str));
-}
-
-function testEscapeExclamationMark()
-{
-  var str = "foo! bar!";
-  assertEquals("Not escaping " + str, "foo\\! bar\\!", escapeExclamationMark(str));
-}
-
-function testEscapeParentheses()
-{
-  var str = "foo (bar) (me)";
-  assertEquals("Not escaping " + str, "foo \\(bar\\) \\(me\\)", escapeParentheses(str));
-}
-
-function testEscapeSquareBrackets()
-{
-  var str = "foo [bar] [me]";
-  assertEquals("Not escaping " + str, "foo \\[bar\\] \\[me\\]", escapeSquareBrackets(str));
-}
-
-function testEscapeBraces()
-{
-  var str = "foo {bar} {me}";
-  assertEquals("Not escaping " + str, "foo \\{bar\\} \\{me\\}", escapeBraces(str));
-}
-
-function testEscapeCaret()
-{
-  var str = "f^oo bar^ me";
-  assertEquals("Not escaping " + str, "f\\^oo bar\\^ me", escapeCaret(str));
-}
-
-function testEscapeSquiggle()
-{
-  var str = "f~oo bar~ me";
-  assertEquals("Not escaping " + str, "f\\~oo bar\\~ me", escapeSquiggle(str));
-}
-
-function testEscapeDoubleAmpersands()
-{
-  var str = "foo && bar me";
-  assertEquals("Not escaping " + str, "foo \\&\\& bar me", escapeDoubleAmpersands(str));
-
-  str = "foo && bar& m&e";
-  assertEquals("Not escaping " + str, "foo \\&\\& bar& m&e", escapeDoubleAmpersands(str));
-}
-
-function testEscapeDoubleBars()
-{
-  var str = "foo || bar me";
-  assertEquals("Not escaping " + str, "foo \\|\\| bar me", escapeDoubleBars(str));
-}
-
-function testDoEscapeQuery()
-{
-  var str = "The: quick*} {~brown? ^fox! (jumped:[over] || me) \"the && lazy: dog\"";
-  assertEquals("Not escaping " + str, "The\\: quick\\*\\} \\{\\~brown\\? \\^fox\\! \\(jumped\\:\\[over\\] \\|\\| me\\) \\\"the \\&\\& lazy\\: dog\\\"", doEscapeQuery(str));
-}
-
-
-</script>
-<form name="test">
-<input type="text" name="foobar">
-</form>
-</body>
-</html>
diff --git a/sandbox/contributions/javascript/queryValidator/luceneQueryValidator.js b/sandbox/contributions/javascript/queryValidator/luceneQueryValidator.js
deleted file mode 100644
index 6c02c34..0000000
--- a/sandbox/contributions/javascript/queryValidator/luceneQueryValidator.js
+++ /dev/null
@@ -1,291 +0,0 @@
-// Author: Kelvin Tan  (kelvint at apache.org)
-// JavaScript Lucene Query Validator
-// Version: $Id$
-// Tested: IE 6.0.2800 and Mozilla Firebird 0.7
-
-// Special characters are + - && || ! ( ) { } [ ] ^ " ~ * ? : \
-// Special words are (case-sensitive) AND NOT OR
-
-// Makes wildcard queries case-insensitive if true.
-// Refer to http://www.mail-archive.com/lucene-user@jakarta.apache.org/msg00646.html
-var wildcardCaseInsensitive = true;
-
-// Mutator method for wildcardCaseInsensitive.
-// @param Should wildcard queries be case-insensitive?
-function setWildcardCaseInsensitive(bool)
-{
-  wildcardCaseInsensitive = bool;
-}
-
-// Should the user be prompted with an alert box if validation fails?
-var alertUser = true;
-
-function setAlertUser(bool)
-{
-  alertUser = bool;
-}
-
-// validates a lucene query.
-// @param Form field that contains the query
-function doCheckLuceneQuery(queryField)
-{
-  return doCheckLuceneQueryValue(queryField.value)
-}
-
-// validates a lucene query.
-// @param query string
-function doCheckLuceneQueryValue(query)
-{
-  if(query != null && query.length > 0)
-  {
-    query = removeEscapes(query);
-    
-    // check for allowed characters
-    if(!checkAllowedCharacters(query)) return false;
-    
-    // check * is used properly
-    if(!checkAsterisk(query)) return false;
-    
-    // check for && usage
-    if(!checkAmpersands(query)) return false;
-    
-    // check ^ is used properly 
-    if(!checkCaret(query)) return false;
-    
-    // check ~ is used properly
-    if(!checkSquiggle(query)) return false;
-    
-    // check ! is used properly 
-    if(!checkExclamationMark(query)) return false;
-    
-    // check question marks are used properly
-    if(!checkQuestionMark(query)) return false;
-    
-    // check parentheses are used properly
-    if(!checkParentheses(query)) return false;
-    
-    // check '+' and '-' are used properly      
-    if(!checkPlusMinus(query)) return false;
-    
-    // check AND, OR and NOT are used properly
-    if(!checkANDORNOT(query)) return false;    
-    
-    // check that quote marks are closed
-    if(!checkQuotes(query)) return false;
-    
-    // check ':' is used properly
-    if(!checkColon(query)) return false;
-    
-    if(wildcardCaseInsensitive)
-    {
-      if(query.indexOf("*") != -1)
-      {
-        var i = query.indexOf(':');
-        if(i == -1)
-        {
-          query.value = query.toLowerCase();
-        }
-        else // found a wildcard field search
-        {
-          query.value = query.substring(0, i) + query.substring(i).toLowerCase();
-        }
-      }
-    }
-    return true;
-  }
-}
-
-// remove the escape character and the character immediately following it
-function removeEscapes(query)
-{
-  return query.replace(/\\./g, "");
-}
-
-function checkAllowedCharacters(query)
-{
-  matches = query.match(/[^a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'= ]/);
-  if(matches != null && matches.length > 0)
-  {
-    if(alertUser) alert("Invalid search query! The allowed characters are a-z A-Z 0-9.  _ + - : () \" & * ? | ! {} [ ] ^ ~ \\ @ = # % $ ' /. Please try again.")
-    return false;
-  }
-  return true;
-}
-
-function checkAsterisk(query)
-{
-  matches = query.match(/^[\*]*$|[\s]\*|^\*[^\s]/);
-  if(matches != null)
-  {
-    if(alertUser) alert("Invalid search query! The wildcard (*) character must be preceded by at least one alphabet or number. Please try again.")
-    return false;
-  }
-  return true;
-}
-
-function checkAmpersands(query)
-{
-  // NB: doesn't handle term1 && term2 && term3 in Firebird 0.7
-  matches = query.match(/[&]{2}/);
-  if(matches != null && matches.length > 0)
-  {
-    matches = query.match(/^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+( && )?[a-zA-Z0-9_+\-:.()\"*?|!{}\[\]\^~\\@#\/$%'=]+[ ]*)+$/); // note missing & in pattern
-    if(matches == null)
-    {
-      if(alertUser) alert("Invalid search query! Queries containing the special characters && must be in the form: term1 && term2. Please try again.")
-      return false;
-    }
-  }
-  return true;
-}
-
-function checkCaret(query)
-{
-  //matches = query.match(/^[^\^]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\~\\@#\/]+(\^[\d]+)?[ ]*)+$/); // note missing ^ in pattern
-  matches = query.match(/[^\\]\^([^\s]*[^0-9.]+)|[^\\]\^$/);
-  if(matches != null)
-  {
-    if(alertUser) alert("Invalid search query! The caret (^) character must be preceded by alphanumeric characters and followed by numbers. Please try again.")
-    return false;
-  }
-  return true;
-}
-
-function checkSquiggle(query)
-{
-  //matches = query.match(/^[^~]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^\\@#\/]+(~[\d.]+|[^\\]\\~)?[ ]*)+$/); // note missing ~ in pattern
-  matches = query.match(/[^\\]~[^\s]*[^0-9\s]+/);
-  if(matches != null)
-  {
-    if(alertUser) alert("Invalid search query! The tilde (~) character must be preceded by alphanumeric characters and followed by numbers. Please try again.")
-    return false;
-  }    
-  return true;
-}
-
-function checkExclamationMark(query)
-{
-  // foo! is not a query, but !foo is. hmmmm...
-  // NB: doesn't handle term1 ! term2 ! term3 or term1 !term2
-  matches = query.match(/^[^!]*$|^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+( ! )?[a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+[ ]*)+$/);
-  if(matches == null || matches.length == 0)
-  {
-    if(alertUser) alert("Invalid search query! Queries containing the special character ! must be in the form: term1 ! term2. Please try again.")
-    return false;
-  }
-  
-  
-  return true;
-}
-
-function checkQuestionMark(query)
-{
-  matches = query.match(/^(\?)|([^a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]\?+)/);
-  if(matches != null && matches.length > 0)
-  {
-      if(alertUser) alert("Invalid search query! The question mark (?) character must be preceded by at least one alphabet or number. Please try again.")
-    return false;
-  }
-  return true;
-}
-
-function checkParentheses(query)
-{
-  var hasLeft = false;
-  var hasRight = false;
-  matchLeft = query.match(/[(]/g);
-  if(matchLeft != null) hasLeft = true
-  matchRight = query.match(/[)]/g);
-  if(matchRight != null) hasRight = true;
-  
-  if(hasLeft || hasRight)
-  {
-    if(hasLeft && !hasRight || hasRight && !hasLeft)
-    {
-        if(alertUser) alert("Invalid search query! Parentheses must be closed. Please try again.")
-        return false;
-    }
-    else
-    {
-      var number = matchLeft.length + matchRight.length;
-      if((number % 2) > 0 || matchLeft.length != matchRight.length)
-      {
-        if(alertUser) alert("Invalid search query! Parentheses must be closed. Please try again.")
-        return false;
-      }    
-    }
-    matches = query.match(/\(\)/);
-    if(matches != null)
-    {
-      if(alertUser) alert("Invalid search query! Parentheses must contain at least one character. Please try again.")
-      return false;    
-    }
-  }  
-  return true;    
-}
-
-function checkPlusMinus(query)
-{
-  matches = query.match(/^[^\n+\-]*$|^([+-]?[a-zA-Z0-9_:.()\"*?&|!{}\[\]\^~\\@#\/$%'=]+[ ]?)+$/);
-  if(matches == null || matches.length == 0)
-  {
-    if(alertUser) alert("Invalid search query! '+' and '-' modifiers must be followed by at least one alphabet or number. Please try again.")
-    return false;
-  }
-  return true;
-}
-
-function checkANDORNOT(query)
-{
-  matches = query.match(/AND|OR|NOT/);
-  if(matches != null && matches.length > 0)
-  {
-    matches = query.match(/^([a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@\/#$%'=]+\s*((AND )|(OR )|(AND NOT )|(NOT ))?[a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@\/#$%'=]+[ ]*)+$/);       
-    if(matches == null || matches.length == 0)
-    {
-      if(alertUser) alert("Invalid search query!  Queries containing AND/OR/NOT must be in the form: term1 AND|OR|NOT|AND NOT term2 Please try again.")
-      return false;
-    }
-    
-    // its difficult to distinguish AND/OR/... from the usual [a-zA-Z] because they're...words!
-    matches = query.match(/^((AND )|(OR )|(AND NOT )|(NOT ))|((AND)|(OR)|(AND NOT )|(NOT))[ ]*$/)
-    if(matches != null && matches.length > 0)
-    {
-      if(alertUser) alert("Invalid search query!  Queries containing AND/OR/NOT must be in the form: term1 AND|OR|NOT|AND NOT term2 Please try again.")
-      return false;
-    }
-  }
-  return true;
-}
-
-function checkQuotes(query)
-{
-  matches = query.match(/\"/g);
-  if(matches != null && matches.length > 0)
-  {
-    var number = matches.length;
-    if((number % 2) > 0)
-    {
-      if(alertUser) alert("Invalid search query! Please close all quote (\") marks.");
-      return false;
-    }
-    matches = query.match(/""/);
-    if(matches != null)
-    {
-      if(alertUser) alert("Invalid search query! Quotes must contain at least one character. Please try again.")
-      return false;    
-    }    
-  }
-  return true;
-}
-
-function checkColon(query)
-{
-  matches = query.match(/[^\\\s]:[\s]|[^\\\s]:$|[\s][^\\]?:|^[^\\\s]?:/);
-  if(matches != null)
-  {
-    if(alertUser) alert("Invalid search query! Field declarations (:) must be preceded by at least one alphabet or number and followed by at least one alphabet or number. Please try again.")
-    return false;
-  }
-  return true;
-}
\ No newline at end of file
diff --git a/sandbox/contributions/javascript/queryValidator/testQueryValidator.html b/sandbox/contributions/javascript/queryValidator/testQueryValidator.html
deleted file mode 100644
index 09569a3..0000000
--- a/sandbox/contributions/javascript/queryValidator/testQueryValidator.html
+++ /dev/null
@@ -1,603 +0,0 @@
-<html>
-
-<head>
-<script language="JavaScript" src="c:/market/jsunit/app/jsUnitCore.js"></script>
-<script language="JavaScript" src="luceneQueryValidator.js"></script>
-</head>
-<body>
-<script>
-setAlertUser(false);
-testCheckParentheses()
-// additions to jsUnit
-function assertTrue(comment, value)
-{
-  return assertEquals(comment, true, value);
-}
-
-function assertFalse(comment, value)
-{
-  return assertEquals(comment, false, value);
-}
-
-function testRemoveEscapes()
-{
-  var query = "\\* foo \\haha";
-  assertEquals(query, " foo aha", removeEscapes(query));
-  query = "\\\\foo";
-  assertEquals(query, "foo", removeEscapes(query));
-  query = "foo\\\"";
-  assertEquals(query, "foo", removeEscapes(query));
-}
-
-function testCheckAllowedCharacters()
-{
-  var query ="a-zA-Z0-9_+\-:.()\"*?&|!{}\[\]\^~\\@#/$%'= ";
-  assertTrue(query, checkAllowedCharacters(query));
-  
-  query = "foobar";
-  assertFalse(query, checkAllowedCharacters(query));
-}
-
-function testQueryParser()
-{
-  // taken from TestQueryParser.java
-  query = "a AND b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "(a AND b)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+a +b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "c OR (a AND b)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "c (+a +b)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a AND NOT b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+a -b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a AND -b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  //query = "a AND !b"; 
-  //assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a && b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  //query = "a && ! b";
-  //assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a OR b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a || b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  //query = "a OR !b";
-  //assertTrue(query, doCheckLuceneQueryValue(query));
-  //query = "a OR ! b";
-  //assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "a OR -b";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+term -term term";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "foo:term AND field:anotherTerm";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "term AND \"phrase phrase\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "\"hello there\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "germ term^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "(term)^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "term^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "(germ term)^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "term^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "term^2";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "\"germ term\"^2.0";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "\"term germ\"^2";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "(foo OR bar) AND (baz OR boo)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+(foo bar) +(baz boo)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "((a OR b) AND NOT c) OR d";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "(+(a b) -c) d";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+(apple \"steve jobs\") -(foo bar baz)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+(apple \"steve jobs\") -(foo bar baz)";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+title:(dog OR cat) -author:\"bob dole\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  query = "+(title:dog title:cat) -author:\"bob dole\"";    
-  assertTrue(query, doCheckLuceneQueryValue(query));
-}
-
-function testCheckAsterisk()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkAsterisk(query));
-  
-  query = "foo bar12* is ok*";
-  assertTrue(query, checkAsterisk(query));
-  
-  query = "foo bar12*sdsd";
-  assertTrue(query, checkAsterisk(query));
-
-  query = "foo bar12*sd**sd";
-  assertTrue(query, checkAsterisk(query));
-
-  query = "*bar12";
-  assertFalse(query, checkAsterisk(query));
-
-  query = "*ba12r*";
-  assertFalse(query, checkAsterisk(query));
-
-  query = "bar* *bar";
-  assertFalse(query, checkAsterisk(query));
-
-  query = "*";
-  assertFalse(query, checkAsterisk(query));  
-
-  query = "*bar";
-  assertFalse(query, checkAsterisk(query));  
-
-  // test with a space in front
-  query = " *bar";
-  assertFalse(query, checkAsterisk(query));  
-
-  // test the escaped case
-  query = "bar* \\*bar";
-  assertTrue(query, checkAsterisk(query));  
-
-  // try including other special characters
-  query = "foo:bar*ba?r";
-  assertTrue(query, checkAsterisk(query));
-
-  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
-  assertTrue(query, checkAsterisk(query));
-}
-
-function testCheckAmpersands()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkAmpersands(query));
-  
-  query = "foo & bar";
-  assertTrue(query, checkAmpersands(query));
-
-  query = "foo & bar& metoo &";
-  assertTrue(query, checkAmpersands(query));
-
-  query = "foo && bar12isok";
-  assertTrue(query, checkAmpersands(query));
-
-  query = "foo && ! bar";
-  assertTrue(query, checkAmpersands(query));
-
-  query = "bar12 &&";
-  assertFalse(query, checkAmpersands(query));
-  
-  query = "bar12 && bar12 &&";
-  assertFalse(query, checkAmpersands(query));
-  
-  query = "bar12 && ";
-  assertFalse(query, checkAmpersands(query));
- }
-
-function testCheckCaret()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkCaret(query));
-  
-  var query = "foo bar12isok^1.0";
-  assertTrue(query, checkCaret(query));
-  
-  query = "\"jakarta apache\"^10";
-  assertTrue(query, checkCaret(query));
-
-  query = "bar12^";
-  assertFalse(query, checkCaret(query));
-  
-  query = "bar12^10 bar12^";
-  assertFalse(query, checkCaret(query));
-  
-  query = "bar12^ ";
-  assertFalse(query, checkCaret(query));
-
-  query = "bar12^ me too";
-  assertFalse(query, checkCaret(query));
-  
-  query = "bar12^foo";
-  assertFalse(query, checkCaret(query));
-
-  query = "bar12^1.foo";
-  assertFalse(query, checkCaret(query));
-  
-  // test the escaped case
-  query = "\\^";
-  assertTrue(query, checkCaret(query));  
-
-  query = "bar\\^";
-  assertTrue(query, checkCaret(query));  
-
-  // try including other special characters
-  query = "bar*ba?r^1.0";
-  assertTrue(query, checkCaret(query));
-}
-
-function testCheckSquiggle()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkSquiggle(query));
-  
-  var query = "foo bar12isok~10";
-  assertTrue(query, checkSquiggle(query));
-  
-  query = "\"jakarta apache\"~10";
-  assertTrue(query, checkSquiggle(query));
-
-  query = "bar12~";
-  assertTrue(query, checkSquiggle(query));
-  
-  query = "bar12~10 bar12~";
-  assertTrue(query, checkSquiggle(query));
-  
-  query = "bar12~ ";
-  assertTrue(query, checkSquiggle(query));
-
-  query = "bar12~foo";
-  assertFalse(query, checkSquiggle(query));
-  
-  query = "bar12~1f";
-  assertFalse(query, checkSquiggle(query))  
-
-  // test the escaped case
-  query = "\\~";
-  assertTrue(query, checkSquiggle(query));  
-
-  query = "bar\\~";
-  assertTrue(query, checkSquiggle(query));  
-
-  // try including other special characters
-  query = "bar*ba?r~10";
-  assertTrue(query, checkSquiggle(query));
-
-  // FIXME: how about floating point proximity searches, e.g. foo~2.5
-}
-
-function testCheckExclamationMark()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkExclamationMark(query));
-  
-  query = "foo ! bar";
-  assertTrue(query, checkExclamationMark(query));
-  
-  query = "\"foo\" ! \"bar\"";
-  assertTrue(query, checkExclamationMark(query));
-
-  query = "foo!";
-  assertTrue(query, checkExclamationMark(query));
-  
-  query = "foo && ! bar";
-  assertTrue(query, checkExclamationMark(query));  
-
-  query = "foo && !bar";
-  assertTrue(query, checkExclamationMark(query));  
-
-  query = "! bar";
-  assertFalse(query, checkExclamationMark(query));
-
-  query = "foo !";
-  assertFalse(query, checkExclamationMark(query));
-
-  query = "foo ! ";
-  assertFalse(query, checkExclamationMark(query));
-  
-  // test escaped case
-  query = "foo \\!";
-  assertTrue(query, checkExclamationMark(query));
-
-  query = "foo ! bar \\!";
-  assertTrue(query, checkExclamationMark(query));  
-  
-  query = "foo ! bar ! car";
-  assertTrue(query, checkExclamationMark(query));
-
-  query = "foo ! bar !";
-  assertFalse(query, checkExclamationMark(query));
-  
-  query = "foo ! bar !   ";
-  assertFalse(query, checkExclamationMark(query));
-
-  // try more complex queries
-  query = "(foo bar) ! (car:dog*)";
-  assertTrue(query, checkExclamationMark(query));
-}
-
-function testCheckQuestionMark()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkQuestionMark(query));
-
-  query = "foo bar12? is ok?";
-  assertTrue(query, checkQuestionMark(query));
-  
-  query = "foo bar12?sdsd";
-  assertTrue(query, checkQuestionMark(query));
-
-  query = "foo bar12?sd??sd";
-  assertTrue(query, checkQuestionMark(query));
-
-  query = "?bar12";
-  assertFalse(query, checkQuestionMark(query));
-
-  query = "?ba12r?";
-  assertFalse(query, checkQuestionMark(query));
-
-  query = "bar? ?bar";
-  assertFalse(query, checkQuestionMark(query));
-
-  // test with a space in front
-  query = " ?bar";
-  assertFalse(query, checkQuestionMark(query));  
-
-  // test the escaped case
-  query = "bar? \\?bar";
-  assertTrue(query, checkQuestionMark(query));  
-
-  // try including other special characters
-  query = "foo:bar*ba?r";
-  assertTrue(query, checkQuestionMark(query));
-
-  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
-  assertTrue(query, checkQuestionMark(query));
-}
-
-function testCheckParentheses()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkParentheses(query));
-
-  query = "(foobar12:isok)";
-  assertTrue(query, checkParentheses(query));
-  
-  query = "(foobar12):(sdsd* me too)";
-  assertTrue(query, checkParentheses(query));
-
-  query = "(bar12";
-  assertFalse(query, checkParentheses(query));
-
-  query = "ba12r)";
-  assertFalse(query, checkParentheses(query));
-
-  query = "()";
-  assertFalse(query, checkParentheses(query));
-
-  query = "))";
-  assertFalse(query, checkParentheses(query));
-
-  query = "(foo bar) (bar";
-  assertFalse(query, checkParentheses(query));
-
-  query = "(foo bar) bar) me too";
-  assertFalse(query, checkParentheses(query));
-
-  // test with a space in front
-  query = " (bar";
-  assertFalse(query, checkParentheses(query));  
-
-  // test the escaped case
-  query = "foo\\)";
-  assertTrue(query, doCheckLuceneQueryValue(query));  
-
-  query = "foo\\) (foo bar)";
-  assertTrue(query, doCheckLuceneQueryValue(query));  
-
-  // try including other special characters
-  query = "-(foo bar*ba?r)";
-  assertTrue(query, checkParentheses(query));
-
-  query = "+foo:(ba*ba?r zoo -(zaa zoo))";
-  assertTrue(query, checkParentheses(query));
-  
-  query = "((bar12";
-  assertFalse(query, checkParentheses(query));  
-  
-  query = "((bar12)";
-  assertFalse(query, checkParentheses(query));    
-}
-
-function testCheckPlusMinus()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkPlusMinus(query));
-  
-  query = "+bar -foo";
-  assertTrue(query, checkPlusMinus(query));   
-   
-  // is this allowed?
-  query = "baa+foo +foo-bar";
-  assertTrue(query, checkPlusMinus(query));  
-
-  query = "baa+";
-  assertFalse(query, checkPlusMinus(query));   
-  
-  query = "++baa";
-  assertFalse(query, checkPlusMinus(query));   
-
-  query = "+";
-  assertFalse(query, checkPlusMinus(query));   
-
-  query = "-";
-  assertFalse(query, checkPlusMinus(query));   
-  
-  // test the escaped case
-  query = "foo\\+";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-  
-  // try including other special characters
-  query = "-(foo bar*ba?r)";
-  assertTrue(query, checkParentheses(query));
-
-  query = "+foo:(ba*ba?r zoo -(zaa zoo))";
-  assertTrue(query, checkParentheses(query));  
-}
-
-function testCheckANDORNOT()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkANDORNOT(query));
-  
-  query = "foo AND bar";
-  assertTrue(query, checkANDORNOT(query));
-  
-  query = "foo OR bar";
-  assertTrue(query, checkANDORNOT(query));
-  
-  query = "foo NOT bar";
-  assertTrue(query, checkANDORNOT(query));
-
-  query = "foo AND NOT bar";
-  assertTrue(query, checkANDORNOT(query));
-
-  query = "foo NOT bar -foobar";
-  assertTrue(query, checkANDORNOT(query));
-
-  query = "foo AND bar dog AND NOT fox";
-  assertTrue(query, checkANDORNOT(query));
-
-  query = "foo and";
-  assertTrue(query, checkANDORNOT(query));
-
-  query = "and bar";
-  assertTrue(query, checkANDORNOT(query)); 
-
-  query = "fooAND bar";
-  assertTrue(query, checkANDORNOT(query)); 
-
-  query = "foo ANDbar";
-  assertTrue(query, checkANDORNOT(query)); 
-
-  query = "AND bar";
-  assertFalse(query, checkANDORNOT(query));
-
-  query = "OR bar";
-  assertFalse(query, checkANDORNOT(query));  
-
-  query = "NOT bar";
-  assertFalse(query, checkANDORNOT(query));  
-
-  query = "foo AND";
-  assertFalse(query, checkANDORNOT(query));  
-
-  query = "foo AND "; // note the space
-  assertFalse(query, checkANDORNOT(query));  
-
-  query = "AND AND";
-  assertFalse(query, checkANDORNOT(query));
-
-  query = "AND";
-  assertFalse(query, checkANDORNOT(query));
-}
-
-function testCheckQuotes()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkQuotes(query));
-
-  query = "\"foobar12:isok\"";
-  assertTrue(query, checkQuotes(query));
-  
-  query = "\"(foobar12)\":(sdsd* me too)";
-  assertTrue(query, checkQuotes(query));
-
-  query = "\"bar12";
-  assertFalse(query, checkQuotes(query));
-  
-  query = "\"\"";
-  assertFalse(query, checkQuotes(query));  
-
-  query = "ba12r\"";
-  assertFalse(query, checkQuotes(query));
-  
-  query = "\"foo bar\" \"bar";
-  assertFalse(query, checkQuotes(query));
-
-  query = "\"foo bar\" bar\" me too";
-  assertFalse(query, checkQuotes(query));
-
-  // test with a space in front
-  query = " \"bar";
-  assertFalse(query, checkQuotes(query));  
-
-  // test the escaped case
-  query = "foo\\\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));  
-
-  query = "foo\\\" \"foo bar\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));  
-
-  // try including other special characters
-  query = "\"foo bar*ba?r\"";
-  assertTrue(query, checkQuotes(query));
-
-  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
-  assertTrue(query, checkQuotes(query));
-
-  query = "\\\"\\\"bar12\\\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-
-  query = "\\\"\\\"bar12\\\"\\\"";
-  assertTrue(query, doCheckLuceneQueryValue(query));
-}
-
-function testCheckColon()
-{
-  var query = "foo bar is ok";
-  assertTrue(query, checkColon(query));
-
-  query = "foobar12:isok";
-  assertTrue(query, checkColon(query));
-  
-  query = "(foobar12):(sdsd* me too)";
-  assertTrue(query, checkColon(query));
-
-  query = "bar12:";
-  assertFalse(query, checkColon(query));
-
-  query = ":ba12r";
-  assertFalse(query, checkColon(query));
-
-  query = "foo:bar :bar";
-  assertFalse(query, checkColon(query));
-
-  query = "foo:bar bar: me too";
-  assertFalse(query, checkColon(query));
-
-  // test with a space in front
-  query = " :bar";
-  assertFalse(query, checkColon(query));  
-
-  // test the escaped case
-  query = "foo\\:";
-  assertTrue(query, checkColon(query));  
-
-  query = "foo\\: foo:bar";
-  assertTrue(query, checkColon(query));  
-
-  // try including other special characters
-  query = "foo:bar*ba?r";
-  assertTrue(query, checkColon(query));
-
-  query = "foo:(ba*ba?r zoo \"zaa zoo\")";
-  assertTrue(query, checkColon(query));
-}
-</script>
-</body>
-</html>
diff --git a/sandbox/contributions/lucli/META-INF/MANIFEST.MF b/sandbox/contributions/lucli/META-INF/MANIFEST.MF
deleted file mode 100644
index bd81eaf..0000000
--- a/sandbox/contributions/lucli/META-INF/MANIFEST.MF
+++ /dev/null
@@ -1,2 +0,0 @@
-Main-Class: lucli.Lucli
-Class-Path: lib/libreadline-java.jar lib/lucene.jar
diff --git a/sandbox/contributions/lucli/README b/sandbox/contributions/lucli/README
deleted file mode 100644
index 3b673f0..0000000
--- a/sandbox/contributions/lucli/README
+++ /dev/null
@@ -1,29 +0,0 @@
-lucli (pronounced Luckily) is the Lucene Command Line Interface.
-
-INSTALLATION
-
-Edit the run.sh shell script
-	Edit JAVA_HOME to point to your java directory.
-	Edit LUCLI to point to where you installed lucli.
-	Edit LUCLI_MEMORY and set it to the maximum amount of memory you want to allocate to lucli
-	You can also replace the Lucene jar file that came with lucli with your own.
-
-
-ENABLING READLINE
-
-If you add the -r command line parameter lucli will try to use a shared library 
-to enable things like tab completion and history. Unfortunately Java doesn't support 
-this capability natively so you'll need a shared library for this. I'm including one
-that worked for me with Debian Linux.
-For more details about GNU readline and java see http://java-readline.sourceforge.net/
-which is the library that lucli uses.
-
-
-Documentation
-
-There is none :-). Type help at the command line or read the code.
-
-Enjoy
-
-Dror Matalon
-dror@zapatec.com.
diff --git a/sandbox/contributions/lucli/build.xml b/sandbox/contributions/lucli/build.xml
deleted file mode 100644
index 9e8a970..0000000
--- a/sandbox/contributions/lucli/build.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0"?>
-
-<project name="lucli" default="default">
-
-  <description>
-    Lucene Command Line Interface
-  </description>
-
-
-  <path id="additional.dependencies">
-    <pathelement location="lib/libreadline-java.jar"/>
-  </path>
-
-  <pathconvert property="project.classpath"
-               targetos="unix"
-               refid="additional.dependencies"
-  />
-
-  <property name="src.dir" location="src"/>
-
-  <target name="dist" depends="compile" description="Create JAR">
-    <jar jarfile="${dist.dir}/${dist.name}.jar"
-         basedir="${build.classes.dir}"
-         manifest="META-INF/MANIFEST.MF"
-    />
-  </target>
-
-  <import file="../common.xml"/>
-</project>
diff --git a/sandbox/contributions/lucli/lib/README b/sandbox/contributions/lucli/lib/README
deleted file mode 100644
index d3d6512..0000000
--- a/sandbox/contributions/lucli/lib/README
+++ /dev/null
@@ -1 +0,0 @@
-Place libreadline-java.jar.
diff --git a/sandbox/contributions/lucli/run.sh b/sandbox/contributions/lucli/run.sh
deleted file mode 100755
index cd0df9d..0000000
--- a/sandbox/contributions/lucli/run.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-LUCLI=.
-LUCLI_MEMORY=128M
-#JAVA_HOME=/home/dror/j2sdk1.4.1_03/
-CLASSPATH=${CLASSPATH}:$LUCLI/lib/libreadline-java.jar:$LUCLI/lib/lucene.jar:$LUCLI/dist/lucli-dev.jar
-PATH=${PATH}:$JAVA_HOME/bin
-LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:$LUCLI
-export LD_LIBRARY_PATH
-export CLASSPATH
-$JAVA_HOME/bin/java -Xmx${LUCLI_MEMORY} lucli.Lucli
-#Use this line to enable tab completion. Depends on the Readline shares library
-#$JAVA_HOME/bin/java lucli.Lucli -r
-
diff --git a/sandbox/contributions/lucli/src/lucli/Completer.java b/sandbox/contributions/lucli/src/lucli/Completer.java
deleted file mode 100644
index a726726..0000000
--- a/sandbox/contributions/lucli/src/lucli/Completer.java
+++ /dev/null
@@ -1,118 +0,0 @@
-package lucli;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache Lucene" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache Lucene", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import org.gnu.readline.*;
-import java.util.Iterator;
-import java.util.TreeMap;
-
-/**
- * Provide for tab completion
- * When the user types a tab do the standard thing: complete the command
- * Two tabs show all possible completions.
- */
-
-
-public class Completer implements ReadlineCompleter {
-
-	String[] words; //list of words
-	int currentPosition = 0; //current position in the array
-
-	/**
-		Default constructor.
-		*/
-
-	public Completer (TreeMap wordMap) {
-		int size = wordMap.size();
-		words = new String[size];
-		Iterator wordIterator = wordMap.keySet().iterator();
-		for (int ii=0; wordIterator.hasNext(); ii++) {
-			words[ii] = (String) wordIterator.next();
-		}
-	}
-
-
-	/**
-		Return possible completion. Implements org.gnu.readline.ReadlineCompleter.
-		*/
-
-	public String completer (String text, int state) {
-
-		String ret = null; //what we're returning
-		for (int ii = currentPosition; ii < words.length; ii++) {
-			if (words[ii].startsWith(text)) {
-				int next = ii + 1;
-				if ((next < words.length) && words[next].startsWith(text)) {
-					//more than one word match
-					currentPosition = ii + 1; //next time start with next one
-					ret = words[ii];
-					break;
-				} else { //found the last one
-					if (state == 0) { //if it's the only one
-						ret = words[ii];
-						break;
-					} else {
-						ret = null; //there were previous ones
-						break;
-					}
-				}
-			}
-		}
-		if (ret == null)
-			currentPosition = 0; //for next search
-		//System.out.println("returned:" + ret);
-		return (ret); //no more matches
-	}
-}
diff --git a/sandbox/contributions/lucli/src/lucli/LuceneMethods.java b/sandbox/contributions/lucli/src/lucli/LuceneMethods.java
deleted file mode 100644
index 15bae4b..0000000
--- a/sandbox/contributions/lucli/src/lucli/LuceneMethods.java
+++ /dev/null
@@ -1,380 +0,0 @@
-package lucli;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache Lucene" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache Lucene", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import java.io.IOException;
-import java.io.BufferedReader;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-
-import java.util.Hashtable;
-import java.util.Vector;
-import java.util.TreeMap;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.Enumeration;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.Token;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.standard.StandardAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermEnum;
-import org.apache.lucene.queryParser.MultiFieldQueryParser;
-import org.apache.lucene.queryParser.ParseException;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Searcher;
-
-/*
- * Parts addapted from Lucene demo. Various methods that interact with
- * Lucene and provide info about the index, search, etc.
- */
-
-class LuceneMethods {
-
-  private int numDocs;
-  private String indexName; //directory of this index
-  java.util.Iterator fieldIterator;
-  Vector fields; //Fields as a vector
-  Vector indexedFields; //Fields as a vector
-  String fieldsArray[]; //Fields as an array
-  Searcher searcher;
-  Query query; //current query string
-
-  public LuceneMethods(String index) {
-    indexName = index;
-    message("Lucene CLI. Using directory '" + indexName + "'. Type 'help' for instructions.");
-  }
-
-
-  public void info() throws java.io.IOException {
-    IndexReader indexReader = IndexReader.open(indexName);
-
-
-    getFieldInfo();
-    numDocs = indexReader.numDocs();
-    message("Index has " + numDocs + " documents ");
-    message("All Fields:" + fields.toString());
-    message("Indexed Fields:" + indexedFields.toString());
-
-    if (IndexReader.isLocked(indexName)) {
-      message("Index is locked");
-    }
-    //IndexReader.getCurrentVersion(indexName);
-    //System.out.println("Version:" + version);
-
-    indexReader.close();
-  }
-
-
-  public void search(String queryString, boolean explain, boolean showTokens) throws java.io.IOException, org.apache.lucene.queryParser.ParseException {
-    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
-    Hits hits = initSearch(queryString);
-    System.out.println(hits.length() + " total matching documents");
-    if (explain) {
-      query = explainQuery(queryString);
-    }
-
-
-    final int HITS_PER_PAGE = 10;
-    message("--------------------------------------");
-    for (int start = 0; start < hits.length(); start += HITS_PER_PAGE) {
-      int end = Math.min(hits.length(), start + HITS_PER_PAGE);
-      for (int ii = start; ii < end; ii++) {
-        Document doc = hits.doc(ii);
-        message("---------------- " + (ii + 1) + " score:" + hits.score(ii) + "---------------------");
-        printHit(doc);
-        if (showTokens) {
-          invertDocument(doc);
-        }
-        if (explain) {
-          Explanation exp = searcher.explain(query, hits.id(ii));
-          message("Explanation:" + exp.toString());
-        }
-      }
-      message("#################################################");
-
-      if (hits.length() > end) {
-        System.out.print("more (y/n) ? ");
-        queryString = in.readLine();
-        if (queryString.length() == 0 || queryString.charAt(0) == 'n')
-          break;
-      }
-    }
-    searcher.close();
-  }
-
-  /**
-   * @todo Allow user to specify what field(s) to display
-   */
-  private void printHit(Document doc) {
-    for (int ii = 0; ii < fieldsArray.length; ii++) {
-      String currField = fieldsArray[ii];
-      String[] result = doc.getValues(currField);
-      if (result != null) {
-        for (int i = 0; i < result.length; i++) {
-          message(currField + ":" + result[i]);
-        }
-      } else {
-        message(currField + ": <not available>");
-      }
-    }
-    //another option is to just do message(doc);
-  }
-
-  public void optimize() throws IOException {
-    //open the index writer. False: don't create a new one
-    IndexWriter indexWriter = new IndexWriter(indexName, new StandardAnalyzer(), false);
-    message("Starting to optimize index.");
-    long start = System.currentTimeMillis();
-    indexWriter.optimize();
-    message("Done optimizing index. Took " + (System.currentTimeMillis() - start) + " msecs");
-    indexWriter.close();
-  }
-
-
-  private Query explainQuery(String queryString) throws IOException, ParseException {
-
-    searcher = new IndexSearcher(indexName);
-    Analyzer analyzer = new StandardAnalyzer();
-    getFieldInfo();
-
-    MultiFieldQueryParser parser = new MultiFieldQueryParser(queryString, analyzer);
-
-    int arraySize = indexedFields.size();
-    String indexedArray[] = new String[arraySize];
-    for (int ii = 0; ii < arraySize; ii++) {
-      indexedArray[ii] = (String) indexedFields.get(ii);
-    }
-    query = parser.parse(queryString, indexedArray, analyzer);
-    System.out.println("Searching for: " + query.toString());
-    return (query);
-
-  }
-
-  /**
-   * @todo Allow user to specify analyzer
-   */
-  private Hits initSearch(String queryString) throws IOException, ParseException {
-
-    searcher = new IndexSearcher(indexName);
-    Analyzer analyzer = new StandardAnalyzer();
-    getFieldInfo();
-
-    MultiFieldQueryParser parser = new MultiFieldQueryParser(queryString, analyzer);
-
-    int arraySize = fields.size();
-    fieldsArray = new String[arraySize];
-    for (int ii = 0; ii < arraySize; ii++) {
-      fieldsArray[ii] = (String) fields.get(ii);
-    }
-    query = parser.parse(queryString, fieldsArray, analyzer);
-    System.out.println("Searching for: " + query.toString());
-    Hits hits = searcher.search(query);
-    return (hits);
-
-  }
-
-  public void count(String queryString) throws java.io.IOException, ParseException {
-    Hits hits = initSearch(queryString);
-    System.out.println(hits.length() + " total documents");
-    searcher.close();
-  }
-
-  static public void message(String s) {
-    System.out.println(s);
-  }
-
-  private void getFieldInfo() throws IOException {
-    IndexReader indexReader = IndexReader.open(indexName);
-    fields = new Vector();
-    indexedFields = new Vector();
-
-    //get the list of all field names
-    fieldIterator = indexReader.getFieldNames().iterator();
-    while (fieldIterator.hasNext()) {
-      Object field = fieldIterator.next();
-      if (field != null && !field.equals(""))
-        fields.add(field.toString());
-    }
-    //
-    //get the list of indexed field names
-    fieldIterator = indexReader.getFieldNames(true).iterator();
-    while (fieldIterator.hasNext()) {
-      Object field = fieldIterator.next();
-      if (field != null && !field.equals(""))
-        indexedFields.add(field.toString());
-    }
-    indexReader.close();
-  }
-
-
-  // Copied from DocumentWriter
-  // Tokenizes the fields of a document into Postings.
-  private void invertDocument(Document doc)
-    throws IOException {
-
-    Hashtable tokenHash = new Hashtable();
-    final int maxFieldLength = 10000;
-
-    Analyzer analyzer = new StandardAnalyzer();
-    Enumeration fields = doc.fields();
-    while (fields.hasMoreElements()) {
-      Field field = (Field) fields.nextElement();
-      String fieldName = field.name();
-
-
-      if (field.isIndexed()) {
-        if (field.isTokenized()) {     // un-tokenized field
-          Reader reader;        // find or make Reader
-          if (field.readerValue() != null)
-            reader = field.readerValue();
-          else if (field.stringValue() != null)
-            reader = new StringReader(field.stringValue());
-          else
-            throw new IllegalArgumentException
-              ("field must have either String or Reader value");
-
-          int position = 0;
-          // Tokenize field and add to postingTable
-          TokenStream stream = analyzer.tokenStream(fieldName, reader);
-          try {
-            for (Token t = stream.next(); t != null; t = stream.next()) {
-              position += (t.getPositionIncrement() - 1);
-              position++;
-              String name = t.termText();
-              Integer Count = (Integer) tokenHash.get(name);
-              if (Count == null) { // not in there yet
-                tokenHash.put(name, new Integer(1)); //first one
-              } else {
-                int count = Count.intValue();
-                tokenHash.put(name, new Integer(count + 1));
-              }
-              if (position > maxFieldLength) break;
-            }
-          } finally {
-            stream.close();
-          }
-        }
-
-      }
-    }
-    Entry[] sortedHash = getSortedHashtableEntries(tokenHash);
-    for (int ii = 0; ii < sortedHash.length && ii < 10; ii++) {
-      Entry currentEntry = sortedHash[ii];
-      message((ii + 1) + ":" + currentEntry.getKey() + " " + currentEntry.getValue());
-    }
-  }
-
-
-  /** Provides a list of the top terms of the index.
-   *
-   * @param field  - the name of the command or null for all of them.
-   */
-  public void terms(String field) throws IOException {
-    TreeMap termMap = new TreeMap();
-    IndexReader indexReader = IndexReader.open(indexName);
-    TermEnum terms = indexReader.terms();
-    while (terms.next()) {
-      Term term = terms.term();
-      //message(term.field() + ":" + term.text() + " freq:" + terms.docFreq());
-      //if we're either not looking by field or we're matching the specific field
-      if ((field == null) || field.equals(term.field()))
-        termMap.put(term.field() + ":" + term.text(), new Integer((terms.docFreq())));
-    }
-
-    Iterator termIterator = termMap.keySet().iterator();
-    for (int ii = 0; termIterator.hasNext() && ii < 100; ii++) {
-      String termDetails = (String) termIterator.next();
-      Integer termFreq = (Integer) termMap.get(termDetails);
-      message(termDetails + ": " + termFreq);
-    }
-    indexReader.close();
-  }
-
-  /** Sort Hashtable values
-   * @param h the hashtable we're sorting
-   * from http://developer.java.sun.com/developer/qow/archive/170/index.jsp
-   */
-
-  public static Entry[]
-    getSortedHashtableEntries(Hashtable h) {
-    Set set = h.entrySet();
-    Entry[] entries =
-      (Entry[]) set.toArray(
-        new Entry[set.size()]);
-    Arrays.sort(entries, new Comparator() {
-      public int compare(Object o1, Object o2) {
-        Object v1 = ((Entry) o1).getValue();
-        Object v2 = ((Entry) o2).getValue();
-        return ((Comparable) v2).compareTo(v1); //descending order
-      }
-    });
-    return entries;
-  }
-
-}
-
diff --git a/sandbox/contributions/lucli/src/lucli/Lucli.java b/sandbox/contributions/lucli/src/lucli/Lucli.java
deleted file mode 100644
index dd551ef..0000000
--- a/sandbox/contributions/lucli/src/lucli/Lucli.java
+++ /dev/null
@@ -1,382 +0,0 @@
-package lucli;
-
-/* ====================================================================
- * The Apache Software License, Version 1.1
- *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
- * reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Apache Software Foundation (http://www.apache.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The names "Apache" and "Apache Software Foundation" and
- *    "Apache Lucene" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache",
- *    "Apache Lucene", nor may "Apache" appear in their name, without
- *    prior written permission of the Apache Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Software Foundation.  For more
- * information on the Apache Software Foundation, please see
- * <http://www.apache.org/>.
- */
-
-import java.io.*;
-import org.gnu.readline.*;
-import org.apache.lucene.queryParser.ParseException;
-import java.util.StringTokenizer;
-import java.util.TreeMap;
-import java.util.Iterator;
-
-/**
- * lucli Main class for lucli: the Lucene Command Line Interface
- * This class handles mostly the actual CLI part, command names, help, etc.
- */
-
-public class Lucli {
-
-	final static String DEFAULT_INDEX = "index"; //directory "index" under the current directory
-	final static String HISTORYFILE = ".lucli"; //history file in user's home directory
-	public final static int MAX_TERMS = 100; //Maximum number of terms we're going to show
-
-	// List of commands
-	// To add another command, add it in here, in the list of addcomand(), and in the switch statement
-	final static int NOCOMMAND = -2;
-	final static int UNKOWN = -1;
-	final static int INFO = 0;
-	final static int SEARCH = 1;
-	final static int OPTIMIZE = 2;
-	final static int QUIT = 3;
-	final static int HELP = 4;
-	final static int COUNT = 5;
-	final static int TERMS = 6;
-	final static int INDEX = 7;
-	final static int TOKENS = 8;
-	final static int EXPLAIN = 9;
-
-	String fullPath;
-	TreeMap commandMap = new TreeMap();
-	LuceneMethods luceneMethods; //current cli class we're using
-	boolean enableReadline; //false: use plain java. True: shared library readline
-
-	/**
-		Main entry point. The first argument can be a filename with an
-		application initialization file.
-		*/
-
-	public Lucli(String[] args) throws ParseException, IOException {
-		String line;
-
-		fullPath = System.getProperty("user.home") +  System.getProperty("file.separator")
-			+ HISTORYFILE;
-
-		/*
-		 * Initialize the list of commands
-		 */
-
-		addCommand("info", INFO, "Display info about the current Lucene index. Example: info");
-		addCommand("search", SEARCH, "Search the current index. Example: search foo", 1);
-		addCommand("count", COUNT, "Return the number of hits for a search. Example: count foo", 1);
-		addCommand("optimize", OPTIMIZE, "Optimize the current index");
-		addCommand("quit", QUIT, "Quit/exit the program");
-		addCommand("help", HELP, "Display help about commands");
-		addCommand("terms", TERMS, "Show the first " + MAX_TERMS + " terms in this index. Supply a field name to only show terms in a specific field. Example: terms");
-		addCommand("index", INDEX, "Choose a different lucene index. Example index my_index", 1);
-		addCommand("tokens", TOKENS, "Does a search and shows the top 10 tokens for each document. Verbose! Example: tokens foo", 1);
-		addCommand("explain", EXPLAIN, "Explanation that describes how the document scored against query. Example: explain foo", 1);
-
-
-
-		//parse command line arguments
-		parseArgs(args);
-
-		if (enableReadline)
-			org.gnu.readline.Readline.load(ReadlineLibrary.GnuReadline  );
-		else
-			org.gnu.readline.Readline.load(ReadlineLibrary.PureJava  );
-
-		Readline.initReadline("lucli"); // init, set app name, read inputrc
-
-
-
-		Readline.readHistoryFile(fullPath);
-
-		// read history file, if available
-
-		File history = new File(".rltest_history");
-		try {
-			if (history.exists())
-				Readline.readHistoryFile(history.getName());
-		} catch (Exception e) {
-			System.err.println("Error reading history file!");
-		}
-
-		// Set word break characters
-		try {
-			Readline.setWordBreakCharacters(" \t;");
-		}
-		catch (UnsupportedEncodingException enc) {
-			System.err.println("Could not set word break characters");
-			System.exit(0);
-		}
-
-		// set completer with list of words
-
-		Readline.setCompleter(new Completer(commandMap));
-
-		// main input loop
-
-		luceneMethods = new LuceneMethods(DEFAULT_INDEX);
-
-		while (true) {
-			try {
-				line = Readline.readline("lucli> ");
-				if (line != null) {
-					handleCommand(line);
-				}
-			} catch (UnsupportedEncodingException enc) {
-				System.err.println("caught UnsupportedEncodingException");
-				break;
-			} catch (java.io.EOFException eof) {
-				System.out.println("");//new line
-				exit();
-			} catch (IOException ioe) {
-				ioe.printStackTrace(System.err);
-			}
-		}
-
-		exit();
-	}
-
-	public static void main(String[] args) throws ParseException, IOException {
-		new Lucli(args);
-	}
-
-
-	private void handleCommand(String line) throws IOException, ParseException {
-		String [] words = tokenizeCommand(line);
-		if (words.length == 0)
-			return; //white space
-		String query = "";
-		//Command name and number of arguments
-		switch (getCommandId(words[0], words.length - 1)) {
-			case INFO:
-				luceneMethods.info();
-				break;
-			case SEARCH:
-				for (int ii = 1; ii < words.length; ii++) {
-					query += words[ii] + " ";
-				}
-				luceneMethods.search(query, false, false);
-				break;
-			case COUNT:
-				for (int ii = 1; ii < words.length; ii++) {
-					query += words[ii] + " ";
-				}
-				luceneMethods.count(query);
-				break;
-			case QUIT:
-				exit();
-				break;
-			case TERMS:
-				if(words.length > 1)
-					luceneMethods.terms(words[1]);
-				else
-					luceneMethods.terms(null);
-				break;
-			case INDEX:
-				LuceneMethods newLm = new LuceneMethods(words[1]);
-				try {
-					newLm.info(); //will fail if can't open the index
-					luceneMethods = newLm; //OK, so we'll use the new one
-				} catch (IOException ioe) {
-					//problem we'll keep using the old one
-					error(ioe.toString());
-				}
-				break;
-			case OPTIMIZE:
-				luceneMethods.optimize();
-				break;
-			case TOKENS:
-				for (int ii = 1; ii < words.length; ii++) {
-					query += words[ii] + " ";
-				}
-				luceneMethods.search(query, false, true);
-				break;
-			case EXPLAIN:
-				for (int ii = 1; ii < words.length; ii++) {
-					query += words[ii] + " ";
-				}
-				luceneMethods.search(query, true, false);
-				break;
-			case HELP:
-				help();
-				break;
-			case NOCOMMAND: //do nothing
-				break;
-			case UNKOWN:
-				System.out.println("Unknown command:" + words[0] + ". Type help to get a list of commands.");
-				break;
-		}
-	}
-
-	private String [] tokenizeCommand(String line) {
-		StringTokenizer tokenizer = new StringTokenizer(line, " \t");
-		int size = tokenizer.countTokens();
-		String [] tokens = new String[size];
-		for (int ii = 0; tokenizer.hasMoreTokens(); ii++) {
-			tokens[ii]  = tokenizer.nextToken();
-		}
-		return tokens;
-	}
-
-	private void exit() {
-
-		try {
-			Readline.writeHistoryFile(fullPath);
-		} catch (IOException ioe) {
-			error("while saving history:" + ioe);
-		}
-		Readline.cleanup();
-		System.exit(0);
-	}
-
-	/**
-	 * Add a command to the list of commands for the interpreter for a
-	 * command that doesn't take any parameters.
-	 * @param name  - the name of the command
-	 * @param id  - the unique id of the command
-	 * @param help  - the help message for this command
-	 */
-	private void addCommand(String name, int id, String help) {
-		addCommand(name, id, help, 0);
-	}
-
-	/**
-	 * Add a command to the list of commands for the interpreter.
-	 * @param name  - the name of the command
-	 * @param id  - the unique id of the command
-	 * @param help  - the help message for this command
-	 * @param params  - the minimum number of required params if any
-	 */
-	private void addCommand(String name, int id, String help, int params) {
-		Command command = new Command(name, id, help, params);
-		commandMap.put(name, command);
-	}
-
-	private int getCommandId(String name, int params) {
-		name.toLowerCase(); //treat uppercase and lower case commands the same
-		Command command = (Command) commandMap.get(name);
-		if (command == null) {
-			return(UNKOWN);
-		}
-		else {
-			if(command.params > params) {
-				error(command.name + " needs at least " + command.params + " arguments.");
-				return (NOCOMMAND);
-			}
-			return (command.id);
-		}
-	}
-
-	private void help() {
-		Iterator commands = commandMap.keySet().iterator();
-		while (commands.hasNext()) {
-			Command command = (Command) commandMap.get(commands.next());
-			System.out.println("\t" + command.name + ": " + command.help);
-
-		}
-	}
-
-	private void error(String message) {
-		System.err.println("Error:" + message);
-	}
-
-	private void message(String text) {
-		System.out.println(text);
-	}
-
-
-	/*
-	 * Parse command line arguments
-	 * Code inspired by http://www.ecs.umass.edu/ece/wireless/people/emmanuel/java/java/cmdLineArgs/parsing.html
-	 */
-	private void parseArgs(String[] args) {
-		for (int ii = 0; ii < args.length; ii++) {
-			// a little overkill for now, but foundation
-			// for other args
-			if (args[ii].startsWith("-")) {
-				String arg = args[ii];
-				if (arg.equals("-r")) {
-					enableReadline = true;
-				}
-				else {
-					usage();
-					System.exit(1);
-				}
-			}
-		}
-	}
-
-	private void usage() {
-		message("Usage: lucli [-r]");
-		message("Arguments:");
-		message("\t-r: Provide tab completion and history using the GNU readline shared library ");
-	}
-
-	private class Command {
-		String name;
-		int id;
-		int numberArgs;
-		String help;
-		int params;
-
-		Command(String name, int id, String help, int params) {
-			this.name = name;
-			this.id = id;
-			this.help = help;
-			this.params = params;
-		}
-
-		/**
-		 * Prints out a usage message for this command.
-		 */
-		public String commandUsage() {
-			return (name + ":" + help + ". Command takes " + params + " params");
-		}
-
-	}
-}

