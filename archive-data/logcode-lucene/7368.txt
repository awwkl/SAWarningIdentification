GitDiffStart: 034595f5e9f4cd16f43175d93145f35fccf88cdc | Mon Dec 2 23:44:13 2013 +0000
diff --git a/TODO b/TODO
index 7a29bc8..986b6c3 100644
--- a/TODO
+++ b/TODO
@@ -7,11 +7,9 @@ TODO
   - getSpecificValue for a dim isn't reliable
   - we could put more stuff into the "schema", e.g. this field is
     sorted-set-DV and that one is taxo?
-  - standardize on facet or facets (e.g. FacetIndexWriter)
-  - fewer args when constructing a range
   - how to do avg() agg?
-  - consistently name things "dimension"? calling these fields is CONFUSING
   - later
+    - fewer args when constructing a range
     - SSDVValueSourceFacets?
     - add hierarchy to ssdv facets?
     - sparse faceting: allow skipping of certain dims?
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
index 1b67f00..cf13c0f 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
@@ -20,14 +20,11 @@ package org.apache.lucene.demo.facet;
 import java.io.Closeable;
 import java.io.IOException;
 import java.text.ParseException;
-import java.util.List;
 
 import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.LongField;
-import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.expressions.Expression;
 import org.apache.lucene.expressions.SimpleBindings;
 import org.apache.lucene.expressions.js.JavascriptCompiler;
@@ -37,14 +34,13 @@ import org.apache.lucene.facet.DrillDownQuery;
 import org.apache.lucene.facet.FacetResult;
 import org.apache.lucene.facet.Facets;
 import org.apache.lucene.facet.FacetsCollector;
-import org.apache.lucene.facet.FacetsConfig;
-import org.apache.lucene.facet.LongRange;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.NumericRangeQuery;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
@@ -56,6 +52,11 @@ import org.apache.lucene.store.RAMDirectory;
  *  expressions module to calculate distance. */
 public class DistanceFacetsExample implements Closeable {
 
+  final DoubleRange ONE_KM = new DoubleRange("< 1 km", 0.0, true, 1.0, false);
+  final DoubleRange TWO_KM = new DoubleRange("< 2 km", 0.0, true, 2.0, false);
+  final DoubleRange FIVE_KM = new DoubleRange("< 5 km", 0.0, true, 5.0, false);
+  final DoubleRange TEN_KM = new DoubleRange("< 10 km", 0.0, true, 10.0, false);
+
   private final Directory indexDir = new RAMDirectory();
   private IndexSearcher searcher;
 
@@ -88,9 +89,7 @@ public class DistanceFacetsExample implements Closeable {
     writer.close();
   }
 
-  /** User runs a query and counts facets. */
-  public FacetResult search() throws IOException {
-
+  private ValueSource getDistanceValueSource() {
     Expression distance;
     try {
       distance = JavascriptCompiler.compile("haversin(40.7143528,-74.0059731,latitude,longitude)");
@@ -102,22 +101,37 @@ public class DistanceFacetsExample implements Closeable {
     bindings.add(new SortField("latitude", SortField.Type.DOUBLE));
     bindings.add(new SortField("longitude", SortField.Type.DOUBLE));
 
+    return distance.getValueSource(bindings);
+  }
+
+  /** User runs a query and counts facets. */
+  public FacetResult search() throws IOException {
+
+
     FacetsCollector fc = new FacetsCollector();
 
     searcher.search(new MatchAllDocsQuery(), fc);
 
-    Facets facets = new DoubleRangeFacetCounts("field", distance.getValueSource(bindings), fc,
-        new DoubleRange("< 1 km", 0.0, true, 1.0, false),
-        new DoubleRange("< 2 km", 0.0, true, 2.0, false),
-        new DoubleRange("< 5 km", 0.0, true, 5.0, false),
-        new DoubleRange("< 10 km", 0.0, true, 10.0, false),
-        new DoubleRange("< 20 km", 0.0, true, 20.0, false),
-        new DoubleRange("< 50 km", 0.0, true, 50.0, false));
+    Facets facets = new DoubleRangeFacetCounts("field", getDistanceValueSource(), fc,
+                                               ONE_KM,
+                                               TWO_KM,
+                                               FIVE_KM,
+                                               TEN_KM);
 
     return facets.getTopChildren(10, "field");
   }
 
-  // nocommit how to show drillDown?
+  /** User drills down on the specified range. */
+  public TopDocs drillDown(DoubleRange range) throws IOException {
+
+    // Passing no baseQuery means we drill down on all
+    // documents ("browse only"):
+    DrillDownQuery q = new DrillDownQuery(null);
+
+    q.add("field", new ConstantScoreQuery(range.getFilter(getDistanceValueSource())));
+
+    return searcher.search(q, 10);
+  }
 
   @Override
   public void close() throws IOException {
@@ -128,13 +142,19 @@ public class DistanceFacetsExample implements Closeable {
   /** Runs the search and drill-down examples and prints the results. */
   @SuppressWarnings("unchecked")
   public static void main(String[] args) throws Exception {
-    RangeFacetsExample example = new RangeFacetsExample();
+    DistanceFacetsExample example = new DistanceFacetsExample();
     example.index();
 
-    System.out.println("Dirance facet counting example:");
+    System.out.println("Distance facet counting example:");
     System.out.println("-----------------------");
     System.out.println(example.search());
 
+    System.out.println("\n");
+    System.out.println("Distance facet drill-down example (field/< 2 km):");
+    System.out.println("---------------------------------------------");
+    TopDocs hits = example.drillDown(example.TWO_KM);
+    System.out.println(hits.totalHits + " totalHits");
+
     example.close();
   }
 }
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/RangeFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/RangeFacetsExample.java
index 3647327..d84d0f6 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/RangeFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/RangeFacetsExample.java
@@ -19,7 +19,6 @@ package org.apache.lucene.demo.facet;
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.util.List;
 
 import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.document.Document;
@@ -110,8 +109,6 @@ public class RangeFacetsExample implements Closeable {
     // documents ("browse only"):
     DrillDownQuery q = new DrillDownQuery(getConfig());
 
-    // Use FieldCacheRangeFilter; this will use
-    // NumericDocValues:
     q.add("timestamp", NumericRangeQuery.newLongRange("timestamp", range.min, range.max, range.minInclusive, range.maxInclusive));
 
     return searcher.search(q, 10);
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestAssociationsFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestAssociationsFacetsExample.java
index 810d779..d143a85 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestAssociationsFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestAssociationsFacetsExample.java
@@ -29,7 +29,7 @@ public class TestAssociationsFacetsExample extends LuceneTestCase {
   public void testExamples() throws Exception {
     List<FacetResult> res = new AssociationsFacetsExample().runSumAssociations();
     assertEquals("Wrong number of results", 2, res.size());
-    assertEquals("value=-1 childCount=2\n  lucene (4)\n  solr (2)\n", res.get(0).toString());
-    assertEquals("value=-1.0 childCount=2\n  computing (1.62)\n  software (0.34)\n", res.get(1).toString());
+    assertEquals("dim=tags path=[] value=-1 childCount=2\n  lucene (4)\n  solr (2)\n", res.get(0).toString());
+    assertEquals("dim=genre path=[] value=-1.0 childCount=2\n  computing (1.62)\n  software (0.34)\n", res.get(1).toString());
   }  
 }
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestDistanceFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestDistanceFacetsExample.java
index fd4cd9e..0ab2dc3 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestDistanceFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestDistanceFacetsExample.java
@@ -17,7 +17,6 @@ package org.apache.lucene.demo.facet;
  * limitations under the License.
  */
 
-import java.util.List;
 
 import org.apache.lucene.facet.FacetResult;
 import org.apache.lucene.search.TopDocs;
@@ -31,7 +30,15 @@ public class TestDistanceFacetsExample extends LuceneTestCase {
     DistanceFacetsExample example = new DistanceFacetsExample();
     example.index();
     FacetResult result = example.search();
-    assertEquals("value=3 childCount=6\n  < 1 km (1)\n  < 2 km (2)\n  < 5 km (2)\n  < 10 km (3)\n  < 20 km (3)\n  < 50 km (3)\n", result.toString());
+    assertEquals("dim=field path=[] value=3 childCount=4\n  < 1 km (1)\n  < 2 km (2)\n  < 5 km (2)\n  < 10 km (3)\n", result.toString());
+    example.close();
+  }
+
+  public void testDrillDown() throws Exception {
+    DistanceFacetsExample example = new DistanceFacetsExample();
+    example.index();
+    TopDocs hits = example.drillDown(example.FIVE_KM);
+    assertEquals(2, hits.totalHits);
     example.close();
   }
 }
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestExpressionAggregationFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestExpressionAggregationFacetsExample.java
index 0b4e552..2cc7029 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestExpressionAggregationFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestExpressionAggregationFacetsExample.java
@@ -29,6 +29,6 @@ public class TestExpressionAggregationFacetsExample extends LuceneTestCase {
   @Test
   public void testSimple() throws Exception {
     FacetResult result = new ExpressionAggregationFacetsExample().runSearch();
-    assertEquals("value=3.9681187 childCount=2\n  B (2.236068)\n  C (1.7320508)\n", result.toString());
+    assertEquals("dim=A path=[] value=3.9681187 childCount=2\n  B (2.236068)\n  C (1.7320508)\n", result.toString());
   }
 }
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
index 070f0e7..b7e6bc7 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestMultiCategoryListsFacetsExample.java
@@ -29,7 +29,7 @@ public class TestMultiCategoryListsFacetsExample extends LuceneTestCase {
   public void testExample() throws Exception {
     List<FacetResult> results = new MultiCategoryListsFacetsExample().runSearch();
     assertEquals(2, results.size());
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", results.get(0).toString());
-    assertEquals("value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", results.get(0).toString());
+    assertEquals("dim=Publish Date path=[] value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
   }
 }
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
index 6fe08ad..b548e5a 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestRangeFacetsExample.java
@@ -33,7 +33,7 @@ public class TestRangeFacetsExample extends LuceneTestCase {
     RangeFacetsExample example = new RangeFacetsExample();
     example.index();
     FacetResult result = example.search();
-    assertEquals("value=100 childCount=3\n  Past hour (4)\n  Past six hours (22)\n  Past day (87)\n", result.toString());
+    assertEquals("dim=timestamp path=[] value=100 childCount=3\n  Past hour (4)\n  Past six hours (22)\n  Past day (87)\n", result.toString());
     example.close();
   }
 
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
index dc6e4f4..bacbb4f 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleFacetsExample.java
@@ -30,13 +30,13 @@ public class TestSimpleFacetsExample extends LuceneTestCase {
   public void testSimple() throws Exception {
     List<FacetResult> results = new SimpleFacetsExample().runSearch();
     assertEquals(2, results.size());
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", results.get(0).toString());
-    assertEquals("value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", results.get(0).toString());
+    assertEquals("dim=Publish Date path=[] value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
   }
 
   @Test
   public void testDrillDown() throws Exception {
     FacetResult result = new SimpleFacetsExample().runDrillDown();
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", result.toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", result.toString());
   }
 }
diff --git a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
index 6908dfe..a629d56 100644
--- a/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
+++ b/lucene/demo/src/test/org/apache/lucene/demo/facet/TestSimpleSortedSetFacetsExample.java
@@ -34,13 +34,13 @@ public class TestSimpleSortedSetFacetsExample extends LuceneTestCase {
   public void testSimple() throws Exception {
     List<FacetResult> results = new SimpleSortedSetFacetsExample().runSearch();
     assertEquals(2, results.size());
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Frank (1)\n  Susan (1)\n", results.get(0).toString());
-    assertEquals("value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Frank (1)\n  Susan (1)\n", results.get(0).toString());
+    assertEquals("dim=Publish Year path=[] value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", results.get(1).toString());
   }
 
   @Test
   public void testDrillDown() throws Exception {
     FacetResult result = new SimpleSortedSetFacetsExample().runDrillDown();
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", result.toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", result.toString());
   }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/DoubleRange.java b/lucene/facet/src/java/org/apache/lucene/facet/DoubleRange.java
index 74c8844..a7ab2a2 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/DoubleRange.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/DoubleRange.java
@@ -17,7 +17,17 @@ package org.apache.lucene.facet;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Collections;
+
 import org.apache.lucene.document.DoubleDocValuesField; // javadocs
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.util.Bits;
 
 /** Represents a range over double values. */
 public final class DoubleRange extends Range {
@@ -64,5 +74,73 @@ public final class DoubleRange extends Range {
   public boolean accept(double value) {
     return value >= minIncl && value <= maxIncl;
   }
+
+  /** Returns a new {@link Filter} accepting only documents
+   *  in this range.  Note that this filter is not
+   *  efficient: it's a linear scan of all docs, testing
+   *  each value.  If the {@link ValueSource} is static,
+   *  e.g. an indexed numeric field, then it's more
+   *  efficient to use {@link NumericRangeFilter}. */
+  public Filter getFilter(final ValueSource valueSource) {
+    return new Filter() {
+      @Override
+      public DocIdSet getDocIdSet(AtomicReaderContext context, final Bits acceptDocs) throws IOException {
+
+        // TODO: this is just like ValueSourceScorer,
+        // ValueSourceFilter (spatial),
+        // ValueSourceRangeFilter (solr); also,
+        // https://issues.apache.org/jira/browse/LUCENE-4251
+
+        final FunctionValues values = valueSource.getValues(Collections.emptyMap(), context);
+
+        final int maxDoc = context.reader().maxDoc();
+
+        return new DocIdSet() {
+
+          @Override
+          public DocIdSetIterator iterator() {
+            return new DocIdSetIterator() {
+              int doc = -1;
+
+              @Override
+              public int nextDoc() throws IOException {
+                while (true) {
+                  doc++;
+                  if (doc == maxDoc) {
+                    return doc = NO_MORE_DOCS;
+                  }
+                  if (acceptDocs != null && acceptDocs.get(doc) == false) {
+                    continue;
+                  }
+                  double v = values.doubleVal(doc);
+                  if (accept(v)) {
+                    return doc;
+                  }
+                }
+              }
+
+              @Override
+              public int advance(int target) throws IOException {
+                doc = target-1;
+                return nextDoc();
+              }
+
+              @Override
+              public int docID() {
+                return doc;
+              }
+
+              @Override
+              public long cost() {
+                // Since we do a linear scan over all
+                // documents, our cost is O(maxDoc):
+                return maxDoc;
+              }
+            };
+          }
+        };
+      }
+    };
+  }
 }
 
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts.java
index 5186998..0983899 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/DoubleRangeFacetCounts.java
@@ -24,7 +24,6 @@ import java.util.List;
 import org.apache.lucene.document.DoubleDocValuesField; // javadocs
 import org.apache.lucene.document.FloatDocValuesField; // javadocs
 import org.apache.lucene.facet.FacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
@@ -108,13 +107,16 @@ public class DoubleRangeFacetCounts extends Facets {
     if (dim.equals(field) == false) {
       throw new IllegalArgumentException("invalid dim \"" + dim + "\"; should be \"" + field + "\"");
     }
+    if (path.length != 0) {
+      throw new IllegalArgumentException("path.length should be 0");
+    }
     LabelAndValue[] labelValues = new LabelAndValue[counts.length];
     for(int i=0;i<counts.length;i++) {
       // nocommit can we add the range into this?
       labelValues[i] = new LabelAndValue(ranges[i].label, counts[i]);
     }
 
-    return new FacetResult(totCount, labelValues, labelValues.length);
+    return new FacetResult(dim, path, totCount, labelValues, labelValues.length);
   }
 
   @Override
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/FacetResult.java b/lucene/facet/src/java/org/apache/lucene/facet/FacetResult.java
index 7cbcae9..9c35b1e 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/FacetResult.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/FacetResult.java
@@ -18,10 +18,15 @@ package org.apache.lucene.facet;
  */
 
 import java.util.Arrays;
-import java.util.List;
 
 public final class FacetResult {
 
+  /** Dimension that was requested. */
+  public final String dim;
+
+  /** Path whose children were requested. */
+  public final String[] path;
+
   /** Total value for this path (sum of all child counts, or
    *  sum of all child values), even those not included in
    *  the topN. */
@@ -33,7 +38,9 @@ public final class FacetResult {
   /** Child counts. */
   public final LabelAndValue[] labelValues;
 
-  public FacetResult(Number value, LabelAndValue[] labelValues, int childCount) {
+  public FacetResult(String dim, String[] path, Number value, LabelAndValue[] labelValues, int childCount) {
+    this.dim = dim;
+    this.path = path;
     this.value = value;
     this.labelValues = labelValues;
     this.childCount = childCount;
@@ -42,7 +49,11 @@ public final class FacetResult {
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder();
-    sb.append("value=");
+    sb.append("dim=");
+    sb.append(dim);
+    sb.append(" path=");
+    sb.append(Arrays.toString(path));
+    sb.append(" value=");
     sb.append(value);
     sb.append(" childCount=");
     sb.append(childCount);
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/FloatTaxonomyFacets.java b/lucene/facet/src/java/org/apache/lucene/facet/FloatTaxonomyFacets.java
index 8f89a67..0dfcf11 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/FloatTaxonomyFacets.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/FloatTaxonomyFacets.java
@@ -131,6 +131,6 @@ public abstract class FloatTaxonomyFacets extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[cp.length], ordAndValue.value);
     }
 
-    return new FacetResult(sumValues, labelValues, childCount);
+    return new FacetResult(dim, path, sumValues, labelValues, childCount);
   }
 }
\ No newline at end of file
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/IntTaxonomyFacets.java b/lucene/facet/src/java/org/apache/lucene/facet/IntTaxonomyFacets.java
index 7289a0e..9f678f8 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/IntTaxonomyFacets.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/IntTaxonomyFacets.java
@@ -135,6 +135,6 @@ public abstract class IntTaxonomyFacets extends TaxonomyFacets {
       labelValues[i] = new LabelAndValue(child.components[cp.length], ordAndValue.value);
     }
 
-    return new FacetResult(totValue, labelValues, childCount);
+    return new FacetResult(dim, path, totValue, labelValues, childCount);
   }
 }
\ No newline at end of file
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/LongRange.java b/lucene/facet/src/java/org/apache/lucene/facet/LongRange.java
index 6b3b9c8..247b5b5 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/LongRange.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/LongRange.java
@@ -17,7 +17,17 @@ package org.apache.lucene.facet;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Collections;
+
 import org.apache.lucene.document.NumericDocValuesField; // javadocs
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.util.Bits;
 
 /** Represents a range over long values. */
 public final class LongRange extends Range {
@@ -55,4 +65,72 @@ public final class LongRange extends Range {
   public boolean accept(long value) {
     return value >= minIncl && value <= maxIncl;
   }
+
+  /** Returns a new {@link Filter} accepting only documents
+   *  in this range.  Note that this filter is not
+   *  efficient: it's a linear scan of all docs, testing
+   *  each value.  If the {@link ValueSource} is static,
+   *  e.g. an indexed numeric field, then it's more
+   *  efficient to use {@link NumericRangeFilter}. */
+  public Filter getFilter(final ValueSource valueSource) {
+    return new Filter() {
+      @Override
+      public DocIdSet getDocIdSet(AtomicReaderContext context, final Bits acceptDocs) throws IOException {
+
+        // TODO: this is just like ValueSourceScorer,
+        // ValueSourceFilter (spatial),
+        // ValueSourceRangeFilter (solr); also,
+        // https://issues.apache.org/jira/browse/LUCENE-4251
+
+        final FunctionValues values = valueSource.getValues(Collections.emptyMap(), context);
+
+        final int maxDoc = context.reader().maxDoc();
+
+        return new DocIdSet() {
+
+          @Override
+          public DocIdSetIterator iterator() {
+            return new DocIdSetIterator() {
+              int doc = -1;
+
+              @Override
+              public int nextDoc() throws IOException {
+                while (true) {
+                  doc++;
+                  if (doc == maxDoc) {
+                    return doc = NO_MORE_DOCS;
+                  }
+                  if (acceptDocs != null && acceptDocs.get(doc) == false) {
+                    continue;
+                  }
+                  long v = values.longVal(doc);
+                  if (accept(v)) {
+                    return doc;
+                  }
+                }
+              }
+
+              @Override
+              public int advance(int target) throws IOException {
+                doc = target-1;
+                return nextDoc();
+              }
+
+              @Override
+              public int docID() {
+                return doc;
+              }
+
+              @Override
+              public long cost() {
+                // Since we do a linear scan over all
+                // documents, our cost is O(maxDoc):
+                return maxDoc;
+              }
+            };
+          }
+        };
+      }
+    };
+  }
 }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/LongRangeFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/LongRangeFacetCounts.java
index b7a34ce..9d9b102 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/LongRangeFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/LongRangeFacetCounts.java
@@ -22,7 +22,6 @@ import java.util.Collections;
 import java.util.List;
 
 import org.apache.lucene.facet.FacetsCollector.MatchingDocs;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.LongFieldSource;
@@ -98,13 +97,16 @@ public class LongRangeFacetCounts extends Facets {
     if (dim.equals(field) == false) {
       throw new IllegalArgumentException("invalid dim \"" + dim + "\"; should be \"" + field + "\"");
     }
+    if (path.length != 0) {
+      throw new IllegalArgumentException("path.length should be 0");
+    }
     LabelAndValue[] labelValues = new LabelAndValue[counts.length];
     for(int i=0;i<counts.length;i++) {
       // nocommit can we add the range into this?
       labelValues[i] = new LabelAndValue(ranges[i].label, counts[i]);
     }
 
-    return new FacetResult(totCount, labelValues, labelValues.length);
+    return new FacetResult(dim, path, totCount, labelValues, labelValues.length);
   }
 
   @Override
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesFacetCounts.java b/lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesFacetCounts.java
index 04aba84..657bcfc 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesFacetCounts.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/SortedSetDocValuesFacetCounts.java
@@ -19,17 +19,13 @@ package org.apache.lucene.facet;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.FacetsCollector.MatchingDocs;
 import org.apache.lucene.facet.SortedSetDocValuesReaderState.OrdRange;
-import org.apache.lucene.facet.SortedSetDocValuesReaderState;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiDocValues.MultiSortedSetDocValues;
@@ -37,7 +33,6 @@ import org.apache.lucene.index.MultiDocValues;
 import org.apache.lucene.index.ReaderUtil;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.PriorityQueue;
 
 /** Compute facets counts from previously
  *  indexed {@link SortedSetDocValuesFacetField},
@@ -51,8 +46,11 @@ import org.apache.lucene.util.PriorityQueue;
  *
  *  <p><b>NOTE</b>: this class should be instantiated and
  *  then used from a single thread, because it holds a
- *  thread-private instance of {@link SortedSetDocValues}. */
-
+ *  thread-private instance of {@link SortedSetDocValues}.
+ * 
+ * <p><b>NOTE:<b/>: tie-break is by unicode sort order
+ *
+ * @lucene.experimental */
 public class SortedSetDocValuesFacetCounts extends Facets {
 
   final SortedSetDocValuesReaderState state;
@@ -136,7 +134,7 @@ public class SortedSetDocValuesFacetCounts extends Facets {
       labelValues[i] = new LabelAndValue(parts[1], ordAndValue.value);
     }
 
-    return new FacetResult(dimCount, labelValues, childCount);
+    return new FacetResult(dim, new String[0], dimCount, labelValues, childCount);
   }
 
   /** Does all the "real work" of tallying up the counts. */
@@ -283,7 +281,7 @@ public class SortedSetDocValuesFacetCounts extends Facets {
                          } else if (b.value.intValue() > a.value.intValue()) {
                            return 1;
                          } else {
-                           return 0;
+                           return a.dim.compareTo(b.dim);
                          }
                        }
                      });
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/TaxonomyFacets.java b/lucene/facet/src/java/org/apache/lucene/facet/TaxonomyFacets.java
index 85bb7e9..4c1b366 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/TaxonomyFacets.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/TaxonomyFacets.java
@@ -77,11 +77,10 @@ public abstract class TaxonomyFacets extends Facets {
                          } else if (b.value.doubleValue() > a.value.doubleValue()) {
                            return 1;
                          } else {
-                           return 0;
+                           return a.dim.compareTo(b.dim);
                          }
                        }
                      });
-
     return results;
   }
 }
\ No newline at end of file
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java
index 4e54820..0df5e64 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/FacetLabel.java
@@ -42,7 +42,7 @@ public class FacetLabel implements Comparable<FacetLabel> {
   public final static int MAX_CATEGORY_PATH_LENGTH = (BYTE_BLOCK_SIZE - 2) / 4;
 
   /** An empty {@link FacetLabel} */
-  public static final FacetLabel EMPTY = new FacetLabel();
+  //public static final FacetLabel EMPTY = new FacetLabel();
 
   /**
    * The components of this {@link FacetLabel}. Note that this array may be
@@ -66,7 +66,7 @@ public class FacetLabel implements Comparable<FacetLabel> {
     // while the code which calls this method is safe, at some point a test
     // tripped on AIOOBE in toString, but we failed to reproduce. adding the
     // assert as a safety check.
-    assert prefixLen > 0 && prefixLen <= copyFrom.components.length : 
+    assert prefixLen >= 0 && prefixLen <= copyFrom.components.length : 
       "prefixLen cannot be negative nor larger than the given components' length: prefixLen=" + prefixLen
         + " components.length=" + copyFrom.components.length;
     this.components = copyFrom.components;
@@ -90,8 +90,6 @@ public class FacetLabel implements Comparable<FacetLabel> {
   }
 
   private void checkComponents() {
-    // nocommit why so anal?
-    // assert components.length > 0 : "use CategoryPath.EMPTY to create an empty path";
     long len = 0;
     for (String comp : components) {
       if (comp == null || comp.isEmpty()) {
@@ -158,25 +156,10 @@ public class FacetLabel implements Comparable<FacetLabel> {
     return hash;
   }
 
-  /** Calculate a 64-bit hash function for this path. */
-  public long longHashCode() {
-    if (length == 0) {
-      return 0;
-    }
-    
-    long hash = length;
-    for (int i = 0; i < length; i++) {
-      hash = hash * 65599 + components[i].hashCode();
-    }
-    return hash;
-  }
-
   /** Returns a sub-path of this path up to {@code length} components. */
   public FacetLabel subpath(final int length) {
     if (length >= this.length || length < 0) {
       return this;
-    } else if (length == 0) {
-      return EMPTY;
     } else {
       return new FacetLabel(this, length);
     }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
index 5b97eb2..1c3e184 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
@@ -231,7 +231,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
       cacheIsComplete = true;
       // Make sure that the taxonomy always contain the root category
       // with category id 0.
-      addCategory(FacetLabel.EMPTY);
+      addCategory(new FacetLabel());
     } else {
       // There are some categories on the disk, which we have not yet
       // read into the cache, and therefore the cache is incomplete.
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/CompactLabelToOrdinal.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/CompactLabelToOrdinal.java
index 53acee1..4db48a9 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/CompactLabelToOrdinal.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/CompactLabelToOrdinal.java
@@ -101,7 +101,7 @@ public class CompactLabelToOrdinal extends LabelToOrdinal {
 
   private void init() {
     labelRepository = new CharBlockArray();
-    CategoryPathUtils.serialize(FacetLabel.EMPTY, labelRepository);
+    CategoryPathUtils.serialize(new FacetLabel(), labelRepository);
 
     int c = this.capacity;
     for (int i = 0; i < this.hashArrays.length; i++) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java
index 9743d4b..a13a547 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/NameHashIntCacheLRU.java
@@ -36,12 +36,12 @@ public class NameHashIntCacheLRU extends NameIntCacheLRU {
 
   @Override
   Object key(FacetLabel name) {
-    return new Long(name.longHashCode());
+    return new Integer(name.hashCode());
   }
 
   @Override
   Object key(FacetLabel name, int prefixLen) {
-    return new Long(name.subpath(prefixLen).longHashCode());
+    return new Integer(name.subpath(prefixLen).hashCode());
   }
   
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java
index cde2115..a691de0 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/FacetTestCase.java
@@ -18,10 +18,19 @@ package org.apache.lucene.facet;
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 import java.util.Random;
 
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
 
 public abstract class FacetTestCase extends LuceneTestCase {
   
@@ -43,4 +52,154 @@ public abstract class FacetTestCase extends LuceneTestCase {
 
     return facets;
   }
+
+  protected String[] getRandomTokens(int count) {
+    String[] tokens = new String[count];
+    for(int i=0;i<tokens.length;i++) {
+      tokens[i] = _TestUtil.randomRealisticUnicodeString(random(), 1, 10);
+      //tokens[i] = _TestUtil.randomSimpleString(random(), 1, 10);
+    }
+    return tokens;
+  }
+
+  protected String pickToken(String[] tokens) {
+    for(int i=0;i<tokens.length;i++) {
+      if (random().nextBoolean()) {
+        return tokens[i];
+      }
+    }
+
+    // Move long tail onto first token:
+    return tokens[0];
+  }
+
+  protected static class TestDoc {
+    public String content;
+    public String[] dims;
+    public float value;
+  }
+
+  protected List<TestDoc> getRandomDocs(String[] tokens, int count, int numDims) {
+    List<TestDoc> docs = new ArrayList<>();
+    for(int i=0;i<count;i++) {
+      TestDoc doc = new TestDoc();
+      docs.add(doc);
+      doc.content = pickToken(tokens);
+      doc.dims = new String[numDims];
+      for(int j=0;j<numDims;j++) {
+        doc.dims[j] = pickToken(tokens);
+        if (random().nextInt(10) < 3) {
+          break;
+        }
+      }
+      if (VERBOSE) {
+        System.out.println("  doc " + i + ": content=" + doc.content);
+        for(int j=0;j<numDims;j++) {
+          if (doc.dims[j] != null) {
+            System.out.println("    dim[" + j + "]=" + doc.dims[j]);
+          }
+        }
+      }
+    }
+
+    return docs;
+  }
+  
+  protected void sortTies(List<FacetResult> results) {
+    for(FacetResult result : results) {
+      sortTies(result.labelValues);
+    }
+  }
+
+  protected void sortTies(LabelAndValue[] labelValues) {
+    double lastValue = -1;
+    int numInRow = 0;
+    int i = 0;
+    while(i <= labelValues.length) {
+      if (i < labelValues.length && labelValues[i].value.doubleValue() == lastValue) {
+        numInRow++;
+      } else {
+        if (numInRow > 1) {
+          Arrays.sort(labelValues, i-numInRow, i,
+                      new Comparator<LabelAndValue>() {
+                        @Override
+                        public int compare(LabelAndValue a, LabelAndValue b) {
+                          assert a.value.doubleValue() == b.value.doubleValue();
+                          return new BytesRef(a.label).compareTo(new BytesRef(b.label));
+                        }
+                      });
+        }
+        numInRow = 1;
+        if (i < labelValues.length) {
+          lastValue = labelValues[i].value.doubleValue();
+        }
+      }
+      i++;
+    }
+  }
+
+  protected void sortLabelValues(List<LabelAndValue> labelValues) {
+    Collections.sort(labelValues,
+                     new Comparator<LabelAndValue>() {
+                       @Override
+                       public int compare(LabelAndValue a, LabelAndValue b) {
+                         if (a.value.doubleValue() > b.value.doubleValue()) {
+                           return -1;
+                         } else if (a.value.doubleValue() < b.value.doubleValue()) {
+                           return 1;
+                         } else {
+                           return new BytesRef(a.label).compareTo(new BytesRef(b.label));
+                         }
+                       }
+                     });
+  }
+
+  protected void sortFacetResults(List<FacetResult> results) {
+      Collections.sort(results,
+                       new Comparator<FacetResult>() {
+                         @Override
+                         public int compare(FacetResult a, FacetResult b) {
+                           if (a.value.doubleValue() > b.value.doubleValue()) {
+                             return -1;
+                           } else if (b.value.doubleValue() > a.value.doubleValue()) {
+                             return 1;
+                           } else {
+                             return 0;
+                           }
+                         }
+                       });
+  }
+
+  protected void assertFloatValuesEquals(List<FacetResult> a, List<FacetResult> b) {
+    assertEquals(a.size(), b.size());
+    float lastValue = Float.POSITIVE_INFINITY;
+    Map<String,FacetResult> aByDim = new HashMap<String,FacetResult>();
+    for(int i=0;i<a.size();i++) {
+      assertTrue(a.get(i).value.floatValue() <= lastValue);
+      lastValue = a.get(i).value.floatValue();
+      aByDim.put(a.get(i).dim, a.get(i));
+    }
+    lastValue = Float.POSITIVE_INFINITY;
+    Map<String,FacetResult> bByDim = new HashMap<String,FacetResult>();
+    for(int i=0;i<b.size();i++) {
+      bByDim.put(b.get(i).dim, b.get(i));
+      assertTrue(b.get(i).value.floatValue() <= lastValue);
+      lastValue = b.get(i).value.floatValue();
+    }
+    for(String dim : aByDim.keySet()) {
+      assertFloatValuesEquals(aByDim.get(dim), bByDim.get(dim));
+    }
+  }
+
+  protected void assertFloatValuesEquals(FacetResult a, FacetResult b) {
+    assertEquals(a.dim, b.dim);
+    assertTrue(Arrays.equals(a.path, b.path));
+    assertEquals(a.childCount, b.childCount);
+    assertEquals(a.value.floatValue(), b.value.floatValue(), a.value.floatValue()/1e5);
+    assertEquals(a.labelValues.length, b.labelValues.length);
+    for(int i=0;i<a.labelValues.length;i++) {
+      assertEquals(a.labelValues[i].label, b.labelValues[i].label);
+      assertEquals(a.labelValues[i].value.floatValue(), b.labelValues[i].value.floatValue(), a.labelValues[i].value.floatValue()/1e5);
+    }
+  }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
index cb48ef3..200cf31 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
@@ -31,7 +31,6 @@ import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.DrillSideways.DrillSidewaysResult;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -121,12 +120,12 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Same simple case, but no baseQuery (pure browse):
     // drill-down on a single field; in this case the
@@ -139,12 +138,12 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Another simple case: drill-down on on single fields
     // but OR of two values
@@ -155,11 +154,11 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(3, r.hits.totalHits);
     // Publish Date is only drill-down: Lisa and Bob
     // (drill-down) published twice in 2010 and once in 2012:
-    assertEquals("value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // More interesting case: drill-down on two fields
     ddq = new DrillDownQuery(config);
@@ -169,10 +168,10 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(1, r.hits.totalHits);
     // Publish Date is drill-sideways + drill-down: Lisa
     // (drill-down) published once in 2010 and once in 2012:
-    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down:
     // only Lisa & Bob published (once each) in 2010:
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Even more interesting case: drill down on two fields,
     // but one of them is OR
@@ -186,10 +185,10 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is both drill-sideways + drill-down:
     // Lisa or Bob published twice in 2010 and once in 2012:
-    assertEquals("value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=3 childCount=2\n  2010 (2)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down:
     // only Lisa & Bob published (once each) in 2010:
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // Test drilling down on invalid field:
     ddq = new DrillDownQuery(config);
@@ -207,11 +206,11 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published twice, and Frank/Susan/Bob
     // published once:
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     // LUCENE-4915: test drilling down on a dimension but
     // NOT facet counting it:
@@ -222,7 +221,7 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(2, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=2 childCount=2\n  2010 (1)\n  2012 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
 
     // Test main query gets null scorer:
     ddq = new DrillDownQuery(config, new TermQuery(new Term("foobar", "baz")));
@@ -280,11 +279,11 @@ public class TestDrillSideways extends FacetTestCase {
     assertEquals(1, r.hits.totalHits);
     // Publish Date is only drill-down, and Lisa published
     // one in 2012 and one in 2010:
-    assertEquals("value=1 childCount=1\n  2010 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Publish Date path=[] value=1 childCount=1\n  2010 (1)\n", r.facets.getTopChildren(10, "Publish Date").toString());
     // Author is drill-sideways + drill-down: Lisa
     // (drill-down) published once, and Bob
     // published once:
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", r.facets.getTopChildren(10, "Author").toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, writer, taxoWriter, dir, taxoDir);
   }
@@ -338,8 +337,8 @@ public class TestDrillSideways extends FacetTestCase {
     DrillSidewaysResult r = new DrillSideways(searcher, config, taxoReader).search(null, ddq, 10);
 
     assertEquals(3, r.hits.totalHits);
-    assertEquals("value=6 childCount=4\n  a (3)\n  b (1)\n  c (1)\n  d (1)\n", r.facets.getTopChildren(10, "dim").toString());
-    assertEquals("value=3 childCount=3\n  x (1)\n  y (1)\n  z (1)\n", r.facets.getTopChildren(10, "dim", "a").toString());
+    assertEquals("dim=dim path=[] value=6 childCount=4\n  a (3)\n  b (1)\n  c (1)\n  d (1)\n", r.facets.getTopChildren(10, "dim").toString());
+    assertEquals("dim=dim path=[a] value=3 childCount=3\n  x (1)\n  y (1)\n  z (1)\n", r.facets.getTopChildren(10, "dim", "a").toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, writer, taxoWriter, dir, taxoDir);
   }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestMultipleIndexFields.java b/lucene/facet/src/test/org/apache/lucene/facet/TestMultipleIndexFields.java
index 22a281e..db25349 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestMultipleIndexFields.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestMultipleIndexFields.java
@@ -18,11 +18,7 @@ package org.apache.lucene.facet;
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -30,8 +26,6 @@ import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.facet.FacetTestCase;
-import org.apache.lucene.facet.taxonomy.FacetLabel;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -43,9 +37,6 @@ import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.MultiCollector;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TopScoreDocCollector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
 import org.junit.Test;
@@ -282,9 +273,9 @@ public class TestMultipleIndexFields extends FacetTestCase {
 
   private void assertCorrectResults(Facets facets) throws IOException {
     assertEquals(5, facets.getSpecificValue("Band"));
-    assertEquals("value=5 childCount=2\n  Rock & Pop (4)\n  Punk (1)\n", facets.getTopChildren(10, "Band").toString());
-    assertEquals("value=4 childCount=4\n  The Beatles (1)\n  U2 (1)\n  REM (1)\n  Dave Matthews Band (1)\n", facets.getTopChildren(10, "Band", "Rock & Pop").toString());
-    assertEquals("value=3 childCount=3\n  Mark Twain (1)\n  Stephen King (1)\n  Kurt Vonnegut (1)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Band path=[] value=5 childCount=2\n  Rock & Pop (4)\n  Punk (1)\n", facets.getTopChildren(10, "Band").toString());
+    assertEquals("dim=Band path=[Rock & Pop] value=4 childCount=4\n  The Beatles (1)\n  U2 (1)\n  REM (1)\n  Dave Matthews Band (1)\n", facets.getTopChildren(10, "Band", "Rock & Pop").toString());
+    assertEquals("dim=Author path=[] value=3 childCount=3\n  Mark Twain (1)\n  Stephen King (1)\n  Kurt Vonnegut (1)\n", facets.getTopChildren(10, "Author").toString());
   }
 
   private FacetsCollector performSearch(TaxonomyReader tr, IndexReader ir, 
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts.java
index da1a849..686bc1d 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestRangeFacetCounts.java
@@ -41,10 +41,10 @@ import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
+import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.NumericRangeQuery;
-import org.apache.lucene.search.SortField;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util._TestUtil;
@@ -80,7 +80,7 @@ public class TestRangeFacetCounts extends FacetTestCase {
         new LongRange("over 1000", 1000L, false, Long.MAX_VALUE, true));
     
     FacetResult result = facets.getTopChildren(10, "field");
-    assertEquals("value=101 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (1)\n",
+    assertEquals("dim=field path=[] value=101 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (1)\n",
                  result.toString());
     
     r.close();
@@ -161,8 +161,8 @@ public class TestRangeFacetCounts extends FacetTestCase {
     DrillSidewaysResult dsr = ds.search(null, ddq, 10);
 
     assertEquals(100, dsr.hits.totalHits);
-    assertEquals("value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("dim=dim path=[] value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("dim=field path=[] value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
 
     // Second search, drill down on dim=b:
@@ -171,8 +171,8 @@ public class TestRangeFacetCounts extends FacetTestCase {
     dsr = ds.search(null, ddq, 10);
 
     assertEquals(75, dsr.hits.totalHits);
-    assertEquals("value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("value=75 childCount=5\n  less than 10 (7)\n  less than or equal to 10 (8)\n  over 90 (7)\n  90 or above (8)\n  over 1000 (0)\n",
+    assertEquals("dim=dim path=[] value=100 childCount=2\n  b (75)\n  a (25)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("dim=field path=[] value=75 childCount=5\n  less than 10 (7)\n  less than or equal to 10 (8)\n  over 90 (7)\n  90 or above (8)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
 
     // Third search, drill down on "less than or equal to 10":
@@ -181,8 +181,8 @@ public class TestRangeFacetCounts extends FacetTestCase {
     dsr = ds.search(null, ddq, 10);
 
     assertEquals(11, dsr.hits.totalHits);
-    assertEquals("value=11 childCount=2\n  b (8)\n  a (3)\n", dsr.facets.getTopChildren(10, "dim").toString());
-    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("dim=dim path=[] value=11 childCount=2\n  b (8)\n  a (3)\n", dsr.facets.getTopChildren(10, "dim").toString());
+    assertEquals("dim=field path=[] value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  dsr.facets.getTopChildren(10, "field").toString());
     IOUtils.close(tw, tr, td, w, r, d);
   }
@@ -211,7 +211,7 @@ public class TestRangeFacetCounts extends FacetTestCase {
         new DoubleRange("90 or above", 90.0, true, 100.0, false),
         new DoubleRange("over 1000", 1000.0, false, Double.POSITIVE_INFINITY, false));
                                          
-    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("dim=field path=[] value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
 
     IOUtils.close(w, r, d);
@@ -242,7 +242,7 @@ public class TestRangeFacetCounts extends FacetTestCase {
         new DoubleRange("90 or above", 90.0f, true, 100.0f, false),
         new DoubleRange("over 1000", 1000.0f, false, Double.POSITIVE_INFINITY, false));
     
-    assertEquals("value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
+    assertEquals("dim=field path=[] value=100 childCount=5\n  less than 10 (10)\n  less than or equal to 10 (11)\n  over 90 (9)\n  90 or above (10)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
     
     IOUtils.close(w, r, d);
@@ -531,7 +531,7 @@ public class TestRangeFacetCounts extends FacetTestCase {
         new LongRange("90 or above", 90L, true, 100L, false),
         new LongRange("over 1000", 1000L, false, Long.MAX_VALUE, false));
     
-    assertEquals("value=100 childCount=5\n  less than 10 (8)\n  less than or equal to 10 (8)\n  over 90 (8)\n  90 or above (8)\n  over 1000 (0)\n",
+    assertEquals("dim=field path=[] value=100 childCount=5\n  less than 10 (8)\n  less than or equal to 10 (8)\n  over 90 (8)\n  90 or above (8)\n  over 1000 (0)\n",
                  facets.getTopChildren(10, "field").toString());
 
     IOUtils.close(w, r, d);
@@ -592,7 +592,11 @@ public class TestRangeFacetCounts extends FacetTestCase {
         new DoubleRange("< 20", 0.0, true, 20.0, false),
         new DoubleRange("< 50", 0.0, true, 50.0, false));
 
-    assertEquals("value=3 childCount=6\n  < 1 (0)\n  < 2 (1)\n  < 5 (3)\n  < 10 (3)\n  < 20 (3)\n  < 50 (3)\n", facets.getTopChildren(10, "field").toString());
+    assertEquals("dim=field path=[] value=3 childCount=6\n  < 1 (0)\n  < 2 (1)\n  < 5 (3)\n  < 10 (3)\n  < 20 (3)\n  < 50 (3)\n", facets.getTopChildren(10, "field").toString());
+
+    // Test drill-down:
+    assertEquals(1, s.search(new ConstantScoreQuery(new DoubleRange("< 2", 0.0, true, 2.0, false).getFilter(vs)), 10).totalHits);
+
     IOUtils.close(r, writer, dir);
   }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestSortedSetDocValuesFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/TestSortedSetDocValuesFacets.java
index 4d0825b..4232509 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestSortedSetDocValuesFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestSortedSetDocValuesFacets.java
@@ -17,18 +17,24 @@ package org.apache.lucene.facet;
  * limitations under the License.
  */
 
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.facet.FacetTestCase;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util._TestUtil;
 
 public class TestSortedSetDocValuesFacets extends FacetTestCase {
 
@@ -69,8 +75,8 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
 
     SortedSetDocValuesFacetCounts facets = new SortedSetDocValuesFacetCounts(state, c);
 
-    assertEquals("value=4 childCount=3\n  foo (2)\n  bar (1)\n  zoo (1)\n", facets.getTopChildren(10, "a").toString());
-    assertEquals("value=1 childCount=1\n  baz (1)\n", facets.getTopChildren(10, "b").toString());
+    assertEquals("dim=a path=[] value=4 childCount=3\n  foo (2)\n  bar (1)\n  zoo (1)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=b path=[] value=1 childCount=1\n  baz (1)\n", facets.getTopChildren(10, "b").toString());
 
     // DrillDown:
     DrillDownQuery q = new DrillDownQuery(config);
@@ -172,9 +178,9 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     List<FacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
-    assertEquals("value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
-    assertEquals("value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
+    assertEquals("dim=a path=[] value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
+    assertEquals("dim=b path=[] value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
+    assertEquals("dim=c path=[] value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
 
     searcher.getIndexReader().close();
     dir.close();
@@ -214,18 +220,12 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     SortedSetDocValuesFacetCounts facets = new SortedSetDocValuesFacetCounts(state, c);
 
     // Ask for top 10 labels for any dims that have counts:
-    assertEquals("value=2 childCount=2\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=a path=[] value=2 childCount=2\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
 
     searcher.getIndexReader().close();
     dir.close();
   }
 
-  // nocommit test different delim char & using the default
-  // one in a dim
-
-  // nocommit in the sparse case test that we are really
-  // sorting by the correct dim count
-
   public void testSlowCompositeReaderWrapper() throws Exception {
     assumeTrue("Test requires SortedSetDV support", defaultCodecSupportsSortedSet());
     Directory dir = newDirectory();
@@ -255,8 +255,96 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     Facets facets = new SortedSetDocValuesFacetCounts(state, c);
 
     // Ask for top 10 labels for any dims that have counts:
-    assertEquals("value=2 childCount=2\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=a path=[] value=2 childCount=2\n  foo1 (1)\n  foo2 (1)\n", facets.getTopChildren(10, "a").toString());
 
     IOUtils.close(writer, searcher.getIndexReader(), dir);
   }
+
+
+  public void testRandom() throws Exception {
+    assumeTrue("Test requires SortedSetDV support", defaultCodecSupportsSortedSet());
+    String[] tokens = getRandomTokens(10);
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+
+    RandomIndexWriter w = new RandomIndexWriter(random(), indexDir);
+    FacetsConfig config = new FacetsConfig();
+    int numDocs = atLeast(1000);
+    int numDims = _TestUtil.nextInt(random(), 1, 7);
+    List<TestDoc> testDocs = getRandomDocs(tokens, numDocs, numDims);
+    for(TestDoc testDoc : testDocs) {
+      Document doc = new Document();
+      doc.add(newStringField("content", testDoc.content, Field.Store.NO));
+      for(int j=0;j<numDims;j++) {
+        if (testDoc.dims[j] != null) {
+          doc.add(new SortedSetDocValuesFacetField("dim" + j, testDoc.dims[j]));
+        }
+      }
+      w.addDocument(config.build(doc));
+    }
+
+    // NRT open
+    IndexSearcher searcher = newSearcher(w.getReader());
+    
+    // Per-top-reader state:
+    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(searcher.getIndexReader());
+
+    int iters = atLeast(100);
+    for(int iter=0;iter<iters;iter++) {
+      String searchToken = tokens[random().nextInt(tokens.length)];
+      if (VERBOSE) {
+        System.out.println("\nTEST: iter content=" + searchToken);
+      }
+      FacetsCollector fc = new FacetsCollector();
+      TopDocs hits = FacetsCollector.search(searcher, new TermQuery(new Term("content", searchToken)), 10, fc);
+      Facets facets = new SortedSetDocValuesFacetCounts(state, fc);
+
+      // Slow, yet hopefully bug-free, faceting:
+      @SuppressWarnings({"rawtypes","unchecked"}) Map<String,Integer>[] expectedCounts = new HashMap[numDims];
+      for(int i=0;i<numDims;i++) {
+        expectedCounts[i] = new HashMap<String,Integer>();
+      }
+
+      for(TestDoc doc : testDocs) {
+        if (doc.content.equals(searchToken)) {
+          for(int j=0;j<numDims;j++) {
+            if (doc.dims[j] != null) {
+              Integer v = expectedCounts[j].get(doc.dims[j]);
+              if (v == null) {
+                expectedCounts[j].put(doc.dims[j], 1);
+              } else {
+                expectedCounts[j].put(doc.dims[j], v.intValue() + 1);
+              }
+            }
+          }
+        }
+      }
+
+      List<FacetResult> expected = new ArrayList<FacetResult>();
+      for(int i=0;i<numDims;i++) {
+        List<LabelAndValue> labelValues = new ArrayList<LabelAndValue>();
+        int totCount = 0;
+        for(Map.Entry<String,Integer> ent : expectedCounts[i].entrySet()) {
+          labelValues.add(new LabelAndValue(ent.getKey(), ent.getValue()));
+          totCount += ent.getValue();
+        }
+        sortLabelValues(labelValues);
+        if (totCount > 0) {
+          expected.add(new FacetResult("dim" + i, new String[0], totCount, labelValues.toArray(new LabelAndValue[labelValues.size()]), labelValues.size()));
+        }
+      }
+
+      // Sort by highest value, tie break by value:
+      sortFacetResults(expected);
+
+      List<FacetResult> actual = facets.getAllDims(10);
+
+      // Messy: fixup ties
+      //sortTies(actual);
+
+      assertEquals(expected, actual);
+    }
+
+    IOUtils.close(w, searcher.getIndexReader(), indexDir, taxoDir);
+  }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetAssociations.java b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetAssociations.java
index 2e5839a..2886a16 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetAssociations.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetAssociations.java
@@ -101,7 +101,7 @@ public class TestTaxonomyFacetAssociations extends FacetTestCase {
     searcher.search(new MatchAllDocsQuery(), fc);
 
     Facets facets = new TaxonomyFacetSumIntAssociations("$facets.int", taxoReader, config, fc);
-    assertEquals("value=-1 childCount=2\n  a (200)\n  b (150)\n", facets.getTopChildren(10, "int").toString());
+    assertEquals("dim=int path=[] value=-1 childCount=2\n  a (200)\n  b (150)\n", facets.getTopChildren(10, "int").toString());
     assertEquals("Wrong count for category 'a'!", 200, facets.getSpecificValue("int", "a").intValue());
     assertEquals("Wrong count for category 'b'!", 150, facets.getSpecificValue("int", "b").intValue());
   }
@@ -113,7 +113,7 @@ public class TestTaxonomyFacetAssociations extends FacetTestCase {
     searcher.search(new MatchAllDocsQuery(), fc);
     
     Facets facets = new TaxonomyFacetSumFloatAssociations("$facets.float", taxoReader, config, fc);
-    assertEquals("value=-1.0 childCount=2\n  a (50.0)\n  b (9.999995)\n", facets.getTopChildren(10, "float").toString());
+    assertEquals("dim=float path=[] value=-1.0 childCount=2\n  a (50.0)\n  b (9.999995)\n", facets.getTopChildren(10, "float").toString());
     assertEquals("Wrong count for category 'a'!", 50f, facets.getSpecificValue("float", "a").floatValue(), 0.00001);
     assertEquals("Wrong count for category 'b'!", 10f, facets.getSpecificValue("float", "b").floatValue(), 0.00001);
   }  
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetCounts.java
index 28ab67e..80a94b7 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetCounts.java
@@ -19,15 +19,17 @@ package org.apache.lucene.facet;
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.facet.FacetTestCase;
 import org.apache.lucene.facet.taxonomy.PrintTaxonomyStats;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -43,6 +45,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.PerFieldSimilarityWrapper;
 import org.apache.lucene.search.similarities.Similarity;
@@ -108,8 +111,8 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     Facets facets = new FastTaxonomyFacetCounts(taxoReader, config, c);
 
     // Retrieve & verify results:
-    assertEquals("value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", facets.getTopChildren(10, "Publish Date").toString());
-    assertEquals("value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Publish Date path=[] value=5 childCount=3\n  2010 (2)\n  2012 (2)\n  1999 (1)\n", facets.getTopChildren(10, "Publish Date").toString());
+    assertEquals("dim=Author path=[] value=5 childCount=4\n  Lisa (2)\n  Bob (1)\n  Susan (1)\n  Frank (1)\n", facets.getTopChildren(10, "Author").toString());
 
     // Now user drills down on Publish Date/2010:
     DrillDownQuery q2 = new DrillDownQuery(config);
@@ -117,10 +120,12 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     c = new FacetsCollector();
     searcher.search(q2, c);
     facets = new FastTaxonomyFacetCounts(taxoReader, config, c);
-    assertEquals("value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=2 childCount=2\n  Bob (1)\n  Lisa (1)\n", facets.getTopChildren(10, "Author").toString());
 
     assertEquals(1, facets.getSpecificValue("Author", "Lisa"));
 
+    assertNull(facets.getTopChildren(10, "Non exitent dim"));
+
     // Smoke test PrintTaxonomyStats:
     ByteArrayOutputStream bos = new ByteArrayOutputStream();
     PrintTaxonomyStats.printStats(taxoReader, new PrintStream(bos, false, "UTF-8"), true);
@@ -185,9 +190,9 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     List<FacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
-    assertEquals("value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
-    assertEquals("value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
+    assertEquals("dim=a path=[] value=3 childCount=3\n  foo1 (1)\n  foo2 (1)\n  foo3 (1)\n", results.get(0).toString());
+    assertEquals("dim=b path=[] value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
+    assertEquals("dim=c path=[] value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
 
     IOUtils.close(writer, taxoWriter, searcher.getIndexReader(), taxoReader, taxoDir, dir);
   }
@@ -250,10 +255,6 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     IOUtils.close(writer, taxoWriter, searcher.getIndexReader(), taxoReader, taxoDir, dir);
   }
 
-
-  // nocommit in the sparse case test that we are really
-  // sorting by the correct dim count
-
   public void testReallyNoNormsForDrillDown() throws Exception {
     Directory dir = newDirectory();
     Directory taxoDir = newDirectory();
@@ -344,7 +345,7 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
     assertEquals(1, facets.getSpecificValue("dim", "test\u001Etwo"));
 
     FacetResult result = facets.getTopChildren(10, "dim");
-    assertEquals("value=-1 childCount=2\n  test\u001Fone (1)\n  test\u001Etwo (1)\n", result.toString());
+    assertEquals("dim=dim path=[] value=-1 childCount=2\n  test\u001Fone (1)\n  test\u001Etwo (1)\n", result.toString());
     IOUtils.close(writer, taxoWriter, searcher.getIndexReader(), taxoReader, dir, taxoDir);
   }
 
@@ -645,4 +646,91 @@ public class TestTaxonomyFacetCounts extends FacetTestCase {
 
     IOUtils.close(indexReader, taxoReader, indexDir, taxoDir);
   }
+
+  public void testRandom() throws Exception {
+    String[] tokens = getRandomTokens(10);
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+
+    RandomIndexWriter w = new RandomIndexWriter(random(), indexDir);
+    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir);
+    FacetsConfig config = new FacetsConfig();
+    int numDocs = atLeast(1000);
+    int numDims = _TestUtil.nextInt(random(), 1, 7);
+    List<TestDoc> testDocs = getRandomDocs(tokens, numDocs, numDims);
+    for(TestDoc testDoc : testDocs) {
+      Document doc = new Document();
+      doc.add(newStringField("content", testDoc.content, Field.Store.NO));
+      for(int j=0;j<numDims;j++) {
+        if (testDoc.dims[j] != null) {
+          doc.add(new FacetField("dim" + j, testDoc.dims[j]));
+        }
+      }
+      w.addDocument(config.build(tw, doc));
+    }
+
+    // NRT open
+    IndexSearcher searcher = newSearcher(w.getReader());
+    
+    // NRT open
+    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);
+
+    int iters = atLeast(100);
+    for(int iter=0;iter<iters;iter++) {
+      String searchToken = tokens[random().nextInt(tokens.length)];
+      if (VERBOSE) {
+        System.out.println("\nTEST: iter content=" + searchToken);
+      }
+      FacetsCollector fc = new FacetsCollector();
+      TopDocs hits = FacetsCollector.search(searcher, new TermQuery(new Term("content", searchToken)), 10, fc);
+      Facets facets = getTaxonomyFacetCounts(tr, config, fc);
+
+      // Slow, yet hopefully bug-free, faceting:
+      @SuppressWarnings({"rawtypes","unchecked"}) Map<String,Integer>[] expectedCounts = new HashMap[numDims];
+      for(int i=0;i<numDims;i++) {
+        expectedCounts[i] = new HashMap<String,Integer>();
+      }
+
+      for(TestDoc doc : testDocs) {
+        if (doc.content.equals(searchToken)) {
+          for(int j=0;j<numDims;j++) {
+            if (doc.dims[j] != null) {
+              Integer v = expectedCounts[j].get(doc.dims[j]);
+              if (v == null) {
+                expectedCounts[j].put(doc.dims[j], 1);
+              } else {
+                expectedCounts[j].put(doc.dims[j], v.intValue() + 1);
+              }
+            }
+          }
+        }
+      }
+
+      List<FacetResult> expected = new ArrayList<FacetResult>();
+      for(int i=0;i<numDims;i++) {
+        List<LabelAndValue> labelValues = new ArrayList<LabelAndValue>();
+        int totCount = 0;
+        for(Map.Entry<String,Integer> ent : expectedCounts[i].entrySet()) {
+          labelValues.add(new LabelAndValue(ent.getKey(), ent.getValue()));
+          totCount += ent.getValue();
+        }
+        sortLabelValues(labelValues);
+        if (totCount > 0) {
+          expected.add(new FacetResult("dim" + i, new String[0], totCount, labelValues.toArray(new LabelAndValue[labelValues.size()]), labelValues.size()));
+        }
+      }
+
+      // Sort by highest value, tie break by value:
+      sortFacetResults(expected);
+
+      List<FacetResult> actual = facets.getAllDims(10);
+
+      // Messy: fixup ties
+      sortTies(actual);
+
+      assertEquals(expected, actual);
+    }
+
+    IOUtils.close(w, tw, searcher.getIndexReader(), tr, indexDir, taxoDir);
+  }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetSumValueSource.java b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetSumValueSource.java
index dbb45d3..5a5ecd3 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetSumValueSource.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestTaxonomyFacetSumValueSource.java
@@ -18,12 +18,16 @@ package org.apache.lucene.facet;
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoubleDocValuesField;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FloatDocValuesField;
 import org.apache.lucene.document.IntField;
 import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.StringField;
@@ -35,10 +39,13 @@ import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
+import org.apache.lucene.queries.function.valuesource.DoubleFieldSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
 import org.apache.lucene.queries.function.valuesource.IntFieldSource;
 import org.apache.lucene.queries.function.valuesource.LongFieldSource;
 import org.apache.lucene.search.ConstantScoreQuery;
@@ -46,10 +53,12 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TopScoreDocCollector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util._TestUtil;
 
 public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
 
@@ -112,7 +121,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     TaxonomyFacetSumValueSource facets = new TaxonomyFacetSumValueSource(taxoReader, new FacetsConfig(), c, new IntFieldSource("num"));
 
     // Retrieve & verify results:
-    assertEquals("value=145.0 childCount=4\n  Lisa (50.0)\n  Frank (45.0)\n  Susan (40.0)\n  Bob (10.0)\n", facets.getTopChildren(10, "Author").toString());
+    assertEquals("dim=Author path=[] value=145.0 childCount=4\n  Lisa (50.0)\n  Frank (45.0)\n  Susan (40.0)\n  Bob (10.0)\n", facets.getTopChildren(10, "Author").toString());
 
     taxoReader.close();
     searcher.getIndexReader().close();
@@ -175,9 +184,9 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     List<FacetResult> results = facets.getAllDims(10);
 
     assertEquals(3, results.size());
-    assertEquals("value=60.0 childCount=3\n  foo3 (30.0)\n  foo2 (20.0)\n  foo1 (10.0)\n", results.get(0).toString());
-    assertEquals("value=50.0 childCount=2\n  bar2 (30.0)\n  bar1 (20.0)\n", results.get(1).toString());
-    assertEquals("value=30.0 childCount=1\n  baz1 (30.0)\n", results.get(2).toString());
+    assertEquals("dim=a path=[] value=60.0 childCount=3\n  foo3 (30.0)\n  foo2 (20.0)\n  foo1 (10.0)\n", results.get(0).toString());
+    assertEquals("dim=b path=[] value=50.0 childCount=2\n  bar2 (30.0)\n  bar1 (20.0)\n", results.get(1).toString());
+    assertEquals("dim=c path=[] value=30.0 childCount=1\n  baz1 (30.0)\n", results.get(2).toString());
 
     IOUtils.close(searcher.getIndexReader(), taxoReader, dir, taxoDir);
   }
@@ -290,7 +299,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     FacetsCollector sfc = new FacetsCollector();
     newSearcher(r).search(new MatchAllDocsQuery(), sfc);
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, sfc, new LongFieldSource("price"));
-    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=a path=[] value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
@@ -342,7 +351,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     FacetsCollector.search(newSearcher(r), q, 10, fc);
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, fc, valueSource);
     
-    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=a path=[] value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
@@ -372,7 +381,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     newSearcher(r).search(new MatchAllDocsQuery(), sfc);
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, sfc, valueSource);
     
-    assertEquals("value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
+    assertEquals("dim=a path=[] value=10.0 childCount=2\n  1 (6.0)\n  0 (4.0)\n", facets.getTopChildren(10, "a").toString());
     
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
@@ -409,6 +418,99 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
     IOUtils.close(taxoWriter, iw, taxoReader, taxoDir, r, indexDir);
   }
 
-  // nocommit in the sparse case test that we are really
-  // sorting by the correct dim count
+  public void testRandom() throws Exception {
+    String[] tokens = getRandomTokens(10);
+    Directory indexDir = newDirectory();
+    Directory taxoDir = newDirectory();
+
+    RandomIndexWriter w = new RandomIndexWriter(random(), indexDir);
+    DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir);
+    FacetsConfig config = new FacetsConfig();
+    int numDocs = atLeast(1000);
+    int numDims = _TestUtil.nextInt(random(), 1, 7);
+    List<TestDoc> testDocs = getRandomDocs(tokens, numDocs, numDims);
+    for(TestDoc testDoc : testDocs) {
+      Document doc = new Document();
+      doc.add(newStringField("content", testDoc.content, Field.Store.NO));
+      testDoc.value = random().nextFloat();
+      doc.add(new FloatDocValuesField("value", testDoc.value));
+      for(int j=0;j<numDims;j++) {
+        if (testDoc.dims[j] != null) {
+          doc.add(new FacetField("dim" + j, testDoc.dims[j]));
+        }
+      }
+      w.addDocument(config.build(tw, doc));
+    }
+
+    // NRT open
+    IndexSearcher searcher = newSearcher(w.getReader());
+    
+    // NRT open
+    TaxonomyReader tr = new DirectoryTaxonomyReader(tw);
+
+    ValueSource values = new FloatFieldSource("value");
+
+    int iters = atLeast(100);
+    for(int iter=0;iter<iters;iter++) {
+      String searchToken = tokens[random().nextInt(tokens.length)];
+      if (VERBOSE) {
+        System.out.println("\nTEST: iter content=" + searchToken);
+      }
+      FacetsCollector fc = new FacetsCollector();
+      TopDocs hits = FacetsCollector.search(searcher, new TermQuery(new Term("content", searchToken)), 10, fc);
+      Facets facets = new TaxonomyFacetSumValueSource(tr, config, fc, values);
+
+      // Slow, yet hopefully bug-free, faceting:
+      @SuppressWarnings({"rawtypes","unchecked"}) Map<String,Float>[] expectedValues = new HashMap[numDims];
+      for(int i=0;i<numDims;i++) {
+        expectedValues[i] = new HashMap<String,Float>();
+      }
+
+      for(TestDoc doc : testDocs) {
+        if (doc.content.equals(searchToken)) {
+          for(int j=0;j<numDims;j++) {
+            if (doc.dims[j] != null) {
+              Float v = expectedValues[j].get(doc.dims[j]);
+              if (v == null) {
+                expectedValues[j].put(doc.dims[j], doc.value);
+              } else {
+                expectedValues[j].put(doc.dims[j], v.floatValue() + doc.value);
+              }
+            }
+          }
+        }
+      }
+
+      List<FacetResult> expected = new ArrayList<FacetResult>();
+      for(int i=0;i<numDims;i++) {
+        List<LabelAndValue> labelValues = new ArrayList<LabelAndValue>();
+        double totValue = 0;
+        for(Map.Entry<String,Float> ent : expectedValues[i].entrySet()) {
+          labelValues.add(new LabelAndValue(ent.getKey(), ent.getValue()));
+          totValue += ent.getValue();
+        }
+        sortLabelValues(labelValues);
+        if (totValue > 0) {
+          expected.add(new FacetResult("dim" + i, new String[0], totValue, labelValues.toArray(new LabelAndValue[labelValues.size()]), labelValues.size()));
+        }
+      }
+
+      // Sort by highest value, tie break by value:
+      sortFacetResults(expected);
+
+      List<FacetResult> actual = facets.getAllDims(10);
+
+      // Messy: fixup ties
+      sortTies(actual);
+
+      if (VERBOSE) {
+        System.out.println("expected=\n" + expected.toString());
+        System.out.println("actual=\n" + actual.toString());
+      }
+
+      assertFloatValuesEquals(expected, actual);
+    }
+
+    IOUtils.close(w, tw, searcher.getIndexReader(), tr, indexDir, taxoDir);
+  }
 }
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestFacetLabel.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestFacetLabel.java
index f1ba467..6c79fbf 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestFacetLabel.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestFacetLabel.java
@@ -27,7 +27,7 @@ public class TestFacetLabel extends FacetTestCase {
   
   @Test 
   public void testBasic() {
-    assertEquals(0, FacetLabel.EMPTY.length);
+    assertEquals(0, new FacetLabel().length);
     assertEquals(1, new FacetLabel("hello").length);
     assertEquals(2, new FacetLabel("hello", "world").length);
   }
@@ -35,7 +35,7 @@ public class TestFacetLabel extends FacetTestCase {
   @Test 
   public void testToString() {
     // When the category is empty, we expect an empty string
-    assertEquals("FacetLabel: []", FacetLabel.EMPTY.toString());
+    assertEquals("FacetLabel: []", new FacetLabel().toString());
     // one category
     assertEquals("FacetLabel: [hello]", new FacetLabel("hello").toString());
     // more than one category
@@ -60,7 +60,7 @@ public class TestFacetLabel extends FacetTestCase {
     // defaults to creating an object with a 0 initial capacity.
     // If we change this default later, we also need to change this
     // test.
-    FacetLabel p = FacetLabel.EMPTY;
+    FacetLabel p = new FacetLabel();
     assertEquals(0, p.length);
     assertEquals("FacetLabel: []", p.toString());
   }
@@ -94,27 +94,20 @@ public class TestFacetLabel extends FacetTestCase {
 
   @Test 
   public void testEquals() {
-    assertEquals(FacetLabel.EMPTY, FacetLabel.EMPTY);
-    assertFalse(FacetLabel.EMPTY.equals(new FacetLabel("hi")));
-    assertFalse(FacetLabel.EMPTY.equals(Integer.valueOf(3)));
+    assertEquals(new FacetLabel(), new FacetLabel());
+    assertFalse(new FacetLabel().equals(new FacetLabel("hi")));
+    assertFalse(new FacetLabel().equals(Integer.valueOf(3)));
     assertEquals(new FacetLabel("hello", "world"), new FacetLabel("hello", "world"));    
   }
   
   @Test 
   public void testHashCode() {
-    assertEquals(FacetLabel.EMPTY.hashCode(), FacetLabel.EMPTY.hashCode());
-    assertFalse(FacetLabel.EMPTY.hashCode() == new FacetLabel("hi").hashCode());
+    assertEquals(new FacetLabel().hashCode(), new FacetLabel().hashCode());
+    assertFalse(new FacetLabel().hashCode() == new FacetLabel("hi").hashCode());
     assertEquals(new FacetLabel("hello", "world").hashCode(), new FacetLabel("hello", "world").hashCode());
   }
   
   @Test 
-  public void testLongHashCode() {
-    assertEquals(FacetLabel.EMPTY.longHashCode(), FacetLabel.EMPTY.longHashCode());
-    assertFalse(FacetLabel.EMPTY.longHashCode() == new FacetLabel("hi").longHashCode());
-    assertEquals(new FacetLabel("hello", "world").longHashCode(), new FacetLabel("hello", "world").longHashCode());
-  }
-  
-  @Test 
   public void testArrayConstructor() {
     FacetLabel p = new FacetLabel("hello", "world", "yo");
     assertEquals(3, p.length);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
index 727b67c..a230d4f 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
@@ -304,7 +304,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     assertEquals(1, tr.getSize());
     assertEquals(0, tr.getPath(0).length);
     assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParallelTaxonomyArrays().parents()[0]);
-    assertEquals(0, tr.getOrdinal(FacetLabel.EMPTY));
+    assertEquals(0, tr.getOrdinal(new FacetLabel()));
     tr.close();
     indexDir.close();
   }
@@ -323,7 +323,7 @@ public class TestTaxonomyCombined extends FacetTestCase {
     assertEquals(1, tr.getSize());
     assertEquals(0, tr.getPath(0).length);
     assertEquals(TaxonomyReader.INVALID_ORDINAL, tr.getParallelTaxonomyArrays().parents()[0]);
-    assertEquals(0, tr.getOrdinal(FacetLabel.EMPTY));
+    assertEquals(0, tr.getOrdinal(new FacetLabel()));
     tw.close();
     tr.close();
     indexDir.close();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
index a7dbee6..23c4111 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestConcurrentFacetedIndexing.java
@@ -135,7 +135,7 @@ public class TestConcurrentFacetedIndexing extends FacetTestCase {
       assertTrue("category not found " + cp, tr.getOrdinal(cp) > 0);
       int level = cp.length;
       int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)
-      FacetLabel path = FacetLabel.EMPTY;
+      FacetLabel path = new FacetLabel();
       for (int i = 0; i < level; i++) {
         path = cp.subpath(i + 1);
         int ord = tr.getOrdinal(path);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
index 2dd6119..f04b917 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter.java
@@ -298,7 +298,7 @@ public class TestDirectoryTaxonomyWriter extends FacetTestCase {
       assertTrue("category not found " + cp, dtr.getOrdinal(cp) > 0);
       int level = cp.length;
       int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)
-      FacetLabel path = FacetLabel.EMPTY;
+      FacetLabel path = new FacetLabel();
       for (int i = 0; i < level; i++) {
         path = cp.subpath(i + 1);
         int ord = dtr.getOrdinal(path);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal.java
index 0ded9fe..f9f485b 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/writercache/TestCompactLabelToOrdinal.java
@@ -85,7 +85,7 @@ public class TestCompactLabelToOrdinal extends FacetTestCase {
       FacetLabel label;
       String s = uniqueValues[index];
       if (s.length() == 0) {
-        label = FacetLabel.EMPTY;
+        label = new FacetLabel();
       } else {
         label = new FacetLabel(s.split("/"));
       }
@@ -106,7 +106,7 @@ public class TestCompactLabelToOrdinal extends FacetTestCase {
       FacetLabel label;
       String s = uniqueValues[i];
       if (s.length() == 0) {
-        label = FacetLabel.EMPTY;
+        label = new FacetLabel();
       } else {
         label = new FacetLabel(s.split("/"));
       }

