GitDiffStart: 2919db8728ed183cdd2a39aae35b736a7e1e2276 | Fri Feb 13 17:19:33 2015 +0000
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/NumberRangePrefixTreeStrategy.java b/lucene/spatial/src/java/org/apache/lucene/spatial/NumberRangePrefixTreeStrategy.java
deleted file mode 100644
index 8d3ed92..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/NumberRangePrefixTreeStrategy.java
+++ /dev/null
@@ -1,205 +0,0 @@
-package org.apache.lucene.spatial;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
-
-import com.spatial4j.core.shape.Point;
-import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.queries.function.ValueSource;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.prefix.PrefixTreeFacetCounter;
-import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
-import org.apache.lucene.spatial.prefix.tree.Cell;
-import org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree;
-
-import static org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape;
-
-/** A PrefixTree based on Number/Date ranges. This isn't very "spatial" on the surface (to the user) but
- * it's implemented using spatial so that's why it's here extending a SpatialStrategy. When using this class, you will
- * use various utility methods on the prefix tree implementation to convert objects/strings to/from shapes.
- *
- * To use with dates, pass in {@link org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree}.
- *
- * @lucene.experimental
- */
-public class NumberRangePrefixTreeStrategy extends RecursivePrefixTreeStrategy {
-
-  public NumberRangePrefixTreeStrategy(NumberRangePrefixTree prefixTree, String fieldName) {
-    super(prefixTree, fieldName);
-    setPruneLeafyBranches(false);
-    setPrefixGridScanLevel(prefixTree.getMaxLevels()-2);//user might want to change, however
-    setPointsOnly(false);
-    setDistErrPct(0);
-  }
-
-  @Override
-  public NumberRangePrefixTree getGrid() {
-    return (NumberRangePrefixTree) super.getGrid();
-  }
-
-  @Override
-  public Field[] createIndexableFields(Shape shape) {
-    //levels doesn't actually matter; NumberRange based Shapes have their own "level".
-    TokenStream tokenStream = createTokenStream(shape, grid.getMaxLevels());
-    Field field = new Field(getFieldName(), tokenStream, FIELD_TYPE);
-    return new Field[]{field};
-  }
-
-  /** Unsupported. */
-  @Override
-  public ValueSource makeDistanceValueSource(Point queryPoint, double multiplier) {
-    throw new UnsupportedOperationException();
-  }
-
-  /** Calculates facets between {@code start} and {@code end} to a detail level one greater than that provided by the
-   * arguments. For example providing March to October of 2014 would return facets to the day level of those months.
-   * This is just a convenience method.
-   * @see #calcFacets(IndexReaderContext, Filter, Shape, int)
-   */
-  public Facets calcFacets(IndexReaderContext context, Filter filter, UnitNRShape start, UnitNRShape end)
-      throws IOException {
-    Shape facetRange = getGrid().toRangeShape(start, end);
-    int detailLevel = Math.max(start.getLevel(), end.getLevel()) + 1;
-    return calcFacets(context, filter, facetRange, detailLevel);
-  }
-
-  /**
-   * Calculates facets (aggregated counts) given a range shape (start-end span) and a level, which specifies the detail.
-   * To get the level of an existing shape, say a Calendar, call
-   * {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree#toUnitShape(Object)} then call
-   * {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape#getLevel()}.
-   * Facet computation is implemented by navigating the underlying indexed terms efficiently.
-   */
-  public Facets calcFacets(IndexReaderContext context, Filter filter, Shape facetRange, final int level)
-      throws IOException {
-    final Facets facets = new Facets(level);
-    PrefixTreeFacetCounter.compute(this, context, filter, facetRange, level,
-        new PrefixTreeFacetCounter.FacetVisitor() {
-          Facets.FacetParentVal parentFacet;
-          UnitNRShape parentShape;
-
-          @Override
-          public void visit(Cell cell, int count) {
-            if (cell.getLevel() < level - 1) {//some ancestor of parent facet level, direct or distant
-              parentFacet = null;//reset
-              parentShape = null;//reset
-              facets.topLeaves += count;
-            } else if (cell.getLevel() == level - 1) {//parent
-              //set up FacetParentVal
-              setupParent((UnitNRShape) cell.getShape());
-              parentFacet.parentLeaves += count;
-            } else {//at facet level
-              UnitNRShape unitShape = (UnitNRShape) cell.getShape();
-              UnitNRShape unitShapeParent = unitShape.getShapeAtLevel(unitShape.getLevel() - 1);
-              if (parentFacet == null || !parentShape.equals(unitShapeParent)) {
-                setupParent(unitShapeParent);
-              }
-              //lazy init childCounts
-              if (parentFacet.childCounts == null) {
-                parentFacet.childCounts = new int[parentFacet.childCountsLen];
-              }
-              parentFacet.childCounts[unitShape.getValAtLevel(cell.getLevel())] += count;
-            }
-          }
-
-          private void setupParent(UnitNRShape unitShape) {
-            parentShape = unitShape.clone();
-            //Look for existing parentFacet (from previous segment), or create anew if needed
-            parentFacet = facets.parents.get(parentShape);
-            if (parentFacet == null) {//didn't find one; make a new one
-              parentFacet = new Facets.FacetParentVal();
-              parentFacet.childCountsLen = getGrid().getNumSubCells(parentShape);
-              facets.parents.put(parentShape, parentFacet);
-            }
-          }
-        });
-    return facets;
-  }
-
-  /** Facet response information */
-  public static class Facets {
-    //TODO consider a variable-level structure -- more general purpose.
-
-    public Facets(int detailLevel) {
-      this.detailLevel = detailLevel;
-    }
-
-    /** The bottom-most detail-level counted, as requested. */
-    public final int detailLevel;
-
-    /**
-     * The count of documents with ranges that completely spanned the parents of the detail level. In more technical
-     * terms, this is the count of leaf cells 2 up and higher from the bottom. Usually you only care about counts at
-     * detailLevel, and so you will add this number to all other counts below, including to omitted/implied children
-     * counts of 0. If there are no indexed ranges (just instances, i.e. fully specified dates) then this value will
-     * always be 0.
-     */
-    public int topLeaves;
-
-    /** Holds all the {@link FacetParentVal} instances in order of the key. This is sparse; there won't be an
-     * instance if it's count and children are all 0. The keys are {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape} shapes, which can be
-     * converted back to the original Object (i.e. a Calendar) via
-     * {@link NumberRangePrefixTree#toObject(org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape)}. */
-    public final SortedMap<UnitNRShape,FacetParentVal> parents = new TreeMap<>();
-
-    /** Holds a block of detailLevel counts aggregated to their parent level. */
-    public static class FacetParentVal {
-
-      /** The count of ranges that span all of the childCounts.  In more technical terms, this is the number of leaf
-       * cells found at this parent.  Treat this like {@link Facets#topLeaves}. */
-      public int parentLeaves;
-
-      /** The length of {@link #childCounts}. If childCounts is not null then this is childCounts.length, otherwise it
-       * says how long it would have been if it weren't null. */
-      public int childCountsLen;
-
-      /** The detail level counts. It will be null if there are none, and thus they are assumed 0. Most apps, when
-       * presenting the information, will add {@link #topLeaves} and {@link #parentLeaves} to each count. */
-      public int[] childCounts;
-      //assert childCountsLen == childCounts.length
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder buf = new StringBuilder(2048);
-      buf.append("Facets: level=" + detailLevel + " topLeaves=" + topLeaves + " parentCount=" + parents.size());
-      for (Map.Entry<UnitNRShape, FacetParentVal> entry : parents.entrySet()) {
-        buf.append('\n');
-        if (buf.length() > 1000) {
-          buf.append("...");
-          break;
-        }
-        final FacetParentVal pVal = entry.getValue();
-        buf.append(' ').append(entry.getKey()+" leafCount=" + pVal.parentLeaves);
-        if (pVal.childCounts != null) {
-          buf.append(' ').append(Arrays.toString(pVal.childCounts));
-        }
-      }
-      return buf.toString();
-    }
-  }
-
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeStrategy.java b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeStrategy.java
new file mode 100644
index 0000000..d7baf58
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/NumberRangePrefixTreeStrategy.java
@@ -0,0 +1,203 @@
+package org.apache.lucene.spatial.prefix;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.spatial.prefix.tree.Cell;
+import org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree;
+
+import static org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape;
+
+/** A PrefixTree based on Number/Date ranges. This isn't very "spatial" on the surface (to the user) but
+ * it's implemented using spatial so that's why it's here extending a SpatialStrategy. When using this class, you will
+ * use various utility methods on the prefix tree implementation to convert objects/strings to/from shapes.
+ *
+ * To use with dates, pass in {@link org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree}.
+ *
+ * @lucene.experimental
+ */
+public class NumberRangePrefixTreeStrategy extends RecursivePrefixTreeStrategy {
+
+  public NumberRangePrefixTreeStrategy(NumberRangePrefixTree prefixTree, String fieldName) {
+    super(prefixTree, fieldName);
+    setPruneLeafyBranches(false);
+    setPrefixGridScanLevel(prefixTree.getMaxLevels()-2);//user might want to change, however
+    setPointsOnly(false);
+    setDistErrPct(0);
+  }
+
+  @Override
+  public NumberRangePrefixTree getGrid() {
+    return (NumberRangePrefixTree) super.getGrid();
+  }
+
+  @Override
+  public Field[] createIndexableFields(Shape shape) {
+    //levels doesn't actually matter; NumberRange based Shapes have their own "level".
+    TokenStream tokenStream = createTokenStream(shape, grid.getMaxLevels());
+    Field field = new Field(getFieldName(), tokenStream, FIELD_TYPE);
+    return new Field[]{field};
+  }
+
+  /** Unsupported. */
+  @Override
+  public ValueSource makeDistanceValueSource(Point queryPoint, double multiplier) {
+    throw new UnsupportedOperationException();
+  }
+
+  /** Calculates facets between {@code start} and {@code end} to a detail level one greater than that provided by the
+   * arguments. For example providing March to October of 2014 would return facets to the day level of those months.
+   * This is just a convenience method.
+   * @see #calcFacets(IndexReaderContext, Filter, Shape, int)
+   */
+  public Facets calcFacets(IndexReaderContext context, Filter filter, UnitNRShape start, UnitNRShape end)
+      throws IOException {
+    Shape facetRange = getGrid().toRangeShape(start, end);
+    int detailLevel = Math.max(start.getLevel(), end.getLevel()) + 1;
+    return calcFacets(context, filter, facetRange, detailLevel);
+  }
+
+  /**
+   * Calculates facets (aggregated counts) given a range shape (start-end span) and a level, which specifies the detail.
+   * To get the level of an existing shape, say a Calendar, call
+   * {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree#toUnitShape(Object)} then call
+   * {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape#getLevel()}.
+   * Facet computation is implemented by navigating the underlying indexed terms efficiently.
+   */
+  public Facets calcFacets(IndexReaderContext context, Filter filter, Shape facetRange, final int level)
+      throws IOException {
+    final Facets facets = new Facets(level);
+    PrefixTreeFacetCounter.compute(this, context, filter, facetRange, level,
+        new PrefixTreeFacetCounter.FacetVisitor() {
+          Facets.FacetParentVal parentFacet;
+          UnitNRShape parentShape;
+
+          @Override
+          public void visit(Cell cell, int count) {
+            if (cell.getLevel() < level - 1) {//some ancestor of parent facet level, direct or distant
+              parentFacet = null;//reset
+              parentShape = null;//reset
+              facets.topLeaves += count;
+            } else if (cell.getLevel() == level - 1) {//parent
+              //set up FacetParentVal
+              setupParent((UnitNRShape) cell.getShape());
+              parentFacet.parentLeaves += count;
+            } else {//at facet level
+              UnitNRShape unitShape = (UnitNRShape) cell.getShape();
+              UnitNRShape unitShapeParent = unitShape.getShapeAtLevel(unitShape.getLevel() - 1);
+              if (parentFacet == null || !parentShape.equals(unitShapeParent)) {
+                setupParent(unitShapeParent);
+              }
+              //lazy init childCounts
+              if (parentFacet.childCounts == null) {
+                parentFacet.childCounts = new int[parentFacet.childCountsLen];
+              }
+              parentFacet.childCounts[unitShape.getValAtLevel(cell.getLevel())] += count;
+            }
+          }
+
+          private void setupParent(UnitNRShape unitShape) {
+            parentShape = unitShape.clone();
+            //Look for existing parentFacet (from previous segment), or create anew if needed
+            parentFacet = facets.parents.get(parentShape);
+            if (parentFacet == null) {//didn't find one; make a new one
+              parentFacet = new Facets.FacetParentVal();
+              parentFacet.childCountsLen = getGrid().getNumSubCells(parentShape);
+              facets.parents.put(parentShape, parentFacet);
+            }
+          }
+        });
+    return facets;
+  }
+
+  /** Facet response information */
+  public static class Facets {
+    //TODO consider a variable-level structure -- more general purpose.
+
+    public Facets(int detailLevel) {
+      this.detailLevel = detailLevel;
+    }
+
+    /** The bottom-most detail-level counted, as requested. */
+    public final int detailLevel;
+
+    /**
+     * The count of documents with ranges that completely spanned the parents of the detail level. In more technical
+     * terms, this is the count of leaf cells 2 up and higher from the bottom. Usually you only care about counts at
+     * detailLevel, and so you will add this number to all other counts below, including to omitted/implied children
+     * counts of 0. If there are no indexed ranges (just instances, i.e. fully specified dates) then this value will
+     * always be 0.
+     */
+    public int topLeaves;
+
+    /** Holds all the {@link FacetParentVal} instances in order of the key. This is sparse; there won't be an
+     * instance if it's count and children are all 0. The keys are {@link org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape} shapes, which can be
+     * converted back to the original Object (i.e. a Calendar) via
+     * {@link NumberRangePrefixTree#toObject(org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape)}. */
+    public final SortedMap<UnitNRShape,FacetParentVal> parents = new TreeMap<>();
+
+    /** Holds a block of detailLevel counts aggregated to their parent level. */
+    public static class FacetParentVal {
+
+      /** The count of ranges that span all of the childCounts.  In more technical terms, this is the number of leaf
+       * cells found at this parent.  Treat this like {@link Facets#topLeaves}. */
+      public int parentLeaves;
+
+      /** The length of {@link #childCounts}. If childCounts is not null then this is childCounts.length, otherwise it
+       * says how long it would have been if it weren't null. */
+      public int childCountsLen;
+
+      /** The detail level counts. It will be null if there are none, and thus they are assumed 0. Most apps, when
+       * presenting the information, will add {@link #topLeaves} and {@link #parentLeaves} to each count. */
+      public int[] childCounts;
+      //assert childCountsLen == childCounts.length
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder(2048);
+      buf.append("Facets: level=" + detailLevel + " topLeaves=" + topLeaves + " parentCount=" + parents.size());
+      for (Map.Entry<UnitNRShape, FacetParentVal> entry : parents.entrySet()) {
+        buf.append('\n');
+        if (buf.length() > 1000) {
+          buf.append("...");
+          break;
+        }
+        final FacetParentVal pVal = entry.getValue();
+        buf.append(' ').append(entry.getKey()+" leafCount=" + pVal.parentLeaves);
+        if (pVal.childCounts != null) {
+          buf.append(' ').append(Arrays.toString(pVal.childCounts));
+        }
+      }
+      return buf.toString();
+    }
+  }
+
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java
index 0e9fd83..f308e8c 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java
@@ -50,7 +50,7 @@ import org.apache.lucene.util.StringHelper;
  * Unlike "normal" spatial components in this module, this special-purpose one only works with {@link Shape}s
  * created by the methods on this class, not from any {@link com.spatial4j.core.context.SpatialContext}.
  *
- * @see org.apache.lucene.spatial.NumberRangePrefixTreeStrategy
+ * @see org.apache.lucene.spatial.prefix.NumberRangePrefixTreeStrategy
  * @see <a href="https://issues.apache.org/jira/browse/LUCENE-5648">LUCENE-5648</a>
  * @lucene.experimental
  */
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java
index fc628c0..c5092bf 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/DateNRStrategyTest.java
@@ -22,7 +22,6 @@ import java.util.Calendar;
 
 import com.carrotsearch.randomizedtesting.annotations.Repeat;
 import com.spatial4j.core.shape.Shape;
-import org.apache.lucene.spatial.NumberRangePrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree;
 import org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape;
 import org.apache.lucene.spatial.query.SpatialOperation;
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/NumberRangeFacetsTest.java b/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/NumberRangeFacetsTest.java
index f190bf0..83e0528 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/NumberRangeFacetsTest.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/prefix/NumberRangeFacetsTest.java
@@ -28,9 +28,8 @@ import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.TermsFilter;
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.NumberRangePrefixTreeStrategy;
-import org.apache.lucene.spatial.NumberRangePrefixTreeStrategy.Facets;
 import org.apache.lucene.spatial.StrategyTestCase;
+import org.apache.lucene.spatial.prefix.NumberRangePrefixTreeStrategy.Facets;
 import org.apache.lucene.spatial.prefix.tree.Cell;
 import org.apache.lucene.spatial.prefix.tree.CellIterator;
 import org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree;
diff --git a/solr/core/src/java/org/apache/solr/schema/DateRangeField.java b/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
index d6f4627..6590476 100644
--- a/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
+++ b/solr/core/src/java/org/apache/solr/schema/DateRangeField.java
@@ -26,7 +26,7 @@ import java.util.Map;
 import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.NumberRangePrefixTreeStrategy;
+import org.apache.lucene.spatial.prefix.NumberRangePrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree;
 import org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.NRShape;
 import org.apache.lucene.spatial.prefix.tree.NumberRangePrefixTree.UnitNRShape;

