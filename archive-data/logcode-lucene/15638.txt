GitDiffStart: 789a44d7061b47d993d2797ff162c8ffc8a51fbe | Fri Jun 3 15:00:13 2011 +0000
diff --git a/lucene/src/java/org/apache/lucene/document/Fieldable.java b/lucene/src/java/org/apache/lucene/document/Fieldable.java
index 8b9c325..81529bc 100755
--- a/lucene/src/java/org/apache/lucene/document/Fieldable.java
+++ b/lucene/src/java/org/apache/lucene/document/Fieldable.java
@@ -18,7 +18,7 @@ package org.apache.lucene.document;
 
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.index.FieldInvertState; // for javadocs
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.PerDocFieldValues;
 import org.apache.lucene.index.values.ValueType;
 import org.apache.lucene.search.PhraseQuery; // for javadocs
@@ -219,7 +219,7 @@ public interface Fieldable {
    * Sets the {@link PerDocFieldValues} for this field. If
    * {@link PerDocFieldValues} is set this field will store per-document values
    * 
-   * @see DocValues
+   * @see IndexDocValues
    */
   public void setDocValues(PerDocFieldValues docValues);
 
diff --git a/lucene/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/src/java/org/apache/lucene/index/CheckIndex.java
index 145a438..1da3d4d 100644
--- a/lucene/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/src/java/org/apache/lucene/index/CheckIndex.java
@@ -28,7 +28,7 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.index.codecs.CodecProvider;
 import org.apache.lucene.index.codecs.DefaultSegmentInfosWriter;
 import org.apache.lucene.index.codecs.PerDocValues;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.DocValuesEnum;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
@@ -952,7 +952,7 @@ public class CheckIndex {
         if (fieldInfo.hasDocValues()) {
           status.totalValueFields++;
           final PerDocValues perDocValues = reader.perDocValues();
-          final DocValues docValues = perDocValues.docValues(fieldInfo.name);
+          final IndexDocValues docValues = perDocValues.docValues(fieldInfo.name);
           if (docValues == null) {
             continue;
           }
diff --git a/lucene/src/java/org/apache/lucene/index/FieldsEnum.java b/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
index 51ffa5f..5d2d707 100644
--- a/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
+++ b/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
@@ -19,7 +19,7 @@ package org.apache.lucene.index;
 
 import java.io.IOException;
 
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.DocValuesEnum;
 import org.apache.lucene.util.AttributeSource;
 
diff --git a/lucene/src/java/org/apache/lucene/index/IndexReader.java b/lucene/src/java/org/apache/lucene/index/IndexReader.java
index 2fc8173..0eb25dc 100644
--- a/lucene/src/java/org/apache/lucene/index/IndexReader.java
+++ b/lucene/src/java/org/apache/lucene/index/IndexReader.java
@@ -24,7 +24,7 @@ import org.apache.lucene.search.Similarity;
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.codecs.CodecProvider;
 import org.apache.lucene.index.codecs.PerDocValues;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.store.*;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
@@ -1585,7 +1585,7 @@ public abstract class IndexReader implements Cloneable,Closeable {
     throw new UnsupportedOperationException("This reader does not support this method.");
   }
   
-  public DocValues docValues(String field) throws IOException {
+  public IndexDocValues docValues(String field) throws IOException {
     final PerDocValues perDoc = perDocValues();
     if (perDoc == null) {
       return null;
diff --git a/lucene/src/java/org/apache/lucene/index/MultiFields.java b/lucene/src/java/org/apache/lucene/index/MultiFields.java
index 453bce7..920bcf6 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiFields.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiFields.java
@@ -22,7 +22,7 @@ import java.util.Map;
 import java.util.List;
 import java.util.ArrayList;
 
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.MultiDocValues;
 import org.apache.lucene.index.values.ValueType;
 import org.apache.lucene.index.values.MultiDocValues.DocValuesIndex;
diff --git a/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java b/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
index 60848bb..d4a5c06 100644
--- a/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
+++ b/lucene/src/java/org/apache/lucene/index/MultiPerDocValues.java
@@ -24,7 +24,7 @@ import java.util.TreeSet;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.lucene.index.codecs.PerDocValues;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.MultiDocValues;
 import org.apache.lucene.index.values.ValueType;
 import org.apache.lucene.index.values.MultiDocValues.DocValuesIndex;
@@ -47,7 +47,7 @@ import org.apache.lucene.util.ReaderUtil.Gather;
 public class MultiPerDocValues extends PerDocValues {
   private final PerDocValues[] subs;
   private final ReaderUtil.Slice[] subSlices;
-  private final Map<String, DocValues> docValues = new ConcurrentHashMap<String, DocValues>();
+  private final Map<String, IndexDocValues> docValues = new ConcurrentHashMap<String, IndexDocValues>();
   private final TreeSet<String> fields;
 
   public MultiPerDocValues(PerDocValues[] subs, ReaderUtil.Slice[] subSlices) {
@@ -110,8 +110,8 @@ public class MultiPerDocValues extends PerDocValues {
     return perDocValues;
   }
 
-  public DocValues docValues(String field) throws IOException {
-    DocValues result = docValues.get(field);
+  public IndexDocValues docValues(String field) throws IOException {
+    IndexDocValues result = docValues.get(field);
     if (result == null) {
       // Lazy init: first time this field is requested, we
       // create & add to docValues:
@@ -120,7 +120,7 @@ public class MultiPerDocValues extends PerDocValues {
       ValueType type = null;
       // Gather all sub-readers that share this field
       for (int i = 0; i < subs.length; i++) {
-        DocValues values = subs[i].docValues(field);
+        IndexDocValues values = subs[i].docValues(field);
         final int start = subSlices[i].start;
         final int length = subSlices[i].length;
         if (values != null) {
diff --git a/lucene/src/java/org/apache/lucene/index/PerFieldCodecWrapper.java b/lucene/src/java/org/apache/lucene/index/PerFieldCodecWrapper.java
index 10aa7c2..7e8b73a 100644
--- a/lucene/src/java/org/apache/lucene/index/PerFieldCodecWrapper.java
+++ b/lucene/src/java/org/apache/lucene/index/PerFieldCodecWrapper.java
@@ -34,7 +34,7 @@ import org.apache.lucene.index.codecs.PerDocConsumer;
 import org.apache.lucene.index.codecs.PerDocValues;
 import org.apache.lucene.index.codecs.TermsConsumer;
 import org.apache.lucene.index.codecs.DocValuesConsumer;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
 
@@ -257,7 +257,7 @@ final class PerFieldCodecWrapper extends Codec {
       return codecs.keySet();
     }
     @Override
-    public DocValues docValues(String field) throws IOException {
+    public IndexDocValues docValues(String field) throws IOException {
       final PerDocValues perDocProducer = codecs.get(field);
       if (perDocProducer == null) {
         return null;
diff --git a/lucene/src/java/org/apache/lucene/index/SegmentReader.java b/lucene/src/java/org/apache/lucene/index/SegmentReader.java
index 0273fab..61fe5a6 100644
--- a/lucene/src/java/org/apache/lucene/index/SegmentReader.java
+++ b/lucene/src/java/org/apache/lucene/index/SegmentReader.java
@@ -30,7 +30,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.index.codecs.PerDocValues;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.store.BufferedIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
@@ -842,7 +842,7 @@ public class SegmentReader extends IndexReader implements Cloneable {
 
   
   @Override
-  public DocValues docValues(String field) throws IOException {
+  public IndexDocValues docValues(String field) throws IOException {
     return core.perDocProducer.docValues(field);
   }
 
diff --git a/lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java b/lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java
index 8d16a6c..c17f84d 100644
--- a/lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java
+++ b/lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java
@@ -35,7 +35,7 @@ import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.codecs.standard.StandardPostingsReader; // javadocs
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
diff --git a/lucene/src/java/org/apache/lucene/index/codecs/DefaultDocValuesProducer.java b/lucene/src/java/org/apache/lucene/index/codecs/DefaultDocValuesProducer.java
index d3d6980..a509f56 100644
--- a/lucene/src/java/org/apache/lucene/index/codecs/DefaultDocValuesProducer.java
+++ b/lucene/src/java/org/apache/lucene/index/codecs/DefaultDocValuesProducer.java
@@ -25,7 +25,7 @@ import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.index.codecs.PerDocValues;
 import org.apache.lucene.index.values.Bytes;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.Floats;
 import org.apache.lucene.index.values.Ints;
 import org.apache.lucene.index.values.ValueType;
@@ -33,22 +33,22 @@ import org.apache.lucene.store.Directory;
 
 /**
  * Abstract base class for FieldsProducer implementations supporting
- * {@link DocValues}.
+ * {@link IndexDocValues}.
  * 
  * @lucene.experimental
  */
 public class DefaultDocValuesProducer extends PerDocValues {
 
-  protected final TreeMap<String, DocValues> docValues;
+  protected final TreeMap<String, IndexDocValues> docValues;
 
   /**
    * Creates a new {@link DefaultDocValuesProducer} instance and loads all
-   * {@link DocValues} instances for this segment and codec.
+   * {@link IndexDocValues} instances for this segment and codec.
    * 
    * @param si
-   *          the segment info to load the {@link DocValues} for.
+   *          the segment info to load the {@link IndexDocValues} for.
    * @param dir
-   *          the directory to load the {@link DocValues} from.
+   *          the directory to load the {@link IndexDocValues} from.
    * @param fieldInfo
    *          the {@link FieldInfos}
    * @param codecId
@@ -62,19 +62,19 @@ public class DefaultDocValuesProducer extends PerDocValues {
   }
 
   /**
-   * Returns a {@link DocValues} instance for the given field name or
-   * <code>null</code> if this field has no {@link DocValues}.
+   * Returns a {@link IndexDocValues} instance for the given field name or
+   * <code>null</code> if this field has no {@link IndexDocValues}.
    */
   @Override
-  public DocValues docValues(String field) throws IOException {
+  public IndexDocValues docValues(String field) throws IOException {
     return docValues.get(field);
   }
 
   // Only opens files... doesn't actually load any values
-  protected TreeMap<String, DocValues> load(FieldInfos fieldInfos,
+  protected TreeMap<String, IndexDocValues> load(FieldInfos fieldInfos,
       String segment, int docCount, Directory dir, int codecId)
       throws IOException {
-    TreeMap<String, DocValues> values = new TreeMap<String, DocValues>();
+    TreeMap<String, IndexDocValues> values = new TreeMap<String, IndexDocValues>();
     boolean success = false;
     try {
 
@@ -101,25 +101,25 @@ public class DefaultDocValuesProducer extends PerDocValues {
   
 
   /**
-   * Loads a {@link DocValues} instance depending on the given {@link ValueType}.
+   * Loads a {@link IndexDocValues} instance depending on the given {@link ValueType}.
    * Codecs that use different implementations for a certain {@link ValueType} can
    * simply override this method and return their custom implementations.
    * 
    * @param docCount
    *          number of documents in the segment
    * @param dir
-   *          the {@link Directory} to load the {@link DocValues} from
+   *          the {@link Directory} to load the {@link IndexDocValues} from
    * @param id
    *          the unique file ID within the segment
    * @param type
    *          the type to load
-   * @return a {@link DocValues} instance for the given type
+   * @return a {@link IndexDocValues} instance for the given type
    * @throws IOException
    *           if an {@link IOException} occurs
    * @throws IllegalArgumentException
    *           if the given {@link ValueType} is not supported
    */
-  protected DocValues loadDocValues(int docCount, Directory dir, String id,
+  protected IndexDocValues loadDocValues(int docCount, Directory dir, String id,
       ValueType type) throws IOException {
     switch (type) {
     case INTS:
@@ -149,10 +149,10 @@ public class DefaultDocValuesProducer extends PerDocValues {
     closeDocValues(docValues.values());
   }
 
-  private void closeDocValues(final Collection<DocValues> values)
+  private void closeDocValues(final Collection<IndexDocValues> values)
       throws IOException {
     IOException ex = null;
-    for (DocValues docValues : values) {
+    for (IndexDocValues docValues : values) {
       try {
         docValues.close();
       } catch (IOException e) {
diff --git a/lucene/src/java/org/apache/lucene/index/codecs/DocValuesConsumer.java b/lucene/src/java/org/apache/lucene/index/codecs/DocValuesConsumer.java
index caf98aa..98a4d9f 100644
--- a/lucene/src/java/org/apache/lucene/index/codecs/DocValuesConsumer.java
+++ b/lucene/src/java/org/apache/lucene/index/codecs/DocValuesConsumer.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.PerDocFieldValues;
 import org.apache.lucene.index.values.Writer;
 import org.apache.lucene.util.Bits;
@@ -99,7 +99,7 @@ public abstract class DocValuesConsumer {
    *           if an {@link IOException} occurs
    */
   public void merge(org.apache.lucene.index.codecs.MergeState mergeState,
-      DocValues values) throws IOException {
+      IndexDocValues values) throws IOException {
     assert mergeState != null;
     // TODO we need some kind of compatibility notation for values such
     // that two slightly different segments can be merged eg. fixed vs.
@@ -112,7 +112,7 @@ public abstract class DocValuesConsumer {
      * with MultiDocValues the writer can not optimize for bulk-copyable data
      */
     for (final IndexReader reader : mergeState.readers) {
-      final DocValues r = reader.docValues(mergeState.fieldInfo.name);
+      final IndexDocValues r = reader.docValues(mergeState.fieldInfo.name);
       if (r != null) {
         merged = true;
         merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader
@@ -148,7 +148,7 @@ public abstract class DocValuesConsumer {
      * the source reader for this MergeState - merged values should be read from
      * this instance
      */
-    public final DocValues reader;
+    public final IndexDocValues reader;
     /** the absolute docBase for this MergeState within the resulting segment */
     public final int docBase;
     /** the number of documents in this MergeState */
@@ -156,7 +156,7 @@ public abstract class DocValuesConsumer {
     /** the deleted bits for this MergeState */
     public final Bits bits;
 
-    public MergeState(DocValues reader, int docBase, int docCount, Bits bits) {
+    public MergeState(IndexDocValues reader, int docBase, int docCount, Bits bits) {
       assert reader != null;
       this.reader = reader;
       this.docBase = docBase;
diff --git a/lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer.java b/lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer.java
index 1749414..7acaef4 100644
--- a/lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer.java
+++ b/lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer.java
@@ -19,7 +19,7 @@ import java.io.Closeable;
 import java.io.IOException;
 
 import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 
 /**
  * Abstract API that consumes per document values. Concrete implementations of
@@ -48,7 +48,7 @@ public abstract class PerDocConsumer implements Closeable{
       assert mergeState.fieldInfo != null : "FieldInfo for field is null: "
           + field;
       if (mergeState.fieldInfo.hasDocValues()) {
-        final DocValues docValues = producer.docValues(field);
+        final IndexDocValues docValues = producer.docValues(field);
         if (docValues == null) {
           /*
            * It is actually possible that a fieldInfo has a values type but no
diff --git a/lucene/src/java/org/apache/lucene/index/codecs/PerDocValues.java b/lucene/src/java/org/apache/lucene/index/codecs/PerDocValues.java
index 19b0c4e..bc194df 100644
--- a/lucene/src/java/org/apache/lucene/index/codecs/PerDocValues.java
+++ b/lucene/src/java/org/apache/lucene/index/codecs/PerDocValues.java
@@ -19,7 +19,7 @@ import java.io.Closeable;
 import java.io.IOException;
 import java.util.Collection;
 
-import org.apache.lucene.index.values.DocValues;
+import org.apache.lucene.index.values.IndexDocValues;
 
 /**
  * Abstract API that provides access to one or more per-document storage
@@ -35,15 +35,15 @@ import org.apache.lucene.index.values.DocValues;
  */
 public abstract class PerDocValues implements Closeable {
   /**
-   * Returns {@link DocValues} for the current field.
+   * Returns {@link IndexDocValues} for the current field.
    * 
    * @param field
    *          the field name
-   * @return the {@link DocValues} for this field or <code>null</code> if not
+   * @return the {@link IndexDocValues} for this field or <code>null</code> if not
    *         applicable.
    * @throws IOException
    */
-  public abstract DocValues docValues(String field) throws IOException;
+  public abstract IndexDocValues docValues(String field) throws IOException;
 
   public static final PerDocValues[] EMPTY_ARRAY = new PerDocValues[0];
 
diff --git a/lucene/src/java/org/apache/lucene/index/values/Bytes.java b/lucene/src/java/org/apache/lucene/index/values/Bytes.java
index d94fa17..cddc69e 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Bytes.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Bytes.java
@@ -24,9 +24,9 @@ import java.util.Comparator;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.values.DocValues.SortedSource;
-import org.apache.lucene.index.values.DocValues.Source;
-import org.apache.lucene.index.values.DocValues.SourceEnum;
+import org.apache.lucene.index.values.IndexDocValues.SortedSource;
+import org.apache.lucene.index.values.IndexDocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues.SourceEnum;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
@@ -136,13 +136,13 @@ public final class Bytes {
   }
 
   /**
-   * Creates a new {@link DocValues} instance that provides either memory
+   * Creates a new {@link IndexDocValues} instance that provides either memory
    * resident or iterative access to a per-document stored <tt>byte[]</tt>
-   * value. The returned {@link DocValues} instance will be initialized without
+   * value. The returned {@link IndexDocValues} instance will be initialized without
    * consuming a significant amount of memory.
    * 
    * @param dir
-   *          the directory to load the {@link DocValues} from.
+   *          the directory to load the {@link IndexDocValues} from.
    * @param id
    *          the file ID in the {@link Directory} to load the values from.
    * @param mode
@@ -152,11 +152,11 @@ public final class Bytes {
    *          otherwise <code>false</code>
    * @param maxDoc
    *          the number of document values stored for the given ID
-   * @return an initialized {@link DocValues} instance.
+   * @return an initialized {@link IndexDocValues} instance.
    * @throws IOException
    *           if an {@link IOException} occurs
    */
-  public static DocValues getValues(Directory dir, String id, Mode mode,
+  public static IndexDocValues getValues(Directory dir, String id, Mode mode,
       boolean fixedSize, int maxDoc) throws IOException {
     // TODO -- I can peek @ header to determing fixed/mode?
     if (fixedSize) {
@@ -421,7 +421,7 @@ public final class Bytes {
    * Opens all necessary files, but does not read any data in until you call
    * {@link #load}.
    */
-  static abstract class BytesReaderBase extends DocValues {
+  static abstract class BytesReaderBase extends IndexDocValues {
     protected final IndexInput idxIn;
     protected final IndexInput datIn;
     protected final int version;
diff --git a/lucene/src/java/org/apache/lucene/index/values/DocValues.java b/lucene/src/java/org/apache/lucene/index/values/DocValues.java
deleted file mode 100644
index 4ad9a07..0000000
--- a/lucene/src/java/org/apache/lucene/index/values/DocValues.java
+++ /dev/null
@@ -1,344 +0,0 @@
-package org.apache.lucene.index.values;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Comparator;
-
-import org.apache.lucene.index.Fields;
-import org.apache.lucene.index.FieldsEnum;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * nocommit - javadoc 
- * 
- * @lucene.experimental
- */
-public abstract class DocValues implements Closeable {
-  /*
-   * TODO: it might be useful to add another Random Access enum for some
-   * implementations like packed ints and only return such a random access enum
-   * if the impl supports random access. For super large segments it might be
-   * useful or even required in certain environements to have disc based random
-   * access
-   */
-  public static final DocValues[] EMPTY_ARRAY = new DocValues[0];
-
-  private SourceCache cache = new SourceCache.DirectSourceCache();
-
-  /**
-   * Returns an iterator that steps through all documents values for this
-   * {@link DocValues} field instance. {@link DocValuesEnum} will skip document
-   * without a value if applicable.
-   */
-  public DocValuesEnum getEnum() throws IOException {
-    return getEnum(null);
-  }
-
-  /**
-   * Returns an iterator that steps through all documents values for this
-   * {@link DocValues} field instance. {@link DocValuesEnum} will skip document
-   * without a value if applicable.
-   * <p>
-   * If an {@link AttributeSource} is supplied to this method the
-   * {@link DocValuesEnum} will use the given source to access implementation
-   * related attributes.
-   */
-  public abstract DocValuesEnum getEnum(AttributeSource attrSource)
-      throws IOException;
-
-  /**
-   * Loads a new {@link Source} instance for this {@link DocValues} field
-   * instance. Source instances returned from this method are not cached. It is
-   * the callers responsibility to maintain the instance and release its
-   * resources once the source is not needed anymore.
-   * <p>
-   * This method will return null iff this {@link DocValues} represent a
-   * {@link SortedSource}.
-   * <p>
-   * For managed {@link Source} instances see {@link #getSource()}.
-   * 
-   * @see #getSource()
-   * @see #setCache(SourceCache)
-   */
-  public abstract Source load() throws IOException;
-
-  /**
-   * Returns a {@link Source} instance through the current {@link SourceCache}.
-   * Iff no {@link Source} has been loaded into the cache so far the source will
-   * be loaded through {@link #load()} and passed to the {@link SourceCache}.
-   * The caller of this method should not close the obtained {@link Source}
-   * instance unless it is not needed for the rest of its life time.
-   * <p>
-   * {@link Source} instances obtained from this method are closed / released
-   * from the cache once this {@link DocValues} instance is closed by the
-   * {@link IndexReader}, {@link Fields} or {@link FieldsEnum} the
-   * {@link DocValues} was created from.
-   * <p>
-   * This method will return null iff this {@link DocValues} represent a
-   * {@link SortedSource}.
-   */
-  public Source getSource() throws IOException {
-    return cache.load(this);
-  }
-
-  /**
-   * Returns a {@link SortedSource} instance for this {@link DocValues} field
-   * instance like {@link #getSource()}.
-   * <p>
-   * This method will return null iff this {@link DocValues} represent a
-   * {@link Source} instead of a {@link SortedSource}.
-   */
-  public SortedSource getSortedSorted(Comparator<BytesRef> comparator)
-      throws IOException {
-    return cache.loadSorted(this, comparator);
-  }
-
-  /**
-   * Loads and returns a {@link SortedSource} instance for this
-   * {@link DocValues} field instance like {@link #load()}.
-   * <p>
-   * This method will return null iff this {@link DocValues} represent a
-   * {@link Source} instead of a {@link SortedSource}.
-   */
-  public SortedSource loadSorted(Comparator<BytesRef> comparator)
-      throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
-  /**
-   * Returns the {@link ValueType} of this {@link DocValues} instance
-   */
-  public abstract ValueType type();
-
-  /**
-   * Closes this {@link DocValues} instance. This method should only be called
-   * by the creator of this {@link DocValues} instance. API users should not
-   * close {@link DocValues} instances.
-   */
-  public void close() throws IOException {
-    cache.close(this);
-  }
-
-  /**
-   * Sets the {@link SourceCache} used by this {@link DocValues} instance. This
-   * method should be called before {@link #load()} or
-   * {@link #loadSorted(Comparator)} is called. All {@link Source} or
-   * {@link SortedSource} instances in the currently used cache will be closed
-   * before the new cache is installed.
-   * <p>
-   * Note: All instances previously obtained from {@link #load()} or
-   * {@link #loadSorted(Comparator)} will be closed.
-   * 
-   * @throws IllegalArgumentException
-   *           if the given cache is <code>null</code>
-   * 
-   */
-  public void setCache(SourceCache cache) {
-    if (cache == null)
-      throw new IllegalArgumentException("cache must not be null");
-    synchronized (this.cache) {
-      this.cache.close(this);
-      this.cache = cache;
-    }
-  }
-
-  /**
-   * Source of per document values like long, double or {@link BytesRef}
-   * depending on the {@link DocValues} fields {@link ValueType}. Source
-   * implementations provide random access semantics similar to array lookups
-   * and typically are entirely memory resident.
-   * <p>
-   * {@link Source} defines 3 {@link ValueType} //TODO finish this
-   */
-  public static abstract class Source {
-
-    /**
-     * Returns a <tt>long</tt> for the given document id or throws an
-     * {@link UnsupportedOperationException} if this source doesn't support
-     * <tt>long</tt> values.
-     * 
-     * @throws UnsupportedOperationException
-     *           if this source doesn't support <tt>long</tt> values.
-     */
-    public long getInt(int docID) {
-      throw new UnsupportedOperationException("ints are not supported");
-    }
-
-    /**
-     * Returns a <tt>double</tt> for the given document id or throws an
-     * {@link UnsupportedOperationException} if this source doesn't support
-     * <tt>double</tt> values.
-     * 
-     * @throws UnsupportedOperationException
-     *           if this source doesn't support <tt>double</tt> values.
-     */
-    public double getFloat(int docID) {
-      throw new UnsupportedOperationException("floats are not supported");
-    }
-
-    /**
-     * Returns a {@link BytesRef} for the given document id or throws an
-     * {@link UnsupportedOperationException} if this source doesn't support
-     * <tt>byte[]</tt> values.
-     * 
-     * @throws UnsupportedOperationException
-     *           if this source doesn't support <tt>byte[]</tt> values.
-     */
-    public BytesRef getBytes(int docID, BytesRef ref) {
-      throw new UnsupportedOperationException("bytes are not supported");
-    }
-
-    /**
-     * Returns number of unique values. Some implementations may throw
-     * UnsupportedOperationException.
-     */
-    public int getValueCount() {
-      throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Returns a {@link DocValuesEnum} for this source.
-     */
-    public DocValuesEnum getEnum() throws IOException {
-      return getEnum(null);
-    }
-
-    /**
-     * Returns the {@link ValueType} of this source.
-     * 
-     * @return the {@link ValueType} of this source.
-     */
-    public abstract ValueType type();
-
-    /**
-     * Returns a {@link DocValuesEnum} for this source which uses the given
-     * {@link AttributeSource}.
-     */
-    public abstract DocValuesEnum getEnum(AttributeSource attrSource)
-        throws IOException;
-  }
-
-  /**
-   * {@link DocValuesEnum} utility for {@link Source} implemenations.
-   * 
-   */
-  public abstract static class SourceEnum extends DocValuesEnum {
-    protected final Source source;
-    protected final int numDocs;
-    protected int pos = -1;
-
-    /**
-     * Creates a new {@link SourceEnum}
-     * 
-     * @param attrs
-     *          the {@link AttributeSource} for this enum
-     * @param type
-     *          the enums {@link ValueType}
-     * @param source
-     *          the source this enum operates on
-     * @param numDocs
-     *          the number of documents within the source
-     */
-    protected SourceEnum(AttributeSource attrs, ValueType type, Source source,
-        int numDocs) {
-      super(attrs, type);
-      this.source = source;
-      this.numDocs = numDocs;
-    }
-
-    @Override
-    public void close() throws IOException {
-    }
-
-    @Override
-    public int docID() {
-      return pos;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      if (pos == NO_MORE_DOCS)
-        return NO_MORE_DOCS;
-      return advance(pos + 1);
-    }
-  }
-
-  /**
-   * A sorted variant of {@link Source} for <tt>byte[]</tt> values per document.
-   * <p>
-   * Note: {@link DocValuesEnum} obtained from a {@link SortedSource} will
-   * enumerate values in document order and not in sorted order.
-   */
-  public static abstract class SortedSource extends Source {
-
-    @Override
-    public BytesRef getBytes(int docID, BytesRef bytesRef) {
-      final int ord = ord(docID);
-      if (ord < 0) {
-        bytesRef.length = 0;
-      } else {
-        getByOrd(ord , bytesRef);
-      }
-      return bytesRef;
-    }
-
-    /**
-     * Returns ord for specified docID. If this docID had not been added to the
-     * Writer, the ord is 0. Ord is dense, ie, starts at 0, then increments by 1
-     * for the next (as defined by {@link Comparator} value.
-     */
-    public abstract int ord(int docID);
-
-    /** Returns value for specified ord. */
-    public abstract BytesRef getByOrd(int ord, BytesRef bytesRef);
-
-
-    /**
-     * Finds the ordinal whose value is greater or equal to the given value.
-     * 
-     * @return the given values ordinal if found or otherwise
-     *         <code>(-(ord)-1)</code>, defined as the ordinal of the first
-     *         element that is greater than the given value. This guarantees
-     *         that the return value will always be &gt;= 0 if the given value
-     *         is found.
-     * 
-     */
-    public final int getByValue(BytesRef value) {
-      return getByValue(value, new BytesRef());
-    }
-
-    /**
-     * Performs a lookup by value.
-     * 
-     * @param value
-     *          the value to look up
-     * @param tmpRef
-     *          a temporary {@link BytesRef} instance used to compare internal
-     *          values to the given value. Must not be <code>null</code>
-     * @return the given values ordinal if found or otherwise
-     *         <code>(-(ord)-1)</code>, defined as the ordinal of the first
-     *         element that is greater than the given value. This guarantees
-     *         that the return value will always be &gt;= 0 if the given value
-     *         is found.
-     */
-    public abstract int getByValue(BytesRef value, BytesRef tmpRef);
-  }
-}
diff --git a/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
index e1385a4..b5ba7e8 100644
--- a/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
@@ -166,7 +166,7 @@ class FixedSortedBytesImpl {
     }
 
     @Override
-    public org.apache.lucene.index.values.DocValues.Source load()
+    public org.apache.lucene.index.values.IndexDocValues.Source load()
         throws IOException {
       return loadSorted(null);
     }
diff --git a/lucene/src/java/org/apache/lucene/index/values/Floats.java b/lucene/src/java/org/apache/lucene/index/values/Floats.java
index 72d1ec8..52a1f2f 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Floats.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Floats.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.values.DocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
@@ -63,7 +63,7 @@ public class Floats {
     }
   }
 
-  public static DocValues getValues(Directory dir, String id, int maxDoc)
+  public static IndexDocValues getValues(Directory dir, String id, int maxDoc)
       throws IOException {
     return new FloatsReader(dir, id, maxDoc);
   }
@@ -232,7 +232,7 @@ public class Floats {
    * Opens all necessary files, but does not read any data in until you call
    * {@link #load}.
    */
-  static class FloatsReader extends DocValues {
+  static class FloatsReader extends IndexDocValues {
 
     private final IndexInput datIn;
     private final int precisionBytes;
diff --git a/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java b/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java
new file mode 100644
index 0000000..e4d68bc
--- /dev/null
+++ b/lucene/src/java/org/apache/lucene/index/values/IndexDocValues.java
@@ -0,0 +1,344 @@
+package org.apache.lucene.index.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Comparator;
+
+import org.apache.lucene.index.Fields;
+import org.apache.lucene.index.FieldsEnum;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * nocommit - javadoc 
+ * 
+ * @lucene.experimental
+ */
+public abstract class IndexDocValues implements Closeable {
+  /*
+   * TODO: it might be useful to add another Random Access enum for some
+   * implementations like packed ints and only return such a random access enum
+   * if the impl supports random access. For super large segments it might be
+   * useful or even required in certain environements to have disc based random
+   * access
+   */
+  public static final IndexDocValues[] EMPTY_ARRAY = new IndexDocValues[0];
+
+  private SourceCache cache = new SourceCache.DirectSourceCache();
+
+  /**
+   * Returns an iterator that steps through all documents values for this
+   * {@link IndexDocValues} field instance. {@link DocValuesEnum} will skip document
+   * without a value if applicable.
+   */
+  public DocValuesEnum getEnum() throws IOException {
+    return getEnum(null);
+  }
+
+  /**
+   * Returns an iterator that steps through all documents values for this
+   * {@link IndexDocValues} field instance. {@link DocValuesEnum} will skip document
+   * without a value if applicable.
+   * <p>
+   * If an {@link AttributeSource} is supplied to this method the
+   * {@link DocValuesEnum} will use the given source to access implementation
+   * related attributes.
+   */
+  public abstract DocValuesEnum getEnum(AttributeSource attrSource)
+      throws IOException;
+
+  /**
+   * Loads a new {@link Source} instance for this {@link IndexDocValues} field
+   * instance. Source instances returned from this method are not cached. It is
+   * the callers responsibility to maintain the instance and release its
+   * resources once the source is not needed anymore.
+   * <p>
+   * This method will return null iff this {@link IndexDocValues} represent a
+   * {@link SortedSource}.
+   * <p>
+   * For managed {@link Source} instances see {@link #getSource()}.
+   * 
+   * @see #getSource()
+   * @see #setCache(SourceCache)
+   */
+  public abstract Source load() throws IOException;
+
+  /**
+   * Returns a {@link Source} instance through the current {@link SourceCache}.
+   * Iff no {@link Source} has been loaded into the cache so far the source will
+   * be loaded through {@link #load()} and passed to the {@link SourceCache}.
+   * The caller of this method should not close the obtained {@link Source}
+   * instance unless it is not needed for the rest of its life time.
+   * <p>
+   * {@link Source} instances obtained from this method are closed / released
+   * from the cache once this {@link IndexDocValues} instance is closed by the
+   * {@link IndexReader}, {@link Fields} or {@link FieldsEnum} the
+   * {@link IndexDocValues} was created from.
+   * <p>
+   * This method will return null iff this {@link IndexDocValues} represent a
+   * {@link SortedSource}.
+   */
+  public Source getSource() throws IOException {
+    return cache.load(this);
+  }
+
+  /**
+   * Returns a {@link SortedSource} instance for this {@link IndexDocValues} field
+   * instance like {@link #getSource()}.
+   * <p>
+   * This method will return null iff this {@link IndexDocValues} represent a
+   * {@link Source} instead of a {@link SortedSource}.
+   */
+  public SortedSource getSortedSorted(Comparator<BytesRef> comparator)
+      throws IOException {
+    return cache.loadSorted(this, comparator);
+  }
+
+  /**
+   * Loads and returns a {@link SortedSource} instance for this
+   * {@link IndexDocValues} field instance like {@link #load()}.
+   * <p>
+   * This method will return null iff this {@link IndexDocValues} represent a
+   * {@link Source} instead of a {@link SortedSource}.
+   */
+  public SortedSource loadSorted(Comparator<BytesRef> comparator)
+      throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  /**
+   * Returns the {@link ValueType} of this {@link IndexDocValues} instance
+   */
+  public abstract ValueType type();
+
+  /**
+   * Closes this {@link IndexDocValues} instance. This method should only be called
+   * by the creator of this {@link IndexDocValues} instance. API users should not
+   * close {@link IndexDocValues} instances.
+   */
+  public void close() throws IOException {
+    cache.close(this);
+  }
+
+  /**
+   * Sets the {@link SourceCache} used by this {@link IndexDocValues} instance. This
+   * method should be called before {@link #load()} or
+   * {@link #loadSorted(Comparator)} is called. All {@link Source} or
+   * {@link SortedSource} instances in the currently used cache will be closed
+   * before the new cache is installed.
+   * <p>
+   * Note: All instances previously obtained from {@link #load()} or
+   * {@link #loadSorted(Comparator)} will be closed.
+   * 
+   * @throws IllegalArgumentException
+   *           if the given cache is <code>null</code>
+   * 
+   */
+  public void setCache(SourceCache cache) {
+    if (cache == null)
+      throw new IllegalArgumentException("cache must not be null");
+    synchronized (this.cache) {
+      this.cache.close(this);
+      this.cache = cache;
+    }
+  }
+
+  /**
+   * Source of per document values like long, double or {@link BytesRef}
+   * depending on the {@link IndexDocValues} fields {@link ValueType}. Source
+   * implementations provide random access semantics similar to array lookups
+   * and typically are entirely memory resident.
+   * <p>
+   * {@link Source} defines 3 {@link ValueType} //TODO finish this
+   */
+  public static abstract class Source {
+
+    /**
+     * Returns a <tt>long</tt> for the given document id or throws an
+     * {@link UnsupportedOperationException} if this source doesn't support
+     * <tt>long</tt> values.
+     * 
+     * @throws UnsupportedOperationException
+     *           if this source doesn't support <tt>long</tt> values.
+     */
+    public long getInt(int docID) {
+      throw new UnsupportedOperationException("ints are not supported");
+    }
+
+    /**
+     * Returns a <tt>double</tt> for the given document id or throws an
+     * {@link UnsupportedOperationException} if this source doesn't support
+     * <tt>double</tt> values.
+     * 
+     * @throws UnsupportedOperationException
+     *           if this source doesn't support <tt>double</tt> values.
+     */
+    public double getFloat(int docID) {
+      throw new UnsupportedOperationException("floats are not supported");
+    }
+
+    /**
+     * Returns a {@link BytesRef} for the given document id or throws an
+     * {@link UnsupportedOperationException} if this source doesn't support
+     * <tt>byte[]</tt> values.
+     * 
+     * @throws UnsupportedOperationException
+     *           if this source doesn't support <tt>byte[]</tt> values.
+     */
+    public BytesRef getBytes(int docID, BytesRef ref) {
+      throw new UnsupportedOperationException("bytes are not supported");
+    }
+
+    /**
+     * Returns number of unique values. Some implementations may throw
+     * UnsupportedOperationException.
+     */
+    public int getValueCount() {
+      throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns a {@link DocValuesEnum} for this source.
+     */
+    public DocValuesEnum getEnum() throws IOException {
+      return getEnum(null);
+    }
+
+    /**
+     * Returns the {@link ValueType} of this source.
+     * 
+     * @return the {@link ValueType} of this source.
+     */
+    public abstract ValueType type();
+
+    /**
+     * Returns a {@link DocValuesEnum} for this source which uses the given
+     * {@link AttributeSource}.
+     */
+    public abstract DocValuesEnum getEnum(AttributeSource attrSource)
+        throws IOException;
+  }
+
+  /**
+   * {@link DocValuesEnum} utility for {@link Source} implemenations.
+   * 
+   */
+  public abstract static class SourceEnum extends DocValuesEnum {
+    protected final Source source;
+    protected final int numDocs;
+    protected int pos = -1;
+
+    /**
+     * Creates a new {@link SourceEnum}
+     * 
+     * @param attrs
+     *          the {@link AttributeSource} for this enum
+     * @param type
+     *          the enums {@link ValueType}
+     * @param source
+     *          the source this enum operates on
+     * @param numDocs
+     *          the number of documents within the source
+     */
+    protected SourceEnum(AttributeSource attrs, ValueType type, Source source,
+        int numDocs) {
+      super(attrs, type);
+      this.source = source;
+      this.numDocs = numDocs;
+    }
+
+    @Override
+    public void close() throws IOException {
+    }
+
+    @Override
+    public int docID() {
+      return pos;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      if (pos == NO_MORE_DOCS)
+        return NO_MORE_DOCS;
+      return advance(pos + 1);
+    }
+  }
+
+  /**
+   * A sorted variant of {@link Source} for <tt>byte[]</tt> values per document.
+   * <p>
+   * Note: {@link DocValuesEnum} obtained from a {@link SortedSource} will
+   * enumerate values in document order and not in sorted order.
+   */
+  public static abstract class SortedSource extends Source {
+
+    @Override
+    public BytesRef getBytes(int docID, BytesRef bytesRef) {
+      final int ord = ord(docID);
+      if (ord < 0) {
+        bytesRef.length = 0;
+      } else {
+        getByOrd(ord , bytesRef);
+      }
+      return bytesRef;
+    }
+
+    /**
+     * Returns ord for specified docID. If this docID had not been added to the
+     * Writer, the ord is 0. Ord is dense, ie, starts at 0, then increments by 1
+     * for the next (as defined by {@link Comparator} value.
+     */
+    public abstract int ord(int docID);
+
+    /** Returns value for specified ord. */
+    public abstract BytesRef getByOrd(int ord, BytesRef bytesRef);
+
+
+    /**
+     * Finds the ordinal whose value is greater or equal to the given value.
+     * 
+     * @return the given values ordinal if found or otherwise
+     *         <code>(-(ord)-1)</code>, defined as the ordinal of the first
+     *         element that is greater than the given value. This guarantees
+     *         that the return value will always be &gt;= 0 if the given value
+     *         is found.
+     * 
+     */
+    public final int getByValue(BytesRef value) {
+      return getByValue(value, new BytesRef());
+    }
+
+    /**
+     * Performs a lookup by value.
+     * 
+     * @param value
+     *          the value to look up
+     * @param tmpRef
+     *          a temporary {@link BytesRef} instance used to compare internal
+     *          values to the given value. Must not be <code>null</code>
+     * @return the given values ordinal if found or otherwise
+     *         <code>(-(ord)-1)</code>, defined as the ordinal of the first
+     *         element that is greater than the given value. This guarantees
+     *         that the return value will always be &gt;= 0 if the given value
+     *         is found.
+     */
+    public abstract int getByValue(BytesRef value, BytesRef tmpRef);
+  }
+}
diff --git a/lucene/src/java/org/apache/lucene/index/values/Ints.java b/lucene/src/java/org/apache/lucene/index/values/Ints.java
index 52dbcc6..d11b548 100644
--- a/lucene/src/java/org/apache/lucene/index/values/Ints.java
+++ b/lucene/src/java/org/apache/lucene/index/values/Ints.java
@@ -39,7 +39,7 @@ public class Ints {
     return new IntsWriter(dir, id, bytesUsed);
   }
 
-  public static DocValues getValues(Directory dir, String id,
+  public static IndexDocValues getValues(Directory dir, String id,
       boolean useFixedArray) throws IOException {
     return new IntsReader(dir, id);
   }
diff --git a/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java b/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
index 6456f9d..3187d80 100644
--- a/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
+++ b/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
@@ -26,15 +26,15 @@ import org.apache.lucene.util.ReaderUtil;
 /**
  * @lucene.experimental
  */
-public class MultiDocValues extends DocValues {
+public class MultiDocValues extends IndexDocValues {
 
   public static class DocValuesIndex {
     public final static DocValuesIndex[] EMPTY_ARRAY = new DocValuesIndex[0];
     final int start;
     final int length;
-    final DocValues docValues;
+    final IndexDocValues docValues;
 
-    public DocValuesIndex(DocValues docValues, int start, int length) {
+    public DocValuesIndex(IndexDocValues docValues, int start, int length) {
       this.docValues = docValues;
       this.start = start;
       this.length = length;
@@ -67,7 +67,7 @@ public class MultiDocValues extends DocValues {
     super.close();
   }
 
-  public DocValues reset(DocValuesIndex[] docValuesIdx) {
+  public IndexDocValues reset(DocValuesIndex[] docValuesIdx) {
     int[] start = new int[docValuesIdx.length];
     for (int i = 0; i < docValuesIdx.length; i++) {
       start[i] = docValuesIdx[i].start;
@@ -77,7 +77,7 @@ public class MultiDocValues extends DocValues {
     return this;
   }
 
-  public static class DummyDocValues extends DocValues {
+  public static class DummyDocValues extends IndexDocValues {
     final int maxDoc;
     final Source emptySoruce;
 
diff --git a/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java b/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
index ca58317..4f3f885 100644
--- a/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
@@ -182,7 +182,7 @@ class PackedIntsImpl {
    * Opens all necessary files, but does not read any data in until you call
    * {@link #load}.
    */
-  static class IntsReader extends DocValues {
+  static class IntsReader extends IndexDocValues {
     private final IndexInput datIn;
     private final boolean packed;
 
diff --git a/lucene/src/java/org/apache/lucene/index/values/SourceCache.java b/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
index 565df06..7080006 100644
--- a/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
+++ b/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
@@ -21,23 +21,23 @@ import java.io.IOException;
 import java.util.Comparator;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.values.DocValues.SortedSource;
-import org.apache.lucene.index.values.DocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues.SortedSource;
+import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.util.BytesRef;
 
 /**
- * Abstract base class for {@link DocValues} {@link Source} /
+ * Abstract base class for {@link IndexDocValues} {@link Source} /
  * {@link SortedSource} cache.
  * <p>
  * {@link Source} and {@link SortedSource} instances loaded via
- * {@link DocValues#load()} and {@link DocValues#loadSorted(Comparator)} are
+ * {@link IndexDocValues#load()} and {@link IndexDocValues#loadSorted(Comparator)} are
  * entirely memory resident and need to be maintained by the caller. Each call
- * to {@link DocValues#load()} or {@link DocValues#loadSorted(Comparator)} will
+ * to {@link IndexDocValues#load()} or {@link IndexDocValues#loadSorted(Comparator)} will
  * cause an entire reload of the underlying data. Source and
- * {@link SortedSource} instances obtained from {@link DocValues#getSource()}
- * and {@link DocValues#getSource()} respectively are maintained by a
- * {@link SourceCache} that is closed ({@link #close(DocValues)}) once the
- * {@link IndexReader} that created the {@link DocValues} instance is closed.
+ * {@link SortedSource} instances obtained from {@link IndexDocValues#getSource()}
+ * and {@link IndexDocValues#getSource()} respectively are maintained by a
+ * {@link SourceCache} that is closed ({@link #close(IndexDocValues)}) once the
+ * {@link IndexReader} that created the {@link IndexDocValues} instance is closed.
  * <p>
  * Unless {@link Source} and {@link SortedSource} instances are managed by
  * another entity it is recommended to use the cached variants to obtain a
@@ -45,9 +45,9 @@ import org.apache.lucene.util.BytesRef;
  * <p>
  * Implementation of this API must be thread-safe.
  * 
- * @see DocValues#setCache(SourceCache)
- * @see DocValues#getSource()
- * @see DocValues#getSortedSorted(Comparator)
+ * @see IndexDocValues#setCache(SourceCache)
+ * @see IndexDocValues#getSource()
+ * @see IndexDocValues#getSortedSorted(Comparator)
  * 
  * @lucene.experimental
  */
@@ -55,38 +55,38 @@ public abstract class SourceCache {
 
   /**
    * Atomically loads a {@link Source} into the cache from the given
-   * {@link DocValues} and returns it iff no other {@link Source} has already
+   * {@link IndexDocValues} and returns it iff no other {@link Source} has already
    * been cached. Otherwise the cached source is returned.
    * <p>
    * This method will not return <code>null</code>
    */
-  public abstract Source load(DocValues values) throws IOException;
+  public abstract Source load(IndexDocValues values) throws IOException;
 
   /**
    * Atomically loads a {@link SortedSource} into the cache from the given
-   * {@link DocValues} and returns it iff no other {@link SortedSource} has
+   * {@link IndexDocValues} and returns it iff no other {@link SortedSource} has
    * already been cached. Otherwise the cached source is returned.
    * <p>
    * This method will not return <code>null</code>
    */
-  public abstract SortedSource loadSorted(DocValues values,
+  public abstract SortedSource loadSorted(IndexDocValues values,
       Comparator<BytesRef> comp) throws IOException;
 
   /**
    * Atomically invalidates the cached {@link Source} and {@link SortedSource}
    * instances if any and empties the cache.
    */
-  public abstract void invalidate(DocValues values);
+  public abstract void invalidate(IndexDocValues values);
 
   /**
    * Atomically closes the cache and frees all resources.
    */
-  public synchronized void close(DocValues values) {
+  public synchronized void close(IndexDocValues values) {
     invalidate(values);
   }
 
   /**
-   * Simple per {@link DocValues} instance cache implementation that holds a
+   * Simple per {@link IndexDocValues} instance cache implementation that holds a
    * {@link Source} and {@link SortedSource} reference as a member variable.
    * <p>
    * If a {@link DirectSourceCache} instance is closed or invalidated the cached
@@ -96,14 +96,14 @@ public abstract class SourceCache {
     private Source ref;
     private SortedSource sortedRef;
 
-    public synchronized Source load(DocValues values) throws IOException {
+    public synchronized Source load(IndexDocValues values) throws IOException {
       if (ref == null) {
         ref = values.load();
       }
       return ref;
     }
 
-    public synchronized SortedSource loadSorted(DocValues values,
+    public synchronized SortedSource loadSorted(IndexDocValues values,
         Comparator<BytesRef> comp) throws IOException {
       if (sortedRef == null) {
         sortedRef = values.loadSorted(comp);
@@ -111,7 +111,7 @@ public abstract class SourceCache {
       return sortedRef;
     }
 
-    public synchronized void invalidate(DocValues values) {
+    public synchronized void invalidate(IndexDocValues values) {
       ref = null;
       sortedRef = null;
     }
diff --git a/lucene/src/java/org/apache/lucene/index/values/ValueType.java b/lucene/src/java/org/apache/lucene/index/values/ValueType.java
index d1d4ced..fa8f95a 100644
--- a/lucene/src/java/org/apache/lucene/index/values/ValueType.java
+++ b/lucene/src/java/org/apache/lucene/index/values/ValueType.java
@@ -19,10 +19,10 @@ package org.apache.lucene.index.values;
 
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.codecs.PerDocConsumer;
-import org.apache.lucene.index.values.DocValues.SortedSource;
+import org.apache.lucene.index.values.IndexDocValues.SortedSource;
 
 /**
- * {@link ValueType} specifies the type of the {@link DocValues} for a certain field.
+ * {@link ValueType} specifies the type of the {@link IndexDocValues} for a certain field.
  * A {@link ValueType} only defines the data type for a field while the actual
  * Implementation used to encode and decode the values depends on the field's
  * {@link Codec}. It is up to the {@link Codec} implementing
diff --git a/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java b/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
index c459692..ac6bbbe 100644
--- a/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
+++ b/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
@@ -161,7 +161,7 @@ class VarSortedBytesImpl {
     }
 
     @Override
-    public org.apache.lucene.index.values.DocValues.Source load()
+    public org.apache.lucene.index.values.IndexDocValues.Source load()
         throws IOException {
       return loadSorted(null);
     }
diff --git a/lucene/src/java/org/apache/lucene/search/FieldComparator.java b/lucene/src/java/org/apache/lucene/search/FieldComparator.java
index 3dbb76e..7ab0d4c 100644
--- a/lucene/src/java/org/apache/lucene/search/FieldComparator.java
+++ b/lucene/src/java/org/apache/lucene/search/FieldComparator.java
@@ -20,8 +20,8 @@ package org.apache.lucene.search;
 import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
-import org.apache.lucene.index.values.DocValues;
-import org.apache.lucene.index.values.DocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues;
+import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.search.FieldCache.DocTerms;
 import org.apache.lucene.search.FieldCache.DocTermsIndex;
 import org.apache.lucene.search.cache.ByteValuesCreator;
@@ -375,7 +375,7 @@ public abstract class FieldComparator {
 
     @Override
     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {
-      final DocValues docValues = context.reader.docValues(field);
+      final IndexDocValues docValues = context.reader.docValues(field);
       if (docValues != null) {
         currentReaderValues = docValues.getSource(); 
       }
@@ -651,7 +651,7 @@ public abstract class FieldComparator {
 
     @Override
     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {
-      DocValues docValues = context.reader.docValues(field);
+      IndexDocValues docValues = context.reader.docValues(field);
       if (docValues != null) {
         currentReaderValues = docValues.getSource();
       }
diff --git a/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java b/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
index 5cc14d8..42d32a0 100644
--- a/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
+++ b/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
@@ -21,8 +21,8 @@ import java.io.IOException;
 import java.util.Comparator;
 import java.util.concurrent.atomic.AtomicLong;
 
-import org.apache.lucene.index.values.DocValues.SortedSource;
-import org.apache.lucene.index.values.DocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues.SortedSource;
+import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.FloatsRef;
@@ -81,7 +81,7 @@ public class TestDocValues extends LuceneTestCase {
     w.finish(maxDoc);
     assertEquals(0, trackBytes.get());
 
-    DocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc);
+    IndexDocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc);
     for (int iter = 0; iter < 2; iter++) {
       DocValuesEnum bytesEnum = getEnum(r);
       assertNotNull("enum is null", bytesEnum);
@@ -103,7 +103,7 @@ public class TestDocValues extends LuceneTestCase {
     // Verify we can load source twice:
     for (int iter = 0; iter < 2; iter++) {
       Source s;
-      DocValues.SortedSource ss;
+      IndexDocValues.SortedSource ss;
       if (mode == Bytes.Mode.SORTED) {
         s = ss = getSortedSource(r, comp);
       } else {
@@ -199,7 +199,7 @@ public class TestDocValues extends LuceneTestCase {
         w.finish(NUM_VALUES + additionalDocs);
         assertEquals(0, trackBytes.get());
 
-        DocValues r = Ints.getValues(dir, "test", false);
+        IndexDocValues r = Ints.getValues(dir, "test", false);
         for (int iter = 0; iter < 2; iter++) {
           Source s = getSource(r);
           for (int i = 0; i < NUM_VALUES; i++) {
@@ -263,7 +263,7 @@ public class TestDocValues extends LuceneTestCase {
     w.finish(NUM_VALUES + additionalValues);
     assertEquals(0, trackBytes.get());
 
-    DocValues r = Floats.getValues(dir, "test", NUM_VALUES + additionalValues);
+    IndexDocValues r = Floats.getValues(dir, "test", NUM_VALUES + additionalValues);
     for (int iter = 0; iter < 2; iter++) {
       Source s = getSource(r);
       for (int i = 0; i < NUM_VALUES; i++) {
@@ -308,16 +308,16 @@ public class TestDocValues extends LuceneTestCase {
     runTestFloats(8, 0.0);
   }
   
-  private DocValuesEnum getEnum(DocValues values) throws IOException {
+  private DocValuesEnum getEnum(IndexDocValues values) throws IOException {
     return random.nextBoolean() ? values.getEnum() : getSource(values).getEnum();
   }
 
-  private Source getSource(DocValues values) throws IOException {
+  private Source getSource(IndexDocValues values) throws IOException {
     // getSource uses cache internally
     return random.nextBoolean() ? values.load() : values.getSource();
   }
 
-  private SortedSource getSortedSource(DocValues values,
+  private SortedSource getSortedSource(IndexDocValues values,
       Comparator<BytesRef> comparator) throws IOException {
     // getSortedSource uses cache internally
     return random.nextBoolean() ? values.loadSorted(comparator) : values
diff --git a/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java b/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
index 8986f11..910fe38 100644
--- a/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
+++ b/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
@@ -41,7 +41,7 @@ import org.apache.lucene.index.MultiPerDocValues;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.codecs.CodecProvider;
 import org.apache.lucene.index.codecs.PerDocValues;
-import org.apache.lucene.index.values.DocValues.Source;
+import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.search.IndexSearcher;
@@ -107,7 +107,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     TopDocs search = searcher.search(parser.parse("0 OR 1 OR 2 OR 3 OR 4"), 10);
     assertEquals(5, search.totalHits);
     ScoreDoc[] scoreDocs = search.scoreDocs;
-    DocValues docValues = MultiPerDocValues.getPerDocs(reader).docValues("docId");
+    IndexDocValues docValues = MultiPerDocValues.getPerDocs(reader).docValues("docId");
     Source source = docValues.getSource();
     for (int i = 0; i < scoreDocs.length; i++) {
       assertEquals(i, scoreDocs[i].doc);
@@ -264,7 +264,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
       final int base = r.numDocs() - numRemainingValues;
       switch (val) {
       case INTS: {
-        DocValues intsReader = getDocValues(r, val.name());
+        IndexDocValues intsReader = getDocValues(r, val.name());
         assertNotNull(intsReader);
 
         Source ints = getSource(intsReader);
@@ -295,7 +295,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
         break;
       case FLOAT_32:
       case FLOAT_64: {
-        DocValues floatReader = getDocValues(r, val.name());
+        IndexDocValues floatReader = getDocValues(r, val.name());
         assertNotNull(floatReader);
         Source floats = getSource(floatReader);
         for (int i = 0; i < base; i++) {
@@ -353,7 +353,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
       assertEquals(0, r.numDeletedDocs());
       final int numRemainingValues = (int) (numValues - deleted.cardinality());
       final int base = r.numDocs() - numRemainingValues;
-      DocValues bytesReader = getDocValues(r, byteIndexValue.name());
+      IndexDocValues bytesReader = getDocValues(r, byteIndexValue.name());
       assertNotNull("field " + byteIndexValue.name()
           + " returned null reader - maybe merged failed", bytesReader);
       Source bytes = getSource(bytesReader);
@@ -448,7 +448,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     d.close();
   }
 
-  private DocValues getDocValues(IndexReader reader, String field)
+  private IndexDocValues getDocValues(IndexReader reader, String field)
       throws IOException {
     boolean optimized = reader.isOptimized();
     PerDocValues perDoc = optimized ? reader.getSequentialSubReaders()[0].perDocValues()
@@ -457,7 +457,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     case 0:
       return perDoc.docValues(field);
     case 1:
-      DocValues docValues = perDoc.docValues(field);
+      IndexDocValues docValues = perDoc.docValues(field);
       if (docValues != null) {
         return docValues;
       }
@@ -468,7 +468,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     throw new RuntimeException();
   }
 
-  private Source getSource(DocValues values) throws IOException {
+  private Source getSource(IndexDocValues values) throws IOException {
     Source source;
     if (random.nextInt(10) == 0) {
       source = values.load();
@@ -480,7 +480,7 @@ public class TestDocValuesIndexing extends LuceneTestCase {
     return source;
   }
 
-  private DocValuesEnum getValuesEnum(DocValues values) throws IOException {
+  private DocValuesEnum getValuesEnum(IndexDocValues values) throws IOException {
     DocValuesEnum valuesEnum;
     if (!(values instanceof MultiDocValues) && random.nextInt(10) == 0) {
       // TODO not supported by MultiDocValues yet!

