GitDiffStart: 6f278e589f9680e1466cb1d67344ccc0d17ba911 | Tue Jan 12 02:19:56 2010 +0000
diff --git a/client/ruby/solr-ruby/solr/conf/solrconfig.xml b/client/ruby/solr-ruby/solr/conf/solrconfig.xml
index 8dc1066..868ede6 100755
--- a/client/ruby/solr-ruby/solr/conf/solrconfig.xml
+++ b/client/ruby/solr-ruby/solr/conf/solrconfig.xml
@@ -367,10 +367,10 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="standard" class="org.apache.solr.request.XMLResponseWriter"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
+    <queryResponseWriter name="standard" class="org.apache.solr.response.XMLResponseWriter"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -379,7 +379,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter> 
     
diff --git a/client/ruby/solr-ruby/test/conf/solrconfig.xml b/client/ruby/solr-ruby/test/conf/solrconfig.xml
index c6cd881..eb49446 100755
--- a/client/ruby/solr-ruby/test/conf/solrconfig.xml
+++ b/client/ruby/solr-ruby/test/conf/solrconfig.xml
@@ -349,10 +349,10 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="standard" class="org.apache.solr.request.XMLResponseWriter"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
+    <queryResponseWriter name="standard" class="org.apache.solr.response.XMLResponseWriter"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -361,7 +361,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter> 
     
diff --git a/contrib/clustering/src/test/java/org/apache/solr/handler/clustering/ClusteringComponentTest.java b/contrib/clustering/src/test/java/org/apache/solr/handler/clustering/ClusteringComponentTest.java
index 095d1b3..096710c 100644
--- a/contrib/clustering/src/test/java/org/apache/solr/handler/clustering/ClusteringComponentTest.java
+++ b/contrib/clustering/src/test/java/org/apache/solr/handler/clustering/ClusteringComponentTest.java
@@ -24,7 +24,7 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.component.QueryComponent;
 import org.apache.solr.handler.component.SearchComponent;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
 
 
diff --git a/contrib/clustering/src/test/resources/solr/conf/solrconfig.xml b/contrib/clustering/src/test/resources/solr/conf/solrconfig.xml
index 110953e..659fc0b 100644
--- a/contrib/clustering/src/test/resources/solr/conf/solrconfig.xml
+++ b/contrib/clustering/src/test/resources/solr/conf/solrconfig.xml
@@ -522,12 +522,12 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -536,7 +536,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter> 
 
diff --git a/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DataImportHandler.java b/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DataImportHandler.java
index 44aba95..5f492fe 100644
--- a/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DataImportHandler.java
+++ b/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DataImportHandler.java
@@ -31,9 +31,9 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
-import org.apache.solr.request.RawResponseWriter;
+import org.apache.solr.response.RawResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
diff --git a/contrib/extraction/src/main/java/org/apache/solr/handler/extraction/ExtractingDocumentLoader.java b/contrib/extraction/src/main/java/org/apache/solr/handler/extraction/ExtractingDocumentLoader.java
index 3bab10a..a4427d7 100644
--- a/contrib/extraction/src/main/java/org/apache/solr/handler/extraction/ExtractingDocumentLoader.java
+++ b/contrib/extraction/src/main/java/org/apache/solr/handler/extraction/ExtractingDocumentLoader.java
@@ -23,7 +23,7 @@ import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
diff --git a/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java b/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java
index 8cadaf5..3a6893e 100644
--- a/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java
+++ b/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java
@@ -18,7 +18,7 @@ package org.apache.solr.handler;
 
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.common.util.NamedList;
diff --git a/contrib/velocity/src/main/java/org/apache/solr/request/PageTool.java b/contrib/velocity/src/main/java/org/apache/solr/request/PageTool.java
index bfe9513..b96566f 100644
--- a/contrib/velocity/src/main/java/org/apache/solr/request/PageTool.java
+++ b/contrib/velocity/src/main/java/org/apache/solr/request/PageTool.java
@@ -17,6 +17,7 @@
 
 package org.apache.solr.request;
 
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.DocSlice;
 import org.apache.solr.common.SolrDocumentList;
 
diff --git a/contrib/velocity/src/main/java/org/apache/solr/request/VelocityResponseWriter.java b/contrib/velocity/src/main/java/org/apache/solr/request/VelocityResponseWriter.java
index 397dc8d..30f8989 100644
--- a/contrib/velocity/src/main/java/org/apache/solr/request/VelocityResponseWriter.java
+++ b/contrib/velocity/src/main/java/org/apache/solr/request/VelocityResponseWriter.java
@@ -22,6 +22,8 @@ import org.apache.solr.client.solrj.SolrResponse;
 import org.apache.solr.client.solrj.response.QueryResponse;
 import org.apache.solr.client.solrj.response.SolrResponseBase;
 import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.velocity.Template;
 import org.apache.velocity.VelocityContext;
 import org.apache.velocity.tools.generic.*;
diff --git a/contrib/velocity/src/main/solr/conf/solrconfig.xml b/contrib/velocity/src/main/solr/conf/solrconfig.xml
index 107c350..cf837bb 100755
--- a/contrib/velocity/src/main/solr/conf/solrconfig.xml
+++ b/contrib/velocity/src/main/solr/conf/solrconfig.xml
@@ -743,23 +743,23 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
 
-  <queryResponseWriter name="velocity" class="org.apache.solr.request.VelocityResponseWriter"/>
+  <queryResponseWriter name="velocity" class="org.apache.solr.response.VelocityResponseWriter"/>
 
   <!-- XSLT response writer transforms the XML output by any xslt file found
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter>
 
diff --git a/example/example-DIH/solr/db/conf/solrconfig.xml b/example/example-DIH/solr/db/conf/solrconfig.xml
index 6de0f71..c286bdc 100644
--- a/example/example-DIH/solr/db/conf/solrconfig.xml
+++ b/example/example-DIH/solr/db/conf/solrconfig.xml
@@ -674,12 +674,12 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -688,7 +688,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter> 
     
diff --git a/example/example-DIH/solr/mail/conf/solrconfig.xml b/example/example-DIH/solr/mail/conf/solrconfig.xml
index 617b142..7939779 100644
--- a/example/example-DIH/solr/mail/conf/solrconfig.xml
+++ b/example/example-DIH/solr/mail/conf/solrconfig.xml
@@ -768,12 +768,12 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -782,7 +782,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter>
 
diff --git a/example/example-DIH/solr/rss/conf/solrconfig.xml b/example/example-DIH/solr/rss/conf/solrconfig.xml
index 1239aa0..db4f70c 100644
--- a/example/example-DIH/solr/rss/conf/solrconfig.xml
+++ b/example/example-DIH/solr/rss/conf/solrconfig.xml
@@ -673,12 +673,12 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -687,7 +687,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter> 
     
diff --git a/example/solr/conf/solrconfig.xml b/example/solr/conf/solrconfig.xml
index ee81b4f..2a1d63c 100755
--- a/example/solr/conf/solrconfig.xml
+++ b/example/solr/conf/solrconfig.xml
@@ -1001,12 +1001,12 @@
        The following response writers are implicitly configured unless
        overridden...
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
       Custom response writers can be declared as needed...
     
@@ -1017,7 +1017,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter>
 
diff --git a/src/java/org/apache/solr/core/QuerySenderListener.java b/src/java/org/apache/solr/core/QuerySenderListener.java
index b7935b0..69a40ba 100644
--- a/src/java/org/apache/solr/core/QuerySenderListener.java
+++ b/src/java/org/apache/solr/core/QuerySenderListener.java
@@ -23,7 +23,7 @@ import org.apache.solr.search.DocIterator;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 import java.util.List;
 
diff --git a/src/java/org/apache/solr/core/RequestHandlers.java b/src/java/org/apache/solr/core/RequestHandlers.java
index 1d7db50..2a9ff5c 100644
--- a/src/java/org/apache/solr/core/RequestHandlers.java
+++ b/src/java/org/apache/solr/core/RequestHandlers.java
@@ -21,8 +21,8 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.plugin.SolrCoreAware;
 import org.apache.solr.util.plugin.PluginInfoInitialized;
 import org.slf4j.Logger;
diff --git a/src/java/org/apache/solr/core/SolrConfig.java b/src/java/org/apache/solr/core/SolrConfig.java
index 5b6dc9a..4b2e7ff 100644
--- a/src/java/org/apache/solr/core/SolrConfig.java
+++ b/src/java/org/apache/solr/core/SolrConfig.java
@@ -25,7 +25,7 @@ import org.apache.solr.handler.component.SearchComponent;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.QueryResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
 
 import org.apache.solr.search.CacheConfig;
 import org.apache.solr.search.FastLRUCache;
diff --git a/src/java/org/apache/solr/core/SolrCore.java b/src/java/org/apache/solr/core/SolrCore.java
index 48f80ff..6603ccb 100644
--- a/src/java/org/apache/solr/core/SolrCore.java
+++ b/src/java/org/apache/solr/core/SolrCore.java
@@ -33,6 +33,16 @@ import org.apache.solr.handler.component.*;
 import org.apache.solr.highlight.DefaultSolrHighlighter;
 import org.apache.solr.highlight.SolrHighlighter;
 import org.apache.solr.request.*;
+import org.apache.solr.response.BinaryResponseWriter;
+import org.apache.solr.response.JSONResponseWriter;
+import org.apache.solr.response.PHPResponseWriter;
+import org.apache.solr.response.PHPSerializedResponseWriter;
+import org.apache.solr.response.PythonResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.RawResponseWriter;
+import org.apache.solr.response.RubyResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.response.XMLResponseWriter;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.search.QParserPlugin;
 import org.apache.solr.search.SolrFieldCacheMBean;
diff --git a/src/java/org/apache/solr/core/SolrResourceLoader.java b/src/java/org/apache/solr/core/SolrResourceLoader.java
index 892dbe8..35e7c38 100644
--- a/src/java/org/apache/solr/core/SolrResourceLoader.java
+++ b/src/java/org/apache/solr/core/SolrResourceLoader.java
@@ -47,8 +47,8 @@ import org.apache.solr.common.util.FileUtils;
 import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.handler.component.SearchComponent;
-import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.QueryResponseWriter;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.update.processor.UpdateRequestProcessorFactory;
 import org.apache.solr.util.plugin.ResourceLoaderAware;
@@ -63,7 +63,7 @@ public class SolrResourceLoader implements ResourceLoader
 
   static final String project = "solr";
   static final String base = "org.apache" + "." + project;
-  static final String[] packages = {"","analysis.","schema.","handler.","search.","update.","core.","request.","update.processor.","util.", "spelling.", "handler.component.", "handler.dataimport."};
+  static final String[] packages = {"","analysis.","schema.","handler.","search.","update.","core.","response","request.","update.processor.","util.", "spelling.", "handler.component.", "handler.dataimport." };
 
   private URLClassLoader classLoader;
   private final String instanceDir;
diff --git a/src/java/org/apache/solr/handler/AnalysisRequestHandler.java b/src/java/org/apache/solr/handler/AnalysisRequestHandler.java
index 2f03c38..e3c4bca 100644
--- a/src/java/org/apache/solr/handler/AnalysisRequestHandler.java
+++ b/src/java/org/apache/solr/handler/AnalysisRequestHandler.java
@@ -27,7 +27,7 @@ import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
diff --git a/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java b/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
index 6d222ff..83c336f 100644
--- a/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
+++ b/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
@@ -30,7 +30,7 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.FieldType;
 
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/handler/BinaryUpdateRequestHandler.java b/src/java/org/apache/solr/handler/BinaryUpdateRequestHandler.java
index d3f4fd7..b009f22 100644
--- a/src/java/org/apache/solr/handler/BinaryUpdateRequestHandler.java
+++ b/src/java/org/apache/solr/handler/BinaryUpdateRequestHandler.java
@@ -26,7 +26,7 @@ import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.ContentStream;
 import static org.apache.solr.handler.XmlUpdateRequestHandler.COMMIT_WITHIN;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
diff --git a/src/java/org/apache/solr/handler/CSVRequestHandler.java b/src/java/org/apache/solr/handler/CSVRequestHandler.java
index 706a0b1..14e5e90 100755
--- a/src/java/org/apache/solr/handler/CSVRequestHandler.java
+++ b/src/java/org/apache/solr/handler/CSVRequestHandler.java
@@ -18,7 +18,7 @@
 package org.apache.solr.handler;
 
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.params.SolrParams;
@@ -54,17 +54,17 @@ public class CSVRequestHandler extends ContentStreamHandlerBase {
 
   @Override
   public String getVersion() {
-    return "$Revision:$";
+    return "$Revision$";
   }
 
   @Override
   public String getSourceId() {
-    return "$Id:$";
+    return "$Id$";
   }
 
   @Override
   public String getSource() {
-    return "$URL:$";
+    return "$URL$";
   }
 }
 
diff --git a/src/java/org/apache/solr/handler/ContentStreamHandlerBase.java b/src/java/org/apache/solr/handler/ContentStreamHandlerBase.java
index b39fb7b..af2a6c3 100644
--- a/src/java/org/apache/solr/handler/ContentStreamHandlerBase.java
+++ b/src/java/org/apache/solr/handler/ContentStreamHandlerBase.java
@@ -21,7 +21,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
 
diff --git a/src/java/org/apache/solr/handler/ContentStreamLoader.java b/src/java/org/apache/solr/handler/ContentStreamLoader.java
index 7565d37..cc37681 100644
--- a/src/java/org/apache/solr/handler/ContentStreamLoader.java
+++ b/src/java/org/apache/solr/handler/ContentStreamLoader.java
@@ -19,7 +19,7 @@ package org.apache.solr.handler;
 
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 
 /**
diff --git a/src/java/org/apache/solr/handler/DumpRequestHandler.java b/src/java/org/apache/solr/handler/DumpRequestHandler.java
index 37766a4..9f94e56 100644
--- a/src/java/org/apache/solr/handler/DumpRequestHandler.java
+++ b/src/java/org/apache/solr/handler/DumpRequestHandler.java
@@ -25,7 +25,7 @@ import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 public class DumpRequestHandler extends RequestHandlerBase
 {
diff --git a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
index ae765a5..e24dfc6 100644
--- a/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
+++ b/src/java/org/apache/solr/handler/MoreLikeThisHandler.java
@@ -51,7 +51,7 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SimpleFacets;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.DocIterator;
diff --git a/src/java/org/apache/solr/handler/PingRequestHandler.java b/src/java/org/apache/solr/handler/PingRequestHandler.java
index 1a5c93d..bb5aed0 100644
--- a/src/java/org/apache/solr/handler/PingRequestHandler.java
+++ b/src/java/org/apache/solr/handler/PingRequestHandler.java
@@ -24,8 +24,8 @@ import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 
 
 /**
diff --git a/src/java/org/apache/solr/handler/ReplicationHandler.java b/src/java/org/apache/solr/handler/ReplicationHandler.java
index e54cd8b..9c805f0 100644
--- a/src/java/org/apache/solr/handler/ReplicationHandler.java
+++ b/src/java/org/apache/solr/handler/ReplicationHandler.java
@@ -26,9 +26,9 @@ import org.apache.solr.common.util.FastOutputStream;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.*;
-import org.apache.solr.request.BinaryQueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.BinaryQueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.update.DirectUpdateHandler2;
 import org.apache.solr.util.RefCounted;
diff --git a/src/java/org/apache/solr/handler/RequestHandlerBase.java b/src/java/org/apache/solr/handler/RequestHandlerBase.java
index 0c7d5b9..c0e312a 100644
--- a/src/java/org/apache/solr/handler/RequestHandlerBase.java
+++ b/src/java/org/apache/solr/handler/RequestHandlerBase.java
@@ -25,8 +25,8 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.DocSet;
 import org.apache.solr.util.SolrPluginUtils;
 import org.apache.lucene.queryParser.ParseException;
@@ -85,8 +85,8 @@ public abstract class RequestHandlerBase implements SolrRequestHandler, SolrInfo
    *
    * @param args The {@link org.apache.solr.common.util.NamedList} to initialize from
    *
-   * @see #handleRequest(org.apache.solr.request.SolrQueryRequest, org.apache.solr.request.SolrQueryResponse)
-   * @see #handleRequestBody(org.apache.solr.request.SolrQueryRequest, org.apache.solr.request.SolrQueryResponse)
+   * @see #handleRequest(org.apache.solr.request.SolrQueryRequest, org.apache.solr.response.SolrQueryResponse)
+   * @see #handleRequestBody(org.apache.solr.request.SolrQueryRequest, org.apache.solr.response.SolrQueryResponse)
    * @see org.apache.solr.util.SolrPluginUtils#setDefaults(org.apache.solr.request.SolrQueryRequest, org.apache.solr.common.params.SolrParams, org.apache.solr.common.params.SolrParams, org.apache.solr.common.params.SolrParams)
    * @see SolrParams#toSolrParams(org.apache.solr.common.util.NamedList)
    *
diff --git a/src/java/org/apache/solr/handler/RequestHandlerUtils.java b/src/java/org/apache/solr/handler/RequestHandlerUtils.java
index 6204c9d..0ec141f 100755
--- a/src/java/org/apache/solr/handler/RequestHandlerUtils.java
+++ b/src/java/org/apache/solr/handler/RequestHandlerUtils.java
@@ -24,7 +24,7 @@ import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.RollbackUpdateCommand;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
diff --git a/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java b/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
index e186caa..a8d9462 100644
--- a/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
+++ b/src/java/org/apache/solr/handler/SpellCheckerRequestHandler.java
@@ -26,7 +26,7 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
diff --git a/src/java/org/apache/solr/handler/XMLLoader.java b/src/java/org/apache/solr/handler/XMLLoader.java
index efd73ec..e94f96f 100644
--- a/src/java/org/apache/solr/handler/XMLLoader.java
+++ b/src/java/org/apache/solr/handler/XMLLoader.java
@@ -22,7 +22,7 @@ import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.RollbackUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.common.SolrException;
diff --git a/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java b/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
index c8183f2..73ee16c 100644
--- a/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
+++ b/src/java/org/apache/solr/handler/XmlUpdateRequestHandler.java
@@ -25,7 +25,7 @@ import org.apache.solr.common.util.XML;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequestBase;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
 import org.slf4j.Logger;
diff --git a/src/java/org/apache/solr/handler/admin/AdminHandlers.java b/src/java/org/apache/solr/handler/admin/AdminHandlers.java
index a017772..bb1a87c 100644
--- a/src/java/org/apache/solr/handler/admin/AdminHandlers.java
+++ b/src/java/org/apache/solr/handler/admin/AdminHandlers.java
@@ -24,8 +24,8 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
 /**
diff --git a/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java b/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
index 1c79d85..bc7ec92 100644
--- a/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
+++ b/src/java/org/apache/solr/handler/admin/CoreAdminHandler.java
@@ -30,8 +30,8 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.DirectoryFactory;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.util.RefCounted;
 import org.apache.solr.update.MergeIndexesCommand;
diff --git a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
index b4b521b..f7b74e9 100644
--- a/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
@@ -57,7 +57,7 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.Base64;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
diff --git a/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java b/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
index e345439..6921d75 100644
--- a/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
+++ b/src/java/org/apache/solr/handler/admin/PluginInfoHandler.java
@@ -28,7 +28,7 @@ import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * similar to "admin/registry.jsp" 
diff --git a/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java b/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
index 4bb1199..12ee354 100644
--- a/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/PropertiesRequestHandler.java
@@ -22,7 +22,7 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * @version $Id$
diff --git a/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java b/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java
index 1b75469..50cc92f 100644
--- a/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java
+++ b/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java
@@ -36,9 +36,9 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
-import org.apache.solr.request.RawResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.RawResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * This handler uses the RawResponseWriter to give client access to
diff --git a/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java b/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
index e43d065..078a75e 100644
--- a/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
+++ b/src/java/org/apache/solr/handler/admin/SystemInfoHandler.java
@@ -37,7 +37,7 @@ import org.apache.solr.common.util.XML;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java b/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
index b6d4be1..280b123 100644
--- a/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
+++ b/src/java/org/apache/solr/handler/admin/ThreadDumpHandler.java
@@ -27,7 +27,7 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.RequestHandlerUtils;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * Copied from "admin/threaddump.jsp"
diff --git a/src/java/org/apache/solr/handler/component/QueryComponent.java b/src/java/org/apache/solr/handler/component/QueryComponent.java
index 4cda38e..8e9bd48 100644
--- a/src/java/org/apache/solr/handler/component/QueryComponent.java
+++ b/src/java/org/apache/solr/handler/component/QueryComponent.java
@@ -34,7 +34,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.FieldType;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.*;
diff --git a/src/java/org/apache/solr/handler/component/ResponseBuilder.java b/src/java/org/apache/solr/handler/component/ResponseBuilder.java
index 00964a4..bd9a36e 100644
--- a/src/java/org/apache/solr/handler/component/ResponseBuilder.java
+++ b/src/java/org/apache/solr/handler/component/ResponseBuilder.java
@@ -23,7 +23,7 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.RTimer;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.DocListAndSet;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SortSpec;
diff --git a/src/java/org/apache/solr/handler/component/SearchComponent.java b/src/java/org/apache/solr/handler/component/SearchComponent.java
index fbb09cc..db4036a 100644
--- a/src/java/org/apache/solr/handler/component/SearchComponent.java
+++ b/src/java/org/apache/solr/handler/component/SearchComponent.java
@@ -25,7 +25,7 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrInfoMBean;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
 
 /**
diff --git a/src/java/org/apache/solr/handler/component/SearchHandler.java b/src/java/org/apache/solr/handler/component/SearchHandler.java
index ccbf904..cbb7f97 100644
--- a/src/java/org/apache/solr/handler/component/SearchHandler.java
+++ b/src/java/org/apache/solr/handler/component/SearchHandler.java
@@ -26,7 +26,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.ShardParams;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.SolrRequest;
 import org.apache.solr.client.solrj.SolrResponse;
diff --git a/src/java/org/apache/solr/request/BaseResponseWriter.java b/src/java/org/apache/solr/request/BaseResponseWriter.java
deleted file mode 100644
index bc9ec04..0000000
--- a/src/java/org/apache/solr/request/BaseResponseWriter.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.search.DocList;
-import org.apache.solr.search.SolrIndexSearcher;
-import org.apache.solr.search.DocIterator;
-import org.apache.solr.schema.FieldType;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.schema.SchemaField;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.Set;
-import java.util.ArrayList;
-
-/**
- * 
- * 
- * This class serves as a basis from which {@link QueryResponseWriter}s can be
- * developed. The class provides a single method
- * {@link #write(SingleResponseWriter, SolrQueryRequest, SolrQueryResponse)}
- * that allows users to implement a {@link SingleResponseWriter} sub-class which
- * defines how to output {@link SolrInputDocument}s or a
- * {@link SolrDocumentList}.
- * 
- * @version $Id$
- * @since 1.5
- * 
- */
-public abstract class BaseResponseWriter {
-
-  private static final Logger LOG = LoggerFactory
-      .getLogger(BaseResponseWriter.class);
-
-  private static final String SCORE_FIELD = "score";
-
-  /**
-   * 
-   * The main method that allows users to write {@link SingleResponseWriter}s
-   * and provide them as the initial parameter <code>responseWriter</code> to
-   * this method which defines how output should be generated.
-   * 
-   * @param responseWriter
-   *          The user-provided {@link SingleResponseWriter} implementation.
-   * @param request
-   *          The provided {@link SolrQueryRequest}.
-   * @param response
-   *          The provided {@link SolrQueryResponse}.
-   * @throws IOException
-   *           If any error occurs.
-   */
-  public void write(SingleResponseWriter responseWriter,
-      SolrQueryRequest request, SolrQueryResponse response) throws IOException {
-    responseWriter.start();
-    NamedList nl = response.getValues();
-    for (int i = 0; i < nl.size(); i++) {
-      String name = nl.getName(i);
-      Object val = nl.getVal(i);
-      if ("responseHeader".equals(name)) {
-        Boolean omitHeader = request.getParams().getBool(CommonParams.OMIT_HEADER);
-        if (omitHeader == null || !omitHeader) responseWriter.writeResponseHeader((NamedList) val);
-      } else if (val instanceof SolrDocumentList) {
-        SolrDocumentList list = (SolrDocumentList) val;
-        DocListInfo info = new DocListInfo((int)list.getNumFound(), list.size(), (int)list.getStart(), list.getMaxScore());
-        if (responseWriter.isStreamingDocs()) {
-          responseWriter.startDocumentList(name,info);
-          for (SolrDocument solrDocument : list)
-            responseWriter.writeDoc(solrDocument);
-          responseWriter.endDocumentList();
-        } else {
-          responseWriter.writeAllDocs(info, list);
-        }
-      } else if (val instanceof DocList) {
-        DocList docList = (DocList) val;
-        int sz = docList.size();
-        IdxInfo idxInfo = new IdxInfo(request.getSchema(), request
-            .getSearcher(), response.getReturnFields());
-        DocListInfo info = new DocListInfo(docList.matches(), docList.size(),docList.offset(),
-            docList.maxScore());
-        DocIterator iterator = docList.iterator();
-        if (responseWriter.isStreamingDocs()) {
-          responseWriter.startDocumentList(name,info);
-          for (int j = 0; j < sz; j++) {
-            SolrDocument sdoc = getDoc(iterator.nextDoc(), idxInfo);
-            if (idxInfo.includeScore && docList.hasScores()) {
-              sdoc.addField(SCORE_FIELD, iterator.score());
-            }
-            responseWriter.writeDoc(sdoc);
-          }
-          responseWriter.end();
-        } else {
-          ArrayList<SolrDocument> list = new ArrayList<SolrDocument>(docList
-              .size());
-          for (int j = 0; j < sz; j++) {
-            SolrDocument sdoc = getDoc(iterator.nextDoc(), idxInfo);
-            if (idxInfo.includeScore && docList.hasScores()) {
-              sdoc.addField(SCORE_FIELD, iterator.score());
-            }
-          }
-          responseWriter.writeAllDocs(info, list);
-        }
-
-      } else {
-        responseWriter.writeOther(name, val);
-
-      }
-    }
-    responseWriter.end();
-
-  }
-
-  /**No ops implementation so that the implementing classes do not have to do it
-   */
-  public void init(NamedList args){}
-
-  private static class IdxInfo {
-    IndexSchema schema;
-    SolrIndexSearcher searcher;
-    Set<String> returnFields;
-    boolean includeScore;
-
-    private IdxInfo(IndexSchema schema, SolrIndexSearcher searcher,
-        Set<String> returnFields) {
-      this.schema = schema;
-      this.searcher = searcher;
-      this.includeScore = returnFields != null
-              && returnFields.contains(SCORE_FIELD);
-      if (returnFields != null) {
-        if (returnFields.size() == 0 || (returnFields.size() == 1 && includeScore) || returnFields.contains("*")) {
-          returnFields = null;  // null means return all stored fields
-        }
-      }
-      this.returnFields = returnFields;
-
-    }
-  }
-
-  private static SolrDocument getDoc(int id, IdxInfo info) throws IOException {
-    Document doc = info.searcher.doc(id);
-    SolrDocument solrDoc = new SolrDocument();
-    for (Fieldable f : (List<Fieldable>) doc.getFields()) {
-      String fieldName = f.name();
-      if (info.returnFields != null && !info.returnFields.contains(fieldName))
-        continue;
-      SchemaField sf = info.schema.getFieldOrNull(fieldName);
-      FieldType ft = null;
-      if (sf != null) ft = sf.getType();
-      Object val = null;
-      if (ft == null) { // handle fields not in the schema
-        if (f.isBinary())
-          val = f.binaryValue();
-        else
-          val = f.stringValue();
-      } else {
-        try {
-          if (BinaryResponseWriter.KNOWN_TYPES.contains(ft.getClass())) {
-            val = ft.toObject(f);
-          } else {
-            val = ft.toExternal(f);
-          }
-        } catch (Exception e) {
-          // There is a chance of the underlying field not really matching the
-          // actual field type . So ,it can throw exception
-          LOG.warn("Error reading a field from document : " + solrDoc, e);
-          // if it happens log it and continue
-          continue;
-        }
-      }
-      if (sf != null && sf.multiValued() && !solrDoc.containsKey(fieldName)) {
-        ArrayList l = new ArrayList();
-        l.add(val);
-        solrDoc.addField(fieldName, l);
-      } else {
-        solrDoc.addField(fieldName, val);
-      }
-    }
-
-    return solrDoc;
-  }
-
-  public static class DocListInfo {
-    public final int numFound;
-    public final int start ;
-    public Float maxScore = null;
-    public final int size;
-
-    public DocListInfo(int numFound, int sz,int start, Float maxScore) {
-      this.numFound = numFound;
-      size = sz;
-      this.start = start;
-      this.maxScore = maxScore;
-    }
-  }
-
-  /**
-   * 
-   * Users wanting to define custom {@link QueryResponseWriter}s that deal with
-   * {@link SolrInputDocument}s and {@link SolrDocumentList} should override the
-   * methods for this class. All the methods are w/o body because the user is left
-   * to choose which all methods are required for his purpose
-   */
-  public static abstract class SingleResponseWriter {
-
-    /**
-     * This method is called at the start of the {@link QueryResponseWriter}
-     * output. Override this method if you want to provide a header for your
-     * output, e.g., XML headers, etc.
-     * 
-     * @throws IOException
-     *           if any error occurs.
-     */
-    public void start() throws IOException { }
-
-    /**
-     * This method is called at the start of processing a
-     * {@link SolrDocumentList}. Those that override this method are provided
-     * with {@link DocListInfo} object to use to inspect the output
-     * {@link SolrDocumentList}.
-     * 
-     * @param info Information about the {@link SolrDocumentList} to output.
-     */
-    public void startDocumentList(String name, DocListInfo info) throws IOException { }
-
-    /**
-     * This method writes out a {@link SolrDocument}, on a doc-by-doc basis.
-     * This method is only called when {@link #isStreamingDocs()} returns true.
-     * 
-     * @param solrDocument
-     *          The doc-by-doc {@link SolrDocument} to transform into output as
-     *          part of this {@link QueryResponseWriter}.
-     */
-    public void writeDoc(SolrDocument solrDocument) throws IOException { }
-
-    /**
-     * This method is called at the end of outputting a {@link SolrDocumentList}
-     * or on a doc-by-doc {@link SolrDocument} basis.
-     */
-    public void endDocumentList() throws IOException { } 
-    /**
-     * This method defines how to output the {@link SolrQueryResponse} header
-     * which is provided as a {@link NamedList} parameter.
-     * 
-     * @param responseHeader
-     *          The response header to output.
-     */
-    public void writeResponseHeader(NamedList responseHeader) throws IOException { }
-
-    /**
-     * This method is called at the end of the {@link QueryResponseWriter}
-     * lifecycle. Implement this method to add a footer to your output, e.g., in
-     * the case of XML, the outer tag for your tag set, etc.
-     * 
-     * @throws IOException
-     *           If any error occurs.
-     */
-    public void end() throws IOException { }
-
-    /**
-     * Define this method to control how output is written by this
-     * {@link QueryResponseWriter} if the output is not a
-     * {@link SolrInputDocument} or a {@link SolrDocumentList}.
-     * 
-     * @param name
-     *          The name of the object to output.
-     * @param other
-     *          The object to output.
-     * @throws IOException
-     *           If any error occurs.
-     */
-    public void writeOther(String name, Object other) throws IOException { }
-
-    /**
-     * Overriding this method to return false forces all
-     * {@link SolrInputDocument}s to be spit out as a {@link SolrDocumentList}
-     * so they can be processed as a whole, rather than on a doc-by-doc basis.
-     * If set to false, this method calls
-     * {@link #writeAllDocs(DocListInfo, List)}, else if set to true, then this
-     * method forces calling {@link #writeDoc(SolrDocument)} on a doc-by-doc
-     * basis. one
-     * 
-     * @return True to force {@link #writeDoc(SolrDocument)} to be called, False
-     *         to force {@link #writeAllDocs(DocListInfo, List)} to be called.
-     */
-    public boolean isStreamingDocs() { return true; }
-
-    /**
-     * Writes out all {@link SolrInputDocument}s . This is invoked only if
-     * {@link #isStreamingDocs()} returns false.
-     * 
-     * @param info
-     *          Information about the {@link List} of {@link SolrDocument}s to
-     *          output.
-     * @param allDocs
-     *          A {@link List} of {@link SolrDocument}s to output.
-     * @throws IOException
-     *           If any error occurs.
-     */
-    public void writeAllDocs(DocListInfo info, List<SolrDocument> allDocs) throws IOException { }
-
-  }
-
-}
diff --git a/src/java/org/apache/solr/request/BinaryQueryResponseWriter.java b/src/java/org/apache/solr/request/BinaryQueryResponseWriter.java
deleted file mode 100755
index ab8ffa4..0000000
--- a/src/java/org/apache/solr/request/BinaryQueryResponseWriter.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.apache.solr.request;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.io.Writer;
-import java.io.OutputStream;
-import java.io.IOException;
-
-/**
- * Implementations of <code>BinaryQueryResponseWriter</code> are used to
- * write response in binary format
- * Functionality is exactly same as its parent class <code>QueryResponseWriter</code
- * But it may not implement the <code>write(Writer writer, SolrQueryRequest request, SolrQueryResponse response)</code>
- * method  
- *
- */
-public interface BinaryQueryResponseWriter extends QueryResponseWriter{
-
-    /**Use it to write the reponse in a binary format
-     */
-    public void write(OutputStream out, SolrQueryRequest request, SolrQueryResponse response) throws IOException;
-}
diff --git a/src/java/org/apache/solr/request/BinaryResponseWriter.java b/src/java/org/apache/solr/request/BinaryResponseWriter.java
deleted file mode 100755
index ea0c2cc..0000000
--- a/src/java/org/apache/solr/request/BinaryResponseWriter.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.request;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.JavaBinCodec;
-import org.apache.solr.schema.*;
-import org.apache.solr.search.DocIterator;
-import org.apache.solr.search.DocList;
-import org.apache.solr.search.SolrIndexSearcher;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.*;
-import java.util.*;
-
-
-public class BinaryResponseWriter implements BinaryQueryResponseWriter {
-  private static final Logger LOG = LoggerFactory.getLogger(BinaryResponseWriter.class);
-  public static final Set<Class> KNOWN_TYPES = new HashSet<Class>();
-
-  public void write(OutputStream out, SolrQueryRequest req, SolrQueryResponse response) throws IOException {
-    Resolver resolver = new Resolver(req, response.getReturnFields());
-    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
-    if (omitHeader != null && omitHeader) response.getValues().remove("responseHeader");
-    JavaBinCodec codec = new JavaBinCodec(resolver);
-    codec.marshal(response.getValues(), out);
-  }
-
-  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
-    throw new RuntimeException("This is a binary writer , Cannot write to a characterstream");
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return "application/octet-stream";
-  }
-
-  public void init(NamedList args) {
-    /* NOOP */
-  }
-
-  private static class Resolver implements JavaBinCodec.ObjectResolver {
-    private final SolrQueryRequest solrQueryRequest;
-    private IndexSchema schema;
-    private SolrIndexSearcher searcher;
-    private final Set<String> returnFields;
-    private final boolean includeScore;
-
-    // transmit field values using FieldType.toObject()
-    // rather than the String from FieldType.toExternal()
-    boolean useFieldObjects = true;
-
-    public Resolver(SolrQueryRequest req, Set<String> returnFields) {
-      solrQueryRequest = req;
-      this.includeScore = returnFields != null && returnFields.contains("score");
-
-      if (returnFields != null) {
-        if (returnFields.size() == 0 || (returnFields.size() == 1 && includeScore) || returnFields.contains("*")) {
-          returnFields = null;  // null means return all stored fields
-        }
-      }
-      this.returnFields = returnFields;
-    }
-
-    public Object resolve(Object o, JavaBinCodec codec) throws IOException {
-      if (o instanceof DocList) {
-        writeDocList((DocList) o, codec);
-        return null; // null means we completely handled it
-      }
-      if (o instanceof SolrDocument) {
-        SolrDocument solrDocument = (SolrDocument) o;
-        codec.writeSolrDocument(solrDocument, returnFields);
-        return null;
-      }
-      if (o instanceof Document) {
-        return getDoc((Document) o);
-      }
-
-      return o;
-    }
-
-    public void writeDocList(DocList ids, JavaBinCodec codec) throws IOException {
-      codec.writeTag(JavaBinCodec.SOLRDOCLST);
-      List l = new ArrayList(3);
-      l.add((long) ids.matches());
-      l.add((long) ids.offset());
-      Float maxScore = null;
-      if (includeScore && ids.hasScores()) {
-        maxScore = ids.maxScore();
-      }
-      l.add(maxScore);
-      codec.writeArray(l);
-
-      int sz = ids.size();
-      codec.writeTag(JavaBinCodec.ARR, sz);
-      if(searcher == null) searcher = solrQueryRequest.getSearcher();
-      if(schema == null) schema = solrQueryRequest.getSchema(); 
-      DocIterator iterator = ids.iterator();
-      for (int i = 0; i < sz; i++) {
-        int id = iterator.nextDoc();
-        Document doc = searcher.doc(id, returnFields);
-
-        SolrDocument sdoc = getDoc(doc);
-
-        if (includeScore && ids.hasScores()) {
-          sdoc.addField("score", iterator.score());
-        }
-
-        codec.writeSolrDocument(sdoc);
-      }
-    }
-
-
-    public SolrDocument getDoc(Document doc) {
-      SolrDocument solrDoc = new SolrDocument();
-      for (Fieldable f : (List<Fieldable>) doc.getFields()) {
-        String fieldName = f.name();
-        if (returnFields != null && !returnFields.contains(fieldName)) continue;
-        SchemaField sf = schema.getFieldOrNull(fieldName);
-        FieldType ft = null;
-        if(sf != null) ft =sf.getType();
-        Object val;
-        if (ft == null) {  // handle fields not in the schema
-          if (f.isBinary()) val = f.binaryValue();
-          else val = f.stringValue();
-        } else {
-          try {
-            if (useFieldObjects && KNOWN_TYPES.contains(ft.getClass())) {
-              val = ft.toObject(f);
-            } else {
-              val = ft.toExternal(f);
-            }
-          } catch (Exception e) {
-            // There is a chance of the underlying field not really matching the
-            // actual field type . So ,it can throw exception
-            LOG.warn("Error reading a field from document : " + solrDoc, e);
-            //if it happens log it and continue
-            continue;
-          }
-        }
-        if(sf != null && sf.multiValued() && !solrDoc.containsKey(fieldName)){
-          ArrayList l = new ArrayList();
-          l.add(val);
-          solrDoc.addField(fieldName, l);
-        } else {
-          solrDoc.addField(fieldName, val);
-        }
-      }
-      return solrDoc;
-    }
-
-  }
-
-
-  /**
-   * TODO -- there may be a way to do this without marshal at all...
-   *
-   * @param req
-   * @param rsp
-   *
-   * @return a response object equivalent to what you get from the XML/JSON/javabin parser. Documents become
-   *         SolrDocuments, DocList becomes SolrDocumentList etc.
-   *
-   * @since solr 1.4
-   */
-  @SuppressWarnings("unchecked")
-  public static NamedList<Object> getParsedResponse(SolrQueryRequest req, SolrQueryResponse rsp) {
-    try {
-      Resolver resolver = new Resolver(req, rsp.getReturnFields());
-
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      new JavaBinCodec(resolver).marshal(rsp.getValues(), out);
-
-      InputStream in = new ByteArrayInputStream(out.toByteArray());
-      return (NamedList<Object>) new JavaBinCodec(resolver).unmarshal(in);
-    }
-    catch (Exception ex) {
-      throw new RuntimeException(ex);
-    }
-  }
-
-  static {
-    KNOWN_TYPES.add(BoolField.class);
-    KNOWN_TYPES.add(BCDIntField.class);
-    KNOWN_TYPES.add(BCDLongField.class);
-    KNOWN_TYPES.add(BCDStrField.class);
-    KNOWN_TYPES.add(ByteField.class);
-    KNOWN_TYPES.add(DateField.class);
-    KNOWN_TYPES.add(DoubleField.class);
-    KNOWN_TYPES.add(FloatField.class);
-    KNOWN_TYPES.add(ShortField.class);
-    KNOWN_TYPES.add(IntField.class);
-    KNOWN_TYPES.add(LongField.class);
-    KNOWN_TYPES.add(SortableLongField.class);
-    KNOWN_TYPES.add(SortableIntField.class);
-    KNOWN_TYPES.add(SortableFloatField.class);
-    KNOWN_TYPES.add(SortableDoubleField.class);
-    KNOWN_TYPES.add(StrField.class);
-    KNOWN_TYPES.add(TextField.class);
-    KNOWN_TYPES.add(TrieField.class);
-    KNOWN_TYPES.add(TrieIntField.class);
-    KNOWN_TYPES.add(TrieLongField.class);
-    KNOWN_TYPES.add(TrieFloatField.class);
-    KNOWN_TYPES.add(TrieDoubleField.class);
-    KNOWN_TYPES.add(TrieDateField.class);
-    KNOWN_TYPES.add(BinaryField.class);
-    // We do not add UUIDField because UUID object is not a supported type in JavaBinCodec
-    // and if we write UUIDField.toObject, we wouldn't know how to handle it in the client side
-  }
-}
diff --git a/src/java/org/apache/solr/request/GenericBinaryResponseWriter.java b/src/java/org/apache/solr/request/GenericBinaryResponseWriter.java
deleted file mode 100644
index 2e880b6..0000000
--- a/src/java/org/apache/solr/request/GenericBinaryResponseWriter.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.OutputStream;
-import java.io.IOException;
-import java.io.Writer;
-
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrInputDocument;
-
-/**
- * 
- * 
- * A generic {@link QueryResponseWriter} implementation that requires a user to
- * implement the
- * {@link #getSingleResponseWriter(OutputStream, SolrQueryRequest, SolrQueryResponse)}
- * that defines a {@link SingleResponseWriter} to handle the binary output.
- * 
- * @since 1.5
- * @version $Id$
- * 
- */
-public abstract class GenericBinaryResponseWriter extends BaseResponseWriter
-    implements BinaryQueryResponseWriter {
-
-  /**
-   * 
-   * Writes the binary output data using the {@link SingleResponseWriter}
-   * provided by a call to
-   * {@link #getSingleResponseWriter(OutputStream, SolrQueryRequest, SolrQueryResponse)}
-   * .
-   * 
-   * @param out
-   *          The {@link OutputStream} to write the binary data to.
-   * @param request
-   *          The provided {@link SolrQueryRequest}.
-   * @param response
-   *          The provided {@link SolrQueryResponse}.
-   */
-  public void write(OutputStream out, SolrQueryRequest request,
-      SolrQueryResponse response) throws IOException {
-    super.write(getSingleResponseWriter(out, request, response), request,
-        response);
-  }
-
-  /**
-   * Users of this class should implement this method to define a
-   * {@link SingleResponseWriter} responsible for writing the binary output
-   * given a {@link SolrDocumentList} or doc-by-doc, given a
-   * {@link SolrInputDocument}.
-   * 
-   * @param out
-   *          The {@link OutputStream} to write the binary data response to.
-   * @param request
-   *          The provided {@link SolrQueryRequest}.
-   * @param response
-   *          The provided {@link SolrQueryResponse}.
-   * @return A {@link SingleResponseWriter} that will be used to generate the
-   *         response output from this {@link QueryResponseWriter}.
-   */
-  public abstract SingleResponseWriter getSingleResponseWriter(
-      OutputStream out, SolrQueryRequest request, SolrQueryResponse response);
-
-  /**Just to throw Exception So that the eimplementing classes do not have to do the  same
-   */
-  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
-    throw new RuntimeException("This is a binary writer , Cannot write to a characterstream");
-  }
-}
diff --git a/src/java/org/apache/solr/request/GenericTextResponseWriter.java b/src/java/org/apache/solr/request/GenericTextResponseWriter.java
deleted file mode 100644
index 1c835fe..0000000
--- a/src/java/org/apache/solr/request/GenericTextResponseWriter.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrInputDocument;
-
-/**
- * 
- * 
- * A generic {@link QueryResponseWriter} implementation that requires a user to
- * implement the
- * {@link #getSingleResponseWriter(Writer, SolrQueryRequest, SolrQueryResponse)}
- * that defines a {@link SingleResponseWriter} to handle plain ol' text output.
- * 
- * @since 1.5
- * @version $Id$
- * 
- */
-public abstract class GenericTextResponseWriter extends BaseResponseWriter
-    implements QueryResponseWriter {
-
-  /**
-   * 
-   * Writes text output using the {@link SingleResponseWriter} provided by a
-   * call to
-   * {@link #getSingleResponseWriter(Writer, SolrQueryRequest, SolrQueryResponse)}
-   * .
-   * 
-   * @param out
-   *          The {@link Writer} to write the text output to.
-   * @param request
-   *          The provided {@link SolrQueryRequest}.
-   * @param response
-   *          The provided {@link SolrQueryResponse}.
-   */
-  public void write(Writer writer, SolrQueryRequest request,
-      SolrQueryResponse response) throws IOException {
-    super.write(getSingleResponseWriter(writer, request, response), request,
-        response);
-  }
-
-  /**
-   * Users of this class should implement this method to define a
-   * {@link SingleResponseWriter} responsible for writing text output given a
-   * {@link SolrDocumentList} or doc-by-doc, given a {@link SolrInputDocument}.
-   * 
-   * @param writer
-   *          The {@link Writer} to write the text data response to.
-   * @param request
-   *          The provided {@link SolrQueryRequest}.
-   * @param response
-   *          The provided {@link SolrQueryResponse}.
-   * @return A {@link SingleResponseWriter} that will be used to generate the
-   *         response output from this {@link QueryResponseWriter}.
-   */
-  protected abstract SingleResponseWriter getSingleResponseWriter(
-      Writer writer, SolrQueryRequest request, SolrQueryResponse response);
-}
diff --git a/src/java/org/apache/solr/request/JSONResponseWriter.java b/src/java/org/apache/solr/request/JSONResponseWriter.java
deleted file mode 100644
index c2a2569..0000000
--- a/src/java/org/apache/solr/request/JSONResponseWriter.java
+++ /dev/null
@@ -1,845 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
-import org.apache.lucene.util.StringHelper;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-import org.apache.solr.schema.SchemaField;
-import org.apache.solr.schema.TextField;
-import org.apache.solr.search.DocIterator;
-import org.apache.solr.search.DocList;
-import org.apache.solr.search.SolrIndexSearcher;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.*;
-
-/**
- * @version $Id$
- */
-
-public class JSONResponseWriter implements QueryResponseWriter {
-  static String CONTENT_TYPE_JSON_UTF8="text/x-json; charset=UTF-8";
-
-  public void init(NamedList n) {
-  }
-
-  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    JSONWriter w = new JSONWriter(writer, req, rsp);
-    try {
-      w.writeResponse();
-    } finally {
-      w.close();
-    }
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    // using the text/plain allows this to be viewed in the browser easily
-    return CONTENT_TYPE_TEXT_UTF8;
-  }
-}
-
-
-class JSONWriter extends TextResponseWriter {
-
-  // cache the calendar instance in case we are writing many dates...
-  private Calendar cal;
-
-  private String namedListStyle;
-  private String wrapperFunction;
-
-  private static final String JSON_NL_STYLE="json.nl";
-  private static final String JSON_NL_MAP="map";
-  private static final String JSON_NL_FLAT="flat";
-  private static final String JSON_NL_ARROFARR="arrarr";
-  private static final String JSON_NL_ARROFMAP="arrmap";
-  private static final String JSON_WRAPPER_FUNCTION="json.wrf";
-
-
-  public JSONWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    super(writer, req, rsp);
-    namedListStyle = StringHelper.intern(req.getParams().get(JSON_NL_STYLE, JSON_NL_FLAT));
-    wrapperFunction = req.getParams().get(JSON_WRAPPER_FUNCTION);
-  }
-
-  public void writeResponse() throws IOException {
-    if(wrapperFunction!=null) {
-        writer.write(wrapperFunction + "(");
-    }
-    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
-    if(omitHeader != null && omitHeader) rsp.getValues().remove("responseHeader");
-    writeNamedList(null, rsp.getValues());
-    if(wrapperFunction!=null) {
-        writer.write(')');
-    }
-  }
-
-  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
-    writeStr(null, fname, needsEscaping);
-    writer.write(':');
-  }
-
-  /** Represents a NamedList directly as a JSON Object (essentially a Map)
-   * Map null to "" and name mangle any repeated keys to avoid repeats in the
-   * output.
-   */
-  protected void writeNamedListAsMapMangled(String name, NamedList val) throws IOException {
-    int sz = val.size();
-    writeMapOpener(sz);
-    incLevel();
-
-    // In JSON objects (maps) we can't have null keys or duplicates...
-    // map null to "" and append a qualifier to duplicates.
-    //
-    // a=123,a=456 will be mapped to {a=1,a__1=456}
-    // Disad: this is ambiguous since a real key could be called a__1
-    //
-    // Another possible mapping could aggregate multiple keys to an array:
-    // a=123,a=456 maps to a=[123,456]
-    // Disad: this is ambiguous with a real single value that happens to be an array
-    //
-    // Both of these mappings have ambiguities.
-    HashMap<String,Integer> repeats = new HashMap<String,Integer>(4);
-
-    boolean first=true;
-    for (int i=0; i<sz; i++) {
-      String key = val.getName(i);
-      if (key==null) key="";
-
-      if (first) {
-        first=false;
-        repeats.put(key,0);
-      } else {
-        writeMapSeparator();
-
-        Integer repeatCount = repeats.get(key);
-        if (repeatCount==null) {
-          repeats.put(key,0);
-        } else {
-          String newKey = key;
-          int newCount = repeatCount;
-          do {  // avoid generated key clashing with a real key
-            newKey = key + ' ' + (++newCount);
-            repeatCount = repeats.get(newKey);
-          } while (repeatCount != null);
-
-          repeats.put(key,newCount);
-          key = newKey;
-        }
-      }
-
-      indent();
-      writeKey(key, true);
-      writeVal(key,val.getVal(i));
-    }
-
-    decLevel();
-    writeMapCloser();
-  }
-
-  /** Represents a NamedList directly as a JSON Object (essentially a Map)
-   * repeating any keys if they are repeated in the NamedList.  null is mapped
-   * to "".
-   */ 
-  protected void writeNamedListAsMapWithDups(String name, NamedList val) throws IOException {
-    int sz = val.size();
-    writeMapOpener(sz);
-    incLevel();
-
-    for (int i=0; i<sz; i++) {
-      if (i!=0) {
-        writeMapSeparator();
-      }
-
-      String key = val.getName(i);
-      if (key==null) key="";
-      indent();
-      writeKey(key, true);
-      writeVal(key,val.getVal(i));
-    }
-
-    decLevel();
-    writeMapCloser();
-  }
-
-  // Represents a NamedList directly as an array of JSON objects...
-  // NamedList("a"=1,"b"=2,null=3) => [{"a":1},{"b":2},3]
-  protected void writeNamedListAsArrMap(String name, NamedList val) throws IOException {
-    int sz = val.size();
-    indent();
-    writeArrayOpener(sz);
-    incLevel();
-
-    boolean first=true;
-    for (int i=0; i<sz; i++) {
-      String key = val.getName(i);
-
-      if (first) {
-        first=false;
-      } else {
-        writeArraySeparator();
-      }
-
-      indent();
-
-      if (key==null) {
-        writeVal(null,val.getVal(i));
-      } else {
-        writeMapOpener(1);
-        writeKey(key, true);
-        writeVal(key,val.getVal(i));
-        writeMapCloser();
-      }
-
-    }
-
-    decLevel();
-    writeArrayCloser();
-  }
-
-  // Represents a NamedList directly as an array of JSON objects...
-  // NamedList("a"=1,"b"=2,null=3) => [["a",1],["b",2],[null,3]]
-  protected void writeNamedListAsArrArr(String name, NamedList val) throws IOException {
-    int sz = val.size();
-    indent();
-    writeArrayOpener(sz);
-    incLevel();
-
-    boolean first=true;
-    for (int i=0; i<sz; i++) {
-      String key = val.getName(i);
-
-      if (first) {
-        first=false;
-      } else {
-        writeArraySeparator();
-      }
-
-      indent();
-
-      /*** if key is null, just write value???
-      if (key==null) {
-        writeVal(null,val.getVal(i));
-      } else {
-     ***/
-
-        writeArrayOpener(1);
-        incLevel();
-        if (key==null) {
-          writeNull(null);
-        } else {
-          writeStr(null, key, true);
-        }
-        writeArraySeparator();
-        writeVal(key,val.getVal(i));
-        decLevel();
-        writeArrayCloser();
-    }
-
-    decLevel();
-    writeArrayCloser();
-  }
-
-  // Represents a NamedList directly as an array with keys/values
-  // interleaved.
-  // NamedList("a"=1,"b"=2,null=3) => ["a",1,"b",2,null,3]
-  protected void writeNamedListAsFlat(String name, NamedList val) throws IOException {
-    int sz = val.size();
-    writeArrayOpener(sz);
-    incLevel();
-
-    for (int i=0; i<sz; i++) {
-      if (i!=0) {
-        writeArraySeparator();
-      }
-      String key = val.getName(i);
-      indent();
-      if (key==null) {
-        writeNull(null);
-      } else {
-        writeStr(null, key, true);
-      }
-      writeArraySeparator();
-      writeVal(key, val.getVal(i));
-    }
-
-    decLevel();
-    writeArrayCloser();
-  }
-
-
-  public void writeNamedList(String name, NamedList val) throws IOException {
-    if (val instanceof SimpleOrderedMap) {
-      writeNamedListAsMapWithDups(name,val);
-    } else if (namedListStyle==JSON_NL_FLAT) {
-      writeNamedListAsFlat(name,val);
-    } else if (namedListStyle==JSON_NL_MAP){
-      writeNamedListAsMapWithDups(name,val);
-    } else if (namedListStyle==JSON_NL_ARROFARR) {
-      writeNamedListAsArrArr(name,val);
-    } else if (namedListStyle==JSON_NL_ARROFMAP) {
-      writeNamedListAsArrMap(name,val);
-    }
-  }
-
-
-  protected static class MultiValueField {
-    final SchemaField sfield;
-    final ArrayList<Fieldable> fields;
-    MultiValueField(SchemaField sfield, Fieldable firstVal) {
-      this.sfield = sfield;
-      this.fields = new ArrayList<Fieldable>(4);
-      this.fields.add(firstVal);
-    }
-  }
-
-  public void writeDoc(String name, Collection<Fieldable> fields, Set<String> returnFields, Map pseudoFields) throws IOException {
-    writeMapOpener(-1); // no trivial way to determine map size
-    incLevel();
-
-    HashMap<String, MultiValueField> multi = new HashMap<String, MultiValueField>();
-
-    boolean first=true;
-
-    for (Fieldable ff : fields) {
-      String fname = ff.name();
-      if (returnFields!=null && !returnFields.contains(fname)) {
-        continue;
-      }
-
-      // if the field is multivalued, it may have other values further on... so
-      // build up a list for each multi-valued field.
-      SchemaField sf = schema.getField(fname);
-      if (sf.multiValued()) {
-        MultiValueField mf = multi.get(fname);
-        if (mf==null) {
-          mf = new MultiValueField(sf, ff);
-          multi.put(fname, mf);
-        } else {
-          mf.fields.add(ff);
-        }
-      } else {
-        // not multi-valued, so write it immediately.
-        if (first) {
-          first=false;
-        } else {
-          writeMapSeparator();
-        }
-        indent();
-        writeKey(fname,true);
-        sf.write(this, fname, ff);
-      }
-    }
-
-    for(MultiValueField mvf : multi.values()) {
-      if (first) {
-        first=false;
-      } else {
-        writeMapSeparator();
-      }
-
-      indent();
-      writeKey(mvf.sfield.getName(), true);
-
-      boolean indentArrElems=false;
-      if (doIndent) {
-        // heuristic... TextField is probably the only field type likely to be long enough
-        // to warrant indenting individual values.
-        indentArrElems = (mvf.sfield.getType() instanceof TextField);
-      }
-
-      writeArrayOpener(-1); // no trivial way to determine array size
-      boolean firstArrElem=true;
-      incLevel();
-
-      for (Fieldable ff : mvf.fields) {
-        if (firstArrElem) {
-          firstArrElem=false;
-        } else {
-          writeArraySeparator();
-        }
-        if (indentArrElems) indent();
-        mvf.sfield.write(this, null, ff);
-      }
-      writeArrayCloser();
-      decLevel();
-    }
-
-    if (pseudoFields !=null && pseudoFields.size()>0) {
-      writeMap(null,pseudoFields,true,first);
-    }
-
-    decLevel();
-    writeMapCloser();
-  }
-
-  public void writeSolrDocument(String name, SolrDocument doc, Set<String> returnFields, Map pseudoFields) throws IOException {
-    writeMapOpener(-1); // no trivial way to determine map size
-    // TODO: could easily figure out size for SolrDocument if needed...
-    incLevel();
-
-    boolean first=true;
-    for (String fname : doc.getFieldNames()) {
-      if (first) {
-        first=false;
-      }
-      else {
-        writeMapSeparator();
-      }
-
-      indent();
-      writeKey(fname, true);
-      Object val = doc.getFieldValue(fname);
-
-      if (val instanceof Collection) {
-        writeVal(fname, val);
-      } else {
-        // if multivalued field, write single value as an array
-        SchemaField sf = schema.getFieldOrNull(fname);
-        if (sf != null && sf.multiValued()) {
-          writeArrayOpener(-1); // no trivial way to determine array size
-          writeVal(fname, val);
-          writeArrayCloser();
-        } else {
-          writeVal(fname, val);
-        }
-      }
-
-      if (pseudoFields !=null && pseudoFields.size()>0) {
-        writeMap(null,pseudoFields,true,first);
-      }
-    }
-
-    decLevel();
-    writeMapCloser();
-  }
-
-
-  // reusable map to store the "score" pseudo-field.
-  // if a Doc can ever contain another doc, this optimization would have to go.
-  private final HashMap scoreMap = new HashMap(1);
-
-  public void writeDoc(String name, Document doc, Set<String> returnFields, float score, boolean includeScore) throws IOException {
-    Map other = null;
-    if (includeScore) {
-      other = scoreMap;
-      scoreMap.put("score",score);
-    }
-    writeDoc(name, (List<Fieldable>)(doc.getFields()), returnFields, other);
-  }
-
-  public void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException {
-    boolean includeScore=false;
-    if (fields!=null) {
-      includeScore = fields.contains("score");
-      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
-        fields=null;  // null means return all stored fields
-      }
-    }
-
-    int sz=ids.size();
-
-    writeMapOpener(includeScore ? 4 : 3);
-    incLevel();
-    writeKey("numFound",false);
-    writeInt(null,ids.matches());
-    writeMapSeparator();
-    writeKey("start",false);
-    writeInt(null,ids.offset());
-
-    if (includeScore) {
-      writeMapSeparator();
-      writeKey("maxScore",false);
-      writeFloat(null,ids.maxScore());
-    }
-    writeMapSeparator();
-    // indent();
-    writeKey("docs",false);
-    writeArrayOpener(sz);
-
-    incLevel();
-    boolean first=true;
-
-    SolrIndexSearcher searcher = req.getSearcher();
-    DocIterator iterator = ids.iterator();
-    for (int i=0; i<sz; i++) {
-      int id = iterator.nextDoc();
-      Document doc = searcher.doc(id, fields);
-
-      if (first) {
-        first=false;
-      } else {
-        writeArraySeparator();
-      }
-      indent();
-      writeDoc(null, doc, fields, (includeScore ? iterator.score() : 0.0f), includeScore);
-    }
-    decLevel();
-    writeArrayCloser();
-
-    if (otherFields !=null) {
-      writeMap(null, otherFields, true, false);
-    }
-
-    decLevel();
-    indent();
-    writeMapCloser();
-  }
-
-
-  @Override
-  public void writeSolrDocumentList(String name, SolrDocumentList docs, Set<String> fields, Map otherFields) throws IOException {
-    boolean includeScore=false;
-    if (fields!=null) {
-      includeScore = fields.contains("score");
-      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
-        fields=null;  // null means return all stored fields
-      }
-    }
-
-    int sz=docs.size();
-
-    writeMapOpener(includeScore ? 4 : 3);
-    incLevel();
-    writeKey("numFound",false);
-    writeLong(null,docs.getNumFound());
-    writeMapSeparator();
-    writeKey("start",false);
-    writeLong(null,docs.getStart());
-
-    if (includeScore && docs.getMaxScore() != null) {
-      writeMapSeparator();
-      writeKey("maxScore",false);
-      writeFloat(null,docs.getMaxScore());
-    }
-    writeMapSeparator();
-    // indent();
-    writeKey("docs",false);
-    writeArrayOpener(sz);
-
-    incLevel();
-    boolean first=true;
-
-    SolrIndexSearcher searcher = req.getSearcher();
-    for (SolrDocument doc : docs) {
-
-      if (first) {
-        first=false;
-      } else {
-        writeArraySeparator();
-      }
-      indent();      
-      writeSolrDocument(null, doc, fields, otherFields);
-    }
-    decLevel();
-    writeArrayCloser();
-
-    if (otherFields !=null) {
-      writeMap(null, otherFields, true, false);
-    }
-
-    decLevel();
-    indent();
-    writeMapCloser();
-  }
-
-
-  //
-  // Data structure tokens
-  // NOTE: a positive size paramater indicates the number of elements
-  //       contained in an array or map, a negative value indicates 
-  //       that the size could not be reliably determined.
-  // 
-  
-  public void writeMapOpener(int size) throws IOException, IllegalArgumentException {
-    writer.write('{');
-  }
-  
-  public void writeMapSeparator() throws IOException {
-    writer.write(',');
-  }
-
-  public void writeMapCloser() throws IOException {
-    writer.write('}');
-  }
-  
-  public void writeArrayOpener(int size) throws IOException, IllegalArgumentException {
-    writer.write('[');
-  }
-  
-  public void writeArraySeparator() throws IOException {
-    writer.write(',');
-  }
-
-  public void writeArrayCloser() throws IOException {
-    writer.write(']');
-  }
-
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    // it might be more efficient to use a stringbuilder or write substrings
-    // if writing chars to the stream is slow.
-    if (needsEscaping) {
-
-
-     /* http://www.ietf.org/internet-drafts/draft-crockford-jsonorg-json-04.txt
-      All Unicode characters may be placed within
-      the quotation marks except for the characters which must be
-      escaped: quotation mark, reverse solidus, and the control
-      characters (U+0000 through U+001F).
-     */
-      writer.write('"');
-
-      for (int i=0; i<val.length(); i++) {
-        char ch = val.charAt(i);
-        if ((ch > '#' && ch != '\\') || ch==' ') { // fast path
-          writer.write(ch);
-          continue;
-        }
-        switch(ch) {
-          case '"':
-          case '\\':
-            writer.write('\\');
-            writer.write(ch);
-            break;
-          case '\r': writer.write('\\'); writer.write('r'); break;
-          case '\n': writer.write('\\'); writer.write('n'); break;
-          case '\t': writer.write('\\'); writer.write('t'); break;
-          case '\b': writer.write('\\'); writer.write('b'); break;
-          case '\f': writer.write('\\'); writer.write('f'); break;
-          // case '/':
-          default: {
-            if (ch <= 0x1F) {
-              unicodeEscape(writer,ch);
-            } else {
-              writer.write(ch);
-            }
-          }
-        }
-      }
-
-      writer.write('"');
-    } else {
-      writer.write('"');
-      writer.write(val);
-      writer.write('"');
-    }
-  }
-
-
-  public void writeMap(String name, Map val, boolean excludeOuter, boolean isFirstVal) throws IOException {
-    if (!excludeOuter) {
-      writeMapOpener(val.size());
-      incLevel();
-      isFirstVal=true;
-    }
-
-    boolean doIndent = excludeOuter || val.size() > 1;
-
-    for (Map.Entry entry : (Set<Map.Entry>)val.entrySet()) {
-      Object e = entry.getKey();
-      String k = e==null ? "" : e.toString();
-      Object v = entry.getValue();
-
-      if (isFirstVal) {
-        isFirstVal=false;
-      } else {
-        writeMapSeparator();
-      }
-
-      if (doIndent) indent();
-      writeKey(k,true);
-      writeVal(k,v);
-    }
-
-    if (!excludeOuter) {
-      decLevel();
-      writeMapCloser();
-    }
-  }
-
-  public void writeArray(String name, Object[] val) throws IOException {
-    writeArray(name, Arrays.asList(val).iterator());
-  }
-
-  public void writeArray(String name, Iterator val) throws IOException {
-    writeArrayOpener(-1); // no trivial way to determine array size
-    incLevel();
-    boolean first=true;
-    while( val.hasNext() ) {
-      if( !first ) indent();
-      writeVal(null, val.next());
-      if( val.hasNext() ) {
-        writeArraySeparator();
-      }
-      first=false;
-    }
-    decLevel();
-    writeArrayCloser();
-  }
-
-  //
-  // Primitive types
-  //
-  public void writeNull(String name) throws IOException {
-    writer.write("null");
-  }
-
-  public void writeInt(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-  public void writeLong(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-  public void writeBool(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-  public void writeFloat(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-  public void writeDouble(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-   @Override
-  public void writeShort(String name, String val) throws IOException {
-    writer.write(val);
-  }
-
-  public void writeByte(String name, String val) throws IOException {
-    writer.write(val);
-
-  }
-
-  // TODO: refactor this out to a DateUtils class or something...
-  public void writeDate(String name, Date val) throws IOException {
-    // using a stringBuilder for numbers can be nice since
-    // a temporary string isn't used (it's added directly to the
-    // builder's buffer.
-
-    StringBuilder sb = new StringBuilder();
-    if (cal==null) cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
-    cal.setTime(val);
-
-    int i = cal.get(Calendar.YEAR);
-    sb.append(i);
-    sb.append('-');
-    i = cal.get(Calendar.MONTH) + 1;  // 0 based, so add 1
-    if (i<10) sb.append('0');
-    sb.append(i);
-    sb.append('-');
-    i=cal.get(Calendar.DAY_OF_MONTH);
-    if (i<10) sb.append('0');
-    sb.append(i);
-    sb.append('T');
-    i=cal.get(Calendar.HOUR_OF_DAY); // 24 hour time format
-    if (i<10) sb.append('0');
-    sb.append(i);
-    sb.append(':');
-    i=cal.get(Calendar.MINUTE);
-    if (i<10) sb.append('0');
-    sb.append(i);
-    sb.append(':');
-    i=cal.get(Calendar.SECOND);
-    if (i<10) sb.append('0');
-    sb.append(i);
-    i=cal.get(Calendar.MILLISECOND);
-    if (i != 0) {
-      sb.append('.');
-      if (i<100) sb.append('0');
-      if (i<10) sb.append('0');
-      sb.append(i);
-
-      // handle canonical format specifying fractional
-      // seconds shall not end in '0'.  Given the slowness of
-      // integer div/mod, simply checking the last character
-      // is probably the fastest way to check.
-      int lastIdx = sb.length()-1;
-      if (sb.charAt(lastIdx)=='0') {
-        lastIdx--;
-        if (sb.charAt(lastIdx)=='0') {
-          lastIdx--;
-        }
-        sb.setLength(lastIdx+1);
-      }
-
-    }
-    sb.append('Z');
-    writeDate(name, sb.toString());
-  }
-
-  public void writeDate(String name, String val) throws IOException {
-    writeStr(name, val, false);
-  }
-
-  private static char[] hexdigits = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
-  protected static void unicodeEscape(Appendable out, int ch) throws IOException {
-    out.append('\\');
-    out.append('u');
-    out.append(hexdigits[(ch>>>12)     ]);
-    out.append(hexdigits[(ch>>>8) & 0xf]);
-    out.append(hexdigits[(ch>>>4) & 0xf]);
-    out.append(hexdigits[(ch)     & 0xf]);
-  }
-
-}
-
-abstract class NaNFloatWriter extends JSONWriter {
-  
-  abstract protected String getNaN();
-  abstract protected String getInf();
-
-  public NaNFloatWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    super(writer, req, rsp);
-  }
-
-  @Override
-  public void writeFloat(String name, float val) throws IOException {
-    if (Float.isNaN(val)) {
-      writer.write(getNaN());
-    } else if (Float.isInfinite(val)) {
-      if (val < 0.0f)
-        writer.write('-');
-      writer.write(getInf());
-    } else {
-      writeFloat(name, Float.toString(val));
-    }
-  }
-
-  @Override
-  public void writeDouble(String name, double val) throws IOException {
-    if (Double.isNaN(val)) {
-      writer.write(getNaN());
-    } else if (Double.isInfinite(val)) {
-      if (val < 0.0)
-        writer.write('-');
-      writer.write(getInf());
-    } else {
-      writeDouble(name, Double.toString(val));
-    }
-  }
-}
diff --git a/src/java/org/apache/solr/request/PHPResponseWriter.java b/src/java/org/apache/solr/request/PHPResponseWriter.java
deleted file mode 100755
index a95ba8e..0000000
--- a/src/java/org/apache/solr/request/PHPResponseWriter.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.util.NamedList;
-
-public class PHPResponseWriter implements QueryResponseWriter {
-  static String CONTENT_TYPE_PHP_UTF8="text/x-php;charset=UTF-8";
-
-  public void init(NamedList n) {
-    /* NOOP */
-  }
-  
- public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    PHPWriter w = new PHPWriter(writer, req, rsp);
-    try {
-      w.writeResponse();
-    } finally {
-      w.close();
-    }
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return CONTENT_TYPE_TEXT_UTF8;
-  }
-}
-
-class PHPWriter extends JSONWriter {
-  public PHPWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    super(writer, req, rsp);
-  }
-  
-  @Override
-  public void writeNamedList(String name, NamedList val) throws IOException {
-    writeNamedListAsMapMangled(name,val);
-  }
-
-  @Override
-  public void writeMapOpener(int size) throws IOException {
-    writer.write("array(");
-  }
-
-  @Override
-  public void writeMapCloser() throws IOException {
-    writer.write(')');
-  }
-
-  @Override
-  public void writeArrayOpener(int size) throws IOException {
-    writer.write("array(");
-  }
-
-  @Override
-  public void writeArrayCloser() throws IOException {
-    writer.write(')');
-  }
-
-  @Override
-  public void writeNull(String name) throws IOException {
-    writer.write("null");
-  }
-
-  @Override
-  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
-    writeStr(null, fname, needsEscaping);
-    writer.write('=');
-    writer.write('>');
-  }
-
-  @Override
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    if (needsEscaping) {
-      writer.write('\'');
-      for (int i=0; i<val.length(); i++) {
-        char ch = val.charAt(i);
-        switch (ch) {
-          case '\'':
-          case '\\': writer.write('\\'); writer.write(ch); break;
-          default:
-            writer.write(ch);
-        }
-      }
-      writer.write('\'');
-    } else {
-      writer.write('\'');
-      writer.write(val);
-      writer.write('\'');
-    }
-  }
-}
diff --git a/src/java/org/apache/solr/request/PHPSerializedResponseWriter.java b/src/java/org/apache/solr/request/PHPSerializedResponseWriter.java
deleted file mode 100755
index 7d1fa3c..0000000
--- a/src/java/org/apache/solr/request/PHPSerializedResponseWriter.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-import java.util.*;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
-import org.apache.lucene.util.UnicodeUtil;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.schema.SchemaField;
-import org.apache.solr.search.DocIterator;
-import org.apache.solr.search.DocList;
-import org.apache.solr.search.SolrIndexSearcher;
-
-/**
- * A description of the PHP serialization format can be found here:
- * http://www.hurring.com/scott/code/perl/serialize/
- *
- * <p>
- * In order to support PHP Serialized strings with a proper byte count, This ResponseWriter
- * must know if the Writers passed to it will result in an output of CESU-8 (UTF-8 w/o support
- * for large code points outside of the BMP)
- * <p>
- * Currently Solr assumes that all Jetty servlet containers (detected using the "jetty.home"
- * system property) use CESU-8 instead of UTF-8 (verified to the current release of 6.1.20).
- * <p>
- * In installations where Solr auto-detects incorrectly, the Solr Administrator should set the
- * "solr.phps.cesu8" system property to either "true" or "false" accordingly.
- */
-public class PHPSerializedResponseWriter implements QueryResponseWriter {
-  static String CONTENT_TYPE_PHP_UTF8="text/x-php-serialized;charset=UTF-8";
-
-  // Is this servlet container's UTF-8 encoding actually CESU-8 (i.e. lacks support for
-  // large characters outside the BMP).
-  boolean CESU8 = false;
-  public void init(NamedList n) {
-    String cesu8Setting = System.getProperty("solr.phps.cesu8");
-    if (cesu8Setting != null) {
-      CESU8="true".equals(cesu8Setting);
-    } else {
-      // guess at the setting.
-      // Jetty up until 6.1.20 at least (and probably versions after) uses CESU8
-      CESU8 = System.getProperty("jetty.home") != null;
-    }
-  }
-  
- public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    PHPSerializedWriter w = new PHPSerializedWriter(writer, req, rsp, CESU8);
-    try {
-      w.writeResponse();
-    } finally {
-      w.close();
-    }
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return CONTENT_TYPE_TEXT_UTF8;
-  }
-}
-
-class PHPSerializedWriter extends JSONWriter {
-  final private boolean CESU8;
-  final UnicodeUtil.UTF8Result utf8;
-
-  public PHPSerializedWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp, boolean CESU8) {
-    super(writer, req, rsp);
-    this.CESU8 = CESU8;
-    this.utf8 = CESU8 ? null : new UnicodeUtil.UTF8Result();
-    // never indent serialized PHP data
-    doIndent = false;
-  }
-
-  public void writeResponse() throws IOException {
-    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
-    if(omitHeader != null && omitHeader) rsp.getValues().remove("responseHeader");
-    writeNamedList(null, rsp.getValues());
-  }
-  
-  @Override
-  public void writeNamedList(String name, NamedList val) throws IOException {
-    writeNamedListAsMapMangled(name,val);
-  }
-  
-  @Override
-  public void writeDoc(String name, Collection<Fieldable> fields, Set<String> returnFields, Map pseudoFields) throws IOException {
-    ArrayList<Fieldable> single = new ArrayList<Fieldable>();
-    HashMap<String, MultiValueField> multi = new HashMap<String, MultiValueField>();
-
-    for (Fieldable ff : fields) {
-      String fname = ff.name();
-      if (returnFields!=null && !returnFields.contains(fname)) {
-        continue;
-      }
-      // if the field is multivalued, it may have other values further on... so
-      // build up a list for each multi-valued field.
-      SchemaField sf = schema.getField(fname);
-      if (sf.multiValued()) {
-        MultiValueField mf = multi.get(fname);
-        if (mf==null) {
-          mf = new MultiValueField(sf, ff);
-          multi.put(fname, mf);
-        } else {
-          mf.fields.add(ff);
-        }
-      } else {
-        single.add(ff);
-      }
-    }
-
-    // obtain number of fields in doc
-    writeArrayOpener(single.size() + multi.size() + ((pseudoFields!=null) ? pseudoFields.size() : 0));
-
-    // output single value fields
-    for(Fieldable ff : single) {
-      SchemaField sf = schema.getField(ff.name());
-      writeKey(ff.name(),true);
-      sf.write(this, ff.name(), ff);
-    }
-    
-    // output multi value fields
-    for(MultiValueField mvf : multi.values()) {
-      writeKey(mvf.sfield.getName(), true);
-      writeArrayOpener(mvf.fields.size());
-      int i = 0;
-      for (Fieldable ff : mvf.fields) {
-        writeKey(i++, false);
-        mvf.sfield.write(this, null, ff);
-      }
-      writeArrayCloser();
-    }
-
-    // output pseudo fields
-    if (pseudoFields !=null && pseudoFields.size()>0) {
-      writeMap(null,pseudoFields,true,false);
-    }
-    writeArrayCloser();
-  }
-  
-  @Override
-  public void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException {
-    boolean includeScore=false;
-    
-    if (fields!=null) {
-      includeScore = fields.contains("score");
-      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
-        fields=null;  // null means return all stored fields
-      }
-    }
-
-    int sz=ids.size();
-
-    writeMapOpener(includeScore ? 4 : 3);
-    writeKey("numFound",false);
-    writeInt(null,ids.matches());
-    writeKey("start",false);
-    writeInt(null,ids.offset());
-
-    if (includeScore) {
-      writeKey("maxScore",false);
-      writeFloat(null,ids.maxScore());
-    }
-    writeKey("docs",false);
-    writeArrayOpener(sz);
-
-    SolrIndexSearcher searcher = req.getSearcher();
-    DocIterator iterator = ids.iterator();
-    for (int i=0; i<sz; i++) {
-      int id = iterator.nextDoc();
-      Document doc = searcher.doc(id, fields);
-      writeKey(i, false);
-      writeDoc(null, doc, fields, (includeScore ? iterator.score() : 0.0f), includeScore);
-    }
-    writeMapCloser();
-
-    if (otherFields !=null) {
-      writeMap(null, otherFields, true, false);
-    }
-
-    writeMapCloser();
-  }
-  
-  @Override
-  public void writeArray(String name, Object[] val) throws IOException {
-    writeMapOpener(val.length);
-    for(int i=0; i < val.length; i++) {
-      writeKey(i, false);
-      writeVal(String.valueOf(i), val[i]);
-    }
-    writeMapCloser();
-  }
-
-  @Override
-  public void writeArray(String name, Iterator val) throws IOException {
-    ArrayList vals = new ArrayList();
-    while( val.hasNext() ) {
-      vals.add(val.next());
-    }
-    writeArray(name, vals.toArray());
-  }
-  
-  @Override
-  public void writeMapOpener(int size) throws IOException, IllegalArgumentException {
-  	// negative size value indicates that something has gone wrong
-  	if (size < 0) {
-  		throw new IllegalArgumentException("Map size must not be negative");
-  	}
-    writer.write("a:"+size+":{");
-  }
-  
-  @Override
-  public void writeMapSeparator() throws IOException {
-    /* NOOP */
-  }
-
-  @Override
-  public void writeMapCloser() throws IOException {
-    writer.write('}');
-  }
-
-  @Override
-  public void writeArrayOpener(int size) throws IOException, IllegalArgumentException {
-  	// negative size value indicates that something has gone wrong
-  	if (size < 0) {
-  		throw new IllegalArgumentException("Array size must not be negative");
-  	}
-    writer.write("a:"+size+":{");
-  }
-
-  @Override  
-  public void writeArraySeparator() throws IOException {
-    /* NOOP */
-  }
-
-  @Override
-  public void writeArrayCloser() throws IOException {
-    writer.write('}');
-  }
-  
-  @Override
-  public void writeNull(String name) throws IOException {
-    writer.write("N;");
-  }
-
-  @Override
-  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
-    writeStr(null, fname, needsEscaping);
-  }
-  void writeKey(int val, boolean needsEscaping) throws IOException {
-    writeInt(null, String.valueOf(val));
-  }
-
-  @Override
-  public void writeBool(String name, boolean val) throws IOException {
-    writer.write(val ? "b:1;" : "b:0;");
-  }
-
-  @Override
-  public void writeBool(String name, String val) throws IOException {
-    writeBool(name, val.charAt(0) == 't');
-  }
-  
-  @Override
-  public void writeInt(String name, String val) throws IOException {
-    writer.write("i:"+val+";");
-  }
-  
-  @Override
-  public void writeLong(String name, String val) throws IOException {
-    writeInt(name,val);
-  }
-
-  @Override
-  public void writeFloat(String name, String val) throws IOException {
-    writeDouble(name,val);
-  }
-
-  @Override
-  public void writeDouble(String name, String val) throws IOException {
-    writer.write("d:"+val+";");
-  }
-
-  @Override
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    // serialized PHP strings don't need to be escaped at all, however the 
-    // string size reported needs be the number of bytes rather than chars.
-    int nBytes;
-    if (CESU8) {
-      nBytes = 0;
-      for (int i=0; i<val.length(); i++) {
-        char ch = val.charAt(i);
-        if (ch<='\u007f') {
-          nBytes += 1;
-        } else if (ch<='\u07ff') {
-          nBytes += 2;
-        } else {
-          nBytes += 3;
-        }
-      }
-    } else {
-      UnicodeUtil.UTF16toUTF8(val, 0, val.length(), utf8);
-      nBytes = utf8.length;
-    }
-
-    writer.write("s:");
-    writer.write(Integer.toString(nBytes));
-    writer.write(":\"");
-    writer.write(val);
-    writer.write("\";");
-  }
-}
diff --git a/src/java/org/apache/solr/request/PythonResponseWriter.java b/src/java/org/apache/solr/request/PythonResponseWriter.java
deleted file mode 100644
index 742e60d..0000000
--- a/src/java/org/apache/solr/request/PythonResponseWriter.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.util.NamedList;
-
-public class PythonResponseWriter implements QueryResponseWriter {
-  static String CONTENT_TYPE_PYTHON_ASCII="text/x-python;charset=US-ASCII";
-
-  public void init(NamedList n) {
-    /* NOOP */
-  }
-  
-  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    PythonWriter w = new PythonWriter(writer, req, rsp);
-    try {
-      w.writeResponse();
-    } finally {
-      w.close();
-    }
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return CONTENT_TYPE_TEXT_ASCII;
-  }
-}
-
-class PythonWriter extends NaNFloatWriter {
-  protected String getNaN() { return "float('NaN')"; }
-  protected String getInf() { return "float('Inf')"; }
-
-  public PythonWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    super(writer, req, rsp);
-  }
-
-  @Override
-  public void writeNull(String name) throws IOException {
-    writer.write("None");
-  }
-
-  @Override
-  public void writeBool(String name, boolean val) throws IOException {
-    writer.write(val ? "True" : "False");
-  }
-
-  @Override
-  public void writeBool(String name, String val) throws IOException {
-    writeBool(name,val.charAt(0)=='t');
-  }
-
-  /* optionally use a unicode python string if necessary */
-  @Override
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    if (!needsEscaping) {
-      writer.write('\'');
-      writer.write(val);
-      writer.write('\'');
-      return;
-    }
-
-    // use python unicode strings...
-    // python doesn't tolerate newlines in strings in it's eval(), so we must escape them.
-
-    StringBuilder sb = new StringBuilder(val.length());
-    boolean needUnicode=false;
-
-    for (int i=0; i<val.length(); i++) {
-      char ch = val.charAt(i);
-      switch(ch) {
-        case '\'':
-        case '\\': sb.append('\\'); sb.append(ch); break;
-        case '\r': sb.append("\\r"); break;
-        case '\n': sb.append("\\n"); break;
-        case '\t': sb.append("\\t"); break;
-        default:
-          // we don't strictly have to escape these chars, but it will probably increase
-          // portability to stick to visible ascii
-          if (ch<' ' || ch>127) {
-            unicodeEscape(sb, ch);
-            needUnicode=true;
-          } else {
-            sb.append(ch);
-          }
-      }
-    }
-
-    if (needUnicode) {
-      writer.write('u');
-    }
-    writer.write('\'');
-    writer.append(sb);
-    writer.write('\'');
-  }
-
-  /*
-  old version that always used unicode
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    // use python unicode strings...
-    // python doesn't tolerate newlines in strings in it's eval(), so we must escape them.
-    writer.write("u'");
-    // it might be more efficient to use a stringbuilder or write substrings
-    // if writing chars to the stream is slow.
-    if (needsEscaping) {
-      for (int i=0; i<val.length(); i++) {
-        char ch = val.charAt(i);
-        switch(ch) {
-          case '\'':
-          case '\\': writer.write('\\'); writer.write(ch); break;
-          case '\r': writer.write("\\r"); break;
-          case '\n': writer.write("\\n"); break;
-          default:
-            // we don't strictly have to escape these chars, but it will probably increase
-            // portability to stick to visible ascii
-            if (ch<' ' || ch>127) {
-              unicodeChar(ch);
-            } else {
-              writer.write(ch);
-            }
-        }
-      }
-    } else {
-      writer.write(val);
-    }
-    writer.write('\'');
-  }
-  */
-
-}
diff --git a/src/java/org/apache/solr/request/QueryResponseWriter.java b/src/java/org/apache/solr/request/QueryResponseWriter.java
deleted file mode 100644
index 3755136..0000000
--- a/src/java/org/apache/solr/request/QueryResponseWriter.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.util.plugin.NamedListInitializedPlugin;
-
-/**
- * Implementations of <code>QueryResponseWriter</code> are used to format responses to query requests.
- *
- * Different <code>QueryResponseWriter</code>s are registered with the <code>SolrCore</code>.
- * One way to register a QueryResponseWriter with the core is through the <code>solrconfig.xml</code> file.
- * <p>
- * Example <code>solrconfig.xml</code> entry to register a <code>QueryResponseWriter</code> implementation to
- * handle all queries with a writer type of "simple":
- * <p>
- * <code>
- *    &lt;queryResponseWriter name="simple" class="foo.SimpleResponseWriter" /&gt;
- * </code>
- * <p>
- * A single instance of any registered QueryResponseWriter is created
- * via the default constructor and is reused for all relevant queries.
- *
- * @version $Id$
- */
-public interface QueryResponseWriter extends NamedListInitializedPlugin {
-  public static String CONTENT_TYPE_XML_UTF8="text/xml; charset=UTF-8";
-  public static String CONTENT_TYPE_TEXT_UTF8="text/plain; charset=UTF-8";
-  public static String CONTENT_TYPE_TEXT_ASCII="text/plain; charset=US-ASCII";
-
-  /**
-   * Write a SolrQueryResponse, this method must be thread save.
-   *
-   * <p>
-   * Information about the request (in particular: formating options) may be 
-   * obtained from <code>req</code> but the dominant source of information 
-   * should be <code>rsp</code>.
-   * <p>
-   * There are no mandatory actions that write must perform.
-   * An empty write implementation would fulfill
-   * all interface obligations.
-   * </p> 
-   */
-  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException;
-
-  /** 
-   * Return the applicable Content Type for a request, this method 
-   * must be thread safe.
-   *
-   * <p>
-   * QueryResponseWriter's must implement this method to return a valid 
-   * HTTP Content-Type header for the request, that will logically 
-   * correspond with the output produced by the write method.
-   * </p>
-   * @return a Content-Type string, which may not be null.
-   */
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response);
-  
-  /** <code>init</code> will be called just once, immediately after creation.
-   * <p>The args are user-level initialization parameters that
-   * may be specified when declaring a response writer in
-   * solrconfig.xml
-   */
-  public void init(NamedList args);
-}
-
-
-
diff --git a/src/java/org/apache/solr/request/RawResponseWriter.java b/src/java/org/apache/solr/request/RawResponseWriter.java
deleted file mode 100644
index dddc004..0000000
--- a/src/java/org/apache/solr/request/RawResponseWriter.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.IOException;
-import java.io.Writer;
-
-import org.apache.commons.io.IOUtils;
-import org.apache.solr.common.util.ContentStream;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * Writes a ContentStream directly to the output.
- *
- * <p>
- * This writer is a special case that extends and alters the
- * QueryResponseWriter contract.  If SolrQueryResponse contains a
- * ContentStream added with the key {@link #CONTENT}
- * then this writer will output that stream exactly as is (with it's
- * Content-Type).  if no such ContentStream has been added, then a
- * "base" QueryResponseWriter will be used to write the response
- * according to the usual contract.  The name of the "base" writer can
- * be specified as an initialization param for this writer, or it
- * defaults to the "standard" writer.
- * </p>
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class RawResponseWriter implements QueryResponseWriter 
-{
-  /** 
-   * The key that should be used to add a ContentStream to the 
-   * SolrQueryResponse if you intend to use this Writer.
-   */
-  public static final String CONTENT = "content";
-  private String _baseWriter = null;
-  
-  public void init(NamedList n) {
-    if( n != null ) {
-      Object base = n.get( "base" );
-      if( base != null ) {
-        _baseWriter = base.toString();
-      }
-    }
-  }
-
-  // Even if this is null, it should be ok
-  protected QueryResponseWriter getBaseWriter( SolrQueryRequest request )
-  {
-    return request.getCore().getQueryResponseWriter( _baseWriter );
-  }
-  
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    Object obj = response.getValues().get( CONTENT );
-    if( obj != null && (obj instanceof ContentStream ) ) {
-      return ((ContentStream)obj).getContentType();
-    }
-    return getBaseWriter( request ).getContentType( request, response );
-  }
-
-  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException 
-  {
-    Object obj = response.getValues().get( CONTENT );
-    if( obj != null && (obj instanceof ContentStream ) ) {
-      // copy the contents to the writer...
-      ContentStream content = (ContentStream)obj;
-      IOUtils.copy( content.getReader(), writer );
-    }
-    else {
-      getBaseWriter( request ).write( writer, request, response );
-    }
-  }
-}
diff --git a/src/java/org/apache/solr/request/RubyResponseWriter.java b/src/java/org/apache/solr/request/RubyResponseWriter.java
deleted file mode 100644
index c16f538..0000000
--- a/src/java/org/apache/solr/request/RubyResponseWriter.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.util.NamedList;
-
-public class RubyResponseWriter implements QueryResponseWriter {
-  static String CONTENT_TYPE_RUBY_UTF8="text/x-ruby;charset=UTF-8";
-
-  public void init(NamedList n) {
-    /* NOOP */
-  }
-  
- public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    RubyWriter w = new RubyWriter(writer, req, rsp);
-    try {
-      w.writeResponse();
-    } finally {
-      w.close();
-    }
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return CONTENT_TYPE_TEXT_UTF8;
-  }
-}
-
-class RubyWriter extends NaNFloatWriter {
-
-  protected String getNaN() { return "(0.0/0.0)"; }
-  protected String getInf() { return "(1.0/0.0)"; }
-
-  public RubyWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    super(writer, req, rsp);
-  }
-
-  @Override
-  public void writeNull(String name) throws IOException {
-    writer.write("nil");
-  }
-
-  @Override
-  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
-    writeStr(null, fname, needsEscaping);
-    writer.write('=');
-    writer.write('>');
-  }
-
-  @Override
-  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
-    // Ruby doesn't do unicode escapes... so let the servlet container write raw UTF-8
-    // bytes into the string.
-    //
-    // Use single quoted strings for safety since no evaluation is done within them.
-    // Also, there are very few escapes recognized in a single quoted string, so
-    // only escape the backslash and single quote.
-    writer.write('\'');
-    if (needsEscaping) {
-      for (int i=0; i<val.length(); i++) {
-        char ch = val.charAt(i);
-        if (ch=='\'' || ch=='\\') {
-          writer.write('\\');
-        }
-        writer.write(ch);
-      }
-    } else {
-      writer.write(val);
-    }
-    writer.write('\'');
-  }
-}
diff --git a/src/java/org/apache/solr/request/SolrQueryResponse.java b/src/java/org/apache/solr/request/SolrQueryResponse.java
deleted file mode 100644
index 81e4d69..0000000
--- a/src/java/org/apache/solr/request/SolrQueryResponse.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-
-import java.util.*;
-
-/**
- * <code>SolrQueryResponse</code> is used by a query handler to return
- * the response to a query request.
- *
- * <p>
- * <a name="returnable_data" /><b>Note On Returnable Data...</b><br/>
- * A <code>SolrQueryResponse</code> may contain the following types of
- * Objects generated by the <code>SolrRequestHandler</code> that processed
- * the request.
- * </p>
- * <ul>
- *  <li>{@link String}</li>
- *  <li>{@link Integer}</li>
- *  <li>{@link Long}</li>
- *  <li>{@link Float}</li>
- *  <li>{@link Double}</li>
- *  <li>{@link Boolean}</li>
- *  <li>{@link Date}</li>
- *  <li>{@link org.apache.solr.search.DocList}</li>
- *  <li>{@link org.apache.solr.common.SolrDocument} (since 1.3)</li>
- *  <li>{@link org.apache.solr.common.SolrDocumentList} (since 1.3)</li>
- *  <li>{@link Map} containing any of the items in this list</li>
- *  <li>{@link NamedList} containing any of the items in this list</li>
- *  <li>{@link Collection} containing any of the items in this list</li>
- *  <li>Array containing any of the items in this list</li>
- *  <li>null</li>
- * </ul>
- * <p>
- * Other data types may be added to the SolrQueryResponse, but there is no guarantee
- * that QueryResponseWriters will be able to deal with unexpected types.
- * </p>
- *
- * @version $Id$
- * @since solr 0.9
- */
-public class SolrQueryResponse {
-
-  /**
-   * Container for user defined values
-   * @see #getValues
-   * @see #add
-   * @see #setAllValues
-   * @see <a href="#returnable_data">Note on Returnable Data</a>
-   */
-  protected NamedList values = new SimpleOrderedMap();
-
-  /**
-   * Container for storing information that should be logged by Solr before returning.
-   */
-  protected NamedList toLog = new SimpleOrderedMap();
-
-  protected Set<String> defaultReturnFields;
-
-  // error if this is set...
-  protected Exception err;
-
-  /**
-   * Should this response be tagged with HTTP caching headers?
-   */
-  protected boolean httpCaching=true;
-  
-  /***
-   // another way of returning an error
-  int errCode;
-  String errMsg;
-  ***/
-
-  public SolrQueryResponse() {
-  }
-  
-  
-  /**
-   * Gets data to be returned in this response
-   * @see <a href="#returnable_data">Note on Returnable Data</a>
-   */
-  public NamedList getValues() { return values; }
-
-  /**
-   * Sets data to be returned in this response
-   * @see <a href="#returnable_data">Note on Returnable Data</a>
-   */
-  public void setAllValues(NamedList nameValuePairs) {
-    values=nameValuePairs;
-  }
-
-  /**
-   * Sets the document field names of fields to return by default when
-   * returning DocLists
-   */
-  public void setReturnFields(Set<String> fields) {
-    defaultReturnFields=fields;
-  }
-  // TODO: should this be represented as a String[] such
-  // that order can be maintained if needed?
-
-  /**
-   * Gets the document field names of fields to return by default when
-   * returning DocLists
-   */
-  public Set<String> getReturnFields() {
-    return defaultReturnFields;
-  }
-
-
-  /**
-   * Appends a named value to the list of named values to be returned.
-   * @param name  the name of the value - may be null if unnamed
-   * @param val   the value to add - also may be null since null is a legal value
-   * @see <a href="#returnable_data">Note on Returnable Data</a>
-   */
-  public void add(String name, Object val) {
-    values.add(name,val);
-  }
-
-  /**
-   * Causes an error to be returned instead of the results.
-   */
-  public void setException(Exception e) {
-    err=e;
-  }
-
-  /**
-   * Returns an Exception if there was a fatal error in processing the request.
-   * Returns null if the request succeeded.
-   */
-  public Exception getException() {
-    return err;
-  }
-
-  /**
-   * The endtime of the request in milliseconds.
-   * Used to calculate query time.
-   * @see #setEndTime(long)
-   * @see #getEndTime()
-   */
-  protected long endtime;
-
-  /**
-   * Get the time in milliseconds when the response officially finished. 
-   */
-  public long getEndTime() {
-    if (endtime==0) {
-      setEndTime();
-    }
-    return endtime;
-  }
-
-  /**
-   * Stop the timer for how long this query took.
-   * @see #setEndTime(long)
-   */
-  public long setEndTime() {
-    return setEndTime(System.currentTimeMillis());
-  }
-
-  /**
-   * Set the in milliseconds when the response officially finished. 
-   * @see #setEndTime()
-   */
-  public long setEndTime(long endtime) {
-    if (endtime!=0) {
-      this.endtime=endtime;
-    }
-    return this.endtime;
-  }
-  
-  /** Repsonse header to be logged */ 
-  public NamedList getResponseHeader() {
-	  SimpleOrderedMap<Object> header = (SimpleOrderedMap<Object>) values.get("responseHeader");
-	  return header;
-  }
-  
-  /** Add a value to be logged.
-   * 
-   * @param name name of the thing to log
-   * @param val value of the thing to log
-   */
-  public void addToLog(String name, Object val) {
-	  toLog.add(name, val);
-  }
-  
-  /** Get loggable items.
-   * 
-   * @return things to log
-   */
-  public NamedList getToLog() {
-	  return toLog;
-  }
-  
-  /**
-   * Enables or disables the emission of HTTP caching headers for this response.
-   * @param httpCaching true=emit caching headers, false otherwise
-   */
-  public void setHttpCaching(boolean httpCaching) {
-    this.httpCaching=httpCaching;
-  }
-  
-  /**
-   * Should this response emit HTTP caching headers?
-   * @return true=yes emit headers, false otherwise
-   */
-  public boolean isHttpCaching() {
-    return this.httpCaching;
-  }
-}
diff --git a/src/java/org/apache/solr/request/SolrRequestHandler.java b/src/java/org/apache/solr/request/SolrRequestHandler.java
index c8b433e..45a80fd 100644
--- a/src/java/org/apache/solr/request/SolrRequestHandler.java
+++ b/src/java/org/apache/solr/request/SolrRequestHandler.java
@@ -19,6 +19,7 @@ package org.apache.solr.request;
 
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrInfoMBean;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * Implementations of <code>SolrRequestHandler</code> are called to handle query requests.
diff --git a/src/java/org/apache/solr/request/TextResponseWriter.java b/src/java/org/apache/solr/request/TextResponseWriter.java
deleted file mode 100644
index b377650..0000000
--- a/src/java/org/apache/solr/request/TextResponseWriter.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import org.apache.lucene.document.Document;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.FastWriter;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.schema.IndexSchema;
-import org.apache.solr.search.DocList;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-/** Base class for text-oriented response writers.
- *
- * @version $Id$
- */
-public abstract class TextResponseWriter {
-  
-  protected final FastWriter writer;
-  protected final IndexSchema schema;
-  protected final SolrQueryRequest req;
-  protected final SolrQueryResponse rsp;
-
-  // the default set of fields to return for each document
-  protected Set<String> returnFields;
-
-  protected int level;
-  protected boolean doIndent;
-
-
-  public TextResponseWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
-    this.writer = FastWriter.wrap(writer);
-    this.schema = req.getSchema();
-    this.req = req;
-    this.rsp = rsp;
-    String indent = req.getParams().get("indent");
-    if (indent != null && !"".equals(indent) && !"off".equals(indent)) {
-      doIndent=true;
-    }
-    returnFields = rsp.getReturnFields();
-  }
-
-  /** done with this ResponseWriter... make sure any buffers are flushed to writer */
-  public void close() throws IOException {
-    writer.flushBuffer();
-  }
-
-  /** returns the Writer that the response is being written to */
-  public Writer getWriter() { return writer; }
-
-  // use a combination of tabs and spaces to minimize the size of an indented response.
-  private static final String[] indentArr = new String[] {
-    "\n",
-    "\n ",
-    "\n  ",
-    "\n\t",
-    "\n\t ",
-    "\n\t  ",  // could skip this one (the only 3 char seq)
-    "\n\t\t",
-    "\n\t\t "};
-
-  public void indent() throws IOException {
-     if (doIndent) indent(level);
-  }
-
-  public void indent(int lev) throws IOException {
-    int arrsz = indentArr.length-1;
-    // power-of-two intent array (gratuitous optimization :-)
-    String istr = indentArr[lev & (indentArr.length-1)];
-    writer.write(istr);
-  }
-
-  //
-  // Functions to manipulate the current logical nesting level.
-  // Any indentation will be partially based on level.
-  //
-  public void setLevel(int level) { this.level = level; }
-  public int level() { return level; }
-  public int incLevel() { return ++level; }
-  public int decLevel() { return --level; }
-  public void setIndent(boolean doIndent) {
-    this.doIndent = doIndent;
-  }
-
-
-  public abstract void writeNamedList(String name, NamedList val) throws IOException;
-
-  public void writeVal(String name, Object val) throws IOException {
-
-    // if there get to be enough types, perhaps hashing on the type
-    // to get a handler might be faster (but types must be exact to do that...)
-
-    // go in order of most common to least common
-    if (val==null) {
-      writeNull(name);
-    } else if (val instanceof String) {
-      writeStr(name, val.toString(), true);
-      // micro-optimization... using toString() avoids a cast first
-    } else if (val instanceof Integer) {
-      writeInt(name, val.toString());
-    } else if (val instanceof Boolean) {
-      writeBool(name, val.toString());
-    } else if (val instanceof Long) {
-      writeLong(name, val.toString());
-    } else if (val instanceof Date) {
-      writeDate(name,(Date)val);
-    } else if (val instanceof Float) {
-      // we pass the float instead of using toString() because
-      // it may need special formatting. same for double.
-      writeFloat(name, ((Float)val).floatValue());
-    } else if (val instanceof Double) {
-      writeDouble(name, ((Double)val).doubleValue());
-    } else if (val instanceof Document) {
-      writeDoc(name, (Document)val, returnFields, 0.0f, false);
-    } else if (val instanceof SolrDocument) {
-      writeSolrDocument(name, (SolrDocument)val, returnFields, null);
-    } else if (val instanceof DocList) {
-      // requires access to IndexReader
-      writeDocList(name, (DocList)val, returnFields,null);
-    // }
-    // else if (val instanceof DocSet) {
-    // how do we know what fields to read?
-    // todo: have a DocList/DocSet wrapper that
-    // restricts the fields to write...?
-    } else if (val instanceof SolrDocumentList) {
-      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields, null);
-    } else if (val instanceof Map) {
-      writeMap(name, (Map)val, false, true);
-    } else if (val instanceof NamedList) {
-      writeNamedList(name, (NamedList)val);
-    } else if (val instanceof Iterable) {
-      writeArray(name,((Iterable)val).iterator());
-    } else if (val instanceof Object[]) {
-      writeArray(name,(Object[])val);
-    } else if (val instanceof Iterator) {
-      writeArray(name,(Iterator)val);
-    } else {
-      // default... for debugging only
-      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
-    }
-  }
-
-  // names are passed when writing primitives like writeInt to allow many different
-  // types of formats, including those where the name may come after the value (like
-  // some XML formats).
-
-  public abstract void writeDoc(String name, Document doc, Set<String> returnFields, float score, boolean includeScore) throws IOException;
-
-  /**
-   * @since solr 1.3
-   */
-  public abstract void writeSolrDocument(String name, SolrDocument doc, Set<String> returnFields, Map pseudoFields) throws IOException;  
-
-  public abstract void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException;
-
-  /**
-   * @since solr 1.3
-   */
-  public abstract void writeSolrDocumentList(String name, SolrDocumentList docs, Set<String> fields, Map otherFields) throws IOException;  
-
-  public abstract void writeStr(String name, String val, boolean needsEscaping) throws IOException;
-
-  public abstract void writeMap(String name, Map val, boolean excludeOuter, boolean isFirstVal) throws IOException;
-
-  public abstract void writeArray(String name, Object[] val) throws IOException;
-
-  public abstract void writeArray(String name, Iterator val) throws IOException;
-
-  public abstract void writeNull(String name) throws IOException;
-
-  /** if this form of the method is called, val is the Java string form of an int */
-  public abstract void writeInt(String name, String val) throws IOException;
-
-  public void writeInt(String name, int val) throws IOException {
-    writeInt(name,Integer.toString(val));
-  }
-
-  /** if this form of the method is called, val is the Java string form of a long */
-  public abstract void writeLong(String name, String val) throws IOException;
-
-  public  void writeLong(String name, long val) throws IOException {
-    writeLong(name,Long.toString(val));
-  }
-
-  /** if this form of the method is called, val is the Java string form of a boolean */
-  public abstract void writeBool(String name, String val) throws IOException;
-
-  public void writeBool(String name, boolean val) throws IOException {
-    writeBool(name,Boolean.toString(val));
-  }
-
-  /** if this form of the method is called, val is the Java string form of a float */
-  public abstract void writeFloat(String name, String val) throws IOException;
-
-  public void writeFloat(String name, float val) throws IOException {
-    writeFloat(name,Float.toString(val));
-  }
-
-  /** if this form of the method is called, val is the Java string form of a double */
-  public abstract void writeDouble(String name, String val) throws IOException;
-
-  public void writeDouble(String name, double val) throws IOException {
-    writeDouble(name,Double.toString(val));
-  }
-
-  public abstract void writeDate(String name, Date val) throws IOException;
-
-  /** if this form of the method is called, val is the Solr ISO8601 based date format */
-  public abstract void writeDate(String name, String val) throws IOException;
-
-  public abstract void writeShort(String name, String val) throws IOException;
-
-  public void writeShort(String name, short val) throws IOException{
-    writeShort(name, Short.toString(val));
-  }
-
-  public abstract void writeByte(String name, String s) throws IOException;
-
-  public void writeByte(String name, byte val) throws IOException{
-    writeByte(name, Byte.toString(val));
-  }
-}
diff --git a/src/java/org/apache/solr/request/XMLResponseWriter.java b/src/java/org/apache/solr/request/XMLResponseWriter.java
deleted file mode 100644
index 48c60f4..0000000
--- a/src/java/org/apache/solr/request/XMLResponseWriter.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.Writer;
-import java.io.IOException;
-
-import org.apache.solr.common.util.NamedList;
-
-/**
- * @version $Id$
- */
-public class XMLResponseWriter implements QueryResponseWriter {
-  public void init(NamedList n) {
-    /* NOOP */
-  }
-
-  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
-    XMLWriter.writeResponse(writer,req,rsp);
-  }
-
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    return CONTENT_TYPE_XML_UTF8;
-  }
-}
diff --git a/src/java/org/apache/solr/request/XMLWriter.java b/src/java/org/apache/solr/request/XMLWriter.java
index bfe9760..53d7993 100644
--- a/src/java/org/apache/solr/request/XMLWriter.java
+++ b/src/java/org/apache/solr/request/XMLWriter.java
@@ -22,6 +22,7 @@ import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.XML;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.DocIterator;
@@ -261,19 +262,6 @@ final public class XMLWriter {
 
 
 
-  /**
-   * Begins the writing of an XML tag output, using the provided 
-   * <code>tag</code> as the name, with an optional <code>name</code>
-   * attribute, set to the provided value of name. If <code>closeTag</code> is
-   * set to true, then the tag is written with no internal text value.
-   * 
-   * @param tag The name of the XML tag to write.
-   * @param name If provided (not set to null), a &quot;name&quot; attribute is
-   * written to the tag, with the value set to the provided parameter.
-   * @param closeTag If set to true, then the tag is closed, without writing any
-   * internal text value.
-   * @throws IOException If the underlying {@link #writer} throws an Exception.
-   */
   public void startTag(String tag, String name, boolean closeTag) throws IOException {
     if (doIndent) indent();
 
diff --git a/src/java/org/apache/solr/request/XSLTResponseWriter.java b/src/java/org/apache/solr/request/XSLTResponseWriter.java
deleted file mode 100644
index 87ef0eb..0000000
--- a/src/java/org/apache/solr/request/XSLTResponseWriter.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.request;
-
-import java.io.BufferedReader;
-import java.io.CharArrayReader;
-import java.io.CharArrayWriter;
-import java.io.IOException;
-import java.io.Reader;
-import java.io.Writer;
-import java.util.Map;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.stream.StreamResult;
-import javax.xml.transform.stream.StreamSource;
-
-import org.apache.solr.core.SolrConfig;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.util.xslt.TransformerProvider;
-
-/** QueryResponseWriter which captures the output of the XMLWriter
- *  (in memory for now, not optimal performancewise), and applies an XSLT transform
- *  to it.
- */
-public class XSLTResponseWriter implements QueryResponseWriter {
-
-  public static final String DEFAULT_CONTENT_TYPE = "text/xml";
-  public static final String TRANSFORM_PARAM = "tr";
-  public static final String CONTEXT_TRANSFORMER_KEY = "xsltwriter.transformer";
-  
-  private Integer xsltCacheLifetimeSeconds = null; 
-  public static final int XSLT_CACHE_DEFAULT = 60;
-  private static final String XSLT_CACHE_PARAM = "xsltCacheLifetimeSeconds"; 
-
-  private static final Logger log = LoggerFactory.getLogger(XSLTResponseWriter.class);
-  
-  public void init(NamedList n) {
-      final SolrParams p = SolrParams.toSolrParams(n);
-      xsltCacheLifetimeSeconds = p.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);
-      log.info("xsltCacheLifetimeSeconds=" + xsltCacheLifetimeSeconds);
-  }
-
-  
-  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
-    Transformer t = null;
-    try {
-      t = getTransformer(request);
-    } catch(Exception e) {
-      // TODO should our parent interface throw (IO)Exception?
-      throw new RuntimeException("getTransformer fails in getContentType",e);
-    }
-    
-    final String mediaTypeFromXslt = t.getOutputProperty("media-type");
-    if(mediaTypeFromXslt == null || mediaTypeFromXslt.length()==0) {
-      // This did not happen in my tests, mediaTypeFromXslt is set to "text/xml"
-      // if the XSLT transform does not contain an xsl:output element. Not sure
-      // if this is standard behavior or if it's just my JVM/libraries
-      return DEFAULT_CONTENT_TYPE;
-    }
-    return mediaTypeFromXslt;
-  }
-
-  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
-    final Transformer t = getTransformer(request);
-    
-    // capture the output of the XMLWriter
-    final CharArrayWriter w = new CharArrayWriter();
-    XMLWriter.writeResponse(w,request,response);
-    
-    // and write transformed result to our writer
-    final Reader r = new BufferedReader(new CharArrayReader(w.toCharArray()));
-    final StreamSource source = new StreamSource(r);
-    final StreamResult result = new StreamResult(writer);
-    try {
-      t.transform(source, result);
-    } catch(TransformerException te) {
-      final IOException ioe = new IOException("XSLT transformation error");
-      ioe.initCause(te);
-      throw ioe;
-    }
-  }
-  
-  /** Get Transformer from request context, or from TransformerProvider.
-   *  This allows either getContentType(...) or write(...) to instantiate the Transformer,
-   *  depending on which one is called first, then the other one reuses the same Transformer
-   */
-  protected Transformer getTransformer(SolrQueryRequest request) throws IOException {
-    final String xslt = request.getParams().get(TRANSFORM_PARAM,null);
-    if(xslt==null) {
-      throw new IOException("'" + TRANSFORM_PARAM + "' request parameter is required to use the XSLTResponseWriter");
-    }
-    // not the cleanest way to achieve this
-    SolrConfig solrConfig = request.getCore().getSolrConfig();
-    // no need to synchronize access to context, right? 
-    // Nothing else happens with it at the same time
-    final Map<Object,Object> ctx = request.getContext();
-    Transformer result = (Transformer)ctx.get(CONTEXT_TRANSFORMER_KEY);
-    if(result==null) {
-      result = TransformerProvider.instance.getTransformer(solrConfig, xslt,xsltCacheLifetimeSeconds.intValue());
-      ctx.put(CONTEXT_TRANSFORMER_KEY,result);
-    }
-    return result;
-  }
-}
diff --git a/src/java/org/apache/solr/response/BaseResponseWriter.java b/src/java/org/apache/solr/response/BaseResponseWriter.java
new file mode 100644
index 0000000..32e6432
--- /dev/null
+++ b/src/java/org/apache/solr/response/BaseResponseWriter.java
@@ -0,0 +1,330 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.schema.FieldType;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.schema.SchemaField;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Fieldable;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+import java.util.ArrayList;
+
+/**
+ * 
+ * 
+ * This class serves as a basis from which {@link QueryResponseWriter}s can be
+ * developed. The class provides a single method
+ * {@link #write(SingleResponseWriter, SolrQueryRequest, SolrQueryResponse)}
+ * that allows users to implement a {@link SingleResponseWriter} sub-class which
+ * defines how to output {@link SolrInputDocument}s or a
+ * {@link SolrDocumentList}.
+ * 
+ * @version $Id$
+ * @since 1.5
+ * 
+ */
+public abstract class BaseResponseWriter {
+
+  private static final Logger LOG = LoggerFactory
+      .getLogger(BaseResponseWriter.class);
+
+  private static final String SCORE_FIELD = "score";
+
+  /**
+   * 
+   * The main method that allows users to write {@link SingleResponseWriter}s
+   * and provide them as the initial parameter <code>responseWriter</code> to
+   * this method which defines how output should be generated.
+   * 
+   * @param responseWriter
+   *          The user-provided {@link SingleResponseWriter} implementation.
+   * @param request
+   *          The provided {@link SolrQueryRequest}.
+   * @param response
+   *          The provided {@link SolrQueryResponse}.
+   * @throws IOException
+   *           If any error occurs.
+   */
+  public void write(SingleResponseWriter responseWriter,
+      SolrQueryRequest request, SolrQueryResponse response) throws IOException {
+    responseWriter.start();
+    NamedList nl = response.getValues();
+    for (int i = 0; i < nl.size(); i++) {
+      String name = nl.getName(i);
+      Object val = nl.getVal(i);
+      if ("responseHeader".equals(name)) {
+        Boolean omitHeader = request.getParams().getBool(CommonParams.OMIT_HEADER);
+        if (omitHeader == null || !omitHeader) responseWriter.writeResponseHeader((NamedList) val);
+      } else if (val instanceof SolrDocumentList) {
+        SolrDocumentList list = (SolrDocumentList) val;
+        DocListInfo info = new DocListInfo((int)list.getNumFound(), list.size(), (int)list.getStart(), list.getMaxScore());
+        if (responseWriter.isStreamingDocs()) {
+          responseWriter.startDocumentList(name,info);
+          for (SolrDocument solrDocument : list)
+            responseWriter.writeDoc(solrDocument);
+          responseWriter.endDocumentList();
+        } else {
+          responseWriter.writeAllDocs(info, list);
+        }
+      } else if (val instanceof DocList) {
+        DocList docList = (DocList) val;
+        int sz = docList.size();
+        IdxInfo idxInfo = new IdxInfo(request.getSchema(), request
+            .getSearcher(), response.getReturnFields());
+        DocListInfo info = new DocListInfo(docList.matches(), docList.size(),docList.offset(),
+            docList.maxScore());
+        DocIterator iterator = docList.iterator();
+        if (responseWriter.isStreamingDocs()) {
+          responseWriter.startDocumentList(name,info);
+          for (int j = 0; j < sz; j++) {
+            SolrDocument sdoc = getDoc(iterator.nextDoc(), idxInfo);
+            if (idxInfo.includeScore && docList.hasScores()) {
+              sdoc.addField(SCORE_FIELD, iterator.score());
+            }
+            responseWriter.writeDoc(sdoc);
+          }
+          responseWriter.end();
+        } else {
+          ArrayList<SolrDocument> list = new ArrayList<SolrDocument>(docList
+              .size());
+          for (int j = 0; j < sz; j++) {
+            SolrDocument sdoc = getDoc(iterator.nextDoc(), idxInfo);
+            if (idxInfo.includeScore && docList.hasScores()) {
+              sdoc.addField(SCORE_FIELD, iterator.score());
+            }
+          }
+          responseWriter.writeAllDocs(info, list);
+        }
+
+      } else {
+        responseWriter.writeOther(name, val);
+
+      }
+    }
+    responseWriter.end();
+
+  }
+
+  /**No ops implementation so that the implementing classes do not have to do it
+   */
+  public void init(NamedList args){}
+
+  private static class IdxInfo {
+    IndexSchema schema;
+    SolrIndexSearcher searcher;
+    Set<String> returnFields;
+    boolean includeScore;
+
+    private IdxInfo(IndexSchema schema, SolrIndexSearcher searcher,
+        Set<String> returnFields) {
+      this.schema = schema;
+      this.searcher = searcher;
+      this.includeScore = returnFields != null
+              && returnFields.contains(SCORE_FIELD);
+      if (returnFields != null) {
+        if (returnFields.size() == 0 || (returnFields.size() == 1 && includeScore) || returnFields.contains("*")) {
+          returnFields = null;  // null means return all stored fields
+        }
+      }
+      this.returnFields = returnFields;
+
+    }
+  }
+
+  private static SolrDocument getDoc(int id, IdxInfo info) throws IOException {
+    Document doc = info.searcher.doc(id);
+    SolrDocument solrDoc = new SolrDocument();
+    for (Fieldable f : (List<Fieldable>) doc.getFields()) {
+      String fieldName = f.name();
+      if (info.returnFields != null && !info.returnFields.contains(fieldName))
+        continue;
+      SchemaField sf = info.schema.getFieldOrNull(fieldName);
+      FieldType ft = null;
+      if (sf != null) ft = sf.getType();
+      Object val = null;
+      if (ft == null) { // handle fields not in the schema
+        if (f.isBinary())
+          val = f.binaryValue();
+        else
+          val = f.stringValue();
+      } else {
+        try {
+          if (BinaryResponseWriter.KNOWN_TYPES.contains(ft.getClass())) {
+            val = ft.toObject(f);
+          } else {
+            val = ft.toExternal(f);
+          }
+        } catch (Exception e) {
+          // There is a chance of the underlying field not really matching the
+          // actual field type . So ,it can throw exception
+          LOG.warn("Error reading a field from document : " + solrDoc, e);
+          // if it happens log it and continue
+          continue;
+        }
+      }
+      if (sf != null && sf.multiValued() && !solrDoc.containsKey(fieldName)) {
+        ArrayList l = new ArrayList();
+        l.add(val);
+        solrDoc.addField(fieldName, l);
+      } else {
+        solrDoc.addField(fieldName, val);
+      }
+    }
+
+    return solrDoc;
+  }
+
+  public static class DocListInfo {
+    public final int numFound;
+    public final int start ;
+    public Float maxScore = null;
+    public final int size;
+
+    public DocListInfo(int numFound, int sz,int start, Float maxScore) {
+      this.numFound = numFound;
+      size = sz;
+      this.start = start;
+      this.maxScore = maxScore;
+    }
+  }
+
+  /**
+   * 
+   * Users wanting to define custom {@link QueryResponseWriter}s that deal with
+   * {@link SolrInputDocument}s and {@link SolrDocumentList} should override the
+   * methods for this class. All the methods are w/o body because the user is left
+   * to choose which all methods are required for his purpose
+   */
+  public static abstract class SingleResponseWriter {
+
+    /**
+     * This method is called at the start of the {@link QueryResponseWriter}
+     * output. Override this method if you want to provide a header for your
+     * output, e.g., XML headers, etc.
+     * 
+     * @throws IOException
+     *           if any error occurs.
+     */
+    public void start() throws IOException { }
+
+    /**
+     * This method is called at the start of processing a
+     * {@link SolrDocumentList}. Those that override this method are provided
+     * with {@link DocListInfo} object to use to inspect the output
+     * {@link SolrDocumentList}.
+     * 
+     * @param info Information about the {@link SolrDocumentList} to output.
+     */
+    public void startDocumentList(String name, DocListInfo info) throws IOException { }
+
+    /**
+     * This method writes out a {@link SolrDocument}, on a doc-by-doc basis.
+     * This method is only called when {@link #isStreamingDocs()} returns true.
+     * 
+     * @param solrDocument
+     *          The doc-by-doc {@link SolrDocument} to transform into output as
+     *          part of this {@link QueryResponseWriter}.
+     */
+    public void writeDoc(SolrDocument solrDocument) throws IOException { }
+
+    /**
+     * This method is called at the end of outputting a {@link SolrDocumentList}
+     * or on a doc-by-doc {@link SolrDocument} basis.
+     */
+    public void endDocumentList() throws IOException { } 
+    /**
+     * This method defines how to output the {@link SolrQueryResponse} header
+     * which is provided as a {@link NamedList} parameter.
+     * 
+     * @param responseHeader
+     *          The response header to output.
+     */
+    public void writeResponseHeader(NamedList responseHeader) throws IOException { }
+
+    /**
+     * This method is called at the end of the {@link QueryResponseWriter}
+     * lifecycle. Implement this method to add a footer to your output, e.g., in
+     * the case of XML, the outer tag for your tag set, etc.
+     * 
+     * @throws IOException
+     *           If any error occurs.
+     */
+    public void end() throws IOException { }
+
+    /**
+     * Define this method to control how output is written by this
+     * {@link QueryResponseWriter} if the output is not a
+     * {@link SolrInputDocument} or a {@link SolrDocumentList}.
+     * 
+     * @param name
+     *          The name of the object to output.
+     * @param other
+     *          The object to output.
+     * @throws IOException
+     *           If any error occurs.
+     */
+    public void writeOther(String name, Object other) throws IOException { }
+
+    /**
+     * Overriding this method to return false forces all
+     * {@link SolrInputDocument}s to be spit out as a {@link SolrDocumentList}
+     * so they can be processed as a whole, rather than on a doc-by-doc basis.
+     * If set to false, this method calls
+     * {@link #writeAllDocs(DocListInfo, List)}, else if set to true, then this
+     * method forces calling {@link #writeDoc(SolrDocument)} on a doc-by-doc
+     * basis. one
+     * 
+     * @return True to force {@link #writeDoc(SolrDocument)} to be called, False
+     *         to force {@link #writeAllDocs(DocListInfo, List)} to be called.
+     */
+    public boolean isStreamingDocs() { return true; }
+
+    /**
+     * Writes out all {@link SolrInputDocument}s . This is invoked only if
+     * {@link #isStreamingDocs()} returns false.
+     * 
+     * @param info
+     *          Information about the {@link List} of {@link SolrDocument}s to
+     *          output.
+     * @param allDocs
+     *          A {@link List} of {@link SolrDocument}s to output.
+     * @throws IOException
+     *           If any error occurs.
+     */
+    public void writeAllDocs(DocListInfo info, List<SolrDocument> allDocs) throws IOException { }
+
+  }
+
+}
diff --git a/src/java/org/apache/solr/response/BinaryQueryResponseWriter.java b/src/java/org/apache/solr/response/BinaryQueryResponseWriter.java
new file mode 100755
index 0000000..1468c7f
--- /dev/null
+++ b/src/java/org/apache/solr/response/BinaryQueryResponseWriter.java
@@ -0,0 +1,39 @@
+package org.apache.solr.response;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.Writer;
+import java.io.OutputStream;
+import java.io.IOException;
+
+import org.apache.solr.request.SolrQueryRequest;
+
+/**
+ * Implementations of <code>BinaryQueryResponseWriter</code> are used to
+ * write response in binary format
+ * Functionality is exactly same as its parent class <code>QueryResponseWriter</code
+ * But it may not implement the <code>write(Writer writer, SolrQueryRequest request, SolrQueryResponse response)</code>
+ * method  
+ *
+ */
+public interface BinaryQueryResponseWriter extends QueryResponseWriter{
+
+    /**Use it to write the reponse in a binary format
+     */
+    public void write(OutputStream out, SolrQueryRequest request, SolrQueryResponse response) throws IOException;
+}
diff --git a/src/java/org/apache/solr/response/BinaryResponseWriter.java b/src/java/org/apache/solr/response/BinaryResponseWriter.java
new file mode 100755
index 0000000..eeb7ad0
--- /dev/null
+++ b/src/java/org/apache/solr/response/BinaryResponseWriter.java
@@ -0,0 +1,229 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.response;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Fieldable;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.JavaBinCodec;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.*;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.util.*;
+
+
+public class BinaryResponseWriter implements BinaryQueryResponseWriter {
+  private static final Logger LOG = LoggerFactory.getLogger(BinaryResponseWriter.class);
+  public static final Set<Class> KNOWN_TYPES = new HashSet<Class>();
+
+  public void write(OutputStream out, SolrQueryRequest req, SolrQueryResponse response) throws IOException {
+    Resolver resolver = new Resolver(req, response.getReturnFields());
+    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
+    if (omitHeader != null && omitHeader) response.getValues().remove("responseHeader");
+    JavaBinCodec codec = new JavaBinCodec(resolver);
+    codec.marshal(response.getValues(), out);
+  }
+
+  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
+    throw new RuntimeException("This is a binary writer , Cannot write to a characterstream");
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return "application/octet-stream";
+  }
+
+  public void init(NamedList args) {
+    /* NOOP */
+  }
+
+  private static class Resolver implements JavaBinCodec.ObjectResolver {
+    private final SolrQueryRequest solrQueryRequest;
+    private IndexSchema schema;
+    private SolrIndexSearcher searcher;
+    private final Set<String> returnFields;
+    private final boolean includeScore;
+
+    // transmit field values using FieldType.toObject()
+    // rather than the String from FieldType.toExternal()
+    boolean useFieldObjects = true;
+
+    public Resolver(SolrQueryRequest req, Set<String> returnFields) {
+      solrQueryRequest = req;
+      this.includeScore = returnFields != null && returnFields.contains("score");
+
+      if (returnFields != null) {
+        if (returnFields.size() == 0 || (returnFields.size() == 1 && includeScore) || returnFields.contains("*")) {
+          returnFields = null;  // null means return all stored fields
+        }
+      }
+      this.returnFields = returnFields;
+    }
+
+    public Object resolve(Object o, JavaBinCodec codec) throws IOException {
+      if (o instanceof DocList) {
+        writeDocList((DocList) o, codec);
+        return null; // null means we completely handled it
+      }
+      if (o instanceof SolrDocument) {
+        SolrDocument solrDocument = (SolrDocument) o;
+        codec.writeSolrDocument(solrDocument, returnFields);
+        return null;
+      }
+      if (o instanceof Document) {
+        return getDoc((Document) o);
+      }
+
+      return o;
+    }
+
+    public void writeDocList(DocList ids, JavaBinCodec codec) throws IOException {
+      codec.writeTag(JavaBinCodec.SOLRDOCLST);
+      List l = new ArrayList(3);
+      l.add((long) ids.matches());
+      l.add((long) ids.offset());
+      Float maxScore = null;
+      if (includeScore && ids.hasScores()) {
+        maxScore = ids.maxScore();
+      }
+      l.add(maxScore);
+      codec.writeArray(l);
+
+      int sz = ids.size();
+      codec.writeTag(JavaBinCodec.ARR, sz);
+      if(searcher == null) searcher = solrQueryRequest.getSearcher();
+      if(schema == null) schema = solrQueryRequest.getSchema(); 
+      DocIterator iterator = ids.iterator();
+      for (int i = 0; i < sz; i++) {
+        int id = iterator.nextDoc();
+        Document doc = searcher.doc(id, returnFields);
+
+        SolrDocument sdoc = getDoc(doc);
+
+        if (includeScore && ids.hasScores()) {
+          sdoc.addField("score", iterator.score());
+        }
+
+        codec.writeSolrDocument(sdoc);
+      }
+    }
+
+
+    public SolrDocument getDoc(Document doc) {
+      SolrDocument solrDoc = new SolrDocument();
+      for (Fieldable f : (List<Fieldable>) doc.getFields()) {
+        String fieldName = f.name();
+        if (returnFields != null && !returnFields.contains(fieldName)) continue;
+        SchemaField sf = schema.getFieldOrNull(fieldName);
+        FieldType ft = null;
+        if(sf != null) ft =sf.getType();
+        Object val;
+        if (ft == null) {  // handle fields not in the schema
+          if (f.isBinary()) val = f.binaryValue();
+          else val = f.stringValue();
+        } else {
+          try {
+            if (useFieldObjects && KNOWN_TYPES.contains(ft.getClass())) {
+              val = ft.toObject(f);
+            } else {
+              val = ft.toExternal(f);
+            }
+          } catch (Exception e) {
+            // There is a chance of the underlying field not really matching the
+            // actual field type . So ,it can throw exception
+            LOG.warn("Error reading a field from document : " + solrDoc, e);
+            //if it happens log it and continue
+            continue;
+          }
+        }
+        if(sf != null && sf.multiValued() && !solrDoc.containsKey(fieldName)){
+          ArrayList l = new ArrayList();
+          l.add(val);
+          solrDoc.addField(fieldName, l);
+        } else {
+          solrDoc.addField(fieldName, val);
+        }
+      }
+      return solrDoc;
+    }
+
+  }
+
+
+  /**
+   * TODO -- there may be a way to do this without marshal at all...
+   *
+   * @param req
+   * @param rsp
+   *
+   * @return a response object equivalent to what you get from the XML/JSON/javabin parser. Documents become
+   *         SolrDocuments, DocList becomes SolrDocumentList etc.
+   *
+   * @since solr 1.4
+   */
+  @SuppressWarnings("unchecked")
+  public static NamedList<Object> getParsedResponse(SolrQueryRequest req, SolrQueryResponse rsp) {
+    try {
+      Resolver resolver = new Resolver(req, rsp.getReturnFields());
+
+      ByteArrayOutputStream out = new ByteArrayOutputStream();
+      new JavaBinCodec(resolver).marshal(rsp.getValues(), out);
+
+      InputStream in = new ByteArrayInputStream(out.toByteArray());
+      return (NamedList<Object>) new JavaBinCodec(resolver).unmarshal(in);
+    }
+    catch (Exception ex) {
+      throw new RuntimeException(ex);
+    }
+  }
+
+  static {
+    KNOWN_TYPES.add(BoolField.class);
+    KNOWN_TYPES.add(BCDIntField.class);
+    KNOWN_TYPES.add(BCDLongField.class);
+    KNOWN_TYPES.add(BCDStrField.class);
+    KNOWN_TYPES.add(ByteField.class);
+    KNOWN_TYPES.add(DateField.class);
+    KNOWN_TYPES.add(DoubleField.class);
+    KNOWN_TYPES.add(FloatField.class);
+    KNOWN_TYPES.add(ShortField.class);
+    KNOWN_TYPES.add(IntField.class);
+    KNOWN_TYPES.add(LongField.class);
+    KNOWN_TYPES.add(SortableLongField.class);
+    KNOWN_TYPES.add(SortableIntField.class);
+    KNOWN_TYPES.add(SortableFloatField.class);
+    KNOWN_TYPES.add(SortableDoubleField.class);
+    KNOWN_TYPES.add(StrField.class);
+    KNOWN_TYPES.add(TextField.class);
+    KNOWN_TYPES.add(TrieField.class);
+    KNOWN_TYPES.add(TrieIntField.class);
+    KNOWN_TYPES.add(TrieLongField.class);
+    KNOWN_TYPES.add(TrieFloatField.class);
+    KNOWN_TYPES.add(TrieDoubleField.class);
+    KNOWN_TYPES.add(TrieDateField.class);
+    KNOWN_TYPES.add(BinaryField.class);
+    // We do not add UUIDField because UUID object is not a supported type in JavaBinCodec
+    // and if we write UUIDField.toObject, we wouldn't know how to handle it in the client side
+  }
+}
diff --git a/src/java/org/apache/solr/response/GenericBinaryResponseWriter.java b/src/java/org/apache/solr/response/GenericBinaryResponseWriter.java
new file mode 100644
index 0000000..489ad31
--- /dev/null
+++ b/src/java/org/apache/solr/response/GenericBinaryResponseWriter.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.OutputStream;
+import java.io.IOException;
+import java.io.Writer;
+
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.request.SolrQueryRequest;
+
+/**
+ * 
+ * 
+ * A generic {@link QueryResponseWriter} implementation that requires a user to
+ * implement the
+ * {@link #getSingleResponseWriter(OutputStream, SolrQueryRequest, SolrQueryResponse)}
+ * that defines a {@link SingleResponseWriter} to handle the binary output.
+ * 
+ * @since 1.5
+ * @version $Id$
+ * 
+ */
+public abstract class GenericBinaryResponseWriter extends BaseResponseWriter
+    implements BinaryQueryResponseWriter {
+
+  /**
+   * 
+   * Writes the binary output data using the {@link SingleResponseWriter}
+   * provided by a call to
+   * {@link #getSingleResponseWriter(OutputStream, SolrQueryRequest, SolrQueryResponse)}
+   * .
+   * 
+   * @param out
+   *          The {@link OutputStream} to write the binary data to.
+   * @param request
+   *          The provided {@link SolrQueryRequest}.
+   * @param response
+   *          The provided {@link SolrQueryResponse}.
+   */
+  public void write(OutputStream out, SolrQueryRequest request,
+      SolrQueryResponse response) throws IOException {
+    super.write(getSingleResponseWriter(out, request, response), request,
+        response);
+  }
+
+  /**
+   * Users of this class should implement this method to define a
+   * {@link SingleResponseWriter} responsible for writing the binary output
+   * given a {@link SolrDocumentList} or doc-by-doc, given a
+   * {@link SolrInputDocument}.
+   * 
+   * @param out
+   *          The {@link OutputStream} to write the binary data response to.
+   * @param request
+   *          The provided {@link SolrQueryRequest}.
+   * @param response
+   *          The provided {@link SolrQueryResponse}.
+   * @return A {@link SingleResponseWriter} that will be used to generate the
+   *         response output from this {@link QueryResponseWriter}.
+   */
+  public abstract SingleResponseWriter getSingleResponseWriter(
+      OutputStream out, SolrQueryRequest request, SolrQueryResponse response);
+
+  /**Just to throw Exception So that the eimplementing classes do not have to do the  same
+   */
+  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
+    throw new RuntimeException("This is a binary writer , Cannot write to a characterstream");
+  }
+}
diff --git a/src/java/org/apache/solr/response/GenericTextResponseWriter.java b/src/java/org/apache/solr/response/GenericTextResponseWriter.java
new file mode 100644
index 0000000..e998a32
--- /dev/null
+++ b/src/java/org/apache/solr/response/GenericTextResponseWriter.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.request.SolrQueryRequest;
+
+/**
+ * 
+ * 
+ * A generic {@link QueryResponseWriter} implementation that requires a user to
+ * implement the
+ * {@link #getSingleResponseWriter(Writer, SolrQueryRequest, SolrQueryResponse)}
+ * that defines a {@link SingleResponseWriter} to handle plain ol' text output.
+ * 
+ * @since 1.5
+ * @version $Id$
+ * 
+ */
+public abstract class GenericTextResponseWriter extends BaseResponseWriter
+    implements QueryResponseWriter {
+
+  /**
+   * 
+   * Writes text output using the {@link SingleResponseWriter} provided by a
+   * call to
+   * {@link #getSingleResponseWriter(Writer, SolrQueryRequest, SolrQueryResponse)}
+   * .
+   * 
+   * @param out
+   *          The {@link Writer} to write the text output to.
+   * @param request
+   *          The provided {@link SolrQueryRequest}.
+   * @param response
+   *          The provided {@link SolrQueryResponse}.
+   */
+  public void write(Writer writer, SolrQueryRequest request,
+      SolrQueryResponse response) throws IOException {
+    super.write(getSingleResponseWriter(writer, request, response), request,
+        response);
+  }
+
+  /**
+   * Users of this class should implement this method to define a
+   * {@link SingleResponseWriter} responsible for writing text output given a
+   * {@link SolrDocumentList} or doc-by-doc, given a {@link SolrInputDocument}.
+   * 
+   * @param writer
+   *          The {@link Writer} to write the text data response to.
+   * @param request
+   *          The provided {@link SolrQueryRequest}.
+   * @param response
+   *          The provided {@link SolrQueryResponse}.
+   * @return A {@link SingleResponseWriter} that will be used to generate the
+   *         response output from this {@link QueryResponseWriter}.
+   */
+  protected abstract SingleResponseWriter getSingleResponseWriter(
+      Writer writer, SolrQueryRequest request, SolrQueryResponse response);
+}
diff --git a/src/java/org/apache/solr/response/JSONResponseWriter.java b/src/java/org/apache/solr/response/JSONResponseWriter.java
new file mode 100644
index 0000000..c59c851
--- /dev/null
+++ b/src/java/org/apache/solr/response/JSONResponseWriter.java
@@ -0,0 +1,846 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.util.StringHelper;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.SchemaField;
+import org.apache.solr.schema.TextField;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.*;
+
+/**
+ * @version $Id$
+ */
+
+public class JSONResponseWriter implements QueryResponseWriter {
+  static String CONTENT_TYPE_JSON_UTF8="text/x-json; charset=UTF-8";
+
+  public void init(NamedList n) {
+  }
+
+  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    JSONWriter w = new JSONWriter(writer, req, rsp);
+    try {
+      w.writeResponse();
+    } finally {
+      w.close();
+    }
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    // using the text/plain allows this to be viewed in the browser easily
+    return CONTENT_TYPE_TEXT_UTF8;
+  }
+}
+
+
+class JSONWriter extends TextResponseWriter {
+
+  // cache the calendar instance in case we are writing many dates...
+  private Calendar cal;
+
+  private String namedListStyle;
+  private String wrapperFunction;
+
+  private static final String JSON_NL_STYLE="json.nl";
+  private static final String JSON_NL_MAP="map";
+  private static final String JSON_NL_FLAT="flat";
+  private static final String JSON_NL_ARROFARR="arrarr";
+  private static final String JSON_NL_ARROFMAP="arrmap";
+  private static final String JSON_WRAPPER_FUNCTION="json.wrf";
+
+
+  public JSONWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    super(writer, req, rsp);
+    namedListStyle = StringHelper.intern(req.getParams().get(JSON_NL_STYLE, JSON_NL_FLAT));
+    wrapperFunction = req.getParams().get(JSON_WRAPPER_FUNCTION);
+  }
+
+  public void writeResponse() throws IOException {
+    if(wrapperFunction!=null) {
+        writer.write(wrapperFunction + "(");
+    }
+    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
+    if(omitHeader != null && omitHeader) rsp.getValues().remove("responseHeader");
+    writeNamedList(null, rsp.getValues());
+    if(wrapperFunction!=null) {
+        writer.write(')');
+    }
+  }
+
+  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
+    writeStr(null, fname, needsEscaping);
+    writer.write(':');
+  }
+
+  /** Represents a NamedList directly as a JSON Object (essentially a Map)
+   * Map null to "" and name mangle any repeated keys to avoid repeats in the
+   * output.
+   */
+  protected void writeNamedListAsMapMangled(String name, NamedList val) throws IOException {
+    int sz = val.size();
+    writeMapOpener(sz);
+    incLevel();
+
+    // In JSON objects (maps) we can't have null keys or duplicates...
+    // map null to "" and append a qualifier to duplicates.
+    //
+    // a=123,a=456 will be mapped to {a=1,a__1=456}
+    // Disad: this is ambiguous since a real key could be called a__1
+    //
+    // Another possible mapping could aggregate multiple keys to an array:
+    // a=123,a=456 maps to a=[123,456]
+    // Disad: this is ambiguous with a real single value that happens to be an array
+    //
+    // Both of these mappings have ambiguities.
+    HashMap<String,Integer> repeats = new HashMap<String,Integer>(4);
+
+    boolean first=true;
+    for (int i=0; i<sz; i++) {
+      String key = val.getName(i);
+      if (key==null) key="";
+
+      if (first) {
+        first=false;
+        repeats.put(key,0);
+      } else {
+        writeMapSeparator();
+
+        Integer repeatCount = repeats.get(key);
+        if (repeatCount==null) {
+          repeats.put(key,0);
+        } else {
+          String newKey = key;
+          int newCount = repeatCount;
+          do {  // avoid generated key clashing with a real key
+            newKey = key + ' ' + (++newCount);
+            repeatCount = repeats.get(newKey);
+          } while (repeatCount != null);
+
+          repeats.put(key,newCount);
+          key = newKey;
+        }
+      }
+
+      indent();
+      writeKey(key, true);
+      writeVal(key,val.getVal(i));
+    }
+
+    decLevel();
+    writeMapCloser();
+  }
+
+  /** Represents a NamedList directly as a JSON Object (essentially a Map)
+   * repeating any keys if they are repeated in the NamedList.  null is mapped
+   * to "".
+   */ 
+  protected void writeNamedListAsMapWithDups(String name, NamedList val) throws IOException {
+    int sz = val.size();
+    writeMapOpener(sz);
+    incLevel();
+
+    for (int i=0; i<sz; i++) {
+      if (i!=0) {
+        writeMapSeparator();
+      }
+
+      String key = val.getName(i);
+      if (key==null) key="";
+      indent();
+      writeKey(key, true);
+      writeVal(key,val.getVal(i));
+    }
+
+    decLevel();
+    writeMapCloser();
+  }
+
+  // Represents a NamedList directly as an array of JSON objects...
+  // NamedList("a"=1,"b"=2,null=3) => [{"a":1},{"b":2},3]
+  protected void writeNamedListAsArrMap(String name, NamedList val) throws IOException {
+    int sz = val.size();
+    indent();
+    writeArrayOpener(sz);
+    incLevel();
+
+    boolean first=true;
+    for (int i=0; i<sz; i++) {
+      String key = val.getName(i);
+
+      if (first) {
+        first=false;
+      } else {
+        writeArraySeparator();
+      }
+
+      indent();
+
+      if (key==null) {
+        writeVal(null,val.getVal(i));
+      } else {
+        writeMapOpener(1);
+        writeKey(key, true);
+        writeVal(key,val.getVal(i));
+        writeMapCloser();
+      }
+
+    }
+
+    decLevel();
+    writeArrayCloser();
+  }
+
+  // Represents a NamedList directly as an array of JSON objects...
+  // NamedList("a"=1,"b"=2,null=3) => [["a",1],["b",2],[null,3]]
+  protected void writeNamedListAsArrArr(String name, NamedList val) throws IOException {
+    int sz = val.size();
+    indent();
+    writeArrayOpener(sz);
+    incLevel();
+
+    boolean first=true;
+    for (int i=0; i<sz; i++) {
+      String key = val.getName(i);
+
+      if (first) {
+        first=false;
+      } else {
+        writeArraySeparator();
+      }
+
+      indent();
+
+      /*** if key is null, just write value???
+      if (key==null) {
+        writeVal(null,val.getVal(i));
+      } else {
+     ***/
+
+        writeArrayOpener(1);
+        incLevel();
+        if (key==null) {
+          writeNull(null);
+        } else {
+          writeStr(null, key, true);
+        }
+        writeArraySeparator();
+        writeVal(key,val.getVal(i));
+        decLevel();
+        writeArrayCloser();
+    }
+
+    decLevel();
+    writeArrayCloser();
+  }
+
+  // Represents a NamedList directly as an array with keys/values
+  // interleaved.
+  // NamedList("a"=1,"b"=2,null=3) => ["a",1,"b",2,null,3]
+  protected void writeNamedListAsFlat(String name, NamedList val) throws IOException {
+    int sz = val.size();
+    writeArrayOpener(sz);
+    incLevel();
+
+    for (int i=0; i<sz; i++) {
+      if (i!=0) {
+        writeArraySeparator();
+      }
+      String key = val.getName(i);
+      indent();
+      if (key==null) {
+        writeNull(null);
+      } else {
+        writeStr(null, key, true);
+      }
+      writeArraySeparator();
+      writeVal(key, val.getVal(i));
+    }
+
+    decLevel();
+    writeArrayCloser();
+  }
+
+
+  public void writeNamedList(String name, NamedList val) throws IOException {
+    if (val instanceof SimpleOrderedMap) {
+      writeNamedListAsMapWithDups(name,val);
+    } else if (namedListStyle==JSON_NL_FLAT) {
+      writeNamedListAsFlat(name,val);
+    } else if (namedListStyle==JSON_NL_MAP){
+      writeNamedListAsMapWithDups(name,val);
+    } else if (namedListStyle==JSON_NL_ARROFARR) {
+      writeNamedListAsArrArr(name,val);
+    } else if (namedListStyle==JSON_NL_ARROFMAP) {
+      writeNamedListAsArrMap(name,val);
+    }
+  }
+
+
+  protected static class MultiValueField {
+    final SchemaField sfield;
+    final ArrayList<Fieldable> fields;
+    MultiValueField(SchemaField sfield, Fieldable firstVal) {
+      this.sfield = sfield;
+      this.fields = new ArrayList<Fieldable>(4);
+      this.fields.add(firstVal);
+    }
+  }
+
+  public void writeDoc(String name, Collection<Fieldable> fields, Set<String> returnFields, Map pseudoFields) throws IOException {
+    writeMapOpener(-1); // no trivial way to determine map size
+    incLevel();
+
+    HashMap<String, MultiValueField> multi = new HashMap<String, MultiValueField>();
+
+    boolean first=true;
+
+    for (Fieldable ff : fields) {
+      String fname = ff.name();
+      if (returnFields!=null && !returnFields.contains(fname)) {
+        continue;
+      }
+
+      // if the field is multivalued, it may have other values further on... so
+      // build up a list for each multi-valued field.
+      SchemaField sf = schema.getField(fname);
+      if (sf.multiValued()) {
+        MultiValueField mf = multi.get(fname);
+        if (mf==null) {
+          mf = new MultiValueField(sf, ff);
+          multi.put(fname, mf);
+        } else {
+          mf.fields.add(ff);
+        }
+      } else {
+        // not multi-valued, so write it immediately.
+        if (first) {
+          first=false;
+        } else {
+          writeMapSeparator();
+        }
+        indent();
+        writeKey(fname,true);
+        sf.write(this, fname, ff);
+      }
+    }
+
+    for(MultiValueField mvf : multi.values()) {
+      if (first) {
+        first=false;
+      } else {
+        writeMapSeparator();
+      }
+
+      indent();
+      writeKey(mvf.sfield.getName(), true);
+
+      boolean indentArrElems=false;
+      if (doIndent) {
+        // heuristic... TextField is probably the only field type likely to be long enough
+        // to warrant indenting individual values.
+        indentArrElems = (mvf.sfield.getType() instanceof TextField);
+      }
+
+      writeArrayOpener(-1); // no trivial way to determine array size
+      boolean firstArrElem=true;
+      incLevel();
+
+      for (Fieldable ff : mvf.fields) {
+        if (firstArrElem) {
+          firstArrElem=false;
+        } else {
+          writeArraySeparator();
+        }
+        if (indentArrElems) indent();
+        mvf.sfield.write(this, null, ff);
+      }
+      writeArrayCloser();
+      decLevel();
+    }
+
+    if (pseudoFields !=null && pseudoFields.size()>0) {
+      writeMap(null,pseudoFields,true,first);
+    }
+
+    decLevel();
+    writeMapCloser();
+  }
+
+  public void writeSolrDocument(String name, SolrDocument doc, Set<String> returnFields, Map pseudoFields) throws IOException {
+    writeMapOpener(-1); // no trivial way to determine map size
+    // TODO: could easily figure out size for SolrDocument if needed...
+    incLevel();
+
+    boolean first=true;
+    for (String fname : doc.getFieldNames()) {
+      if (first) {
+        first=false;
+      }
+      else {
+        writeMapSeparator();
+      }
+
+      indent();
+      writeKey(fname, true);
+      Object val = doc.getFieldValue(fname);
+
+      if (val instanceof Collection) {
+        writeVal(fname, val);
+      } else {
+        // if multivalued field, write single value as an array
+        SchemaField sf = schema.getFieldOrNull(fname);
+        if (sf != null && sf.multiValued()) {
+          writeArrayOpener(-1); // no trivial way to determine array size
+          writeVal(fname, val);
+          writeArrayCloser();
+        } else {
+          writeVal(fname, val);
+        }
+      }
+
+      if (pseudoFields !=null && pseudoFields.size()>0) {
+        writeMap(null,pseudoFields,true,first);
+      }
+    }
+
+    decLevel();
+    writeMapCloser();
+  }
+
+
+  // reusable map to store the "score" pseudo-field.
+  // if a Doc can ever contain another doc, this optimization would have to go.
+  private final HashMap scoreMap = new HashMap(1);
+
+  public void writeDoc(String name, Document doc, Set<String> returnFields, float score, boolean includeScore) throws IOException {
+    Map other = null;
+    if (includeScore) {
+      other = scoreMap;
+      scoreMap.put("score",score);
+    }
+    writeDoc(name, (List<Fieldable>)(doc.getFields()), returnFields, other);
+  }
+
+  public void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException {
+    boolean includeScore=false;
+    if (fields!=null) {
+      includeScore = fields.contains("score");
+      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
+        fields=null;  // null means return all stored fields
+      }
+    }
+
+    int sz=ids.size();
+
+    writeMapOpener(includeScore ? 4 : 3);
+    incLevel();
+    writeKey("numFound",false);
+    writeInt(null,ids.matches());
+    writeMapSeparator();
+    writeKey("start",false);
+    writeInt(null,ids.offset());
+
+    if (includeScore) {
+      writeMapSeparator();
+      writeKey("maxScore",false);
+      writeFloat(null,ids.maxScore());
+    }
+    writeMapSeparator();
+    // indent();
+    writeKey("docs",false);
+    writeArrayOpener(sz);
+
+    incLevel();
+    boolean first=true;
+
+    SolrIndexSearcher searcher = req.getSearcher();
+    DocIterator iterator = ids.iterator();
+    for (int i=0; i<sz; i++) {
+      int id = iterator.nextDoc();
+      Document doc = searcher.doc(id, fields);
+
+      if (first) {
+        first=false;
+      } else {
+        writeArraySeparator();
+      }
+      indent();
+      writeDoc(null, doc, fields, (includeScore ? iterator.score() : 0.0f), includeScore);
+    }
+    decLevel();
+    writeArrayCloser();
+
+    if (otherFields !=null) {
+      writeMap(null, otherFields, true, false);
+    }
+
+    decLevel();
+    indent();
+    writeMapCloser();
+  }
+
+
+  @Override
+  public void writeSolrDocumentList(String name, SolrDocumentList docs, Set<String> fields, Map otherFields) throws IOException {
+    boolean includeScore=false;
+    if (fields!=null) {
+      includeScore = fields.contains("score");
+      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
+        fields=null;  // null means return all stored fields
+      }
+    }
+
+    int sz=docs.size();
+
+    writeMapOpener(includeScore ? 4 : 3);
+    incLevel();
+    writeKey("numFound",false);
+    writeLong(null,docs.getNumFound());
+    writeMapSeparator();
+    writeKey("start",false);
+    writeLong(null,docs.getStart());
+
+    if (includeScore && docs.getMaxScore() != null) {
+      writeMapSeparator();
+      writeKey("maxScore",false);
+      writeFloat(null,docs.getMaxScore());
+    }
+    writeMapSeparator();
+    // indent();
+    writeKey("docs",false);
+    writeArrayOpener(sz);
+
+    incLevel();
+    boolean first=true;
+
+    SolrIndexSearcher searcher = req.getSearcher();
+    for (SolrDocument doc : docs) {
+
+      if (first) {
+        first=false;
+      } else {
+        writeArraySeparator();
+      }
+      indent();      
+      writeSolrDocument(null, doc, fields, otherFields);
+    }
+    decLevel();
+    writeArrayCloser();
+
+    if (otherFields !=null) {
+      writeMap(null, otherFields, true, false);
+    }
+
+    decLevel();
+    indent();
+    writeMapCloser();
+  }
+
+
+  //
+  // Data structure tokens
+  // NOTE: a positive size paramater indicates the number of elements
+  //       contained in an array or map, a negative value indicates 
+  //       that the size could not be reliably determined.
+  // 
+  
+  public void writeMapOpener(int size) throws IOException, IllegalArgumentException {
+    writer.write('{');
+  }
+  
+  public void writeMapSeparator() throws IOException {
+    writer.write(',');
+  }
+
+  public void writeMapCloser() throws IOException {
+    writer.write('}');
+  }
+  
+  public void writeArrayOpener(int size) throws IOException, IllegalArgumentException {
+    writer.write('[');
+  }
+  
+  public void writeArraySeparator() throws IOException {
+    writer.write(',');
+  }
+
+  public void writeArrayCloser() throws IOException {
+    writer.write(']');
+  }
+
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    // it might be more efficient to use a stringbuilder or write substrings
+    // if writing chars to the stream is slow.
+    if (needsEscaping) {
+
+
+     /* http://www.ietf.org/internet-drafts/draft-crockford-jsonorg-json-04.txt
+      All Unicode characters may be placed within
+      the quotation marks except for the characters which must be
+      escaped: quotation mark, reverse solidus, and the control
+      characters (U+0000 through U+001F).
+     */
+      writer.write('"');
+
+      for (int i=0; i<val.length(); i++) {
+        char ch = val.charAt(i);
+        if ((ch > '#' && ch != '\\') || ch==' ') { // fast path
+          writer.write(ch);
+          continue;
+        }
+        switch(ch) {
+          case '"':
+          case '\\':
+            writer.write('\\');
+            writer.write(ch);
+            break;
+          case '\r': writer.write('\\'); writer.write('r'); break;
+          case '\n': writer.write('\\'); writer.write('n'); break;
+          case '\t': writer.write('\\'); writer.write('t'); break;
+          case '\b': writer.write('\\'); writer.write('b'); break;
+          case '\f': writer.write('\\'); writer.write('f'); break;
+          // case '/':
+          default: {
+            if (ch <= 0x1F) {
+              unicodeEscape(writer,ch);
+            } else {
+              writer.write(ch);
+            }
+          }
+        }
+      }
+
+      writer.write('"');
+    } else {
+      writer.write('"');
+      writer.write(val);
+      writer.write('"');
+    }
+  }
+
+
+  public void writeMap(String name, Map val, boolean excludeOuter, boolean isFirstVal) throws IOException {
+    if (!excludeOuter) {
+      writeMapOpener(val.size());
+      incLevel();
+      isFirstVal=true;
+    }
+
+    boolean doIndent = excludeOuter || val.size() > 1;
+
+    for (Map.Entry entry : (Set<Map.Entry>)val.entrySet()) {
+      Object e = entry.getKey();
+      String k = e==null ? "" : e.toString();
+      Object v = entry.getValue();
+
+      if (isFirstVal) {
+        isFirstVal=false;
+      } else {
+        writeMapSeparator();
+      }
+
+      if (doIndent) indent();
+      writeKey(k,true);
+      writeVal(k,v);
+    }
+
+    if (!excludeOuter) {
+      decLevel();
+      writeMapCloser();
+    }
+  }
+
+  public void writeArray(String name, Object[] val) throws IOException {
+    writeArray(name, Arrays.asList(val).iterator());
+  }
+
+  public void writeArray(String name, Iterator val) throws IOException {
+    writeArrayOpener(-1); // no trivial way to determine array size
+    incLevel();
+    boolean first=true;
+    while( val.hasNext() ) {
+      if( !first ) indent();
+      writeVal(null, val.next());
+      if( val.hasNext() ) {
+        writeArraySeparator();
+      }
+      first=false;
+    }
+    decLevel();
+    writeArrayCloser();
+  }
+
+  //
+  // Primitive types
+  //
+  public void writeNull(String name) throws IOException {
+    writer.write("null");
+  }
+
+  public void writeInt(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+  public void writeLong(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+  public void writeBool(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+  public void writeFloat(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+  public void writeDouble(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+   @Override
+  public void writeShort(String name, String val) throws IOException {
+    writer.write(val);
+  }
+
+  public void writeByte(String name, String val) throws IOException {
+    writer.write(val);
+
+  }
+
+  // TODO: refactor this out to a DateUtils class or something...
+  public void writeDate(String name, Date val) throws IOException {
+    // using a stringBuilder for numbers can be nice since
+    // a temporary string isn't used (it's added directly to the
+    // builder's buffer.
+
+    StringBuilder sb = new StringBuilder();
+    if (cal==null) cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
+    cal.setTime(val);
+
+    int i = cal.get(Calendar.YEAR);
+    sb.append(i);
+    sb.append('-');
+    i = cal.get(Calendar.MONTH) + 1;  // 0 based, so add 1
+    if (i<10) sb.append('0');
+    sb.append(i);
+    sb.append('-');
+    i=cal.get(Calendar.DAY_OF_MONTH);
+    if (i<10) sb.append('0');
+    sb.append(i);
+    sb.append('T');
+    i=cal.get(Calendar.HOUR_OF_DAY); // 24 hour time format
+    if (i<10) sb.append('0');
+    sb.append(i);
+    sb.append(':');
+    i=cal.get(Calendar.MINUTE);
+    if (i<10) sb.append('0');
+    sb.append(i);
+    sb.append(':');
+    i=cal.get(Calendar.SECOND);
+    if (i<10) sb.append('0');
+    sb.append(i);
+    i=cal.get(Calendar.MILLISECOND);
+    if (i != 0) {
+      sb.append('.');
+      if (i<100) sb.append('0');
+      if (i<10) sb.append('0');
+      sb.append(i);
+
+      // handle canonical format specifying fractional
+      // seconds shall not end in '0'.  Given the slowness of
+      // integer div/mod, simply checking the last character
+      // is probably the fastest way to check.
+      int lastIdx = sb.length()-1;
+      if (sb.charAt(lastIdx)=='0') {
+        lastIdx--;
+        if (sb.charAt(lastIdx)=='0') {
+          lastIdx--;
+        }
+        sb.setLength(lastIdx+1);
+      }
+
+    }
+    sb.append('Z');
+    writeDate(name, sb.toString());
+  }
+
+  public void writeDate(String name, String val) throws IOException {
+    writeStr(name, val, false);
+  }
+
+  private static char[] hexdigits = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
+  protected static void unicodeEscape(Appendable out, int ch) throws IOException {
+    out.append('\\');
+    out.append('u');
+    out.append(hexdigits[(ch>>>12)     ]);
+    out.append(hexdigits[(ch>>>8) & 0xf]);
+    out.append(hexdigits[(ch>>>4) & 0xf]);
+    out.append(hexdigits[(ch)     & 0xf]);
+  }
+
+}
+
+abstract class NaNFloatWriter extends JSONWriter {
+  
+  abstract protected String getNaN();
+  abstract protected String getInf();
+
+  public NaNFloatWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    super(writer, req, rsp);
+  }
+
+  @Override
+  public void writeFloat(String name, float val) throws IOException {
+    if (Float.isNaN(val)) {
+      writer.write(getNaN());
+    } else if (Float.isInfinite(val)) {
+      if (val < 0.0f)
+        writer.write('-');
+      writer.write(getInf());
+    } else {
+      writeFloat(name, Float.toString(val));
+    }
+  }
+
+  @Override
+  public void writeDouble(String name, double val) throws IOException {
+    if (Double.isNaN(val)) {
+      writer.write(getNaN());
+    } else if (Double.isInfinite(val)) {
+      if (val < 0.0)
+        writer.write('-');
+      writer.write(getInf());
+    } else {
+      writeDouble(name, Double.toString(val));
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/response/PHPResponseWriter.java b/src/java/org/apache/solr/response/PHPResponseWriter.java
new file mode 100755
index 0000000..f94c9df
--- /dev/null
+++ b/src/java/org/apache/solr/response/PHPResponseWriter.java
@@ -0,0 +1,109 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+
+public class PHPResponseWriter implements QueryResponseWriter {
+  static String CONTENT_TYPE_PHP_UTF8="text/x-php;charset=UTF-8";
+
+  public void init(NamedList n) {
+    /* NOOP */
+  }
+  
+ public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    PHPWriter w = new PHPWriter(writer, req, rsp);
+    try {
+      w.writeResponse();
+    } finally {
+      w.close();
+    }
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return CONTENT_TYPE_TEXT_UTF8;
+  }
+}
+
+class PHPWriter extends JSONWriter {
+  public PHPWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    super(writer, req, rsp);
+  }
+  
+  @Override
+  public void writeNamedList(String name, NamedList val) throws IOException {
+    writeNamedListAsMapMangled(name,val);
+  }
+
+  @Override
+  public void writeMapOpener(int size) throws IOException {
+    writer.write("array(");
+  }
+
+  @Override
+  public void writeMapCloser() throws IOException {
+    writer.write(')');
+  }
+
+  @Override
+  public void writeArrayOpener(int size) throws IOException {
+    writer.write("array(");
+  }
+
+  @Override
+  public void writeArrayCloser() throws IOException {
+    writer.write(')');
+  }
+
+  @Override
+  public void writeNull(String name) throws IOException {
+    writer.write("null");
+  }
+
+  @Override
+  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
+    writeStr(null, fname, needsEscaping);
+    writer.write('=');
+    writer.write('>');
+  }
+
+  @Override
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    if (needsEscaping) {
+      writer.write('\'');
+      for (int i=0; i<val.length(); i++) {
+        char ch = val.charAt(i);
+        switch (ch) {
+          case '\'':
+          case '\\': writer.write('\\'); writer.write(ch); break;
+          default:
+            writer.write(ch);
+        }
+      }
+      writer.write('\'');
+    } else {
+      writer.write('\'');
+      writer.write(val);
+      writer.write('\'');
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/response/PHPSerializedResponseWriter.java b/src/java/org/apache/solr/response/PHPSerializedResponseWriter.java
new file mode 100755
index 0000000..3ca560e
--- /dev/null
+++ b/src/java/org/apache/solr/response/PHPSerializedResponseWriter.java
@@ -0,0 +1,330 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+import java.util.*;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.util.UnicodeUtil;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.SchemaField;
+import org.apache.solr.search.DocIterator;
+import org.apache.solr.search.DocList;
+import org.apache.solr.search.SolrIndexSearcher;
+
+/**
+ * A description of the PHP serialization format can be found here:
+ * http://www.hurring.com/scott/code/perl/serialize/
+ *
+ * <p>
+ * In order to support PHP Serialized strings with a proper byte count, This ResponseWriter
+ * must know if the Writers passed to it will result in an output of CESU-8 (UTF-8 w/o support
+ * for large code points outside of the BMP)
+ * <p>
+ * Currently Solr assumes that all Jetty servlet containers (detected using the "jetty.home"
+ * system property) use CESU-8 instead of UTF-8 (verified to the current release of 6.1.20).
+ * <p>
+ * In installations where Solr auto-detects incorrectly, the Solr Administrator should set the
+ * "solr.phps.cesu8" system property to either "true" or "false" accordingly.
+ */
+public class PHPSerializedResponseWriter implements QueryResponseWriter {
+  static String CONTENT_TYPE_PHP_UTF8="text/x-php-serialized;charset=UTF-8";
+
+  // Is this servlet container's UTF-8 encoding actually CESU-8 (i.e. lacks support for
+  // large characters outside the BMP).
+  boolean CESU8 = false;
+  public void init(NamedList n) {
+    String cesu8Setting = System.getProperty("solr.phps.cesu8");
+    if (cesu8Setting != null) {
+      CESU8="true".equals(cesu8Setting);
+    } else {
+      // guess at the setting.
+      // Jetty up until 6.1.20 at least (and probably versions after) uses CESU8
+      CESU8 = System.getProperty("jetty.home") != null;
+    }
+  }
+  
+ public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    PHPSerializedWriter w = new PHPSerializedWriter(writer, req, rsp, CESU8);
+    try {
+      w.writeResponse();
+    } finally {
+      w.close();
+    }
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return CONTENT_TYPE_TEXT_UTF8;
+  }
+}
+
+class PHPSerializedWriter extends JSONWriter {
+  final private boolean CESU8;
+  final UnicodeUtil.UTF8Result utf8;
+
+  public PHPSerializedWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp, boolean CESU8) {
+    super(writer, req, rsp);
+    this.CESU8 = CESU8;
+    this.utf8 = CESU8 ? null : new UnicodeUtil.UTF8Result();
+    // never indent serialized PHP data
+    doIndent = false;
+  }
+
+  public void writeResponse() throws IOException {
+    Boolean omitHeader = req.getParams().getBool(CommonParams.OMIT_HEADER);
+    if(omitHeader != null && omitHeader) rsp.getValues().remove("responseHeader");
+    writeNamedList(null, rsp.getValues());
+  }
+  
+  @Override
+  public void writeNamedList(String name, NamedList val) throws IOException {
+    writeNamedListAsMapMangled(name,val);
+  }
+  
+  @Override
+  public void writeDoc(String name, Collection<Fieldable> fields, Set<String> returnFields, Map pseudoFields) throws IOException {
+    ArrayList<Fieldable> single = new ArrayList<Fieldable>();
+    HashMap<String, MultiValueField> multi = new HashMap<String, MultiValueField>();
+
+    for (Fieldable ff : fields) {
+      String fname = ff.name();
+      if (returnFields!=null && !returnFields.contains(fname)) {
+        continue;
+      }
+      // if the field is multivalued, it may have other values further on... so
+      // build up a list for each multi-valued field.
+      SchemaField sf = schema.getField(fname);
+      if (sf.multiValued()) {
+        MultiValueField mf = multi.get(fname);
+        if (mf==null) {
+          mf = new MultiValueField(sf, ff);
+          multi.put(fname, mf);
+        } else {
+          mf.fields.add(ff);
+        }
+      } else {
+        single.add(ff);
+      }
+    }
+
+    // obtain number of fields in doc
+    writeArrayOpener(single.size() + multi.size() + ((pseudoFields!=null) ? pseudoFields.size() : 0));
+
+    // output single value fields
+    for(Fieldable ff : single) {
+      SchemaField sf = schema.getField(ff.name());
+      writeKey(ff.name(),true);
+      sf.write(this, ff.name(), ff);
+    }
+    
+    // output multi value fields
+    for(MultiValueField mvf : multi.values()) {
+      writeKey(mvf.sfield.getName(), true);
+      writeArrayOpener(mvf.fields.size());
+      int i = 0;
+      for (Fieldable ff : mvf.fields) {
+        writeKey(i++, false);
+        mvf.sfield.write(this, null, ff);
+      }
+      writeArrayCloser();
+    }
+
+    // output pseudo fields
+    if (pseudoFields !=null && pseudoFields.size()>0) {
+      writeMap(null,pseudoFields,true,false);
+    }
+    writeArrayCloser();
+  }
+  
+  @Override
+  public void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException {
+    boolean includeScore=false;
+    
+    if (fields!=null) {
+      includeScore = fields.contains("score");
+      if (fields.size()==0 || (fields.size()==1 && includeScore) || fields.contains("*")) {
+        fields=null;  // null means return all stored fields
+      }
+    }
+
+    int sz=ids.size();
+
+    writeMapOpener(includeScore ? 4 : 3);
+    writeKey("numFound",false);
+    writeInt(null,ids.matches());
+    writeKey("start",false);
+    writeInt(null,ids.offset());
+
+    if (includeScore) {
+      writeKey("maxScore",false);
+      writeFloat(null,ids.maxScore());
+    }
+    writeKey("docs",false);
+    writeArrayOpener(sz);
+
+    SolrIndexSearcher searcher = req.getSearcher();
+    DocIterator iterator = ids.iterator();
+    for (int i=0; i<sz; i++) {
+      int id = iterator.nextDoc();
+      Document doc = searcher.doc(id, fields);
+      writeKey(i, false);
+      writeDoc(null, doc, fields, (includeScore ? iterator.score() : 0.0f), includeScore);
+    }
+    writeMapCloser();
+
+    if (otherFields !=null) {
+      writeMap(null, otherFields, true, false);
+    }
+
+    writeMapCloser();
+  }
+  
+  @Override
+  public void writeArray(String name, Object[] val) throws IOException {
+    writeMapOpener(val.length);
+    for(int i=0; i < val.length; i++) {
+      writeKey(i, false);
+      writeVal(String.valueOf(i), val[i]);
+    }
+    writeMapCloser();
+  }
+
+  @Override
+  public void writeArray(String name, Iterator val) throws IOException {
+    ArrayList vals = new ArrayList();
+    while( val.hasNext() ) {
+      vals.add(val.next());
+    }
+    writeArray(name, vals.toArray());
+  }
+  
+  @Override
+  public void writeMapOpener(int size) throws IOException, IllegalArgumentException {
+  	// negative size value indicates that something has gone wrong
+  	if (size < 0) {
+  		throw new IllegalArgumentException("Map size must not be negative");
+  	}
+    writer.write("a:"+size+":{");
+  }
+  
+  @Override
+  public void writeMapSeparator() throws IOException {
+    /* NOOP */
+  }
+
+  @Override
+  public void writeMapCloser() throws IOException {
+    writer.write('}');
+  }
+
+  @Override
+  public void writeArrayOpener(int size) throws IOException, IllegalArgumentException {
+  	// negative size value indicates that something has gone wrong
+  	if (size < 0) {
+  		throw new IllegalArgumentException("Array size must not be negative");
+  	}
+    writer.write("a:"+size+":{");
+  }
+
+  @Override  
+  public void writeArraySeparator() throws IOException {
+    /* NOOP */
+  }
+
+  @Override
+  public void writeArrayCloser() throws IOException {
+    writer.write('}');
+  }
+  
+  @Override
+  public void writeNull(String name) throws IOException {
+    writer.write("N;");
+  }
+
+  @Override
+  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
+    writeStr(null, fname, needsEscaping);
+  }
+  void writeKey(int val, boolean needsEscaping) throws IOException {
+    writeInt(null, String.valueOf(val));
+  }
+
+  @Override
+  public void writeBool(String name, boolean val) throws IOException {
+    writer.write(val ? "b:1;" : "b:0;");
+  }
+
+  @Override
+  public void writeBool(String name, String val) throws IOException {
+    writeBool(name, val.charAt(0) == 't');
+  }
+  
+  @Override
+  public void writeInt(String name, String val) throws IOException {
+    writer.write("i:"+val+";");
+  }
+  
+  @Override
+  public void writeLong(String name, String val) throws IOException {
+    writeInt(name,val);
+  }
+
+  @Override
+  public void writeFloat(String name, String val) throws IOException {
+    writeDouble(name,val);
+  }
+
+  @Override
+  public void writeDouble(String name, String val) throws IOException {
+    writer.write("d:"+val+";");
+  }
+
+  @Override
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    // serialized PHP strings don't need to be escaped at all, however the 
+    // string size reported needs be the number of bytes rather than chars.
+    int nBytes;
+    if (CESU8) {
+      nBytes = 0;
+      for (int i=0; i<val.length(); i++) {
+        char ch = val.charAt(i);
+        if (ch<='\u007f') {
+          nBytes += 1;
+        } else if (ch<='\u07ff') {
+          nBytes += 2;
+        } else {
+          nBytes += 3;
+        }
+      }
+    } else {
+      UnicodeUtil.UTF16toUTF8(val, 0, val.length(), utf8);
+      nBytes = utf8.length;
+    }
+
+    writer.write("s:");
+    writer.write(Integer.toString(nBytes));
+    writer.write(":\"");
+    writer.write(val);
+    writer.write("\";");
+  }
+}
diff --git a/src/java/org/apache/solr/response/PythonResponseWriter.java b/src/java/org/apache/solr/response/PythonResponseWriter.java
new file mode 100644
index 0000000..181a936
--- /dev/null
+++ b/src/java/org/apache/solr/response/PythonResponseWriter.java
@@ -0,0 +1,147 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+
+public class PythonResponseWriter implements QueryResponseWriter {
+  static String CONTENT_TYPE_PYTHON_ASCII="text/x-python;charset=US-ASCII";
+
+  public void init(NamedList n) {
+    /* NOOP */
+  }
+  
+  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    PythonWriter w = new PythonWriter(writer, req, rsp);
+    try {
+      w.writeResponse();
+    } finally {
+      w.close();
+    }
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return CONTENT_TYPE_TEXT_ASCII;
+  }
+}
+
+class PythonWriter extends NaNFloatWriter {
+  protected String getNaN() { return "float('NaN')"; }
+  protected String getInf() { return "float('Inf')"; }
+
+  public PythonWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    super(writer, req, rsp);
+  }
+
+  @Override
+  public void writeNull(String name) throws IOException {
+    writer.write("None");
+  }
+
+  @Override
+  public void writeBool(String name, boolean val) throws IOException {
+    writer.write(val ? "True" : "False");
+  }
+
+  @Override
+  public void writeBool(String name, String val) throws IOException {
+    writeBool(name,val.charAt(0)=='t');
+  }
+
+  /* optionally use a unicode python string if necessary */
+  @Override
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    if (!needsEscaping) {
+      writer.write('\'');
+      writer.write(val);
+      writer.write('\'');
+      return;
+    }
+
+    // use python unicode strings...
+    // python doesn't tolerate newlines in strings in it's eval(), so we must escape them.
+
+    StringBuilder sb = new StringBuilder(val.length());
+    boolean needUnicode=false;
+
+    for (int i=0; i<val.length(); i++) {
+      char ch = val.charAt(i);
+      switch(ch) {
+        case '\'':
+        case '\\': sb.append('\\'); sb.append(ch); break;
+        case '\r': sb.append("\\r"); break;
+        case '\n': sb.append("\\n"); break;
+        case '\t': sb.append("\\t"); break;
+        default:
+          // we don't strictly have to escape these chars, but it will probably increase
+          // portability to stick to visible ascii
+          if (ch<' ' || ch>127) {
+            unicodeEscape(sb, ch);
+            needUnicode=true;
+          } else {
+            sb.append(ch);
+          }
+      }
+    }
+
+    if (needUnicode) {
+      writer.write('u');
+    }
+    writer.write('\'');
+    writer.append(sb);
+    writer.write('\'');
+  }
+
+  /*
+  old version that always used unicode
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    // use python unicode strings...
+    // python doesn't tolerate newlines in strings in it's eval(), so we must escape them.
+    writer.write("u'");
+    // it might be more efficient to use a stringbuilder or write substrings
+    // if writing chars to the stream is slow.
+    if (needsEscaping) {
+      for (int i=0; i<val.length(); i++) {
+        char ch = val.charAt(i);
+        switch(ch) {
+          case '\'':
+          case '\\': writer.write('\\'); writer.write(ch); break;
+          case '\r': writer.write("\\r"); break;
+          case '\n': writer.write("\\n"); break;
+          default:
+            // we don't strictly have to escape these chars, but it will probably increase
+            // portability to stick to visible ascii
+            if (ch<' ' || ch>127) {
+              unicodeChar(ch);
+            } else {
+              writer.write(ch);
+            }
+        }
+      }
+    } else {
+      writer.write(val);
+    }
+    writer.write('\'');
+  }
+  */
+
+}
diff --git a/src/java/org/apache/solr/response/QueryResponseWriter.java b/src/java/org/apache/solr/response/QueryResponseWriter.java
new file mode 100644
index 0000000..db500a1
--- /dev/null
+++ b/src/java/org/apache/solr/response/QueryResponseWriter.java
@@ -0,0 +1,87 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.util.plugin.NamedListInitializedPlugin;
+
+/**
+ * Implementations of <code>QueryResponseWriter</code> are used to format responses to query requests.
+ *
+ * Different <code>QueryResponseWriter</code>s are registered with the <code>SolrCore</code>.
+ * One way to register a QueryResponseWriter with the core is through the <code>solrconfig.xml</code> file.
+ * <p>
+ * Example <code>solrconfig.xml</code> entry to register a <code>QueryResponseWriter</code> implementation to
+ * handle all queries with a writer type of "simple":
+ * <p>
+ * <code>
+ *    &lt;queryResponseWriter name="simple" class="foo.SimpleResponseWriter" /&gt;
+ * </code>
+ * <p>
+ * A single instance of any registered QueryResponseWriter is created
+ * via the default constructor and is reused for all relevant queries.
+ *
+ * @version $Id$
+ */
+public interface QueryResponseWriter extends NamedListInitializedPlugin {
+  public static String CONTENT_TYPE_XML_UTF8="text/xml; charset=UTF-8";
+  public static String CONTENT_TYPE_TEXT_UTF8="text/plain; charset=UTF-8";
+  public static String CONTENT_TYPE_TEXT_ASCII="text/plain; charset=US-ASCII";
+
+  /**
+   * Write a SolrQueryResponse, this method must be thread save.
+   *
+   * <p>
+   * Information about the request (in particular: formating options) may be 
+   * obtained from <code>req</code> but the dominant source of information 
+   * should be <code>rsp</code>.
+   * <p>
+   * There are no mandatory actions that write must perform.
+   * An empty write implementation would fulfill
+   * all interface obligations.
+   * </p> 
+   */
+  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException;
+
+  /** 
+   * Return the applicable Content Type for a request, this method 
+   * must be thread safe.
+   *
+   * <p>
+   * QueryResponseWriter's must implement this method to return a valid 
+   * HTTP Content-Type header for the request, that will logically 
+   * correspond with the output produced by the write method.
+   * </p>
+   * @return a Content-Type string, which may not be null.
+   */
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response);
+  
+  /** <code>init</code> will be called just once, immediately after creation.
+   * <p>The args are user-level initialization parameters that
+   * may be specified when declaring a response writer in
+   * solrconfig.xml
+   */
+  public void init(NamedList args);
+}
+
+
+
diff --git a/src/java/org/apache/solr/response/RawResponseWriter.java b/src/java/org/apache/solr/response/RawResponseWriter.java
new file mode 100644
index 0000000..849ff5c
--- /dev/null
+++ b/src/java/org/apache/solr/response/RawResponseWriter.java
@@ -0,0 +1,90 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+
+/**
+ * Writes a ContentStream directly to the output.
+ *
+ * <p>
+ * This writer is a special case that extends and alters the
+ * QueryResponseWriter contract.  If SolrQueryResponse contains a
+ * ContentStream added with the key {@link #CONTENT}
+ * then this writer will output that stream exactly as is (with it's
+ * Content-Type).  if no such ContentStream has been added, then a
+ * "base" QueryResponseWriter will be used to write the response
+ * according to the usual contract.  The name of the "base" writer can
+ * be specified as an initialization param for this writer, or it
+ * defaults to the "standard" writer.
+ * </p>
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class RawResponseWriter implements QueryResponseWriter 
+{
+  /** 
+   * The key that should be used to add a ContentStream to the 
+   * SolrQueryResponse if you intend to use this Writer.
+   */
+  public static final String CONTENT = "content";
+  private String _baseWriter = null;
+  
+  public void init(NamedList n) {
+    if( n != null ) {
+      Object base = n.get( "base" );
+      if( base != null ) {
+        _baseWriter = base.toString();
+      }
+    }
+  }
+
+  // Even if this is null, it should be ok
+  protected QueryResponseWriter getBaseWriter( SolrQueryRequest request )
+  {
+    return request.getCore().getQueryResponseWriter( _baseWriter );
+  }
+  
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    Object obj = response.getValues().get( CONTENT );
+    if( obj != null && (obj instanceof ContentStream ) ) {
+      return ((ContentStream)obj).getContentType();
+    }
+    return getBaseWriter( request ).getContentType( request, response );
+  }
+
+  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException 
+  {
+    Object obj = response.getValues().get( CONTENT );
+    if( obj != null && (obj instanceof ContentStream ) ) {
+      // copy the contents to the writer...
+      ContentStream content = (ContentStream)obj;
+      IOUtils.copy( content.getReader(), writer );
+    }
+    else {
+      getBaseWriter( request ).write( writer, request, response );
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/response/RubyResponseWriter.java b/src/java/org/apache/solr/response/RubyResponseWriter.java
new file mode 100644
index 0000000..7ee0b5b
--- /dev/null
+++ b/src/java/org/apache/solr/response/RubyResponseWriter.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+
+public class RubyResponseWriter implements QueryResponseWriter {
+  static String CONTENT_TYPE_RUBY_UTF8="text/x-ruby;charset=UTF-8";
+
+  public void init(NamedList n) {
+    /* NOOP */
+  }
+  
+ public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    RubyWriter w = new RubyWriter(writer, req, rsp);
+    try {
+      w.writeResponse();
+    } finally {
+      w.close();
+    }
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return CONTENT_TYPE_TEXT_UTF8;
+  }
+}
+
+class RubyWriter extends NaNFloatWriter {
+
+  protected String getNaN() { return "(0.0/0.0)"; }
+  protected String getInf() { return "(1.0/0.0)"; }
+
+  public RubyWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    super(writer, req, rsp);
+  }
+
+  @Override
+  public void writeNull(String name) throws IOException {
+    writer.write("nil");
+  }
+
+  @Override
+  protected void writeKey(String fname, boolean needsEscaping) throws IOException {
+    writeStr(null, fname, needsEscaping);
+    writer.write('=');
+    writer.write('>');
+  }
+
+  @Override
+  public void writeStr(String name, String val, boolean needsEscaping) throws IOException {
+    // Ruby doesn't do unicode escapes... so let the servlet container write raw UTF-8
+    // bytes into the string.
+    //
+    // Use single quoted strings for safety since no evaluation is done within them.
+    // Also, there are very few escapes recognized in a single quoted string, so
+    // only escape the backslash and single quote.
+    writer.write('\'');
+    if (needsEscaping) {
+      for (int i=0; i<val.length(); i++) {
+        char ch = val.charAt(i);
+        if (ch=='\'' || ch=='\\') {
+          writer.write('\\');
+        }
+        writer.write(ch);
+      }
+    } else {
+      writer.write(val);
+    }
+    writer.write('\'');
+  }
+}
diff --git a/src/java/org/apache/solr/response/SolrQueryResponse.java b/src/java/org/apache/solr/response/SolrQueryResponse.java
new file mode 100644
index 0000000..fc3de1a
--- /dev/null
+++ b/src/java/org/apache/solr/response/SolrQueryResponse.java
@@ -0,0 +1,229 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+import java.util.*;
+
+/**
+ * <code>SolrQueryResponse</code> is used by a query handler to return
+ * the response to a query request.
+ *
+ * <p>
+ * <a name="returnable_data" /><b>Note On Returnable Data...</b><br/>
+ * A <code>SolrQueryResponse</code> may contain the following types of
+ * Objects generated by the <code>SolrRequestHandler</code> that processed
+ * the request.
+ * </p>
+ * <ul>
+ *  <li>{@link String}</li>
+ *  <li>{@link Integer}</li>
+ *  <li>{@link Long}</li>
+ *  <li>{@link Float}</li>
+ *  <li>{@link Double}</li>
+ *  <li>{@link Boolean}</li>
+ *  <li>{@link Date}</li>
+ *  <li>{@link org.apache.solr.search.DocList}</li>
+ *  <li>{@link org.apache.solr.common.SolrDocument} (since 1.3)</li>
+ *  <li>{@link org.apache.solr.common.SolrDocumentList} (since 1.3)</li>
+ *  <li>{@link Map} containing any of the items in this list</li>
+ *  <li>{@link NamedList} containing any of the items in this list</li>
+ *  <li>{@link Collection} containing any of the items in this list</li>
+ *  <li>Array containing any of the items in this list</li>
+ *  <li>null</li>
+ * </ul>
+ * <p>
+ * Other data types may be added to the SolrQueryResponse, but there is no guarantee
+ * that QueryResponseWriters will be able to deal with unexpected types.
+ * </p>
+ *
+ * @version $Id$
+ * @since solr 0.9
+ */
+public class SolrQueryResponse {
+
+  /**
+   * Container for user defined values
+   * @see #getValues
+   * @see #add
+   * @see #setAllValues
+   * @see <a href="#returnable_data">Note on Returnable Data</a>
+   */
+  protected NamedList values = new SimpleOrderedMap();
+
+  /**
+   * Container for storing information that should be logged by Solr before returning.
+   */
+  protected NamedList toLog = new SimpleOrderedMap();
+
+  protected Set<String> defaultReturnFields;
+
+  // error if this is set...
+  protected Exception err;
+
+  /**
+   * Should this response be tagged with HTTP caching headers?
+   */
+  protected boolean httpCaching=true;
+  
+  /***
+   // another way of returning an error
+  int errCode;
+  String errMsg;
+  ***/
+
+  public SolrQueryResponse() {
+  }
+  
+  
+  /**
+   * Gets data to be returned in this response
+   * @see <a href="#returnable_data">Note on Returnable Data</a>
+   */
+  public NamedList getValues() { return values; }
+
+  /**
+   * Sets data to be returned in this response
+   * @see <a href="#returnable_data">Note on Returnable Data</a>
+   */
+  public void setAllValues(NamedList nameValuePairs) {
+    values=nameValuePairs;
+  }
+
+  /**
+   * Sets the document field names of fields to return by default when
+   * returning DocLists
+   */
+  public void setReturnFields(Set<String> fields) {
+    defaultReturnFields=fields;
+  }
+  // TODO: should this be represented as a String[] such
+  // that order can be maintained if needed?
+
+  /**
+   * Gets the document field names of fields to return by default when
+   * returning DocLists
+   */
+  public Set<String> getReturnFields() {
+    return defaultReturnFields;
+  }
+
+
+  /**
+   * Appends a named value to the list of named values to be returned.
+   * @param name  the name of the value - may be null if unnamed
+   * @param val   the value to add - also may be null since null is a legal value
+   * @see <a href="#returnable_data">Note on Returnable Data</a>
+   */
+  public void add(String name, Object val) {
+    values.add(name,val);
+  }
+
+  /**
+   * Causes an error to be returned instead of the results.
+   */
+  public void setException(Exception e) {
+    err=e;
+  }
+
+  /**
+   * Returns an Exception if there was a fatal error in processing the request.
+   * Returns null if the request succeeded.
+   */
+  public Exception getException() {
+    return err;
+  }
+
+  /**
+   * The endtime of the request in milliseconds.
+   * Used to calculate query time.
+   * @see #setEndTime(long)
+   * @see #getEndTime()
+   */
+  protected long endtime;
+
+  /**
+   * Get the time in milliseconds when the response officially finished. 
+   */
+  public long getEndTime() {
+    if (endtime==0) {
+      setEndTime();
+    }
+    return endtime;
+  }
+
+  /**
+   * Stop the timer for how long this query took.
+   * @see #setEndTime(long)
+   */
+  public long setEndTime() {
+    return setEndTime(System.currentTimeMillis());
+  }
+
+  /**
+   * Set the in milliseconds when the response officially finished. 
+   * @see #setEndTime()
+   */
+  public long setEndTime(long endtime) {
+    if (endtime!=0) {
+      this.endtime=endtime;
+    }
+    return this.endtime;
+  }
+  
+  /** Repsonse header to be logged */ 
+  public NamedList getResponseHeader() {
+	  SimpleOrderedMap<Object> header = (SimpleOrderedMap<Object>) values.get("responseHeader");
+	  return header;
+  }
+  
+  /** Add a value to be logged.
+   * 
+   * @param name name of the thing to log
+   * @param val value of the thing to log
+   */
+  public void addToLog(String name, Object val) {
+	  toLog.add(name, val);
+  }
+  
+  /** Get loggable items.
+   * 
+   * @return things to log
+   */
+  public NamedList getToLog() {
+	  return toLog;
+  }
+  
+  /**
+   * Enables or disables the emission of HTTP caching headers for this response.
+   * @param httpCaching true=emit caching headers, false otherwise
+   */
+  public void setHttpCaching(boolean httpCaching) {
+    this.httpCaching=httpCaching;
+  }
+  
+  /**
+   * Should this response emit HTTP caching headers?
+   * @return true=yes emit headers, false otherwise
+   */
+  public boolean isHttpCaching() {
+    return this.httpCaching;
+  }
+}
diff --git a/src/java/org/apache/solr/response/TextResponseWriter.java b/src/java/org/apache/solr/response/TextResponseWriter.java
new file mode 100644
index 0000000..456e661
--- /dev/null
+++ b/src/java/org/apache/solr/response/TextResponseWriter.java
@@ -0,0 +1,245 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import org.apache.lucene.document.Document;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.FastWriter;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.search.DocList;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+/** Base class for text-oriented response writers.
+ *
+ * @version $Id$
+ */
+public abstract class TextResponseWriter {
+  
+  protected final FastWriter writer;
+  protected final IndexSchema schema;
+  protected final SolrQueryRequest req;
+  protected final SolrQueryResponse rsp;
+
+  // the default set of fields to return for each document
+  protected Set<String> returnFields;
+
+  protected int level;
+  protected boolean doIndent;
+
+
+  public TextResponseWriter(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) {
+    this.writer = FastWriter.wrap(writer);
+    this.schema = req.getSchema();
+    this.req = req;
+    this.rsp = rsp;
+    String indent = req.getParams().get("indent");
+    if (indent != null && !"".equals(indent) && !"off".equals(indent)) {
+      doIndent=true;
+    }
+    returnFields = rsp.getReturnFields();
+  }
+
+  /** done with this ResponseWriter... make sure any buffers are flushed to writer */
+  public void close() throws IOException {
+    writer.flushBuffer();
+  }
+
+  /** returns the Writer that the response is being written to */
+  public Writer getWriter() { return writer; }
+
+  // use a combination of tabs and spaces to minimize the size of an indented response.
+  private static final String[] indentArr = new String[] {
+    "\n",
+    "\n ",
+    "\n  ",
+    "\n\t",
+    "\n\t ",
+    "\n\t  ",  // could skip this one (the only 3 char seq)
+    "\n\t\t",
+    "\n\t\t "};
+
+  public void indent() throws IOException {
+     if (doIndent) indent(level);
+  }
+
+  public void indent(int lev) throws IOException {
+    int arrsz = indentArr.length-1;
+    // power-of-two intent array (gratuitous optimization :-)
+    String istr = indentArr[lev & (indentArr.length-1)];
+    writer.write(istr);
+  }
+
+  //
+  // Functions to manipulate the current logical nesting level.
+  // Any indentation will be partially based on level.
+  //
+  public void setLevel(int level) { this.level = level; }
+  public int level() { return level; }
+  public int incLevel() { return ++level; }
+  public int decLevel() { return --level; }
+  public void setIndent(boolean doIndent) {
+    this.doIndent = doIndent;
+  }
+
+
+  public abstract void writeNamedList(String name, NamedList val) throws IOException;
+
+  public void writeVal(String name, Object val) throws IOException {
+
+    // if there get to be enough types, perhaps hashing on the type
+    // to get a handler might be faster (but types must be exact to do that...)
+
+    // go in order of most common to least common
+    if (val==null) {
+      writeNull(name);
+    } else if (val instanceof String) {
+      writeStr(name, val.toString(), true);
+      // micro-optimization... using toString() avoids a cast first
+    } else if (val instanceof Integer) {
+      writeInt(name, val.toString());
+    } else if (val instanceof Boolean) {
+      writeBool(name, val.toString());
+    } else if (val instanceof Long) {
+      writeLong(name, val.toString());
+    } else if (val instanceof Date) {
+      writeDate(name,(Date)val);
+    } else if (val instanceof Float) {
+      // we pass the float instead of using toString() because
+      // it may need special formatting. same for double.
+      writeFloat(name, ((Float)val).floatValue());
+    } else if (val instanceof Double) {
+      writeDouble(name, ((Double)val).doubleValue());
+    } else if (val instanceof Document) {
+      writeDoc(name, (Document)val, returnFields, 0.0f, false);
+    } else if (val instanceof SolrDocument) {
+      writeSolrDocument(name, (SolrDocument)val, returnFields, null);
+    } else if (val instanceof DocList) {
+      // requires access to IndexReader
+      writeDocList(name, (DocList)val, returnFields,null);
+    // }
+    // else if (val instanceof DocSet) {
+    // how do we know what fields to read?
+    // todo: have a DocList/DocSet wrapper that
+    // restricts the fields to write...?
+    } else if (val instanceof SolrDocumentList) {
+      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields, null);
+    } else if (val instanceof Map) {
+      writeMap(name, (Map)val, false, true);
+    } else if (val instanceof NamedList) {
+      writeNamedList(name, (NamedList)val);
+    } else if (val instanceof Iterable) {
+      writeArray(name,((Iterable)val).iterator());
+    } else if (val instanceof Object[]) {
+      writeArray(name,(Object[])val);
+    } else if (val instanceof Iterator) {
+      writeArray(name,(Iterator)val);
+    } else {
+      // default... for debugging only
+      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
+    }
+  }
+
+  // names are passed when writing primitives like writeInt to allow many different
+  // types of formats, including those where the name may come after the value (like
+  // some XML formats).
+
+  public abstract void writeDoc(String name, Document doc, Set<String> returnFields, float score, boolean includeScore) throws IOException;
+
+  /**
+   * @since solr 1.3
+   */
+  public abstract void writeSolrDocument(String name, SolrDocument doc, Set<String> returnFields, Map pseudoFields) throws IOException;  
+
+  public abstract void writeDocList(String name, DocList ids, Set<String> fields, Map otherFields) throws IOException;
+
+  /**
+   * @since solr 1.3
+   */
+  public abstract void writeSolrDocumentList(String name, SolrDocumentList docs, Set<String> fields, Map otherFields) throws IOException;  
+
+  public abstract void writeStr(String name, String val, boolean needsEscaping) throws IOException;
+
+  public abstract void writeMap(String name, Map val, boolean excludeOuter, boolean isFirstVal) throws IOException;
+
+  public abstract void writeArray(String name, Object[] val) throws IOException;
+
+  public abstract void writeArray(String name, Iterator val) throws IOException;
+
+  public abstract void writeNull(String name) throws IOException;
+
+  /** if this form of the method is called, val is the Java string form of an int */
+  public abstract void writeInt(String name, String val) throws IOException;
+
+  public void writeInt(String name, int val) throws IOException {
+    writeInt(name,Integer.toString(val));
+  }
+
+  /** if this form of the method is called, val is the Java string form of a long */
+  public abstract void writeLong(String name, String val) throws IOException;
+
+  public  void writeLong(String name, long val) throws IOException {
+    writeLong(name,Long.toString(val));
+  }
+
+  /** if this form of the method is called, val is the Java string form of a boolean */
+  public abstract void writeBool(String name, String val) throws IOException;
+
+  public void writeBool(String name, boolean val) throws IOException {
+    writeBool(name,Boolean.toString(val));
+  }
+
+  /** if this form of the method is called, val is the Java string form of a float */
+  public abstract void writeFloat(String name, String val) throws IOException;
+
+  public void writeFloat(String name, float val) throws IOException {
+    writeFloat(name,Float.toString(val));
+  }
+
+  /** if this form of the method is called, val is the Java string form of a double */
+  public abstract void writeDouble(String name, String val) throws IOException;
+
+  public void writeDouble(String name, double val) throws IOException {
+    writeDouble(name,Double.toString(val));
+  }
+
+  public abstract void writeDate(String name, Date val) throws IOException;
+
+  /** if this form of the method is called, val is the Solr ISO8601 based date format */
+  public abstract void writeDate(String name, String val) throws IOException;
+
+  public abstract void writeShort(String name, String val) throws IOException;
+
+  public void writeShort(String name, short val) throws IOException{
+    writeShort(name, Short.toString(val));
+  }
+
+  public abstract void writeByte(String name, String s) throws IOException;
+
+  public void writeByte(String name, byte val) throws IOException{
+    writeByte(name, Byte.toString(val));
+  }
+}
diff --git a/src/java/org/apache/solr/response/XMLResponseWriter.java b/src/java/org/apache/solr/response/XMLResponseWriter.java
new file mode 100644
index 0000000..c113b8b
--- /dev/null
+++ b/src/java/org/apache/solr/response/XMLResponseWriter.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.Writer;
+import java.io.IOException;
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.XMLWriter;
+
+/**
+ * @version $Id$
+ */
+public class XMLResponseWriter implements QueryResponseWriter {
+  public void init(NamedList n) {
+    /* NOOP */
+  }
+
+  public void write(Writer writer, SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {
+    XMLWriter.writeResponse(writer,req,rsp);
+  }
+
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    return CONTENT_TYPE_XML_UTF8;
+  }
+}
diff --git a/src/java/org/apache/solr/response/XSLTResponseWriter.java b/src/java/org/apache/solr/response/XSLTResponseWriter.java
new file mode 100644
index 0000000..7942121
--- /dev/null
+++ b/src/java/org/apache/solr/response/XSLTResponseWriter.java
@@ -0,0 +1,125 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.response;
+
+import java.io.BufferedReader;
+import java.io.CharArrayReader;
+import java.io.CharArrayWriter;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.Map;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.XMLWriter;
+import org.apache.solr.util.xslt.TransformerProvider;
+
+/** QueryResponseWriter which captures the output of the XMLWriter
+ *  (in memory for now, not optimal performancewise), and applies an XSLT transform
+ *  to it.
+ */
+public class XSLTResponseWriter implements QueryResponseWriter {
+
+  public static final String DEFAULT_CONTENT_TYPE = "text/xml";
+  public static final String TRANSFORM_PARAM = "tr";
+  public static final String CONTEXT_TRANSFORMER_KEY = "xsltwriter.transformer";
+  
+  private Integer xsltCacheLifetimeSeconds = null; 
+  public static final int XSLT_CACHE_DEFAULT = 60;
+  private static final String XSLT_CACHE_PARAM = "xsltCacheLifetimeSeconds"; 
+
+  private static final Logger log = LoggerFactory.getLogger(XSLTResponseWriter.class);
+  
+  public void init(NamedList n) {
+      final SolrParams p = SolrParams.toSolrParams(n);
+      xsltCacheLifetimeSeconds = p.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);
+      log.info("xsltCacheLifetimeSeconds=" + xsltCacheLifetimeSeconds);
+  }
+
+  
+  public String getContentType(SolrQueryRequest request, SolrQueryResponse response) {
+    Transformer t = null;
+    try {
+      t = getTransformer(request);
+    } catch(Exception e) {
+      // TODO should our parent interface throw (IO)Exception?
+      throw new RuntimeException("getTransformer fails in getContentType",e);
+    }
+    
+    final String mediaTypeFromXslt = t.getOutputProperty("media-type");
+    if(mediaTypeFromXslt == null || mediaTypeFromXslt.length()==0) {
+      // This did not happen in my tests, mediaTypeFromXslt is set to "text/xml"
+      // if the XSLT transform does not contain an xsl:output element. Not sure
+      // if this is standard behavior or if it's just my JVM/libraries
+      return DEFAULT_CONTENT_TYPE;
+    }
+    return mediaTypeFromXslt;
+  }
+
+  public void write(Writer writer, SolrQueryRequest request, SolrQueryResponse response) throws IOException {
+    final Transformer t = getTransformer(request);
+    
+    // capture the output of the XMLWriter
+    final CharArrayWriter w = new CharArrayWriter();
+    XMLWriter.writeResponse(w,request,response);
+    
+    // and write transformed result to our writer
+    final Reader r = new BufferedReader(new CharArrayReader(w.toCharArray()));
+    final StreamSource source = new StreamSource(r);
+    final StreamResult result = new StreamResult(writer);
+    try {
+      t.transform(source, result);
+    } catch(TransformerException te) {
+      final IOException ioe = new IOException("XSLT transformation error");
+      ioe.initCause(te);
+      throw ioe;
+    }
+  }
+  
+  /** Get Transformer from request context, or from TransformerProvider.
+   *  This allows either getContentType(...) or write(...) to instantiate the Transformer,
+   *  depending on which one is called first, then the other one reuses the same Transformer
+   */
+  protected Transformer getTransformer(SolrQueryRequest request) throws IOException {
+    final String xslt = request.getParams().get(TRANSFORM_PARAM,null);
+    if(xslt==null) {
+      throw new IOException("'" + TRANSFORM_PARAM + "' request parameter is required to use the XSLTResponseWriter");
+    }
+    // not the cleanest way to achieve this
+    SolrConfig solrConfig = request.getCore().getSolrConfig();
+    // no need to synchronize access to context, right? 
+    // Nothing else happens with it at the same time
+    final Map<Object,Object> ctx = request.getContext();
+    Transformer result = (Transformer)ctx.get(CONTEXT_TRANSFORMER_KEY);
+    if(result==null) {
+      result = TransformerProvider.instance.getTransformer(solrConfig, xslt,xsltCacheLifetimeSeconds.intValue());
+      ctx.put(CONTEXT_TRANSFORMER_KEY,result);
+    }
+    return result;
+  }
+}
diff --git a/src/java/org/apache/solr/schema/BCDIntField.java b/src/java/org/apache/solr/schema/BCDIntField.java
index 4745e9e..04b90bf 100644
--- a/src/java/org/apache/solr/schema/BCDIntField.java
+++ b/src/java/org/apache/solr/schema/BCDIntField.java
@@ -22,7 +22,7 @@ import org.apache.solr.search.function.ValueSource;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.util.BCDUtils;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/BinaryField.java b/src/java/org/apache/solr/schema/BinaryField.java
index f7fdcfc..da5231b 100644
--- a/src/java/org/apache/solr/schema/BinaryField.java
+++ b/src/java/org/apache/solr/schema/BinaryField.java
@@ -18,7 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.common.util.Base64;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.Field;
diff --git a/src/java/org/apache/solr/schema/BoolField.java b/src/java/org/apache/solr/schema/BoolField.java
index 834d7a0..d4417a8 100644
--- a/src/java/org/apache/solr/schema/BoolField.java
+++ b/src/java/org/apache/solr/schema/BoolField.java
@@ -27,7 +27,7 @@ import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.analysis.SolrAnalyzer;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/schema/ByteField.java b/src/java/org/apache/solr/schema/ByteField.java
index ecb4d37..ca2712b 100644
--- a/src/java/org/apache/solr/schema/ByteField.java
+++ b/src/java/org/apache/solr/schema/ByteField.java
@@ -19,8 +19,8 @@ package org.apache.solr.schema;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.ByteFieldSource;
 
diff --git a/src/java/org/apache/solr/schema/DateField.java b/src/java/org/apache/solr/schema/DateField.java
index b784861..d215cbc 100644
--- a/src/java/org/apache/solr/schema/DateField.java
+++ b/src/java/org/apache/solr/schema/DateField.java
@@ -25,8 +25,8 @@ import org.apache.lucene.search.TermRangeQuery;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.util.DateUtil;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.*;
 import org.apache.solr.util.DateMathParser;
diff --git a/src/java/org/apache/solr/schema/DoubleField.java b/src/java/org/apache/solr/schema/DoubleField.java
index 832ada3..21ad1fe 100644
--- a/src/java/org/apache/solr/schema/DoubleField.java
+++ b/src/java/org/apache/solr/schema/DoubleField.java
@@ -19,8 +19,8 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.DoubleFieldSource;
 import org.apache.solr.search.function.ValueSource;
 
diff --git a/src/java/org/apache/solr/schema/ExternalFileField.java b/src/java/org/apache/solr/schema/ExternalFileField.java
index 59c3142..8dc3a0f 100755
--- a/src/java/org/apache/solr/schema/ExternalFileField.java
+++ b/src/java/org/apache/solr/schema/ExternalFileField.java
@@ -23,7 +23,7 @@ import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.solr.search.function.FileFloatSource;
 import org.apache.solr.search.QParser;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.common.SolrException;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/schema/FieldType.java b/src/java/org/apache/solr/schema/FieldType.java
index 3bcb046..d3ee13f 100644
--- a/src/java/org/apache/solr/schema/FieldType.java
+++ b/src/java/org/apache/solr/schema/FieldType.java
@@ -33,7 +33,7 @@ import org.apache.solr.search.function.OrdFieldSource;
 import org.apache.solr.search.Sorting;
 import org.apache.solr.search.QParser;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.analysis.SolrAnalyzer;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.SolrParams;
diff --git a/src/java/org/apache/solr/schema/FloatField.java b/src/java/org/apache/solr/schema/FloatField.java
index eeb0fd2..2b88fe6 100644
--- a/src/java/org/apache/solr/schema/FloatField.java
+++ b/src/java/org/apache/solr/schema/FloatField.java
@@ -22,7 +22,7 @@ import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/GeoHashField.java b/src/java/org/apache/solr/schema/GeoHashField.java
index cf4892e..194506f 100644
--- a/src/java/org/apache/solr/schema/GeoHashField.java
+++ b/src/java/org/apache/solr/schema/GeoHashField.java
@@ -20,8 +20,8 @@ package org.apache.solr.schema;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.distance.DistanceUtils;
diff --git a/src/java/org/apache/solr/schema/IntField.java b/src/java/org/apache/solr/schema/IntField.java
index 15d2e3a..35e333e 100644
--- a/src/java/org/apache/solr/schema/IntField.java
+++ b/src/java/org/apache/solr/schema/IntField.java
@@ -22,7 +22,7 @@ import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Fieldable;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/LegacyDateField.java b/src/java/org/apache/solr/schema/LegacyDateField.java
index 8a6364f..40328ab 100644
--- a/src/java/org/apache/solr/schema/LegacyDateField.java
+++ b/src/java/org/apache/solr/schema/LegacyDateField.java
@@ -19,7 +19,7 @@ package org.apache.solr.schema;
 
 import org.apache.solr.common.SolrException;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.search.function.ValueSource;
diff --git a/src/java/org/apache/solr/schema/LongField.java b/src/java/org/apache/solr/schema/LongField.java
index 3f33177..0179f65 100644
--- a/src/java/org/apache/solr/schema/LongField.java
+++ b/src/java/org/apache/solr/schema/LongField.java
@@ -19,8 +19,8 @@ package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.IntFieldSource;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.LongFieldSource;
diff --git a/src/java/org/apache/solr/schema/PointType.java b/src/java/org/apache/solr/schema/PointType.java
index a9f4cf3..bd0990e 100644
--- a/src/java/org/apache/solr/schema/PointType.java
+++ b/src/java/org/apache/solr/schema/PointType.java
@@ -26,8 +26,8 @@ import org.apache.lucene.search.SortField;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.VectorValueSource;
 import org.apache.solr.search.function.ValueSource;
diff --git a/src/java/org/apache/solr/schema/RandomSortField.java b/src/java/org/apache/solr/schema/RandomSortField.java
index edbfc15..23036ca 100644
--- a/src/java/org/apache/solr/schema/RandomSortField.java
+++ b/src/java/org/apache/solr/schema/RandomSortField.java
@@ -23,8 +23,8 @@ import java.util.Map;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.*;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.DocValues;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.SolrIndexReader;
diff --git a/src/java/org/apache/solr/schema/SchemaField.java b/src/java/org/apache/solr/schema/SchemaField.java
index 8acd41e..a04fae0 100644
--- a/src/java/org/apache/solr/schema/SchemaField.java
+++ b/src/java/org/apache/solr/schema/SchemaField.java
@@ -21,7 +21,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/ShortField.java b/src/java/org/apache/solr/schema/ShortField.java
index 7451455..408f6bb 100644
--- a/src/java/org/apache/solr/schema/ShortField.java
+++ b/src/java/org/apache/solr/schema/ShortField.java
@@ -19,8 +19,8 @@ package org.apache.solr.schema;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.ShortFieldSource;
 
diff --git a/src/java/org/apache/solr/schema/SortableDoubleField.java b/src/java/org/apache/solr/schema/SortableDoubleField.java
index 359edb1..bfb2c30 100644
--- a/src/java/org/apache/solr/schema/SortableDoubleField.java
+++ b/src/java/org/apache/solr/schema/SortableDoubleField.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/SortableFloatField.java b/src/java/org/apache/solr/schema/SortableFloatField.java
index d70252d..9b11fcb 100644
--- a/src/java/org/apache/solr/schema/SortableFloatField.java
+++ b/src/java/org/apache/solr/schema/SortableFloatField.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/SortableIntField.java b/src/java/org/apache/solr/schema/SortableIntField.java
index 152ac04..263cb1e 100644
--- a/src/java/org/apache/solr/schema/SortableIntField.java
+++ b/src/java/org/apache/solr/schema/SortableIntField.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/SortableLongField.java b/src/java/org/apache/solr/schema/SortableLongField.java
index 4ee5032..8b7457f 100644
--- a/src/java/org/apache/solr/schema/SortableLongField.java
+++ b/src/java/org/apache/solr/schema/SortableLongField.java
@@ -26,7 +26,7 @@ import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/src/java/org/apache/solr/schema/SpatialTileField.java b/src/java/org/apache/solr/schema/SpatialTileField.java
index 7285771..fad26f7 100644
--- a/src/java/org/apache/solr/schema/SpatialTileField.java
+++ b/src/java/org/apache/solr/schema/SpatialTileField.java
@@ -29,8 +29,8 @@ import org.apache.solr.common.ResourceLoader;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.params.MapSolrParams;
 import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.distance.DistanceUtils;
diff --git a/src/java/org/apache/solr/schema/StrField.java b/src/java/org/apache/solr/schema/StrField.java
index 4847910..3b8cb87 100644
--- a/src/java/org/apache/solr/schema/StrField.java
+++ b/src/java/org/apache/solr/schema/StrField.java
@@ -21,7 +21,7 @@ import org.apache.lucene.search.SortField;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.FieldCacheSource;
 import org.apache.solr.search.function.DocValues;
diff --git a/src/java/org/apache/solr/schema/TextField.java b/src/java/org/apache/solr/schema/TextField.java
index 4c7e88f..edf8eae 100644
--- a/src/java/org/apache/solr/schema/TextField.java
+++ b/src/java/org/apache/solr/schema/TextField.java
@@ -32,7 +32,7 @@ import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 
 import java.util.Map;
diff --git a/src/java/org/apache/solr/schema/TrieDateField.java b/src/java/org/apache/solr/schema/TrieDateField.java
index 029d935..d4d79c1 100755
--- a/src/java/org/apache/solr/schema/TrieDateField.java
+++ b/src/java/org/apache/solr/schema/TrieDateField.java
@@ -25,7 +25,7 @@ import org.apache.solr.analysis.TrieTokenizerFactory;
 import org.apache.solr.search.function.*;
 import org.apache.solr.search.QParser;
 import org.apache.solr.request.XMLWriter;
-import org.apache.solr.request.TextResponseWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.search.SortField;
diff --git a/src/java/org/apache/solr/schema/TrieField.java b/src/java/org/apache/solr/schema/TrieField.java
index bbe87f7..31b59df 100644
--- a/src/java/org/apache/solr/schema/TrieField.java
+++ b/src/java/org/apache/solr/schema/TrieField.java
@@ -24,8 +24,8 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.NumericTokenStream;
 import org.apache.solr.analysis.*;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.*;
 
diff --git a/src/java/org/apache/solr/schema/UUIDField.java b/src/java/org/apache/solr/schema/UUIDField.java
index 41c4af3..30a8e36 100644
--- a/src/java/org/apache/solr/schema/UUIDField.java
+++ b/src/java/org/apache/solr/schema/UUIDField.java
@@ -24,8 +24,8 @@ import java.util.UUID;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.request.TextResponseWriter;
 import org.apache.solr.request.XMLWriter;
+import org.apache.solr.response.TextResponseWriter;
 
 /**
  * This FieldType accepts UUID string values, as well as the special value 
diff --git a/src/java/org/apache/solr/tst/OldRequestHandler.java b/src/java/org/apache/solr/tst/OldRequestHandler.java
index fb05852..0a815f7 100644
--- a/src/java/org/apache/solr/tst/OldRequestHandler.java
+++ b/src/java/org/apache/solr/tst/OldRequestHandler.java
@@ -30,8 +30,8 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * @version $Id$
diff --git a/src/java/org/apache/solr/tst/TestRequestHandler.java b/src/java/org/apache/solr/tst/TestRequestHandler.java
index 9a5dd60..a40a6be 100644
--- a/src/java/org/apache/solr/tst/TestRequestHandler.java
+++ b/src/java/org/apache/solr/tst/TestRequestHandler.java
@@ -36,7 +36,7 @@ import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * @version $Id$
diff --git a/src/java/org/apache/solr/update/processor/LogUpdateProcessorFactory.java b/src/java/org/apache/solr/update/processor/LogUpdateProcessorFactory.java
index b238a9c..750e10c 100644
--- a/src/java/org/apache/solr/update/processor/LogUpdateProcessorFactory.java
+++ b/src/java/org/apache/solr/update/processor/LogUpdateProcessorFactory.java
@@ -25,7 +25,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
diff --git a/src/java/org/apache/solr/update/processor/RunUpdateProcessorFactory.java b/src/java/org/apache/solr/update/processor/RunUpdateProcessorFactory.java
index 14ca807..3a91cda 100644
--- a/src/java/org/apache/solr/update/processor/RunUpdateProcessorFactory.java
+++ b/src/java/org/apache/solr/update/processor/RunUpdateProcessorFactory.java
@@ -20,7 +20,7 @@ package org.apache.solr.update.processor;
 import java.io.IOException;
 
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
diff --git a/src/java/org/apache/solr/update/processor/SignatureUpdateProcessorFactory.java b/src/java/org/apache/solr/update/processor/SignatureUpdateProcessorFactory.java
index 0934617..b32d36f 100755
--- a/src/java/org/apache/solr/update/processor/SignatureUpdateProcessorFactory.java
+++ b/src/java/org/apache/solr/update/processor/SignatureUpdateProcessorFactory.java
@@ -29,7 +29,7 @@ import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.AddUpdateCommand;
 import org.apache.solr.update.CommitUpdateCommand;
 import org.apache.solr.update.DeleteUpdateCommand;
diff --git a/src/java/org/apache/solr/update/processor/UpdateRequestProcessorChain.java b/src/java/org/apache/solr/update/processor/UpdateRequestProcessorChain.java
index 0c7a9f1..1e635e8 100644
--- a/src/java/org/apache/solr/update/processor/UpdateRequestProcessorChain.java
+++ b/src/java/org/apache/solr/update/processor/UpdateRequestProcessorChain.java
@@ -18,7 +18,7 @@
 package org.apache.solr.update.processor;
 
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.plugin.PluginInfoInitialized;
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrCore;
diff --git a/src/java/org/apache/solr/update/processor/UpdateRequestProcessorFactory.java b/src/java/org/apache/solr/update/processor/UpdateRequestProcessorFactory.java
index 0515085..3de6459 100644
--- a/src/java/org/apache/solr/update/processor/UpdateRequestProcessorFactory.java
+++ b/src/java/org/apache/solr/update/processor/UpdateRequestProcessorFactory.java
@@ -20,7 +20,7 @@ package org.apache.solr.update.processor;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
diff --git a/src/java/org/apache/solr/util/SolrPluginUtils.java b/src/java/org/apache/solr/util/SolrPluginUtils.java
index f7dc638..9cc04c3 100644
--- a/src/java/org/apache/solr/util/SolrPluginUtils.java
+++ b/src/java/org/apache/solr/util/SolrPluginUtils.java
@@ -35,7 +35,7 @@ import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.highlight.SolrHighlighter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.*;
diff --git a/src/java/org/apache/solr/util/TestHarness.java b/src/java/org/apache/solr/util/TestHarness.java
index e713ba4..5b916ce 100644
--- a/src/java/org/apache/solr/util/TestHarness.java
+++ b/src/java/org/apache/solr/util/TestHarness.java
@@ -27,9 +27,9 @@ import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 import org.w3c.dom.Document;
 import org.xml.sax.SAXException;
diff --git a/src/test/org/apache/solr/BasicFunctionalityTest.java b/src/test/org/apache/solr/BasicFunctionalityTest.java
index 35a6041..4d98654 100644
--- a/src/test/org/apache/solr/BasicFunctionalityTest.java
+++ b/src/test/org/apache/solr/BasicFunctionalityTest.java
@@ -30,6 +30,7 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.search.*;
 import org.apache.solr.handler.*;
 import org.apache.solr.request.*;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.SolrIndexWriter;
 import org.apache.solr.util.*;
 import org.apache.solr.schema.*;
diff --git a/src/test/org/apache/solr/OutputWriterTest.java b/src/test/org/apache/solr/OutputWriterTest.java
index a021f06..54c2e20 100644
--- a/src/test/org/apache/solr/OutputWriterTest.java
+++ b/src/test/org/apache/solr/OutputWriterTest.java
@@ -21,9 +21,9 @@ import java.io.IOException;
 import java.io.Writer;
 
 import org.apache.solr.common.util.NamedList;
-import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 /** Tests the ability to configure multiple query output writers, and select those
diff --git a/src/test/org/apache/solr/core/MockQuerySenderListenerReqHandler.java b/src/test/org/apache/solr/core/MockQuerySenderListenerReqHandler.java
index 8755274..6d4dc75 100644
--- a/src/test/org/apache/solr/core/MockQuerySenderListenerReqHandler.java
+++ b/src/test/org/apache/solr/core/MockQuerySenderListenerReqHandler.java
@@ -18,7 +18,7 @@ package org.apache.solr.core;
 
 import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 
 /**
diff --git a/src/test/org/apache/solr/core/ResourceLoaderTest.java b/src/test/org/apache/solr/core/ResourceLoaderTest.java
index 3d78af8..5b386f0 100644
--- a/src/test/org/apache/solr/core/ResourceLoaderTest.java
+++ b/src/test/org/apache/solr/core/ResourceLoaderTest.java
@@ -25,7 +25,7 @@ import org.apache.solr.analysis.NGramFilterFactory;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.handler.admin.LukeRequestHandler;
 import org.apache.solr.handler.component.FacetComponent;
-import org.apache.solr.request.JSONResponseWriter;
+import org.apache.solr.response.JSONResponseWriter;
 import org.apache.solr.util.plugin.ResourceLoaderAware;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
diff --git a/src/test/org/apache/solr/core/SolrCoreTest.java b/src/test/org/apache/solr/core/SolrCoreTest.java
index 6d889aa..9c6a609 100755
--- a/src/test/org/apache/solr/core/SolrCoreTest.java
+++ b/src/test/org/apache/solr/core/SolrCoreTest.java
@@ -21,8 +21,8 @@ import org.apache.solr.handler.RequestHandlerBase;
 import org.apache.solr.handler.component.SpellCheckComponent;
 import org.apache.solr.handler.component.QueryComponent;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
diff --git a/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java b/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
index c943a2c..1942bf7 100644
--- a/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
+++ b/src/test/org/apache/solr/handler/MoreLikeThisHandlerTest.java
@@ -31,7 +31,7 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequestBase;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 
diff --git a/src/test/org/apache/solr/handler/component/SpellCheckComponentTest.java b/src/test/org/apache/solr/handler/component/SpellCheckComponentTest.java
index bbbd9ca..3130b2d 100644
--- a/src/test/org/apache/solr/handler/component/SpellCheckComponentTest.java
+++ b/src/test/org/apache/solr/handler/component/SpellCheckComponentTest.java
@@ -28,8 +28,8 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.spelling.AbstractLuceneSpellChecker;
 import org.apache.solr.spelling.IndexBasedSpellChecker;
 import org.apache.solr.util.AbstractSolrTestCase;
diff --git a/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java b/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java
index 2fbcfab..16de7f6 100644
--- a/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java
+++ b/src/test/org/apache/solr/handler/component/TermVectorComponentTest.java
@@ -8,8 +8,8 @@ import org.apache.solr.common.params.TermVectorParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.LocalSolrQueryRequest;
+import org.apache.solr.response.SolrQueryResponse;
 
 import java.util.HashMap;
 import java.util.ArrayList;
diff --git a/src/test/org/apache/solr/handler/component/TermsComponentTest.java b/src/test/org/apache/solr/handler/component/TermsComponentTest.java
index bf54f3f..1b54c42 100644
--- a/src/test/org/apache/solr/handler/component/TermsComponentTest.java
+++ b/src/test/org/apache/solr/handler/component/TermsComponentTest.java
@@ -24,7 +24,7 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.request.LocalSolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 import java.util.regex.Pattern;
 
diff --git a/src/test/org/apache/solr/request/JSONWriterTest.java b/src/test/org/apache/solr/request/JSONWriterTest.java
index ee222c7..015009f 100644
--- a/src/test/org/apache/solr/request/JSONWriterTest.java
+++ b/src/test/org/apache/solr/request/JSONWriterTest.java
@@ -22,6 +22,12 @@ import java.io.Writer;
 import java.io.StringWriter;
 
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.response.JSONResponseWriter;
+import org.apache.solr.response.PHPSerializedResponseWriter;
+import org.apache.solr.response.PythonResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.RubyResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 /** Test some aspects of JSON/python writer output (very incomplete)
diff --git a/src/test/org/apache/solr/request/TestBinaryResponseWriter.java b/src/test/org/apache/solr/request/TestBinaryResponseWriter.java
index e81995c..2e202f0 100644
--- a/src/test/org/apache/solr/request/TestBinaryResponseWriter.java
+++ b/src/test/org/apache/solr/request/TestBinaryResponseWriter.java
@@ -21,6 +21,8 @@ import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.JavaBinCodec;
+import org.apache.solr.response.BinaryQueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 import java.io.ByteArrayInputStream;
diff --git a/src/test/org/apache/solr/request/TestWriterPerf.java b/src/test/org/apache/solr/request/TestWriterPerf.java
index b1eb3cf..09c7784 100755
--- a/src/test/org/apache/solr/request/TestWriterPerf.java
+++ b/src/test/org/apache/solr/request/TestWriterPerf.java
@@ -17,6 +17,9 @@
 
 package org.apache.solr.request;
 
+import org.apache.solr.response.BinaryQueryResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.client.solrj.ResponseParser;
 import org.apache.solr.client.solrj.impl.BinaryResponseParser;
diff --git a/src/test/org/apache/solr/search/TestRangeQuery.java b/src/test/org/apache/solr/search/TestRangeQuery.java
index a703a5c..575308b 100644
--- a/src/test/org/apache/solr/search/TestRangeQuery.java
+++ b/src/test/org/apache/solr/search/TestRangeQuery.java
@@ -18,7 +18,7 @@ package org.apache.solr.search;
 
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 
 import java.util.*;
 
diff --git a/src/test/org/apache/solr/search/TestSearchPerf.java b/src/test/org/apache/solr/search/TestSearchPerf.java
index bc4c599..0f55adb 100755
--- a/src/test/org/apache/solr/search/TestSearchPerf.java
+++ b/src/test/org/apache/solr/search/TestSearchPerf.java
@@ -21,7 +21,7 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.*;
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
 import org.apache.solr.update.AddUpdateCommand;
diff --git a/src/test/org/apache/solr/update/AutoCommitTest.java b/src/test/org/apache/solr/update/AutoCommitTest.java
index dedcedd..40ff74b 100644
--- a/src/test/org/apache/solr/update/AutoCommitTest.java
+++ b/src/test/org/apache/solr/update/AutoCommitTest.java
@@ -29,7 +29,7 @@ import org.apache.solr.core.*;
 import org.apache.solr.search.*;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
 import org.apache.solr.request.SolrQueryRequestBase;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 import org.apache.solr.util.RefCounted;
 
diff --git a/src/test/org/apache/solr/update/processor/CustomUpdateRequestProcessorFactory.java b/src/test/org/apache/solr/update/processor/CustomUpdateRequestProcessorFactory.java
index de0de6f..e853f28 100644
--- a/src/test/org/apache/solr/update/processor/CustomUpdateRequestProcessorFactory.java
+++ b/src/test/org/apache/solr/update/processor/CustomUpdateRequestProcessorFactory.java
@@ -19,7 +19,7 @@ package org.apache.solr.update.processor;
 
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.update.processor.UpdateRequestProcessor;
 import org.apache.solr.update.processor.UpdateRequestProcessorFactory;
 
diff --git a/src/test/org/apache/solr/update/processor/SignatureUpdateProcessorFactoryTest.java b/src/test/org/apache/solr/update/processor/SignatureUpdateProcessorFactoryTest.java
index 188bb47..7a9854f 100755
--- a/src/test/org/apache/solr/update/processor/SignatureUpdateProcessorFactoryTest.java
+++ b/src/test/org/apache/solr/update/processor/SignatureUpdateProcessorFactoryTest.java
@@ -29,7 +29,7 @@ import org.apache.solr.common.util.ContentStreamBase;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
 import org.apache.solr.request.SolrQueryRequestBase;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.util.AbstractSolrTestCase;
 
 /**
diff --git a/src/test/org/apache/solr/util/SolrPluginUtilsTest.java b/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
index a4304fd..e383e88 100644
--- a/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
+++ b/src/test/org/apache/solr/util/SolrPluginUtilsTest.java
@@ -23,7 +23,7 @@ import org.apache.solr.core.SolrCore;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.DocSlice;
-import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.common.util.*;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrDocumentList;
diff --git a/src/test/test-files/solr/conf/solrconfig-spellchecker.xml b/src/test/test-files/solr/conf/solrconfig-spellchecker.xml
index 2b6d0b6..1e6e87e 100644
--- a/src/test/test-files/solr/conf/solrconfig-spellchecker.xml
+++ b/src/test/test-files/solr/conf/solrconfig-spellchecker.xml
@@ -88,10 +88,10 @@
 
   
 
-  <queryResponseWriter name="standard" class="org.apache.solr.request.XMLResponseWriter"/>
+  <queryResponseWriter name="standard" class="org.apache.solr.response.XMLResponseWriter"/>
   <queryResponseWriter name="useless" class="org.apache.solr.OutputWriterTest$UselessOutputWriter"/>
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter"/>
-  <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter"/>
+  <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
 
     
   <!-- config for the admin interface --> 
diff --git a/src/test/test-files/solr/conf/solrconfig_perf.xml b/src/test/test-files/solr/conf/solrconfig_perf.xml
index 3024021..d03f567 100755
--- a/src/test/test-files/solr/conf/solrconfig_perf.xml
+++ b/src/test/test-files/solr/conf/solrconfig_perf.xml
@@ -819,12 +819,12 @@
     in the request. XMLResponseWriter will be used if nothing is specified here.
     The json, python, and ruby writers are also available by default.
 
-    <queryResponseWriter name="xml" class="org.apache.solr.request.XMLResponseWriter" default="true"/>
-    <queryResponseWriter name="json" class="org.apache.solr.request.JSONResponseWriter"/>
-    <queryResponseWriter name="python" class="org.apache.solr.request.PythonResponseWriter"/>
-    <queryResponseWriter name="ruby" class="org.apache.solr.request.RubyResponseWriter"/>
-    <queryResponseWriter name="php" class="org.apache.solr.request.PHPResponseWriter"/>
-    <queryResponseWriter name="phps" class="org.apache.solr.request.PHPSerializedResponseWriter"/>
+    <queryResponseWriter name="xml" class="org.apache.solr.response.XMLResponseWriter" default="true"/>
+    <queryResponseWriter name="json" class="org.apache.solr.response.JSONResponseWriter"/>
+    <queryResponseWriter name="python" class="org.apache.solr.response.PythonResponseWriter"/>
+    <queryResponseWriter name="ruby" class="org.apache.solr.response.RubyResponseWriter"/>
+    <queryResponseWriter name="php" class="org.apache.solr.response.PHPResponseWriter"/>
+    <queryResponseWriter name="phps" class="org.apache.solr.response.PHPSerializedResponseWriter"/>
 
     <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
   -->
@@ -833,7 +833,7 @@
        in Solr's conf/xslt directory.  Changes to xslt files are checked for
        every xsltCacheLifetimeSeconds.  
    -->
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter">
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter">
     <int name="xsltCacheLifetimeSeconds">5</int>
   </queryResponseWriter>
 
diff --git a/src/test/test-files/solr/crazy-path-to-config.xml b/src/test/test-files/solr/crazy-path-to-config.xml
index 03a0773..09bcab5 100644
--- a/src/test/test-files/solr/crazy-path-to-config.xml
+++ b/src/test/test-files/solr/crazy-path-to-config.xml
@@ -65,9 +65,9 @@
   <requestHandler name="/update" class="solr.XmlUpdateRequestHandler" />
   
   
-  <queryResponseWriter name="standard" class="org.apache.solr.request.XMLResponseWriter"/>
+  <queryResponseWriter name="standard" class="org.apache.solr.response.XMLResponseWriter"/>
   <queryResponseWriter name="useless" class="org.apache.solr.OutputWriterTest$UselessOutputWriter"/>
-  <queryResponseWriter name="xslt" class="org.apache.solr.request.XSLTResponseWriter"/>
+  <queryResponseWriter name="xslt" class="org.apache.solr.response.XSLTResponseWriter"/>
 
 
   <admin>
diff --git a/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
index e822eee..eb5adf2 100644
--- a/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
+++ b/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
@@ -30,10 +30,10 @@ import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.core.SolrCore;
-import org.apache.solr.request.BinaryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.BinaryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.servlet.SolrRequestParsers;
 
 /**
diff --git a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
index 0b079d2..b8795ae 100644
--- a/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
+++ b/src/webapp/src/org/apache/solr/servlet/DirectSolrConnection.java
@@ -34,10 +34,10 @@ import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrResourceLoader;
-import org.apache.solr.request.QueryResponseWriter;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
 
 /**
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
index a38fb54..78340b6 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java
@@ -41,6 +41,9 @@ import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.core.*;
 import org.apache.solr.request.*;
+import org.apache.solr.response.BinaryQueryResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.servlet.cache.HttpCacheHeaderUtil;
 import org.apache.solr.servlet.cache.Method;
 
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrServlet.java b/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
index ba7d177..d1d6dd8 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrServlet.java
@@ -31,9 +31,9 @@ import javax.servlet.http.HttpServletResponse;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrResourceLoader;
-import org.apache.solr.request.QueryResponseWriter;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.SolrQueryResponse;
 
 /**
  * @deprecated Register a standard request handler instead of using this
diff --git a/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java b/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
index fc7d3f5..51a07d9 100644
--- a/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
+++ b/src/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java
@@ -29,8 +29,8 @@ import javax.servlet.http.HttpServletResponse;
 
 import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.handler.XmlUpdateRequestHandler;
-import org.apache.solr.request.QueryResponseWriter;
-import org.apache.solr.request.XMLResponseWriter;
+import org.apache.solr.response.QueryResponseWriter;
+import org.apache.solr.response.XMLResponseWriter;
 
 /**
  * @version $Id$
diff --git a/src/webapp/src/org/apache/solr/servlet/cache/HttpCacheHeaderUtil.java b/src/webapp/src/org/apache/solr/servlet/cache/HttpCacheHeaderUtil.java
index 4aa8785..5d71a48 100644
--- a/src/webapp/src/org/apache/solr/servlet/cache/HttpCacheHeaderUtil.java
+++ b/src/webapp/src/org/apache/solr/servlet/cache/HttpCacheHeaderUtil.java
@@ -35,8 +35,8 @@ import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
 import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.response.SolrQueryResponse;
 
 import org.apache.commons.codec.binary.Base64;
 

