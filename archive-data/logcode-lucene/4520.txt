GitDiffStart: d385c653c286bb5b3656332026aaf379ef5b00ac | Mon Jan 12 13:40:34 2015 +0000
diff --git a/solr/CHANGES.txt b/solr/CHANGES.txt
index 1b6af51..17ed8c0 100644
--- a/solr/CHANGES.txt
+++ b/solr/CHANGES.txt
@@ -291,6 +291,9 @@ New Features
 
 * SOLR-6916: Toggle payload support for the default highlighter via hl.payloads.  It's auto
   enabled when the index has payloads. (David Smiley)
+
+* SOLR-6581: Efficient DocValues support and numeric collapse field implementations 
+  for Collapse and Expand (Joel Bernstein)
   
 Bug Fixes
 ----------------------
diff --git a/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java b/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
index 6b39a01..c0a720e 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
@@ -24,11 +24,29 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Iterator;
+import java.util.Arrays;
 
+import com.carrotsearch.hppc.IntObjectOpenHashMap;
+import com.carrotsearch.hppc.LongOpenHashSet;
+import com.carrotsearch.hppc.LongObjectOpenHashMap;
+import com.carrotsearch.hppc.cursors.IntObjectCursor;
+import com.carrotsearch.hppc.cursors.LongCursor;
+import com.carrotsearch.hppc.cursors.LongObjectCursor;
+import com.carrotsearch.hppc.IntOpenHashSet;
+import com.carrotsearch.hppc.cursors.ObjectCursor;
+import com.carrotsearch.hppc.LongObjectMap;
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.FilterLeafReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.MultiDocValues;
+import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.queries.TermsFilter;
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.LeafCollector;
@@ -40,35 +58,37 @@ import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TopDocsCollector;
 import org.apache.lucene.search.TopFieldCollector;
 import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.uninverting.UninvertingReader;
 import org.apache.lucene.util.BitSetIterator;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.CharsRefBuilder;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.LongValues;
 import org.apache.solr.common.SolrDocumentList;
 import org.apache.solr.common.params.ExpandParams;
-import org.apache.solr.common.params.ShardParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.PluginInfo;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.FieldType;
+import org.apache.solr.schema.TrieFloatField;
+import org.apache.solr.schema.TrieIntField;
+import org.apache.solr.schema.TrieLongField;
+import org.apache.solr.schema.TrieDoubleField;
+import org.apache.solr.schema.StrField;
 import org.apache.solr.search.CollapsingQParserPlugin;
 import org.apache.solr.search.DocIterator;
 import org.apache.solr.search.DocList;
 import org.apache.solr.search.DocSlice;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.QueryParsing;
+import org.apache.solr.search.SolrConstantScoreQuery;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.util.plugin.PluginInfoInitialized;
 import org.apache.solr.util.plugin.SolrCoreAware;
 
-import com.carrotsearch.hppc.IntObjectMap;
-import com.carrotsearch.hppc.IntObjectOpenHashMap;
-import com.carrotsearch.hppc.IntOpenHashSet;
-import com.carrotsearch.hppc.cursors.IntObjectCursor;
-import com.carrotsearch.hppc.cursors.ObjectCursor;
-
 /**
  * The ExpandComponent is designed to work with the CollapsingPostFilter.
  * The CollapsingPostFilter collapses a result set on a field.
@@ -118,6 +138,7 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
     SolrParams params = req.getParams();
 
     String field = params.get(ExpandParams.EXPAND_FIELD);
+    String hint = null;
     if (field == null) {
       List<Query> filters = rb.getFilters();
       if (filters != null) {
@@ -125,6 +146,7 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
           if (q instanceof CollapsingQParserPlugin.CollapsingPostFilter) {
             CollapsingQParserPlugin.CollapsingPostFilter cp = (CollapsingQParserPlugin.CollapsingPostFilter) q;
             field = cp.getField();
+            hint = cp.hint;
           }
         }
       }
@@ -183,26 +205,168 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
 
     SolrIndexSearcher searcher = req.getSearcher();
     LeafReader reader = searcher.getLeafReader();
-    SortedDocValues values = DocValues.getSorted(reader, field);
-    FixedBitSet groupBits = new FixedBitSet(values.getValueCount());
+
+    FieldType fieldType = searcher.getSchema().getField(field).getType();
+
+    SortedDocValues values = null;
+    long nullValue = 0;
+
+    if(fieldType instanceof StrField) {
+      //Get The Top Level SortedDocValues
+      if(CollapsingQParserPlugin.HINT_TOP_FC.equals(hint)) {
+        Map<String, UninvertingReader.Type> mapping = new HashMap();
+        mapping.put(field, UninvertingReader.Type.SORTED);
+        UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), field), mapping);
+        values = uninvertingReader.getSortedDocValues(field);
+      } else {
+        values = DocValues.getSorted(reader, field);
+      }
+    } else {
+      //Get the nullValue for the numeric collapse field
+      String defaultValue = searcher.getSchema().getField(field).getDefaultValue();
+      if(defaultValue != null) {
+        if(fieldType instanceof TrieIntField || fieldType instanceof TrieLongField) {
+          nullValue = Long.parseLong(defaultValue);
+        } else if(fieldType instanceof TrieFloatField){
+          nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));
+        } else if(fieldType instanceof TrieDoubleField){
+          nullValue = Double.doubleToLongBits(Double.parseDouble(defaultValue));
+        }
+      } else {
+        if(fieldType instanceof TrieFloatField){
+          nullValue = Float.floatToIntBits(0.0f);
+        } else if(fieldType instanceof TrieDoubleField){
+          nullValue = Double.doubleToLongBits(0.0f);
+        }
+      }
+    }
+
+    FixedBitSet groupBits = null;
+    LongOpenHashSet groupSet = null;
     DocList docList = rb.getResults().docList;
     IntOpenHashSet collapsedSet = new IntOpenHashSet(docList.size() * 2);
 
+    //Gather the groups for the current page of documents
     DocIterator idit = docList.iterator();
-
+    int[] globalDocs = new int[docList.size()];
+    int docsIndex = -1;
     while (idit.hasNext()) {
-      int doc = idit.nextDoc();
-      int ord = values.getOrd(doc);
-      if (ord > -1) {
-        groupBits.set(ord);
-        collapsedSet.add(doc);
+      globalDocs[++docsIndex] = idit.nextDoc();
+    }
+
+    Arrays.sort(globalDocs);
+    Query groupQuery = null;
+
+    /*
+    * This code gathers the group information for the current page.
+    */
+    List<LeafReaderContext> contexts = searcher.getTopReaderContext().leaves();
+    int currentContext = 0;
+    int currentDocBase = contexts.get(currentContext).docBase;
+    int nextDocBase = (currentContext+1)<contexts.size() ? contexts.get(currentContext+1).docBase : Integer.MAX_VALUE;
+    IntObjectOpenHashMap<BytesRef> ordBytes = null;
+    if(values != null) {
+      groupBits = new FixedBitSet(values.getValueCount());
+      MultiDocValues.OrdinalMap ordinalMap = null;
+      SortedDocValues[] sortedDocValues = null;
+      LongValues segmentOrdinalMap = null;
+      SortedDocValues currentValues = null;
+      if(values instanceof  MultiDocValues.MultiSortedDocValues) {
+        ordinalMap = ((MultiDocValues.MultiSortedDocValues)values).mapping;
+        sortedDocValues = ((MultiDocValues.MultiSortedDocValues)values).values;
+        currentValues = sortedDocValues[currentContext];
+        segmentOrdinalMap = ordinalMap.getGlobalOrds(currentContext);
+      }
+      int count = 0;
+
+      ordBytes = new IntObjectOpenHashMap();
+
+      for(int i=0; i<globalDocs.length; i++) {
+        int globalDoc = globalDocs[i];
+        while(globalDoc >= nextDocBase) {
+          currentContext++;
+          currentDocBase = contexts.get(currentContext).docBase;
+          nextDocBase = (currentContext+1) < contexts.size() ? contexts.get(currentContext+1).docBase : Integer.MAX_VALUE;
+          if(ordinalMap != null) {
+            currentValues = sortedDocValues[currentContext];
+            segmentOrdinalMap = ordinalMap.getGlobalOrds(currentContext);
+          }
+        }
+
+        int contextDoc = globalDoc - currentDocBase;
+        if(ordinalMap != null) {
+          int ord = currentValues.getOrd(contextDoc);
+          if(ord > -1) {
+            ++count;
+            BytesRef ref = currentValues.lookupOrd(ord);
+            ord = (int)segmentOrdinalMap.get(ord);
+            ordBytes.put(ord, BytesRef.deepCopyOf(ref));
+            groupBits.set(ord);
+            collapsedSet.add(globalDoc);
+          }
+        } else {
+          int ord = values.getOrd(globalDoc);
+          if(ord > -1) {
+            ++count;
+            BytesRef ref = values.lookupOrd(ord);
+            ordBytes.put(ord, BytesRef.deepCopyOf(ref));
+            groupBits.set(ord);
+            collapsedSet.add(globalDoc);
+          }
+        }
+      }
+
+      if(count > 0 && count < 200) {
+        try {
+          groupQuery = getGroupQuery(field, count, ordBytes);
+        } catch(Exception e) {
+          throw new IOException(e);
+        }
+      }
+    } else {
+      groupSet = new LongOpenHashSet((int)(docList.size()*1.25));
+      NumericDocValues collapseValues = contexts.get(currentContext).reader().getNumericDocValues(field);
+      int count = 0;
+      for(int i=0; i<globalDocs.length; i++) {
+        int globalDoc = globalDocs[i];
+        while(globalDoc >= nextDocBase) {
+          currentContext++;
+          currentDocBase = contexts.get(currentContext).docBase;
+          nextDocBase = currentContext+1 < contexts.size() ? contexts.get(currentContext+1).docBase : Integer.MAX_VALUE;
+          collapseValues = contexts.get(currentContext).reader().getNumericDocValues(field);
+        }
+        int contextDoc = globalDoc - currentDocBase;
+        long value = collapseValues.get(contextDoc);
+        if(value != nullValue) {
+          ++count;
+          groupSet.add(value);
+          collapsedSet.add(globalDoc);
+        }
+      }
+
+      if(count > 0 && count < 200) {
+        groupQuery = getGroupQuery(field, fieldType, count, groupSet);
       }
     }
 
     Collector collector;
     if (sort != null)
       sort = sort.rewrite(searcher);
-    GroupExpandCollector groupExpandCollector = new GroupExpandCollector(values, groupBits, collapsedSet, limit, sort);
+
+
+    Collector groupExpandCollector = null;
+
+    if(values != null) {
+      groupExpandCollector = new GroupExpandCollector(values, groupBits, collapsedSet, limit, sort);
+    } else {
+      groupExpandCollector = new NumericGroupExpandCollector(field, nullValue, groupSet, collapsedSet, limit, sort);
+    }
+
+    if(groupQuery !=  null) {
+      //Limits the results to documents that are in the same group as the documents in the page.
+      newFilters.add(groupQuery);
+    }
+
     SolrIndexSearcher.ProcessedFilter pfilter = searcher.getProcessedFilter(null, newFilters);
     if (pfilter.postFilter != null) {
       pfilter.postFilter.setLastDelegate(groupExpandCollector);
@@ -212,12 +376,11 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
     }
 
     searcher.search(query, pfilter.filter, collector);
-    IntObjectMap groups = groupExpandCollector.getGroups();
+    LongObjectMap groups = ((GroupCollector)groupExpandCollector).getGroups();
     Map<String, DocSlice> outMap = new HashMap<>();
     CharsRefBuilder charsRef = new CharsRefBuilder();
-    FieldType fieldType = searcher.getSchema().getField(field).getType();
-    for (IntObjectCursor cursor : (Iterable<IntObjectCursor>) groups) {
-      int ord = cursor.key;
+    for (LongObjectCursor cursor : (Iterable<LongObjectCursor>) groups) {
+      long groupValue = cursor.key;
       TopDocsCollector topDocsCollector = (TopDocsCollector) cursor.value;
       TopDocs topDocs = topDocsCollector.topDocs();
       ScoreDoc[] scoreDocs = topDocs.scoreDocs;
@@ -230,10 +393,21 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
           scores[i] = scoreDoc.score;
         }
         DocSlice slice = new DocSlice(0, docs.length, docs, scores, topDocs.totalHits, topDocs.getMaxScore());
-        final BytesRef bytesRef = values.lookupOrd(ord);
-        fieldType.indexedToReadable(bytesRef, charsRef);
-        String group = charsRef.toString();
-        outMap.put(group, slice);
+
+        if(fieldType instanceof StrField) {
+          final BytesRef bytesRef = ordBytes.get((int)groupValue);
+          fieldType.indexedToReadable(bytesRef, charsRef);
+          String group = charsRef.toString();
+          outMap.put(group, slice);
+        } else {
+          if(fieldType instanceof TrieIntField || fieldType instanceof TrieLongField ) {
+            outMap.put(Long.toString(groupValue), slice);
+          } else if(fieldType instanceof TrieFloatField) {
+            outMap.put(Float.toString(Float.intBitsToFloat((int)groupValue)), slice);
+          } else if(fieldType instanceof TrieDoubleField) {
+            outMap.put(Double.toString(Double.longBitsToDouble(groupValue)), slice);
+          }
+        }
       }
     }
 
@@ -306,16 +480,20 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
     rb.rsp.add("expanded", expanded);
   }
 
-  private class GroupExpandCollector implements Collector {
+  private class GroupExpandCollector implements Collector, GroupCollector {
     private SortedDocValues docValues;
-    private IntObjectMap<Collector> groups;
-    private int docBase;
+    private MultiDocValues.OrdinalMap ordinalMap;
+    private SortedDocValues segmentValues;
+    private LongValues segmentOrdinalMap;
+    private MultiDocValues.MultiSortedDocValues multiSortedDocValues;
+
+    private LongObjectMap<Collector> groups;
     private FixedBitSet groupBits;
     private IntOpenHashSet collapsedSet;
 
     public GroupExpandCollector(SortedDocValues docValues, FixedBitSet groupBits, IntOpenHashSet collapsedSet, int limit, Sort sort) throws IOException {
       int numGroups = collapsedSet.size();
-      groups = new IntObjectOpenHashMap<>(numGroups * 2);
+      groups = new LongObjectOpenHashMap<>(numGroups * 2);
       DocIdSetIterator iterator = new BitSetIterator(groupBits, 0); // cost is not useful here
       int group;
       while ((group = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
@@ -326,12 +504,22 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
       this.collapsedSet = collapsedSet;
       this.groupBits = groupBits;
       this.docValues = docValues;
+      if(docValues instanceof MultiDocValues.MultiSortedDocValues) {
+        this.multiSortedDocValues = (MultiDocValues.MultiSortedDocValues)docValues;
+        this.ordinalMap = multiSortedDocValues.mapping;
+      }
     }
 
     public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
       final int docBase = context.docBase;
-      final IntObjectMap<LeafCollector> leafCollectors = new IntObjectOpenHashMap<>();
-      for (IntObjectCursor<Collector> entry : groups) {
+
+      if(ordinalMap != null) {
+        this.segmentValues = this.multiSortedDocValues.values[context.ord];
+        this.segmentOrdinalMap = ordinalMap.getGlobalOrds(context.ord);
+      }
+
+      final LongObjectMap<LeafCollector> leafCollectors = new LongObjectOpenHashMap<>();
+      for (LongObjectCursor<Collector> entry : groups) {
         leafCollectors.put(entry.key, entry.value.getLeafCollector(context));
       }
       return new LeafCollector() {
@@ -345,9 +533,18 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
 
         @Override
         public void collect(int docId) throws IOException {
-          int doc = docId + docBase;
-          int ord = docValues.getOrd(doc);
-          if (ord > -1 && groupBits.get(ord) && !collapsedSet.contains(doc)) {
+          int globalDoc = docId + docBase;
+          int ord = -1;
+          if(ordinalMap != null) {
+            ord = segmentValues.getOrd(docId);
+            if(ord > -1) {
+              ord = (int)segmentOrdinalMap.get(ord);
+            }
+          } else {
+            ord = docValues.getOrd(globalDoc);
+          }
+
+          if (ord > -1 && groupBits.get(ord) && !collapsedSet.contains(globalDoc)) {
             LeafCollector c = leafCollectors.get(ord);
             c.collect(docId);
           }
@@ -360,12 +557,125 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
       };
     }
 
-    public IntObjectMap<Collector> getGroups() {
+    public LongObjectMap<Collector> getGroups() {
+      return groups;
+    }
+  }
+
+  private class NumericGroupExpandCollector implements Collector, GroupCollector {
+    private NumericDocValues docValues;
+
+
+    private String field;
+    private LongObjectOpenHashMap<Collector> groups;
+
+    private IntOpenHashSet collapsedSet;
+    private long nullValue;
+
+    public NumericGroupExpandCollector(String field, long nullValue, LongOpenHashSet groupSet, IntOpenHashSet collapsedSet, int limit, Sort sort) throws IOException {
+      int numGroups = collapsedSet.size();
+      this.nullValue = nullValue;
+      groups = new LongObjectOpenHashMap(numGroups * 2);
+      Iterator<LongCursor> iterator = groupSet.iterator();
+      while (iterator.hasNext()) {
+        LongCursor cursor = iterator.next();
+        Collector collector = (sort == null) ? TopScoreDocCollector.create(limit, true) : TopFieldCollector.create(sort, limit, false, false, false, true);
+        groups.put(cursor.value, collector);
+      }
+
+      this.field = field;
+      this.collapsedSet = collapsedSet;
+    }
+
+    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
+      final int docBase = context.docBase;
+      this.docValues = context.reader().getNumericDocValues(this.field);
+
+      final LongObjectOpenHashMap<LeafCollector> leafCollectors = new LongObjectOpenHashMap<>();
+
+      for (LongObjectCursor<Collector> entry : groups) {
+        leafCollectors.put(entry.key, entry.value.getLeafCollector(context));
+      }
+
+      return new LeafCollector() {
+
+        @Override
+        public void setScorer(Scorer scorer) throws IOException {
+          for (ObjectCursor<LeafCollector> c : leafCollectors.values()) {
+            c.value.setScorer(scorer);
+          }
+        }
+
+        @Override
+        public void collect(int docId) throws IOException {
+          long value = docValues.get(docId);
+          if (value != nullValue && leafCollectors.containsKey(value) && !collapsedSet.contains(docId + docBase)) {
+            LeafCollector c = leafCollectors.lget();
+            c.collect(docId);
+          }
+        }
+
+        @Override
+        public boolean acceptsDocsOutOfOrder() {
+          return false;
+        }
+      };
+    }
+
+    public LongObjectOpenHashMap<Collector> getGroups() {
       return groups;
     }
 
   }
 
+  private interface GroupCollector {
+    public LongObjectMap getGroups();
+
+  }
+
+  private Query getGroupQuery(String fname,
+                           FieldType ft,
+                           int size,
+                           LongOpenHashSet groupSet) {
+
+    BytesRef[] bytesRefs = new BytesRef[size];
+    BytesRefBuilder term = new BytesRefBuilder();
+    Iterator<LongCursor> it = groupSet.iterator();
+    int index = -1;
+    String stringVal =  null;
+    while (it.hasNext()) {
+      LongCursor cursor = it.next();
+      if(ft instanceof TrieIntField || ft instanceof TrieLongField) {
+        stringVal = Long.toString(cursor.value);
+      } else {
+        if(ft instanceof TrieFloatField) {
+          stringVal = Float.toString(Float.intBitsToFloat((int)cursor.value));
+        } else {
+          stringVal = Double.toString(Double.longBitsToDouble(cursor.value));
+        }
+      }
+      ft.readableToIndexed(stringVal, term);
+      bytesRefs[++index] = term.toBytesRef();
+    }
+
+    return new SolrConstantScoreQuery(new TermsFilter(fname, bytesRefs));
+  }
+
+  private Query getGroupQuery(String fname,
+                              int size,
+                              IntObjectOpenHashMap<BytesRef> ordBytes) throws Exception {
+
+    BytesRef[] bytesRefs = new BytesRef[size];
+    int index = -1;
+    Iterator<IntObjectCursor<BytesRef>>it = ordBytes.iterator();
+    while (it.hasNext()) {
+      IntObjectCursor<BytesRef> cursor = it.next();
+      bytesRefs[++index] = cursor.value;
+    }
+    return new SolrConstantScoreQuery(new TermsFilter(fname, bytesRefs));
+  }
+
+
   ////////////////////////////////////////////
   ///  SolrInfoMBean
   ////////////////////////////////////////////
@@ -385,4 +695,49 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
       throw new RuntimeException(e);
     }
   }
+
+  private class ReaderWrapper extends FilterLeafReader {
+
+    private String field;
+
+    public ReaderWrapper(LeafReader leafReader, String field) {
+      super(leafReader);
+      this.field = field;
+    }
+
+    public SortedDocValues getSortedDocValues(String field) {
+      return null;
+    }
+
+    public Object getCoreCacheKey() {
+      return in.getCoreCacheKey();
+    }
+
+    public FieldInfos getFieldInfos() {
+      Iterator<FieldInfo> it = in.getFieldInfos().iterator();
+      List<FieldInfo> newInfos = new ArrayList();
+      while(it.hasNext()) {
+        FieldInfo fieldInfo = it.next();
+
+        if(fieldInfo.name.equals(field)) {
+          FieldInfo f = new FieldInfo(fieldInfo.name,
+              fieldInfo.number,
+              fieldInfo.hasVectors(),
+              fieldInfo.hasNorms(),
+              fieldInfo.hasPayloads(),
+              fieldInfo.getIndexOptions(),
+              DocValuesType.NONE,
+              fieldInfo.getDocValuesGen(),
+              fieldInfo.attributes());
+          newInfos.add(f);
+
+        } else {
+          newInfos.add(fieldInfo);
+        }
+      }
+      FieldInfos infos = new FieldInfos(newInfos.toArray(new FieldInfo[newInfos.size()]));
+      return infos;
+    }
+  }
+
 }
diff --git a/solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java b/solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java
index 7ac7fe2..834f577 100644
--- a/solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java
+++ b/solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java
@@ -19,13 +19,28 @@ package org.apache.solr.search;
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
 
+import com.carrotsearch.hppc.IntArrayList;
+import com.carrotsearch.hppc.IntLongOpenHashMap;
+import com.carrotsearch.hppc.LongArrayList;
+import com.carrotsearch.hppc.cursors.IntLongCursor;
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.FilterLeafReader;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.MultiDocValues;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.uninverting.UninvertingReader;
+import org.apache.lucene.util.LongValues;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
@@ -45,13 +60,13 @@ import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestInfo;
 import org.apache.solr.schema.FieldType;
+import org.apache.solr.schema.TrieDoubleField;
 import org.apache.solr.schema.TrieFloatField;
 import org.apache.solr.schema.TrieIntField;
 import org.apache.solr.schema.TrieLongField;
-
+import org.apache.solr.schema.StrField;
 import com.carrotsearch.hppc.FloatArrayList;
 import com.carrotsearch.hppc.IntIntOpenHashMap;
-import com.carrotsearch.hppc.IntOpenHashSet;
 import com.carrotsearch.hppc.cursors.IntIntCursor;
 
 /**
@@ -87,8 +102,6 @@ import com.carrotsearch.hppc.cursors.IntIntCursor;
  collapse : collapses all docs with a null value into a single group using either highest score, or min/max.
  <p/>
  The CollapsingQParserPlugin fully supports the QueryElevationComponent
-
-
  **/
 
 public class CollapsingQParserPlugin extends QParserPlugin {
@@ -97,6 +110,8 @@ public class CollapsingQParserPlugin extends QParserPlugin {
   public static final String NULL_COLLAPSE = "collapse";
   public static final String NULL_IGNORE = "ignore";
   public static final String NULL_EXPAND = "expand";
+  public static final String HINT_TOP_FC = "TOP_FC";
+  public static final String HINT_MULTI_DOCVALUES = "MULTI_DOCVALUES";
 
 
   public void init(NamedList namedList) {
@@ -124,19 +139,20 @@ public class CollapsingQParserPlugin extends QParserPlugin {
 
   public class CollapsingPostFilter extends ExtendedQueryBase implements PostFilter, ScoreFilter {
 
-    private String field;
+    private String collapseField;
     private String max;
     private String min;
+    public String hint;
     private boolean needsScores = true;
     private int nullPolicy;
     private Map<BytesRef, Integer> boosted;
     public static final int NULL_POLICY_IGNORE = 0;
     public static final int NULL_POLICY_COLLAPSE = 1;
     public static final int NULL_POLICY_EXPAND = 2;
-
+    private int size;
 
     public String getField(){
-      return this.field;
+      return this.collapseField;
     }
 
     public void setCache(boolean cache) {
@@ -156,7 +172,7 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public int hashCode() {
-      int hashCode = field.hashCode();
+      int hashCode = collapseField.hashCode();
       hashCode = max!=null ? hashCode+max.hashCode():hashCode;
       hashCode = min!=null ? hashCode+min.hashCode():hashCode;
       hashCode = hashCode+nullPolicy;
@@ -168,7 +184,7 @@ public class CollapsingQParserPlugin extends QParserPlugin {
 
       if(o instanceof CollapsingPostFilter) {
         CollapsingPostFilter c = (CollapsingPostFilter)o;
-        if(this.field.equals(c.field) &&
+        if(this.collapseField.equals(c.collapseField) &&
            ((this.max == null && c.max == null) || (this.max != null && c.max != null && this.max.equals(c.max))) &&
            ((this.min == null && c.min == null) || (this.min != null && c.min != null && this.min.equals(c.min))) &&
            this.nullPolicy == c.nullPolicy &&
@@ -188,12 +204,15 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public CollapsingPostFilter(SolrParams localParams, SolrParams params, SolrQueryRequest request) throws IOException {
-      this.field = localParams.get("field");
-      if (this.field == null) {
+      this.collapseField = localParams.get("field");
+      if (this.collapseField == null) {
         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Required 'field' param is missing.");
       }
       this.max = localParams.get("max");
       this.min = localParams.get("min");
+      this.hint = localParams.get("hint");
+      this.size = localParams.getInt("size", 100000); //Only used for collapsing on int fields.
+
       if(this.min != null || this.max != null) {
         this.needsScores = needsScores(params);
       }
@@ -208,7 +227,6 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       } else {
         throw new IOException("Invalid nullPolicy:"+nPolicy);
       }
-
     }
 
     private IntIntOpenHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Map<BytesRef, Integer> boosted, Map context) throws IOException {
@@ -220,57 +238,12 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       try {
 
         SolrIndexSearcher searcher = (SolrIndexSearcher)indexSearcher;
-
-        SortedDocValues docValues = null;
-        FunctionQuery funcQuery = null;
-        docValues = DocValues.getSorted(searcher.getLeafReader(), this.field);
-
-        FieldType fieldType = null;
-
-        if(this.max != null) {
-          if(this.max.indexOf("(") == -1) {
-            fieldType = searcher.getSchema().getField(this.max).getType();
-          } else {
-            LocalSolrQueryRequest request = null;
-            try {
-              SolrParams params = new ModifiableSolrParams();
-              request = new LocalSolrQueryRequest(searcher.getCore(), params);
-              FunctionQParser functionQParser = new FunctionQParser(this.max, null, null,request);
-              funcQuery = (FunctionQuery)functionQParser.parse();
-            } catch (Exception e) {
-              throw new IOException(e);
-            } finally {
-              request.close();
-            }
-          }
-        }
-
-        if(this.min != null) {
-          if(this.min.indexOf("(") == -1) {
-            fieldType = searcher.getSchema().getField(this.min).getType();
-          } else {
-            LocalSolrQueryRequest request = null;
-            try {
-              SolrParams params = new ModifiableSolrParams();
-              request = new LocalSolrQueryRequest(searcher.getCore(), params);
-              FunctionQParser functionQParser = new FunctionQParser(this.min, null, null,request);
-              funcQuery = (FunctionQuery)functionQParser.parse();
-            } catch (Exception e) {
-              throw new IOException(e);
-            } finally {
-              request.close();
-            }
-          }
-        }
-
-        int maxDoc = searcher.maxDoc();
-        int leafCount = searcher.getTopReaderContext().leaves().size();
-
+        CollectorFactory collectorFactory = new CollectorFactory();
         //Deal with boosted docs.
         //We have to deal with it here rather then the constructor because
         //because the QueryElevationComponent runs after the Queries are constructed.
 
-        IntIntOpenHashMap boostDocs = null;
+        IntIntOpenHashMap boostDocsMap = null;
         Map context = null;
         SolrRequestInfo info = SolrRequestInfo.getRequestInfo();
         if(info != null) {
@@ -281,23 +254,17 @@ public class CollapsingQParserPlugin extends QParserPlugin {
           this.boosted = (Map<BytesRef, Integer>)context.get(QueryElevationComponent.BOOSTED_PRIORITY);
         }
 
-        boostDocs = getBoostDocs(searcher, this.boosted, context);
-
-        if (this.min != null || this.max != null) {
+        boostDocsMap = getBoostDocs(searcher, this.boosted, context);
+        return collectorFactory.getCollector(this.collapseField,
+                                             this.min,
+                                             this.max,
+                                             this.nullPolicy,
+                                             this.hint,
+                                             this.needsScores,
+                                             this.size,
+                                             boostDocsMap,
+                                             searcher);
 
-          return new CollapsingFieldValueCollector(maxDoc,
-                                                   leafCount,
-                                                   docValues,
-                                                   this.nullPolicy,
-                                                   max != null ? this.max : this.min,
-                                                   max != null,
-                                                   this.needsScores,
-                                                   fieldType,
-                                                   boostDocs,
-                                                   funcQuery, searcher);
-        } else {
-          return new CollapsingScoreCollector(maxDoc, leafCount, docValues, this.nullPolicy, boostDocs);
-        }
       } catch (Exception e) {
         throw new RuntimeException(e);
       }
@@ -337,6 +304,51 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
+  private class ReaderWrapper extends FilterLeafReader {
+
+    private String field;
+
+    public ReaderWrapper(LeafReader leafReader, String field) {
+      super(leafReader);
+      this.field = field;
+    }
+
+    public SortedDocValues getSortedDocValues(String field) {
+      return null;
+    }
+
+    public Object getCoreCacheKey() {
+      return in.getCoreCacheKey();
+    }
+
+    public FieldInfos getFieldInfos() {
+      Iterator<FieldInfo> it = in.getFieldInfos().iterator();
+      List<FieldInfo> newInfos = new ArrayList();
+      while(it.hasNext()) {
+        FieldInfo fieldInfo = it.next();
+
+        if(fieldInfo.name.equals(field)) {
+          FieldInfo f = new FieldInfo(fieldInfo.name,
+                                      fieldInfo.number,
+                                      fieldInfo.hasVectors(),
+                                      fieldInfo.hasNorms(),
+                                      fieldInfo.hasPayloads(),
+                                      fieldInfo.getIndexOptions(),
+                                      DocValuesType.NONE,
+                                      fieldInfo.getDocValuesGen(),
+                                      fieldInfo.attributes());
+          newInfos.add(f);
+
+        } else {
+          newInfos.add(fieldInfo);
+        }
+      }
+      FieldInfos infos = new FieldInfos(newInfos.toArray(new FieldInfo[newInfos.size()]));
+      return infos;
+    }
+  }
+
+
   private class DummyScorer extends Scorer {
 
     public float score;
@@ -372,11 +384,20 @@ public class CollapsingQParserPlugin extends QParserPlugin {
   }
 
 
-  private class CollapsingScoreCollector extends DelegatingCollector {
+
+  /*
+  * Collapses on Ordinal Values using Score to select the group head.
+  */
+
+  private class OrdScoreCollector extends DelegatingCollector {
 
     private LeafReaderContext[] contexts;
     private FixedBitSet collapsedSet;
-    private SortedDocValues values;
+    private SortedDocValues collapseValues;
+    private MultiDocValues.OrdinalMap ordinalMap;
+    private SortedDocValues segmentValues;
+    private LongValues segmentOrdinalMap;
+    private MultiDocValues.MultiSortedDocValues multiSortedDocValues;
     private int[] ords;
     private float[] scores;
     private int maxDoc;
@@ -384,36 +405,25 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     private float nullScore = -Float.MAX_VALUE;
     private int nullDoc;
     private FloatArrayList nullScores;
-    private IntIntOpenHashMap boostDocs;
-    private int[] boostOrds;
-
-    public CollapsingScoreCollector(int maxDoc,
-                                    int segments,
-                                    SortedDocValues values,
-                                    int nullPolicy,
-                                    IntIntOpenHashMap boostDocs) {
+    private IntArrayList boostOrds;
+    private IntArrayList boostDocs;
+    private MergeBoost mergeBoost;
+    private boolean boosts;
+
+    public OrdScoreCollector(int maxDoc,
+                             int segments,
+                             SortedDocValues collapseValues,
+                             int nullPolicy,
+                             IntIntOpenHashMap boostDocsMap) {
       this.maxDoc = maxDoc;
       this.contexts = new LeafReaderContext[segments];
       this.collapsedSet = new FixedBitSet(maxDoc);
-      this.boostDocs = boostDocs;
-      if(this.boostDocs != null) {
-        //Set the elevated docs now.
-        IntOpenHashSet boostG = new IntOpenHashSet();
-        Iterator<IntIntCursor> it = this.boostDocs.iterator();
-        while(it.hasNext()) {
-          IntIntCursor cursor = it.next();
-          int i = cursor.key;
-          this.collapsedSet.set(i);
-          int ord = values.getOrd(i);
-          if(ord > -1) {
-            boostG.add(ord);
-          }
-        }
-        boostOrds = boostG.toArray();
-        Arrays.sort(boostOrds);
+      this.collapseValues = collapseValues;
+      int valueCount = collapseValues.getValueCount();
+      if(collapseValues instanceof MultiDocValues.MultiSortedDocValues) {
+        this.multiSortedDocValues = (MultiDocValues.MultiSortedDocValues)collapseValues;
+        this.ordinalMap = multiSortedDocValues.mapping;
       }
-      this.values = values;
-      int valueCount = values.getValueCount();
       this.ords = new int[valueCount];
       Arrays.fill(this.ords, -1);
       this.scores = new float[valueCount];
@@ -422,6 +432,22 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
         nullScores = new FloatArrayList();
       }
+
+      if(boostDocsMap != null) {
+        this.boosts = true;
+        this.boostOrds = new IntArrayList();
+        this.boostDocs = new IntArrayList();
+        int[] bd = new int[boostDocsMap.size()];
+        Iterator<IntIntCursor> it =  boostDocsMap.iterator();
+        int index = -1;
+        while(it.hasNext()) {
+          IntIntCursor cursor = it.next();
+          bd[++index] = cursor.key;
+        }
+
+        Arrays.sort(bd);
+        this.mergeBoost = new MergeBoost(bd);
+      }
     }
 
     @Override
@@ -434,12 +460,35 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     protected void doSetNextReader(LeafReaderContext context) throws IOException {
       this.contexts[context.ord] = context;
       this.docBase = context.docBase;
+      if(ordinalMap != null) {
+        this.segmentValues = this.multiSortedDocValues.values[context.ord];
+        this.segmentOrdinalMap = ordinalMap.getGlobalOrds(context.ord);
+      } else {
+        this.segmentValues = collapseValues;
+      }
     }
 
     @Override
-    public void collect(int docId) throws IOException {
-      int globalDoc = docId+this.docBase;
-      int ord = values.getOrd(globalDoc);
+    public void collect(int contextDoc) throws IOException {
+      int globalDoc = contextDoc+this.docBase;
+      int ord = -1;
+      if(this.ordinalMap != null) {
+        //Handle ordinalMapping case
+        ord = segmentValues.getOrd(contextDoc);
+        if(ord > -1) {
+          ord = (int)segmentOrdinalMap.get(ord);
+        }
+      } else {
+        //Handle top Level FieldCache or Single Segment Case
+        ord = segmentValues.getOrd(globalDoc);
+      }
+
+      // Check to see if we have documents boosted by the QueryElevationComponent
+      if(boosts && mergeBoost.boost(globalDoc)) {
+        boostDocs.add(globalDoc);
+        boostOrds.add(ord);
+        return;
+      }
 
       if(ord > -1) {
         float score = scorer.score();
@@ -447,9 +496,6 @@ public class CollapsingQParserPlugin extends QParserPlugin {
           ords[ord] = globalDoc;
           scores[ord] = score;
         }
-      } else if (this.collapsedSet.get(globalDoc)) {
-        //The doc is elevated so score does not matter
-        //We just want to be sure it doesn't fall into the null policy
       } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
         float score = scorer.score();
         if(score > nullScore) {
@@ -469,15 +515,25 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       }
 
       if(nullScore > 0) {
-        this.collapsedSet.set(nullDoc);
+        collapsedSet.set(nullDoc);
       }
 
+      //Handle the boosted docs.
       if(this.boostOrds != null) {
-        for(int i=0; i<this.boostOrds.length; i++) {
-          ords[boostOrds[i]] = -1;
+        int s = boostOrds.size();
+        for(int i=0; i<s; i++) {
+          int ord = this.boostOrds.get(i);
+          if(ord > -1) {
+            //Remove any group heads that are in the same groups as boosted documents.
+            ords[ord] = -1;
+          }
+          //Add the boosted docs to the collapsedSet
+          this.collapsedSet.set(boostDocs.get(i));
         }
+        mergeBoost.reset(); // Reset mergeBoost because we're going to use it again.
       }
 
+      //Build the sorted DocSet of group heads.
       for(int i=0; i<ords.length; i++) {
         int doc = ords[i];
         if(doc > -1) {
@@ -487,37 +543,248 @@ public class CollapsingQParserPlugin extends QParserPlugin {
 
       int currentContext = 0;
       int currentDocBase = 0;
+
+      if(ordinalMap != null) {
+        this.segmentValues = this.multiSortedDocValues.values[currentContext];
+        this.segmentOrdinalMap = this.ordinalMap.getGlobalOrds(currentContext);
+      } else {
+        this.segmentValues = collapseValues;
+      }
+
       int nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
       leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
       DummyScorer dummy = new DummyScorer();
       leafDelegate.setScorer(dummy);
       DocIdSetIterator it = new BitSetIterator(collapsedSet, 0L); // cost is not useful here
       int docId = -1;
-      int nullScoreIndex = 0;
+      int index = -1;
       while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
 
-        int ord = values.getOrd(docId);
+        while(docId >= nextDocBase) {
+          currentContext++;
+          currentDocBase = contexts[currentContext].docBase;
+          nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
+          leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
+          leafDelegate.setScorer(dummy);
+          if(ordinalMap != null) {
+            this.segmentValues = this.multiSortedDocValues.values[currentContext];
+            this.segmentOrdinalMap = this.ordinalMap.getGlobalOrds(currentContext);
+          }
+        }
+
+        int contextDoc = docId-currentDocBase;
+
+        int ord = -1;
+        if(this.ordinalMap != null) {
+          //Handle ordinalMapping case
+          ord = segmentValues.getOrd(contextDoc);
+          if(ord > -1) {
+            ord = (int)segmentOrdinalMap.get(ord);
+          }
+        } else {
+          //Handle top Level FieldCache or Single Segment Case
+          ord = segmentValues.getOrd(docId);
+        }
 
         if(ord > -1) {
           dummy.score = scores[ord];
-        } else if(this.boostDocs != null && boostDocs.containsKey(docId)) {
-          //Elevated docs don't need a score.
-          dummy.score = 0F;
-        } else if (nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
+        } else if(boosts && mergeBoost.boost(docId)) {
+          //Ignore so it doesn't mess up the null scoring.
+        } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
           dummy.score = nullScore;
-        } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
-          dummy.score = nullScores.get(nullScoreIndex++);
+        } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+          dummy.score = nullScores.get(++index);
         }
 
-        while(docId >= nextDocBase) {
+        dummy.docId = contextDoc;
+        leafDelegate.collect(contextDoc);
+      }
+
+      if(delegate instanceof DelegatingCollector) {
+        ((DelegatingCollector) delegate).finish();
+      }
+    }
+  }
+
+  /*
+  * Collapses on an integer field using the score to select the group head.
+  */
+
+  private class IntScoreCollector extends DelegatingCollector {
+
+    private LeafReaderContext[] contexts;
+    private FixedBitSet collapsedSet;
+    private NumericDocValues collapseValues;
+    private IntLongOpenHashMap cmap;
+    private int maxDoc;
+    private int nullPolicy;
+    private float nullScore = -Float.MAX_VALUE;
+    private int nullDoc;
+    private FloatArrayList nullScores;
+    private IntArrayList boostKeys;
+    private IntArrayList boostDocs;
+    private MergeBoost mergeBoost;
+    private boolean boosts;
+    private String field;
+    private int nullValue;
+
+    public IntScoreCollector(int maxDoc,
+                             int segments,
+                             int nullValue,
+                             int nullPolicy,
+                             int size,
+                             String field,
+                             IntIntOpenHashMap boostDocsMap) {
+      this.maxDoc = maxDoc;
+      this.contexts = new LeafReaderContext[segments];
+      this.collapsedSet = new FixedBitSet(maxDoc);
+      this.nullValue = nullValue;
+      this.nullPolicy = nullPolicy;
+      if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+        nullScores = new FloatArrayList();
+      }
+      this.cmap = new IntLongOpenHashMap(size);
+      this.field = field;
+
+      if(boostDocsMap != null) {
+        this.boosts = true;
+        this.boostDocs = new IntArrayList();
+        this.boostKeys = new IntArrayList();
+        int[] bd = new int[boostDocsMap.size()];
+        Iterator<IntIntCursor> it =  boostDocsMap.iterator();
+        int index = -1;
+        while(it.hasNext()) {
+          IntIntCursor cursor = it.next();
+          bd[++index] = cursor.key;
+        }
+
+        Arrays.sort(bd);
+        this.mergeBoost = new MergeBoost(bd);
+        this.boosts = true;
+      }
+
+    }
+
+    @Override
+    public boolean acceptsDocsOutOfOrder() {
+      //Documents must be sent in order to this collector.
+      return false;
+    }
+
+    @Override
+    protected void doSetNextReader(LeafReaderContext context) throws IOException {
+      this.contexts[context.ord] = context;
+      this.docBase = context.docBase;
+      this.collapseValues = DocValues.getNumeric(context.reader(), this.field);
+    }
+
+    @Override
+    public void collect(int contextDoc) throws IOException {
+
+      int collapseValue = (int)this.collapseValues.get(contextDoc);
+      int globalDoc = docBase+contextDoc;
+
+      // Check to see of we have documents boosted by the QueryElevationComponent
+      if(boosts && mergeBoost.boost(globalDoc)) {
+        boostDocs.add(globalDoc);
+        boostKeys.add(collapseValue);
+        return;
+      }
+
+      if(collapseValue != nullValue) {
+        float score = scorer.score();
+        if(cmap.containsKey(collapseValue)) {
+          long scoreDoc = cmap.lget();
+          int testScore = (int)(scoreDoc>>32);
+          int currentScore = Float.floatToRawIntBits(score);
+          if(currentScore > testScore) {
+            //Current score is higher so replace the old scoreDoc with the current scoreDoc
+            cmap.lset((((long)currentScore)<<32)+globalDoc);
+          }
+        } else {
+          //Combine the score and document into a long.
+          long scoreDoc = (((long)Float.floatToRawIntBits(score))<<32)+globalDoc;
+          cmap.put(collapseValue, scoreDoc);
+        }
+      } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
+        float score = scorer.score();
+        if(score > this.nullScore) {
+          this.nullScore = score;
+          this.nullDoc = globalDoc;
+        }
+      } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+        collapsedSet.set(globalDoc);
+        nullScores.add(scorer.score());
+      }
+    }
+
+    @Override
+    public void finish() throws IOException {
+      if(contexts.length == 0) {
+        return;
+      }
+
+      if(nullScore > -1) {
+        collapsedSet.set(nullDoc);
+      }
+
+      //Handle the boosted docs.
+      if(this.boostKeys != null) {
+        int s = boostKeys.size();
+        for(int i=0; i<s; i++) {
+          int key = this.boostKeys.get(i);
+          if(key != nullValue) {
+            cmap.remove(key);
+          }
+          //Add the boosted docs to the collapsedSet
+          this.collapsedSet.set(boostDocs.get(i));
+        }
+      }
+
+      Iterator<IntLongCursor> it1 = cmap.iterator();
+
+      while(it1.hasNext()) {
+        IntLongCursor cursor = it1.next();
+        int doc = (int)cursor.value;
+        collapsedSet.set(doc);
+      }
+
+      int currentContext = 0;
+      int currentDocBase = 0;
+
+      collapseValues = contexts[currentContext].reader().getNumericDocValues(this.field);
+      int nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
+      leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
+      DummyScorer dummy = new DummyScorer();
+      leafDelegate.setScorer(dummy);
+      DocIdSetIterator it = new BitSetIterator(collapsedSet, 0L); // cost is not useful here
+      int globalDoc = -1;
+      int nullScoreIndex = 0;
+      while((globalDoc = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+
+        while(globalDoc >= nextDocBase) {
           currentContext++;
           currentDocBase = contexts[currentContext].docBase;
           nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
           leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
           leafDelegate.setScorer(dummy);
+          collapseValues = contexts[currentContext].reader().getNumericDocValues(this.field);
+        }
+
+        int contextDoc = globalDoc-currentDocBase;
+
+        int collapseValue = (int)collapseValues.get(contextDoc);
+        if(collapseValue != nullValue) {
+          long scoreDoc = cmap.get(collapseValue);
+          dummy.score = Float.intBitsToFloat((int)(scoreDoc>>32));
+        } else if(boosts && mergeBoost.boost(globalDoc)) {
+          //Ignore so boosted documents don't mess up the null scoring policies.
+        } else if (nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
+          dummy.score = nullScore;
+        } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+          dummy.score = nullScores.get(nullScoreIndex++);
         }
 
-        int contextDoc = docId-currentDocBase;
         dummy.docId = contextDoc;
         leafDelegate.collect(contextDoc);
       }
@@ -527,47 +794,55 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       }
     }
   }
+  /*
+  *  Collapse on Ordinal value using max/min value of a field to select the group head.
+  */
 
-  private class CollapsingFieldValueCollector extends DelegatingCollector {
+  private class OrdFieldValueCollector extends DelegatingCollector {
     private LeafReaderContext[] contexts;
-    private SortedDocValues values;
+    private SortedDocValues collapseValues;
+    protected MultiDocValues.OrdinalMap ordinalMap;
+    protected SortedDocValues segmentValues;
+    protected LongValues segmentOrdinalMap;
+    protected MultiDocValues.MultiSortedDocValues multiSortedDocValues;
 
     private int maxDoc;
     private int nullPolicy;
 
-    private FieldValueCollapse fieldValueCollapse;
+    private OrdFieldValueStrategy collapseStrategy;
     private boolean needsScores;
-    private IntIntOpenHashMap boostDocs;
-
-    public CollapsingFieldValueCollector(int maxDoc,
-                                         int segments,
-                                         SortedDocValues values,
-                                         int nullPolicy,
-                                         String field,
-                                         boolean max,
-                                         boolean needsScores,
-                                         FieldType fieldType,
-                                         IntIntOpenHashMap boostDocs,
-                                         FunctionQuery funcQuery, IndexSearcher searcher) throws IOException{
+
+    public OrdFieldValueCollector(int maxDoc,
+                                  int segments,
+                                  SortedDocValues collapseValues,
+                                  int nullPolicy,
+                                  String field,
+                                  boolean max,
+                                  boolean needsScores,
+                                  FieldType fieldType,
+                                  IntIntOpenHashMap boostDocs,
+                                  FunctionQuery funcQuery, IndexSearcher searcher) throws IOException{
 
       this.maxDoc = maxDoc;
       this.contexts = new LeafReaderContext[segments];
-      this.values = values;
-      int valueCount = values.getValueCount();
+      this.collapseValues = collapseValues;
+      if(collapseValues instanceof MultiDocValues.MultiSortedDocValues) {
+        this.multiSortedDocValues = (MultiDocValues.MultiSortedDocValues)collapseValues;
+        this.ordinalMap = multiSortedDocValues.mapping;
+      }
+
+      int valueCount = collapseValues.getValueCount();
       this.nullPolicy = nullPolicy;
       this.needsScores = needsScores;
-      this.boostDocs = boostDocs;
       if(funcQuery != null) {
-        this.fieldValueCollapse =  new ValueSourceCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, funcQuery, searcher, values);
+        this.collapseStrategy =  new OrdValueSourceStrategy(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, funcQuery, searcher, collapseValues);
       } else {
-        if(fieldType instanceof TrieIntField) {
-          this.fieldValueCollapse = new IntValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, values);
-        } else if(fieldType instanceof TrieLongField) {
-          this.fieldValueCollapse =  new LongValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, values);
-        } else if(fieldType instanceof TrieFloatField) {
-          this.fieldValueCollapse =  new FloatValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, values);
+        if(fieldType instanceof TrieIntField || fieldType instanceof TrieFloatField) {
+          this.collapseStrategy = new OrdIntStrategy(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, collapseValues);
+        } else if(fieldType instanceof TrieLongField || fieldType instanceof TrieDoubleField) {
+          this.collapseStrategy =  new OrdLongStrategy(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, collapseValues);
         } else {
-          throw new IOException("min/max must be either TrieInt, TrieLong or TrieFloat.");
+          throw new IOException("min/max must be either TrieInt, TrieLong, TrieFloat or TrieDouble.");
         }
       }
     }
@@ -578,19 +853,33 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public void setScorer(Scorer scorer) {
-      this.fieldValueCollapse.setScorer(scorer);
+      this.collapseStrategy.setScorer(scorer);
     }
 
     public void doSetNextReader(LeafReaderContext context) throws IOException {
       this.contexts[context.ord] = context;
       this.docBase = context.docBase;
-      this.fieldValueCollapse.setNextReader(context);
+      this.collapseStrategy.setNextReader(context);
+      if(ordinalMap != null) {
+        this.segmentValues = this.multiSortedDocValues.values[context.ord];
+        this.segmentOrdinalMap = ordinalMap.getGlobalOrds(context.ord);
+      } else {
+        this.segmentValues = collapseValues;
+      }
     }
 
-    public void collect(int docId) throws IOException {
-      int globalDoc = docId+this.docBase;
-      int ord = values.getOrd(globalDoc);
-      fieldValueCollapse.collapse(ord, docId, globalDoc);
+    public void collect(int contextDoc) throws IOException {
+      int globalDoc = contextDoc+this.docBase;
+      int ord = -1;
+      if(this.ordinalMap != null) {
+        ord = segmentValues.getOrd(contextDoc);
+        if(ord > -1) {
+          ord = (int)segmentOrdinalMap.get(ord);
+        }
+      } else {
+        ord = segmentValues.getOrd(globalDoc);
+      }
+      collapseStrategy.collapse(ord, contextDoc, globalDoc);
     }
 
     public void finish() throws IOException {
@@ -600,23 +889,58 @@ public class CollapsingQParserPlugin extends QParserPlugin {
 
       int currentContext = 0;
       int currentDocBase = 0;
+
+      if(ordinalMap != null) {
+        this.segmentValues = this.multiSortedDocValues.values[currentContext];
+        this.segmentOrdinalMap = this.ordinalMap.getGlobalOrds(currentContext);
+      } else {
+        this.segmentValues = collapseValues;
+      }
+
       int nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
       leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
       DummyScorer dummy = new DummyScorer();
       leafDelegate.setScorer(dummy);
-      DocIdSetIterator it = new BitSetIterator(fieldValueCollapse.getCollapsedSet(), 0); // cost is not useful here
-      int docId = -1;
+      DocIdSetIterator it = new BitSetIterator(collapseStrategy.getCollapsedSet(), 0); // cost is not useful here
+      int globalDoc = -1;
       int nullScoreIndex = 0;
-      float[] scores = fieldValueCollapse.getScores();
-      FloatArrayList nullScores = fieldValueCollapse.getNullScores();
-      float nullScore = fieldValueCollapse.getNullScore();
-      while((docId = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+      float[] scores = collapseStrategy.getScores();
+      FloatArrayList nullScores = collapseStrategy.getNullScores();
+      float nullScore = collapseStrategy.getNullScore();
+
+      MergeBoost mergeBoost = collapseStrategy.getMergeBoost();
+      while((globalDoc = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+
+        while(globalDoc >= nextDocBase) {
+          currentContext++;
+          currentDocBase = contexts[currentContext].docBase;
+          nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
+          leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
+          leafDelegate.setScorer(dummy);
+          if(ordinalMap != null) {
+            this.segmentValues = this.multiSortedDocValues.values[currentContext];
+            this.segmentOrdinalMap = this.ordinalMap.getGlobalOrds(currentContext);
+          }
+        }
+
+        int contextDoc = globalDoc-currentDocBase;
 
         if(this.needsScores){
-          int ord = values.getOrd(docId);
+          int ord = -1;
+          if(this.ordinalMap != null) {
+            //Handle ordinalMapping case
+            ord = segmentValues.getOrd(contextDoc);
+            if(ord > -1) {
+              ord = (int)segmentOrdinalMap.get(ord);
+            }
+          } else {
+            //Handle top Level FieldCache or Single Segment Case
+            ord = segmentValues.getOrd(globalDoc);
+          }
+
           if(ord > -1) {
             dummy.score = scores[ord];
-          } else if (boostDocs != null && boostDocs.containsKey(docId)) {
+          } else if (mergeBoost != null && mergeBoost.boost(globalDoc)) {
             //It's an elevated doc so no score is needed
             dummy.score = 0F;
           } else if (nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
@@ -626,15 +950,6 @@ public class CollapsingQParserPlugin extends QParserPlugin {
           }
         }
 
-        while(docId >= nextDocBase) {
-          currentContext++;
-          currentDocBase = contexts[currentContext].docBase;
-          nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
-          leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
-          leafDelegate.setScorer(dummy);
-        }
-
-        int contextDoc = docId-currentDocBase;
         dummy.docId = contextDoc;
         leafDelegate.collect(contextDoc);
       }
@@ -645,53 +960,373 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
-  private abstract class FieldValueCollapse {
-    protected int nullPolicy;
-    protected int[] ords;
-    protected Scorer scorer;
-    protected FloatArrayList nullScores;
-    protected float nullScore;
-    protected float[] scores;
-    protected FixedBitSet collapsedSet;
-    protected IntIntOpenHashMap boostDocs;
-    protected int[] boostOrds;
-    protected int nullDoc = -1;
-    protected boolean needsScores;
-    protected boolean max;
-    protected String field;
 
-    public abstract void collapse(int ord, int contextDoc, int globalDoc) throws IOException;
-    public abstract void setNextReader(LeafReaderContext context) throws IOException;
+  /*
+  *  Collapses on an integer field using the min/max value of numeric field to select the group head.
+  */
 
-    public FieldValueCollapse(int maxDoc,
-                              String field,
-                              int nullPolicy,
-                              boolean max,
-                              boolean needsScores,
-                              IntIntOpenHashMap boostDocs,
-                              SortedDocValues values) {
-      this.field = field;
-      this.nullPolicy = nullPolicy;
-      this.max = max;
-      this.needsScores = needsScores;
-      this.collapsedSet = new FixedBitSet(maxDoc);
-      this.boostDocs = boostDocs;
-      if(this.boostDocs != null) {
-        IntOpenHashSet boostG = new IntOpenHashSet();
-        Iterator<IntIntCursor> it = boostDocs.iterator();
-        while(it.hasNext()) {
-          IntIntCursor cursor = it.next();
-          int i = cursor.key;
-          this.collapsedSet.set(i);
-          int ord = values.getOrd(i);
-          if(ord > -1) {
-            boostG.add(ord);
+  private class IntFieldValueCollector extends DelegatingCollector {
+    private LeafReaderContext[] contexts;
+    private NumericDocValues collapseValues;
+    private int maxDoc;
+    private int nullValue;
+    private int nullPolicy;
+
+    private IntFieldValueStrategy collapseStrategy;
+    private boolean needsScores;
+    private String collapseField;
+
+    public IntFieldValueCollector(int maxDoc,
+                                  int size,
+                                  int segments,
+                                  int nullValue,
+                                  int nullPolicy,
+                                  String collapseField,
+                                  String field,
+                                  boolean max,
+                                  boolean needsScores,
+                                  FieldType fieldType,
+                                  IntIntOpenHashMap boostDocsMap,
+                                  FunctionQuery funcQuery,
+                                  IndexSearcher searcher) throws IOException{
+
+      this.maxDoc = maxDoc;
+      this.contexts = new LeafReaderContext[segments];
+      this.collapseField = collapseField;
+      this.nullValue = nullValue;
+      this.nullPolicy = nullPolicy;
+      this.needsScores = needsScores;
+      if(funcQuery != null) {
+        this.collapseStrategy =  new IntValueSourceStrategy(maxDoc, field, size, collapseField, nullValue, nullPolicy, max, this.needsScores, boostDocsMap, funcQuery, searcher);
+      } else {
+        if(fieldType instanceof TrieIntField || fieldType instanceof TrieFloatField) {
+          this.collapseStrategy = new IntIntStrategy(maxDoc, size, collapseField, field, nullValue, nullPolicy, max, this.needsScores, boostDocsMap);
+        } else {
+          throw new IOException("min/max must be TrieInt or TrieFloat when collapsing on numeric fields .");
+        }
+      }
+    }
+
+    public boolean acceptsDocsOutOfOrder() {
+      //Documents must be sent in order to this collector.
+      return false;
+    }
+
+    public void setScorer(Scorer scorer) {
+      this.collapseStrategy.setScorer(scorer);
+    }
+
+    public void doSetNextReader(LeafReaderContext context) throws IOException {
+      this.contexts[context.ord] = context;
+      this.docBase = context.docBase;
+      this.collapseStrategy.setNextReader(context);
+      this.collapseValues = context.reader().getNumericDocValues(this.collapseField);
+    }
+
+    public void collect(int contextDoc) throws IOException {
+      int globalDoc = contextDoc+this.docBase;
+      int collapseKey = (int)this.collapseValues.get(contextDoc);
+      collapseStrategy.collapse(collapseKey, contextDoc, globalDoc);
+    }
+
+    public void finish() throws IOException {
+      if(contexts.length == 0) {
+        return;
+      }
+
+      int currentContext = 0;
+      int currentDocBase = 0;
+      this.collapseValues = contexts[currentContext].reader().getNumericDocValues(this.collapseField);
+      int nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
+      leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
+      DummyScorer dummy = new DummyScorer();
+      leafDelegate.setScorer(dummy);
+      DocIdSetIterator it = new BitSetIterator(collapseStrategy.getCollapsedSet(), 0); // cost is not useful here
+      int globalDoc = -1;
+      int nullScoreIndex = 0;
+      IntLongOpenHashMap cmap = collapseStrategy.getCollapseMap();
+      LongArrayList docScores = collapseStrategy.getDocScores();
+      FloatArrayList nullScores = collapseStrategy.getNullScores();
+      MergeBoost mergeBoost = collapseStrategy.getMergeBoost();
+      float nullScore = collapseStrategy.getNullScore();
+
+      while((globalDoc = it.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+
+        while(globalDoc >= nextDocBase) {
+          currentContext++;
+          currentDocBase = contexts[currentContext].docBase;
+          nextDocBase = currentContext+1 < contexts.length ? contexts[currentContext+1].docBase : maxDoc;
+          leafDelegate = delegate.getLeafCollector(contexts[currentContext]);
+          leafDelegate.setScorer(dummy);
+          this.collapseValues = contexts[currentContext].reader().getNumericDocValues(this.collapseField);
+        }
+
+        int contextDoc = globalDoc-currentDocBase;
+
+        if(this.needsScores){
+          int collapseValue = (int)collapseValues.get(contextDoc);
+          if(collapseValue != nullValue) {
+            long pointerValue = cmap.get(collapseValue);
+            //Unpack the pointer
+            int pointer = (int)(pointerValue>>32);
+            long docScore = docScores.get(pointer);
+            //Unpack the score
+            dummy.score = Float.intBitsToFloat(((int)docScore));
+          } else if (mergeBoost != null && mergeBoost.boost(globalDoc)) {
+            //Its an elevated doc so no score is needed
+            dummy.score = 0F;
+          } else if (nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
+            dummy.score = nullScore;
+          } else if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+            dummy.score = nullScores.get(nullScoreIndex++);
           }
         }
-        this.boostOrds = boostG.toArray();
-        Arrays.sort(this.boostOrds);
+
+        dummy.docId = contextDoc;
+        leafDelegate.collect(contextDoc);
+      }
+
+      if(delegate instanceof DelegatingCollector) {
+        ((DelegatingCollector) delegate).finish();
       }
     }
+  }
+
+
+
+  private class CollectorFactory {
+
+
+    public DelegatingCollector getCollector(String collapseField,
+                                            String min,
+                                            String max,
+                                            int nullPolicy,
+                                            String hint,
+                                            boolean needsScores,
+                                            int size,
+                                            IntIntOpenHashMap boostDocs,
+                                            SolrIndexSearcher searcher) throws IOException {
+
+
+
+      SortedDocValues docValues = null;
+      FunctionQuery funcQuery = null;
+
+      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();
+      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();
+
+      if(collapseFieldType instanceof StrField) {
+        if(HINT_TOP_FC.equals(hint)) {
+
+            /*
+            * This hint forces the use of the top level field cache for String fields.
+            * This is VERY fast at query time but slower to warm and causes insanity.
+            */
+
+          Map<String, UninvertingReader.Type> mapping = new HashMap();
+          mapping.put(collapseField, UninvertingReader.Type.SORTED);
+          UninvertingReader uninvertingReader = new UninvertingReader(new ReaderWrapper(searcher.getLeafReader(), collapseField), mapping);
+          docValues = uninvertingReader.getSortedDocValues(collapseField);
+        } else {
+          docValues = DocValues.getSorted(searcher.getLeafReader(), collapseField);
+        }
+      } else {
+        if(HINT_TOP_FC.equals(hint)) {
+          throw new IOException("top_fc hint is only supported when collapsing on String Fields");
+        }
+      }
+
+      FieldType minMaxFieldType = null;
+      if(max != null) {
+        if(max.indexOf("(") == -1) {
+          minMaxFieldType = searcher.getSchema().getField(max).getType();
+        } else {
+          LocalSolrQueryRequest request = null;
+          try {
+            SolrParams params = new ModifiableSolrParams();
+            request = new LocalSolrQueryRequest(searcher.getCore(), params);
+            FunctionQParser functionQParser = new FunctionQParser(max, null, null,request);
+            funcQuery = (FunctionQuery)functionQParser.parse();
+          } catch (Exception e) {
+            throw new IOException(e);
+          } finally {
+            request.close();
+          }
+        }
+      }
+
+      if(min != null) {
+        if(min.indexOf("(") == -1) {
+          minMaxFieldType = searcher.getSchema().getField(min).getType();
+        } else {
+          LocalSolrQueryRequest request = null;
+          try {
+            SolrParams params = new ModifiableSolrParams();
+            request = new LocalSolrQueryRequest(searcher.getCore(), params);
+            FunctionQParser functionQParser = new FunctionQParser(min, null, null,request);
+            funcQuery = (FunctionQuery)functionQParser.parse();
+          } catch (Exception e) {
+            throw new IOException(e);
+          } finally {
+            request.close();
+          }
+        }
+      }
+
+      int maxDoc = searcher.maxDoc();
+      int leafCount = searcher.getTopReaderContext().leaves().size();
+
+      if (min != null || max != null) {
+
+        if(collapseFieldType instanceof StrField) {
+
+          return new OrdFieldValueCollector(maxDoc,
+                                            leafCount,
+                                            docValues,
+                                            nullPolicy,
+                                            max != null ? max : min,
+                                            max != null,
+                                            needsScores,
+                                            minMaxFieldType,
+                                            boostDocs,
+                                            funcQuery,
+                                            searcher);
+
+        } else if((collapseFieldType instanceof TrieIntField ||
+                   collapseFieldType instanceof TrieFloatField)) {
+
+          int nullValue = 0;
+
+          if(collapseFieldType instanceof TrieFloatField) {
+            if(defaultValue != null) {
+              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));
+            } else {
+              nullValue = Float.floatToIntBits(0.0f);
+            }
+          } else {
+            if(defaultValue != null) {
+              nullValue = Integer.parseInt(defaultValue);
+            }
+          }
+
+          return new IntFieldValueCollector(maxDoc,
+                                            size,
+                                            leafCount,
+                                            nullValue,
+                                            nullPolicy,
+                                            collapseField,
+                                            max != null ? max : min,
+                                            max != null,
+                                            needsScores,
+                                            minMaxFieldType,
+                                            boostDocs,
+                                            funcQuery,
+                                            searcher);
+        } else {
+          throw new IOException("64 bit numeric collapse fields are not supported");
+        }
+
+      } else {
+
+        if(collapseFieldType instanceof StrField) {
+
+          return new OrdScoreCollector(maxDoc, leafCount, docValues, nullPolicy, boostDocs);
+
+        } else if(collapseFieldType instanceof TrieIntField ||
+                  collapseFieldType instanceof TrieFloatField) {
+
+          int nullValue = 0;
+
+          if(collapseFieldType instanceof TrieFloatField) {
+            if(defaultValue != null) {
+              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));
+            } else {
+              nullValue = Float.floatToIntBits(0.0f);
+            }
+          } else {
+            if(defaultValue != null) {
+              nullValue = Integer.parseInt(defaultValue);
+            }
+          }
+
+          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);
+
+        } else {
+          throw new IOException("64 bit numeric collapse fields are not supported");
+        }
+      }
+    }
+  }
+
+  public static final class CollapseScore {
+    public float score;
+  }
+
+
+  /*
+  * Collapse Strategies
+  */
+
+  /*
+  * The abstract base Strategy for collapse strategies that collapse on an ordinal
+  * using min/max field value to select the group head.
+  *
+  */
+
+  private abstract class OrdFieldValueStrategy {
+    protected int nullPolicy;
+    protected int[] ords;
+    protected Scorer scorer;
+    protected FloatArrayList nullScores;
+    protected float nullScore;
+    protected float[] scores;
+    protected FixedBitSet collapsedSet;
+    protected int nullDoc = -1;
+    protected boolean needsScores;
+    protected boolean max;
+    protected String field;
+    protected boolean boosts;
+    protected IntArrayList boostOrds;
+    protected IntArrayList boostDocs;
+    protected MergeBoost mergeBoost;
+    protected boolean boosted;
+
+    public abstract void collapse(int ord, int contextDoc, int globalDoc) throws IOException;
+    public abstract void setNextReader(LeafReaderContext context) throws IOException;
+
+    public OrdFieldValueStrategy(int maxDoc,
+                                 String field,
+                                 int nullPolicy,
+                                 boolean max,
+                                 boolean needsScores,
+                                 IntIntOpenHashMap boostDocsMap,
+                                 SortedDocValues values) {
+      this.field = field;
+      this.nullPolicy = nullPolicy;
+      this.max = max;
+      this.needsScores = needsScores;
+      this.collapsedSet = new FixedBitSet(maxDoc);
+      if(boostDocsMap != null) {
+        this.boosts = true;
+        this.boostOrds = new IntArrayList();
+        this.boostDocs = new IntArrayList();
+        int[] bd = new int[boostDocsMap.size()];
+        Iterator<IntIntCursor> it =  boostDocsMap.iterator();
+        int index = -1;
+        while(it.hasNext()) {
+          IntIntCursor cursor = it.next();
+          bd[++index] = cursor.key;
+        }
+
+        Arrays.sort(bd);
+        this.mergeBoost = new MergeBoost(bd);
+        this.boosted = true;
+      }
+    }
+
+    public MergeBoost getMergeBoost() {
+      return this.mergeBoost;
+    }
 
     public FixedBitSet getCollapsedSet() {
       if(nullDoc > -1) {
@@ -699,9 +1334,16 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       }
 
       if(this.boostOrds != null) {
-        for(int i=0; i<this.boostOrds.length; i++) {
-          ords[boostOrds[i]] = -1;
+        int s = boostOrds.size();
+        for(int i=0; i<s; i++) {
+          int ord = boostOrds.get(i);
+          if(ord > -1) {
+            ords[ord] = -1;
+          }
+          collapsedSet.set(boostDocs.get(i));
         }
+
+        mergeBoost.reset();
       }
 
       for(int i=0; i<ords.length; i++) {
@@ -731,20 +1373,25 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
-  private class IntValueCollapse extends FieldValueCollapse {
+  /*
+  * Strategy for collapsing on ordinal using min/max of an int field to select the group head.
+  */
+
+  private class OrdIntStrategy extends OrdFieldValueStrategy {
 
-    private NumericDocValues vals;
+    private NumericDocValues minMaxValues;
     private IntCompare comp;
     private int nullVal;
     private int[] ordVals;
 
-    public IntValueCollapse(int maxDoc,
-                            String field,
-                            int nullPolicy,
-                            int[] ords,
-                            boolean max,
-                            boolean needsScores,
-                            IntIntOpenHashMap boostDocs, SortedDocValues values) throws IOException {
+    public OrdIntStrategy(int maxDoc,
+                          String field,
+                          int nullPolicy,
+                          int[] ords,
+                          boolean max,
+                          boolean needsScores,
+                          IntIntOpenHashMap boostDocs,
+                          SortedDocValues values) throws IOException {
       super(maxDoc, field, nullPolicy, max, needsScores, boostDocs, values);
       this.ords = ords;
       this.ordVals = new int[ords.length];
@@ -768,24 +1415,30 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public void setNextReader(LeafReaderContext context) throws IOException {
-      this.vals = DocValues.getNumeric(context.reader(), this.field);
+      this.minMaxValues = DocValues.getNumeric(context.reader(), this.field);
     }
 
     public void collapse(int ord, int contextDoc, int globalDoc) throws IOException {
-      int val = (int) vals.get(contextDoc);
+
+      if(this.boosted && mergeBoost.boost(globalDoc)) {
+        this.boostDocs.add(globalDoc);
+        this.boostOrds.add(ord);
+        return;
+      }
+
+      int currentVal = (int) minMaxValues.get(contextDoc);
+
       if(ord > -1) {
-        if(comp.test(val, ordVals[ord])) {
+        if(comp.test(currentVal, ordVals[ord])) {
           ords[ord] = globalDoc;
-          ordVals[ord] = val;
+          ordVals[ord] = currentVal;
           if(needsScores) {
             scores[ord] = scorer.score();
           }
         }
-      } else if(this.collapsedSet.get(globalDoc)) {
-        // Elevated doc so do nothing.
       } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
-        if(comp.test(val, nullVal)) {
-          nullVal = val;
+        if(comp.test(currentVal, nullVal)) {
+          nullVal = currentVal;
           nullDoc = globalDoc;
           if(needsScores) {
             nullScore = scorer.score();
@@ -800,19 +1453,24 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
-  private class LongValueCollapse extends FieldValueCollapse {
+  /*
+  * Strategy for collapsing on ordinal and using the min/max value of a long
+  * field to select the group head
+  */
+
+  private class OrdLongStrategy extends OrdFieldValueStrategy {
 
-    private NumericDocValues vals;
+    private NumericDocValues minMaxVals;
     private LongCompare comp;
     private long nullVal;
     private long[] ordVals;
 
-    public LongValueCollapse(int maxDoc, String field,
-                             int nullPolicy,
-                             int[] ords,
-                             boolean max,
-                             boolean needsScores,
-                             IntIntOpenHashMap boostDocs, SortedDocValues values) throws IOException {
+    public OrdLongStrategy(int maxDoc, String field,
+                           int nullPolicy,
+                           int[] ords,
+                           boolean max,
+                           boolean needsScores,
+                           IntIntOpenHashMap boostDocs, SortedDocValues values) throws IOException {
       super(maxDoc, field, nullPolicy, max, needsScores, boostDocs, values);
       this.ords = ords;
       this.ordVals = new long[ords.length];
@@ -836,24 +1494,29 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public void setNextReader(LeafReaderContext context) throws IOException {
-      this.vals = DocValues.getNumeric(context.reader(), this.field);
+      this.minMaxVals = DocValues.getNumeric(context.reader(), this.field);
     }
 
     public void collapse(int ord, int contextDoc, int globalDoc) throws IOException {
-      long val = vals.get(contextDoc);
+
+      if(boosted && mergeBoost.boost(globalDoc)) {
+        this.boostOrds.add(ord);
+        this.boostDocs.add(globalDoc);
+        return;
+      }
+
+      long currentVal = minMaxVals.get(contextDoc);
       if(ord > -1) {
-        if(comp.test(val, ordVals[ord])) {
+        if(comp.test(currentVal, ordVals[ord])) {
           ords[ord] = globalDoc;
-          ordVals[ord] = val;
+          ordVals[ord] = currentVal;
           if(needsScores) {
             scores[ord] = scorer.score();
           }
         }
-      } else if (this.collapsedSet.get(globalDoc)) {
-        //Elevated doc so do nothing
       } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
-        if(comp.test(val, nullVal)) {
-          nullVal = val;
+        if(comp.test(currentVal, nullVal)) {
+          nullVal = currentVal;
           nullDoc = globalDoc;
           if(needsScores) {
             nullScore = scorer.score();
@@ -868,21 +1531,36 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
-  private class FloatValueCollapse extends FieldValueCollapse {
+  /*
+  * Strategy for collapsing on ordinal and using the min/max value of a value source function
+  * to select the group head
+  */
+
+  private class OrdValueSourceStrategy extends OrdFieldValueStrategy {
 
-    private NumericDocValues vals;
     private FloatCompare comp;
     private float nullVal;
+    private ValueSource valueSource;
+    private FunctionValues functionValues;
     private float[] ordVals;
+    private Map rcontext;
+    private CollapseScore collapseScore = new CollapseScore();
+    private float score;
+    private boolean cscore;
 
-    public FloatValueCollapse(int maxDoc,
-                              String field,
-                              int nullPolicy,
-                              int[] ords,
-                              boolean max,
-                              boolean needsScores,
-                              IntIntOpenHashMap boostDocs, SortedDocValues values) throws IOException {
-      super(maxDoc, field, nullPolicy, max, needsScores, boostDocs, values);
+    public OrdValueSourceStrategy(int maxDoc,
+                                  String funcStr,
+                                  int nullPolicy,
+                                  int[] ords,
+                                  boolean max,
+                                  boolean needsScores,
+                                  IntIntOpenHashMap boostDocs,
+                                  FunctionQuery funcQuery,
+                                  IndexSearcher searcher,
+                                  SortedDocValues values) throws IOException {
+      super(maxDoc, null, nullPolicy, max, needsScores, boostDocs, values);
+      this.valueSource = funcQuery.getValueSource();
+      this.rcontext = ValueSource.newContext(searcher);
       this.ords = ords;
       this.ordVals = new float[ords.length];
       Arrays.fill(ords, -1);
@@ -896,7 +1574,12 @@ public class CollapsingQParserPlugin extends QParserPlugin {
         Arrays.fill(ordVals, Float.MAX_VALUE);
       }
 
-      if(needsScores) {
+      if(funcStr.indexOf("cscore()") != -1) {
+        this.cscore = true;
+        this.rcontext.put("CSCORE",this.collapseScore);
+      }
+
+      if(this.needsScores) {
         this.scores = new float[ords.length];
         if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
           nullScores = new FloatArrayList();
@@ -905,24 +1588,271 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
 
     public void setNextReader(LeafReaderContext context) throws IOException {
-      this.vals = DocValues.getNumeric(context.reader(), this.field);
+      functionValues = this.valueSource.getValues(rcontext, context);
     }
 
     public void collapse(int ord, int contextDoc, int globalDoc) throws IOException {
-      float val = Float.intBitsToFloat((int)vals.get(contextDoc));
+
+      if(boosted && mergeBoost.boost(globalDoc)) {
+        this.boostOrds.add(ord);
+        this.boostDocs.add(globalDoc);
+      }
+
+      if(needsScores || cscore) {
+        this.score = scorer.score();
+        this.collapseScore.score = score;
+      }
+
+      float currentVal = functionValues.floatVal(contextDoc);
+
       if(ord > -1) {
-        if(comp.test(val, ordVals[ord])) {
+        if(comp.test(currentVal, ordVals[ord])) {
           ords[ord] = globalDoc;
-          ordVals[ord] = val;
+          ordVals[ord] = currentVal;
           if(needsScores) {
-            scores[ord] = scorer.score();
+            scores[ord] = score;
+          }
+        }
+      } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
+        if(comp.test(currentVal, nullVal)) {
+          nullVal = currentVal;
+          nullDoc = globalDoc;
+          if(needsScores) {
+            nullScore = score;
+          }
+        }
+      } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+        this.collapsedSet.set(globalDoc);
+        if(needsScores) {
+          nullScores.add(score);
+        }
+      }
+    }
+  }
+
+
+  /*
+  * Base strategy for collapsing on a 32 bit numeric field and selecting a group head
+  * based on min/max value of a 32 bit numeric field.
+  */
+
+  private abstract class IntFieldValueStrategy {
+    protected int nullPolicy;
+    protected IntLongOpenHashMap cmap;
+    protected Scorer scorer;
+    protected FloatArrayList nullScores;
+    protected float nullScore;
+    protected float[] scores;
+    protected FixedBitSet collapsedSet;
+    protected int nullDoc = -1;
+    protected boolean needsScores;
+    protected boolean max;
+    protected String field;
+    protected String collapseField;
+    protected LongArrayList docScores;
+    protected IntArrayList docs;
+    protected int nullValue;
+    protected IntArrayList boostDocs;
+    protected IntArrayList boostKeys;
+    protected boolean boosts;
+    protected MergeBoost mergeBoost;
+
+    public abstract void collapse(int collapseKey, int contextDoc, int globalDoc) throws IOException;
+    public abstract void setNextReader(LeafReaderContext context) throws IOException;
+
+    public IntFieldValueStrategy(int maxDoc,
+                                 int size,
+                                 String collapseField,
+                                 String field,
+                                 int nullValue,
+                                 int nullPolicy,
+                                 boolean max,
+                                 boolean needsScores,
+                                 IntIntOpenHashMap boostDocsMap) {
+      this.field = field;
+      this.collapseField = collapseField;
+      this.nullValue = nullValue;
+      this.nullPolicy = nullPolicy;
+      this.max = max;
+      this.needsScores = needsScores;
+      this.collapsedSet = new FixedBitSet(maxDoc);
+      this.cmap = new IntLongOpenHashMap(size);
+      if(boostDocsMap != null) {
+        this.boosts = true;
+        this.boostDocs = new IntArrayList();
+        this.boostKeys = new IntArrayList();
+        int[] bd = new int[boostDocsMap.size()];
+        Iterator<IntIntCursor> it =  boostDocsMap.iterator();
+        int index = -1;
+        while(it.hasNext()) {
+          IntIntCursor cursor = it.next();
+          bd[++index] = cursor.key;
+        }
+
+        Arrays.sort(bd);
+        this.mergeBoost = new MergeBoost(bd);
+      }
+    }
+
+    public FixedBitSet getCollapsedSet() {
+
+      if(nullDoc > -1) {
+        this.collapsedSet.set(nullDoc);
+      }
+
+      //Handle the boosted docs.
+      if(this.boostKeys != null) {
+        int s = boostKeys.size();
+        for(int i=0; i<s; i++) {
+          int key = this.boostKeys.get(i);
+          if(key != nullValue) {
+            cmap.remove(key);
+          }
+          //Add the boosted docs to the collapsedSet
+          this.collapsedSet.set(boostDocs.get(i));
+        }
+
+        mergeBoost.reset();
+      }
+
+      Iterator<IntLongCursor> it1 = cmap.iterator();
+
+     if(needsScores) {
+       while(it1.hasNext()) {
+         IntLongCursor cursor = it1.next();
+         int pointer = (int)(cursor.value>>32);
+         collapsedSet.set((int)(docScores.get(pointer)>>32));
+       }
+     } else {
+      while(it1.hasNext()) {
+        IntLongCursor cursor = it1.next();
+        int pointer = (int)(cursor.value>>32);
+        collapsedSet.set(docs.get(pointer));
+      }
+     }
+
+      return collapsedSet;
+    }
+
+    public void setScorer(Scorer scorer) {
+      this.scorer = scorer;
+    }
+
+    public FloatArrayList getNullScores() {
+      return nullScores;
+    }
+
+    public IntLongOpenHashMap getCollapseMap() {
+      return cmap;
+    }
+
+    public float getNullScore() {
+      return this.nullScore;
+    }
+
+    public LongArrayList getDocScores() {
+      return this.docScores;
+    }
+
+    public float[] getScores() {
+      return scores;
+    }
+
+    public MergeBoost getMergeBoost()  {
+      return this.mergeBoost;
+    }
+  }
+
+  /*
+  *  Strategy for collapsing on a 32 bit numeric field and selecting the group head based
+  *  on the min/max value of a 32 bit field numeric field.
+  */
+
+  private class IntIntStrategy extends IntFieldValueStrategy {
+
+    private NumericDocValues minMaxVals;
+    private IntCompare comp;
+    private int nullCompVal;
+
+    private int index=-1;
+
+    public IntIntStrategy(int maxDoc,
+                          int size,
+                          String collapseField,
+                          String field,
+                          int nullValue,
+                          int nullPolicy,
+                          boolean max,
+                          boolean needsScores,
+                          IntIntOpenHashMap boostDocs) throws IOException {
+
+      super(maxDoc, size, collapseField, field, nullValue, nullPolicy, max, needsScores, boostDocs);
+
+      if(max) {
+        comp = new MaxIntComp();
+      } else {
+        comp = new MinIntComp();
+        this.nullCompVal = Integer.MAX_VALUE;
+      }
+
+      if(needsScores) {
+        this.docScores = new LongArrayList();
+        if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
+          nullScores = new FloatArrayList();
+        }
+      } else {
+        this.docs = new IntArrayList();
+      }
+    }
+
+    public void setNextReader(LeafReaderContext context) throws IOException {
+      this.minMaxVals = DocValues.getNumeric(context.reader(), this.field);
+    }
+
+    public void collapse(int collapseKey, int contextDoc, int globalDoc) throws IOException {
+
+      // Check to see if we have documents boosted by the QueryElevationComponent
+      if(boosts && mergeBoost.boost(globalDoc)) {
+        boostDocs.add(globalDoc);
+        boostKeys.add(collapseKey);
+        return;
+      }
+
+      int currentVal = (int) minMaxVals.get(contextDoc);
+
+      if(collapseKey != nullValue) {
+        if(cmap.containsKey(collapseKey)) {
+          long pointerValue = cmap.lget();
+          int testValue = (int)pointerValue;
+          if(comp.test(currentVal, testValue)) {
+            pointerValue = (pointerValue-testValue)+currentVal;
+            cmap.lset(pointerValue);
+            int pointer = (int)(pointerValue>>32);
+            if(needsScores) {
+              float score = scorer.score();
+              long docScore = (((long)globalDoc)<<32)+Float.floatToIntBits(score);
+              docScores.set(pointer, docScore);
+            } else {
+              docs.set(pointer, globalDoc);
+            }
+          }
+        } else {
+          ++index;
+          //The index provides a pointer into docs or docScore lists.
+          //Combined the pointer with the current value into a long
+          long pointerValue = (((long)index)<<32)+currentVal;
+          cmap.put(collapseKey, pointerValue);
+          if(needsScores) {
+            float score = scorer.score();
+            long docScore = (((long)globalDoc)<<32)+Float.floatToIntBits(score);
+            docScores.add(docScore);
+          } else {
+            docs.add(globalDoc);
           }
         }
-      } else if (this.collapsedSet.get(globalDoc)) {
-        //Elevated doc so do nothing
       } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
-        if(comp.test(val, nullVal)) {
-          nullVal = val;
+        if(comp.test(currentVal, nullCompVal)) {
+          nullCompVal = currentVal;
           nullDoc = globalDoc;
           if(needsScores) {
             nullScore = scorer.score();
@@ -937,40 +1867,48 @@ public class CollapsingQParserPlugin extends QParserPlugin {
     }
   }
 
-  private class ValueSourceCollapse extends FieldValueCollapse {
 
-    private FloatCompare comp;
-    private float nullVal;
+  /*
+  *  Strategy for collapsing on a 32 bit numeric field and selecting the group head based
+  *  on the min/max value of a Value Source Function.
+  */
+
+  private class IntValueSourceStrategy extends IntFieldValueStrategy {
+
+    private IntCompare comp;
+    private int nullCompVal;
+
     private ValueSource valueSource;
     private FunctionValues functionValues;
-    private float[] ordVals;
     private Map rcontext;
     private CollapseScore collapseScore = new CollapseScore();
-    private float score;
     private boolean cscore;
+    private float score;
+    private int index=-1;
+
+    public IntValueSourceStrategy(int maxDoc,
+                                  String funcStr,
+                                  int size,
+                                  String collapseField,
+                                  int nullValue,
+                                  int nullPolicy,
+                                  boolean max,
+                                  boolean needsScores,
+                                  IntIntOpenHashMap boostDocs,
+                                  FunctionQuery funcQuery,
+                                  IndexSearcher searcher) throws IOException {
+
+      super(maxDoc, size, collapseField, null, nullValue, nullPolicy, max, needsScores, boostDocs);
 
-    public ValueSourceCollapse(int maxDoc,
-                               String funcStr,
-                               int nullPolicy,
-                               int[] ords,
-                               boolean max,
-                               boolean needsScores,
-                               IntIntOpenHashMap boostDocs,
-                               FunctionQuery funcQuery, IndexSearcher searcher, SortedDocValues values) throws IOException {
-      super(maxDoc, null, nullPolicy, max, needsScores, boostDocs, values);
       this.valueSource = funcQuery.getValueSource();
       this.rcontext = ValueSource.newContext(searcher);
-      this.ords = ords;
-      this.ordVals = new float[ords.length];
-      Arrays.fill(ords, -1);
 
       if(max) {
-        comp = new MaxFloatComp();
-        Arrays.fill(ordVals, -Float.MAX_VALUE );
+        this.nullCompVal = Integer.MIN_VALUE;
+        comp = new MaxIntComp();
       } else {
-        this.nullVal = Float.MAX_VALUE;
-        comp = new MinFloatComp();
-        Arrays.fill(ordVals, Float.MAX_VALUE);
+        this.nullCompVal = Integer.MAX_VALUE;
+        comp = new MinIntComp();
       }
 
       if(funcStr.indexOf("cscore()") != -1) {
@@ -978,11 +1916,13 @@ public class CollapsingQParserPlugin extends QParserPlugin {
         this.rcontext.put("CSCORE",this.collapseScore);
       }
 
-      if(this.needsScores) {
-        this.scores = new float[ords.length];
+      if(needsScores) {
+        this.docScores = new LongArrayList();
         if(nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
           nullScores = new FloatArrayList();
         }
+      } else {
+        this.docs = new IntArrayList();
       }
     }
 
@@ -990,43 +1930,104 @@ public class CollapsingQParserPlugin extends QParserPlugin {
       functionValues = this.valueSource.getValues(rcontext, context);
     }
 
-    public void collapse(int ord, int contextDoc, int globalDoc) throws IOException {
+    public void collapse(int collapseKey, int contextDoc, int globalDoc) throws IOException {
+
+      // Check to see if we have documents boosted by the QueryElevationComponent
+      if(boosts && mergeBoost.boost(globalDoc)) {
+        boostDocs.add(globalDoc);
+        boostKeys.add(collapseKey);
+        return;
+      }
+
       if(needsScores || cscore) {
         this.score = scorer.score();
         this.collapseScore.score = score;
       }
 
-      float val = functionValues.floatVal(contextDoc);
-
-      if(ord > -1) {
-        if(comp.test(val, ordVals[ord])) {
-          ords[ord] = globalDoc;
-          ordVals[ord] = val;
+      float functionValue = functionValues.floatVal(contextDoc);
+      int currentVal = Float.floatToRawIntBits(functionValue);
+
+      if(collapseKey != nullValue) {
+        if(cmap.containsKey(collapseKey)) {
+          long pointerValue = cmap.lget();
+          int testValue = (int)pointerValue;
+          if(comp.test(currentVal, testValue)) {
+            pointerValue = (pointerValue-testValue)+currentVal;
+            cmap.lset(pointerValue);
+            int pointer = (int)(pointerValue>>32);
+            if(needsScores){
+              //Combine the doc and score into a long
+              long docScore = (((long)globalDoc)<<32)+Float.floatToIntBits(score);
+              docScores.set(pointer, docScore);
+            } else {
+              docs.set(pointer, globalDoc);
+            }
+          }
+        } else {
+          ++index;
+          //Use the index as a pointer into the docScore and docs list.
+          long pointerValue = (((long)index)<<32)+currentVal;
+          cmap.put(collapseKey, pointerValue);
           if(needsScores) {
-            scores[ord] = score;
+            //Combine the doc and score into a long
+            long docScore = (((long)globalDoc)<<32)+Float.floatToIntBits(score);
+            docScores.add(docScore);
+          } else {
+            docs.add(globalDoc);
           }
         }
-      } else if (this.collapsedSet.get(globalDoc)) {
-        //Elevated doc so do nothing
       } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_COLLAPSE) {
-        if(comp.test(val, nullVal)) {
-          nullVal = val;
+        if(comp.test(currentVal, nullCompVal)) {
+          nullCompVal = currentVal;
           nullDoc = globalDoc;
           if(needsScores) {
-            nullScore = score;
+            nullScore = scorer.score();
           }
         }
       } else if(this.nullPolicy == CollapsingPostFilter.NULL_POLICY_EXPAND) {
         this.collapsedSet.set(globalDoc);
         if(needsScores) {
-          nullScores.add(score);
+          nullScores.add(scorer.score());
         }
       }
     }
   }
 
-  public static final class CollapseScore {
-    public float score;
+  private class MergeBoost {
+
+    private int[] boostDocs;
+    private int index = 0;
+
+    public MergeBoost(int[] boostDocs) {
+      this.boostDocs = boostDocs;
+    }
+
+    public void reset() {
+      this.index = 0;
+    }
+
+    public boolean boost(int globalDoc) {
+      if(index == Integer.MIN_VALUE) {
+        return false;
+      } else {
+        while(true) {
+          if(index >= boostDocs.length) {
+            index = Integer.MIN_VALUE;
+            return false;
+          } else {
+            int comp = boostDocs[index];
+            if(comp == globalDoc) {
+              ++index;
+              return true;
+            } else if(comp < globalDoc) {
+              ++index;
+            } else {
+              return false;
+            }
+          }
+        }
+      }
+    }
   }
 
   private interface IntCompare {
diff --git a/solr/core/src/test/org/apache/solr/handler/component/TestExpandComponent.java b/solr/core/src/test/org/apache/solr/handler/component/TestExpandComponent.java
index 2da638d..19d9a64 100644
--- a/solr/core/src/test/org/apache/solr/handler/component/TestExpandComponent.java
+++ b/solr/core/src/test/org/apache/solr/handler/component/TestExpandComponent.java
@@ -19,6 +19,7 @@ package org.apache.solr.handler.component;
 
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.search.CollapsingQParserPlugin;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -43,14 +44,46 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
     assertU(commit());
   }
 
+
+
   @Test
   public void testExpand() throws Exception {
-    final String group = (random().nextBoolean() ? "group_s" : "group_s_dv");
-    
-    String[] doc = {"id","1", "term_s", "YYYY", group, "group1", "test_ti", "5", "test_tl", "10", "test_tf", "2000", "type_s", "parent"};
+    List<String> groups = new ArrayList();
+    groups.add("group_s");
+    groups.add("group_s_dv");
+
+    Collections.shuffle(groups, random());
+    String floatAppend = "";
+
+    String hint = (random().nextBoolean() ? " hint="+ CollapsingQParserPlugin.HINT_TOP_FC : "");
+
+     _testExpand(groups.get(0), floatAppend, hint);
+  }
+
+  @Test
+  public void testNumericExpand() throws Exception {
+    List<String> groups = new ArrayList();
+    groups.add("group_i");
+    groups.add("group_ti_dv");
+    groups.add("group_f");
+    groups.add("group_tf_dv");
+    Collections.shuffle(groups, random());
+    String floatAppend = "";
+    if(groups.get(0).indexOf("f") > -1) {
+      floatAppend = "."+random().nextInt(100);  //Append the float
+    }
+
+    String hint = "";
+
+      _testExpand(groups.get(0), floatAppend, hint);
+  }
+
+  private void _testExpand(String group, String floatAppend, String hint) throws Exception {
+
+    String[] doc = {"id","1", "term_s", "YYYY", group, "1"+floatAppend, "test_ti", "5", "test_tl", "10", "test_tf", "2000", "type_s", "parent"};
     assertU(adoc(doc));
     assertU(commit());
-    String[] doc1 = {"id","2", "term_s","YYYY", group, "group1", "test_ti", "50", "test_tl", "100", "test_tf", "200", "type_s", "child"};
+    String[] doc1 = {"id","2", "term_s","YYYY", group, "1"+floatAppend, "test_ti", "50", "test_tl", "100", "test_tf", "200", "type_s", "child"};
     assertU(adoc(doc1));
 
     String[] doc2 = {"id","3", "term_s", "YYYY", "test_ti", "5000", "test_tl", "100", "test_tf", "200"};
@@ -60,17 +93,17 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
     assertU(adoc(doc3));
 
 
-    String[] doc4 = {"id","5", "term_s", "YYYY", group, "group2", "test_ti", "4", "test_tl", "10", "test_tf", "2000", "type_s", "parent"};
+    String[] doc4 = {"id","5", "term_s", "YYYY", group, "2"+floatAppend, "test_ti", "4", "test_tl", "10", "test_tf", "2000", "type_s", "parent"};
     assertU(adoc(doc4));
     assertU(commit());
-    String[] doc5 = {"id","6", "term_s","YYYY", group, "group2", "test_ti", "10", "test_tl", "100", "test_tf", "200", "type_s", "child"};
+    String[] doc5 = {"id","6", "term_s","YYYY", group, "2"+floatAppend, "test_ti", "10", "test_tl", "100", "test_tf", "200", "type_s", "child"};
     assertU(adoc(doc5));
     assertU(commit());
 
-    String[] doc6 = {"id","7", "term_s", "YYYY", group, "group1", "test_ti", "1", "test_tl", "100000", "test_tf", "2000", "type_s", "child"};
+    String[] doc6 = {"id","7", "term_s", "YYYY", group, "1"+floatAppend, "test_ti", "1", "test_tl", "100000", "test_tf", "2000", "type_s", "child"};
     assertU(adoc(doc6));
     assertU(commit());
-    String[] doc7 = {"id","8", "term_s","YYYY", group, "group2", "test_ti", "2", "test_tl", "100000", "test_tf", "200", "type_s", "child"};
+    String[] doc7 = {"id","8", "term_s","YYYY", group, "2"+floatAppend, "test_ti", "2", "test_tl", "100000", "test_tf", "200", "type_s", "child"};
     assertU(adoc(doc7));
 
     assertU(commit());
@@ -78,7 +111,7 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
     //First basic test case.
     ModifiableSolrParams params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -86,17 +119,17 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='2.0']",
         "/response/result/doc[2]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='1.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='8.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='1.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='5.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='8.0']"
     );
 
     //Basic test case page 2
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -105,14 +138,14 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
     assertQ(req(params), "*[count(/response/result/doc)=1]",
         "*[count(/response/lst[@name='expanded']/result)=1]",
         "/response/result/doc[1]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='8.0']"
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='5.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='8.0']"
     );
 
     //Test expand.sort
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -121,17 +154,17 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='2.0']",
         "/response/result/doc[2]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='1.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='5.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='1.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='5.0']"
     );
 
     //Test with nullPolicy, ExpandComponent should ignore docs with null values in the collapse fields.
     //Main result set should include the doc with null value in the collapse field.
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+hint+" nullPolicy=collapse}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -141,10 +174,10 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "/response/result/doc[1]/float[@name='id'][.='3.0']",
         "/response/result/doc[2]/float[@name='id'][.='2.0']",
         "/response/result/doc[3]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='1.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='5.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='1.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='5.0']"
     );
 
 
@@ -162,10 +195,10 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='1.0']",
         "/response/result/doc[2]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='2.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='6.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='2.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='6.0']"
     );
 
 
@@ -184,10 +217,10 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='1.0']",
         "/response/result/doc[2]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='2.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='6.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='2.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='6.0']"
     );
 
     //Test overide expand.fq and expand.q
@@ -206,17 +239,17 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='1.0']",
         "/response/result/doc[2]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='2.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='6.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='2.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='6.0']"
     );
 
     //Test expand.rows
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -224,12 +257,12 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
     params.add("expand.rows", "1");
     assertQ(req(params), "*[count(/response/result/doc)=2]",
         "*[count(/response/lst[@name='expanded']/result)=2]",
-        "*[count(/response/lst[@name='expanded']/result[@name='group1']/doc)=1]",
-        "*[count(/response/lst[@name='expanded']/result[@name='group2']/doc)=1]",
+        "*[count(/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc)=1]",
+        "*[count(/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc)=1]",
         "/response/result/doc[1]/float[@name='id'][.='2.0']",
         "/response/result/doc[2]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='8.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='8.0']"
     );
 
 
@@ -237,7 +270,7 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "test_ti:5");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -251,7 +284,7 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "test_ti:5532535");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -265,7 +298,7 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("expand", "true");
@@ -274,10 +307,10 @@ public class TestExpandComponent extends SolrTestCaseJ4 {
         "*[count(/response/lst[@name='expanded']/result)=2]",
         "/response/result/doc[1]/float[@name='id'][.='2.0']",
         "/response/result/doc[2]/float[@name='id'][.='6.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[1]/float[@name='id'][.='1.0']",
-        "/response/lst[@name='expanded']/result[@name='group1']/doc[2]/float[@name='id'][.='7.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[1]/float[@name='id'][.='5.0']",
-        "/response/lst[@name='expanded']/result[@name='group2']/doc[2]/float[@name='id'][.='8.0']"
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[1]/float[@name='id'][.='1.0']",
+        "/response/lst[@name='expanded']/result[@name='1"+floatAppend+"']/doc[2]/float[@name='id'][.='7.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[1]/float[@name='id'][.='5.0']",
+        "/response/lst[@name='expanded']/result[@name='2"+floatAppend+"']/doc[2]/float[@name='id'][.='8.0']"
     );
   }
 
diff --git a/solr/core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java b/solr/core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java
index 791c6ee..444ed29 100644
--- a/solr/core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java
+++ b/solr/core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java
@@ -17,6 +17,11 @@
 
 package org.apache.solr.search;
 
+import java.util.Collections;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Random;
+
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrException;
@@ -45,13 +50,38 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
   }
 
   @Test
-  public void testCollapseQueries() throws Exception {
-    final String group = (random().nextBoolean() ? "group_s" : "group_s_dv");
-    
-    String[] doc = {"id","1", "term_s", "YYYY", group, "group1", "test_ti", "5", "test_tl", "10", "test_tf", "2000"};
+  public void testStringCollapse() throws Exception {
+    List<String> types = new ArrayList();
+    types.add("group_s");
+    types.add("group_s_dv");
+    Collections.shuffle(types, random());
+    String group = types.get(0);
+    String hint = (random().nextBoolean() ? " hint="+CollapsingQParserPlugin.HINT_TOP_FC : "");
+    testCollapseQueries(group, hint, false);
+  }
+
+
+  @Test
+  public void testNumericCollapse() throws Exception {
+    List<String> types = new ArrayList();
+    types.add("group_i");
+    types.add("group_ti_dv");
+    types.add("group_f");
+    types.add("group_tf_dv");
+    Collections.shuffle(types, random());
+    String group = types.get(0);
+    String hint = "";
+    testCollapseQueries(group, hint, true);
+  }
+
+
+
+  private void testCollapseQueries(String group, String hint, boolean numeric) throws Exception {
+
+    String[] doc = {"id","1", "term_s", "YYYY", group, "1", "test_ti", "5", "test_tl", "10", "test_tf", "2000"};
     assertU(adoc(doc));
     assertU(commit());
-    String[] doc1 = {"id","2", "term_s","YYYY", group, "group1", "test_ti", "50", "test_tl", "100", "test_tf", "200"};
+    String[] doc1 = {"id","2", "term_s","YYYY", group, "1", "test_ti", "50", "test_tl", "100", "test_tf", "200"};
     assertU(adoc(doc1));
 
 
@@ -63,19 +93,25 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     assertU(adoc(doc3));
 
 
-    String[] doc4 = {"id","5", "term_s", "YYYY", group, "group2", "test_ti", "4", "test_tl", "10", "test_tf", "2000"};
+    String[] doc4 = {"id","5", "term_s", "YYYY", group, "2", "test_ti", "4", "test_tl", "10", "test_tf", "2000"};
     assertU(adoc(doc4));
     assertU(commit());
-    String[] doc5 = {"id","6", "term_s","YYYY", group, "group2", "test_ti", "10", "test_tl", "100", "test_tf", "200"};
+    String[] doc5 = {"id","6", "term_s","YYYY", group, "2", "test_ti", "10", "test_tl", "100", "test_tf", "200"};
     assertU(adoc(doc5));
     assertU(commit());
 
+    String[] doc6 = {"id","7", "term_s", "YYYY", group, "1", "test_ti", "8", "test_tl", "50", "test_tf", "300"};
+    assertU(adoc(doc6));
+    assertU(commit());
+
+
+
 
 
     //Test collapse by score and following sort by score
     ModifiableSolrParams params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+""+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     assertQ(req(params, "indent", "on"), "*[count(//doc)=2]",
@@ -87,7 +123,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     // SOLR-5544 test ordering with empty sort param
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=expand min=test_tf}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=expand min=test_tf"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("sort","");
@@ -101,7 +137,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     // Test value source collapse criteria
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=field(test_ti)}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=field(test_ti)"+hint+"}");
     params.add("sort", "test_ti desc");
     assertQ(req(params), "*[count(//doc)=3]",
         "//result/doc[1]/float[@name='id'][.='4.0']",
@@ -112,7 +148,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     // Test value source collapse criteria with cscore function
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=cscore()}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=cscore()"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     assertQ(req(params), "*[count(//doc)=3]",
@@ -124,7 +160,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     // Test value source collapse criteria with compound cscore function
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=sum(cscore(),field(test_ti))}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse min=sum(cscore(),field(test_ti))"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     assertQ(req(params), "*[count(//doc)=3]",
@@ -137,7 +173,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "YYYY");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("qf", "term_s");
@@ -151,7 +187,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test SOLR-5773 with score collapse criteria
     params = new ModifiableSolrParams();
     params.add("q", "YYYY");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("qf", "term_s");
@@ -165,7 +201,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test SOLR-5773 with max field collapse criteria
     params = new ModifiableSolrParams();
     params.add("q", "YYYY");
-    params.add("fq", "{!collapse field="+group+" min=test_ti nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+" min=test_ti nullPolicy=collapse"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("qf", "term_s");
@@ -180,7 +216,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test SOLR-5773 elevating documents with null group
     params = new ModifiableSolrParams();
     params.add("q", "YYYY");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+""+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("qf", "term_s");
@@ -197,7 +233,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test collapse by min int field and sort
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_ti}");
+    params.add("fq", "{!collapse field="+group+" min=test_ti"+hint+"}");
     params.add("sort", "id desc");
     assertQ(req(params), "*[count(//doc)=2]",
                            "//result/doc[1]/float[@name='id'][.='5.0']",
@@ -205,7 +241,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_ti}");
+    params.add("fq", "{!collapse field="+group+" min=test_ti"+hint+"}");
     params.add("sort", "id asc");
     assertQ(req(params), "*[count(//doc)=2]",
                          "//result/doc[1]/float[@name='id'][.='1.0']",
@@ -213,15 +249,17 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_ti}");
+    params.add("fq", "{!collapse field="+group+" min=test_ti"+hint+"}");
     params.add("sort", "test_tl asc,id desc");
     assertQ(req(params), "*[count(//doc)=2]",
         "//result/doc[1]/float[@name='id'][.='5.0']",
         "//result/doc[2]/float[@name='id'][.='1.0']");
 
+
+
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_ti}");
+    params.add("fq", "{!collapse field="+group+" min=test_ti"+hint+"}");
     params.add("sort", "score desc,id asc");
     params.add("defType", "edismax");
     params.add("bf", "field(id)");
@@ -235,39 +273,43 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test collapse by max int field
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_ti}");
+    params.add("fq", "{!collapse field="+group+" max=test_ti"+hint+"}");
     params.add("sort", "test_ti asc");
     assertQ(req(params), "*[count(//doc)=2]",
                          "//result/doc[1]/float[@name='id'][.='6.0']",
                          "//result/doc[2]/float[@name='id'][.='2.0']"
         );
 
-
-
-    //Test collapse by min long field
-    params = new ModifiableSolrParams();
-    params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_tl}");
-    params.add("sort", "test_ti desc");
-    assertQ(req(params), "*[count(//doc)=2]",
-        "//result/doc[1]/float[@name='id'][.='1.0']",
-        "//result/doc[2]/float[@name='id'][.='5.0']");
-
-
-    //Test collapse by max long field
-    params = new ModifiableSolrParams();
-    params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_tl}");
-    params.add("sort", "test_ti desc");
-    assertQ(req(params), "*[count(//doc)=2]",
-                         "//result/doc[1]/float[@name='id'][.='2.0']",
-                         "//result/doc[2]/float[@name='id'][.='6.0']");
+    try {
+      //Test collapse by min long field
+      params = new ModifiableSolrParams();
+      params.add("q", "*:*");
+      params.add("fq", "{!collapse field="+group+" min=test_tl"+hint+"}");
+      params.add("sort", "test_ti desc");
+      assertQ(req(params), "*[count(//doc)=2]",
+          "//result/doc[1]/float[@name='id'][.='1.0']",
+          "//result/doc[2]/float[@name='id'][.='5.0']");
+
+
+      //Test collapse by max long field
+      params = new ModifiableSolrParams();
+      params.add("q", "*:*");
+      params.add("fq", "{!collapse field="+group+" max=test_tl"+hint+"}");
+      params.add("sort", "test_ti desc");
+      assertQ(req(params), "*[count(//doc)=2]",
+                           "//result/doc[1]/float[@name='id'][.='2.0']",
+                           "//result/doc[2]/float[@name='id'][.='6.0']");
+    } catch (Exception e) {
+      if(!numeric) {
+        throw e;
+      }
+    }
 
 
     //Test collapse by min float field
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" min=test_tf}");
+    params.add("fq", "{!collapse field="+group+" min=test_tf"+hint+"}");
     params.add("sort", "test_ti desc");
     assertQ(req(params), "*[count(//doc)=2]",
                          "//result/doc[1]/float[@name='id'][.='2.0']",
@@ -279,7 +321,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test collapse by min float field
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_tf}");
+    params.add("fq", "{!collapse field="+group+" max=test_tf"+hint+"}");
     params.add("sort", "test_ti asc");
     assertQ(req(params), "*[count(//doc)=2]",
                          "//result/doc[1]/float[@name='id'][.='5.0']",
@@ -288,7 +330,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test collapse by min float field sort by score
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_tf}");
+    params.add("fq", "{!collapse field="+group+" max=test_tf"+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(id)");
     params.add("fl", "score, id");
@@ -304,7 +346,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     //Test nullPolicy expand
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_tf nullPolicy=expand}");
+    params.add("fq", "{!collapse field="+group+" max=test_tf nullPolicy=expand"+hint+"}");
     params.add("sort", "id desc");
     assertQ(req(params), "*[count(//doc)=4]",
         "//result/doc[1]/float[@name='id'][.='5.0']",
@@ -316,7 +358,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+" max=test_tf nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+" max=test_tf nullPolicy=collapse"+hint+"}");
     params.add("sort", "id desc");
     assertQ(req(params), "*[count(//doc)=3]",
         "//result/doc[1]/float[@name='id'][.='5.0']",
@@ -326,7 +368,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
 
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("fq","{!tag=test_ti}id:5");
@@ -338,7 +380,7 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     // SOLR-5230 - ensure CollapsingFieldValueCollector.finish() is called
     params = new ModifiableSolrParams();
     params.add("q", "*:*");
-    params.add("fq", "{!collapse field="+group+"}");
+    params.add("fq", "{!collapse field="+group+hint+"}");
     params.add("group", "true");
     params.add("group.field", "id");
     assertQ(req(params), "*[count(//doc)=2]");
@@ -350,14 +392,15 @@ public class TestCollapseQParserPlugin extends SolrTestCaseJ4 {
     assertU(commit());
     params = new ModifiableSolrParams();
     params.add("q", "YYYY");
-    params.add("fq", "{!collapse field="+group+" nullPolicy=collapse}");
+    params.add("fq", "{!collapse field="+group+hint+" nullPolicy=collapse}");
     params.add("defType", "edismax");
     params.add("bf", "field(test_ti)");
     params.add("qf", "term_s");
     params.add("qt", "/elevate");
-    assertQ(req(params), "*[count(//doc)=2]",
+    assertQ(req(params), "*[count(//doc)=3]",
                          "//result/doc[1]/float[@name='id'][.='3.0']",
-                         "//result/doc[2]/float[@name='id'][.='6.0']");
+                         "//result/doc[2]/float[@name='id'][.='6.0']",
+                         "//result/doc[3]/float[@name='id'][.='7.0']");
 
 
   }

