GitDiffStart: a3fff54fc15c1356a97c5601d9fc5f9d81df738c | Sun Dec 7 19:07:11 2008 +0000
diff --git a/CHANGES.txt b/CHANGES.txt
index 204c7e3..15ff50d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -184,6 +184,10 @@ Other Changes
 
  9. SOLR-819: Upgraded to Lucene 2.9-dev (r724059) to get access to Arabic public constructors (gsingers)
 
+10. SOLR-900: Moved solrj into /src/solrj.  The contents of solr-common.jar is now included
+    in the solr-solrj.jar. (ryan)
+
+
 Build
 ----------------------
  1. SOLR-776: Added in ability to sign artifacts via Ant for releases (gsingers)
diff --git a/build.xml b/build.xml
index 3f1b647..9879883 100644
--- a/build.xml
+++ b/build.xml
@@ -97,18 +97,6 @@
   <!-- ===================== COMPILATION-RELATED TASKS ========================= -->
   <!-- ========================================================================= -->
 
-  <!-- Compile common classes. -->
-  <target name="compile-common"
-          description="Compile the source code."
-          depends="init-forrest-entities">
-
-    <solr-javac destdir="${dest}/common"
-                classpathref="compile.classpath">
-      <src path="${src}/java" />
-      <include name="org/apache/solr/common/**" />
-    </solr-javac>
-  </target>
-
   <!-- The compilation classpath -->
   <path id="compile.classpath">
     <fileset dir="${lib}">
@@ -117,65 +105,82 @@
     <pathelement location="${dest}/common"/>
   </path>
 
+  <target name="compile-solrj"
+          description="Compile the java client."
+          depends="init-forrest-entities">
+
+    <solr-javac destdir="${dest}/solrj"
+                classpathref="compile.classpath">
+      <src path="${src}/common" />
+      <src path="${src}/solrj" />
+    </solr-javac>
+  </target>
+
+
+  <!-- This depend on all of solr -->
+  <path id="compile.classpath.solrj">
+    <path refid="compile.classpath" />
+    <pathelement location="${dest}/solrj"/>
+    <!-- jetty -->
+    <fileset dir="example/lib">
+      <include name="**/*.jar" />
+    </fileset>
+  </path>
+    
   <!-- Compile the project. -->
   <target name="compile"
           description="Compile the source code."
-          depends="compile-common,init-forrest-entities">
+          depends="compile-solrj,init-forrest-entities">
 
-    <solr-javac destdir="${dest}/core"
-                classpathref="compile.classpath.solrj-embedded">
+    <solr-javac destdir="${dest}/solr"
+                classpathref="compile.classpath.solrj">
       <src path="${src}/java" />
       <src path="${src}/webapp/src" />
-      <src path="client/java/solrj/src" />
-      <exclude name="org/apache/solr/common/**" />
     </solr-javac>
   </target>
 
-  <target name="javadoc-core" depends="compile,compile-solrj"  description="Generates javadoc documentation for core.">
-
+  <target name="javadoc-solrj" depends="compile-solrj" description="Generates solrj javadoc documentation.">
     <sequential>
-      <mkdir dir="${build.javadoc}/core"/>
+      <mkdir dir="${build.javadoc}/solrj"/>
 
       <path id="javadoc.classpath">
         <path refid="compile.classpath"/>
-        <path refid="compile.classpath.solrj"/>
-        <pathelement location="${dest}/client/solrj"/>
       </path>
 
       <invoke-javadoc
-        destdir="${build.javadoc}/core"
-      	title="${Name} ${version} core API (${specversion})">
+        destdir="${build.javadoc}/solrj"
+        title="${Name}-j ${version} API (${specversion})">
         <sources>
-          <packageset dir="${src}/java">
-            <exclude name="org/apache/solr/common/**" />
-          </packageset>
-          <packageset dir="${src}/webapp/src"/>
+          <packageset dir="${src}/common"/>
+          <packageset dir="${src}/solrj"/>
         </sources>
       </invoke-javadoc>
     </sequential>
   </target>
-
-  <target name="javadoc-common" depends="compile,compile-solrj"  description="Generates javadoc documentation for core.">
+  
+  <target name="javadoc-core" depends="compile"  description="Generates javadoc documentation for core.">
 
     <sequential>
-      <mkdir dir="${build.javadoc}/common"/>
+      <mkdir dir="${build.javadoc}/solr"/>
 
       <path id="javadoc.classpath">
         <path refid="compile.classpath"/>
         <path refid="compile.classpath.solrj"/>
-        <pathelement location="${dest}/client/solrj"/>
+        <pathelement location="${dest}/solrj"/>
       </path>
 
       <invoke-javadoc
-        destdir="${build.javadoc}/common"
+        destdir="${build.javadoc}/solr"
       	title="${Name} ${version} core API (${specversion})">
         <sources>
-          <fileset dir="${src}/java" includes="org/apache/solr/common/**" />
+          <packageset dir="${src}/java" />
+          <packageset dir="${src}/webapp/src"/>
         </sources>
       </invoke-javadoc>
     </sequential>
   </target>
 
+
   <target name="javadoc-all" description="Generate javadoc for core, client and contrib">
     <sequential>
       <mkdir dir="${build.javadoc}"/>
@@ -183,15 +188,15 @@
       <path id="javadoc.classpath">
          <path refid="compile.classpath"/>
          <path refid="compile.classpath.solrj"/>
-         <path refid="compile.classpath.solrj-embedded"/>
          <pathelement location="${dest}/client/solrj"/>
       </path>
 
       <invoke-javadoc destdir="${build.javadoc}">
         <sources>
+          <packageset dir="${src}/common" />
+          <packageset dir="${src}/solrj" />
           <packageset dir="${src}/java" />
           <packageset dir="${src}/webapp/src" />
-          <packageset dir="${solrj-dir}/src" />
           <packageset dir="contrib/dataimporthandler/src/main/java" />
 
           <group title="Core" packages="org.apache.*" />
@@ -208,7 +213,7 @@
                    failonerror="true"/>
   </target>
 
-  <target name="javadoc" depends="javadoc-core, javadoc-common, javadoc-contrib, javadoc-solrj, javadoc-all">
+  <target name="javadoc" depends="javadoc-core, javadoc-contrib, javadoc-solrj, javadoc-all">
   </target>
 
   <target name="stub-factories" depends="dist-jar"
@@ -298,73 +303,6 @@
   <!-- ===================== CLIENT: solrj         ============================= -->
   <!-- ========================================================================= -->
 
-  <property name="solrj-dir" value="client/java/solrj" />
-
-  <path id="compile.classpath.solrj">
-    <fileset dir="${solrj-dir}/lib">
-      <include name="*.jar" />
-    </fileset>
-    <fileset dir="${lib}">
-      <include name="commons-io-*.jar" />
-      <include name="*stax-*.jar" />
-      <include name="wstx-*.jar" />
-    </fileset>
-    <pathelement location="${dest}/common"/>
-  </path>
-
-  <!-- This depend on all of solr -->
-  <path id="compile.classpath.solrj-embedded">
-    <path refid="compile.classpath.solrj" />
-    <path refid="compile.classpath" />
-    <pathelement location="${dest}/core"/>
-    
-    <!-- jetty -->
-    <fileset dir="example/lib">
-      <include name="**/*.jar" />
-    </fileset>
-  </path>
-    
-  <target name="compile-solrj-core"
-          description="Compile the java client."
-          depends="compile-common">
-
-    <solr-javac destdir="${dest}/client/solrj"
-                classpathref="compile.classpath.solrj">
-      <src path="${solrj-dir}/src" />
-      <exclude name="org/apache/solr/client/solrj/embedded/**" />
-    </solr-javac>
-  </target>
-
-  <!-- solrj includes the embedded app -->
-  <target name="compile-solrj"
-          description="Compile the java client."
-          depends="compile,compile-solrj-core">
-
-    <solr-javac destdir="${dest}/client/solrj"
-                classpathref="compile.classpath.solrj-embedded">
-      <src path="${solrj-dir}/src/org/apache/solr/client/solrj/embedded" />
-    </solr-javac>
-  </target>
-  
-  
-  <target name="javadoc-solrj" depends="compile-solrj" description="Generates solrj javadoc documentation.">
-    <sequential>
-      <mkdir dir="${build.javadoc}/solrj"/>
-
-      <path id="javadoc.classpath">
-        <path refid="compile.classpath.solrj"/>
-        <path refid="compile.classpath.solrj-embedded"/>
-      </path>
-
-      <invoke-javadoc
-        destdir="${build.javadoc}/solrj"
-      	title="${Name}-j ${version} API (${specversion})">
-        <sources>
-          <packageset dir="${solrj-dir}/src"/>
-        </sources>
-      </invoke-javadoc>
-    </sequential>
-  </target>
   
 
 
@@ -377,11 +315,10 @@
   <!-- For now, it's the same as main classpath.  Later it will have JUnit, Clover, etc. -->
   <path id="test.compile.classpath">
     <path refid="compile.classpath" />
-    <path refid="compile.classpath.solrj-embedded" />
+    <path refid="compile.classpath.solrj" />
       
-    <pathelement location="${dest}/common"/>
-    <pathelement location="${dest}/core"/>
-    <pathelement location="${dest}/client/solrj"/> <!-- include solrj -->
+    <pathelement location="${dest}/solr"/>
+    <pathelement location="${dest}/solrj"/> <!-- include solrj -->
   </path>
 
   <path id="test.run.classpath">
@@ -404,7 +341,6 @@
        destdir="${dest}/tests"
        classpathref="test.compile.classpath">
       <src path="${src}/test" />
-      <src path="${solrj-dir}/test" />
     </solr-javac>
   </target>
 
@@ -433,12 +369,9 @@
       <formatter type="xml"/>
       <batchtest fork="yes" todir="${junit.output.dir}" unless="testcase">
         <fileset dir="src/test" includes="${junit.includes}"/>
-        <!-- this will start jetty and run some tests through HTTP -->
-        <fileset dir="${solrj-dir}/test/" includes="${junit.includes}" />
       </batchtest>
       <batchtest fork="yes" todir="${junit.output.dir}" if="testcase">
         <fileset dir="src/test" includes="**/${testcase}.java"/>
-        <fileset dir="${solrj-dir}/test/" includes="**/${testcase}.java" />
       </batchtest>
     </junit>
 
@@ -463,9 +396,10 @@
     <taskdef resource="clovertasks"/>
     <mkdir dir="${clover.db.dir}"/>
     <clover-setup initString="${clover.db.dir}/solr_coverage.db">
+      <fileset dir="src/common"/>
+      <fileset dir="src/solrj"/>
       <fileset dir="src/java"/>
       <fileset dir="src/webapp/src"/>
-      <fileset dir="${solrj-dir}/src" />
       <fileset dir="contrib/dataimporthandler/src/main/java" />
     </clover-setup>
   </target>
@@ -526,10 +460,9 @@
          <exclude name="easymock.jar" />
        </lib>
        <lib dir="${dist}">
-         <include name="${fullname}-core-${version}.jar" />
-         <include name="${fullname}-common-${version}.jar" />
+         <include name="${fullname}-solrj-${version}.jar" />
+         <include name="${fullname}-${version}.jar" />
        </lib>
-       <lib dir="client/java/solrj/lib"/>
        <fileset dir="${src}/webapp/web" />
        
        <!-- Include anything put in by contrib projects -->
@@ -542,15 +475,17 @@
   <target name="dist-src" description="Creates the Solr source distribution files"
           depends="make-manifest">
     <mkdir dir="${dist}" />
-    
+
+    <solr-jar destfile="${dist}/${fullname}-solrj-src-${version}.jar">
+      <fileset dir="${src}/common" />
+      <fileset dir="${src}/solrj"/>
+    </solr-jar>
+    	
     <solr-jar destfile="${dist}/${fullname}-core-src-${version}.jar">
-      <fileset dir="${src}/java" excludes="org/apache/solr/common/**" />
+      <fileset dir="${src}/java" />
       <fileset dir="${src}/webapp/src"/>
     </solr-jar>
-    <solr-jar destfile="${dist}/${fullname}-common-src-${version}.jar" basedir="${src}/java"
-              includes="org/apache/solr/common/**" />
-    <solr-jar destfile="${dist}/${fullname}-solrj-src-${version}.jar"
-              basedir="client/java/solrj/src" />
+  	
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-src-${version}.jar"
               basedir="contrib/dataimporthandler/src" />
   </target>
@@ -560,9 +495,7 @@
     <mkdir dir="${dist}" />
 
     <solr-jar destfile="${dist}/${fullname}-core-docs-${version}.jar"
-              basedir="${build.javadoc}/core" />
-    <solr-jar destfile="${dist}/${fullname}-common-docs-${version}.jar"
-              basedir="${build.javadoc}/common"/>
+              basedir="${build.javadoc}/solr" />
     <solr-jar destfile="${dist}/${fullname}-solrj-docs-${version}.jar"
               basedir="${build.javadoc}/solrj" />
     <solr-jar destfile="${dist}/apache-solr-dataimporthandler-docs-${version}.jar"
@@ -574,15 +507,10 @@
           description="Creates the Solr JAR Distribution file."
           depends="compile, make-manifest">
     <mkdir dir="${dist}" />
-    <solr-jar
-         destfile="${dist}/${fullname}-core-${version}.jar"
-         basedir="${dest}/core" />
+    <solr-jar destfile="${dist}/${fullname}-core-${version}.jar">
+      <fileset dir="${dest}/solr" />
+    </solr-jar>
 
-    <!-- package the common classes together -->
-    <solr-jar
-         destfile="${dist}/${fullname}-common-${version}.jar"
-         basedir="${dest}/common" />
-    
   </target>
 
   <!-- Creates the solr jar. -->
@@ -592,18 +520,18 @@
     <mkdir dir="${dist}" />
     <solr-jar
          destfile="${dist}/${fullname}-solrj-${version}.jar"
-         basedir="${dest}/client/solrj" />
+         basedir="${dest}/solrj" />
 
     <mkdir  dir="${dist}/solrj-lib" />
     <copy todir="${dist}/solrj-lib">
       <fileset dir="${lib}">
         <include name="commons-codec-*.jar"/>
         <include name="commons-io-*.jar"/>
+        <include name="commons-httpclient-*.jar"/>
         <include name="*stax-*.jar" />
         <include name="wstx-*.jar" />
-      </fileset>
-      <fileset dir="${solrj-dir}/lib">
-        <include name="*.jar" />
+        <include name="jcl-over-slf4j-*.jar" />
+        <include name="slf4j-api-*.jar" />
       </fileset>
     </copy>
       
@@ -615,7 +543,7 @@
     <copy file="${dist}/${fullnamever}.war"
           tofile="${example}/webapps/${ant.project.name}.war"/>
     <jar destfile="${example}/exampledocs/post.jar"
-         basedir="${dest}/core"
+         basedir="${dest}/solr"
          filesetmanifest="skip"
          includes="org/apache/solr/util/SimplePostTool*.class">
        <manifest>
@@ -818,16 +746,6 @@
 
       <!-- ========== SOLR ARTIFACTS ========== -->
 
-      <m2-deploy pom.xml="${src}/maven/solr-common-pom.xml.template"
-                 jar.file="${dist}/apache-solr-common-${version}.jar">
-
-        <artifact-attachments>
-          <attach file="${dist}/${fullname}-common-src-${version}.jar" classifier="sources"/>
-          <attach file="${dist}/${fullname}-common-docs-${version}.jar" classifier="javadoc"/>
-        </artifact-attachments>
-
-      </m2-deploy>
-
       <m2-deploy pom.xml="contrib/dataimporthandler/solr-dataimporthandler-pom.xml.template"
                  jar.file="${dist}/apache-solr-dataimporthandler-${version}.jar">
 
@@ -847,7 +765,7 @@
 
       </m2-deploy>
 
-      <m2-deploy pom.xml="client/java/solrj/solr-solrj-pom.xml.template"
+      <m2-deploy pom.xml="${src}/maven/solr-solrj-pom.xml.template"
                  jar.file="${dist}/apache-solr-solrj-${version}.jar">
 
         <artifact-attachments>
@@ -875,6 +793,8 @@
     description="runs the tasks over src/java excluding the license directory">
     <rat:report xmlns:rat="antlib:org.apache.rat.anttasks">
       <fileset dir="src/java"/>
+      <fileset dir="src/common"/>
+      <fileset dir="src/solrj"/>
       <fileset dir="client">
         <exclude name="**/CHANGES.*"/>
       </fileset>
diff --git a/client/java/solrj/CHANGES.txt b/client/java/solrj/CHANGES.txt
deleted file mode 100644
index 5c8213f..0000000
--- a/client/java/solrj/CHANGES.txt
+++ /dev/null
@@ -1,95 +0,0 @@
-                    Apache Solr - solrj Version 1.3-dev
-                            Release Notes
-
-Introduction
-------------
-solrj is a java client for the solr search engine.
-
-
-$Id$
-
-================== Release 1.4-dev ==================
-Upgrading from Solr 1.3
------------------------
-
-Detailed Change List
-----------------------
-
-New Features
-----------------------
-
-Optimizations
-----------------------
-
-
-Bug Fixes
-----------------------
-
- 1. SOLR-778: SolrQuery#getFacetMinCount() returns value of facet limit
-              (Kohei Taketa via shalin)
-
- 2. SOLR-779: SolrQuery#setHighlightRequireFieldMatch() should be renamed to
-    SolrQuery#getHighlightRequireFieldMatch()
-    (Kohei Taketa, Lars Kotthoff via koji)
-
- 3. SOLR-794: ClientUtils.escapeQueryChars escapes chars a bit aggressive
-    (ryan, koji)
-
-Documentation
-----------------------
-
-Build
-----------------------
-
- 1. SOLR-787: Changed SolrJ POM to refer to woodstox implementation instead of stax as a dependency
-              (shalin)
-
-
-================== Release 1.3.0 20080915 ==================
-
-Status
-------
-This is the first release since Solrj was added to the main solr distribution.
-The following changes list changes since the code was introduced, not since
-the first official release.
-
-
-Detailed Change List
---------------------
-
-New Features
-
-Changes in runtime behavior
- 1. SOLR-278:  Modify LukeRequest/Response to support SOLR-266 schema display.
-    (Will Johnson via ryan)
-
- 2. SOLR-280: Changed the SolrDocument / SolrInputDocument implementation.  
-    The API to build documents has changed -- you need to pass a boost 
-    (or null) with every field.  (ryan)
-
- 3. SOLR-462: Changes to CommonsHttpSolrServer.java to add soTimeout (read 
-    timeout), connection pool timeout, directive to not follow HTTP redirects, 
-    configurable retries on NoHttpResponseException, compression, and not 
-    creating a new HttpClient on each request.  If your existing code overrides 
-    getHttpConnection(), you will now need to override createHttpClient()
-    (Sean Timm via ryan)
-    
- 4. SOLR-436: To make future changes easier, SolrServer changed from an
-    interface to an abstract super class. (ryan)
-
- 5. SOLR-476: CommonsHttpSolrServer can set the ResponseParser on a per 
-    request basis.  (Grant Ingersoll, ryan)
-
- 6. SOLR-430: Added support for reading SpellCheckComponent's responses. (shalin)
-
- 7. SOLR-718: Support persisting solr.xml through SolrJ (Henri Biestro via shalin)
-
-Bug Fixes
-
-Other Changes
-
- 1. SOLR-653: Since the "overwrite" command will be removed in future versions
-    it has been removed from solrj now -- before anyone starts to rely on it.
-    (ryan)
- 
- 
diff --git a/client/java/solrj/LICENSE.txt b/client/java/solrj/LICENSE.txt
deleted file mode 100644
index 57bc88a..0000000
--- a/client/java/solrj/LICENSE.txt
+++ /dev/null
@@ -1,202 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
diff --git a/client/java/solrj/lib/commons-httpclient-3.1.jar b/client/java/solrj/lib/commons-httpclient-3.1.jar
deleted file mode 100644
index 3c261e7..0000000
--- a/client/java/solrj/lib/commons-httpclient-3.1.jar
+++ /dev/null
@@ -1,2 +0,0 @@
-AnyObjectId[7c59774aed4f5dd08778489aaad565690ff7c132] was removed in git history.
-Apache SVN contains full history.
\ No newline at end of file
diff --git a/client/java/solrj/lib/jcl-over-slf4j-1.5.5.jar b/client/java/solrj/lib/jcl-over-slf4j-1.5.5.jar
deleted file mode 100644
index 9a5e656..0000000
--- a/client/java/solrj/lib/jcl-over-slf4j-1.5.5.jar
+++ /dev/null
@@ -1,2 +0,0 @@
-AnyObjectId[6b8ddd6339582fa3e6bce99a74f4186918f3f4d8] was removed in git history.
-Apache SVN contains full history.
\ No newline at end of file
diff --git a/client/java/solrj/lib/slf4j-api-1.5.5.jar b/client/java/solrj/lib/slf4j-api-1.5.5.jar
deleted file mode 100644
index ffc1fa3..0000000
--- a/client/java/solrj/lib/slf4j-api-1.5.5.jar
+++ /dev/null
@@ -1,2 +0,0 @@
-AnyObjectId[4bb4abbb0f75c1bdfb81a44c3a2dd078c1656832] was removed in git history.
-Apache SVN contains full history.
\ No newline at end of file
diff --git a/client/java/solrj/lib/slf4j-jdk14-1.5.5.jar b/client/java/solrj/lib/slf4j-jdk14-1.5.5.jar
deleted file mode 100644
index 03386ff..0000000
--- a/client/java/solrj/lib/slf4j-jdk14-1.5.5.jar
+++ /dev/null
@@ -1,2 +0,0 @@
-AnyObjectId[d58ef5a16b4ae2aa82cf725d510bd0c8c8d4097f] was removed in git history.
-Apache SVN contains full history.
\ No newline at end of file
diff --git a/client/java/solrj/solr-solrj-pom.xml.template b/client/java/solrj/solr-solrj-pom.xml.template
deleted file mode 100644
index 42303fe..0000000
--- a/client/java/solrj/solr-solrj-pom.xml.template
+++ /dev/null
@@ -1,84 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-  -->
-
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.apache.solr</groupId>
-    <artifactId>solr-parent</artifactId>
-    <version>@maven_version@</version>
-  </parent>
-
-  <groupId>org.apache.solr</groupId>
-  <artifactId>solr-solrj</artifactId>
-  <name>Apache Solr Solrj</name>
-  <version>@maven_version@</version>
-  <description>Apache Solr Solrj</description>
-  <packaging>jar</packaging>
-
-  <dependencies>
-
-    <!-- Solr -->
-    <dependency>
-      <groupId>org.apache.solr</groupId>
-      <artifactId>solr-common</artifactId>
-      <version>@maven_version@</version>
-    </dependency>
-
-    <!-- Apache Commons -->
-    <dependency>
-      <groupId>commons-httpclient</groupId>
-      <artifactId>commons-httpclient</artifactId>
-      <version>3.1</version>
-    </dependency>
-    <dependency>
-      <groupId>commons-codec</groupId>
-      <artifactId>commons-codec</artifactId>
-      <version>1.3</version>
-    </dependency>
-    <dependency>
-      <groupId>commons-io</groupId>
-      <artifactId>commons-io</artifactId>
-      <version>1.4</version>
-    </dependency>
-    <dependency>
-      <groupId>commons-fileupload</groupId>
-      <artifactId>commons-fileupload</artifactId>
-      <version>1.2.1</version>
-    </dependency>
-
-    <!-- Stax -->
-    <dependency>
-      <groupId>woodstox</groupId>
-      <artifactId>wstx-asl</artifactId>
-      <version>3.2.7</version>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.geronimo.specs</groupId>
-      <artifactId>geronimo-stax-api_1.0_spec</artifactId>
-      <version>1.0.1</version>
-    </dependency>   
-
-  </dependencies>
-
-</project>
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/ResponseParser.java b/client/java/solrj/src/org/apache/solr/client/solrj/ResponseParser.java
deleted file mode 100644
index 5c028be..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/ResponseParser.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.Reader;
-import java.io.InputStream;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class ResponseParser
-{
-  public abstract String getWriterType(); // for example: wt=XML, JSON, etc
-
-  public abstract NamedList<Object> processResponse(InputStream body, String encoding);
-
-  public abstract NamedList<Object> processResponse(Reader reader);
-  
-  /**
-   * @return the version param passed to solr
-   */
-  public String getVersion()
-  {
-    return "2.2";
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java
deleted file mode 100644
index 4d4faae..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrQuery.java
+++ /dev/null
@@ -1,588 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.FacetParams;
-import org.apache.solr.common.params.HighlightParams;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.StatsParams;
-
-
-/**
- * This is an augmented SolrParams with get/set/add fields for common fields used
- * in the Standard and Dismax request handlers
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrQuery extends ModifiableSolrParams 
-{
-  public enum ORDER { desc, asc;
-    public ORDER reverse() {
-      return (this == asc) ? desc : asc;
-    }
-  }
-  
-  public SolrQuery() {
-    super();
-  }
-
-  /** Create a new SolrQuery
-   * 
-   * @param q query string
-   */
-  public SolrQuery(String q) {
-    this();
-    this.set(CommonParams.Q, q);
-  }
-
-
-  /** add a field for facet computation
-   * 
-   * @param fields the field name from the IndexSchema
-   * @return this
-   */
-  public SolrQuery addFacetField(String ... fields) {
-    for( String f : fields ) {
-      this.add(FacetParams.FACET_FIELD, f);
-    }
-    this.set(FacetParams.FACET, true);
-    return this;
-  }
-
-  /** get the facet fields
-   * 
-   * @return string array of facet fields or null if not set/empty
-   */
-  public String[] getFacetFields() {
-    return this.getParams(FacetParams.FACET_FIELD);
-  }
-
-  /** remove a facet field
-   * 
-   */
-  public boolean removeFacetField(String name) {
-    boolean b = this.remove(FacetParams.FACET_FIELD, name);
-    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
-      this.setFacet(false);
-    }
-    return b;
-  }
-  
-  /** enable/disable faceting.  
-   * 
-   * @param b flag to indicate faceting should be enabled.  if b==false removes all other faceting parameters
-   * @return this
-   */
-  public SolrQuery setFacet(boolean b) {
-    if (b) {
-      this.set(FacetParams.FACET, true);
-    } else {
-      this.remove(FacetParams.FACET);
-      this.remove(FacetParams.FACET_MINCOUNT);
-      this.remove(FacetParams.FACET_FIELD);
-      this.remove(FacetParams.FACET_LIMIT);
-      this.remove(FacetParams.FACET_MISSING);
-      this.remove(FacetParams.FACET_OFFSET);
-      this.remove(FacetParams.FACET_PREFIX);
-      this.remove(FacetParams.FACET_QUERY);
-      this.remove(FacetParams.FACET_SORT);
-      this.remove(FacetParams.FACET_ZEROS);
-      this.remove(FacetParams.FACET_PREFIX); // does not include the individual fields...
-    }
-    return this;
-  }
-  
-  public SolrQuery setFacetPrefix( String prefix )
-  {
-    this.set( FacetParams.FACET_PREFIX, prefix );
-    return this;
-  }
-
-  public SolrQuery setFacetPrefix( String field, String prefix )
-  {
-    this.set( "f."+field+"."+FacetParams.FACET_PREFIX, prefix );
-    return this;
-  }
-
-  /** add a faceting query
-   * 
-   * @param f facet query
-   */
-  public SolrQuery addFacetQuery(String f) {
-    this.add(FacetParams.FACET_QUERY, f);
-    return this;
-  }
-
-  /** get facet queries
-   * 
-   * @return all facet queries or null if not set/empty
-   */
-  public String[] getFacetQuery() {
-    return this.getParams(FacetParams.FACET_QUERY);
-  }
-
-  /** remove a facet query
-   * 
-   * @param q the facet query to remove
-   * @return true if the facet query was removed false otherwise
-   */
-  public boolean removeFacetQuery(String q) {
-    boolean b = this.remove(FacetParams.FACET_QUERY, q);
-    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
-      this.setFacet(false);
-    }
-    return b;
-  }
-
-  /** se the facet limit
-   * 
-   * @param lim number facet items to return
-   */
-  public SolrQuery setFacetLimit(int lim) {
-    this.set(FacetParams.FACET_LIMIT, lim);
-    return this;
-  }
-
-  /** get current facet limit
-   * 
-   * @return facet limit or default of 25
-   */
-  public int getFacetLimit() {
-    return this.getInt(FacetParams.FACET_LIMIT, 25);
-  }
-
-  /** set facet minimum count
-   * 
-   * @param cnt facets having less that cnt hits will be excluded from teh facet list
-   */
-  public SolrQuery setFacetMinCount(int cnt) {
-    this.set(FacetParams.FACET_MINCOUNT, cnt);
-    return this;
-  }
-
-  /** get facet minimum count
-   * 
-   * @return facet minimum count or default of 1
-   */
-  public int getFacetMinCount() {
-    return this.getInt(FacetParams.FACET_MINCOUNT, 1);
-  }
-
-  public SolrQuery setFacetMissing(Boolean v) {
-    this.set(FacetParams.FACET_MISSING, v);
-    return this;
-  }
-
-  /**
-   * @deprecated use {@link #setFacetMissing(String)}
-   */
-  public SolrQuery setMissing(String fld) {
-    return setFacetMissing(Boolean.valueOf(fld));
-  }
-
-  /** get facet sort
-   * 
-   * @return facet sort or default of FacetParams.FACET_SORT_COUNT
-   */
-  public String getFacetSortString() {
-    return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT);
-  }
-
-  /** get facet sort
-   * 
-   * @return facet sort or default of true
-   * @deprecated Use {@link #getFacetSortString()} instead, true corresponds to
-   * FacetParams.FACET_SORT_COUNT and false to FacetParams.FACET_SORT_LEX.
-   */
-  @Deprecated
-  public boolean getFacetSort() {
-    return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT).equals(FacetParams.FACET_SORT_COUNT);
-  }
-
-  /** set facet sort
-   * 
-   * @param sort sort facets
-   * @return this
-   */
-  public SolrQuery setFacetSort(String sort) {
-    this.set(FacetParams.FACET_SORT, sort);
-    return this;
-  }
-
-  /** set facet sort
-   * 
-   * @param sort sort facets
-   * @return this
-   * @deprecated Use {@link #setFacetSort(String)} instead, true corresponds to
-   * FacetParams.FACET_SORT_COUNT and false to FacetParams.FACET_SORT_LEX.
-   */
-  @Deprecated
-  public SolrQuery setFacetSort(boolean sort) {
-    this.set(FacetParams.FACET_SORT, sort == true ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_LEX);
-    return this;
-  }
-
-  /** add highlight field
-   * 
-   * @param f field to enable for highlighting
-   */
-  public SolrQuery addHighlightField(String f) {
-    this.add(HighlightParams.FIELDS, f);
-    this.set(HighlightParams.HIGHLIGHT, true);
-    return this;
-  }
-
-  /** remove a field for highlighting
-   * 
-   * @param f field name to not highlight
-   * @return true if removed, false otherwise
-   */
-  public boolean removeHighlightField(String f) {
-    boolean b = this.remove(HighlightParams.FIELDS, f);
-    if (this.get(HighlightParams.FIELDS) == null) {
-      this.setHighlight(false);
-    }
-    return b;
-  }
-
-  /** get list of hl fields
-   * 
-   * @return highlight fields or null if not set/empty
-   */
-  public String[] getHighlightFields() {
-    return this.getParams(HighlightParams.FIELDS);
-  }
-
-  public SolrQuery setHighlightSnippets(int num) {
-    this.set(HighlightParams.SNIPPETS, num);
-    return this;
-  }
-
-  public int getHighlightSnippets() {
-    return this.getInt(HighlightParams.SNIPPETS, 1);
-  }
-
-  public SolrQuery setHighlightFragsize(int num) {
-    this.set(HighlightParams.FRAGSIZE, num);
-    return this;
-  }
-
-  public int getHighlightFragsize() {
-    return this.getInt(HighlightParams.FRAGSIZE, 100);
-  }
-
-  public SolrQuery setHighlightRequireFieldMatch(boolean flag) {
-    this.set(HighlightParams.FIELD_MATCH, flag);
-    return this;
-  }
-
-  public boolean getHighlightRequireFieldMatch() {
-    return this.getBool(HighlightParams.FIELD_MATCH, false);
-  }
-
-  public SolrQuery setHighlightSimplePre(String f) {
-    this.set(HighlightParams.SIMPLE_PRE, f);
-    return this;
-  }
-
-  public String getHighlightSimplePre() {
-    return this.get(HighlightParams.SIMPLE_PRE, "");
-  }
-
-  public SolrQuery setHighlightSimplePost(String f) {
-    this.set(HighlightParams.SIMPLE_POST, f);
-    return this;
-  }
-
-  public String getHighlightSimplePost() {
-    return this.get(HighlightParams.SIMPLE_POST, "");
-  }
-
-  public SolrQuery setSortField(String field, ORDER order) {
-    this.remove(CommonParams.SORT);
-    addValueToParam(CommonParams.SORT, toSortString(field, order));
-    return this;
-  }
-  
-  public SolrQuery addSortField(String field, ORDER order) {
-    return addValueToParam(CommonParams.SORT, toSortString(field, order));
-  }
-
-  public SolrQuery removeSortField(String field, ORDER order) {
-    String s = this.get(CommonParams.SORT);
-    String removeSort = toSortString(field, order);
-    if (s != null) {
-      String[] sorts = s.split(",");
-      s = join(sorts, ", ", removeSort);
-      if (s.length()==0) s=null;
-      this.set(CommonParams.SORT, s);
-    }
-    return this;
-  }
-  
-  public String[] getSortFields() {
-    String s = getSortField();
-    if (s==null) return null;
-    return s.split(",");
-  }
-
-  public String getSortField() {
-    return this.get(CommonParams.SORT);
-  }
-  
-  public void setGetFieldStatistics( boolean v )
-  {
-    this.set( StatsParams.STATS, v );
-  }
-  
-  public void setGetFieldStatistics( String field, boolean twopass )
-  {
-    this.set( StatsParams.STATS, true );
-    this.add( StatsParams.STATS_FIELD, field );
-    this.set( "f."+field+"."+StatsParams.STATS_TWOPASS, twopass+"" );
-  }
-  
-  public void addStatsFieldFacets( String field, String ... facets )
-  {
-    if( field == null ) {
-      this.add( StatsParams.STATS_FACET, facets );
-    }
-    else {
-      for( String f : facets ) {
-        this.add( "f."+field+"."+StatsParams.STATS_FACET, f );
-      }
-    }
-  }
-
-  public SolrQuery setFilterQueries(String ... fq) {
-    this.set(CommonParams.FQ, fq);
-    return this;
-  }
-
-  public SolrQuery addFilterQuery(String ... fq) {
-    this.add(CommonParams.FQ, fq);
-    return this;
-  }
-
-  public boolean removeFilterQuery(String fq) {
-    return this.remove(CommonParams.FQ, fq);
-  }
-
-  public String[] getFilterQueries() {
-    return this.getParams(CommonParams.FQ);
-  }
-  
-  public boolean getHighlight() {
-    return this.getBool(HighlightParams.HIGHLIGHT, false);
-  }
-  
-  public SolrQuery setHighlight(boolean b) {
-    if (b) {
-      this.set(HighlightParams.HIGHLIGHT, true);
-    } else {
-      this.remove(HighlightParams.HIGHLIGHT);
-      this.remove(HighlightParams.FIELD_MATCH);
-      this.remove(HighlightParams.FIELDS);
-      this.remove(HighlightParams.FORMATTER);
-      this.remove(HighlightParams.FRAGSIZE);
-      this.remove(HighlightParams.SIMPLE_POST);
-      this.remove(HighlightParams.SIMPLE_PRE);
-      this.remove(HighlightParams.SNIPPETS);
-    }
-    return this;
-  }
-
-  public SolrQuery setFields(String ... fields) {
-    if( fields == null || fields.length == 0 ) {
-      this.remove( CommonParams.FL );
-      return this;
-    }
-    StringBuilder sb = new StringBuilder();
-    sb.append( fields[0] );
-    for( int i=1; i<fields.length; i++ ) {
-      sb.append( ',' );
-      sb.append( fields[i] );
-    }
-    this.set(CommonParams.FL, sb.toString() );
-    return this;
-  }
-    
-  public SolrQuery addField(String field) {
-    return addValueToParam(CommonParams.FL, field);
-  }
-
-  public String getFields() {
-    String fields = this.get(CommonParams.FL);
-    if (fields!=null && fields.equals("score")) {
-      fields = "*, score";
-    }
-    return fields;
-  }
-
-  public SolrQuery setIncludeScore(boolean includeScore) {
-    if (includeScore) {
-      this.add(CommonParams.FL, "score");
-    } else {
-      this.remove(CommonParams.FL, "score");
-    }
-    return this;
-  }
-
-  public SolrQuery setQuery(String query) {
-    this.set(CommonParams.Q, query);
-    return this;
-  }
-
-  public String getQuery() {
-    return this.get(CommonParams.Q);
-  }
-
-  public SolrQuery setRows(Integer rows) {
-    if( rows == null ) {
-      this.remove( CommonParams.ROWS );
-    }
-    else {
-      this.set(CommonParams.ROWS, rows);
-    }
-    return this;
-  }
-
-  public Integer getRows()
-  {
-    return this.getInt(CommonParams.ROWS);
-  }
-
-  public void setShowDebugInfo(boolean showDebugInfo) {
-    this.set(CommonParams.DEBUG_QUERY, String.valueOf(showDebugInfo));
-  }
-
-// use addSortField( sort, order 
-//  public void setSort(String ... sort) {
-//    this.set(CommonParams.SORT, sort);
-//  }
-
-  public SolrQuery setStart(Integer start) {
-    if( start == null ) {
-      this.remove( CommonParams.START );
-    }
-    else {
-      this.set(CommonParams.START, start);
-    }
-    return this;
-  }
-  
-  public Integer getStart()
-  {
-    return this.getInt(CommonParams.START);
-  }
-
-  public SolrQuery setQueryType(String qt) {
-    this.set(CommonParams.QT, qt);
-    return this;
-  }
-
-  public String getQueryType() {
-    return this.get(CommonParams.QT);
-  }
-
-  public SolrQuery setParam(String name, String ... values) {
-    this.set(name, values);
-    return this;
-  }
-
-  public SolrQuery setParam(String name, boolean value) {
-    this.set(name, value);
-    return this;
-  }
-
-  /** get a deep copy of this object * */
-  public SolrQuery getCopy() {
-    SolrQuery q = new SolrQuery();
-    for (String name : this.getParameterNames()) {
-      q.setParam(name, this.getParams(name));
-    }
-    return q;
-  }
-  
-  /**
-  * Set the maximum time allowed for this query. If the query takes more time
-  * than the specified milliseconds, a timeout occurs and partial (or no)
-  * results may be returned.
-  * 
-  * If given Integer is null, then this parameter is removed from the request
-  * 
-  *@param milliseconds the time in milliseconds allowed for this query
-  */
-  public SolrQuery setTimeAllowed(Integer milliseconds) {
-    if (milliseconds == null) {
-      this.remove(CommonParams.TIME_ALLOWED);
-    } else {
-      this.set(CommonParams.TIME_ALLOWED, milliseconds);
-    }
-    return this;
-  }
-  
-  /**
-  * Get the maximum time allowed for this query.
-  */
-  public Integer getTimeAllowed() {
-    return this.getInt(CommonParams.TIME_ALLOWED);
-  }
-
-  ///////////////////////
-  //  Utility functions
-  ///////////////////////
-  
-  private String toSortString(String field, ORDER order) {
-    return field.trim() + ' ' + String.valueOf(order).trim();
-  }
-  
-  private String join(String a, String b, String sep) {
-    StringBuilder sb = new StringBuilder();
-    if (a!=null && a.length()>0) {
-      sb.append(a);
-      sb.append(sep);
-    } 
-    if (b!=null && b.length()>0) {
-      sb.append(b);
-    }
-    return sb.toString().trim();
-  }
-  
-  private SolrQuery addValueToParam(String name, String value) {
-    String tmp = this.get(name);
-    tmp = join(tmp, value, ",");
-    this.set(name, tmp);
-    return this;
-  }
-   
-  private String join(String[] vals, String sep, String removeVal) {
-    StringBuilder sb = new StringBuilder();
-    for (int i=0; i<vals.length; i++) {
-      if (removeVal==null || !vals[i].equals(removeVal)) {
-        sb.append(vals[i]);
-        if (i<vals.length-1) {
-          sb.append(sep);
-        }
-      }
-    }
-    return sb.toString().trim();
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrRequest.java
deleted file mode 100644
index 57833fe..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrRequest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.util.Collection;
-
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class SolrRequest implements Serializable
-{
-  public enum METHOD {
-    GET,
-    POST
-  };
-
-  private METHOD method = METHOD.GET;
-  private String path = null;
-
-  private ResponseParser responseParser;
-  //---------------------------------------------------------
-  //---------------------------------------------------------
-
-  public SolrRequest( METHOD m, String path )
-  {
-    this.method = m;
-    this.path = path;
-  }
-
-  //---------------------------------------------------------
-  //---------------------------------------------------------
-
-  public METHOD getMethod() {
-    return method;
-  }
-  public void setMethod(METHOD method) {
-    this.method = method;
-  }
-
-  public String getPath() {
-    return path;
-  }
-  public void setPath(String path) {
-    this.path = path;
-  }
-
-  /**
-   *
-   * @return The {@link org.apache.solr.client.solrj.ResponseParser}
-   */
-  public ResponseParser getResponseParser() {
-    return responseParser;
-  }
-
-  /**
-   * Optionally specify how the Response should be parsed.  Not all server implementations require a ResponseParser
-   * to be specified.
-   * @param responseParser The {@link org.apache.solr.client.solrj.ResponseParser}
-   */
-  public void setResponseParser(ResponseParser responseParser) {
-    this.responseParser = responseParser;
-  }
-
-  public abstract SolrParams getParams();
-  public abstract Collection<ContentStream> getContentStreams() throws IOException;
-  public abstract SolrResponse process( SolrServer server ) throws SolrServerException, IOException;
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrResponse.java
deleted file mode 100644
index aa89c74..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrResponse.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.Serializable;
-
-import org.apache.solr.common.util.NamedList;
-
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class SolrResponse implements Serializable
-{
-  public abstract long getElapsedTime();
-  public abstract void setResponse(  NamedList<Object> rsp );
-  public abstract NamedList<Object> getResponse();
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrServer.java
deleted file mode 100644
index b661d65..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrServer.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.ArrayList;
-
-import org.apache.solr.client.solrj.request.QueryRequest;
-import org.apache.solr.client.solrj.request.SolrPing;
-import org.apache.solr.client.solrj.request.UpdateRequest;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.client.solrj.response.SolrPingResponse;
-import org.apache.solr.client.solrj.response.UpdateResponse;
-import org.apache.solr.client.solrj.SolrRequest.METHOD;
-import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class SolrServer implements Serializable
-{
-  private DocumentObjectBinder binder;
-
-  public UpdateResponse add(Collection<SolrInputDocument> docs ) throws SolrServerException, IOException {
-    UpdateRequest req = new UpdateRequest();
-    req.add(docs);
-    return req.process(this);
-  }
-
-  public UpdateResponse addBeans(Collection<?> beans ) throws SolrServerException, IOException {
-    DocumentObjectBinder binder = this.getBinder();
-    ArrayList<SolrInputDocument> docs =  new ArrayList<SolrInputDocument>(beans.size());
-    for (Object bean : beans) {
-      docs.add(binder.toSolrInputDocument(bean));
-    }
-    return add(docs);
-  }
-
-  public UpdateResponse add(SolrInputDocument doc ) throws SolrServerException, IOException {
-    UpdateRequest req = new UpdateRequest();
-    req.add(doc);
-    return req.process(this);
-  }
-
-  public UpdateResponse addBean(Object obj) throws IOException, SolrServerException {
-    return add(getBinder().toSolrInputDocument(obj));
-  }
-
-  /** waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
-   * @throws IOException 
-   */
-  public UpdateResponse commit( ) throws SolrServerException, IOException {
-    return commit(true, true);
-  }
-
-  /** waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
-   * @throws IOException 
-   */
-  public UpdateResponse optimize( ) throws SolrServerException, IOException {
-    return optimize(true, true, 1);
-  }
-  
-  public UpdateResponse commit( boolean waitFlush, boolean waitSearcher ) throws SolrServerException, IOException {
-    return new UpdateRequest().setAction( UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher ).process( this );
-  }
-
-  public UpdateResponse optimize( boolean waitFlush, boolean waitSearcher ) throws SolrServerException, IOException {
-    return optimize(waitFlush, waitSearcher, 1);
-  }
-
-  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher, int maxSegments ) throws SolrServerException, IOException {
-    return new UpdateRequest().setAction( UpdateRequest.ACTION.OPTIMIZE, waitFlush, waitSearcher, maxSegments ).process( this );
-  }
-  
-  public UpdateResponse rollback() throws SolrServerException, IOException {
-    return new UpdateRequest().rollback().process( this );
-  }
-  
-  public UpdateResponse deleteById(String id) throws SolrServerException, IOException {
-    return new UpdateRequest().deleteById( id ).process( this );
-  }
-
-  public UpdateResponse deleteByQuery(String query) throws SolrServerException, IOException {
-    return new UpdateRequest().deleteByQuery( query ).process( this );
-  }
-
-  public SolrPingResponse ping() throws SolrServerException, IOException {
-    return new SolrPing().process( this );
-  }
-
-  public QueryResponse query(SolrParams params) throws SolrServerException {
-    return new QueryRequest( params ).process( this );
-  }
-  
-  public QueryResponse query(SolrParams params, METHOD method) throws SolrServerException {
-    return new QueryRequest( params, method ).process( this );
-  }
-  
-  /**
-   * SolrServer implementations need to implement a how a request is actually processed
-   */ 
-  public abstract NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException;
-
-  public DocumentObjectBinder getBinder() {
-    if(binder == null){
-      binder = new DocumentObjectBinder();
-    }
-    return binder;
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/SolrServerException.java b/client/java/solrj/src/org/apache/solr/client/solrj/SolrServerException.java
deleted file mode 100644
index 67c46d9..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/SolrServerException.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-/** Exception to catch all types of communication / parsing issues associated with talking to SOLR
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrServerException extends Exception {
-
-  private static final long serialVersionUID = -3371703521752000294L;
-  
-  public SolrServerException(String message, Throwable cause) {
-    super(message, cause);
-  }
-
-  public SolrServerException(String message) {
-    super(message);
-  }
-
-  public SolrServerException(Throwable cause) {
-    super(cause);
-  }
-  
-  public Throwable getRootCause() {
-    Throwable t = this;
-    while (true) {
-      Throwable cause = t.getCause();
-      if (cause!=null) {
-        t = cause;
-      } else {
-        break;
-      }
-    }
-    return t;
-  }
-
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java b/client/java/solrj/src/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
deleted file mode 100644
index 6ca3234..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.client.solrj.beans;
-
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrInputDocument;
-
-import java.lang.reflect.AccessibleObject;
-import java.lang.reflect.Method;
-import java.lang.reflect.Array;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * A class to map objects to and from solr documents.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class DocumentObjectBinder {
-  private final Map<Class, List<DocField>> infocache = new ConcurrentHashMap<Class, List<DocField>>();
-
-  public DocumentObjectBinder() {
-  }
-
-  public <T> List<T> getBeans(Class<T> clazz, SolrDocumentList solrDocList) {
-    List<DocField> fields = getDocFields( clazz );
-    List<T> result = new ArrayList<T>(solrDocList.size());
-
-    for(int j=0;j<solrDocList.size();j++) {
-      SolrDocument sdoc = solrDocList.get(j);
-
-      T obj = null;
-      try {
-        obj = clazz.newInstance();
-        result.add(obj);
-      } catch (Exception e) {
-        throw new RuntimeException("Could not instantiate object of " + clazz,e);
-      }
-      for (int i = 0; i < fields.size(); i++) {
-        DocField docField = fields.get(i);
-        docField.inject(obj, sdoc);
-      }
-    }
-    return result;
-  }
-  
-  public SolrInputDocument toSolrInputDocument( Object obj )
-  {
-    List<DocField> fields = getDocFields( obj.getClass() );
-    if( fields.isEmpty() ) {
-      throw new RuntimeException( "class: "+obj.getClass()+" does not define any fields." );
-    }
-    
-    SolrInputDocument doc = new SolrInputDocument();
-    for( DocField field : fields ) {
-      doc.setField( field.name, field.get( obj ), 1.0f );
-    }
-    return doc;
-  }
-  
-  private List<DocField> getDocFields( Class clazz )
-  {
-    List<DocField> fields = infocache.get(clazz);
-    if (fields == null) {
-      synchronized(infocache) {
-        infocache.put(clazz, fields = collectInfo(clazz));
-      }
-    }
-    return fields;
-  }
-
-  private List<DocField> collectInfo(Class clazz) {
-    List<DocField> fields = new ArrayList<DocField>();
-    Class superClazz = clazz;
-    ArrayList<AccessibleObject> members = new ArrayList<AccessibleObject>();
-    while (superClazz != null && superClazz != Object.class) {
-      members.addAll(Arrays.asList(superClazz.getDeclaredFields()));
-      members.addAll(Arrays.asList(superClazz.getDeclaredMethods()));
-      superClazz = superClazz.getSuperclass();
-    }
-    for (AccessibleObject member : members) {
-      if (member.isAnnotationPresent(Field.class)) {
-        member.setAccessible(true);
-        fields.add(new DocField(member));
-      }
-    }
-    return fields;
-  }
-
-  private static class DocField {
-    private String name;
-    private java.lang.reflect.Field field;
-    private Method setter;
-    private Method getter;
-    private Class type;
-    private boolean isArray = false, isList=false;
-
-    public DocField(AccessibleObject member) {
-      if (member instanceof java.lang.reflect.Field) {
-        field = (java.lang.reflect.Field) member;
-      } else {
-        setter = (Method) member;
-      }
-      Field annotation = member.getAnnotation(Field.class);
-      storeName(annotation);
-      storeType();
-      
-      // Look for a matching getter
-      if( setter != null ) {
-        String gname = setter.getName();
-        if( gname.startsWith("set") ) {
-          gname = "get" + gname.substring(3);
-          try {
-            getter = setter.getDeclaringClass().getMethod( gname, (Class[])null );
-          }
-          catch( Exception ex ) {
-            // no getter -- don't worry about it...
-            if( type == Boolean.class ) {
-              gname = "is" + setter.getName().substring( 3 );
-              try {
-                getter = setter.getDeclaringClass().getMethod( gname, (Class[])null );
-              }
-              catch( Exception ex2 ) {
-                // no getter -- don't worry about it...
-              }
-            }
-          }
-        }
-      }
-    }
-
-    private void storeName(Field annotation) {
-      if (annotation.value().equals(Field.DEFAULT)) {
-        if (field != null) {
-          name = field.getName();
-        } else {
-          String setterName = setter.getName();
-          if (setterName.startsWith("set") && setterName.length() > 3) {
-            name = setterName.substring(3, 4).toLowerCase() + setterName.substring(4);
-          } else {
-            name = setter.getName();
-          }
-        }
-      } else {
-        name = annotation.value();
-      }
-    }
-
-    private void storeType() {
-      if (field != null) {
-        type = field.getType();
-      } else {
-        Class[] params = setter.getParameterTypes();
-        if (params.length != 1)
-          throw new RuntimeException("Invalid setter method. Must have one and only one parameter");
-        type = params[0];
-      }
-      if(type == Collection.class || type == List.class || type == ArrayList.class) {
-        type = Object.class;
-        isList = true;
-        /*ParameterizedType parameterizedType = null;
-        if(field !=null){
-          if( field.getGenericType() instanceof ParameterizedType){
-            parameterizedType = (ParameterizedType) field.getGenericType();
-            Type[] types = parameterizedType.getActualTypeArguments();
-            if (types != null && types.length > 0) type = (Class) types[0];
-          }
-        }*/
-      } else if (type.isArray()) {
-        isArray = true;
-        type = type.getComponentType();
-      }
-    }
-
-    public <T> void inject(T obj, SolrDocument sdoc) {
-      Object val = sdoc.getFieldValue(name);
-      if(val == null) return;
-      if (isArray) {
-        if (val instanceof List) {
-          List collection = (List) val;
-          set(obj, collection.toArray((Object[]) Array.newInstance(type,collection.size())));
-        } else {
-          Object[] arr = (Object[]) Array.newInstance(type, 1);
-          arr[0] = val;
-          set(obj, arr);
-        }
-      } else if (isList) {
-        if (val instanceof List) {
-          set(obj, val);
-        } else {
-          ArrayList l = new ArrayList();
-          l.add(val);
-          set(obj, l);
-        }
-      } else {
-        if (val instanceof List) {
-          List l = (List) val;
-          if(l.size()>0) 
-            set(obj, l.get(0));
-        } 
-        else {
-          set(obj,val) ;
-        }
-      }
-    }
-    
-    private void set(Object obj, Object v) {
-      try {
-        if (field != null) {
-          field.set(obj, v);
-        } else if (setter != null) {
-          setter.invoke(obj, v);
-        }
-      } 
-      catch (Exception e) {
-        throw new RuntimeException("Exception while setting value : "+v+" on " + (field != null ? field : setter), e);
-      }
-    }
-    
-    public Object get( final Object obj )
-    {
-      if (field != null) {
-        try {
-          return field.get(obj);
-        } 
-        catch (Exception e) {        
-          throw new RuntimeException("Exception while getting value: " + field, e);
-        }
-      }
-      else if (getter == null) {
-        throw new RuntimeException( "Missing getter for field: "+name+" -- You can only call the 'get' for fields that have a field of 'get' method" );
-      }
-      
-      try {
-        return getter.invoke( obj, (Object[])null );
-      } 
-      catch (Exception e) {        
-        throw new RuntimeException("Exception while getting value: " + getter, e);
-      }
-    }
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/beans/Field.java b/client/java/solrj/src/org/apache/solr/client/solrj/beans/Field.java
deleted file mode 100644
index 156fcef..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/beans/Field.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.client.solrj.beans;
-
-import static java.lang.annotation.ElementType.*;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Target;
-import java.lang.annotation.Retention;
-
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-@Target({FIELD, METHOD})
-@Retention(RUNTIME)
-public @interface Field {
-  public static final String DEFAULT ="#default";
-  String value() default DEFAULT;
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
deleted file mode 100644
index e822eee..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import java.io.IOException;
-
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.core.CoreContainer;
-import org.apache.solr.core.CoreDescriptor;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.request.BinaryResponseWriter;
-import org.apache.solr.request.SolrQueryRequest;
-import org.apache.solr.request.SolrQueryResponse;
-import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.servlet.SolrRequestParsers;
-
-/**
- * SolrServer that connects directly to SolrCore
- * 
- * TODO -- this implementation sends the response to XML and then parses it.  
- * It *should* be able to convert the response directly into a named list.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class EmbeddedSolrServer extends SolrServer
-{
-  protected final CoreContainer coreContainer;
-  protected final String coreName;
-  private final SolrRequestParsers _parser;
-  
-  /**
-   * Use the other constructor using a CoreContainer and a name.
-   * @param core
-   * @deprecated
-   */
-  @Deprecated
-  public EmbeddedSolrServer( SolrCore core )
-  {
-    if ( core == null ) {
-      throw new NullPointerException("SolrCore instance required");
-    }
-    CoreDescriptor dcore = core.getCoreDescriptor();
-    if (dcore == null)
-      throw new NullPointerException("CoreDescriptor required");
-    
-    CoreContainer cores = dcore.getCoreContainer();
-    if (cores == null)
-      throw new NullPointerException("CoreContainer required");
-    
-    coreName = dcore.getName();
-    coreContainer = cores;
-    _parser = new SolrRequestParsers( null );
-  }
-    
-  /**
-   * Creates a SolrServer.
-   * @param coreContainer the core container
-   * @param coreName the core name
-   */
-  public EmbeddedSolrServer(  CoreContainer coreContainer, String coreName )
-  {
-    if ( coreContainer == null ) {
-      throw new NullPointerException("CoreContainer instance required");
-    }
-    this.coreContainer = coreContainer;
-    this.coreName = coreName == null? "" : coreName;
-    _parser = new SolrRequestParsers( null );
-  }
-  
-  @Override
-  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException 
-  {
-    String path = request.getPath();
-    if( path == null || !path.startsWith( "/" ) ) {
-      path = "/select";
-    }
-
-    // Check for cores action
-    SolrCore core =  coreContainer.getCore( coreName );
-    if( core == null ) {
-      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, 
-                               "No such core: " + coreName );
-    }
-    
-    SolrParams params = request.getParams();
-    if( params == null ) {
-      params = new ModifiableSolrParams();
-    }
-    
-    // Extract the handler from the path or params
-    SolrRequestHandler handler = core.getRequestHandler( path );
-    if( handler == null ) {
-      if( "/select".equals( path ) || "/select/".equalsIgnoreCase( path) ) {
-        String qt = params.get( CommonParams.QT );
-        handler = core.getRequestHandler( qt );
-        if( handler == null ) {
-          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
-        }
-      }
-      // Perhaps the path is to manage the cores
-      if( handler == null &&
-          coreContainer != null &&
-          path.equals( coreContainer.getAdminPath() ) ) {
-        handler = coreContainer.getMultiCoreHandler();
-      }
-    }
-    if( handler == null ) {
-      core.close();
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+path );
-    }
-
-    try {
-      SolrQueryRequest req = _parser.buildRequestFrom( core, params, request.getContentStreams() );
-      req.getContext().put( "path", path );
-      SolrQueryResponse rsp = new SolrQueryResponse();
-      core.execute( handler, req, rsp );
-      if( rsp.getException() != null ) {
-        throw new SolrServerException( rsp.getException() );
-      }
-      
-      // Now write it out
-      NamedList<Object> normalized = getParsedResponse(req, rsp);
-      req.close();
-      return normalized;
-    }
-    catch( IOException iox ) {
-      throw iox;
-    }
-    catch( Exception ex ) {
-      throw new SolrServerException( ex );
-    }
-    finally {
-      core.close();
-    }
-  }
-  
-  /**
-   * @param req
-   * @param rsp
-   * @return a response object equivalent to what you get from the XML/JSON/javabin parser. Documents
-   * become SolrDocuments, DocList becomes SolrDocumentList etc.
-   * 
-   * @deprecated use {@link BinaryResponseWriter#getParsedResponse(SolrQueryRequest, SolrQueryResponse)}
-   */
-  public NamedList<Object> getParsedResponse( SolrQueryRequest req, SolrQueryResponse rsp )
-  {
-    return BinaryResponseWriter.getParsedResponse(req, rsp);
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java b/client/java/solrj/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java
deleted file mode 100644
index ff7a058..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import java.io.IOException;
-
-import javax.servlet.http.HttpServlet;
-import javax.servlet.http.HttpServletRequest;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.solr.servlet.SolrDispatchFilter;
-import org.mortbay.jetty.Handler;
-import org.mortbay.jetty.Server;
-import org.mortbay.jetty.Connector;
-import org.mortbay.jetty.servlet.Context;
-import org.mortbay.jetty.servlet.FilterHolder;
-import org.mortbay.log.Logger;
-
-/**
- * Run solr using jetty
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class JettySolrRunner 
-{
-  Server server;
-  FilterHolder dispatchFilter;
-  
-  public JettySolrRunner( String context, int port )
-  {
-    this.init( context, port );
-  }
-
-  public JettySolrRunner( String context, int port, String solrConfigFilename )
-  {
-    this.init( context, port );
-    dispatchFilter.setInitParameter("solrconfig-filename", solrConfigFilename);
-  }
-  
-//  public JettySolrRunner( String context, String home, String dataDir, int port, boolean log )
-//  {
-//    if(!log) {
-//      System.setProperty("org.mortbay.log.class", NoLog.class.getName() );
-//      System.setProperty("java.util.logging.config.file", home+"/conf/logging.properties");
-//      NoLog noLogger = new NoLog();
-//      org.mortbay.log.Log.setLog(noLogger);
-//    }
-//
-//    // Initalize JNDI
-//    Config.setInstanceDir(home);
-//    new SolrCore(dataDir, new IndexSchema(home+"/conf/schema.xml"));
-//    this.init( context, port );
-//  }
-  
-  private void init( String context, int port )
-  {
-    server = new Server( port );    
-    server.setStopAtShutdown( true );
-    
-    // Initialize the servlets
-    Context root = new Context( server, context, Context.SESSIONS );
-    
-    // for some reason, there must be a servlet for this to get applied
-    root.addServlet( Servlet404.class, "/*" );
-    dispatchFilter = root.addFilter( SolrDispatchFilter.class, "*", Handler.REQUEST );
-  }
-
-  //------------------------------------------------------------------------------------------------
-  //------------------------------------------------------------------------------------------------
-  
-  public void start() throws Exception
-  {
-    if(!server.isRunning() ) {
-      server.start();
-    }
-  }
-  
-  public void stop() throws Exception
-  {
-    if( server.isRunning() ) {
-      server.stop();
-      server.join();
-    }
-  }
-
-  /**
-   * Returns the Local Port of the first Connector found for the jetty Server.
-   * @exception RuntimeException if there is no Connector
-   */
-  public int getLocalPort() {
-    Connector[] conns = server.getConnectors();
-    if (0 == conns.length) {
-      throw new RuntimeException("Jetty Server has no Connectors");
-    }
-    return conns[0].getLocalPort();
-  }
-  
-  //--------------------------------------------------------------
-  //--------------------------------------------------------------
-    
-  /** 
-   * This is a stupid hack to give jetty something to attach to
-   */
-  public static class Servlet404 extends HttpServlet
-  {
-    @Override
-    public void service(HttpServletRequest req, HttpServletResponse res ) throws IOException
-    {
-      res.sendError( 404, "Can not find: "+req.getRequestURI() );
-    }
-  }
-  
-  /**
-   * A main class that starts jetty+solr 
-   * This is useful for debugging
-   */
-  public static void main( String[] args )
-  {
-    try {
-      JettySolrRunner jetty = new JettySolrRunner( "/solr", 3456 );
-      jetty.start();
-    }
-    catch( Exception ex ) {
-      ex.printStackTrace();
-    }
-  }
-}
-
-
-class NoLog implements Logger
-{    
-  private static boolean debug = System.getProperty("DEBUG",null)!=null;
-  private final String name;
-      
-  public NoLog()
-  {
-    this(null);
-  }
-  
-  public NoLog(String name)
-  {    
-    this.name=name==null?"":name;
-  }
-  
-  public boolean isDebugEnabled()
-  {
-    return debug;
-  }
-  
-  public void setDebugEnabled(boolean enabled)
-  {
-    debug=enabled;
-  }
-  
-  public void info(String msg,Object arg0, Object arg1) {}
-  public void debug(String msg,Throwable th){}
-  public void debug(String msg,Object arg0, Object arg1){}
-  public void warn(String msg,Object arg0, Object arg1){}
-  public void warn(String msg, Throwable th){}
-
-  public Logger getLogger(String name)
-  {
-    if ((name==null && this.name==null) ||
-      (name!=null && name.equals(this.name)))
-      return this;
-    return new NoLog(name);
-  }
-  
-  @Override
-  public String toString()
-  {
-    return "NOLOG["+name+"]";
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/impl/BinaryResponseParser.java b/client/java/solrj/src/org/apache/solr/client/solrj/impl/BinaryResponseParser.java
deleted file mode 100755
index 466b07c..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/impl/BinaryResponseParser.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.client.solrj.impl;
-
-import org.apache.solr.client.solrj.ResponseParser;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.NamedListCodec;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class BinaryResponseParser extends ResponseParser {
-  public String getWriterType() {
-    return "javabin";
-  }
-
-  public NamedList<Object> processResponse(InputStream body, String encoding) {
-    try {
-      return new NamedListCodec().unmarshal(body);
-    } catch (IOException e) {
-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
-
-    }
-  }
-
-  public NamedList<Object> processResponse(Reader reader) {
-    throw new RuntimeException("Cannot handle character stream");
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java b/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
deleted file mode 100644
index 9fa758c..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.impl;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.InflaterInputStream;
-
-import org.apache.commons.httpclient.*;
-import org.apache.commons.httpclient.methods.GetMethod;
-import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
-import org.apache.commons.httpclient.methods.PostMethod;
-import org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;
-import org.apache.commons.httpclient.methods.multipart.Part;
-import org.apache.commons.httpclient.methods.multipart.PartBase;
-import org.apache.commons.httpclient.methods.multipart.StringPart;
-import org.apache.commons.io.IOUtils;
-import org.apache.solr.client.solrj.ResponseParser;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.DefaultSolrParams;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class CommonsHttpSolrServer extends SolrServer 
-{
-  public static final String AGENT = "Solr["+CommonsHttpSolrServer.class.getName()+"] 1.0"; 
-  
-  /**
-   * The URL of the Solr server.
-   */
-  protected String _baseURL;
-  protected ModifiableSolrParams _invariantParams;
-  protected ResponseParser _parser;
-  
-  private final HttpClient _httpClient;
-  private boolean _followRedirects = false;
-  private boolean _allowCompression = false;
-  private int _maxRetries = 0;
-  
-  /**
-   * If set to false, add the query parameters as URL-encoded parameters to the
-   * POST request in a single part. If set to true, create a new part of a
-   * multi-part request for each parameter.
-   * 
-   * The reason for adding all parameters as parts of a multi-part request is
-   * that this allows us to specify the charset -- standards for single-part
-   * requests specify that non-ASCII characters should be URL-encoded, but don't
-   * specify the charset of the characters to be URL-encoded (cf.
-   * http://www.w3.org/TR/html401/interact/forms.html#form-content-type).
-   * Therefore you have to rely on your servlet container doing the right thing
-   * with single-part requests.
-   */
-  private boolean useMultiPartPost;
-  
-  /**  
-   * @param solrServerUrl The URL of the Solr server.  For 
-   * example, "<code>http://localhost:8983/solr/</code>"
-   * if you are using the standard distribution Solr webapp 
-   * on your local machine.
-   */
-  public CommonsHttpSolrServer(String solrServerUrl) throws MalformedURLException {
-    this(new URL(solrServerUrl));
-  }
-
-  /** Talk to the Solr server via the given HttpClient.  The connection manager
-   * for the client should be a MultiThreadedHttpConnectionManager if this
-   * client is being reused across SolrServer instances, or of multiple threads
-   * will use this SolrServer.
-   */
-  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient) throws MalformedURLException {
-    this(new URL(solrServerUrl), httpClient, new BinaryResponseParser(), false);
-  }
-  
-  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient, boolean useMultiPartPost) throws MalformedURLException {
-    this(new URL(solrServerUrl), httpClient, new BinaryResponseParser(), useMultiPartPost);
-  }
-
-  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient, ResponseParser parser) throws MalformedURLException {
-    this(new URL(solrServerUrl), httpClient, parser, false);
-  }
-
-  /**
-   * @param baseURL The URL of the Solr server.  For 
-   * example, "<code>http://localhost:8983/solr/</code>"
-   * if you are using the standard distribution Solr webapp 
-   * on your local machine.
-   */
-  public CommonsHttpSolrServer(URL baseURL) 
-  {
-    this(baseURL, null, new BinaryResponseParser(), false);
-  }
-
-  public CommonsHttpSolrServer(URL baseURL, HttpClient client){
-    this(baseURL, client, new BinaryResponseParser(), false);
-  }
-  
-  public CommonsHttpSolrServer(URL baseURL, HttpClient client, boolean useMultiPartPost){
-    this(baseURL, client, new BinaryResponseParser(), useMultiPartPost);
-  }
-
-
-  public CommonsHttpSolrServer(URL baseURL, HttpClient client, ResponseParser parser, boolean useMultiPartPost) {
-    _baseURL = baseURL.toExternalForm();
-    if( _baseURL.endsWith( "/" ) ) {
-      _baseURL = _baseURL.substring( 0, _baseURL.length()-1 );
-    }
-    if( _baseURL.indexOf( '?' ) >=0 ) {
-      throw new RuntimeException( "Invalid base url for solrj.  The base URL must not contain parameters: "+_baseURL );
-    }
- 
-    _httpClient = (client == null) ? new HttpClient(new MultiThreadedHttpConnectionManager()) : client;
-
-    if (client == null) {
-      // set some better defaults if we created a new connection manager and client
-      
-      // increase the default connections
-      this.setDefaultMaxConnectionsPerHost( 32 );  // 2
-      this.setMaxTotalConnections( 128 ); // 20
-    }
-
-    // by default use the binary response parser
-    _parser = parser;
-    
-    this.useMultiPartPost = useMultiPartPost;
-  }
-
-
-  //------------------------------------------------------------------------
-  //------------------------------------------------------------------------
-
-  /**
-   * Process the request.  If {@link org.apache.solr.client.solrj.SolrRequest#getResponseParser()} is null, then use
-   * {@link #getParser()}
-   * @param request The {@link org.apache.solr.client.solrj.SolrRequest} to process
-   * @return The {@link org.apache.solr.common.util.NamedList} result
-   * @throws SolrServerException
-   * @throws IOException
-   *
-   * @see #request(org.apache.solr.client.solrj.SolrRequest, org.apache.solr.client.solrj.ResponseParser)
-   */
-  @Override
-  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException
-  {
-    ResponseParser responseParser = request.getResponseParser();
-    if (responseParser == null) {
-      responseParser = _parser;
-    }
-    return request(request, responseParser);
-  }
-
-  
-  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException{
-    
-    HttpMethod method = null;
-    SolrParams params = request.getParams();
-    Collection<ContentStream> streams = request.getContentStreams();
-    String path = request.getPath();
-    if( path == null || !path.startsWith( "/" ) ) {
-      path = "/select";
-    }
-    
-    ResponseParser parser = request.getResponseParser();
-    if( parser == null ) {
-      parser = _parser;
-    }
-    
-    // The parser 'wt=' and 'version=' params are used instead of the original params
-    ModifiableSolrParams wparams = new ModifiableSolrParams();
-    wparams.set( CommonParams.WT, parser.getWriterType() );
-    wparams.set( CommonParams.VERSION, parser.getVersion() );
-    if( params == null ) {
-      params = wparams;
-    }
-    else {
-      params = new DefaultSolrParams( wparams, params );
-    }
-    
-    if( _invariantParams != null ) {
-      params = new DefaultSolrParams( _invariantParams, params );
-    }
-
-    int tries = _maxRetries + 1;
-    try {
-      while( tries-- > 0 ) {
-        // Note: since we aren't do intermittent time keeping
-        // ourselves, the potential non-timeout latency could be as
-        // much as tries-times (plus scheduling effects) the given
-        // timeAllowed.
-        try {
-          if( SolrRequest.METHOD.GET == request.getMethod() ) {
-            if( streams != null ) {
-              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "GET can't send streams!" );
-            }
-            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );
-          }
-          else if( SolrRequest.METHOD.POST == request.getMethod() ) {
-
-            String url = _baseURL + path;
-            boolean isMultipart = ( streams != null && streams.size() > 1 );
-
-            if (streams == null || isMultipart) {
-              PostMethod post = new PostMethod(url);
-              post.getParams().setContentCharset("UTF-8");
-              if (!this.useMultiPartPost && !isMultipart) {
-                post.addRequestHeader("Content-Type",
-                    "application/x-www-form-urlencoded; charset=UTF-8");
-              }
-
-              List<Part> parts = new LinkedList<Part>();
-              Iterator<String> iter = params.getParameterNamesIterator();
-              while (iter.hasNext()) {
-                String p = iter.next();
-                String[] vals = params.getParams(p);
-                if (vals != null) {
-                  for (String v : vals) {
-                    if (this.useMultiPartPost || isMultipart) {
-                      parts.add(new StringPart(p, v, "UTF-8"));
-                    } else {
-                      post.addParameter(p, v);
-                    }
-                  }
-                }
-              }
-
-              if (isMultipart) {
-                int i = 0;
-                for (ContentStream content : streams) {
-                  final ContentStream c = content;
-
-                  String charSet = null;
-                  String transferEncoding = null;
-                  parts.add(new PartBase(c.getName(), c.getContentType(),
-                      charSet, transferEncoding) {
-                    @Override
-                    protected long lengthOfData() throws IOException {
-                      return c.getSize();
-                    }
-
-                    @Override
-                    protected void sendData(OutputStream out)
-                        throws IOException {
-                      IOUtils.copy(c.getReader(), out);
-                    }
-                  });
-                }
-              }
-              if (parts.size() > 0) {
-                post.setRequestEntity(new MultipartRequestEntity(parts
-                    .toArray(new Part[parts.size()]), post.getParams()));
-              }
-
-              method = post;
-            }
-            // It is has one stream, it is the post body, put the params in the URL
-            else {
-              String pstr = ClientUtils.toQueryString( params, false );
-              PostMethod post = new PostMethod( url+pstr );
-
-              // Single stream as body
-              // Using a loop just to get the first one
-              for( ContentStream content : streams ) {
-                post.setRequestEntity(
-                    new InputStreamRequestEntity( content.getStream(), content.getContentType())
-                );
-                break;
-              }
-              method = post;
-            }
-          }
-          else {
-            throw new SolrServerException("Unsupported method: "+request.getMethod() );
-          }
-        }
-        catch( NoHttpResponseException r ) {
-          // This is generally safe to retry on
-          method.releaseConnection();
-          method = null;
-          // If out of tries then just rethrow (as normal error).
-          if( ( tries < 1 ) ) {
-            throw r;
-          }
-          //log.warn( "Caught: " + r + ". Retrying..." );
-        }
-      }
-    }
-    catch( IOException ex ) {
-      throw new SolrServerException("error reading streams", ex );
-    }
-
-    method.setFollowRedirects( _followRedirects );
-    method.addRequestHeader( "User-Agent", AGENT );
-    if( _allowCompression ) {
-      method.setRequestHeader( new Header( "Accept-Encoding", "gzip,deflate" ) );
-    }
-
-    try {
-      // Execute the method.
-      //System.out.println( "EXECUTE:"+method.getURI() );
-
-      int statusCode = _httpClient.executeMethod(method);
-      if (statusCode != HttpStatus.SC_OK) {
-        StringBuilder msg = new StringBuilder();
-        msg.append( method.getStatusLine().getReasonPhrase() );
-        msg.append( "\n\n" );
-        msg.append( method.getStatusText() );
-        msg.append( "\n\n" );
-        msg.append( "request: "+method.getURI() );
-        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), "UTF-8") );
-      }
-
-      // Read the contents
-      String charset = "UTF-8";
-      if( method instanceof HttpMethodBase ) {
-        charset = ((HttpMethodBase)method).getResponseCharSet();
-      }
-      InputStream respBody = method.getResponseBodyAsStream();
-      // Jakarta Commons HTTPClient doesn't handle any
-      // compression natively.  Handle gzip or deflate
-      // here if applicable.
-      if( _allowCompression ) {
-        Header contentEncodingHeader = method.getResponseHeader( "Content-Encoding" );
-        if( contentEncodingHeader != null ) {
-          String contentEncoding = contentEncodingHeader.getValue();
-          if( contentEncoding.contains( "gzip" ) ) {
-            //log.debug( "wrapping response in GZIPInputStream" );
-            respBody = new GZIPInputStream( respBody );
-          }
-          else if( contentEncoding.contains( "deflate" ) ) {
-            //log.debug( "wrapping response in InflaterInputStream" );
-            respBody = new InflaterInputStream(respBody);
-          }
-        }
-        else {
-          Header contentTypeHeader = method.getResponseHeader( "Content-Type" );
-          if( contentTypeHeader != null ) {
-            String contentType = contentTypeHeader.getValue();
-            if( contentType != null ) {
-              if( contentType.startsWith( "application/x-gzip-compressed" ) ) {
-                //log.debug( "wrapping response in GZIPInputStream" );
-                respBody = new GZIPInputStream( respBody );
-              }
-              else if ( contentType.startsWith("application/x-deflate") ) {
-                //log.debug( "wrapping response in InflaterInputStream" );
-                respBody = new InflaterInputStream(respBody);
-              }
-            }
-          }
-        }
-      }
-      return processor.processResponse(respBody, charset);
-    }
-    catch (HttpException e) {
-      throw new SolrServerException( e );
-    }
-    catch (IOException e) {
-      throw new SolrServerException( e );
-    }
-    finally {
-      method.releaseConnection();
-    }
-  }
-
-  //-------------------------------------------------------------------
-  //-------------------------------------------------------------------
-  
-  /**
-   * Parameters are added to ever request regardless.  This may be a place to add 
-   * something like an authentication token.
-   */
-  public ModifiableSolrParams getInvariantParams()
-  {
-    return _invariantParams;
-  }
-
-  public String getBaseURL() {
-    return _baseURL;
-  }
-
-  public void setBaseURL(String baseURL) {
-    this._baseURL = baseURL;
-  }
-
-  public ResponseParser getParser() {
-    return _parser;
-  }
-
-  /**
-   * Note: Setting this value is not thread-safe.
-   * @param processor The {@link org.apache.solr.client.solrj.ResponseParser}
-   */
-  public void setParser(ResponseParser processor) {
-    _parser = processor;
-  }
-
-  public HttpClient getHttpClient() {
-    return _httpClient;
-  }
-
-  private HttpConnectionManager getConnectionManager() {
-    return _httpClient.getHttpConnectionManager();
-  }
-  
-  /** set connectionTimeout on the underlying HttpConnectionManager */
-  public void setConnectionTimeout(int timeout) {
-    getConnectionManager().getParams().setConnectionTimeout(timeout);
-  }
-  
-  /** set connectionManagerTimeout on the HttpClient.**/
-  public void setConnectionManagerTimeout(int timeout) {
-    _httpClient.getParams().setConnectionManagerTimeout(timeout);
-  }
-  
-  /** set soTimeout (read timeout) on the underlying HttpConnectionManager.  This is desirable for queries, but probably not for indexing. */
-  public void setSoTimeout(int timeout) {
-    getConnectionManager().getParams().setSoTimeout(timeout);
-  }
-  
-  /** set maxConnectionsPerHost on the underlying HttpConnectionManager */
-  public void setDefaultMaxConnectionsPerHost(int connections) {
-    getConnectionManager().getParams().setDefaultMaxConnectionsPerHost(connections);
-  }
-  
-  /** set maxTotalConnection on the underlying HttpConnectionManager */
-  public void setMaxTotalConnections(int connections) {
-    getConnectionManager().getParams().setMaxTotalConnections(connections);
-  }
-
-  /**
-   * set followRedirects.  This defaults to false under the
-   * assumption that if you are following a redirect to get to a Solr
-   * installation, something is misconfigured somewhere.
-   */
-  public void setFollowRedirects( boolean followRedirects ) {
-    _followRedirects = followRedirects;
-  }
-
-  /**
-   * set allowCompression.  If compression is enabled, both gzip and
-   * deflate compression will be accepted in the HTTP response.
-   */
-  public void setAllowCompression( boolean allowCompression ) {
-    _allowCompression = allowCompression;
-  }
-
-  /**
-   *  set maximum number of retries to attempt in the event of
-   *  transient errors.  Default: 0 (no) retries. No more than 1
-   *  recommended.
-   */
-  public void setMaxRetries( int maxRetries ) {
-    _maxRetries = maxRetries;
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/impl/XMLResponseParser.java b/client/java/solrj/src/org/apache/solr/client/solrj/impl/XMLResponseParser.java
deleted file mode 100644
index 318048f..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/impl/XMLResponseParser.java
+++ /dev/null
@@ -1,440 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.impl;
-
-import java.io.Reader;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.xml.stream.XMLInputFactory;
-import javax.xml.stream.XMLStreamConstants;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-
-import org.apache.solr.client.solrj.ResponseParser;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class XMLResponseParser extends ResponseParser
-{
-  public static Logger log = LoggerFactory.getLogger(XMLResponseParser.class);
-
-  // reuse the factory among all parser instances so things like string caches
-  // won't be duplicated
-  static final XMLInputFactory factory;
-  static {
-    factory = XMLInputFactory.newInstance();
-    try {
-      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe
-      // XMLInputFactory, as that implementation tries to cache and reuse the
-      // XMLStreamReader.  Setting the parser-specific "reuse-instance" property to false
-      // prevents this.
-      // All other known open-source stax parsers (and the bea ref impl)
-      // have thread-safe factories.
-      factory.setProperty("reuse-instance", Boolean.FALSE);
-    }
-    catch( IllegalArgumentException ex ) {
-      // Other implementations will likely throw this exception since "reuse-instance"
-      // isimplementation specific.
-      log.debug( "Unable to set the 'reuse-instance' property for the input factory: "+factory );
-    }
-  }
-
-  public XMLResponseParser() {}
-  
-  @Override
-  public String getWriterType()
-  {
-    return "xml";
-  }
-
-  @Override
-  public NamedList<Object> processResponse(Reader in) {
-    XMLStreamReader parser = null;
-    try {
-      parser = factory.createXMLStreamReader(in);
-    } catch (XMLStreamException e) {
-      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
-    }
-
-    return processResponse(parser);    
-  }
-
-  @Override
-  public NamedList<Object> processResponse(InputStream in, String encoding)
-  {
-     XMLStreamReader parser = null;
-    try {
-      parser = factory.createXMLStreamReader(in, encoding);
-    } catch (XMLStreamException e) {
-      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
-    }
-
-    return processResponse(parser);
-  }
-
-  /**
-   * parse the text into a named list...
-   */
-  private NamedList<Object> processResponse(XMLStreamReader parser)
-  {
-    try {
-      NamedList<Object> response = null;
-      for (int event = parser.next();  
-       event != XMLStreamConstants.END_DOCUMENT;
-       event = parser.next()) 
-      {
-        switch (event) {
-          case XMLStreamConstants.START_ELEMENT:
-
-            if( response != null ) {
-              throw new Exception( "already read the response!" );
-            }
-            
-            // only top-level element is "response
-            String name = parser.getLocalName();
-            if( name.equals( "response" ) || name.equals( "result" ) ) {
-              response = readNamedList( parser );
-            }
-            else if( name.equals( "solr" ) ) {
-              return new SimpleOrderedMap<Object>();
-            }
-            else {
-              throw new Exception( "really needs to be response or result.  " +
-                  "not:"+parser.getLocalName() );
-            }
-            break;
-        } 
-      } 
-      return response;
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", ex );
-    }
-    finally {
-      try {
-        parser.close();
-      }
-      catch( Exception ex ){}
-    }
-  }
-
-  
-  protected enum KnownType {
-    STR    (true)  { @Override public String  read( String txt ) { return txt;                  } },
-    INT    (true)  { @Override public Integer read( String txt ) { return Integer.valueOf(txt); } },
-    FLOAT  (true)  { @Override public Float   read( String txt ) { return Float.valueOf(txt);   } },
-    DOUBLE (true)  { @Override public Double  read( String txt ) { return Double.valueOf(txt);  } },
-    LONG   (true)  { @Override public Long    read( String txt ) { return Long.valueOf(txt);    } },
-    BOOL   (true)  { @Override public Boolean read( String txt ) { return Boolean.valueOf(txt); } },
-    NULL   (true)  { @Override public Object  read( String txt ) { return null;                 } },
-    DATE   (true)  { 
-      @Override 
-      public Date read( String txt ) { 
-        try {
-          return ClientUtils.parseDate(txt);      
-        }
-        catch( Exception ex ) {
-          ex.printStackTrace();
-        }
-        return null;
-      } 
-    },
-    
-    ARR    (false) { @Override public Object read( String txt ) { return null; } },
-    LST    (false) { @Override public Object read( String txt ) { return null; } },
-    RESULT (false) { @Override public Object read( String txt ) { return null; } },
-    DOC    (false) { @Override public Object read( String txt ) { return null; } };
-    
-    final boolean isLeaf;
-    
-    KnownType( boolean isLeaf )
-    {
-      this.isLeaf = isLeaf;
-    }
-    
-    public abstract Object read( String txt );
-    
-    public static KnownType get( String v )
-    {
-      if( v != null ) {
-        try {
-          return KnownType.valueOf( v.toUpperCase() );
-        }
-        catch( Exception ex ) {}
-      }
-      return null;
-    }
-  };
-  
-  protected NamedList<Object> readNamedList( XMLStreamReader parser ) throws XMLStreamException
-  {
-    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
-      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
-    }
-
-    StringBuilder builder = new StringBuilder();
-    NamedList<Object> nl = new SimpleOrderedMap<Object>();
-    KnownType type = null;
-    String name = null;
-    
-    // just eat up the events...
-    int depth = 0;
-    while( true ) 
-    {
-      switch (parser.next()) {
-      case XMLStreamConstants.START_ELEMENT:
-        depth++;
-        builder.setLength( 0 ); // reset the text
-        type = KnownType.get( parser.getLocalName() );
-        if( type == null ) {
-          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
-        }
-        
-        name = null;
-        int cnt = parser.getAttributeCount();
-        for( int i=0; i<cnt; i++ ) {
-          if( "name".equals( parser.getAttributeLocalName( i ) ) ) {
-            name = parser.getAttributeValue( i );
-            break;
-          }
-        }
-        
-        if( name == null ) {
-          throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );
-        }
-        
-        if( !type.isLeaf ) {
-          switch( type ) {
-          case LST:    nl.add( name, readNamedList( parser ) ); depth--; continue;
-          case ARR:    nl.add( name, readArray(     parser ) ); depth--; continue;
-          case RESULT: nl.add( name, readDocuments( parser ) ); depth--; continue;
-          case DOC:    nl.add( name, readDocument(  parser ) ); depth--; continue;
-          }
-          throw new XMLStreamException( "branch element not handled!", parser.getLocation() );
-        }
-        break;
-        
-      case XMLStreamConstants.END_ELEMENT:
-        if( --depth < 0 ) {
-          return nl;
-        }
-        //System.out.println( "NL:ELEM:"+type+"::"+name+"::"+builder );
-        nl.add( name, type.read( builder.toString().trim() ) );
-        break;
-
-      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
-      case XMLStreamConstants.CDATA:
-      case XMLStreamConstants.CHARACTERS:
-        builder.append( parser.getText() );
-        break;
-      }
-    }
-  }
-
-  protected List<Object> readArray( XMLStreamReader parser ) throws XMLStreamException
-  {
-    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
-      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
-    }
-    if( !"arr".equals( parser.getLocalName().toLowerCase() ) ) {
-      throw new RuntimeException( "must be 'arr', not: "+parser.getLocalName() );
-    }
-    
-    StringBuilder builder = new StringBuilder();
-    KnownType type = null;
-
-    List<Object> vals = new ArrayList<Object>();
-
-    int depth = 0;
-    while( true ) 
-    {
-      switch (parser.next()) {
-      case XMLStreamConstants.START_ELEMENT:
-        depth++;
-        KnownType t = KnownType.get( parser.getLocalName() );
-        if( t == null ) {
-          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
-        }
-        if( type == null ) {
-          type = t;
-        }
-        /*** actually, there is no rule that arrays need the same type
-        else if( type != t && !(t == KnownType.NULL || type == KnownType.NULL)) {
-          throw new RuntimeException( "arrays must have the same type! ("+type+"!="+t+") "+parser.getLocalName() );
-        }
-        ***/
-        type = t;
-
-        builder.setLength( 0 ); // reset the text
-        
-        if( !type.isLeaf ) {
-          switch( type ) {
-          case LST:    vals.add( readNamedList( parser ) ); continue;
-          case ARR:    vals.add( readArray( parser ) ); continue;
-          case RESULT: vals.add( readDocuments( parser ) ); continue;
-          case DOC:    vals.add( readDocument( parser ) ); continue;
-          }
-          throw new XMLStreamException( "branch element not handled!", parser.getLocation() );
-        }
-        break;
-        
-      case XMLStreamConstants.END_ELEMENT:
-        if( --depth < 0 ) {
-          return vals; // the last element is itself
-        }
-        //System.out.println( "ARR:"+type+"::"+builder );
-        Object val = type.read( builder.toString().trim() );
-        if( val == null && type != KnownType.NULL) {
-          throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );
-        }
-        vals.add( val );
-        break;
-
-      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
-      case XMLStreamConstants.CDATA:
-      case XMLStreamConstants.CHARACTERS:
-        builder.append( parser.getText() );
-        break;
-    }
-    }
-  }
-  
-  protected SolrDocumentList readDocuments( XMLStreamReader parser ) throws XMLStreamException
-  {
-    SolrDocumentList docs = new SolrDocumentList();
-
-    // Parse the attributes
-    for( int i=0; i<parser.getAttributeCount(); i++ ) {
-      String n = parser.getAttributeLocalName( i );
-      String v = parser.getAttributeValue( i );
-      if( "numFound".equals( n ) ) {
-        docs.setNumFound( Long.parseLong( v ) );
-      }
-      else if( "start".equals( n ) ) {
-        docs.setStart( Long.parseLong( v ) );
-      }
-      else if( "maxScore".equals( n ) ) {
-        docs.setMaxScore( Float.parseFloat( v ) );
-      }
-    }
-    
-    // Read through each document
-    int event;
-    while( true ) {
-      event = parser.next();
-      if( XMLStreamConstants.START_ELEMENT == event ) {
-        if( !"doc".equals( parser.getLocalName() ) ) {
-          throw new RuntimeException( "shoudl be doc! "+parser.getLocalName() + " :: " + parser.getLocation() );
-        }
-        docs.add( readDocument( parser ) );
-      }
-      else if ( XMLStreamConstants.END_ELEMENT == event ) {
-        return docs;  // only happens once
-      }
-    }
-  }
-
-  protected SolrDocument readDocument( XMLStreamReader parser ) throws XMLStreamException
-  {
-    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
-      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
-    }
-    if( !"doc".equals( parser.getLocalName().toLowerCase() ) ) {
-      throw new RuntimeException( "must be 'lst', not: "+parser.getLocalName() );
-    }
-
-    SolrDocument doc = new SolrDocument();
-    StringBuilder builder = new StringBuilder();
-    KnownType type = null;
-    String name = null;
-    
-    // just eat up the events...
-    int depth = 0;
-    while( true ) 
-    {
-      switch (parser.next()) {
-      case XMLStreamConstants.START_ELEMENT:
-        depth++;
-        builder.setLength( 0 ); // reset the text
-        type = KnownType.get( parser.getLocalName() );
-        if( type == null ) {
-          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
-        }
-        
-        name = null;
-        int cnt = parser.getAttributeCount();
-        for( int i=0; i<cnt; i++ ) {
-          if( "name".equals( parser.getAttributeLocalName( i ) ) ) {
-            name = parser.getAttributeValue( i );
-            break;
-          }
-        }
-        
-        if( name == null ) {
-          throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );
-        }
-        
-        // Handle multi-valued fields
-        if( type == KnownType.ARR ) {
-          for( Object val : readArray( parser ) ) {
-            doc.addField( name, val );
-          }
-          depth--; // the array reading clears out the 'endElement'
-        }
-        else if( !type.isLeaf ) {
-          throw new XMLStreamException( "must be value or array", parser.getLocation() );
-        }
-        break;
-        
-      case XMLStreamConstants.END_ELEMENT:
-        if( --depth < 0 ) {
-          return doc;
-        }
-        //System.out.println( "FIELD:"+type+"::"+name+"::"+builder );
-        Object val = type.read( builder.toString().trim() );
-        if( val == null ) {
-          throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );
-        }
-        doc.addField( name, val );
-        break;
-
-      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
-      case XMLStreamConstants.CDATA:
-      case XMLStreamConstants.CHARACTERS:
-        builder.append( parser.getText() );
-        break;
-      }
-    }
-  }
-
-  
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/CoreAdminRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/CoreAdminRequest.java
deleted file mode 100644
index c2a2389..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/CoreAdminRequest.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.response.CoreAdminResponse;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.CoreAdminParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * This class is experimental and subject to change.
- * @version $Id: CoreAdminRequest.java 606335 2007-12-21 22:23:39Z ryan $
- * @since solr 1.3
- */
-public class CoreAdminRequest extends SolrRequest
-{
-  protected String core = null;
-  protected String other = null;
-  protected CoreAdminParams.CoreAdminAction action = null;
-  
-  //a create core request
-  public static class Create extends CoreAdminRequest {
-    protected String instanceDir;
-    protected String configName = null;
-    protected String schemaName = null;
-    
-    public Create() {
-      action = CoreAdminAction.CREATE;
-    }
-    
-    public void setInstanceDir(String instanceDir) { this.instanceDir = instanceDir; }
-    public void setSchemaName(String schema) { this.schemaName = schema; }
-    public void setConfigName(String config) { this.configName = config; }
-    
-    public String getInstanceDir() { return instanceDir; }
-    public String getSchemaName()  { return schemaName; }
-    public String getConfigName()  { return configName; }
-    
-    @Override
-    public SolrParams getParams() {
-      if( action == null ) {
-        throw new RuntimeException( "no action specified!" );
-      }
-      ModifiableSolrParams params = new ModifiableSolrParams();
-      params.set( CoreAdminParams.ACTION, action.toString() );
-      if( action.equals(CoreAdminAction.CREATE) ) {
-        params.set( CoreAdminParams.NAME, core );
-      } else {
-        params.set( CoreAdminParams.CORE, core );
-      }
-      params.set( CoreAdminParams.INSTANCE_DIR, instanceDir);
-      if (configName != null) {
-        params.set( CoreAdminParams.CONFIG, configName);
-      }
-      if (schemaName != null) {
-        params.set( CoreAdminParams.SCHEMA, schemaName);
-      }
-      return params;
-    }
-  }
-    //a persist core request
-  public static class Persist extends CoreAdminRequest {
-    protected String fileName = null;
-    
-    public Persist() {
-      action = CoreAdminAction.PERSIST;
-    }
-    
-    public void setFileName(String name) {
-      fileName = name;
-    }
-    public String getFileName() {
-      return fileName;
-    }
-    @Override
-    public SolrParams getParams() {
-      if( action == null ) {
-        throw new RuntimeException( "no action specified!" );
-      }
-      ModifiableSolrParams params = new ModifiableSolrParams();
-      params.set( CoreAdminParams.ACTION, action.toString() );
-      if (fileName != null) {
-        params.set( CoreAdminParams.FILE, fileName);
-      }
-      return params;
-    }
-  }
-  
-  public CoreAdminRequest()
-  {
-    super( METHOD.GET, "/admin/cores" );
-  }
-
-  public CoreAdminRequest( String path )
-  {
-    super( METHOD.GET, path );
-  }
-
-  public final void setCoreName( String coreName )
-  {
-    this.core = coreName;
-  }
-
-  public final void setOtherCoreName( String otherCoreName )
-  {
-    this.other = otherCoreName;
-  }
-  
-  //---------------------------------------------------------------------------------------
-  //
-  //---------------------------------------------------------------------------------------
-
-  public void setAction( CoreAdminAction action )
-  {
-    this.action = action;
-  }
-
-  //---------------------------------------------------------------------------------------
-  //
-  //---------------------------------------------------------------------------------------
-
-  @Override
-  public SolrParams getParams() 
-  {
-    if( action == null ) {
-      throw new RuntimeException( "no action specified!" );
-    }
-    ModifiableSolrParams params = new ModifiableSolrParams();
-    params.set( CoreAdminParams.ACTION, action.toString() );
-    params.set( CoreAdminParams.CORE, core );
-    if (other != null) {
-      params.set(CoreAdminParams.OTHER, other);
-    }
-    return params;
-  }
-
-  //---------------------------------------------------------------------------------------
-  //
-  //---------------------------------------------------------------------------------------
-
-  @Override
-  public Collection<ContentStream> getContentStreams() throws IOException {
-    return null;
-  }
-
-  @Override
-  public CoreAdminResponse process(SolrServer server) throws SolrServerException, IOException 
-  {
-    long startTime = System.currentTimeMillis();
-    CoreAdminResponse res = new CoreAdminResponse();
-    res.setResponse( server.request( this ) );
-    res.setElapsedTime( System.currentTimeMillis()-startTime );
-    return res;
-  }
-
-  //---------------------------------------------------------------------------------------
-  //
-  //---------------------------------------------------------------------------------------
-
-  public static CoreAdminResponse reloadCore( String name, SolrServer server ) throws SolrServerException, IOException
-  {
-    CoreAdminRequest req = new CoreAdminRequest();
-    req.setCoreName( name );
-    req.setAction( CoreAdminAction.RELOAD );
-    return req.process( server );
-  }
-
-  public static CoreAdminResponse unloadCore( String name, SolrServer server ) throws SolrServerException, IOException
-  {
-    CoreAdminRequest req = new CoreAdminRequest();
-    req.setCoreName( name );
-    req.setAction( CoreAdminAction.UNLOAD );
-    return req.process( server );
-  }  
-
-  public static CoreAdminResponse renameCore(String coreName, String newName, SolrServer server ) throws SolrServerException, IOException
-  {
-    CoreAdminRequest req = new CoreAdminRequest();
-    req.setCoreName(coreName);
-    req.setOtherCoreName(newName);
-    req.setAction( CoreAdminAction.RENAME );
-    return req.process( server );
-  }
-
-  public static CoreAdminResponse aliasCore(String coreName, String newName, SolrServer server ) throws SolrServerException, IOException
-  {
-    CoreAdminRequest req = new CoreAdminRequest();
-    req.setCoreName(coreName);
-    req.setOtherCoreName(newName);
-    req.setAction( CoreAdminAction.ALIAS );
-    return req.process( server );
-  }
-
-  public static CoreAdminResponse getStatus( String name, SolrServer server ) throws SolrServerException, IOException
-  {
-    CoreAdminRequest req = new CoreAdminRequest();
-    req.setCoreName( name );
-    req.setAction( CoreAdminAction.STATUS );
-    return req.process( server );
-  }
-  
-  public static CoreAdminResponse createCore( String name, String instanceDir, SolrServer server ) throws SolrServerException, IOException 
-  {
-    return CoreAdminRequest.createCore(name, instanceDir, server, null, null);
-  }
-  
-  public static CoreAdminResponse createCore( String name, String instanceDir, SolrServer server, String configFile, String schemaFile ) throws SolrServerException, IOException 
-  {
-    CoreAdminRequest.Create req = new CoreAdminRequest.Create();
-    req.setCoreName( name );
-    req.setInstanceDir(instanceDir);
-    if(configFile != null){
-      req.setConfigName(configFile);
-    }
-    if(schemaFile != null){
-      req.setSchemaName(schemaFile);
-    }
-    return req.process( server );
-  }
-
-  public static CoreAdminResponse persist(String fileName, SolrServer server) throws SolrServerException, IOException 
-  {
-    CoreAdminRequest.Persist req = new CoreAdminRequest.Persist();
-    req.setFileName(fileName);
-    return req.process(server);
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/DirectXmlRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/DirectXmlRequest.java
deleted file mode 100644
index 0f10300..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/DirectXmlRequest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.response.UpdateResponse;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * Send arbitrary XML to a request handler
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class DirectXmlRequest extends SolrRequest
-{
-  final String xml;
-  
-  public DirectXmlRequest( String path, String body )
-  {
-    super( METHOD.POST, path );
-    xml = body;
-  }
-
-  @Override
-  public Collection<ContentStream> getContentStreams() {
-    return ClientUtils.toContentStreams( xml, ClientUtils.TEXT_XML );
-  }
-
-  @Override
-  public SolrParams getParams() {
-    return null;
-  }
-
-  @Override
-  public UpdateResponse process( SolrServer server ) throws SolrServerException, IOException
-  {
-    long startTime = System.currentTimeMillis();
-    UpdateResponse res = new UpdateResponse();
-    res.setResponse( server.request( this ) );
-    res.setElapsedTime( System.currentTimeMillis()-startTime );
-    return res;
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java
deleted file mode 100644
index 3109203..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/LukeRequest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.response.LukeResponse;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class LukeRequest extends SolrRequest
-{
-  private List<String> fields;
-  private int numTerms = -1;
-  private boolean showSchema = false;
-  
-  public LukeRequest()
-  {
-    super( METHOD.GET, "/admin/luke" );
-  }
-
-  public LukeRequest( String path )
-  {
-    super( METHOD.GET, path );
-  }
-
-  //---------------------------------------------------------------------------------
-  //---------------------------------------------------------------------------------
-  
-  public void addField( String f )
-  {
-    if( fields == null ) {
-      fields = new ArrayList<String>();
-    }
-    fields.add( f );
-  }
-
-  public void setFields( List<String> f )
-  {
-    fields = f;
-  }
-  
-  //---------------------------------------------------------------------------------
-  //---------------------------------------------------------------------------------
-  
-  public boolean isShowSchema() {
-    return showSchema;
-  }
-
-  public void setShowSchema(boolean showSchema) {
-    this.showSchema = showSchema;
-  }
-
-  public int getNumTerms() {
-    return numTerms;
-  }
-
-  /**
-   * the number of terms to return for a given field.  If the number is 0, it will not traverse the terms.  
-   */
-  public void setNumTerms(int count) {
-    this.numTerms = count;
-  }
-
-  //---------------------------------------------------------------------------------
-  //---------------------------------------------------------------------------------
-  
-  @Override
-  public Collection<ContentStream> getContentStreams() {
-    return null;
-  }
-
-  @Override
-  public SolrParams getParams() {
-    ModifiableSolrParams params = new ModifiableSolrParams();
-    if( fields != null && fields.size() > 0 ) {
-      params.add( CommonParams.FL, fields.toArray( new String[fields.size()] ) );
-    }
-    if( numTerms >= 0 ) {
-      params.add( "numTerms", numTerms+"" );
-    }
-    if (showSchema) {
-    	params.add("show", "schema");
-    }
-    return params;
-  }
-
-  @Override
-  public LukeResponse process( SolrServer server ) throws SolrServerException, IOException 
-  {
-    long startTime = System.currentTimeMillis();
-    LukeResponse res = new LukeResponse();
-    res.setResponse( server.request( this ) );
-    res.setElapsedTime( System.currentTimeMillis()-startTime );
-    return res;
-  }
-}
-
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java
deleted file mode 100644
index 2bbc581..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/QueryRequest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.util.Collection;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class QueryRequest extends SolrRequest
-{
-  private SolrParams query;
-  
-  public QueryRequest()
-  {
-    super( METHOD.GET, null );
-  }
-
-  public QueryRequest( SolrParams q )
-  {
-    super( METHOD.GET, null );
-    query = q;
-  }
-  
-  public QueryRequest( SolrParams q, METHOD method )
-  {
-    super( method, null );
-    query = q;
-  }
-
-  /**
-   * Use the params 'QT' parameter if it exists
-   */
-  @Override
-  public String getPath() {
-    String qt = query.get( CommonParams.QT );
-    if( qt == null ) {
-      qt = super.getPath();
-    }
-    if( qt != null && qt.startsWith( "/" ) ) {
-      return qt;
-    }
-    return "/select";
-  }
-  
-  //---------------------------------------------------------------------------------
-  //---------------------------------------------------------------------------------
-  
-  @Override
-  public Collection<ContentStream> getContentStreams() {
-    return null;
-  }
-
-  @Override
-  public SolrParams getParams() {
-    return query;
-  }
-
-  @Override
-  public QueryResponse process( SolrServer server ) throws SolrServerException 
-  {
-    try 
-    {
-      long startTime = System.currentTimeMillis();
-      QueryResponse res = new QueryResponse( server.request( this ), server );
-      res.setElapsedTime( System.currentTimeMillis()-startTime );
-      return res;
-    } 
-    catch (Exception e) 
-    {
-      throw new SolrServerException("Error executing query", e);
-    }
-  }
-}
-
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/SolrPing.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/SolrPing.java
deleted file mode 100644
index 16c7e17..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/SolrPing.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.response.SolrPingResponse;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.util.ContentStream;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrPing extends SolrRequest
-{
-  private ModifiableSolrParams params;
-  
-  public SolrPing()
-  {
-    super( METHOD.GET, "/admin/ping" );
-    params = new ModifiableSolrParams();
-  }
-
-  @Override
-  public Collection<ContentStream> getContentStreams() {
-    return null;
-  }
-
-  @Override
-  public ModifiableSolrParams getParams() {
-    return params;
-  }
-
-  @Override
-  public SolrPingResponse process( SolrServer server ) throws SolrServerException, IOException 
-  {
-    long startTime = System.currentTimeMillis();
-    SolrPingResponse res = new SolrPingResponse();
-    res.setResponse( server.request( this ) );
-    res.setElapsedTime( System.currentTimeMillis()-startTime );
-    return res;
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/request/UpdateRequest.java b/client/java/solrj/src/org/apache/solr/client/solrj/request/UpdateRequest.java
deleted file mode 100644
index 55599e1..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/request/UpdateRequest.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.request;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.SolrServerException;
-import org.apache.solr.client.solrj.SolrRequest;
-import org.apache.solr.client.solrj.response.UpdateResponse;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.params.ModifiableSolrParams;
-import org.apache.solr.common.params.UpdateParams;
-import org.apache.solr.common.util.ContentStream;
-import org.apache.solr.common.util.XML;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class UpdateRequest extends SolrRequest
-{
-  public enum ACTION {
-    COMMIT,
-    OPTIMIZE
-  };
-  
-  private List<SolrInputDocument> documents = null;
-  private List<String> deleteById = null;
-  private List<String> deleteQuery = null;
-
-  private ModifiableSolrParams params;
-  private int commitWithin = -1;
-  
-  public UpdateRequest()
-  {
-    super( METHOD.POST, "/update" );
-  }
-
-  public UpdateRequest(String url) {
-    super(METHOD.POST, url);
-  }
-
-  //---------------------------------------------------------------------------
-  //---------------------------------------------------------------------------
-  
-  /**
-   * clear the pending documents and delete commands
-   */
-  public void clear()
-  {
-    if( documents != null ) {
-      documents.clear();
-    }
-    if( deleteById != null ) {
-      deleteById.clear();
-    }
-    if( deleteQuery != null ) {
-      deleteQuery.clear();
-    }
-  }
-  
-  //---------------------------------------------------------------------------
-  //---------------------------------------------------------------------------
-  
-  public UpdateRequest add( final SolrInputDocument doc )
-  {
-    if( documents == null ) {
-      documents = new ArrayList<SolrInputDocument>( 2 );
-    }
-    documents.add( doc );
-    return this;
-  }
-  
-  public UpdateRequest add( final Collection<SolrInputDocument> docs )
-  {
-    if( documents == null ) {
-      documents = new ArrayList<SolrInputDocument>( docs.size()+1 );
-    }
-    documents.addAll( docs );
-    return this;
-  }
-  
-  public UpdateRequest deleteById( String id )
-  {
-    if( deleteById == null ) {
-      deleteById = new ArrayList<String>();
-    }
-    deleteById.add( id );
-    return this;
-  }
-  
-  public UpdateRequest deleteByQuery( String q )
-  {
-    if( deleteQuery == null ) {
-      deleteQuery = new ArrayList<String>();
-    }
-    deleteQuery.add( q );
-    return this;
-  }
-
-  /** Sets appropriate parameters for the given ACTION */
-  public UpdateRequest setAction(ACTION action, boolean waitFlush, boolean waitSearcher ) {
-    return setAction(action, waitFlush, waitSearcher, 1);
-  }
-
-  public UpdateRequest setAction(ACTION action, boolean waitFlush, boolean waitSearcher, int maxSegments ) {
-    if (params == null)
-      params = new ModifiableSolrParams();
-
-    if( action == ACTION.OPTIMIZE ) {
-      params.set( UpdateParams.OPTIMIZE, "true" );
-      params.set(UpdateParams.MAX_OPTIMIZE_SEGMENTS, maxSegments);
-    }
-    else if( action == ACTION.COMMIT ) {
-      params.set( UpdateParams.COMMIT, "true" );
-    }
-    params.set( UpdateParams.WAIT_FLUSH, waitFlush+"" );
-    params.set( UpdateParams.WAIT_SEARCHER, waitSearcher+"" );
-    return this;
-  }
-
-  /**
-   * @since Solr 1.4
-   */
-  public UpdateRequest rollback() {
-    if (params == null)
-      params = new ModifiableSolrParams();
-
-    params.set( UpdateParams.ROLLBACK, "true" );
-    return this;
-  }
-  
-
-  public void setParam(String param, String value) {
-    if (params == null)
-      params = new ModifiableSolrParams();
-    params.set(param, value);
-  }
-
-  /** Sets the parameters for this update request, overwriting any previous */
-  public void setParams(ModifiableSolrParams params) {
-    this.params = params;
-  }
-
-  //--------------------------------------------------------------------------
-  //--------------------------------------------------------------------------
-
-  @Override
-  public Collection<ContentStream> getContentStreams() throws IOException {
-    return ClientUtils.toContentStreams( getXML(), ClientUtils.TEXT_XML );
-  }
-  
-  public String getXML() throws IOException {
-    StringWriter writer = new StringWriter();
-    if( documents != null && documents.size() > 0 ) {
-      if( commitWithin > 0 ) {
-        writer.write("<add commitWithin=\""+commitWithin+"\">");
-      }
-      else {
-        writer.write("<add>");
-      }
-      for (SolrInputDocument doc : documents ) {
-        if( doc != null ) {
-          ClientUtils.writeXML( doc, writer );
-        }
-      }
-      writer.write("</add>");
-    }
-    
-    // Add the delete commands
-    boolean deleteI = deleteById != null && deleteById.size() > 0;
-    boolean deleteQ = deleteQuery != null && deleteQuery.size() > 0;
-    if( deleteI || deleteQ ) {
-      writer.append( "<delete>" );
-      if( deleteI ) {
-        for( String id : deleteById ) {
-          writer.append( "<id>" );
-          XML.escapeCharData( id, writer );
-          writer.append( "</id>" );
-        }
-      }
-      if( deleteQ ) {
-        for( String q : deleteQuery ) {
-          writer.append( "<query>" );
-          XML.escapeCharData( q, writer );
-          writer.append( "</query>" );
-        }
-      }
-      writer.append( "</delete>" );
-    }
-    
-    // If action is COMMIT or OPTIMIZE, it is sent with params
-    String xml = writer.toString();
-    //System.out.println( "SEND:"+xml );
-    return (xml.length() > 0) ? xml : null;
-  }
-
-
-  //--------------------------------------------------------------------------
-  //--------------------------------------------------------------------------
-
-  @Override
-  public ModifiableSolrParams getParams() {
-    return params;
-  }
-  
-  @Override
-  public UpdateResponse process( SolrServer server ) throws SolrServerException, IOException
-  {
-    long startTime = System.currentTimeMillis();
-    UpdateResponse res = new UpdateResponse();
-    res.setResponse( server.request( this ) );
-    res.setElapsedTime( System.currentTimeMillis()-startTime );
-    return res;
-  }
-  
-  //--------------------------------------------------------------------------
-  // 
-  //--------------------------------------------------------------------------
-
-  public boolean isWaitFlush() {
-    return params != null && params.getBool(UpdateParams.WAIT_FLUSH, false);
-  }
-
-  public boolean isWaitSearcher() {
-    return params != null && params.getBool(UpdateParams.WAIT_SEARCHER, false);
-  }
-
-  public ACTION getAction() {
-    if (params==null) return null;
-    if (params.getBool(UpdateParams.COMMIT, false)) return ACTION.COMMIT; 
-    if (params.getBool(UpdateParams.OPTIMIZE, false)) return ACTION.OPTIMIZE;
-    return null;
-  }
-
-  public void setWaitFlush(boolean waitFlush) {
-    setParam( UpdateParams.WAIT_FLUSH, waitFlush+"" );
-  }
-
-  public void setWaitSearcher(boolean waitSearcher) {
-    setParam( UpdateParams.WAIT_SEARCHER, waitSearcher+"" );
-  }
-
-  public int getCommitWithin() {
-    return commitWithin;
-  }
-
-  public void setCommitWithin(int commitWithin) {
-    this.commitWithin = commitWithin;
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/CoreAdminResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/CoreAdminResponse.java
deleted file mode 100644
index 7034402..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/CoreAdminResponse.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import java.util.Date;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class CoreAdminResponse extends SolrResponseBase
-{ 
-  @SuppressWarnings("unchecked")
-  public NamedList<NamedList<Object>> getCoreStatus()
-  {
-    return (NamedList<NamedList<Object>>) getResponse().get( "status" );
-  }
-
-  public NamedList<Object> getCoreStatus( String core )
-  {
-    return getCoreStatus().get( core );
-  }
-  
-  public Date getStartTime( String core )
-  {
-    NamedList<Object> v = getCoreStatus( core );
-    if( v == null ) {
-      return null;
-    }
-    return (Date) v.get( "startTime" );
-  }
-  
-  public Long getUptime( String core )
-  {
-    NamedList<Object> v = getCoreStatus( core );
-    if( v == null ) {
-      return null;
-    }
-    return (Long) v.get( "uptime" );
-  }
-}
\ No newline at end of file
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/FacetField.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/FacetField.java
deleted file mode 100644
index bbfaa47..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/FacetField.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-
-import org.apache.solr.client.solrj.util.ClientUtils;
- 
- /**
-  * A utility class to hold the facet response.  It could use the NamedList container,
-  * but for JSTL, it is nice to have something that implements List so it can be iterated
-  * 
-  * @version $Id$
-  * @since solr 1.3
-  */
- public class FacetField implements Serializable
- {
-   public static class Count implements Serializable 
-   {
-     private String _name = null;
-     private long _count = 0;
-     // hang onto the FacetField for breadcrumb creation convenience
-     private FacetField _ff = null;
-     
-     public Count( FacetField ff, String n, long c )
-     {
-       _name = n;
-       _count = c;
-       _ff = ff;
-     }
-     
-     public String getName() {
-       return _name;
-     }
-     
-     public void setName( String n )
-     {
-       _name = n;
-     }
-
-     public long getCount() {
-       return _count;
-     }
-     
-     public void setCount( long c )
-     {
-       _count = c;
-     }
-     
-     public FacetField getFacetField() {
-       return _ff;
-     }
-     
-     @Override
-     public String toString()
-     {
-       return _name+" ("+_count+")";
-     }
-     
-     public String getAsFilterQuery() {
-       if (_ff.getName().equals("facet_queries")) {
-         return _name;
-       }
-       return 
-          ClientUtils.escapeQueryChars( _ff._name ) + ":" + 
-          ClientUtils.escapeQueryChars( _name );
-     }
-   }
-   
-   private String      _name   = null;
-   private List<Count> _values = null;
-   private String _gap = null;
-   private Date _end = null;
-   
-   public FacetField( final String n )
-   {
-     _name = n;
-   }
-   
-   public FacetField(String name, String gap, Date end) {
-     _name = name;
-     _gap = gap;
-     _end = end;
-   }
-   
-   /**
-    * Date Gap Facet parameter
-    * 
-    * @return the value specified for facet.date.gap
-    */
-   public String getGap()   {
-     return _gap;
-   }
-   
-   /**
-    * Date End Facet parameter
-    * 
-    * @return the value specified for facet.date.end
-    */
-   public Date getEnd() {
-     return _end;
-   }
-
-   /**
-    * Insert at the end of the list
-    */
-   public void add( String name, long cnt )
-   {
-     if( _values == null ) {
-       _values = new ArrayList<Count>( 30 );
-     }
-     _values.add( new Count( this, name, cnt ) );
-   }
-
-   /**
-    * Insert at the beginning of the list.
-    */
-   public void insert( String name, long cnt )
-   {
-     if( _values == null ) {
-       _values = new ArrayList<Count>( 30 );
-     }
-     _values.add( 0, new Count( this, name, cnt ) );
-   }
-
-   public String getName() {
-     return _name;
-   }
-
-   public List<Count> getValues() {
-     return _values;
-   }
-   
-   public int getValueCount()
-   {
-     return _values == null ? 0 : _values.size();
-   }
-
-   public FacetField getLimitingFields(long max) 
-   {
-     FacetField ff = new FacetField( _name );
-     if( _values != null ) {
-       ff._values = new ArrayList<Count>( _values.size() );
-       for( Count c : _values ) {
-         if( c._count < max ) { // !equal to
-           ff._values.add( c );
-         }
-       }
-     }
-     return ff;
-   }
-   
-   @Override
-   public String toString()
-   {
-     return _name + ":" + _values;
-   }
- }
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/FieldStatsInfo.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/FieldStatsInfo.java
deleted file mode 100644
index 2516160..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/FieldStatsInfo.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.client.solrj.response;
-
-import org.apache.solr.common.util.NamedList;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Holds stats info
- *
- * @version $Id: SpellCheckResponse.java 693622 2008-09-09 21:21:06Z gsingers $
- * @since solr 1.4
- */
-public class FieldStatsInfo implements Serializable {
-  final String name;
-  
-  Double min;
-  Double max;
-  Double sum;
-  Long count;
-  Long missing;
-  Double mean = null;
-  Double sumOfSquares = null;
-  Double stddev = null;
-  Double median = null;
-  
-  Map<String,List<FieldStatsInfo>> facets;
-  
-  public FieldStatsInfo( NamedList<Object> nl, String fname )
-  {
-    name = fname;
-    
-    for( Map.Entry<String, Object> entry : nl ) {
-      if( "min".equals( entry.getKey() ) ) {
-        min = (Double)entry.getValue();
-      }
-      else if( "max".equals( entry.getKey() ) ) {
-        max = (Double)entry.getValue();
-      }
-      else if( "sum".equals( entry.getKey() ) ) {
-        sum = (Double)entry.getValue();
-      }
-      else if( "count".equals( entry.getKey() ) ) {
-        count = (Long)entry.getValue();
-      }
-      else if( "missing".equals( entry.getKey() ) ) {
-        missing = (Long)entry.getValue();
-      }
-      else if( "mean".equals( entry.getKey() ) ) {
-        mean = (Double)entry.getValue();
-      }
-      else if( "sumOfSquares".equals( entry.getKey() ) ) {
-        sumOfSquares = (Double)entry.getValue();
-      }
-      else if( "stddev".equals( entry.getKey() ) ) {
-        stddev = (Double)entry.getValue();
-      }
-      else if( "median".equals( entry.getKey() ) ) {
-        median = (Double)entry.getValue();
-      }
-      else if( "facets".equals( entry.getKey() ) ) {
-        NamedList<Object> fields = (NamedList<Object>)entry.getValue();
-        facets = new HashMap<String, List<FieldStatsInfo>>();
-        for( Map.Entry<String, Object> ev : fields ) {
-          List<FieldStatsInfo> vals = new ArrayList<FieldStatsInfo>();
-          facets.put( ev.getKey(), vals );
-          NamedList<NamedList<Object>> vnl = (NamedList<NamedList<Object>>) ev.getValue();
-          for( int i=0; i<vnl.size(); i++ ) {
-            String n = vnl.getName(i);
-            vals.add( new FieldStatsInfo( vnl.getVal(i), n ) );
-          }
-        }
-      }
-      else {
-        throw new RuntimeException( "unknown key: "+entry.getKey() + " ["+entry.getValue()+"]" );
-      }
-    }
-  }
-  
-  public String toString()
-  {
-    StringBuilder sb = new StringBuilder();
-    sb.append( name );
-    sb.append( ": {" );
-    if( min != null ) {
-      sb.append( " min:").append( min );
-    }
-    if( max != null ) {
-      sb.append( " max:").append( max );
-    }
-    if( sum != null ) {
-      sb.append( " sum:").append( sum );
-    }
-    if( count != null ) {
-      sb.append( " count:").append( count );
-    }
-    if( missing != null ) {
-      sb.append( " missing:").append( missing );
-    }
-    if( mean != null ) {
-      sb.append( " mean:").append( mean );
-    }
-    if( median != null ) {
-      sb.append( " median:").append(median);
-    }
-    if( stddev != null ) {
-      sb.append( " stddev:").append(stddev);
-    }
-    sb.append( " }" );
-    return sb.toString();
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public Double getMin() {
-    return min;
-  }
-
-  public Double getMax() {
-    return max;
-  }
-
-  public Double getSum() {
-    return sum;
-  }
-
-  public Long getCount() {
-    return count;
-  }
-
-  public Long getMissing() {
-    return missing;
-  }
-
-  public Double getMean() {
-    return mean;
-  }
-
-  public Double getStddev() {
-    return stddev;
-  }
-
-  public Double getMedian() {
-    return median;
-  }
-
-  public Map<String, List<FieldStatsInfo>> getFacets() {
-    return facets;
-  }
-  
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/LukeResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/LukeResponse.java
deleted file mode 100644
index 4e4877c..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/LukeResponse.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import org.apache.solr.common.luke.FieldFlag;
-import org.apache.solr.common.util.NamedList;
-
-import java.io.Serializable;
-import java.util.*;
-
-
-/**
- * This is an incomplete representation of the data returned from Luke
- *
- * @version $Id$
- * @since solr 1.3
- */
-public class LukeResponse extends SolrResponseBase {
-
-  public static class FieldTypeInfo implements Serializable {
-    String name;
-    String className;
-    boolean tokenized;
-    String analyzer;
-    List<String> fields;
-
-
-    public FieldTypeInfo(String name) {
-      this.name = name;
-      fields = Collections.emptyList();
-    }
-
-
-    public String getAnalyzer() {
-      return analyzer;
-    }
-
-    public String getClassName() {
-      return className;
-    }
-
-    public List<String> getFields() {
-      return fields;
-    }
-
-    public String getName() {
-      return name;
-    }
-
-    public boolean isTokenized() {
-      return tokenized;
-    }/*
-     Sample:
-     types={ignored={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f94934},
-     integer={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@3525a2},
-     sfloat={fields=[price, weight],tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@39cf9c},
-     text_ws={fields=[cat],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@6d3ca2)},
-     alphaOnlySort={fields=[alphaNameSort],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.KeywordTokenizerFactory@a7bd3b,
-      org.apache.solr.analysis.LowerCaseFilterFactory@78aae2, org.apache.solr.analysis.TrimFilterFactory@1b16a7,
-      org.apache.solr.analysis.PatternReplaceFilterFactory@6c6b08)},date={fields=[timestamp],tokenized=false,
-      analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@e6e42e},sint={fields=[popularity],
-      tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@8ea21d},
-      boolean={fields=[inStock],tokenized=false,analyzer=org.apache.solr.schema.BoolField$1@354949},
-      textTight={fields=[sku],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@5e88f7,
-       org.apache.solr.analysis.SynonymFilterFactory@723646, org.apache.solr.analysis.StopFilterFactory@492ff1,
-       org.apache.solr.analysis.WordDelimiterFilterFactory@eaabad, org.apache.solr.analysis.LowerCaseFilterFactory@ad1355,
-        org.apache.solr.analysis.EnglishPorterFilterFactory@d03a00, org.apache.solr.analysis.RemoveDuplicatesTokenFilterFactory@900079)},
-        long={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f3b83},
-        double={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@c2b07},
-
-      */
-
-    @SuppressWarnings("unchecked")
-    public void read(NamedList<Object> nl) {
-      for (Map.Entry<String, Object> entry : nl) {
-        String key = entry.getKey();
-        if ("fields".equals(key) && entry.getValue() != null) {
-          List<String> theFields = (List<String>) entry.getValue();
-          fields = new ArrayList<String>(theFields);
-        } else if ("tokenized".equals(key) == true) {
-          tokenized = Boolean.parseBoolean(entry.getValue().toString());
-        } else if ("analyzer".equals(key) == true) {
-          analyzer = entry.getValue().toString();
-        } else if ("className".equals(key) == true) {
-          className = entry.getValue().toString();
-        }
-      }
-    }
-  }
-
-  public static class FieldInfo implements Serializable {
-    String name;
-    String type;
-    String schema;
-    int docs;
-    int distinct;
-    EnumSet<FieldFlag> flags;
-    boolean cacheableFaceting;
-    NamedList<Integer> topTerms;
-
-    public FieldInfo(String n) {
-      name = n;
-    }
-
-    @SuppressWarnings("unchecked")
-    public void read(NamedList<Object> nl) {
-      for (Map.Entry<String, Object> entry : nl) {
-        if ("type".equals(entry.getKey())) {
-          type = (String) entry.getValue();
-        }
-        if ("flags".equals(entry.getKey())) {
-          flags = parseFlags((String) entry.getValue());
-        } else if ("schema".equals(entry.getKey())) {
-          schema = (String) entry.getValue();
-        } else if ("docs".equals(entry.getKey())) {
-          docs = (Integer) entry.getValue();
-        } else if ("distinct".equals(entry.getKey())) {
-          distinct = (Integer) entry.getValue();
-        } else if ("cacheableFaceting".equals(entry.getKey())) {
-          cacheableFaceting = (Boolean) entry.getValue();
-        } else if ("topTerms".equals(entry.getKey())) {
-          topTerms = (NamedList<Integer>) entry.getValue();
-        }
-      }
-    }
-
-    public static EnumSet<FieldFlag> parseFlags(String flagStr) {
-      EnumSet<FieldFlag> result = EnumSet.noneOf(FieldFlag.class);
-      char[] chars = flagStr.toCharArray();
-      for (int i = 0; i < chars.length; i++) {
-        if (chars[i] != '-') {
-          FieldFlag flag = FieldFlag.getFlag(chars[i]);
-          result.add(flag);
-        }
-      }
-      return result;
-    }
-
-    public EnumSet<FieldFlag> getFlags() {
-      return flags;
-    }
-
-    public boolean isCacheableFaceting() {
-      return cacheableFaceting;
-    }
-
-    public String getType() {
-      return type;
-    }
-
-    public int getDistinct() {
-      return distinct;
-    }
-
-    public int getDocs() {
-      return docs;
-    }
-
-    public String getName() {
-      return name;
-    }
-
-    public String getSchema() {
-      return schema;
-    }
-
-    public NamedList<Integer> getTopTerms() {
-      return topTerms;
-    }
-  }
-
-  private NamedList<Object> indexInfo;
-  private Map<String, FieldInfo> fieldInfo;
-  private Map<String, FieldTypeInfo> fieldTypeInfo;
-
-  @Override
-  @SuppressWarnings("unchecked")
-  public void setResponse(NamedList<Object> res) {
-    super.setResponse(res);
-
-    // Parse indexinfo
-    indexInfo = (NamedList<Object>) res.get("index");
-
-    NamedList<Object> schema = (NamedList<Object>) res.get("schema");
-    NamedList<Object> flds = (NamedList<Object>) res.get("fields");
-    if (flds == null && schema != null ) {
-      flds = (NamedList<Object>) schema.get("fields");
-    }
-    if (flds != null) {
-      fieldInfo = new HashMap<String, FieldInfo>();
-      for (Map.Entry<String, Object> field : flds) {
-        FieldInfo f = new FieldInfo(field.getKey());
-        f.read((NamedList<Object>) field.getValue());
-        fieldInfo.put(field.getKey(), f);
-      }
-    }
-
-    if( schema != null ) {
-      NamedList<Object> fldTypes = (NamedList<Object>) schema.get("types");
-      if (fldTypes != null) {
-        fieldTypeInfo = new HashMap<String, FieldTypeInfo>();
-        for (Map.Entry<String, Object> fieldType : fldTypes) {
-          FieldTypeInfo ft = new FieldTypeInfo(fieldType.getKey());
-          ft.read((NamedList<Object>) fieldType.getValue());
-          fieldTypeInfo.put(fieldType.getKey(), ft);
-        }
-      }
-    }
-  }
-
-  //----------------------------------------------------------------
-  //----------------------------------------------------------------
-
-  public String getIndexDirectory() {
-    if (indexInfo == null) return null;
-    return (String) indexInfo.get("directory");
-  }
-
-  public Integer getNumDocs() {
-    if (indexInfo == null) return null;
-    return (Integer) indexInfo.get("numDocs");
-  }
-
-  public Integer getMaxDoc() {
-    if (indexInfo == null) return null;
-    return (Integer) indexInfo.get("maxDoc");
-  }
-
-  public Integer getNumTerms() {
-    if (indexInfo == null) return null;
-    return (Integer) indexInfo.get("numTerms");
-  }
-
-  public Map<String, FieldTypeInfo> getFieldTypeInfo() {
-    return fieldTypeInfo;
-  }
-
-  public FieldTypeInfo getFieldTypeInfo(String name) {
-    return fieldTypeInfo.get(name);
-  }
-
-  public NamedList<Object> getIndexInfo() {
-    return indexInfo;
-  }
-
-  public Map<String, FieldInfo> getFieldInfo() {
-    return fieldInfo;
-  }
-
-  public FieldInfo getFieldInfo(String f) {
-    return fieldInfo.get(f);
-  }
-
-  //----------------------------------------------------------------
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/QueryResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/QueryResponse.java
deleted file mode 100644
index 25a6ff5..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/QueryResponse.java
+++ /dev/null
@@ -1,320 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-@SuppressWarnings("unchecked")
-public class QueryResponse extends SolrResponseBase 
-{
-  // Direct pointers to known types
-  private NamedList<Object> _header = null;
-  private SolrDocumentList _results = null;
-  private NamedList<ArrayList> _sortvalues = null;
-  private NamedList<Object> _facetInfo = null;
-  private NamedList<Object> _debugInfo = null;
-  private NamedList<Object> _highlightingInfo = null;
-  private NamedList<Object> _spellInfo = null;
-  private NamedList<Object> _statsInfo = null;
-
-  // Facet stuff
-  private Map<String,Integer> _facetQuery = null;
-  private List<FacetField> _facetFields = null;
-  private List<FacetField> _limitingFacets = null;
-  private List<FacetField> _facetDates = null;
-
-  // Highlight Info
-  private Map<String,Map<String,List<String>>> _highlighting = null;
-
-  // SpellCheck Response
-  private SpellCheckResponse _spellResponse = null;
-
-  // Field stats Response
-  private Map<String,FieldStatsInfo> _fieldStatsInfo = null;
-  
-  // Debug Info
-  private Map<String,Object> _debugMap = null;
-  private Map<String,String> _explainMap = null;
-
-  // utility variable used for automatic binding -- it should not be serialized
-  private transient final SolrServer solrServer;
-  
-  public QueryResponse(){
-    solrServer = null;
-  }
-  
-  /**
-   * Utility constructor to set the solrServer and namedList
-   */
-  public QueryResponse( NamedList<Object> res , SolrServer solrServer){
-    this.setResponse( res );
-    this.solrServer = solrServer;
-  }
-
-  @Override
-  public void setResponse( NamedList<Object> res )
-  {
-    super.setResponse( res );
-    
-    // Look for known things
-    for( int i=0; i<res.size(); i++ ) {
-      String n = res.getName( i );
-      if( "responseHeader".equals( n ) ) {
-        _header = (NamedList<Object>) res.getVal( i );
-      }
-      else if( "response".equals( n ) ) {
-        _results = (SolrDocumentList) res.getVal( i );
-      }
-      else if( "sort_values".equals( n ) ) {
-        _sortvalues = (NamedList<ArrayList>) res.getVal( i );
-      }
-      else if( "facet_counts".equals( n ) ) {
-        _facetInfo = (NamedList<Object>) res.getVal( i );
-        extractFacetInfo( _facetInfo );
-      }
-      else if( "debug".equals( n ) ) {
-        _debugInfo = (NamedList<Object>) res.getVal( i );
-        extractDebugInfo( _debugInfo );
-      }
-      else if( "highlighting".equals( n ) ) {
-        _highlightingInfo = (NamedList<Object>) res.getVal( i );
-        extractHighlightingInfo( _highlightingInfo );
-      }
-      else if ( "spellcheck".equals( n ) )  {
-        _spellInfo = (NamedList<Object>) res.getVal( i );
-        extractSpellCheckInfo( _spellInfo );
-      }
-      else if ( "stats".equals( n ) )  {
-        _statsInfo = (NamedList<Object>) res.getVal( i );
-        extractStatsInfo( _statsInfo );
-      }
-    }
-  }
-
-  private void extractSpellCheckInfo(NamedList<Object> spellInfo) {
-    _spellResponse = new SpellCheckResponse(spellInfo);
-  }
-
-  private void extractStatsInfo(NamedList<Object> info) {
-    if( info != null ) {
-      _fieldStatsInfo = new HashMap<String, FieldStatsInfo>();
-      NamedList<NamedList<Object>> ff = (NamedList<NamedList<Object>>) info.get( "stats_fields" );
-      if( ff != null ) {
-        for( Map.Entry<String,NamedList<Object>> entry : ff ) {
-          _fieldStatsInfo.put( entry.getKey(), 
-              new FieldStatsInfo( entry.getValue(), entry.getKey() ) );
-        }
-      }
-    }
-  }
-
-  private void extractDebugInfo( NamedList<Object> debug )
-  {
-    _debugMap = new LinkedHashMap<String, Object>(); // keep the order
-    for( Map.Entry<String, Object> info : debug ) {
-      _debugMap.put( info.getKey(), info.getValue() );
-    }
-
-    // Parse out interesting bits from the debug info
-    _explainMap = new HashMap<String, String>();
-    NamedList<String> explain = (NamedList<String>)_debugMap.get( "explain" );
-    if( explain != null ) {
-      for( Map.Entry<String, String> info : explain ) {
-        String key = info.getKey();
-        _explainMap.put( key, info.getValue() );
-      }
-    }
-  }
-
-  private void extractHighlightingInfo( NamedList<Object> info )
-  {
-    _highlighting = new HashMap<String,Map<String,List<String>>>();
-    for( Map.Entry<String, Object> doc : info ) {
-      Map<String,List<String>> fieldMap = new HashMap<String, List<String>>();
-      _highlighting.put( doc.getKey(), fieldMap );
-      
-      NamedList<List<String>> fnl = (NamedList<List<String>>)doc.getValue();
-      for( Map.Entry<String, List<String>> field : fnl ) {
-        fieldMap.put( field.getKey(), field.getValue() );
-      }
-    }
-  }
-
-  private void extractFacetInfo( NamedList<Object> info )
-  {
-    // Parse the queries
-    _facetQuery = new HashMap<String, Integer>();
-    NamedList<Integer> fq = (NamedList<Integer>) info.get( "facet_queries" );
-    for( Map.Entry<String, Integer> entry : fq ) {
-      _facetQuery.put( entry.getKey(), entry.getValue() );
-    }
-    
-    // Parse the facet info into fields
-    // TODO?? The list could be <int> or <long>?  If always <long> then we can switch to <Long>
-    NamedList<NamedList<Number>> ff = (NamedList<NamedList<Number>>) info.get( "facet_fields" );
-    if( ff != null ) {
-      _facetFields = new ArrayList<FacetField>( ff.size() );
-      _limitingFacets = new ArrayList<FacetField>( ff.size() );
-      
-      long minsize = _results.getNumFound();
-      for( Map.Entry<String,NamedList<Number>> facet : ff ) {
-        FacetField f = new FacetField( facet.getKey() );
-        for( Map.Entry<String, Number> entry : facet.getValue() ) {
-          f.add( entry.getKey(), entry.getValue().longValue() );
-        }
-        
-        _facetFields.add( f );
-        FacetField nl = f.getLimitingFields( minsize );
-        if( nl.getValueCount() > 0 ) {
-          _limitingFacets.add( nl );
-        }
-      }
-    }
-    
-    //Parse date facets
-    NamedList<NamedList<Object>> df = (NamedList<NamedList<Object>>) info.get("facet_dates");
-    if (df != null) {
-      // System.out.println(df);
-      _facetDates = new ArrayList<FacetField>( df.size() );
-      for (Map.Entry<String, NamedList<Object>> facet : df) {
-        // System.out.println("Key: " + facet.getKey() + " Value: " + facet.getValue());
-        NamedList<Object> values = facet.getValue();
-        String gap = (String) values.get("gap");
-        Date end = (Date) values.get("end");
-        FacetField f = new FacetField(facet.getKey(), gap, end);
-        
-        for (Map.Entry<String, Object> entry : values)   {
-          try {
-            f.add(entry.getKey(), Long.parseLong(entry.getValue().toString()));
-          } catch (NumberFormatException e) {
-            //Ignore for non-number responses which are already handled above
-          }
-        }
-        
-        _facetDates.add(f);
-      }
-    }
-  }
-
-  //------------------------------------------------------
-  //------------------------------------------------------
-
-  /**
-   * Remove the field facet info
-   */
-  public void removeFacets() {
-    _facetFields = new ArrayList<FacetField>();
-  }
-  
-  //------------------------------------------------------
-  //------------------------------------------------------
-
-  public NamedList<Object> getHeader() {
-    return _header;
-  }
-
-  public SolrDocumentList getResults() {
-    return _results;
-  }
- 
-  public NamedList<ArrayList> getSortValues(){
-    return _sortvalues;
-  }
-
-  public Map<String, Object> getDebugMap() {
-    return _debugMap;
-  }
-
-  public Map<String, String> getExplainMap() {
-    return _explainMap;
-  }
-
-  public Map<String,Integer> getFacetQuery() {
-    return _facetQuery;
-  }
-
-  public Map<String, Map<String, List<String>>> getHighlighting() {
-    return _highlighting;
-  }
-
-  public SpellCheckResponse getSpellCheckResponse() {
-    return _spellResponse;
-  }
-
-  public List<FacetField> getFacetFields() {
-    return _facetFields;
-  }
-  
-  public List<FacetField> getFacetDates()   {
-    return _facetDates;
-  }
-  
-  /** get 
-   * 
-   * @param name the name of the 
-   * @return the FacetField by name or null if it does not exist
-   */
-  public FacetField getFacetField(String name) {
-    if (_facetFields==null) return null;
-    for (FacetField f : _facetFields) {
-      if (f.getName().equals(name)) return f;
-    }
-    return null;
-  }
-  
-  public FacetField getFacetDate(String name)   {
-    if (_facetDates == null)
-      return null;
-    for (FacetField f : _facetDates)
-      if (f.getName().equals(name))
-        return f;
-    return null;
-  }
-  
-  public List<FacetField> getLimitingFacets() {
-    return _limitingFacets;
-  }
-  
-  public <T> List<T> getBeans(Class<T> type){
-    return solrServer == null ? 
-      new DocumentObjectBinder().getBeans(type,_results):
-      solrServer.getBinder().getBeans(type, _results);
-  }
-
-  public Map<String, FieldStatsInfo> getFieldStatsInfo() {
-    return _fieldStatsInfo;
-  }
-}
-
-
-
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrPingResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrPingResponse.java
deleted file mode 100644
index 44d3785..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrPingResponse.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import org.apache.solr.common.util.NamedList;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrPingResponse extends SolrResponseBase
-{
-  // nothing special now...
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrResponseBase.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrResponseBase.java
deleted file mode 100644
index ed0908f..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/SolrResponseBase.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import org.apache.solr.client.solrj.SolrResponse;
-import org.apache.solr.common.util.NamedList;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrResponseBase extends SolrResponse
-{
-  private long elapsedTime = -1;
-  private NamedList<Object> response = null;
-  private String requestUrl = null;
-  
-  @Override
-  public long getElapsedTime() {
-    return elapsedTime;
-  }
-
-  public void setElapsedTime(long elapsedTime) {
-    this.elapsedTime = elapsedTime;
-  }
-
-  @Override
-  public NamedList<Object> getResponse() {
-    return response;
-  }
-
-  @Override
-  public void setResponse(NamedList<Object> response) {
-    this.response = response;
-  }
-
-  @Override
-  public String toString() {
-    return response.toString();
-  }
-  
-  public NamedList getResponseHeader() {
-    return (NamedList) response.get("responseHeader");
-  }
-  
-  // these two methods are based on the logic in SolrCore.setResponseHeaderValues(...)
-  public int getStatus() {
-    NamedList header = getResponseHeader();
-    if (header != null) {
-        return (Integer) header.get("status");
-    }
-    else {
-        return 0;
-    }
-  }
-  
-  public int getQTime() {
-    NamedList header = getResponseHeader();
-    if (header != null) {
-        return (Integer) header.get("QTime");
-    }
-    else {
-        return 0;
-    }
-  }
-
-  public String getRequestUrl() {
-    return requestUrl;
-  }
-
-  public void setRequestUrl(String requestUrl) {
-    this.requestUrl = requestUrl;
-  }
-  
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/SpellCheckResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/SpellCheckResponse.java
deleted file mode 100644
index b69005d..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/SpellCheckResponse.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package org.apache.solr.client.solrj.response;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Encapsulates responses from SpellCheckComponent
- *
- * @version $Id$
- * @since solr 1.3
- */
-public class SpellCheckResponse {
-  private boolean correctlySpelled;
-  private String collation;
-  private List<Suggestion> suggestions = new ArrayList<Suggestion>();
-  Map<String, Suggestion> suggestionMap = new LinkedHashMap<String, Suggestion>();
-
-  public SpellCheckResponse(NamedList<Object> spellInfo) {
-    NamedList<Object> sugg = (NamedList<Object>) spellInfo.get("suggestions");
-    if (sugg == null) {
-      correctlySpelled = true;
-      return;
-    }
-    for (int i = 0; i < sugg.size(); i++) {
-      String n = sugg.getName(i);
-      if ("correctlySpelled".equals(n)) {
-        correctlySpelled = (Boolean) sugg.getVal(i);
-      } else if ("collation".equals(n)) {
-        collation = (String) sugg.getVal(i);
-      } else {
-        Suggestion s = new Suggestion(n, (NamedList<Object>) sugg.getVal(i));
-        suggestionMap.put(n, s);
-        suggestions.add(s);
-      }
-    }
-  }
-
-  public boolean isCorrectlySpelled() {
-    return correctlySpelled;
-  }
-
-  public List<Suggestion> getSuggestions() {
-    return suggestions;
-  }
-
-  public Map<String, Suggestion> getSuggestionMap() {
-    return suggestionMap;
-  }
-
-  public Suggestion getSuggestion(String token) {
-    return suggestionMap.get(token);
-  }
-
-  public String getFirstSuggestion(String token) {
-    Suggestion s = suggestionMap.get(token);
-    if (s != null) {
-      return s.getSuggestions().isEmpty() ? null : s.getSuggestions().get(0);
-    }
-    return null;
-  }
-
-  public String getCollatedResult() {
-    return collation;
-  }
-
-  public static class Suggestion {
-    private String token;
-    private int numFound;
-    private int startOffset;
-    private int endOffset;
-    private int originalFrequency;
-    private List<String> suggestions = new ArrayList<String>();
-    private List<Integer> suggestionFrequencies = new ArrayList<Integer>();
-
-    public Suggestion(String token, NamedList<Object> suggestion) {
-      this.token = token;
-      for (int i = 0; i < suggestion.size(); i++) {
-        String n = suggestion.getName(i);
-
-        if ("numFound".equals(n)) {
-          numFound = (Integer) suggestion.getVal(i);
-        } else if ("startOffset".equals(n)) {
-          startOffset = (Integer) suggestion.getVal(i);
-        } else if ("endOffset".equals(n)) {
-          endOffset = (Integer) suggestion.getVal(i);
-        } else if ("origFreq".equals(n)) {
-          originalFrequency = (Integer) suggestion.getVal(i);
-        } else if ("suggestion".equals(n)) {
-          Object o = suggestion.getVal(i);
-          if (o instanceof List) {
-            List<String> list = (List<String>) o;
-            suggestions.addAll(list);
-          } else if (o instanceof SimpleOrderedMap) {
-            SimpleOrderedMap map = (SimpleOrderedMap) o;
-            suggestions.add((String) map.get("word"));
-            suggestionFrequencies.add((Integer) map.get("frequency"));
-          }
-        }
-      }
-    }
-
-    public String getToken() {
-      return token;
-    }
-
-    public int getNumFound() {
-      return numFound;
-    }
-
-    public int getStartOffset() {
-      return startOffset;
-    }
-
-    public int getEndOffset() {
-      return endOffset;
-    }
-
-    public int getOriginalFrequency() {
-      return originalFrequency;
-    }
-
-    public List<String> getSuggestions() {
-      return suggestions;
-    }
-
-    public List<Integer> getSuggestionFrequencies() {
-      return suggestionFrequencies;
-    }
-  }
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/response/UpdateResponse.java b/client/java/solrj/src/org/apache/solr/client/solrj/response/UpdateResponse.java
deleted file mode 100644
index d4dc756..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/response/UpdateResponse.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import org.apache.solr.common.util.NamedList;
-
-
-/**
- * TODO -- mostly a stub until we have a defined output format
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class UpdateResponse extends SolrResponseBase
-{
-  // nothing special now...
-}
diff --git a/client/java/solrj/src/org/apache/solr/client/solrj/util/ClientUtils.java b/client/java/solrj/src/org/apache/solr/client/solrj/util/ClientUtils.java
deleted file mode 100644
index 5785738..0000000
--- a/client/java/solrj/src/org/apache/solr/client/solrj/util/ClientUtils.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.util;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.net.URLEncoder;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.TimeZone;
-
-import org.apache.commons.httpclient.util.DateParseException;
-
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.params.SolrParams;
-import org.apache.solr.common.util.ContentStream;
-import org.apache.solr.common.util.ContentStreamBase;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.common.util.DateUtil;
-
-
-/**
- * TODO? should this go in common?
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class ClientUtils 
-{
-  // Standard Content types
-  public static final String TEXT_XML = "text/xml; charset=utf-8";  
-  
-  /**
-   * Take a string and make it an iterable ContentStream
-   */
-  public static Collection<ContentStream> toContentStreams( final String str, final String contentType )
-  {
-    if( str == null )
-      return null;
-
-    ArrayList<ContentStream> streams = new ArrayList<ContentStream>( 1 );
-    ContentStreamBase ccc = new ContentStreamBase.StringStream( str );
-    ccc.setContentType( contentType );
-    streams.add( ccc );
-    return streams;
-  }
-
-  /**
-   * @param d SolrDocument to convert
-   * @return a SolrInputDocument with the same fields and values as the
-   *   SolrDocument.  All boosts are 1.0f
-   */
-  public static SolrInputDocument toSolrInputDocument( SolrDocument d )
-  {
-    SolrInputDocument doc = new SolrInputDocument();
-    for( String name : d.getFieldNames() ) {
-      doc.addField( name, d.getFieldValue(name), 1.0f );
-    }
-    return doc;
-  }
-
-  /**
-   * @param d SolrInputDocument to convert
-   * @return a SolrDocument with the same fields and values as the SolrInputDocument
-   */
-  public static SolrDocument toSolrDocument( SolrInputDocument d )
-  {
-    SolrDocument doc = new SolrDocument();
-    for( SolrInputField field : d ) {
-      doc.setField( field.getName(), field.getValue() );
-    }
-    return doc;
-  }
-
-  //------------------------------------------------------------------------
-  //------------------------------------------------------------------------
-
-  public static void writeXML( SolrInputDocument doc, Writer writer ) throws IOException
-  {
-    writer.write("<doc boost=\""+doc.getDocumentBoost()+"\">");
-
-    for( SolrInputField field : doc ) {
-      float boost = field.getBoost();
-      String name = field.getName();
-      for( Object v : field ) {
-        if (v instanceof Date) {
-          v = DateUtil.getThreadLocalDateFormat().format( (Date)v );
-        }
-        if( boost != 1.0f ) {
-          XML.writeXML(writer, "field", v.toString(), "name", name, "boost", boost );
-        }
-        else {
-          XML.writeXML(writer, "field", v.toString(), "name", name );
-        }
-
-        // only write the boost for the first multi-valued field
-        // otherwise, the used boost is the product of all the boost values
-        boost = 1.0f;
-      }
-    }
-    writer.write("</doc>");
-  }
-
-
-  public static String toXML( SolrInputDocument doc )
-  {
-    StringWriter str = new StringWriter();
-    try {
-      writeXML( doc, str );
-    }
-    catch( Exception ex ){}
-    return str.toString();
-  }
-
-  //---------------------------------------------------------------------------------------
-
-  /**
-   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#DEFAULT_DATE_FORMATS}
-   */
-  public static final Collection<String> fmts = DateUtil.DEFAULT_DATE_FORMATS;
-
-  /**
-   * Returns a formatter that can be use by the current thread if needed to
-   * convert Date objects to the Internal representation.
-   * @throws ParseException
-   * @throws DateParseException
-   *
-   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#parseDate(String)}
-   */
-  public static Date parseDate( String d ) throws ParseException, DateParseException
-  {
-    return DateUtil.parseDate(d);
-  }
-
-  /**
-   * Returns a formatter that can be use by the current thread if needed to
-   * convert Date objects to the Internal representation.
-   *
-   * @deprecated use {@link org.apache.solr.common.util.DateUtil#getThreadLocalDateFormat()}
-   */
-  public static DateFormat getThreadLocalDateFormat() {
-
-    return DateUtil.getThreadLocalDateFormat();
-  }
-
-  /**
-   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#UTC}.
-   */
-  public static TimeZone UTC = DateUtil.UTC;
-
-
-
-  /**
-   * See: http://lucene.apache.org/java/docs/queryparsersyntax.html#Escaping Special Characters
-   */
-  public static String escapeQueryChars(String s) {
-    StringBuffer sb = new StringBuffer();
-    for (int i = 0; i < s.length(); i++) {
-      char c = s.charAt(i);
-      // These characters are part of the query syntax and must be escaped
-      if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':'
-        || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~'
-        || c == '*' || c == '?' || c == '|' || c == '&'
-        || Character.isWhitespace(c)) {
-        sb.append('\\');
-      }
-      sb.append(c);
-    }
-    return sb.toString();
-  }
-
-  public static String toQueryString( SolrParams params, boolean xml ) {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      String amp = xml ? "&amp;" : "&";
-      boolean first=true;
-      Iterator<String> names = params.getParameterNamesIterator();
-      while( names.hasNext() ) {
-        String key = names.next();
-        String[] valarr = params.getParams( key );
-        if( valarr == null ) {
-          sb.append( first?"?":amp );
-          sb.append(key);
-          first=false;
-        }
-        else {
-          for (String val : valarr) {
-            sb.append( first? "?":amp );
-            sb.append(key);
-            if( val != null ) {
-              sb.append('=');
-              sb.append( URLEncoder.encode( val, "UTF-8" ) );
-            }
-            first=false;
-          }
-        }
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-    return sb.toString();
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java b/client/java/solrj/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java
deleted file mode 100644
index b9dd2cf..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.client.solrj.response.UpdateResponse;
-import org.apache.solr.common.SolrInputDocument;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class LargeVolumeTestBase extends SolrExampleTestBase 
-{
-  SolrServer gserver = null;
-  
-  // for real load testing, make these numbers bigger
-  static final int numdocs = 100; //1000 * 1000;
-  static final int threadCount = 5;
-  
-  public void testMultiThreaded() throws Exception {
-    gserver = this.getSolrServer();
-    gserver.deleteByQuery( "*:*" ); // delete everything!
-    
-    DocThread[] threads = new DocThread[threadCount];
-    for (int i=0; i<threadCount; i++) {
-      threads[i] = new DocThread( "T"+i+":" );
-      threads[i].setName("DocThread-" + i);
-      threads[i].start();
-      System.out.println("Started thread: " + i);
-    }
-    for (int i=0; i<threadCount; i++) {
-      threads[i].join();
-    }
-    
-    query(threadCount * numdocs);
-    System.out.println("done");
-  }
-
-  private void query(int count) throws SolrServerException, IOException {
-    SolrQuery query = new SolrQuery("*:*");
-    QueryResponse response = gserver.query(query);
-    assertEquals(0, response.getStatus());
-    assertEquals(count, response.getResults().getNumFound());
-  }
-
-  public class DocThread extends Thread {
-    
-    final SolrServer tserver;
-    final String name;
-    
-    public DocThread( String name )
-    {
-      tserver = createNewSolrServer();
-      this.name = name;
-    }
-    
-    @Override
-    public void run() {
-      try {
-        UpdateResponse resp = null;
-        List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
-        for (int i = 0; i < numdocs; i++) {
-          if (i > 0 && i % 200 == 0) {
-            resp = tserver.add(docs);
-            assertEquals(0, resp.getStatus());
-            docs = new ArrayList<SolrInputDocument>();
-          }
-          if (i > 0 && i % 5000 == 0) {
-            System.out.println(getName() + " - Committing " + i);
-            resp = tserver.commit();
-            assertEquals(0, resp.getStatus());
-          }
-          SolrInputDocument doc = new SolrInputDocument();
-          doc.addField("id", name+i );
-          doc.addField("cat", "foocat");
-          docs.add(doc);
-        }
-        resp = tserver.add(docs);
-        assertEquals(0, resp.getStatus());
-        resp = tserver.commit();
-        assertEquals(0, resp.getStatus());
-        resp = tserver.optimize();
-        assertEquals(0, resp.getStatus());
-
-      } catch (Exception e) {
-        e.printStackTrace();
-        fail( getName() + "---" + e.getMessage() );
-      }
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java b/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
deleted file mode 100644
index a8f22a2..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.io.File;
-
-import org.apache.solr.client.solrj.request.CoreAdminRequest;
-import org.apache.solr.client.solrj.request.QueryRequest;
-import org.apache.solr.client.solrj.request.UpdateRequest;
-import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
-import org.apache.solr.client.solrj.response.CoreAdminResponse;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.core.CoreContainer;
-import org.apache.solr.core.SolrCore;
-
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public abstract class MultiCoreExampleTestBase extends SolrExampleTestBase 
-{
-  // protected static final CoreContainer cores = new CoreContainer();
-  protected static CoreContainer cores;
-
-  @Override public String getSolrHome() { return "../../../example/multicore/"; }
-  
-  @Override public String getSchemaFile()     { return getSolrHome()+"core0/conf/schema.xml";     }
-  @Override public String getSolrConfigFile() { return getSolrHome()+"core0/conf/solrconfig.xml"; }
-  
-  @Override public void setUp() throws Exception {
-    super.setUp();
-    cores = h.getCoreContainer();
-    SolrCore.log.info("CORES=" + cores + " : " + cores.getCoreNames());
-    cores.setPersistent(false);
-  }
-
-  @Override
-  protected final SolrServer getSolrServer()
-  {
-    throw new UnsupportedOperationException();
-  }
-  
-  @Override
-  protected final SolrServer createNewSolrServer()
-  {
-    throw new UnsupportedOperationException();
-  }
-
-  protected abstract SolrServer getSolrCore0();
-  protected abstract SolrServer getSolrCore1();
-  protected abstract SolrServer getSolrAdmin();
-  protected abstract SolrServer getSolrCore(String name);
-  
-
-  public void testMultiCore() throws Exception
-  {
-    UpdateRequest up = new UpdateRequest();
-    up.setAction( ACTION.COMMIT, true, true );
-    up.deleteByQuery( "*:*" );
-    up.process( getSolrCore0() );
-    up.process( getSolrCore1() );
-    up.clear();
-    
-    // Add something to each core
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setField( "id", "AAA" );
-    doc.setField( "core0", "yup" );
-   
-    // Add to core0
-    up.add( doc );
-    up.process( getSolrCore0() );
-
-    // You can't add it to core1
-    try {
-      up.process( getSolrCore1() );
-      fail( "Can't add core0 field to core1!" );
-    }
-    catch( Exception ex ) {}
-
-    // Add to core1
-    doc.setField( "id", "BBB" );
-    doc.setField( "core1", "yup" );
-    doc.removeField( "core0" );
-    up.add( doc );
-    up.process( getSolrCore1() );
-
-    // You can't add it to core1
-    try {
-      up.process( getSolrCore0() );
-      fail( "Can't add core1 field to core0!" );
-    }
-    catch( Exception ex ) {}
-    
-    // now Make sure AAA is in 0 and BBB in 1
-    SolrQuery q = new SolrQuery();
-    QueryRequest r = new QueryRequest( q );
-    q.setQuery( "id:AAA" );
-    assertEquals( 1, r.process( getSolrCore0() ).getResults().size() );
-    assertEquals( 0, r.process( getSolrCore1() ).getResults().size() );
-    
-    // Now test Changing the default core
-    assertEquals( 1, getSolrCore0().query( new SolrQuery( "id:AAA" ) ).getResults().size() );
-    assertEquals( 0, getSolrCore0().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-
-    assertEquals( 0, getSolrCore1().query( new SolrQuery( "id:AAA" ) ).getResults().size() );
-    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-
-    // Now test reloading it should have a newer open time
-    String name = "core0";
-    SolrServer coreadmin = getSolrAdmin();
-    CoreAdminResponse mcr = CoreAdminRequest.getStatus( name, coreadmin );
-    long before = mcr.getStartTime( name ).getTime();
-    CoreAdminRequest.reloadCore( name, coreadmin );
-    
-    mcr = CoreAdminRequest.getStatus( name, coreadmin );
-    long after = mcr.getStartTime( name ).getTime();
-    assertTrue( "should have more recent time: "+after+","+before, after > before );
-
-    // test alias
-    CoreAdminRequest.aliasCore("core1","corefoo",coreadmin);
-    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-    assertEquals( 1, getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-
-    // test that reload affects aliases
-    CoreAdminRequest.reloadCore("core1", coreadmin);
-
-    // this is only an effective test for embedded, where we have
-    // direct access to the core container.
-    SolrCore c1 = cores.getCore("core1");
-    SolrCore c2 = cores.getCore("corefoo");
-    assertTrue(c1 == c2);
-    if (c1 != null) c1.close();
-    if (c2 != null) c2.close();
-
-    // retest core query
-    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-
-    // test close
-    CoreAdminRequest.unloadCore("corefoo",coreadmin);
-    try {
-      getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) );
-      fail( "corefoo should be gone" );
-    }
-    catch( Exception ex ) {}
-    // aliased core should still work
-    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-    
-    // test move
-    CoreAdminRequest.renameCore("core1","corea",coreadmin);
-    CoreAdminRequest.renameCore("corea","coreb",coreadmin);
-    CoreAdminRequest.renameCore("coreb","corec",coreadmin);
-    CoreAdminRequest.renameCore("corec","cored",coreadmin);
-    CoreAdminRequest.renameCore("cored","corefoo",coreadmin);
-    try {
-      getSolrCore("core1").query( new SolrQuery( "id:BBB" ) );
-      fail( "core1 should be gone" );
-    }
-    catch( Exception ex ) {}
-    assertEquals( 1, getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) ).getResults().size() );
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTestBase.java b/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTestBase.java
deleted file mode 100644
index f2717ad..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTestBase.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-
-import org.apache.solr.util.AbstractSolrTestCase;
-
-/**
- * This should include tests against the example solr config
- * 
- * This lets us try various SolrServer implementations with the same tests.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-abstract public class SolrExampleTestBase extends AbstractSolrTestCase 
-{
-  public String getSolrHome() { return "../../../example/solr/"; }
-  
-  @Override public String getSchemaFile()     { return getSolrHome()+"conf/schema.xml";     }
-  @Override public String getSolrConfigFile() { return getSolrHome()+"conf/solrconfig.xml"; }
- 
-  @Override
-  public void setUp() throws Exception
-  {
-    super.setUp();
-    
-    // this sets the property for jetty starting SolrDispatchFilter
-    System.setProperty( "solr.solr.home", this.getSolrHome() ); 
-  }
-  
-  /**
-   * Subclasses need to initialize the server impl
-   */
-  protected abstract SolrServer getSolrServer();
-  
-  /**
-   * Create a new solr server
-   */
-  protected abstract SolrServer createNewSolrServer();
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTests.java b/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTests.java
deleted file mode 100644
index 032cefb..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExampleTests.java
+++ /dev/null
@@ -1,519 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import junit.framework.Assert;
-
-import org.apache.solr.client.solrj.request.DirectXmlRequest;
-import org.apache.solr.client.solrj.request.LukeRequest;
-import org.apache.solr.client.solrj.request.SolrPing;
-import org.apache.solr.client.solrj.response.FieldStatsInfo;
-import org.apache.solr.client.solrj.request.UpdateRequest;
-import org.apache.solr.client.solrj.response.LukeResponse;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.client.solrj.response.FacetField;
-import org.apache.solr.client.solrj.response.UpdateResponse;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.util.XML;
-import org.apache.solr.common.params.FacetParams;
-
-/**
- * This should include tests against the example solr config
- * 
- * This lets us try various SolrServer implementations with the same tests.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-abstract public class SolrExampleTests extends SolrExampleTestBase 
-{
-  /**
-   * query the example
-   */
-  public void testExampleConfig() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    
-    // Now add something...
-    SolrInputDocument doc = new SolrInputDocument();
-    String docID = "1112211111";
-    doc.addField( "id", docID, 1.0f );
-    doc.addField( "name", "my name!", 1.0f );
-    
-    Assert.assertEquals( null, doc.getField("foo") );
-    Assert.assertTrue(doc.getField("name").getValue() != null );
-        
-    UpdateResponse upres = server.add( doc ); 
-    System.out.println( "ADD:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    upres = server.commit( true, true );
-    System.out.println( "COMMIT:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    upres = server.optimize( true, true );
-    System.out.println( "OPTIMIZE:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    SolrQuery query = new SolrQuery();
-    query.setQuery( "id:"+docID );
-    QueryResponse response = server.query( query );
-    
-    Assert.assertEquals(docID, response.getResults().get(0).getFieldValue("id") );
-    
-    // Now add a few docs for facet testing...
-    List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
-    SolrInputDocument doc2 = new SolrInputDocument();
-    doc2.addField( "id", "2", 1.0f );
-    doc2.addField( "inStock", true, 1.0f );
-    doc2.addField( "price", 2, 1.0f );
-    doc2.addField( "timestamp", new java.util.Date(), 1.0f );
-    docs.add(doc2);
-    SolrInputDocument doc3 = new SolrInputDocument();
-    doc3.addField( "id", "3", 1.0f );
-    doc3.addField( "inStock", false, 1.0f );
-    doc3.addField( "price", 3, 1.0f );
-    doc3.addField( "timestamp", new java.util.Date(), 1.0f );
-    docs.add(doc3);
-    SolrInputDocument doc4 = new SolrInputDocument();
-    doc4.addField( "id", "4", 1.0f );
-    doc4.addField( "inStock", true, 1.0f );
-    doc4.addField( "price", 4, 1.0f );
-    doc4.addField( "timestamp", new java.util.Date(), 1.0f );
-    docs.add(doc4);
-    SolrInputDocument doc5 = new SolrInputDocument();
-    doc5.addField( "id", "5", 1.0f );
-    doc5.addField( "inStock", false, 1.0f );
-    doc5.addField( "price", 5, 1.0f );
-    doc5.addField( "timestamp", new java.util.Date(), 1.0f );
-    docs.add(doc5);
-    
-    upres = server.add( docs ); 
-    System.out.println( "ADD:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    upres = server.commit( true, true );
-    System.out.println( "COMMIT:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    upres = server.optimize( true, true );
-    System.out.println( "OPTIMIZE:"+upres.getResponse() );
-    Assert.assertEquals(0, upres.getStatus());
-    
-    query = new SolrQuery("*:*");
-    query.addFacetQuery("price:[* TO 2]");
-    query.addFacetQuery("price:[2 TO 4]");
-    query.addFacetQuery("price:[5 TO *]");
-    query.addFacetField("inStock");
-    query.addFacetField("price");
-    query.addFacetField("timestamp");
-    query.removeFilterQuery("inStock:true");
-    
-    response = server.query( query );
-    Assert.assertEquals(0, response.getStatus());
-    Assert.assertEquals(5, response.getResults().getNumFound() );
-    Assert.assertEquals(3, response.getFacetQuery().size());    
-    Assert.assertEquals(2, response.getFacetField("inStock").getValueCount());
-    Assert.assertEquals(4, response.getFacetField("price").getValueCount());
-    
-    // test a second query, test making a copy of the main query
-    SolrQuery query2 = query.getCopy();
-    query2.addFilterQuery("inStock:true");
-    response = server.query( query2 );
-    Assert.assertEquals(1, query2.getFilterQueries().length);
-    Assert.assertEquals(0, response.getStatus());
-    Assert.assertEquals(2, response.getResults().getNumFound() );
-    Assert.assertFalse(query.getFilterQueries() == query2.getFilterQueries());
-  }
-
-
-  /**
-   * query the example
-   */
-  public void testAddRetrieve() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    
-    // Now add something...
-    SolrInputDocument doc1 = new SolrInputDocument();
-    doc1.addField( "id", "id1", 1.0f );
-    doc1.addField( "name", "doc1", 1.0f );
-    doc1.addField( "price", 10 );
-
-    SolrInputDocument doc2 = new SolrInputDocument();
-    doc2.addField( "id", "id2", 1.0f );
-    doc2.addField( "name", "doc2", 1.0f );
-    doc2.addField( "price", 20 );
-    
-    Collection<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
-    docs.add( doc1 );
-    docs.add( doc2 );
-    
-    // Add the documents
-    server.add( docs );
-    server.commit();
-    
-    SolrQuery query = new SolrQuery();
-    query.setQuery( "*:*" );
-    query.addSortField( "price", SolrQuery.ORDER.asc );
-    QueryResponse rsp = server.query( query );
-    
-    Assert.assertEquals( 2, rsp.getResults().getNumFound() );
-    System.out.println( rsp.getResults() );
-    
-    // Now do it again
-    server.add( docs );
-    server.commit();
-    
-    rsp = server.query( query );
-    Assert.assertEquals( 2, rsp.getResults().getNumFound() );
-    System.out.println( rsp.getResults() );
-    
-  }
-  
-  /**
-   * query the example
-   */
-  public void testCommitWithin() throws Exception
-  {    
-    // make sure it is empty...
-    SolrServer server = getSolrServer();
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    QueryResponse rsp = server.query( new SolrQuery( "*:*") );
-    Assert.assertEquals( 0, rsp.getResults().getNumFound() );
-
-    // Now try a timed commit...
-    SolrInputDocument doc3 = new SolrInputDocument();
-    doc3.addField( "id", "id3", 1.0f );
-    doc3.addField( "name", "doc3", 1.0f );
-    doc3.addField( "price", 10 );
-    UpdateRequest up = new UpdateRequest();
-    up.add( doc3 );
-    up.setCommitWithin( 100 );
-    up.process( server );
-    
-    rsp = server.query( new SolrQuery( "*:*") );
-    Assert.assertEquals( 0, rsp.getResults().getNumFound() );
-    
-    Thread.sleep( 500 ); // wait 1/2 seconds...
-
-    // now check that it comes out...
-    rsp = server.query( new SolrQuery( "id:id3") );
-    Assert.assertEquals( 1, rsp.getResults().getNumFound() );
-  }
-  
-  
-  protected void assertNumFound( String query, int num ) throws SolrServerException, IOException
-  {
-    QueryResponse rsp = getSolrServer().query( new SolrQuery( query ) );
-    if( num != rsp.getResults().getNumFound() ) {
-      fail( "expected: "+num +" but had: "+rsp.getResults().getNumFound() + " :: " + rsp.getResults() );
-    }
-  }
-
-  public void testAddDelete() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    
-    SolrInputDocument[] doc = new SolrInputDocument[3];
-    for( int i=0; i<3; i++ ) {
-      doc[i] = new SolrInputDocument();
-      doc[i].setField( "id", i + " & 222", 1.0f );
-    }
-    String id = (String) doc[0].getField( "id" ).getFirstValue();
-    
-    server.add( doc[0] );
-    server.commit();
-    assertNumFound( "*:*", 1 ); // make sure it got in
-    
-    // make sure it got in there
-    server.deleteById( id );
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got out
-    
-    // add it back 
-    server.add( doc[0] );
-    server.commit();
-    assertNumFound( "*:*", 1 ); // make sure it got in
-    server.deleteByQuery( "id:\""+ClientUtils.escapeQueryChars(id)+"\"" );
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got out
-    
-    // Add two documents
-    for( SolrInputDocument d : doc ) {
-      server.add( d );
-    }
-    server.commit();
-    assertNumFound( "*:*", 3 ); // make sure it got in
-    
-    // should be able to handle multiple delete commands in a single go
-    StringWriter xml = new StringWriter();
-    xml.append( "<delete>" );
-    for( SolrInputDocument d : doc ) {
-      xml.append( "<id>" );
-      XML.escapeCharData( (String)d.getField( "id" ).getFirstValue(), xml );
-      xml.append( "</id>" );
-    }
-    xml.append( "</delete>" );
-    DirectXmlRequest up = new DirectXmlRequest( "/update", xml.toString() );
-    server.request( up );
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got out
-  }
-  
-  public void testLukeHandler() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    
-    SolrInputDocument[] doc = new SolrInputDocument[5];
-    for( int i=0; i<doc.length; i++ ) {
-      doc[i] = new SolrInputDocument();
-      doc[i].setField( "id", "ID"+i, 1.0f );
-      server.add( doc[i] );
-    }
-    server.commit();
-    assertNumFound( "*:*", doc.length ); // make sure it got in
-    
-    LukeRequest luke = new LukeRequest();
-    luke.setShowSchema( false );
-    LukeResponse rsp = luke.process( server );
-    assertNull( rsp.getFieldTypeInfo() ); // if you don't ask for it, the schema is null
-    
-    luke.setShowSchema( true );
-    rsp = luke.process( server );
-    assertNotNull( rsp.getFieldTypeInfo() ); 
-  }
-
-  public void testStatistics() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got in
-    
-    int i=0;               // 0   1   2   3   4   5   6   7   8   9 
-    int[] nums = new int[] { 23, 26, 38, 46, 55, 63, 77, 84, 92, 94 };
-    for( int num : nums ) {
-      SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "id", "doc"+i++ );
-      doc.setField( "name", "doc: "+num );
-      doc.setField( "popularity", num );
-      server.add( doc );
-    }
-    server.commit();
-    assertNumFound( "*:*", nums.length ); // make sure they all got in
-    
-    SolrQuery query = new SolrQuery( "*:*" );
-    query.setRows( 0 );
-    query.setGetFieldStatistics( "popularity", true );
-    
-    QueryResponse rsp = server.query( query );
-    FieldStatsInfo stats = rsp.getFieldStatsInfo().get( "popularity" );
-    assertNotNull( stats );
-    
-    assertEquals( 23.0, stats.getMin() );
-    assertEquals( 94.0, stats.getMax() );
-    assertEquals( new Long(nums.length), stats.getCount() );
-    assertEquals( new Long(0), stats.getMissing() );
-    assertEquals( (nums[4]+nums[5])/2.0, stats.getMedian() );
-    assertEquals( "26.4", stats.getStddev().toString().substring(0,4) );
-    
-    // now lets try again with a new set...  (odd median)
-    //----------------------------------------------------
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got in
-    nums = new int[] { 5, 7, 10, 19, 20 };
-    for( int num : nums ) {
-      SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "id", "doc"+i++ );
-      doc.setField( "name", "doc: "+num );
-      doc.setField( "popularity", num );
-      server.add( doc );
-    }
-    server.commit();
-    assertNumFound( "*:*", nums.length ); // make sure they all got in
-    
-    rsp = server.query( query );
-    stats = rsp.getFieldStatsInfo().get( "popularity" );
-    assertNotNull( stats );
-    
-    assertEquals( 5.0, stats.getMin() );
-    assertEquals( 20.0, stats.getMax() );
-    assertEquals( new Long(nums.length), stats.getCount() );
-    assertEquals( new Long(0), stats.getMissing() );
-    assertEquals( 10.0, stats.getMedian() );
-    
-    // Now try again with faceting
-    //---------------------------------
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got in
-    nums = new int[] { 1, 2, 3, 4, 5, 10, 11, 12, 13, 14 };
-    for( i=0; i<nums.length; i++ ) {
-      int num = nums[i];
-      SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "id", "doc"+i );
-      doc.setField( "name", "doc: "+num );
-      doc.setField( "popularity", num );
-      doc.setField( "inStock", i < 5 );
-      server.add( doc );
-    }
-    server.commit();
-    assertNumFound( "inStock:true",  5 ); // make sure they all got in
-    assertNumFound( "inStock:false", 5 ); // make sure they all got in
-
-    // facet on 'inStock'
-    query.addStatsFieldFacets( "popularity", "inStock" );
-    rsp = server.query( query );
-    stats = rsp.getFieldStatsInfo().get( "popularity" );
-    assertNotNull( stats );
-    
-    List<FieldStatsInfo> facets = stats.getFacets().get( "inStock" );
-    assertNotNull( facets );
-    assertEquals( 2, facets.size() );
-    FieldStatsInfo inStockF = facets.get(0);
-    FieldStatsInfo inStockT = facets.get(1);
-    if( "true".equals( inStockF.getName() ) ) {
-      FieldStatsInfo tmp = inStockF;
-      inStockF = inStockT;
-      inStockT = tmp;
-    }
-
-    // make sure half went to each
-    assertEquals( inStockF.getCount(), inStockT.getCount() );
-    assertEquals( stats.getCount().longValue(), inStockF.getCount()+inStockT.getCount() );
-
-    assertTrue( "check that min max faceted ok", inStockF.getMin() > inStockT.getMax() );
-    assertEquals( "they have the same distribution", inStockF.getStddev(), inStockT.getStddev() );
-  }
-
-  public void testPingHandler() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got in
-    
-    // should be ok
-    server.ping();
-    
-    try {
-      SolrPing ping = new SolrPing();
-      ping.getParams().set( "qt", "unknown handler!" );
-      ping.process( server );
-      fail( "sent unknown query type!" );
-    }
-    catch( Exception ex ) {
-      // expected
-    }
-  }
-  
-  public void testFaceting() throws Exception
-  {    
-    SolrServer server = getSolrServer();
-    
-    // Empty the database...
-    server.deleteByQuery( "*:*" );// delete everything!
-    server.commit();
-    assertNumFound( "*:*", 0 ); // make sure it got in
-    
-    ArrayList<SolrInputDocument> docs = new ArrayList<SolrInputDocument>(10);
-    for( int i=1; i<=10; i++ ) {
-      SolrInputDocument doc = new SolrInputDocument();
-      doc.setField( "id", i+"", 1.0f );
-      if( (i%2)==0 ) {
-        doc.addField( "features", "two" );
-      }
-      if( (i%3)==0 ) {
-        doc.addField( "features", "three" );
-      }
-      if( (i%4)==0 ) {
-        doc.addField( "features", "four" );
-      }
-      if( (i%5)==0 ) {
-        doc.addField( "features", "five" );
-      }
-      docs.add( doc );
-    }
-    server.add( docs );
-    server.commit();
-    
-    SolrQuery query = new SolrQuery( "*:*" );
-    query.remove( FacetParams.FACET_FIELD );
-    query.addFacetField( "features" );
-    query.setFacetMinCount( 0 );
-    query.setFacet( true );
-    query.setRows( 0 );
-    
-    QueryResponse rsp = server.query( query );
-    assertEquals( docs.size(), rsp.getResults().getNumFound() );
-    
-    List<FacetField> facets = rsp.getFacetFields();
-    assertEquals( 1, facets.size() );
-    FacetField ff = facets.get( 0 );
-    assertEquals( "features", ff.getName() );
-    System.out.println( "111: "+ff.getValues() );
-    // check all counts
-    assertEquals( "[two (5), three (3), five (2), four (2)]", ff.getValues().toString() );
-    
-    // should be the same facets with minCount=0
-    query.setFilterQueries( "features:two" );
-    rsp = server.query( query );
-    ff = rsp.getFacetField( "features" );
-    assertEquals( "[two (5), four (2), five (1), three (1)]", ff.getValues().toString() );
-    
-    // with minCount > 3
-    query.setFacetMinCount( 4 );
-    rsp = server.query( query );
-    ff = rsp.getFacetField( "features" );
-    assertEquals( "[two (5)]", ff.getValues().toString() );
-
-    // with minCount > 3
-    query.setFacetMinCount( -1 );
-    rsp = server.query( query );
-    ff = rsp.getFacetField( "features" );
-    
-    System.out.println( rsp.getResults().getNumFound() + " :::: 444: "+ff.getValues() );
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExceptionTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/SolrExceptionTest.java
deleted file mode 100644
index b83a291..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/SolrExceptionTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import java.net.UnknownHostException;
-
-import junit.framework.TestCase;
-
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.common.SolrException;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrExceptionTest extends TestCase {
-
-  public void testSolrException() throws Throwable {
-    // test a connection to a solr server that probably doesn't exist
-    // this is a very simple test and most of the test should be considered verified 
-    // if the compiler won't let you by without the try/catch
-    boolean gotExpectedError = false;
-    try {
-      SolrServer client = new CommonsHttpSolrServer("http://333.333.333.333:8080/solr/");
-      SolrQuery query = new SolrQuery("test123");
-      client.query(query);
-    } catch (SolrServerException sse) {
-      gotExpectedError = true;
-      assertTrue(UnknownHostException.class == sse.getRootCause().getClass()
-              //If one is using OpenDNS, then you don't get UnknownHostException, instead you get back that the query couldn't execute
-              || (sse.getRootCause().getClass() == SolrException.class && ((SolrException) sse.getRootCause()).code() == 302 && sse.getMessage().equals("Error executing query")));
-    }
-    assertTrue(gotExpectedError);
-  }
-  
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/SolrQueryTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/SolrQueryTest.java
deleted file mode 100644
index c339461..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/SolrQueryTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import org.apache.solr.common.params.FacetParams;
-
-import junit.framework.Assert;
-import junit.framework.TestCase;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrQueryTest extends TestCase {
-  
-  public void testSolrQueryMethods() {
-    SolrQuery q = new SolrQuery("dog");
-    boolean b = false;
-    
-    q.setFacetLimit(10);
-    q.addFacetField("price");
-    q.addFacetField("state");
-    Assert.assertEquals(q.getFacetFields().length, 2);
-    q.addFacetQuery("instock:true");
-    q.addFacetQuery("instock:false");
-    q.addFacetQuery("a:b");
-    Assert.assertEquals(q.getFacetQuery().length, 3);
-    
-    b = q.removeFacetField("price");
-    Assert.assertEquals(b, true);
-    b = q.removeFacetField("price2");
-    Assert.assertEquals(b, false);
-    b = q.removeFacetField("state");
-    Assert.assertEquals(b, true);
-    Assert.assertEquals(null, q.getFacetFields());
-    
-    b = q.removeFacetQuery("instock:true");
-    Assert.assertEquals(b, true);
-    b = q.removeFacetQuery("instock:false");
-    b = q.removeFacetQuery("a:c");
-    Assert.assertEquals(b, false);
-    b = q.removeFacetQuery("a:b");
-    Assert.assertEquals(null, q.getFacetQuery());   
-    
-    q.addSortField("price", SolrQuery.ORDER.asc);
-    q.addSortField("date", SolrQuery.ORDER.desc);
-    q.addSortField("qty", SolrQuery.ORDER.desc);
-    q.removeSortField("date", SolrQuery.ORDER.desc);
-    Assert.assertEquals(2, q.getSortFields().length);
-    q.removeSortField("price", SolrQuery.ORDER.asc);
-    q.removeSortField("qty", SolrQuery.ORDER.desc);
-    Assert.assertEquals(null, q.getSortFields());
-    
-    q.addHighlightField("hl1");
-    q.addHighlightField("hl2");
-    q.setHighlightSnippets(2);
-    Assert.assertEquals(2, q.getHighlightFields().length);
-    Assert.assertEquals(100, q.getHighlightFragsize());
-    Assert.assertEquals(q.getHighlightSnippets(), 2);
-    q.removeHighlightField("hl1");
-    q.removeHighlightField("hl3");
-    Assert.assertEquals(1, q.getHighlightFields().length);
-    q.removeHighlightField("hl2");
-    Assert.assertEquals(null, q.getHighlightFields());
-    
-    // check to see that the removes are properly clearing the cgi params
-    Assert.assertEquals(q.toString(), "q=dog");
-
-    //Add time allowed param
-    q.setTimeAllowed(1000);
-    Assert.assertEquals((Integer)1000, q.getTimeAllowed() );
-    //Adding a null should remove it
-    q.setTimeAllowed(null);
-    Assert.assertEquals(null, q.getTimeAllowed() ); 
-    
-    System.out.println(q);
-  }
-  
-  public void testFacetSort() {
-    SolrQuery q = new SolrQuery("dog");
-    assertEquals("count", q.getFacetSortString());
-    q.setFacetSort("lex");
-    assertEquals("lex", q.getFacetSortString());
-  }
-
-  public void testFacetSortLegacy() {
-    SolrQuery q = new SolrQuery("dog");
-    assertTrue("expected default value to be true", q.getFacetSort());
-    q.setFacetSort(false);
-    assertFalse("expected set value to be false", q.getFacetSort());
-  }
-
-  public void testSettersGetters() {
-      SolrQuery q = new SolrQuery("foo");
-      assertEquals(10, q.setFacetLimit(10).getFacetLimit());
-      assertEquals(10, q.setFacetMinCount(10).getFacetMinCount());
-      assertEquals("lex", q.setFacetSort("lex").getFacetSortString());
-      assertEquals(10, q.setHighlightSnippets(10).getHighlightSnippets());
-      assertEquals(10, q.setHighlightFragsize(10).getHighlightFragsize());
-      assertEquals(true, q.setHighlightRequireFieldMatch(true).getHighlightRequireFieldMatch());
-      assertEquals("foo", q.setHighlightSimplePre("foo").getHighlightSimplePre());
-      assertEquals("foo", q.setHighlightSimplePost("foo").getHighlightSimplePost());
-      assertEquals(true, q.setHighlight(true).getHighlight());
-      assertEquals("foo", q.setQuery("foo").getQuery());
-      assertEquals(10, q.setRows(10).getRows().intValue());
-      assertEquals(10, q.setStart(10).getStart().intValue());
-      assertEquals("foo", q.setQueryType("foo").getQueryType());
-      assertEquals(10, q.setTimeAllowed(10).getTimeAllowed().intValue());
-      
-      // non-standard
-      assertEquals("foo", q.setFacetPrefix("foo").get( FacetParams.FACET_PREFIX, null ) );
-      assertEquals("foo", q.setFacetPrefix("a", "foo").getFieldParam( "a", FacetParams.FACET_PREFIX, null ) );
-
-      assertEquals( Boolean.TRUE, q.setMissing(Boolean.TRUE.toString()).getBool( FacetParams.FACET_MISSING ) );
-      assertEquals( Boolean.FALSE, q.setFacetMissing( Boolean.FALSE ).getBool( FacetParams.FACET_MISSING ) );      
-      assertEquals( "true", q.setParam( "xxx", true ).getParams( "xxx" )[0] );
-  }
-  
-  public void testOrder() {
-    assertEquals( SolrQuery.ORDER.asc, SolrQuery.ORDER.desc.reverse() );
-    assertEquals( SolrQuery.ORDER.desc, SolrQuery.ORDER.asc.reverse() );
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/StartSolrJetty.java b/client/java/solrj/test/org/apache/solr/client/solrj/StartSolrJetty.java
deleted file mode 100644
index 8749674..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/StartSolrJetty.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj;
-
-import org.mortbay.jetty.Connector;
-import org.mortbay.jetty.Server;
-import org.mortbay.jetty.bio.SocketConnector;
-import org.mortbay.jetty.webapp.WebAppContext;
-
-/**
- * @since solr 1.3
- */
-public class StartSolrJetty 
-{
-  public static void main( String[] args ) 
-  {
-    //System.setProperty("solr.solr.home", "../../../example/solr");
-
-    Server server = new Server();
-    SocketConnector connector = new SocketConnector();
-    // Set some timeout options to make debugging easier.
-    connector.setMaxIdleTime(1000 * 60 * 60);
-    connector.setSoLingerTime(-1);
-    connector.setPort(8080);
-    server.setConnectors(new Connector[] { connector });
-    
-    WebAppContext bb = new WebAppContext();
-    bb.setServer(server);
-    bb.setContextPath("/");
-    bb.setWar("src/webapp/web");
-
-//    // START JMX SERVER
-//    if( true ) {
-//      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
-//      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);
-//      server.getContainer().addEventListener(mBeanContainer);
-//      mBeanContainer.start();
-//    }
-    
-    server.addHandler(bb);
-
-    try {
-      System.out.println(">>> STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP");
-      server.start();
-      while (System.in.available() == 0) {
-        Thread.sleep(5000);
-      }
-      server.stop();
-      server.join();
-    } 
-    catch (Exception e) {
-      e.printStackTrace();
-      System.exit(100);
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java b/client/java/solrj/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java
deleted file mode 100644
index b0577bd..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java
+++ /dev/null
@@ -1,180 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.client.solrj.beans;
-
-import junit.framework.TestCase;
-
-import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
-import org.apache.solr.client.solrj.beans.Field;
-import org.apache.solr.client.solrj.impl.XMLResponseParser;
-import org.apache.solr.client.solrj.response.QueryResponse;
-import org.apache.solr.client.solrj.util.ClientUtils;
-import org.apache.solr.common.SolrDocumentList;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.SolrInputField;
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.util.NamedList;
-import org.junit.Assert;
-
-import java.io.StringReader;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-public class TestDocumentObjectBinder extends TestCase 
-{
-  public void testSimple() throws Exception {
-    DocumentObjectBinder binder = new DocumentObjectBinder();
-    XMLResponseParser parser = new XMLResponseParser();
-    NamedList<Object> nl = null;
-    nl = parser.processResponse(new StringReader(xml));
-    QueryResponse res = new QueryResponse(nl, null);
-    SolrDocumentList solDocList = res.getResults();
-    List<Item> l = binder.getBeans(Item.class,res.getResults());
-    Assert.assertEquals(solDocList.size(), l.size());
-    Assert.assertEquals(solDocList.get(0).getFieldValue("features"), l.get(0).features);
-
-    Item item = new Item();
-    item.id = "aaa";
-    item.categories = new String[] { "aaa", "bbb", "ccc" };
-    SolrInputDocument out = binder.toSolrInputDocument( item );
-
-    Assert.assertEquals( item.id, out.getFieldValue( "id" ) );
-    SolrInputField catfield = out.getField( "cat" );
-    Assert.assertEquals( 3, catfield.getValueCount() );
-    Assert.assertEquals( "[aaa, bbb, ccc]", catfield.getValue().toString() );
-  
-    // Test the error on not settable stuff...
-    NotGettableItem ng = new NotGettableItem();
-    ng.setInStock( false );
-    try {
-      out = binder.toSolrInputDocument( ng );
-      Assert.fail( "Should throw an error" );
-    }
-    catch( RuntimeException ex ) {
-      // ok -- this should happen...
-    }
-  }
-  public void testSingleVal4Array(){
-    DocumentObjectBinder binder = new DocumentObjectBinder();
-    SolrDocumentList solDocList = new SolrDocumentList();
-    SolrDocument d = new SolrDocument();
-    solDocList.add(d);
-    d.setField("cat","hello");
-    List<Item> l = binder.getBeans(Item.class,solDocList);
-    Assert.assertEquals("hello", l.get(0).categories[0]);
-
-  }
-  
-  public void testToAndFromSolrDocument()
-  {
-    Item item = new Item();
-    item.id = "one";
-    item.inStock = false;
-    item.categories =  new String[] { "aaa", "bbb", "ccc" };
-    item.features = Arrays.asList( item.categories );
-    
-    DocumentObjectBinder binder = new DocumentObjectBinder();
-    SolrInputDocument doc = binder.toSolrInputDocument( item );
-    SolrDocumentList docs = new SolrDocumentList();
-    docs.add( ClientUtils.toSolrDocument(doc) );
-    Item out = binder.getBeans( Item.class, docs ).get( 0 );
-
-    // make sure it came out the same
-    Assert.assertEquals( item.id, out.id );
-    Assert.assertEquals( item.inStock, out.inStock );
-    Assert.assertEquals( item.categories.length, out.categories.length );
-    Assert.assertEquals( item.features, out.features );
-  }
-
-  public static class Item {
-    @Field
-    String id;
-
-    @Field("cat")
-    String[] categories;
-
-    @Field
-    List<String> features;
-
-    @Field
-    Date timestamp;
-
-    @Field("highway_mileage")
-    int mwyMileage;
-
-    boolean inStock = false;
-
-    @Field
-    public void setInStock(Boolean b) {
-      inStock = b;
-    }
-    
-    // required if you want to fill SolrDocuments with the same annotaion...
-    public boolean isInStock()
-    {
-      return inStock;
-    }
-  }
-  
-
-  public static class NotGettableItem {
-    @Field
-    String id;
-
-    private boolean inStock;
-    private String aaa;
-
-    @Field
-    public void setInStock(Boolean b) {
-      inStock = b;
-    }
-
-    public String getAaa() {
-      return aaa;
-    }
-
-    @Field
-    public void setAaa(String aaa) {
-      this.aaa = aaa;
-    }
-  }
-
-  public static final String xml = 
-    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
-    "<response>" +
-    "<lst name=\"responseHeader\"><int name=\"status\">0</int><int name=\"QTime\">0</int><lst name=\"params\"><str name=\"start\">0</str><str name=\"q\">*:*\n" +
-    "</str><str name=\"version\">2.2</str><str name=\"rows\">4</str></lst></lst><result name=\"response\" numFound=\"26\" start=\"0\"><doc><arr name=\"cat\">" +
-    "<str>electronics</str><str>hard drive</str></arr><arr name=\"features\"><str>7200RPM, 8MB cache, IDE Ultra ATA-133</str>" +
-    "<str>NoiseGuard, SilentSeek technology, Fluid Dynamic Bearing (FDB) motor</str></arr><str name=\"id\">SP2514N</str>" +
-    "<bool name=\"inStock\">true</bool><str name=\"manu\">Samsung Electronics Co. Ltd.</str><str name=\"name\">Samsung SpinPoint P120 SP2514N - hard drive - 250 GB - ATA-133</str>" +
-    "<int name=\"popularity\">6</int><float name=\"price\">92.0</float><str name=\"sku\">SP2514N</str><date name=\"timestamp\">2008-04-16T10:35:57.078Z</date></doc>" +
-    "<doc><arr name=\"cat\"><str>electronics</str><str>hard drive</str></arr><arr name=\"features\"><str>SATA 3.0Gb/s, NCQ</str><str>8.5ms seek</str>" +
-    "<str>16MB cache</str></arr><str name=\"id\">6H500F0</str><bool name=\"inStock\">true</bool><str name=\"manu\">Maxtor Corp.</str>" +
-    "<str name=\"name\">Maxtor DiamondMax 11 - hard drive - 500 GB - SATA-300</str><int name=\"popularity\">6</int><float name=\"price\">350.0</float>" +
-    "<str name=\"sku\">6H500F0</str><date name=\"timestamp\">2008-04-16T10:35:57.109Z</date></doc><doc><arr name=\"cat\"><str>electronics</str>" +
-    "<str>connector</str></arr><arr name=\"features\"><str>car power adapter, white</str></arr><str name=\"id\">F8V7067-APL-KIT</str>" +
-    "<bool name=\"inStock\">false</bool><str name=\"manu\">Belkin</str><str name=\"name\">Belkin Mobile Power Cord for iPod w/ Dock</str>" +
-    "<int name=\"popularity\">1</int><float name=\"price\">19.95</float><str name=\"sku\">F8V7067-APL-KIT</str>" +
-    "<date name=\"timestamp\">2008-04-16T10:35:57.140Z</date><float name=\"weight\">4.0</float></doc><doc>" +
-    "<arr name=\"cat\"><str>electronics</str><str>connector</str></arr><arr name=\"features\">" +
-    "<str>car power adapter for iPod, white</str></arr><str name=\"id\">IW-02</str><bool name=\"inStock\">false</bool>" +
-    "<str name=\"manu\">Belkin</str><str name=\"name\">iPod &amp; iPod Mini USB 2.0 Cable</str>" +
-    "<int name=\"popularity\">1</int><float name=\"price\">11.5</float><str name=\"sku\">IW-02</str>" +
-    "<date name=\"timestamp\">2008-04-16T10:35:57.140Z</date><float name=\"weight\">2.0</float></doc></result>\n" +
-    "</response>";
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
deleted file mode 100644
index 17baea1..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import java.net.URL;
-
-import junit.framework.TestCase;
-
-import org.apache.commons.io.IOUtils;
-import org.mortbay.jetty.Connector;
-import org.mortbay.jetty.Server;
-import org.mortbay.jetty.bio.SocketConnector;
-import org.mortbay.jetty.webapp.WebAppContext;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class JettyWebappTest extends TestCase 
-{
-  int port = 0;
-  static final String context = "/test";
-  
-  Server server;
-  
-  @Override
-  public void setUp() throws Exception 
-  {
-    System.setProperty("solr.solr.home", "../../../example/solr");
-    String path = "../../webapp/web";
-
-    server = new Server(port);
-    new WebAppContext(server, path, context );
-
-    SocketConnector connector = new SocketConnector();
-    connector.setMaxIdleTime(1000 * 60 * 60);
-    connector.setSoLingerTime(-1);
-    connector.setPort(0);
-    server.setConnectors(new Connector[]{connector});
-    server.setStopAtShutdown( true );
-    
-    server.start();
-    port = connector.getLocalPort();
-  }
-
-  @Override
-  public void tearDown() throws Exception 
-  {
-    try {
-      server.stop();
-    } catch( Exception ex ) {}
-  }
-  
-  public void testJSP() throws Exception
-  {
-    // Currently not an extensive test, but it does fire up the JSP pages and make 
-    // sure they compile ok
-    
-    String adminPath = "http://localhost:"+port+context+"/";
-    String html = IOUtils.toString( new URL(adminPath).openStream() );
-    assertNotNull( html ); // real error will be an exception
-
-    adminPath += "admin/";
-    html = IOUtils.toString( new URL(adminPath).openStream() );
-    assertNotNull( html ); // real error will be an exception
-
-    // analysis
-    html = IOUtils.toString( new URL(adminPath+"analysis.jsp").openStream() );
-    assertNotNull( html ); // real error will be an exception
-
-    // schema browser
-    html = IOUtils.toString( new URL(adminPath+"schema.jsp").openStream() );
-    assertNotNull( html ); // real error will be an exception
-
-    // schema browser
-    html = IOUtils.toString( new URL(adminPath+"threaddump.jsp").openStream() );
-    assertNotNull( html ); // real error will be an exception
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
deleted file mode 100644
index e523562..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import org.apache.solr.client.solrj.LargeVolumeTestBase;
-import org.apache.solr.client.solrj.SolrServer;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class LargeVolumeEmbeddedTest extends LargeVolumeTestBase {
-
-  SolrServer server;
-  
-  @Override public void setUp() throws Exception 
-  {
-    super.setUp();
-    
-    // setup the server...
-    server = createNewSolrServer();
-  }
-
-  @Override
-  protected SolrServer getSolrServer()
-  {
-    return server;
-  }
-
-  @Override
-  protected SolrServer createNewSolrServer()
-  {
-    return new EmbeddedSolrServer( h.getCoreContainer(), "" );
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
deleted file mode 100644
index ff42d35..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import org.apache.solr.client.solrj.LargeVolumeTestBase;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class LargeVolumeJettyTest extends LargeVolumeTestBase {
-
-  SolrServer server;
-  JettySolrRunner jetty;
-
-  int port = 0;
-  static final String context = "/example";
-
-  
-  @Override public void setUp() throws Exception 
-  {
-    super.setUp();
-    
-    jetty = new JettySolrRunner( context, 0 );
-    jetty.start();
-    port = jetty.getLocalPort();
-    
-    server = this.createNewSolrServer();
-  }
-
-  @Override public void tearDown() throws Exception 
-  {
-    super.tearDown();
-    jetty.stop();  // stop the server
-  }
-  
-
-  @Override
-  protected SolrServer getSolrServer()
-  {
-    return server;
-  }
-
-  @Override
-  protected SolrServer createNewSolrServer()
-  {
-    try {
-      // setup the server...
-      String url = "http://localhost:"+port+context;
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
-      s.setConnectionTimeout(100); // 1/10th sec
-      s.setDefaultMaxConnectionsPerHost(100);
-      s.setMaxTotalConnections(100);
-      return s;
-    }
-    catch( Exception ex ) {
-      throw new RuntimeException( ex );
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java
deleted file mode 100644
index be95da0..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import java.io.File;
-
-import org.apache.solr.client.solrj.MultiCoreExampleTestBase;
-import org.apache.solr.client.solrj.SolrServer;
-
-/**
- * This runs SolrServer test using 
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class MultiCoreEmbeddedTest extends MultiCoreExampleTestBase {
-
-  @Override public void setUp() throws Exception 
-  {
-    super.setUp();
-    
-    File home = new File( getSolrHome() );
-    File f = new File( home, "solr.xml" );
-    cores.load( getSolrHome(), f );
-  }
-
-  @Override
-  protected SolrServer getSolrCore0()
-  {
-    return new EmbeddedSolrServer( cores, "core0" );
-  }
-
-  @Override
-  protected SolrServer getSolrCore1()
-  {
-    return new EmbeddedSolrServer( cores, "core1" );
-  }
-
-  @Override
-  protected SolrServer getSolrCore(String name)
-  {
-    return new EmbeddedSolrServer( cores, name );
-  }
-
-  @Override
-  protected SolrServer getSolrAdmin()
-  {
-    return new EmbeddedSolrServer( cores, "core0" );
-  } 
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java
deleted file mode 100644
index a08c61e..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import org.apache.solr.client.solrj.MultiCoreExampleTestBase;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-
-/**
- * TODO? perhaps use:
- *  http://docs.codehaus.org/display/JETTY/ServletTester
- * rather then open a real connection?
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class MultiCoreExampleJettyTest extends MultiCoreExampleTestBase {
-
-  JettySolrRunner jetty;
-
-  int port = 0;
-  static final String context = "/example";
-  
-  @Override public void setUp() throws Exception 
-  {    
-    super.setUp();
-
-    jetty = new JettySolrRunner( context, 0 );
-    jetty.start();
-    port = jetty.getLocalPort();
-
-    h.getCoreContainer().setPersistent(false);    
-  }
-
-  @Override public void tearDown() throws Exception 
-  {
-    super.tearDown();
-    jetty.stop();  // stop the server
-  }
-  
-
-  @Override
-  protected SolrServer getSolrCore(String name)
-  {
-    return createServer(name);
-  }
-
-  @Override
-  protected SolrServer getSolrCore0()
-  {
-    return createServer( "core0" );
-  }
-
-  @Override
-  protected SolrServer getSolrCore1()
-  {
-    return createServer( "core1" );
-  }
-
-  @Override
-  protected SolrServer getSolrAdmin()
-  {
-    return createServer( "" );
-  } 
-  
-  private SolrServer createServer( String name )
-  {
-    try {
-      // setup the server...
-      String url = "http://localhost:"+port+context+"/"+name;
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
-      s.setConnectionTimeout(100); // 1/10th sec
-      s.setDefaultMaxConnectionsPerHost(100);
-      s.setMaxTotalConnections(100);
-      return s;
-    }
-    catch( Exception ex ) {
-      throw new RuntimeException( ex );
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
deleted file mode 100644
index 36c57af..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import org.apache.solr.client.solrj.SolrExampleTests;
-import org.apache.solr.client.solrj.SolrServer;
-
-/**
- * This runs SolrServer test using 
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrExampleEmbeddedTest extends SolrExampleTests {
-
-  SolrServer server;
-  
-  @Override public void setUp() throws Exception 
-  {
-    super.setUp();
-    
-    // setup the server...
-    server = createNewSolrServer();
-  }
-
-  @Override
-  protected SolrServer getSolrServer()
-  {
-    return server;
-  }
-
-  @Override
-  protected SolrServer createNewSolrServer()
-  {
-    return new EmbeddedSolrServer( h.getCoreContainer(), "" );
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
deleted file mode 100644
index d0c4a20..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import org.apache.solr.client.solrj.SolrExampleTests;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-import org.apache.solr.core.SolrCore;
-import org.apache.solr.schema.SchemaField;
-import org.junit.Assert;
-
-/**
- * TODO? perhaps use:
- *  http://docs.codehaus.org/display/JETTY/ServletTester
- * rather then open a real connection?
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrExampleJettyTest extends SolrExampleTests {
-
-  SolrServer server;
-  JettySolrRunner jetty;
-
-  int port = 0;
-  static final String context = "/example";
-  
-  @Override public void setUp() throws Exception 
-  {
-    super.setUp();
-    
-    jetty = new JettySolrRunner( context, 0 );
-    jetty.start();
-    port = jetty.getLocalPort();
-    System.out.println("Assigned Port#" + port);
-    server = this.createNewSolrServer();
-  }
-
-  @Override public void tearDown() throws Exception 
-  {
-    super.tearDown();
-    jetty.stop();  // stop the server
-  }
-  
-  
-  @Override
-  protected SolrServer getSolrServer()
-  {
-    return server;
-  }
-
-  @Override
-  protected SolrServer createNewSolrServer()
-  {
-    try {
-      // setup the server...
-      String url = "http://localhost:"+port+context;
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
-      s.setConnectionTimeout(100); // 1/10th sec
-      s.setDefaultMaxConnectionsPerHost(100);
-      s.setMaxTotalConnections(100);
-      return s;
-    }
-    catch( Exception ex ) {
-      throw new RuntimeException( ex );
-    }
-  }
-  
-  public void testBadSetup()
-  {
-    try {
-      // setup the server...
-      String url = "http://localhost/?core=xxx";
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
-      Assert.fail( "CommonsHttpSolrServer should not allow a path with a parameter: "+s.getBaseURL() );
-    }
-    catch( Exception ex ) {
-      // expected
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java b/client/java/solrj/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
deleted file mode 100644
index 9aed3a7..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.embedded;
-
-import static junit.framework.Assert.assertEquals;
-import org.apache.solr.client.solrj.SolrQuery;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.request.CoreAdminRequest;
-import org.apache.solr.client.solrj.request.QueryRequest;
-import org.apache.solr.client.solrj.request.UpdateRequest;
-import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
-import org.apache.solr.client.solrj.response.CoreAdminResponse;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.core.CoreContainer;
-import org.apache.solr.util.AbstractSolrTestCase;
-import org.junit.After;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.File;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class TestSolrProperties {
-  protected static Logger log = LoggerFactory.getLogger(TestSolrProperties.class);
-  protected CoreContainer cores = null;
-
-  public String getSolrHome() {
-    return "solr/shared";
-  }
-
-  public String getSolrXml() {
-    return "solr.xml";
-  }
-
-  @Before
-  public void setUp() throws Exception {
-    System.setProperty("solr.solr.home", getSolrHome());
-
-    log.info("pwd: " + (new File(".")).getAbsolutePath());
-    File home = new File(getSolrHome());
-    File f = new File(home, "solr.xml");
-    cores = new CoreContainer(getSolrHome(), f);
-  }
-
-  @After
-  public void tearDown() throws Exception {
-    if (cores != null)
-      cores.shutdown();
-    File dataDir = new File(getSolrHome() + "/data");
-    String skip = System.getProperty("solr.test.leavedatadir");
-    if (null != skip && 0 != skip.trim().length()) {
-      log.info("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
-    } else {
-      if (!AbstractSolrTestCase.recurseDelete(dataDir)) {
-        log.warn("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
-      }
-    }
-    File persistedFile = new File(getSolrHome() + File.separator + "solr-persist.xml");
-    persistedFile.delete();
-  }
-
-  protected SolrServer getSolrCore0() {
-    return new EmbeddedSolrServer(cores, "core0");
-  }
-
-
-  protected SolrServer getSolrCore1() {
-    return new EmbeddedSolrServer(cores, "core1");
-  }
-
-  protected SolrServer getSolrAdmin() {
-    return new EmbeddedSolrServer(cores, "core0");
-  }
-
-  protected SolrServer getSolrCore(String name) {
-    return new EmbeddedSolrServer(cores, name);
-  }
-
-  @Test
-  public void testProperties() throws Exception {
-    UpdateRequest up = new UpdateRequest();
-    up.setAction(ACTION.COMMIT, true, true);
-    up.deleteByQuery("*:*");
-    up.process(getSolrCore0());
-    up.process(getSolrCore1());
-    up.clear();
-
-    // Add something to each core
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setField("id", "AAA");
-    doc.setField("core0", "yup stopfra stopfrb stopena stopenb");
-
-    // Add to core0
-    up.add(doc);
-    up.process(getSolrCore0());
-
-    // You can't add it to core1
-    try {
-      up.process(getSolrCore1());
-      fail("Can't add core0 field to core1!");
-    }
-    catch (Exception ex) {
-    }
-
-    // Add to core1
-    doc.setField("id", "BBB");
-    doc.setField("core1", "yup stopfra stopfrb stopena stopenb");
-    doc.removeField("core0");
-    up.add(doc);
-    up.process(getSolrCore1());
-
-    // You can't add it to core1
-    try {
-      up.process(getSolrCore0());
-      fail("Can't add core1 field to core0!");
-    }
-    catch (Exception ex) {
-    }
-
-    // now Make sure AAA is in 0 and BBB in 1
-    SolrQuery q = new SolrQuery();
-    QueryRequest r = new QueryRequest(q);
-    q.setQuery("id:AAA");
-    assertEquals(1, r.process(getSolrCore0()).getResults().size());
-    assertEquals(0, r.process(getSolrCore1()).getResults().size());
-
-    // Now test Changing the default core
-    assertEquals(1, getSolrCore0().query(new SolrQuery("id:AAA")).getResults().size());
-    assertEquals(0, getSolrCore0().query(new SolrQuery("id:BBB")).getResults().size());
-
-    assertEquals(0, getSolrCore1().query(new SolrQuery("id:AAA")).getResults().size());
-    assertEquals(1, getSolrCore1().query(new SolrQuery("id:BBB")).getResults().size());
-
-    // Now test reloading it should have a newer open time
-    String name = "core0";
-    SolrServer coreadmin = getSolrAdmin();
-    CoreAdminResponse mcr = CoreAdminRequest.getStatus(name, coreadmin);
-    long before = mcr.getStartTime(name).getTime();
-    CoreAdminRequest.reloadCore(name, coreadmin);
-
-    mcr = CoreAdminRequest.getStatus(name, coreadmin);
-    long after = mcr.getStartTime(name).getTime();
-    assertTrue("should have more recent time: " + after + "," + before, after > before);
-
-    mcr = CoreAdminRequest.persist("solr-persist.xml", coreadmin);
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/response/QueryResponseTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/response/QueryResponseTest.java
deleted file mode 100644
index 694cdac..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/response/QueryResponseTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.response;
-
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.FileReader;
-
-import junit.framework.Assert;
-
-import org.apache.solr.client.solrj.impl.XMLResponseParser;
-import org.apache.solr.common.util.NamedList;
-import org.junit.Test;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Simple test for Date facet support in QueryResponse
- * 
- * @since solr 1.3
- */
-public class QueryResponseTest {
-  @Test
-  public void testDateFacets() throws Exception   {
-    XMLResponseParser parser = new XMLResponseParser();
-    FileReader in = new FileReader("sampleDateFacetResponse.xml");
-    assertTrue("in is null and it shouldn't be", in != null);
-    NamedList<Object> response = parser.processResponse(in);
-    in.close();
-    
-    QueryResponse qr = new QueryResponse(response, null);
-    Assert.assertNotNull(qr);
-    
-    Assert.assertNotNull(qr.getFacetDates());
-    
-    for (FacetField f : qr.getFacetDates()) {
-      Assert.assertNotNull(f);
-      System.out.println(f.toString());
-      System.out.println("GAP: " + f.getGap());
-      System.out.println("END: " + f.getEnd());
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java b/client/java/solrj/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
deleted file mode 100644
index 7eb7e0c..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package org.apache.solr.client.solrj.response;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import junit.framework.Assert;
-import org.apache.solr.client.solrj.SolrExampleTestBase;
-import org.apache.solr.client.solrj.SolrQuery;
-import org.apache.solr.client.solrj.SolrServer;
-import org.apache.solr.client.solrj.embedded.JettySolrRunner;
-import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
-import org.apache.solr.client.solrj.request.QueryRequest;
-import org.apache.solr.common.SolrInputDocument;
-import org.apache.solr.common.params.CommonParams;
-import org.apache.solr.common.params.SpellingParams;
-
-/**
- * Test for SpellCheckComponent's response in Solrj
- *
- * @version $Id$
- * @since solr 1.3
- */
-public class TestSpellCheckResponse extends SolrExampleTestBase {
-
-  SolrServer server;
-  JettySolrRunner jetty;
-
-  int port = 0;
-  static final String context = "/example";
-
-  public void setUp() throws Exception {
-    super.setUp();
-
-    jetty = new JettySolrRunner(context, 0);
-    jetty.start();
-    port = jetty.getLocalPort();
-    System.out.println("Assigned Port: " + port);
-    server = this.createNewSolrServer();
-  }
-
-  public void testSpellCheckResponse() throws Exception {
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setField("id", "AAA");
-    doc.setField("name", "Samsung");
-    server.add(doc);
-    server.commit(true, true);
-
-    SolrQuery query = new SolrQuery("*:*");
-    query.set(CommonParams.QT, "/spellCheckCompRH");
-    query.set("spellcheck", true);
-    query.set(SpellingParams.SPELLCHECK_Q, "samsang");
-    query.set(SpellingParams.SPELLCHECK_BUILD, true);
-    QueryRequest request = new QueryRequest(query);
-    SpellCheckResponse response = request.process(server).getSpellCheckResponse();
-    Assert.assertEquals("Incorrect spelling results", "samsung", response.getFirstSuggestion("samsang"));
-  }
-
-  public void testSpellCheckResponse_Extended() throws Exception {
-    SolrInputDocument doc = new SolrInputDocument();
-    doc.setField("id", "AAA");
-    doc.setField("name", "Samsung");
-    server.add(doc);
-    server.commit(true, true);
-
-    SolrQuery query = new SolrQuery("*:*");
-    query.set(CommonParams.QT, "/spellCheckCompRH");
-    query.set("spellcheck", true);
-    query.set(SpellingParams.SPELLCHECK_Q, "samsang");
-    query.set(SpellingParams.SPELLCHECK_BUILD, true);
-    query.set(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, true);
-    QueryRequest request = new QueryRequest(query);
-    SpellCheckResponse response = request.process(server).getSpellCheckResponse();
-    Assert.assertEquals("Incorrect spelling results", "samsung", response.getFirstSuggestion("samsang"));
-  }
-
-  protected SolrServer getSolrServer() {
-    return server;
-  }
-
-  protected SolrServer createNewSolrServer() {
-    try {
-      // setup the server...
-      String url = "http://localhost:" + port + context;
-      CommonsHttpSolrServer s = new CommonsHttpSolrServer(url);
-      s.setConnectionTimeout(100); // 1/10th sec
-      s.setDefaultMaxConnectionsPerHost(100);
-      s.setMaxTotalConnections(100);
-      return s;
-    }
-    catch (Exception ex) {
-      throw new RuntimeException(ex);
-    }
-  }
-}
diff --git a/client/java/solrj/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java b/client/java/solrj/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java
deleted file mode 100644
index 77beeb3..0000000
--- a/client/java/solrj/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.client.solrj.util;
-
-import junit.framework.TestCase;
-
-/**
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class ClientUtilsTest extends TestCase {
-  
-  public void testEscapeQuery() 
-  { 
-    assertEquals( "nochange", ClientUtils.escapeQueryChars( "nochange" ) );
-    assertEquals( "12345", ClientUtils.escapeQueryChars( "12345" ) );
-    assertEquals( "with\\ space", ClientUtils.escapeQueryChars( "with space" ) );
-    assertEquals( "h\\:ello\\!", ClientUtils.escapeQueryChars( "h:ello!" ) );
-    assertEquals( "h\\~\\!", ClientUtils.escapeQueryChars( "h~!" ) );
-  }
-}
diff --git a/contrib/dataimporthandler/build.xml b/contrib/dataimporthandler/build.xml
index 7858df7..92071e8 100644
--- a/contrib/dataimporthandler/build.xml
+++ b/contrib/dataimporthandler/build.xml
@@ -28,8 +28,8 @@
   </description>
 
   <path id="common.classpath">
-  	<pathelement location="${solr-path}/build/common" />
-  	<pathelement location="${solr-path}/build/core" />
+  	<pathelement location="${solr-path}/build/solr" />
+  	<pathelement location="${solr-path}/build/solrj" />
   	<fileset dir="${solr-path}/lib" includes="*.jar"></fileset>
   </path>
 	
diff --git a/contrib/extraction/build.xml b/contrib/extraction/build.xml
index 32bf658..5909408 100644
--- a/contrib/extraction/build.xml
+++ b/contrib/extraction/build.xml
@@ -30,8 +30,8 @@
   </description>
 
   <path id="common.classpath">
-    <pathelement location="${solr-path}/build/common" />
-    <pathelement location="${solr-path}/build/core" />
+    <pathelement location="${solr-path}/build/solr" />
+    <pathelement location="${solr-path}/build/solrj" />
     <fileset dir="lib" includes="*.jar"/>
     <fileset dir="${solr-path}/lib" includes="*.jar"></fileset>
   </path>
diff --git a/contrib/velocity/build.xml b/contrib/velocity/build.xml
index a6f9ad3..9a3cb49 100644
--- a/contrib/velocity/build.xml
+++ b/contrib/velocity/build.xml
@@ -28,8 +28,8 @@
   </description>
 
   <path id="common.classpath">
-  	<pathelement location="${solr-path}/build/common" />
-  	<pathelement location="${solr-path}/build/core" />
+  	<pathelement location="${solr-path}/build/solrj" />
+  	<pathelement location="${solr-path}/build/solr" />
     <fileset dir="src/main/solr/lib" includes="*.jar"/>
     <fileset dir="${solr-path}/lib" includes="*.jar"></fileset>
   </path>
diff --git a/lib/commons-httpclient-3.1.jar b/lib/commons-httpclient-3.1.jar
new file mode 100644
index 0000000..3c261e7
--- /dev/null
+++ b/lib/commons-httpclient-3.1.jar
@@ -0,0 +1,2 @@
+AnyObjectId[7c59774aed4f5dd08778489aaad565690ff7c132] was removed in git history.
+Apache SVN contains full history.
\ No newline at end of file
diff --git a/lib/jcl-over-slf4j-1.5.5.jar b/lib/jcl-over-slf4j-1.5.5.jar
new file mode 100644
index 0000000..9a5e656
--- /dev/null
+++ b/lib/jcl-over-slf4j-1.5.5.jar
@@ -0,0 +1,2 @@
+AnyObjectId[6b8ddd6339582fa3e6bce99a74f4186918f3f4d8] was removed in git history.
+Apache SVN contains full history.
\ No newline at end of file
diff --git a/src/common/org/apache/solr/common/ResourceLoader.java b/src/common/org/apache/solr/common/ResourceLoader.java
new file mode 100644
index 0000000..381d261
--- /dev/null
+++ b/src/common/org/apache/solr/common/ResourceLoader.java
@@ -0,0 +1,47 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+/**
+ * @since solr 1.3
+ */ 
+public interface ResourceLoader
+{
+  public InputStream openResource(String resource) throws IOException;
+  
+  /**
+   * Accesses a resource by name and returns the (non comment) lines
+   * containing data.
+   *
+   * <p>
+   * A comment line is any line that starts with the character "#"
+   * </p>
+   *
+   * @param resource
+   * @return a list of non-blank non-comment lines with whitespace trimmed
+   * from front and back.
+   * @throws IOException
+   */
+  public List<String> getLines(String resource) throws IOException;
+  
+  public Object newInstance(String cname, String ... subpackages);
+}
\ No newline at end of file
diff --git a/src/common/org/apache/solr/common/SolrDocument.java b/src/common/org/apache/solr/common/SolrDocument.java
new file mode 100644
index 0000000..2900a7f
--- /dev/null
+++ b/src/common/org/apache/solr/common/SolrDocument.java
@@ -0,0 +1,253 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+
+/**
+ * A concrete representation of a document within a Solr index.  Unlike a lucene
+ * Document, a SolrDocument may have an Object value matching the type defined in
+ * schema.xml
+ * 
+ * For indexing documents, use the SolrInputDocument that contains extra information
+ * for document and field boosting.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrDocument implements Serializable, Iterable<Map.Entry<String, Object>>
+{
+  private Map<String,Object> _fields = null;
+  
+  public SolrDocument()
+  {
+    _fields = new HashMap<String,Object>();
+  }
+
+  /**
+   * @return a list of fields defined in this document
+   */
+  public Collection<String> getFieldNames() {
+    return _fields.keySet();
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Add / Set / Remove Fields
+  ///////////////////////////////////////////////////////////////////
+
+  /**
+   * Remove all fields from the document
+   */
+  public void clear()
+  {
+    _fields.clear();
+  }
+  
+  /**
+   * Remove all fields with the name
+   */
+  public boolean removeFields(String name) 
+  {
+    return _fields.remove( name ) != null;
+  }
+
+  /**
+   * Set a field with the given object.  If the object is an Array, it will 
+   * set multiple fields with the included contents.  This will replace any existing 
+   * field with the given name
+   */
+  @SuppressWarnings("unchecked")
+  public void setField(String name, Object value) 
+  {
+    if( value instanceof Object[] ) {
+      value = new ArrayList(Arrays.asList( (Object[])value ));
+    }
+    else if( value instanceof Collection ) {
+      // nothing
+    }
+    else if( value instanceof Iterable ) {
+      ArrayList<Object> lst = new ArrayList<Object>();
+      for( Object o : (Iterable)value ) {
+        lst.add( o );
+      }
+      value = lst;
+    }
+    _fields.put(name, value);
+  }
+  
+  /**
+   * This will add a field to the document.  If fields already exist with this name
+   * it will append the collection
+   */
+  @SuppressWarnings("unchecked")
+  public void addField(String name, Object value) 
+  { 
+    Object existing = _fields.get(name);
+    if (existing == null) {
+      this.setField( name, value );
+      return;
+    }
+    
+    Collection<Object> vals = null;
+    if( existing instanceof Collection ) {
+      vals = (Collection<Object>)existing;
+    }
+    else {
+      vals = new ArrayList<Object>( 3 );
+      vals.add( existing );
+    }
+    
+    // Add the values to the collection
+    if( value instanceof Iterable ) {
+      for( Object o : (Iterable<Object>)value ) {
+        vals.add( o );
+      }
+    }
+    else if( value instanceof Object[] ) {
+      for( Object o : (Object[])value ) {
+        vals.add( o );
+      }
+    }
+    else {
+      vals.add( value );
+    }
+    _fields.put( name, vals );
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Get the field values
+  ///////////////////////////////////////////////////////////////////
+
+  /**
+   * returns the first value for a field
+   */
+  public Object getFirstValue(String name) {
+    Object v = _fields.get( name );
+    if (v == null || !(v instanceof Collection)) return v;
+    Collection c = (Collection)v;
+    if (c.size() > 0 ) {
+      return c.iterator().next();
+    }
+    return null;
+  }
+  
+  /**
+   * Get the value or collection of values for a given field.  
+   */
+  public Object getFieldValue(String name) {
+    return _fields.get( name );
+  }
+
+  /**
+   * Get a collection of values for a given field name
+   */
+  @SuppressWarnings("unchecked")
+  public Collection<Object> getFieldValues(String name) {
+    Object v = _fields.get( name );
+    if( v instanceof Collection ) {
+      return (Collection<Object>)v;
+    }
+    if( v != null ) {
+      ArrayList<Object> arr = new ArrayList<Object>(1);
+      arr.add( v );
+      return arr;
+    }
+    return null;
+  }
+    
+  @Override
+  public String toString()
+  {
+    return "SolrDocument["+_fields.toString()+"]";
+  }
+
+  /**
+   * Iterate of String->Object keys
+   */
+  public Iterator<Entry<String, Object>> iterator() {
+    return _fields.entrySet().iterator();
+  }
+  
+  //-----------------------------------------------------------------------------------------
+  // JSTL Helpers
+  //-----------------------------------------------------------------------------------------
+  
+  /**
+   * Expose a Map interface to the solr field value collection.
+   */
+  public Map<String,Collection<Object>> getFieldValuesMap()
+  {
+    return new Map<String,Collection<Object>>() {
+      /** Get the field Value */
+      public Collection<Object> get(Object key) { 
+        return getFieldValues( (String)key ); 
+      }
+      
+      // Easily Supported methods
+      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
+      public Set<String>  keySet()           { return _fields.keySet();  }
+      public int          size()             { return _fields.size();    }
+      public boolean      isEmpty()          { return _fields.isEmpty(); }
+
+      // Unsupported operations.  These are not necessary for JSTL
+      public void clear() { throw new UnsupportedOperationException(); }
+      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
+      public Set<java.util.Map.Entry<String, Collection<Object>>> entrySet() {throw new UnsupportedOperationException();}
+      public void putAll(Map<? extends String, ? extends Collection<Object>> t) {throw new UnsupportedOperationException();}
+      public Collection<Collection<Object>> values() {throw new UnsupportedOperationException();}
+      public Collection<Object> put(String key, Collection<Object> value) {throw new UnsupportedOperationException();}
+      public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();}      
+    };
+  }
+
+  /**
+   * Expose a Map interface to the solr fields.  This function is useful for JSTL
+   */
+  public Map<String,Object> getFieldValueMap() {
+    return new Map<String,Object>() {
+      /** Get the field Value */
+      public Object get(Object key) { 
+        return getFirstValue( (String)key ); 
+      }
+      
+      // Easily Supported methods
+      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
+      public Set<String>  keySet()           { return _fields.keySet();  }
+      public int          size()             { return _fields.size();    }
+      public boolean      isEmpty()          { return _fields.isEmpty(); }
+
+      // Unsupported operations.  These are not necessary for JSTL
+      public void clear() { throw new UnsupportedOperationException(); }
+      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
+      public Set<java.util.Map.Entry<String, Object>> entrySet() {throw new UnsupportedOperationException();}
+      public void putAll(Map<? extends String, ? extends Object> t) {throw new UnsupportedOperationException();}
+      public Collection<Object> values() {throw new UnsupportedOperationException();}
+      public Collection<Object> put(String key, Object value) {throw new UnsupportedOperationException();}
+      public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();}      
+   };
+  }
+}
diff --git a/src/common/org/apache/solr/common/SolrDocumentList.java b/src/common/org/apache/solr/common/SolrDocumentList.java
new file mode 100644
index 0000000..273cd80
--- /dev/null
+++ b/src/common/org/apache/solr/common/SolrDocumentList.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.util.ArrayList;
+
+
+/**
+ * Represent a list of SolrDocuments returned from a search.  This includes
+ * position and offset information.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrDocumentList extends ArrayList<SolrDocument>
+{ 
+  private long numFound = 0;
+  private long start = 0;
+  private Float maxScore = null;
+  
+  public Float getMaxScore() {
+    return maxScore;
+  }
+  
+  public void setMaxScore(Float maxScore) {
+    this.maxScore = maxScore;
+  }
+  
+  public long getNumFound() {
+    return numFound;
+  }
+  
+  public void setNumFound(long numFound) {
+    this.numFound = numFound;
+  }
+  
+  public long getStart() {
+    return start;
+  }
+  
+  public void setStart(long start) {
+    this.start = start;
+  }
+
+  public String toString() {
+    return "{numFound="+numFound
+            +",start="+start
+            + (maxScore!=null ? ""+maxScore : "")
+            +",docs="+super.toString()
+            +"}";
+  }
+}
diff --git a/src/common/org/apache/solr/common/SolrException.java b/src/common/org/apache/solr/common/SolrException.java
new file mode 100644
index 0000000..bdc516c
--- /dev/null
+++ b/src/common/org/apache/solr/common/SolrException.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.io.CharArrayWriter;
+import java.io.PrintWriter;
+
+/**
+ * @version $Id$
+ */
+public class SolrException extends RuntimeException {
+  
+  /**
+   * @since solr 1.2
+   */
+  public enum ErrorCode {
+    BAD_REQUEST( 400 ),
+    UNAUTHORIZED( 401 ),
+    FORBIDDEN( 403 ),
+    NOT_FOUND( 404 ),
+    SERVER_ERROR( 500 ),
+    SERVICE_UNAVAILABLE( 503 ); 
+    
+    final int code;
+    
+    private ErrorCode( int c )
+    {
+      code = c;
+    }
+  };
+  
+  public boolean logged=false;
+
+  public SolrException(ErrorCode code, String msg) {
+    super(msg);
+    this.code=code.code;
+  }
+  
+  public SolrException(ErrorCode code, String msg, boolean alreadyLogged) {
+    super(msg);
+    this.code=code.code;
+    this.logged=alreadyLogged;
+  }
+
+  public SolrException(ErrorCode code, String msg, Throwable th, boolean alreadyLogged) {
+    super(msg,th);
+    this.code=code.code;
+    logged=alreadyLogged;
+  }
+
+  public SolrException(ErrorCode code, String msg, Throwable th) {
+    this(code,msg,th,true);
+  }
+
+  public SolrException(ErrorCode code, Throwable th) {
+    super(th);
+    this.code=code.code;
+    logged=true;
+  }
+  
+  /**
+   * @deprecated Use {@link #SolrException(ErrorCode,String)}.
+   */
+  @Deprecated
+  public SolrException(int code, String msg) {
+    super(msg);
+    this.code=code;
+  }
+  
+  /**
+   * @deprecated Use {@link #SolrException(ErrorCode,String,boolean)}.
+   */
+  @Deprecated
+  public SolrException(int code, String msg, boolean alreadyLogged) {
+    super(msg);
+    this.code=code;
+    this.logged=alreadyLogged;
+  }
+
+  /**
+   * @deprecated Use {@link #SolrException(ErrorCode,String,Throwable,boolean)}.
+   */
+  @Deprecated
+  public SolrException(int code, String msg, Throwable th, boolean alreadyLogged) {
+    super(msg,th);
+    this.code=code;
+    logged=alreadyLogged;
+  }
+
+  /**
+   * @deprecated Use {@link #SolrException(ErrorCode,String,Throwable)}.
+   */
+  @Deprecated
+  public SolrException(int code, String msg, Throwable th) {
+    this(code,msg,th,true);
+  }
+
+  /**
+   * @deprecated Use {@link #SolrException(ErrorCode,Throwable)}.
+   */
+  @Deprecated
+  public SolrException(int code, Throwable th) {
+    super(th);
+    this.code=code;
+    logged=true;
+  }
+
+  int code=0;
+  public int code() { return code; }
+
+
+
+
+  public void log(Logger log) { log(log,this); }
+  public static void log(Logger log, Throwable e) {
+    log.error(toStr(e));
+    if (e instanceof SolrException) {
+      ((SolrException)e).logged = true;
+    }
+  }
+
+  public static void log(Logger log, String msg, Throwable e) {
+    log.error(msg + ':' + toStr(e));
+    if (e instanceof SolrException) {
+      ((SolrException)e).logged = true;
+    }
+  }
+
+  public static void logOnce(Logger log, String msg, Throwable e) {
+    if (e instanceof SolrException) {
+      if(((SolrException)e).logged) return;
+    }
+    if (msg!=null) log(log,msg,e);
+    else log(log,e);
+  }
+
+
+  // public String toString() { return toStr(this); }  // oops, inf loop
+  @Override
+  public String toString() { return super.toString(); }
+
+  public static String toStr(Throwable e) {
+    CharArrayWriter cw = new CharArrayWriter();
+    PrintWriter pw = new PrintWriter(cw);
+    e.printStackTrace(pw);
+    pw.flush();
+    return cw.toString();
+
+/** This doesn't work for some reason!!!!!
+    StringWriter sw = new StringWriter();
+    PrintWriter pw = new PrintWriter(sw);
+    e.printStackTrace(pw);
+    pw.flush();
+    System.out.println("The STRING:" + sw.toString());
+    return sw.toString();
+**/
+  }
+
+}
diff --git a/src/common/org/apache/solr/common/SolrInputDocument.java b/src/common/org/apache/solr/common/SolrInputDocument.java
new file mode 100644
index 0000000..b0abf53
--- /dev/null
+++ b/src/common/org/apache/solr/common/SolrInputDocument.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Collection;
+
+/**
+ * Represent the field and boost information needed to construct and index
+ * a Lucene Document.  Like the SolrDocument, the field values should
+ * match those specified in schema.xml 
+ *
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrInputDocument implements Iterable<SolrInputField>, Serializable
+{
+  private final Map<String,SolrInputField> _fields;
+  private float _documentBoost = 1.0f;
+
+  public SolrInputDocument()
+  {
+    _fields = new LinkedHashMap<String,SolrInputField>();
+  }
+  
+  /**
+   * Remove all fields and boosts from the document
+   */
+  public void clear()
+  {
+    if( _fields != null ) {
+      _fields.clear();
+    }
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Add / Set fields
+  ///////////////////////////////////////////////////////////////////
+
+  /** 
+   * Add a field with implied null value for boost.
+   * 
+   * @see #addField(String, Object, float)
+   * @param name name of the field to add
+   * @param value value of the field
+   */
+  public void addField(String name, Object value) 
+  {
+    addField(name, value, 1.0f );
+  }
+  
+  /** Get the first value for a field.
+   * 
+   * @param name name of the field to fetch
+   * @return first value of the field or null if not present
+   */
+  public Object getFieldValue(String name) 
+  {
+    SolrInputField field = getField(name);
+    Object o = null;
+    if (field!=null) o = field.getFirstValue();
+    return o;
+  }
+  
+  /** Get all the values for a field.
+   * 
+   * @param name name of the field to fetch
+   * @return value of the field or null if not set
+   */
+  public Collection<Object> getFieldValues(String name) 
+  {
+    SolrInputField field = getField(name);
+    if (field!=null) {
+      return field.getValues();
+    }
+    return null;
+  } 
+  
+  /** Get all field names.
+   * 
+   * @return Set of all field names.
+   */
+  public Collection<String> getFieldNames() 
+  {
+    return _fields.keySet();
+  }
+  
+  /** Set a field with implied null value for boost.
+   * 
+   * @see #setField(String, Object, float)
+   * @param name name of the field to set
+   * @param value value of the field
+   */
+  public void setField(String name, Object value) 
+  {
+    setField(name, value, 1.0f );
+  }
+  
+  public void setField(String name, Object value, float boost ) 
+  {
+    SolrInputField field = new SolrInputField( name );
+    _fields.put( name, field );
+    field.setValue( value, boost );
+  }
+
+  /**
+   * Remove all fields and boosts from the document
+   */
+  public void addField(String name, Object value, float boost ) 
+  {
+    SolrInputField field = _fields.get( name );
+    if( field == null || field.value == null ) {
+      setField(name, value, boost);
+    }
+    else {
+      field.addValue( value, boost );
+    }
+  }
+
+  /**
+   * Remove a field from the document
+   * 
+   * @param name The field name whose field is to be removed from the document
+   * @return the previous field with <tt>name</tt>, or
+   *         <tt>null</tt> if there was no field for <tt>key</tt>.
+   */
+  public SolrInputField removeField(String name) {
+    return _fields.remove( name );
+  }
+
+  ///////////////////////////////////////////////////////////////////
+  // Get the field values
+  ///////////////////////////////////////////////////////////////////
+
+  public SolrInputField getField( String field )
+  {
+    return _fields.get( field );
+  }
+
+  public Iterator<SolrInputField> iterator() {
+    return _fields.values().iterator();
+  }
+  
+  public float getDocumentBoost() {
+    return _documentBoost;
+  }
+
+  public void setDocumentBoost(float documentBoost) {
+    _documentBoost = documentBoost;
+  }
+  
+  @Override
+  public String toString()
+  {
+    return "SolrInputDocument["+_fields+"]";
+  }
+}
diff --git a/src/common/org/apache/solr/common/SolrInputField.java b/src/common/org/apache/solr/common/SolrInputField.java
new file mode 100644
index 0000000..5e9102c
--- /dev/null
+++ b/src/common/org/apache/solr/common/SolrInputField.java
@@ -0,0 +1,202 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrInputField implements Iterable<Object>, Serializable
+{
+  String name;
+  Object value = null; 
+  float boost = 1.0f;
+  
+  public SolrInputField( String n )
+  {
+    this.name = n;
+  }
+
+  //---------------------------------------------------------------
+  //---------------------------------------------------------------
+
+  /**
+   * Set the value for a field.  Arrays will be converted to a collection.
+   */
+  public void setValue(Object v, float b) {
+    boost = b;
+
+    if( v instanceof Object[] ) {
+      Object[] arr = (Object[])v;
+      Collection<Object> c = new ArrayList<Object>( arr.length );
+      for( Object o : arr ) {
+        c.add( o );
+      }
+      value = c;
+    }
+    else {
+      value = v;
+    }
+  }
+
+  /**
+   * Add values to a field.  if the added value is a collection, each value
+   * will be added individually
+   */
+  @SuppressWarnings("unchecked")
+  public void addValue(Object v, float b) {
+    if( value == null ) {
+      setValue(v, b);
+      return;
+    }
+    
+    // The lucene API and solr XML field specification make it possible to set boosts
+    // on multi-value fields even though lucene indexing does not support this.
+    // To keep behavior consistent with what happens in the lucene index, we accumulate
+    // the product of all boosts specified for this field.
+    boost *= b;
+    
+    Collection<Object> vals = null;
+    if( value instanceof Collection ) {
+      vals = (Collection<Object>)value;
+    }
+    else {
+      vals = new ArrayList<Object>( 3 );
+      vals.add( value );
+      value = vals;
+    }
+    
+    // Add the new values to a collection
+    if( v instanceof Iterable ) {
+      for( Object o : (Iterable<Object>)v ) {
+        vals.add( o );
+      }
+    }
+    else if( v instanceof Object[] ) {
+      for( Object o : (Object[])v ) {
+        vals.add( o );
+      }
+    }
+    else {
+      vals.add( v );
+    }
+  }
+
+  //---------------------------------------------------------------
+  //---------------------------------------------------------------
+  
+  @SuppressWarnings("unchecked")
+  public Object getFirstValue() {
+    if( value instanceof Collection ) {
+      Collection c = (Collection<Object>)value;
+      if( c.size() > 0 ) {
+        return c.iterator().next();
+      }
+      return null;
+    }
+    return value;
+  }
+
+  /**
+   * @return the value for this field.  If the field has multiple values, this
+   * will be a collection.
+   */
+  public Object getValue() {
+    return value;
+  }
+
+  /**
+   * @return the values for this field.  This will return a collection even
+   * if the field is not multi-valued
+   */
+  @SuppressWarnings("unchecked")
+  public Collection<Object> getValues() {
+    if( value instanceof Collection ) {
+      return (Collection<Object>)value;
+    }
+    if( value != null ) {
+      Collection<Object> vals = new ArrayList<Object>(1);
+      vals.add( value );
+      return vals;
+    }
+    return null;
+  }
+
+  /**
+   * @return the number of values for this field
+   */
+  public int getValueCount() {
+    if( value instanceof Collection ) {
+      return ((Collection)value).size();
+    }
+    return (value == null) ? 0 : 1;
+  }
+  
+  //---------------------------------------------------------------
+  //---------------------------------------------------------------
+  
+  public float getBoost() {
+    return boost;
+  }
+
+  public void setBoost(float boost) {
+    this.boost = boost;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  @SuppressWarnings("unchecked")
+  public Iterator<Object> iterator() {
+    if( value instanceof Collection ) {
+      return ((Collection)value).iterator();
+    }
+    return new Iterator<Object>() {
+      boolean nxt = (value!=null);
+      
+      public boolean hasNext() {
+        return nxt;
+      }
+
+      public Object next() {
+        nxt = false;
+        return value;
+      }
+
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+  }
+
+  @Override
+  public String toString()
+  {
+    return name + "("+boost+")={" + value + "}";
+  }
+}
diff --git a/src/common/org/apache/solr/common/luke/FieldFlag.java b/src/common/org/apache/solr/common/luke/FieldFlag.java
new file mode 100644
index 0000000..63d8356
--- /dev/null
+++ b/src/common/org/apache/solr/common/luke/FieldFlag.java
@@ -0,0 +1,67 @@
+package org.apache.solr.common.luke;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @version $Id: AdminHandlers.java 608150 2008-01-02 17:15:30Z ryan $
+ * @since solr 1.3
+ */
+public enum FieldFlag {
+  INDEXED('I', "Indexed"), 
+  TOKENIZED('T', "Tokenized"), 
+  STORED('S', "Stored"), 
+  MULTI_VALUED('M', "Multivalued"),
+  TERM_VECTOR_STORED('V', "TermVector Stored"), 
+  TERM_VECTOR_OFFSET('o', "Store Offset With TermVector"),
+  TERM_VECTOR_POSITION('p', "Store Position With TermVector"),
+  OMIT_NORMS('O', "Omit Norms"), 
+  LAZY('L', "Lazy"), 
+  BINARY('B', "Binary"), 
+  COMPRESSED('C', "Compressed"),
+  SORT_MISSING_FIRST('f', "Sort Missing First"), 
+  SORT_MISSING_LAST('l', "Sort Missing Last");
+
+  private final char abbreviation;
+  private final String display;
+
+  FieldFlag(char abbreviation, String display) {
+    this.abbreviation = abbreviation;
+    this.display = display;
+    this.display.intern();//QUESTION:  Need we bother here?
+  }
+
+  public static FieldFlag getFlag(char abbrev){
+    FieldFlag result = null;
+    FieldFlag [] vals = FieldFlag.values();
+    for (int i = 0; i < vals.length; i++) {
+      if (vals[i].getAbbreviation() == abbrev){
+        result = vals[i];
+        break;
+      }
+    }
+    return result;
+  }
+
+  public char getAbbreviation() {
+    return abbreviation;
+  }
+
+  public String getDisplay() {
+    return display;
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/AppendedSolrParams.java b/src/common/org/apache/solr/common/params/AppendedSolrParams.java
new file mode 100644
index 0000000..f0d5ed5
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/AppendedSolrParams.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * SolrParams wrapper which acts similar to DefaultSolrParams except that
+ * it "appends" the values of multi-value params from both sub instances, so
+ * that all of the values are returned. 
+ */
+public class AppendedSolrParams extends DefaultSolrParams {
+  public AppendedSolrParams(SolrParams main, SolrParams extra) {
+    super(main, extra);
+  }
+
+  @Override
+  public String[] getParams(String param) {
+    String[] main = params.getParams(param);
+    String[] extra = defaults.getParams(param);
+    if (null == extra || 0 == extra.length) {
+      return main;
+    }
+    if (null == main || 0 == main.length) {
+      return extra;
+    }
+    String[] result = new String[main.length + extra.length];
+    System.arraycopy(main,0,result,0,main.length);
+    System.arraycopy(extra,0,result,main.length,extra.length);
+    return result;
+  }
+
+  @Override
+  public String toString() {
+    return "{main("+params+"),extra("+defaults+")}";
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/CommonParams.java b/src/common/org/apache/solr/common/params/CommonParams.java
new file mode 100755
index 0000000..4f33c4d
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/CommonParams.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+
+/**
+ * Parameters used across many handlers
+ */
+public interface CommonParams {
+
+  /** the query type - which query handler should handle the request */
+  public static final String QT ="qt";
+  
+  /** the response writer type - the format of the response */
+  public static final String WT ="wt";
+  
+  /** query string */
+  public static final String Q ="q";
+  
+  /** sort order */
+  public static final String SORT ="sort";
+  
+  /** Lucene query string(s) for filtering the results without affecting scoring */
+  public static final String FQ ="fq";
+  
+  /** zero based offset of matching documents to retrieve */
+  public static final String START ="start";
+  
+  /** number of documents to return starting at "start" */
+  public static final String ROWS ="rows";
+  
+  /** stylesheet to apply to XML results */
+  public static final String XSL ="xsl";
+  
+  /** stylesheet to apply to XML results */
+  public static final String VERSION ="version";
+  
+  /** query and init param for field list */
+  public static final String FL = "fl";
+  
+  /** default query field */
+  public static final String DF = "df";
+  
+  /** whether to include debug data */
+  public static final String DEBUG_QUERY = "debugQuery";
+  
+  /** another query to explain against */
+  public static final String EXPLAIN_OTHER = "explainOther";
+  
+
+  /** If the content stream should come from a URL (using URLConnection) */
+  public static final String STREAM_URL = "stream.url";
+
+  /** If the content stream should come from a File (using FileReader) */
+  public static final String STREAM_FILE = "stream.file";
+  
+  /** If the content stream should come directly from a field */
+  public static final String STREAM_BODY = "stream.body";
+  
+  /** 
+   * Explicitly set the content type for the input stream
+   * If multiple streams are specified, the explicit contentType
+   * will be used for all of them.  
+   */
+  public static final String STREAM_CONTENTTYPE = "stream.contentType";
+  
+  /**
+   * Timeout value in milliseconds.  If not set, or the value is <= 0, there is no timeout.
+   */
+  public static final String TIME_ALLOWED = "timeAllowed";
+  
+  /** 'true' if the header should include the handler name */
+  public static final String HEADER_ECHO_HANDLER = "echoHandler";
+  
+  /** include the parameters in the header **/
+  public static final String HEADER_ECHO_PARAMS = "echoParams";
+
+  /** include header in the response */
+  public static final String OMIT_HEADER = "omitHeader";
+
+  /** valid values for: <code>echoParams</code> */
+  public enum EchoParamStyle {
+    EXPLICIT,
+    ALL,
+    NONE;
+    
+    public static EchoParamStyle get( String v ) {
+      if( v != null ) {
+        v = v.toUpperCase();
+        if( v.equals( "EXPLICIT" ) ) {
+          return EXPLICIT;
+        }
+        if( v.equals( "ALL") ) {
+          return ALL;
+        }
+        if( v.equals( "NONE") ) {  // the same as nothing...
+          return NONE;
+        }
+      }
+      return null;
+    }
+  };
+}
+
diff --git a/src/common/org/apache/solr/common/params/CoreAdminParams.java b/src/common/org/apache/solr/common/params/CoreAdminParams.java
new file mode 100644
index 0000000..1d85b2f
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/CoreAdminParams.java
@@ -0,0 +1,75 @@
+/**
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * @since solr 1.3
+ */
+public interface CoreAdminParams 
+{
+  /** What Core are we talking about **/
+  public final static String CORE = "core";
+
+  /** Persistent -- should it save the cores state? **/
+  public final static String PERSISTENT = "persistent";
+  
+  /** If you rename something, what is the new name **/
+  public final static String NAME = "name";
+
+  /** Name of the other core in actions involving 2 cores **/
+  public final static String OTHER = "other";
+
+  /** What action **/
+  public final static String ACTION = "action";
+  
+  /** If you specify a schema, what is its name **/
+  public final static String SCHEMA = "schema";
+  
+  /** If you specify a config, what is its name **/
+  public final static String CONFIG = "config";
+  
+  /** Specifies a core instance dir. */
+  public final static String INSTANCE_DIR = "instanceDir";
+
+  /** If you specify a file, what is its name **/
+  public final static String FILE = "file";
+  
+  public enum CoreAdminAction {
+    STATUS,  
+    LOAD,
+    UNLOAD,
+    RELOAD,
+    CREATE,
+    PERSIST,
+    SWAP,
+    RENAME,
+    ALIAS;
+    
+    public static CoreAdminAction get( String p )
+    {
+      if( p != null ) {
+        try {
+          return CoreAdminAction.valueOf( p.toUpperCase() );
+        }
+        catch( Exception ex ) {}
+      }
+      return null; 
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/common/org/apache/solr/common/params/DefaultSolrParams.java b/src/common/org/apache/solr/common/params/DefaultSolrParams.java
new file mode 100644
index 0000000..b71d9ca
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/DefaultSolrParams.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import java.util.Iterator;
+
+import org.apache.solr.common.util.IteratorChain;
+
+/**
+ * @version $Id$
+ */
+public class DefaultSolrParams extends SolrParams {
+  protected final SolrParams params;
+  protected final SolrParams defaults;
+
+  public DefaultSolrParams(SolrParams params, SolrParams defaults) {
+    this.params = params;
+    this.defaults = defaults;
+  }
+
+  @Override
+  public String get(String param) {
+    String val = params.get(param);
+    return val!=null ? val : defaults.get(param);
+  }
+
+  @Override
+  public String[] getParams(String param) {
+    String[] vals = params.getParams(param);
+    return vals!=null ? vals : defaults.getParams(param);
+  }
+
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    final IteratorChain<String> c = new IteratorChain<String>();
+    c.addIterator(defaults.getParameterNamesIterator());
+    c.addIterator(params.getParameterNamesIterator());
+    return c;
+  }
+
+  @Override
+  public String toString() {
+    return "{params("+params+"),defaults("+defaults+")}";
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/DisMaxParams.java b/src/common/org/apache/solr/common/params/DisMaxParams.java
new file mode 100755
index 0000000..6354225
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/DisMaxParams.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+    
+
+/**
+ * A collection of params used in DisMaxRequestHandler,
+ * both for Plugin initialization and for Requests.
+ */
+public interface DisMaxParams {
+  
+  /** query and init param for tiebreaker value */
+  public static String TIE = "tie";
+  
+  /** query and init param for query fields */
+  public static String QF = "qf";
+  
+  /** query and init param for phrase boost fields */
+  public static String PF = "pf";
+  
+  /** query and init param for MinShouldMatch specification */
+  public static String MM = "mm";
+  
+  /**
+   * query and init param for Phrase Slop value in phrase
+   * boost query (in pf fields)
+   */
+  public static String PS = "ps";
+  
+  /**
+   * query and init param for phrase Slop value in phrases
+   * explicitly included in the user's query string ( in qf fields)
+   */
+  public static String QS = "qs";
+  
+  /** query and init param for boosting query */
+  public static String BQ = "bq";
+  
+  /** query and init param for boosting functions */
+  public static String BF = "bf";
+  
+  /**
+   * Alternate query (expressed in Solr QuerySyntax)
+   * to use if main query (q) is empty
+   */
+  public static String ALTQ = "q.alt";
+  
+  /** query and init param for field list */
+  public static String GEN = "gen";
+}
diff --git a/src/common/org/apache/solr/common/params/FacetParams.java b/src/common/org/apache/solr/common/params/FacetParams.java
new file mode 100644
index 0000000..b4b60b4
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/FacetParams.java
@@ -0,0 +1,181 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.SolrException;
+
+
+/**
+ * Facet parameters
+ */
+public interface FacetParams {
+
+  /**
+   * Should facet counts be calculated?
+   */
+  public static final String FACET = "facet";
+
+  /** What method should be used to do the faceting */
+  public static final String FACET_METHOD = FACET + ".method";
+
+  /** Value for FACET_METHOD param to indicate that Solr should enumerate over terms
+   * in a field to calculate the facet counts.
+   */
+  public static final String FACET_METHOD_enum = "enum";
+
+  /** Value for FACET_METHOD param to indicate that Solr should enumerate over documents
+   * and count up terms by consulting an uninverted representation of the field values
+   * (such as the FieldCache used for sorting).
+   */
+  public static final String FACET_METHOD_fc = "fc";
+  
+  /**
+   * Any lucene formated queries the user would like to use for
+   * Facet Constraint Counts (multi-value)
+   */
+  public static final String FACET_QUERY = FACET + ".query";
+  /**
+   * Any field whose terms the user wants to enumerate over for
+   * Facet Constraint Counts (multi-value)
+   */
+  public static final String FACET_FIELD = FACET + ".field";
+
+  /**
+   * The offset into the list of facets.
+   * Can be overridden on a per field basis.
+   */
+  public static final String FACET_OFFSET = FACET + ".offset";
+
+  /**
+   * Numeric option indicating the maximum number of facet field counts
+   * be included in the response for each field - in descending order of count.
+   * Can be overridden on a per field basis.
+   */
+  public static final String FACET_LIMIT = FACET + ".limit";
+
+  /**
+   * Numeric option indicating the minimum number of hits before a facet should
+   * be included in the response.  Can be overridden on a per field basis.
+   */
+  public static final String FACET_MINCOUNT = FACET + ".mincount";
+
+  /**
+   * Boolean option indicating whether facet field counts of "0" should 
+   * be included in the response.  Can be overridden on a per field basis.
+   */
+  public static final String FACET_ZEROS = FACET + ".zeros";
+
+  /**
+   * Boolean option indicating whether the response should include a 
+   * facet field count for all records which have no value for the 
+   * facet field. Can be overridden on a per field basis.
+   */
+  public static final String FACET_MISSING = FACET + ".missing";
+
+  /**
+   * String option: "count" causes facets to be sorted
+   * by the count, "lex" results in lexicographical order.
+   */
+  public static final String FACET_SORT = FACET + ".sort";
+
+  public static final String FACET_SORT_COUNT = "count";
+  public static final String FACET_SORT_COUNT_LEGACY = "true";
+  public static final String FACET_SORT_LEX = "lex";
+  public static final String FACET_SORT_LEX_LEGACY = "false";
+
+  /**
+   * Only return constraints of a facet field with the given prefix.
+   */
+  public static final String FACET_PREFIX = FACET + ".prefix";
+
+ /**
+   * When faceting by enumerating the terms in a field,
+   * only use the filterCache for terms with a df >= to this parameter.
+   */
+  public static final String FACET_ENUM_CACHE_MINDF = FACET + ".enum.cache.minDf";
+  /**
+   * Any field whose terms the user wants to enumerate over for
+   * Facet Contraint Counts (multi-value)
+   */
+  public static final String FACET_DATE = FACET + ".date";
+  /**
+   * Date string indicating the starting point for a date facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_START = FACET_DATE + ".start";
+  /**
+   * Date string indicating the endinging point for a date facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_END = FACET_DATE + ".end";
+  /**
+   * Date Math string indicating the interval of sub-ranges for a date
+   * facet range.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_GAP = FACET_DATE + ".gap";
+  /**
+   * Boolean indicating how counts should be computed if the range
+   * between 'start' and 'end' is not evenly divisible by 'gap'.  If
+   * this value is true, then all counts of ranges involving the 'end'
+   * point will use the exact endpoint specified -- this includes the
+   * 'between' and 'after' counts as well as the last range computed
+   * using the 'gap'.  If the value is false, then 'gap' is used to
+   * compute the effective endpoint closest to the 'end' param which
+   * results in the range between 'start' and 'end' being evenly
+   * divisible by 'gap'.
+   * The default is false.
+   * Can be overriden on a per field basis.
+   */
+  public static final String FACET_DATE_HARD_END = FACET_DATE + ".hardend";
+  /**
+   * String indicating what "other" ranges should be computed for a
+   * date facet range (multi-value).
+   * Can be overriden on a per field basis.
+   * @see FacetDateOther
+   */
+  public static final String FACET_DATE_OTHER = FACET_DATE + ".other";
+
+  /**
+   * An enumeration of the legal values for FACET_DATE_OTHER...
+   * <ul>
+   * <li>before = the count of matches before the start date</li>
+   * <li>after = the count of matches after the end date</li>
+   * <li>between = the count of all matches between start and end</li>
+   * <li>all = all of the above (default value)</li>
+   * <li>none = no additional info requested</li>
+   * </ul>
+   * @see #FACET_DATE_OTHER
+   */
+  public enum FacetDateOther {
+    BEFORE, AFTER, BETWEEN, ALL, NONE;
+    public String toString() { return super.toString().toLowerCase(); }
+    public static FacetDateOther get(String label) {
+      try {
+        return valueOf(label.toUpperCase());
+      } catch (IllegalArgumentException e) {
+        throw new SolrException
+          (SolrException.ErrorCode.BAD_REQUEST,
+           label+" is not a valid type of 'other' date facet information",e);
+      }
+    }
+  }
+  
+
+}
+
diff --git a/src/common/org/apache/solr/common/params/HighlightParams.java b/src/common/org/apache/solr/common/params/HighlightParams.java
new file mode 100644
index 0000000..8435bf1
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/HighlightParams.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public interface HighlightParams {
+  public static final String HIGHLIGHT   = "hl";
+  public static final String FIELDS      = HIGHLIGHT+".fl";
+  public static final String SNIPPETS    = HIGHLIGHT+".snippets";
+  public static final String FRAGSIZE    = HIGHLIGHT+".fragsize";
+  public static final String INCREMENT   = HIGHLIGHT+".increment";
+  public static final String MAX_CHARS   = HIGHLIGHT+".maxAnalyzedChars";
+  public static final String FORMATTER   = HIGHLIGHT+".formatter";
+  public static final String FRAGMENTER  = HIGHLIGHT+".fragmenter";
+  public static final String FIELD_MATCH = HIGHLIGHT+".requireFieldMatch";
+  public static final String ALTERNATE_FIELD = HIGHLIGHT+".alternateField";
+  public static final String ALTERNATE_FIELD_LENGTH = HIGHLIGHT+".maxAlternateFieldLength";
+  
+  public static final String USE_PHRASE_HIGHLIGHTER = HIGHLIGHT+".usePhraseHighlighter";
+
+  public static final String MERGE_CONTIGUOUS_FRAGMENTS = HIGHLIGHT + ".mergeContiguous";
+  // Formatter
+  public static final String SIMPLE = "simple";
+  public static final String SIMPLE_PRE  = HIGHLIGHT+"."+SIMPLE+".pre";
+  public static final String SIMPLE_POST = HIGHLIGHT+"."+SIMPLE+".post";
+
+  // Regex fragmenter
+  public static final String REGEX = "regex";
+  public static final String SLOP  = HIGHLIGHT+"."+REGEX+".slop";
+  public static final String PATTERN  = HIGHLIGHT+"."+REGEX+".pattern";
+  public static final String MAX_RE_CHARS   = HIGHLIGHT+"."+REGEX+".maxAnalyzedChars";
+}
diff --git a/src/common/org/apache/solr/common/params/MapSolrParams.java b/src/common/org/apache/solr/common/params/MapSolrParams.java
new file mode 100644
index 0000000..95c71d2
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/MapSolrParams.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.util.StrUtils;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.io.IOException;
+
+/**
+ * @version $Id$
+ */
+public class MapSolrParams extends SolrParams {
+  protected final Map<String,String> map;
+
+  public MapSolrParams(Map<String,String> map) {
+    this.map = map;
+  }
+
+  @Override
+  public String get(String name) {
+    return map.get(name);
+  }
+
+  @Override
+  public String[] getParams(String name) {
+    String val = map.get(name);
+    return val==null ? null : new String[]{val};
+  }
+
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    return map.keySet().iterator();
+  }
+
+  public Map<String,String> getMap() { return map; }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      boolean first=true;
+
+      for (Map.Entry<String,String> entry : map.entrySet()) {
+        String key = entry.getKey();
+        String val = entry.getValue();
+
+        if (!first) sb.append('&');
+        first=false;
+        sb.append(key);
+        sb.append('=');
+        StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+
+    return sb.toString();
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/ModifiableSolrParams.java b/src/common/org/apache/solr/common/params/ModifiableSolrParams.java
new file mode 100644
index 0000000..32752ac
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/ModifiableSolrParams.java
@@ -0,0 +1,212 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import java.io.IOException;
+import java.net.URLEncoder;
+import java.util.LinkedHashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * This class is similar to MultiMapSolrParams except you can edit the 
+ * parameters after it is initialized.  It has helper functions to set/add
+ * integer and boolean param values.
+ * 
+ * @since solr 1.3
+ */
+public class ModifiableSolrParams extends SolrParams 
+{
+  private Map<String,String[]> vals;
+  
+  public ModifiableSolrParams()
+  {
+    // LinkedHashMap so params show up in CGI in the same order as they are entered
+    vals = new LinkedHashMap<String, String[]>();
+  }
+
+  /** Constructs a new ModifiableSolrParams directly using the provided Map<String,String[]> */
+  public ModifiableSolrParams( Map<String,String[]> v )
+  {
+    vals = v;
+  }
+
+  /** Constructs a new ModifiableSolrParams, copying values from an existing SolrParams */
+  public ModifiableSolrParams(SolrParams params)
+  {
+    vals = new LinkedHashMap<String, String[]>();
+    if( params != null ) {
+      this.add( params );
+    }
+  }
+
+  //----------------------------------------------------------------
+  //----------------------------------------------------------------
+
+  /**
+   * Replace any existing parameter with the given name.  if val==null remove key from params completely.
+   */
+  public ModifiableSolrParams set( String name, String ... val ) {
+    if (val==null || (val.length==1 && val[0]==null)) {
+      vals.remove(name);
+    } else {
+      vals.put( name, val );
+    }
+    return this;
+  }
+  
+  public ModifiableSolrParams set( String name, int val ) {
+    set( name, String.valueOf(val) );
+    return this;
+  }
+  
+  public ModifiableSolrParams set( String name, boolean val ) {
+    set( name, String.valueOf(val) );
+    return this;
+  }
+
+  /**
+   * Add the given values to any existing name
+   */
+  public ModifiableSolrParams add( String name, String ... val ) {
+    String[] old = vals.put(name, val);
+    if( old != null ) {
+      int i =0;
+      if( val == null || val.length < 1 ) {
+        String[] both = new String[old.length+1];
+        for( String v : old ) {
+          both[i++] = v;
+        }
+        both[i++] = null;
+        vals.put( name, both );
+      }
+      else {
+        String[] both = new String[old.length+val.length];
+        for( String v : old ) {
+          both[i++] = v;
+        }
+        for( String v : val ) {
+          both[i++] = v;
+        }
+        vals.put( name, both );
+      }
+    }
+    return this;
+  }
+
+  public void add(SolrParams params)
+  {
+    Iterator<String> names = params.getParameterNamesIterator();
+    while (names.hasNext()) {
+      String name = names.next();
+      set(name, params.getParams(name));
+    }
+  }
+  
+  /**
+   * remove a field at the given name
+   */
+  public String[] remove( String name )
+  {
+    return vals.remove( name );
+  }
+  
+  /** clear all parameters */
+  public void clear()
+  {
+    vals.clear();
+  }
+  
+  /** 
+   * remove the given value for the given name
+   * 
+   * @return true if the item was removed, false if null or not present
+   */
+  public boolean remove(String name, String value) {
+     String[] tmp = vals.get(name);
+     if (tmp==null) return false;
+     for (int i=0; i<tmp.length; i++) {
+       if (tmp[i].equals(value)) {
+         String[] tmp2 = new String[tmp.length-1];
+         if (tmp2.length==0) {
+           tmp2 = null;
+           remove(name);
+         } else {
+           System.arraycopy(tmp, 0, tmp2, 0, i);
+           System.arraycopy(tmp, i+1, tmp2, i, tmp.length-i-1);
+           set(name, tmp2);
+         }
+         return true;
+       }
+     }
+     return false;
+  }
+
+  //----------------------------------------------------------------
+  //----------------------------------------------------------------
+
+  @Override
+  public String get(String param) {
+    String[] v = vals.get( param );
+    if( v!= null && v.length > 0 ) {
+      return v[0];
+    }
+    return null;
+  }
+
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    return vals.keySet().iterator();
+  }
+  
+  public Set<String> getParameterNames() {
+    return vals.keySet();
+  }
+
+  @Override
+  public String[] getParams(String param) {
+    return vals.get( param );
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      boolean first=true;
+
+      for (Map.Entry<String,String[]> entry : vals.entrySet()) {
+        String key = entry.getKey();
+        String[] valarr = entry.getValue();
+        for (String val : valarr) {
+          if (!first) sb.append('&');
+          first=false;
+          sb.append(key);
+          sb.append('=');
+          if( val != null ) {
+            sb.append( URLEncoder.encode( val, "UTF-8" ) );
+          }
+        }
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+
+    return sb.toString();
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/MoreLikeThisParams.java b/src/common/org/apache/solr/common/params/MoreLikeThisParams.java
new file mode 100644
index 0000000..9ca6ad3
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/MoreLikeThisParams.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * @since solr 1.3
+ */
+public interface MoreLikeThisParams 
+{
+  // enable more like this -- this only applies to 'StandardRequestHandler' maybe DismaxRequestHandler
+  public final static String MLT = "mlt";
+  
+  public final static String PREFIX = "mlt.";
+  
+  public final static String SIMILARITY_FIELDS     = PREFIX + "fl";
+  public final static String MIN_TERM_FREQ         = PREFIX + "mintf";
+  public final static String MIN_DOC_FREQ          = PREFIX + "mindf";
+  public final static String MIN_WORD_LEN          = PREFIX + "minwl";
+  public final static String MAX_WORD_LEN          = PREFIX + "maxwl";
+  public final static String MAX_QUERY_TERMS       = PREFIX + "maxqt";
+  public final static String MAX_NUM_TOKENS_PARSED = PREFIX + "maxntp";
+  public final static String BOOST                 = PREFIX + "boost"; // boost or not?
+  public final static String QF                    = PREFIX + "qf"; //boosting applied to mlt fields
+
+  // the /mlt request handler uses 'rows'
+  public final static String DOC_COUNT = PREFIX + "count";
+
+  // Do you want to include the original document in the results or not
+  public final static String MATCH_INCLUDE = PREFIX + "match.include";
+  
+  // If multiple docs are matched in the query, what offset do you want?
+  public final static String MATCH_OFFSET  = PREFIX + "match.offset";
+
+  // Do you want to include the original document in the results or not
+  public final static String INTERESTING_TERMS = PREFIX + "interestingTerms";  // false,details,(list or true)
+  
+  public enum TermStyle {
+    NONE,
+    LIST,
+    DETAILS;
+    
+    public static TermStyle get( String p )
+    {
+      if( p != null ) {
+        p = p.toUpperCase();
+        if( p.equals( "DETAILS" ) ) {
+          return DETAILS;
+        }
+        else if( p.equals( "LIST" ) ) {
+          return LIST;
+        }
+      }
+      return NONE; 
+    }
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/MultiMapSolrParams.java b/src/common/org/apache/solr/common/params/MultiMapSolrParams.java
new file mode 100644
index 0000000..781c1da
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/MultiMapSolrParams.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.util.StrUtils;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.io.IOException;
+
+/**
+ * @version $Id$
+ */
+public class MultiMapSolrParams extends SolrParams {
+  protected final Map<String,String[]> map;
+
+  public static void addParam(String name, String val, Map<String,String[]> map) {
+      String[] arr = map.get(name);
+      if (arr ==null) {
+        arr =new String[]{val};
+      } else {
+        String[] newarr = new String[arr.length+1];
+        System.arraycopy(arr,0,newarr,0,arr.length);
+        newarr[arr.length]=val;
+        arr =newarr;
+      }
+      map.put(name, arr);
+  }
+
+  public MultiMapSolrParams(Map<String,String[]> map) {
+    this.map = map;
+  }
+
+  @Override
+  public String get(String name) {
+    String[] arr = map.get(name);
+    return arr==null ? null : arr[0];
+  }
+
+  @Override
+  public String[] getParams(String name) {
+    return map.get(name);
+  }
+
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    return map.keySet().iterator();
+  }
+
+  public Map<String,String[]> getMap() { return map; }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      boolean first=true;
+
+      for (Map.Entry<String,String[]> entry : map.entrySet()) {
+        String key = entry.getKey();
+        String[] valarr = entry.getValue();
+
+        for (String val : valarr) {
+          if (!first) sb.append('&');
+          first=false;
+          sb.append(key);
+          sb.append('=');
+          StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
+        }
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+
+    return sb.toString();
+  }
+
+
+}
diff --git a/src/common/org/apache/solr/common/params/RequiredSolrParams.java b/src/common/org/apache/solr/common/params/RequiredSolrParams.java
new file mode 100755
index 0000000..7abf75b
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/RequiredSolrParams.java
@@ -0,0 +1,151 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import org.apache.solr.common.SolrException;
+
+import java.util.Iterator;
+
+/**
+ * This is a simple wrapper to SolrParams that will throw a 400
+ * exception if you ask for a parameter that does not exist.  Fields
+ * specified with
+ * 
+ * In short, any value you for from a <code>RequiredSolrParams</code> 
+ * will return a valid non-null value or throw a 400 exception.  
+ * (If you pass in <code>null</code> as the default value, you can 
+ * get a null return value)
+ * 
+ * @version $Id$
+ * @since solr 1.2
+ */
+public class RequiredSolrParams extends SolrParams {
+  protected final SolrParams params;
+  
+  public RequiredSolrParams(SolrParams params) {
+    this.params = params;
+  }
+
+  /** get the param from params, fail if not found **/
+  @Override
+  public String get(String param) {
+    String val = params.get(param);
+    if( val == null )  {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
+    }
+    return val;
+  }
+  
+  @Override
+  public String getFieldParam(final String field, final String param) {
+    final String fpname = fpname(field,param);
+    String val = params.get(fpname);
+    if (null == val) {
+      // don't call this.get, we want a specified exception message
+      val = params.get(param);
+      if (null == val)  {
+        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+                                 "Missing required parameter: "+fpname+
+                                 " (or default: "+param+")" );
+      }
+    }
+    return val;
+  }
+
+  @Override
+  public String[] getFieldParams(final String field, final String param) {
+    final String fpname = fpname(field,param);
+    String[] val = params.getParams(fpname);
+    if (null == val) {
+      // don't call this.getParams, we want a specified exception message
+      val = params.getParams(param);
+      if (null == val)  {
+        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
+                                 "Missing required parameter: "+fpname+
+                                 " (or default: "+param+")" );
+      }
+    }
+    return val;
+  }
+
+  
+  @Override
+  public String[] getParams(String param) {
+    String[] vals = params.getParams(param);
+    if( vals == null || vals.length == 0 ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
+    }
+    return vals;
+  }
+  
+  /** returns an Iterator over the parameter names */
+  @Override
+  public Iterator<String> getParameterNamesIterator() {
+    return params.getParameterNamesIterator();
+  }
+
+  @Override
+  public String toString() {
+    return "{required("+params+")}";  
+  }    
+
+  //----------------------------------------------------------
+  // Functions with a default value - pass directly to the
+  // wrapped SolrParams (they won't return null - unless its the default)
+  //----------------------------------------------------------
+
+  @Override
+  public String get(String param, String def) {
+    return params.get(param, def);
+  }
+
+  @Override
+  public int getInt(String param, int def) {
+    return params.getInt(param, def);
+  }
+
+  @Override
+  public float getFloat(String param, float def) {
+    return params.getFloat(param, def);
+  }
+  
+  @Override
+  public boolean getBool(String param, boolean def) {
+    return params.getBool(param, def);
+  }
+
+  @Override
+  public int getFieldInt(String field, String param, int def) {
+    return params.getFieldInt(field, param, def);
+  }
+  
+  @Override
+  public boolean getFieldBool(String field, String param, boolean def) {
+    return params.getFieldBool(field, param, def);
+  }
+
+  @Override
+  public float getFieldFloat(String field, String param, float def) {
+    return params.getFieldFloat(field, param, def);
+  }
+
+  @Override
+  public String getFieldParam(String field, String param, String def) {
+    return params.getFieldParam(field, param, def);
+  }
+}
diff --git a/src/common/org/apache/solr/common/params/ShardParams.java b/src/common/org/apache/solr/common/params/ShardParams.java
new file mode 100644
index 0000000..e929c0c
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/ShardParams.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * Parameters used for distributed search.
+ */
+public interface ShardParams {
+  /** the shards to use (distributed configuration) */
+  public static final String SHARDS = "shards";
+  
+  /** IDs of the shard documents */
+  public static final String IDS = "ids";
+  
+  /** whether the request goes to a shard */
+  public static final String IS_SHARD = "isShard";
+  
+  /** query type for shard requests */
+  public static final String SHARDS_QT = "shards.qt";
+}
diff --git a/src/common/org/apache/solr/common/params/SolrParams.java b/src/common/org/apache/solr/common/params/SolrParams.java
new file mode 100644
index 0000000..4b96fb1
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/SolrParams.java
@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+/**  SolrParams hold request parameters.
+ *
+ * @version $Id$
+ */
+public abstract class SolrParams implements Serializable {
+  
+  /** returns the String value of a param, or null if not set */
+  public abstract String get(String param);
+
+  /** returns an array of the String values of a param, or null if none */
+  public abstract String[] getParams(String param);
+
+  /** returns an Iterator over the parameter names */
+  public abstract Iterator<String> getParameterNamesIterator();
+
+  /** returns the value of the param, or def if not set */
+  public String get(String param, String def) {
+    String val = get(param);
+    return val==null ? def : val;
+  }
+  
+  /** returns a RequiredSolrParams wrapping this */
+  public RequiredSolrParams required()
+  {
+    // TODO? should we want to stash a reference?
+    return new RequiredSolrParams(this);
+  }
+  
+  protected String fpname(String field, String param) {
+    return "f."+field+'.'+param;
+  }
+
+  /** returns the String value of the field parameter, "f.field.param", or
+   *  the value for "param" if that is not set.
+   */
+  public String getFieldParam(String field, String param) {
+    String val = get(fpname(field,param));
+    return val!=null ? val : get(param);
+  }
+
+  /** returns the String value of the field parameter, "f.field.param", or
+   *  the value for "param" if that is not set.  If that is not set, def
+   */
+  public String getFieldParam(String field, String param, String def) {
+    String val = get(fpname(field,param));
+    return val!=null ? val : get(param, def);
+  }
+  
+  /** returns the String values of the field parameter, "f.field.param", or
+   *  the values for "param" if that is not set.
+   */
+  public String[] getFieldParams(String field, String param) {
+    String[] val = getParams(fpname(field,param));
+    return val!=null ? val : getParams(param);
+  }
+
+  /** Returns the Boolean value of the param, or null if not set */
+  public Boolean getBool(String param) {
+    String val = get(param);
+    return val==null ? null : parseBool(val);
+  }
+
+  /** Returns the boolean value of the param, or def if not set */
+  public boolean getBool(String param, boolean def) {
+    String val = get(param);
+    return val==null ? def : parseBool(val);
+  }
+  
+  /** Returns the Boolean value of the field param, 
+      or the value for param, or null if neither is set. */
+  public Boolean getFieldBool(String field, String param) {
+    String val = getFieldParam(field, param);
+    return val==null ? null : parseBool(val);
+  }
+  
+  /** Returns the boolean value of the field param, 
+  or the value for param, or def if neither is set. */
+  public boolean getFieldBool(String field, String param, boolean def) {
+    String val = getFieldParam(field, param);
+    return val==null ? def : parseBool(val);
+  }
+
+  /** Returns the Integer value of the param, or null if not set */
+  public Integer getInt(String param) {
+    String val = get(param);
+    try {
+      return val==null ? null : Integer.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the int value of the param, or def if not set */
+  public int getInt(String param, int def) {
+    String val = get(param);
+    try {
+      return val==null ? def : Integer.parseInt(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** Returns the int value of the field param,
+  or the value for param, or def if neither is set. */
+  public Integer getFieldInt(String field, String param) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? null : Integer.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** Returns the int value of the field param, 
+  or the value for param, or def if neither is set. */
+  public int getFieldInt(String field, String param, int def) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? def : Integer.parseInt(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+
+  /** Returns the Float value of the param, or null if not set */
+  public Float getFloat(String param) {
+    String val = get(param);
+    try {
+      return val==null ? null : Float.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the param, or def if not set */
+  public float getFloat(String param, float def) {
+    String val = get(param);
+    try {
+      return val==null ? def : Float.parseFloat(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the field param. */
+  public Float getFieldFloat(String field, String param) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? null : Float.valueOf(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+
+  /** Returns the float value of the field param,
+  or the value for param, or def if neither is set. */
+  public float getFieldFloat(String field, String param, float def) {
+    String val = getFieldParam(field, param);
+    try {
+      return val==null ? def : Float.parseFloat(val);
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
+    }
+  }
+  
+  /** how to transform a String into a boolean... more flexible than
+   * Boolean.parseBoolean() to enable easier integration with html forms.
+   */
+  protected boolean parseBool(String s) {
+    if( s != null ) {
+      if( s.startsWith("true") || s.startsWith("on") || s.startsWith("yes") ) {
+        return true;
+      }
+      if( s.startsWith("false") || s.startsWith("off") || s.equals("no") ) {
+        return false;
+      }
+    }
+    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "invalid boolean value: "+s );
+  }
+
+  /** Create a Map<String,String> from a NamedList given no keys are repeated */
+  public static Map<String,String> toMap(NamedList params) {
+    HashMap<String,String> map = new HashMap<String,String>();
+    for (int i=0; i<params.size(); i++) {
+      map.put(params.getName(i), params.getVal(i).toString());
+    }
+    return map;
+  }
+
+  /** Create a Map<String,String[]> from a NamedList */
+  public static Map<String,String[]> toMultiMap(NamedList params) {
+    HashMap<String,String[]> map = new HashMap<String,String[]>();
+    for (int i=0; i<params.size(); i++) {
+      String name = params.getName(i);
+      String val = params.getVal(i).toString();
+      MultiMapSolrParams.addParam(name,val,map);
+    }
+    return map;
+  }
+
+  /** Create SolrParams from NamedList. */
+  public static SolrParams toSolrParams(NamedList params) {
+    // if no keys are repeated use the faster MapSolrParams
+    HashMap<String,String> map = new HashMap<String,String>();
+    for (int i=0; i<params.size(); i++) {
+      String prev = map.put(params.getName(i), params.getVal(i).toString());
+      if (prev!=null) return new MultiMapSolrParams(toMultiMap(params));
+    }
+    return new MapSolrParams(map);
+  }
+  
+  /** Convert this to a NamedList */
+  public NamedList<Object> toNamedList() {
+    final SimpleOrderedMap<Object> result = new SimpleOrderedMap<Object>();
+    
+    for(Iterator<String> it=getParameterNamesIterator(); it.hasNext(); ) {
+      final String name = it.next();
+      final String [] values = getParams(name);
+      if(values.length==1) {
+        result.add(name,values[0]);
+      } else {
+        // currently no reason not to use the same array
+        result.add(name,values);
+      }
+    }
+    return result;
+  }
+}
+
+
+
+
+
+
+
+
diff --git a/src/common/org/apache/solr/common/params/SpellingParams.java b/src/common/org/apache/solr/common/params/SpellingParams.java
new file mode 100644
index 0000000..b0c77a0
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/SpellingParams.java
@@ -0,0 +1,84 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * Parameters used for spellchecking
+ * 
+ * @since solr 1.3
+ */
+public interface SpellingParams {
+
+  public static final String SPELLCHECK_PREFIX = "spellcheck.";
+
+  /**
+   * The name of the dictionary to be used for giving the suggestion for a
+   * request. The value for this parameter is configured in solrconfig.xml
+   */
+  public static final String SPELLCHECK_DICT = SPELLCHECK_PREFIX + "dictionary";
+
+  /**
+   * The count of suggestions needed for a given query.
+   * <p/>
+   * If this parameter is absent in the request then only one suggestion is
+   * returned. If it is more than one then a maximum of given suggestions are
+   * returned for each token in the query.
+   */
+  public static final String SPELLCHECK_COUNT = SPELLCHECK_PREFIX + "count";
+
+  /**
+   * When this parameter is set to true and the misspelled word exists in the
+   * user field, only words that occur more frequently in the Solr field than
+   * the one given will be returned. The default value is false.
+   * <p/>
+   * <b>This is applicable only for dictionaries built from Solr fields.</b>
+   */
+  public static final String SPELLCHECK_ONLY_MORE_POPULAR = SPELLCHECK_PREFIX + "onlyMorePopular";
+
+  /**
+   * Whether to use the extended response format, which is more complicated but
+   * richer. Returns the document frequency for each suggestion and returns one
+   * suggestion block for each term in the query string. Default is false.
+   * <p/>
+   * <b>This is applicable only for dictionaries built from Solr fields.</b>
+   */
+  public static final String SPELLCHECK_EXTENDED_RESULTS = SPELLCHECK_PREFIX + "extendedResults";
+
+  /**
+   * Use the value for this parameter as the query to spell check.
+   * <p/>
+   * This parameter is <b>optional</b>. If absent, then the q parameter is
+   * used.
+   */
+  public static final String SPELLCHECK_Q = SPELLCHECK_PREFIX + "q";
+
+  /**
+   * Whether to build the index or not. Optional and false by default.
+   */
+  public static final String SPELLCHECK_BUILD = SPELLCHECK_PREFIX + "build";
+
+  /**
+   * Whether to reload the index. Optional and false by default.
+   */
+  public static final String SPELLCHECK_RELOAD = SPELLCHECK_PREFIX + "reload";
+
+  /**
+   * Take the top suggestion for each token and create a new query from it
+   */
+  public static final String SPELLCHECK_COLLATE = SPELLCHECK_PREFIX + "collate";
+}
diff --git a/src/common/org/apache/solr/common/params/StatsParams.java b/src/common/org/apache/solr/common/params/StatsParams.java
new file mode 100644
index 0000000..f63cd21
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/StatsParams.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * Stats Parameters
+ */
+public interface StatsParams {
+  public static final String STATS = "stats";
+  public static final String STATS_FIELD = STATS + ".field";
+  public static final String STATS_FACET = STATS + ".facet";
+  public static final String STATS_TWOPASS = STATS + ".twopass";
+}
diff --git a/src/common/org/apache/solr/common/params/TermVectorParams.java b/src/common/org/apache/solr/common/params/TermVectorParams.java
new file mode 100644
index 0000000..cf75ac7
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/TermVectorParams.java
@@ -0,0 +1,50 @@
+package org.apache.solr.common.params;
+
+
+/**
+ *
+ *
+ **/
+public interface TermVectorParams {
+
+  public static final String TV_PREFIX = "tv.";
+
+    /**
+  * Return Term Frequency info
+  * */
+  public static final String TF =  TV_PREFIX + "tf";
+  /**
+  * Return Term Vector position information
+  *
+  * */
+  public static final String POSITIONS = TV_PREFIX + "positions";
+  /**
+  * Return offset information, if available
+  * */
+  public static final String OFFSETS = TV_PREFIX + "offsets";
+  /**
+  * Return IDF information.  May be expensive
+  * */
+  public static final String DF = TV_PREFIX + "df";
+
+  /**
+   * Return TF-IDF calculation, i.e. (tf / idf).  May be expensive.
+   */
+  public static final String TF_IDF = TV_PREFIX + "tf_idf";
+
+
+  /**
+   * Return all the options: TF, positions, offsets, idf
+   */
+  public static final String ALL = TV_PREFIX + "all";
+
+  /**
+   * The fields to get term vectors for
+   */
+  public static final String FIELDS = TV_PREFIX + "fl";
+
+  /**
+   * The Doc Ids (Lucene internal ids) of the docs to get the term vectors for
+   */
+  public static final String DOC_IDS = TV_PREFIX + "docIds";
+}
diff --git a/src/common/org/apache/solr/common/params/TermsParams.java b/src/common/org/apache/solr/common/params/TermsParams.java
new file mode 100644
index 0000000..1ade243
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/TermsParams.java
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+
+/**
+ *
+ *
+ **/
+public interface TermsParams {
+  /**
+   * The component name.  Set to true to turn on the TermsComponent
+   */
+  public static final String TERMS = "terms";
+
+  /**
+   * Used for building up the other terms
+   */
+  public static final String TERMS_PREFIX = TERMS + ".";
+
+  /**
+   * Required.  Specify the field to look up terms in.
+   */
+  public static final String TERMS_FIELD = TERMS_PREFIX + "fl";
+
+  /**
+   * Optional.  The lower bound term to start at.  The TermEnum will start at the next term after this term in the dictionary.
+   *
+   * If not specified, the empty string is used
+   */
+  public static final String TERMS_LOWER = TERMS_PREFIX + "lower";
+
+  /**
+   * Optional.  The term to stop at.
+   *
+   * @see #TERMS_UPPER_INCLUSIVE
+   */
+  public static final String TERMS_UPPER = TERMS_PREFIX + "upper";
+  /**
+   * Optional.  If true, include the upper bound term in the results.  False by default.
+   */
+  public static final String TERMS_UPPER_INCLUSIVE = TERMS_PREFIX + "upper.incl";
+
+  /**
+   * Optional.  If true, include the lower bound term in the results, otherwise skip to the next one.  True by default.
+   */
+  public static final String TERMS_LOWER_INCLUSIVE = TERMS_PREFIX + "lower.incl";
+
+  /**
+   * Optional.  The number of results to return.  If not specified, looks for {@link org.apache.solr.common.params.CommonParams#ROWS}.  If that's not specified, uses 10.
+   */
+  public static final String TERMS_ROWS = TERMS_PREFIX + "rows";
+
+  public static final String TERMS_PREFIX_STR = TERMS_PREFIX + "prefix";
+
+  /**
+   * Optional.  The minimum value of docFreq to be returned.  1 by default
+   */
+  public static final String TERMS_MINCOUNT = TERMS_PREFIX + "mincount";
+  /**
+   * Optional.  The maximum value of docFreq to be returned.  -1 by default means no boundary
+   */
+  public static final String TERMS_MAXCOUNT = TERMS_PREFIX + "maxcount";
+}
+
diff --git a/src/common/org/apache/solr/common/params/UpdateParams.java b/src/common/org/apache/solr/common/params/UpdateParams.java
new file mode 100644
index 0000000..b354bcb
--- /dev/null
+++ b/src/common/org/apache/solr/common/params/UpdateParams.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.params;
+
+/**
+ * A collection of standard params used by Update handlers
+ *
+ * @version $Id$
+ * @since solr 1.2
+ */
+public interface UpdateParams 
+{
+  /** wait till the command has flushed */
+  public static String WAIT_FLUSH = "waitFlush";
+  
+  /** wait for the search to warm up */
+  public static String WAIT_SEARCHER = "waitSearcher";
+  
+  /** overwrite indexing fields */
+  public static String OVERWRITE = "overwrite";
+  
+  /** Commit everything after the command completes */
+  public static String COMMIT = "commit";
+  
+  /** Optimize the index and commit everything after the command completes */
+  public static String OPTIMIZE = "optimize";
+  
+  /** Rollback update commands */
+  public static String ROLLBACK = "rollback";
+
+  /** Select the update processor to use.  A RequestHandler may or may not respect this parameter */
+  public static final String UPDATE_PROCESSOR = "update.processor";
+  /**
+   * If optimizing, set the maximum number of segments left in the index after optimization.  1 is the default (and is equivalent to calling IndexWriter.optimize() in Lucene).
+   */
+  public static final String MAX_OPTIMIZE_SEGMENTS = "maxSegments";
+}
diff --git a/src/common/org/apache/solr/common/util/ConcurrentLRUCache.java b/src/common/org/apache/solr/common/util/ConcurrentLRUCache.java
new file mode 100644
index 0000000..ddbf9fa
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/ConcurrentLRUCache.java
@@ -0,0 +1,535 @@
+package org.apache.solr.common.util;
+
+import org.apache.lucene.util.PriorityQueue;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.locks.ReentrantLock;
+import java.lang.ref.WeakReference;
+
+/**
+ * A LRU cache implementation based upon ConcurrentHashMap and other techniques to reduce
+ * contention and synchronization overhead to utilize multiple CPU cores more effectively.
+ * <p/>
+ * Note that the implementation does not follow a true LRU (least-recently-used) eviction
+ * strategy. Instead it strives to remove least recently used items but when the initial
+ * cleanup does not remove enough items to reach the 'acceptableWaterMark' limit, it can
+ * remove more items forcefully regardless of access order.
+ *
+ * @version $Id$
+ * @since solr 1.4
+ */
+public class ConcurrentLRUCache<K,V> {
+
+  private final ConcurrentHashMap<Object, CacheEntry> map;
+  private final int upperWaterMark, lowerWaterMark;
+  private final ReentrantLock markAndSweepLock = new ReentrantLock(true);
+  private boolean isCleaning = false;  // not volatile... piggybacked on other volatile vars
+  private final boolean newThreadForCleanup;
+  private volatile boolean islive = true;
+  private final Stats stats = new Stats();
+  private final int acceptableWaterMark;
+  private long oldestEntry = 0;  // not volatile, only accessed in the cleaning method
+  private final EvictionListener<K,V> evictionListener;
+  private CleanupThread cleanupThread ;
+
+  public ConcurrentLRUCache(int upperWaterMark, final int lowerWaterMark, int acceptableWatermark,
+                            int initialSize, boolean runCleanupThread, boolean runNewThreadForCleanup,
+                            EvictionListener<K,V> evictionListener) {
+    if (upperWaterMark < 1) throw new IllegalArgumentException("upperWaterMark must be > 0");
+    if (lowerWaterMark >= upperWaterMark)
+      throw new IllegalArgumentException("lowerWaterMark must be  < upperWaterMark");
+    map = new ConcurrentHashMap<Object, CacheEntry>(initialSize);
+    newThreadForCleanup = runNewThreadForCleanup;
+    this.upperWaterMark = upperWaterMark;
+    this.lowerWaterMark = lowerWaterMark;
+    this.acceptableWaterMark = acceptableWatermark;
+    this.evictionListener = evictionListener;
+    if (runCleanupThread) {
+      cleanupThread = new CleanupThread(this);
+      cleanupThread.start();
+    }
+  }
+
+
+  public void setAlive(boolean live) {
+    islive = live;
+  }
+
+  public V get(K key) {
+    CacheEntry<K,V> e = map.get(key);
+    if (e == null) {
+      if (islive) stats.missCounter.incrementAndGet();
+      return null;
+    }
+    if (islive) e.lastAccessed = stats.accessCounter.incrementAndGet();
+    return e.value;
+  }
+
+  public V remove(K key) {
+    CacheEntry<K,V> cacheEntry = map.remove(key);
+    if (cacheEntry != null) {
+      stats.size.decrementAndGet();
+      if(evictionListener != null) evictionListener.evictedEntry(cacheEntry.key , cacheEntry.value);
+      return cacheEntry.value;
+    }
+    return null;
+  }
+
+  public Object put(K key, V val) {
+    if (val == null) return null;
+    CacheEntry e = new CacheEntry(key, val, stats.accessCounter.incrementAndGet());
+    CacheEntry oldCacheEntry = map.put(key, e);
+    if (oldCacheEntry == null) {
+      stats.size.incrementAndGet();
+    }
+    if (islive) {
+      stats.putCounter.incrementAndGet();
+    } else {
+      stats.nonLivePutCounter.incrementAndGet();
+    }
+
+    // Check if we need to clear out old entries from the cache.
+    // isCleaning variable is checked instead of markAndSweepLock.isLocked()
+    // for performance because every put invokation will check until
+    // the size is back to an acceptable level.
+    //
+    // There is a race between the check and the call to markAndSweep, but
+    // it's unimportant because markAndSweep actually aquires the lock or returns if it can't.
+    //
+    // Thread safety note: isCleaning read is piggybacked (comes after) other volatile reads
+    // in this method.
+    if (stats.size.get() > upperWaterMark && !isCleaning) {
+      if (newThreadForCleanup) {
+        new Thread() {
+          public void run() {
+            markAndSweep();
+          }
+        }.start();
+      } else if (cleanupThread != null){
+        cleanupThread.wakeThread();
+      } else {
+        markAndSweep();
+      }
+    }
+    return oldCacheEntry == null ? null : oldCacheEntry.value;
+  }
+
+  /**
+   * Removes items from the cache to bring the size down
+   * to an acceptable value ('acceptableWaterMark').
+   * <p/>
+   * It is done in two stages. In the first stage, least recently used items are evicted.
+   * If, after the first stage, the cache size is still greater than 'acceptableSize'
+   * config parameter, the second stage takes over.
+   * <p/>
+   * The second stage is more intensive and tries to bring down the cache size
+   * to the 'lowerWaterMark' config parameter.
+   */
+  private void markAndSweep() {
+    // if we want to keep at least 1000 entries, then timestamps of
+    // current through current-1000 are guaranteed not to be the oldest (but that does
+    // not mean there are 1000 entries in that group... it's acutally anywhere between
+    // 1 and 1000).
+    // Also, if we want to remove 500 entries, then
+    // oldestEntry through oldestEntry+500 are guaranteed to be
+    // removed (however many there are there).
+
+    if (!markAndSweepLock.tryLock()) return;
+    try {
+      long oldestEntry = this.oldestEntry;
+      isCleaning = true;
+      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible
+
+      long timeCurrent = stats.accessCounter.get();
+      int sz = stats.size.get();
+
+      int numRemoved = 0;
+      int numKept = 0;
+      long newestEntry = timeCurrent;
+      long newNewestEntry = -1;
+      long newOldestEntry = Integer.MAX_VALUE;
+
+      int wantToKeep = lowerWaterMark;
+      int wantToRemove = sz - lowerWaterMark;
+
+      CacheEntry<K,V>[] eset = new CacheEntry[sz];
+      int eSize = 0;
+
+      // System.out.println("newestEntry="+newestEntry + " oldestEntry="+oldestEntry);
+      // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
+
+      for (CacheEntry<K,V> ce : map.values()) {
+        // set lastAccessedCopy to avoid more volatile reads
+        ce.lastAccessedCopy = ce.lastAccessed;
+        long thisEntry = ce.lastAccessedCopy;
+
+        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first
+        if (thisEntry > newestEntry - wantToKeep) {
+          // this entry is guaranteed not to be in the bottom
+          // group, so do nothing.
+          numKept++;
+          newOldestEntry = Math.min(thisEntry, newOldestEntry);
+        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?
+          // this entry is guaranteed to be in the bottom group
+          // so immediately remove it from the map.
+          evictEntry(ce.key);
+          numRemoved++;
+        } else {
+          // This entry *could* be in the bottom group.
+          // Collect these entries to avoid another full pass... this is wasted
+          // effort if enough entries are normally removed in this first pass.
+          // An alternate impl could make a full second pass.
+          if (eSize < eset.length-1) {
+            eset[eSize++] = ce;
+            newNewestEntry = Math.max(thisEntry, newNewestEntry);
+            newOldestEntry = Math.min(thisEntry, newOldestEntry);
+          }
+        }
+      }
+
+      // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
+      // TODO: allow this to be customized in the constructor?
+      int numPasses=1; // maximum number of linear passes over the data
+
+      // if we didn't remove enough entries, then make more passes
+      // over the values we collected, with updated min and max values.
+      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {
+
+        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
+        newOldestEntry = Integer.MAX_VALUE;
+        newestEntry = newNewestEntry;
+        newNewestEntry = -1;
+        wantToKeep = lowerWaterMark - numKept;
+        wantToRemove = sz - lowerWaterMark - numRemoved;
+
+        // iterate backward to make it easy to remove items.
+        for (int i=eSize-1; i>=0; i--) {
+          CacheEntry<K,V> ce = eset[i];
+          long thisEntry = ce.lastAccessedCopy;
+
+          if (thisEntry > newestEntry - wantToKeep) {
+            // this entry is guaranteed not to be in the bottom
+            // group, so do nothing but remove it from the eset.
+            numKept++;
+            // remove the entry by moving the last element to it's position
+            eset[i] = eset[eSize-1];
+            eSize--;
+
+            newOldestEntry = Math.min(thisEntry, newOldestEntry);
+            
+          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?
+
+            // this entry is guaranteed to be in the bottom group
+            // so immediately remove it from the map.
+            evictEntry(ce.key);
+            numRemoved++;
+
+            // remove the entry by moving the last element to it's position
+            eset[i] = eset[eSize-1];
+            eSize--;
+          } else {
+            // This entry *could* be in the bottom group, so keep it in the eset,
+            // and update the stats.
+            newNewestEntry = Math.max(thisEntry, newNewestEntry);
+            newOldestEntry = Math.min(thisEntry, newOldestEntry);
+          }
+        }
+        // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
+      }
+
+
+
+      // if we still didn't remove enough entries, then make another pass while
+      // inserting into a priority queue
+      if (sz - numRemoved > acceptableWaterMark) {
+
+        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
+        newOldestEntry = Integer.MAX_VALUE;
+        newestEntry = newNewestEntry;
+        newNewestEntry = -1;
+        wantToKeep = lowerWaterMark - numKept;
+        wantToRemove = sz - lowerWaterMark - numRemoved;
+
+        PQueue queue = new PQueue(wantToRemove);
+
+        for (int i=eSize-1; i>=0; i--) {
+          CacheEntry<K,V> ce = eset[i];
+          long thisEntry = ce.lastAccessedCopy;
+
+          if (thisEntry > newestEntry - wantToKeep) {
+            // this entry is guaranteed not to be in the bottom
+            // group, so do nothing but remove it from the eset.
+            numKept++;
+            // removal not necessary on last pass.
+            // eset[i] = eset[eSize-1];
+            // eSize--;
+
+            newOldestEntry = Math.min(thisEntry, newOldestEntry);
+            
+          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?
+            // this entry is guaranteed to be in the bottom group
+            // so immediately remove it.
+            evictEntry(ce.key);
+            numRemoved++;
+
+            // removal not necessary on last pass.
+            // eset[i] = eset[eSize-1];
+            // eSize--;
+          } else {
+            // This entry *could* be in the bottom group.
+            // add it to the priority queue
+
+            // everything in the priority queue will be removed, so keep track of
+            // the lowest value that ever comes back out of the queue.
+
+            // first reduce the size of the priority queue to account for
+            // the number of items we have already removed while executing
+            // this loop so far.
+            queue.myMaxSize = sz - lowerWaterMark - numRemoved;
+            while (queue.size() > queue.myMaxSize && queue.size() > 0) {
+              CacheEntry otherEntry = (CacheEntry) queue.pop();
+              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);
+            }
+            if (queue.myMaxSize <= 0) break;
+
+            Object o = queue.myInsertWithOverflow(ce);
+            if (o != null) {
+              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);
+            }
+          }
+        }
+
+        // Now delete everything in the priority queue.
+        // avoid using pop() since order doesn't matter anymore
+        for (Object o : queue.getValues()) {
+          if (o==null) continue;
+          CacheEntry<K,V> ce = (CacheEntry)o;
+          evictEntry(ce.key);
+          numRemoved++;
+        }
+
+        // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " initialQueueSize="+ wantToRemove + " finalQueueSize=" + queue.size() + " sz-numRemoved=" + (sz-numRemoved));
+      }
+
+      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
+      this.oldestEntry = oldestEntry;
+    } finally {
+      isCleaning = false;  // set before markAndSweep.unlock() for visibility
+      markAndSweepLock.unlock();
+    }
+  }
+
+  private static class PQueue extends PriorityQueue {
+    int myMaxSize;
+    PQueue(int maxSz) {
+      super.initialize(maxSz);
+      myMaxSize = maxSz;
+    }
+
+    Object[] getValues() { return heap; }
+
+    protected boolean lessThan(Object a, Object b) {
+      // reverse the parameter order so that the queue keeps the oldest items
+      return ((CacheEntry)b).lastAccessedCopy < ((CacheEntry)a).lastAccessedCopy;
+    }
+
+    // necessary because maxSize is private in base class
+    public Object myInsertWithOverflow(Object element) {
+      if (size() < myMaxSize) {
+        put(element);
+        return null;
+      } else if (size() > 0 && !lessThan(element, heap[1])) {
+        Object ret = heap[1];
+        heap[1] = element;
+        adjustTop();
+        return ret;
+      } else {
+        return element;
+      }
+    }
+  }
+
+
+  private void evictEntry(K key) {
+    CacheEntry<K,V> o = map.remove(key);
+    if (o == null) return;
+    stats.size.decrementAndGet();
+    stats.evictionCounter++;
+    if(evictionListener != null) evictionListener.evictedEntry(o.key,o.value);
+  }
+
+
+  public Map getLatestAccessedItems(long n) {
+    // we need to grab the lock since we are changing lastAccessedCopy
+    markAndSweepLock.lock();
+    Map<K,V> result = new LinkedHashMap<K,V>();
+    TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();
+    try {
+      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {
+        CacheEntry ce = entry.getValue();
+        ce.lastAccessedCopy = ce.lastAccessed;
+        if (tree.size() < n) {
+          tree.add(ce);
+        } else {
+          if (ce.lastAccessedCopy > tree.last().lastAccessedCopy) {
+            tree.remove(tree.last());
+            tree.add(entry.getValue());
+          }
+        }
+      }
+    } finally {
+      markAndSweepLock.unlock();
+    }
+    for (CacheEntry<K,V> e : tree) {
+      result.put(e.key, e.value);
+    }
+    return result;
+  }
+
+  public int size() {
+    return stats.size.get();
+  }
+
+  public void clear() {
+    map.clear();
+  }
+
+  public Map<Object, CacheEntry> getMap() {
+    return map;
+  }
+
+  private static class CacheEntry<K,V> implements Comparable<CacheEntry> {
+    K key;
+    V value;
+    volatile long lastAccessed = 0;
+    long lastAccessedCopy = 0;
+
+
+    public CacheEntry(K key, V value, long lastAccessed) {
+      this.key = key;
+      this.value = value;
+      this.lastAccessed = lastAccessed;
+    }
+
+    public void setLastAccessed(long lastAccessed) {
+      this.lastAccessed = lastAccessed;
+    }
+
+    public int compareTo(CacheEntry that) {
+      if (this.lastAccessedCopy == that.lastAccessedCopy) return 0;
+      return this.lastAccessedCopy < that.lastAccessedCopy ? 1 : -1;
+    }
+
+    public int hashCode() {
+      return value.hashCode();
+    }
+
+    public boolean equals(Object obj) {
+      return value.equals(obj);
+    }
+
+    public String toString() {
+      return "key: " + key + " value: " + value + " lastAccessed:" + lastAccessed;
+    }
+  }
+
+
+  public void destroy() {
+    if(cleanupThread != null){
+      cleanupThread.stopThread();
+    }
+  }
+
+  public Stats getStats() {
+    return stats;
+  }
+
+
+  public static class Stats {
+    private final AtomicLong accessCounter = new AtomicLong(0),
+            putCounter = new AtomicLong(0),
+            nonLivePutCounter = new AtomicLong(0),
+            missCounter = new AtomicLong();
+    private final AtomicInteger size = new AtomicInteger();
+    private long evictionCounter = 0;
+
+    public long getCumulativeLookups() {
+      return (accessCounter.get() - putCounter.get() - nonLivePutCounter.get()) + missCounter.get();
+    }
+
+    public long getCumulativeHits() {
+      return accessCounter.get() - putCounter.get() - nonLivePutCounter.get();
+    }
+
+    public long getCumulativePuts() {
+      return putCounter.get();
+    }
+
+    public long getCumulativeEvictions() {
+      return evictionCounter;
+    }
+
+    public int getCurrentSize() {
+      return size.get();
+    }
+
+    public long getCumulativeNonLivePuts() {
+      return nonLivePutCounter.get();
+    }
+
+    public long getCumulativeMisses() {
+      return missCounter.get();
+    }
+  }
+
+  public static interface EvictionListener<K,V>{
+    public void evictedEntry(K key, V value);
+  }
+
+  private static class CleanupThread extends Thread {
+    private WeakReference<ConcurrentLRUCache> cache;
+
+    private boolean stop = false;
+
+    public CleanupThread(ConcurrentLRUCache c) {
+      cache = new WeakReference<ConcurrentLRUCache>(c);
+    }
+
+    public void run() {
+      while (true) {
+        synchronized (this) {
+          if (stop) break;
+          try {
+            this.wait();
+          } catch (InterruptedException e) {}
+        }
+        if (stop) break;
+        ConcurrentLRUCache c = cache.get();
+        if(c == null) break;
+        c.markAndSweep();
+      }
+    }
+
+    void wakeThread() {
+      synchronized(this){
+        this.notify();
+      }
+    }
+
+    void stopThread() {
+      synchronized(this){
+        stop=true;
+        this.notify();
+      }
+    }
+  }
+
+  protected void finalize() throws Throwable {
+    destroy();
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/ContentStream.java b/src/common/org/apache/solr/common/util/ContentStream.java
new file mode 100755
index 0000000..7249419
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/ContentStream.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+
+/**
+ * @version $Id$
+ * @since solr 1.2
+ */
+public interface ContentStream {
+  String getName();
+  String getSourceInfo();
+  String getContentType();
+  
+  /**
+   * @return the stream size or <code>null</code> if not known
+   */
+  Long getSize(); // size if we know it, otherwise null
+  
+  /**
+   * Get an open stream.  You are responsible for closing it.  Consider using 
+   * something like:
+   * <pre>
+   *   InputStream stream = stream.getStream();
+   *   try {
+   *     // use the stream...
+   *   }
+   *   finally {
+   *     IOUtils.closeQuietly(stream);
+   *   }
+   *  </pre>
+   *  
+   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
+   * is guaranteed to work.  The runtime behavior for additional calls is undefined.
+   */
+  InputStream getStream() throws IOException;
+
+  /**
+   * Get an open stream.  You are responsible for closing it.  Consider using 
+   * something like:
+   * <pre>
+   *   Reader reader = stream.getReader();
+   *   try {
+   *     // use the reader...
+   *   }
+   *   finally {
+   *     IOUtils.closeQuietly(reader);
+   *   }
+   *  </pre>
+   *  
+   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
+   * is guaranteed to work.  The runtime behavior for additional calls is undefined.
+   */
+  Reader getReader() throws IOException;
+}
diff --git a/src/common/org/apache/solr/common/util/ContentStreamBase.java b/src/common/org/apache/solr/common/util/ContentStreamBase.java
new file mode 100755
index 0000000..b0967b4
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/ContentStreamBase.java
@@ -0,0 +1,204 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.net.URL;
+import java.net.URLConnection;
+
+
+/**
+ * Three concrete implementations for ContentStream - one for File/URL/String
+ * 
+ * @version $Id$
+ * @since solr 1.2
+ */
+public abstract class ContentStreamBase implements ContentStream
+{
+  public static final String DEFAULT_CHARSET = "utf-8";
+  
+  protected String name;
+  protected String sourceInfo;
+  protected String contentType;
+  protected Long size;
+  
+  //---------------------------------------------------------------------
+  //---------------------------------------------------------------------
+  
+  public static String getCharsetFromContentType( String contentType )
+  {
+    if( contentType != null ) {
+      int idx = contentType.toLowerCase().indexOf( "charset=" );
+      if( idx > 0 ) {
+        return contentType.substring( idx + "charset=".length() ).trim();
+      }
+    }
+    return null;
+  }
+  
+  //------------------------------------------------------------------------
+  //------------------------------------------------------------------------
+  
+  /**
+   * Construct a <code>ContentStream</code> from a <code>URL</code>
+   * 
+   * This uses a <code>URLConnection</code> to get the content stream
+   * @see  URLConnection
+   */
+  public static class URLStream extends ContentStreamBase
+  {
+    private final URL url;
+    final URLConnection conn;
+    
+    public URLStream( URL url ) throws IOException {
+      this.url = url; 
+      this.conn = this.url.openConnection();
+      
+      contentType = conn.getContentType();
+      name = url.toExternalForm();
+      size = new Long( conn.getContentLength() );
+      sourceInfo = "url";
+    }
+
+    public InputStream getStream() throws IOException {
+      return conn.getInputStream();
+    }
+  }
+  
+  /**
+   * Construct a <code>ContentStream</code> from a <code>File</code>
+   */
+  public static class FileStream extends ContentStreamBase
+  {
+    private final File file;
+    
+    public FileStream( File f ) throws IOException {
+      file = f; 
+      
+      contentType = null; // ??
+      name = file.getName();
+      size = file.length();
+      sourceInfo = file.toURI().toString();
+    }
+
+    public InputStream getStream() throws IOException {
+      return new FileInputStream( file );
+    }
+
+    /**
+     * If an charset is defined (by the contentType) use that, otherwise 
+     * use a file reader
+     */
+    @Override
+    public Reader getReader() throws IOException {
+      String charset = getCharsetFromContentType( contentType );
+      return charset == null 
+        ? new FileReader( file )
+        : new InputStreamReader( getStream(), charset );
+    }
+  }
+  
+
+  /**
+   * Construct a <code>ContentStream</code> from a <code>File</code>
+   */
+  public static class StringStream extends ContentStreamBase
+  {
+    private final String str;
+    
+    public StringStream( String str ) {
+      this.str = str; 
+      
+      contentType = null;
+      name = null;
+      size = new Long( str.length() );
+      sourceInfo = "string";
+    }
+
+    public InputStream getStream() throws IOException {
+      return new ByteArrayInputStream( str.getBytes(DEFAULT_CHARSET) );
+    }
+
+    /**
+     * If an charset is defined (by the contentType) use that, otherwise 
+     * use a StringReader
+     */
+    @Override
+    public Reader getReader() throws IOException {
+      String charset = getCharsetFromContentType( contentType );
+      return charset == null 
+        ? new StringReader( str )
+        : new InputStreamReader( getStream(), charset );
+    }
+  }
+
+  /**
+   * Base reader implementation.  If the contentType declares a 
+   * charset use it, otherwise use "utf-8".
+   */
+  public Reader getReader() throws IOException {
+    String charset = getCharsetFromContentType( getContentType() );
+    return charset == null 
+      ? new InputStreamReader( getStream(), DEFAULT_CHARSET )
+      : new InputStreamReader( getStream(), charset );
+  }
+
+  //------------------------------------------------------------------
+  // Getters / Setters for overrideable attributes
+  //------------------------------------------------------------------
+
+  public String getContentType() {
+    return contentType;
+  }
+
+  public void setContentType(String contentType) {
+    this.contentType = contentType;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public void setName(String name) {
+    this.name = name;
+  }
+
+  public Long getSize() {
+    return size;
+  }
+
+  public void setSize(Long size) {
+    this.size = size;
+  }
+
+  public String getSourceInfo() {
+    return sourceInfo;
+  }
+
+  public void setSourceInfo(String sourceInfo) {
+    this.sourceInfo = sourceInfo;
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/DOMUtil.java b/src/common/org/apache/solr/common/util/DOMUtil.java
new file mode 100644
index 0000000..206f4b0
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/DOMUtil.java
@@ -0,0 +1,377 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.*;
+
+import org.apache.solr.common.SolrException;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * @version $Id$
+ */
+public class DOMUtil {
+
+  public static Map<String,String> toMap(NamedNodeMap attrs) {
+    return toMapExcept(attrs);
+  }
+
+  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
+    Map<String,String> args = new HashMap<String,String>();
+    outer: for (int j=0; j<attrs.getLength(); j++) {
+      Node attr = attrs.item(j);
+      String attrName = attr.getNodeName();
+      for (String ex : exclusions)
+        if (ex.equals(attrName)) continue outer;
+      String val = attr.getNodeValue();
+      args.put(attrName, val);
+    }
+    return args;
+  }
+
+  public static Node getChild(Node node, String name) {
+    if (!node.hasChildNodes()) return null;
+    NodeList lst = node.getChildNodes();
+    if (lst == null) return null;
+    for (int i=0; i<lst.getLength(); i++) {
+      Node child = lst.item(i);
+      if (name.equals(child.getNodeName())) return child;
+    }
+    return null;
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name) {
+    return getAttr(attrs,name,null);
+  }
+
+  public static String getAttr(Node nd, String name) {
+    return getAttr(nd.getAttributes(), name);
+  }
+
+  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
+    Node attr = attrs==null? null : attrs.getNamedItem(name);
+    if (attr==null) {
+      if (missing_err==null) return null;
+      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
+    }
+    String val = attr.getNodeValue();
+    return val;
+  }
+
+  public static String getAttr(Node node, String name, String missing_err) {
+    return getAttr(node.getAttributes(), name, missing_err);
+  }
+
+  //////////////////////////////////////////////////////////
+  // Routines to parse XML in the syntax of the Solr query
+  // response schema.
+  // Should these be moved to Config?  Should all of these things?
+  //////////////////////////////////////////////////////////
+  public static NamedList<Object> childNodesToNamedList(Node nd) {
+    return nodesToNamedList(nd.getChildNodes());
+  }
+
+  public static List childNodesToList(Node nd) {
+    return nodesToList(nd.getChildNodes());
+  }
+
+  public static NamedList<Object> nodesToNamedList(NodeList nlst) {
+    NamedList<Object> clst = new NamedList<Object>();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), clst, null);
+    }
+    return clst;
+  }
+
+  public static List nodesToList(NodeList nlst) {
+    List lst = new ArrayList();
+    for (int i=0; i<nlst.getLength(); i++) {
+      addToNamedList(nlst.item(i), null, lst);
+    }
+    return lst;
+  }
+
+
+  @SuppressWarnings("unchecked")
+  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
+    // Nodes often include whitespace, etc... so just return if this
+    // is not an Element.
+    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
+
+    String type = nd.getNodeName();
+
+    String name = null;
+    if (nd.hasAttributes()) {
+      NamedNodeMap attrs = nd.getAttributes();
+      Node nameNd = attrs.getNamedItem("name");
+      if (nameNd != null) name=nameNd.getNodeValue();
+    }
+
+    Object val=null;
+
+    if ("str".equals(type)) {
+      val = getText(nd);
+    } else if ("int".equals(type)) {
+      val = Integer.valueOf(getText(nd));
+    } else if ("long".equals(type)) {
+      val = Long.valueOf(getText(nd));
+    } else if ("float".equals(type)) {
+      val = Float.valueOf(getText(nd));
+    } else if ("double".equals(type)) {
+      val = Double.valueOf(getText(nd));
+    } else if ("bool".equals(type)) {
+      val = Boolean.valueOf(getText(nd));
+    } else if ("lst".equals(type)) {
+      val = childNodesToNamedList(nd);
+    } else if ("arr".equals(type)) {
+      val = childNodesToList(nd);
+    }
+
+    if (nlst != null) nlst.add(name,val);
+    if (arr != null) arr.add(val);
+  }
+
+  /**
+   * Drop in replacement for Node.getTextContent().
+   *
+   * <p>
+   * This method is provided to support the same functionality as
+   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
+   * </p>
+   *
+   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
+   */
+  public static String getText(Node nd) {
+
+    short type = nd.getNodeType();
+
+    // for most node types, we can defer to the recursive helper method,
+    // but when asked for the text of these types, we must return null
+    // (Not the empty string)
+    switch (type) {
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+      return null;
+    }
+
+    StringBuilder sb = new StringBuilder();
+    getText(nd, sb);
+    return sb.toString();
+  }
+
+  /** @see #getText(Node) */
+  private static void getText(Node nd, StringBuilder buf) {
+
+    short type = nd.getNodeType();
+
+    switch (type) {
+
+    case Node.ELEMENT_NODE: /* fall through */
+    case Node.ENTITY_NODE: /* fall through */
+    case Node.ENTITY_REFERENCE_NODE: /* fall through */
+    case Node.DOCUMENT_FRAGMENT_NODE:
+      NodeList childs = nd.getChildNodes();
+      for (int i = 0; i < childs.getLength(); i++) {
+        Node child = childs.item(i);
+        short childType = child.getNodeType();
+        if (childType != Node.COMMENT_NODE &&
+            childType != Node.PROCESSING_INSTRUCTION_NODE) {
+          getText(child, buf);
+        }
+      }
+      break;
+
+    case Node.ATTRIBUTE_NODE: /* fall through */
+      /* Putting Attribute nodes in this section does not exactly
+         match the definition of how textContent should behave
+         according to the DOM Level-3 Core documentation - which
+         specifies that the Attr's children should have their
+         textContent concated (Attr's can have a single child which
+         is either Text node or an EntityRefrence).  In practice,
+         DOM implementations do not seem to use child nodes of
+         Attributes, storing the "text" directly as the nodeValue.
+         Fortunately, the DOM Spec indicates that when Attr.nodeValue
+         is read, it should return the nodeValue from the child Node,
+         so this approach should work both for strict implementations,
+         and implementations actually encountered.
+      */
+    case Node.TEXT_NODE: /* fall through */
+    case Node.CDATA_SECTION_NODE: /* fall through */
+    case Node.COMMENT_NODE: /* fall through */
+    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
+      buf.append(nd.getNodeValue());
+      break;
+
+    case Node.DOCUMENT_NODE: /* fall through */
+    case Node.DOCUMENT_TYPE_NODE: /* fall through */
+    case Node.NOTATION_NODE: /* fall through */
+    default:
+      /* :NOOP: */
+
+    }
+  }
+
+  /**
+   * Replaces ${system.property[:default value]} references in all attributes
+   * and text nodes of supplied node.  If the system property is not defined and no
+   * default value is provided, a runtime exception is thrown.
+   *
+   * @param node DOM node to walk for substitutions
+   */
+  public static void substituteSystemProperties(Node node) {
+    substituteProperties(node, null);
+  }
+
+  /**
+   * Replaces ${property[:default value]} references in all attributes
+   * and text nodes of supplied node.  If the property is not defined neither in the
+   * given Properties instance nor in System.getProperty and no
+   * default value is provided, a runtime exception is thrown.
+   *
+   * @param node DOM node to walk for substitutions
+   * @param properties the Properties instance from which a value can be looked up
+   */
+  public static void substituteProperties(Node node, Properties properties) {
+    // loop through child nodes
+    Node child;
+    Node next = node.getFirstChild();
+    while ((child = next) != null) {
+
+      // set next before we change anything
+      next = child.getNextSibling();
+
+      // handle child by node type
+      if (child.getNodeType() == Node.TEXT_NODE) {
+        child.setNodeValue(substituteProperty(child.getNodeValue(), properties));
+      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
+        // handle child elements with recursive call
+        NamedNodeMap attributes = child.getAttributes();
+        for (int i = 0; i < attributes.getLength(); i++) {
+          Node attribute = attributes.item(i);
+          attribute.setNodeValue(substituteProperty(attribute.getNodeValue(), properties));
+        }
+        substituteProperties(child, properties);
+      }
+    }
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.replaceProperties:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  private static String substituteProperty(String value, Properties coreProperties) {
+    if (value == null || value.indexOf('$') == -1) {
+      return value;
+    }
+
+    List<String> fragments = new ArrayList<String>();
+    List<String> propertyRefs = new ArrayList<String>();
+    parsePropertyString(value, fragments, propertyRefs);
+
+    StringBuffer sb = new StringBuffer();
+    Iterator<String> i = fragments.iterator();
+    Iterator<String> j = propertyRefs.iterator();
+
+    while (i.hasNext()) {
+      String fragment = i.next();
+      if (fragment == null) {
+        String propertyName = j.next();
+        String defaultValue = null;
+        int colon_index = propertyName.indexOf(':');
+        if (colon_index > -1) {
+          defaultValue = propertyName.substring(colon_index + 1);
+          propertyName = propertyName.substring(0,colon_index);
+        }
+        if (coreProperties != null) {
+          fragment = coreProperties.getProperty(propertyName);
+        }
+        if (fragment == null) {
+          fragment = System.getProperty(propertyName, defaultValue);
+        }
+        if (fragment == null) {
+          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName);
+        }
+      }
+      sb.append(fragment);
+    }
+    return sb.toString();
+  }
+
+  /*
+   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
+   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
+   */
+  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
+      int prev = 0;
+      int pos;
+      //search for the next instance of $ from the 'prev' position
+      while ((pos = value.indexOf("$", prev)) >= 0) {
+
+          //if there was any text before this, add it as a fragment
+          //TODO, this check could be modified to go if pos>prev;
+          //seems like this current version could stick empty strings
+          //into the list
+          if (pos > 0) {
+              fragments.add(value.substring(prev, pos));
+          }
+          //if we are at the end of the string, we tack on a $
+          //then move past it
+          if (pos == (value.length() - 1)) {
+              fragments.add("$");
+              prev = pos + 1;
+          } else if (value.charAt(pos + 1) != '{') {
+              //peek ahead to see if the next char is a property or not
+              //not a property: insert the char as a literal
+              /*
+              fragments.addElement(value.substring(pos + 1, pos + 2));
+              prev = pos + 2;
+              */
+              if (value.charAt(pos + 1) == '$') {
+                  //backwards compatibility two $ map to one mode
+                  fragments.add("$");
+                  prev = pos + 2;
+              } else {
+                  //new behaviour: $X maps to $X for all values of X!='$'
+                  fragments.add(value.substring(pos, pos + 2));
+                  prev = pos + 2;
+              }
+
+          } else {
+              //property found, extract its name or bail on a typo
+              int endName = value.indexOf('}', pos);
+              if (endName < 0) {
+                throw new RuntimeException("Syntax error in property: " + value);
+              }
+              String propertyName = value.substring(pos + 2, endName);
+              fragments.add(null);
+              propertyRefs.add(propertyName);
+              prev = endName + 1;
+          }
+      }
+      //no more $ signs found
+      //if there is any tail to the string, append it
+      if (prev < value.length()) {
+          fragments.add(value.substring(prev));
+      }
+  }
+
+}
diff --git a/src/common/org/apache/solr/common/util/DateUtil.java b/src/common/org/apache/solr/common/util/DateUtil.java
new file mode 100644
index 0000000..eea0ac0
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/DateUtil.java
@@ -0,0 +1,200 @@
+package org.apache.solr.common.util;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.TimeZone;
+
+
+/**
+ * This class has some code from HttpClient DateUtil.
+ */
+public class DateUtil {
+  //start HttpClient
+  /**
+   * Date format pattern used to parse HTTP date headers in RFC 1123 format.
+   */
+  public static final String PATTERN_RFC1123 = "EEE, dd MMM yyyy HH:mm:ss zzz";
+
+  /**
+   * Date format pattern used to parse HTTP date headers in RFC 1036 format.
+   */
+  public static final String PATTERN_RFC1036 = "EEEE, dd-MMM-yy HH:mm:ss zzz";
+
+  /**
+   * Date format pattern used to parse HTTP date headers in ANSI C
+   * <code>asctime()</code> format.
+   */
+  public static final String PATTERN_ASCTIME = "EEE MMM d HH:mm:ss yyyy";
+  //These are included for back compat
+  private static final Collection<String> DEFAULT_HTTP_CLIENT_PATTERNS = Arrays.asList(
+          PATTERN_ASCTIME, PATTERN_RFC1036, PATTERN_RFC1123);
+
+  private static final Date DEFAULT_TWO_DIGIT_YEAR_START;
+
+  static {
+    Calendar calendar = Calendar.getInstance();
+    calendar.set(2000, Calendar.JANUARY, 1, 0, 0);
+    DEFAULT_TWO_DIGIT_YEAR_START = calendar.getTime();
+  }
+
+  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
+  //end HttpClient
+
+  //---------------------------------------------------------------------------------------
+
+  /**
+   * A suite of default date formats that can be parsed, and thus transformed to the Solr specific format
+   */
+  public static final Collection<String> DEFAULT_DATE_FORMATS = new ArrayList<String>();
+
+  static {
+    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd'T'HH:mm:ss'Z'");
+    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd'T'HH:mm:ss");
+    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd");
+    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd hh:mm:ss");
+    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd HH:mm:ss");
+    DEFAULT_DATE_FORMATS.add("EEE MMM d hh:mm:ss z yyyy");
+    DEFAULT_DATE_FORMATS.addAll(DEFAULT_HTTP_CLIENT_PATTERNS);
+  }
+
+  /**
+   * Returns a formatter that can be use by the current thread if needed to
+   * convert Date objects to the Internal representation.
+   *
+   * @param d The input date to parse
+   * @return The parsed {@link java.util.Date}
+   * @throws java.text.ParseException If the input can't be parsed
+   * @throws org.apache.commons.httpclient.util.DateParseException
+   *                                  If the input can't be parsed
+   */
+  public static Date parseDate(String d) throws ParseException {
+    return parseDate(d, DEFAULT_DATE_FORMATS);
+  }
+
+  public static Date parseDate(String d, Collection<String> fmts) throws ParseException {
+    // 2007-04-26T08:05:04Z
+    if (d.endsWith("Z") && d.length() > 20) {
+      return getThreadLocalDateFormat().parse(d);
+    }
+    return parseDate(d, fmts, null);
+  }
+
+  /**
+   * Slightly modified from org.apache.commons.httpclient.util.DateUtil.parseDate
+   * <p/>
+   * Parses the date value using the given date formats.
+   *
+   * @param dateValue   the date value to parse
+   * @param dateFormats the date formats to use
+   * @param startDate   During parsing, two digit years will be placed in the range
+   *                    <code>startDate</code> to <code>startDate + 100 years</code>. This value may
+   *                    be <code>null</code>. When <code>null</code> is given as a parameter, year
+   *                    <code>2000</code> will be used.
+   * @return the parsed date
+   * @throws ParseException if none of the dataFormats could parse the dateValue
+   */
+  public static Date parseDate(
+          String dateValue,
+          Collection<String> dateFormats,
+          Date startDate
+  ) throws ParseException {
+
+    if (dateValue == null) {
+      throw new IllegalArgumentException("dateValue is null");
+    }
+    if (dateFormats == null) {
+      dateFormats = DEFAULT_HTTP_CLIENT_PATTERNS;
+    }
+    if (startDate == null) {
+      startDate = DEFAULT_TWO_DIGIT_YEAR_START;
+    }
+    // trim single quotes around date if present
+    // see issue #5279
+    if (dateValue.length() > 1
+            && dateValue.startsWith("'")
+            && dateValue.endsWith("'")
+            ) {
+      dateValue = dateValue.substring(1, dateValue.length() - 1);
+    }
+
+    SimpleDateFormat dateParser = null;
+    Iterator formatIter = dateFormats.iterator();
+
+    while (formatIter.hasNext()) {
+      String format = (String) formatIter.next();
+      if (dateParser == null) {
+        dateParser = new SimpleDateFormat(format, Locale.US);
+        dateParser.setTimeZone(GMT);
+        dateParser.set2DigitYearStart(startDate);
+      } else {
+        dateParser.applyPattern(format);
+      }
+      try {
+        return dateParser.parse(dateValue);
+      } catch (ParseException pe) {
+        // ignore this exception, we will try the next format
+      }
+    }
+
+    // we were unable to parse the date
+    throw new ParseException("Unable to parse the date " + dateValue, 0);
+  }
+
+
+  /**
+   * Returns a formatter that can be use by the current thread if needed to
+   * convert Date objects to the Internal representation.
+   *
+   * @return The {@link java.text.DateFormat} for the current thread
+   */
+  public static DateFormat getThreadLocalDateFormat() {
+    return fmtThreadLocal.get();
+  }
+
+  public static TimeZone UTC = TimeZone.getTimeZone("UTC");
+  private static ThreadLocalDateFormat fmtThreadLocal = new ThreadLocalDateFormat();
+
+  private static class ThreadLocalDateFormat extends ThreadLocal<DateFormat> {
+    DateFormat proto;
+
+    public ThreadLocalDateFormat() {
+      super();
+      //2007-04-26T08:05:04Z
+      SimpleDateFormat tmp = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
+      tmp.setTimeZone(UTC);
+      proto = tmp;
+    }
+
+    @Override
+    protected DateFormat initialValue() {
+      return (DateFormat) proto.clone();
+    }
+  }
+
+
+}
\ No newline at end of file
diff --git a/src/common/org/apache/solr/common/util/FastInputStream.java b/src/common/org/apache/solr/common/util/FastInputStream.java
new file mode 100755
index 0000000..3abddc5
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/FastInputStream.java
@@ -0,0 +1,211 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.*;
+
+/** Single threaded buffered InputStream
+ *  Internal Solr use only, subject to change.
+ */
+public class FastInputStream extends InputStream implements DataInput {
+  private final InputStream in;
+  private final byte[] buf;
+  private int pos;
+  private int end;
+
+  public FastInputStream(InputStream in) {
+  // use default BUFSIZE of BufferedOutputStream so if we wrap that
+  // it won't cause double buffering.
+    this(in, new byte[8192], 0, 0);
+  }
+
+  public FastInputStream(InputStream in, byte[] tempBuffer, int start, int end) {
+    this.in = in;
+    this.buf = tempBuffer;
+    this.pos = start;
+    this.end = end;
+  }
+
+
+  public static FastInputStream wrap(InputStream in) {
+    return (in instanceof FastInputStream) ? (FastInputStream)in : new FastInputStream(in);
+  }
+
+  @Override
+  public int read() throws IOException {
+    if (pos >= end) {
+      refill();
+      if (pos >= end) return -1;
+    }
+    return buf[pos++] & 0xff;     
+  }
+
+  public int readUnsignedByte() throws IOException {
+    if (pos >= end) {
+      refill();
+      if (pos >= end) throw new EOFException();
+    }
+    return buf[pos++] & 0xff;
+  }
+
+  public void refill() throws IOException {
+    // this will set end to -1 at EOF
+    end = in.read(buf, 0, buf.length);
+    pos = 0;
+  }
+
+  @Override
+  public int available() throws IOException {
+    return end - pos;
+  }
+
+  @Override
+  public int read(byte b[], int off, int len) throws IOException {
+    int r=0;  // number of bytes read
+    // first read from our buffer;
+    if (end-pos > 0) {
+      r = Math.min(end-pos, len);
+      System.arraycopy(buf, pos, b, off, r);      
+      pos += r;
+    }
+
+    if (r == len) return r;
+
+    // amount left to read is >= buffer size
+    if (len-r >= buf.length) {
+      int ret = in.read(b, off+r, len-r);
+      if (ret==-1) return r==0 ? -1 : r;
+      r += ret;
+      return r;
+    }
+
+    refill();
+
+    // first read from our buffer;
+    if (end-pos > 0) {
+      int toRead = Math.min(end-pos, len-r);
+      System.arraycopy(buf, pos, b, off+r, toRead);
+      pos += toRead;
+      r += toRead;
+      return r;
+    }
+    
+    return -1;
+  }
+
+  @Override
+  public void close() throws IOException {
+    in.close();
+  }
+
+  public void readFully(byte b[]) throws IOException {
+    readFully(b, 0, b.length);
+  }
+
+  public void readFully(byte b[], int off, int len) throws IOException {
+    while (len>0) {
+      int ret = read(b, off, len);
+      if (ret==-1) {
+        throw new EOFException();
+      }
+      off += ret;
+      len -= ret;
+    }
+  }
+
+  public int skipBytes(int n) throws IOException {
+    if (end-pos >= n) {
+      pos += n;
+      return n;
+    }
+
+    if (end-pos<0) return -1;
+    
+    int r = end-pos;
+    pos = end;
+
+    while (r < n) {
+      refill();
+      if (end-pos <= 0) return r;
+      int toRead = Math.min(end-pos, n-r);
+      r += toRead;
+      pos += toRead;
+    }
+
+    return r;
+  }
+
+  public boolean readBoolean() throws IOException {
+    return readByte()==1;
+  }
+
+  public byte readByte() throws IOException {
+    if (pos >= end) {
+      refill();
+      if (pos >= end) throw new EOFException();
+    }
+    return buf[pos++];
+  }
+
+
+  public short readShort() throws IOException {
+    return (short)((readUnsignedByte() << 8) | readUnsignedByte());
+  }
+
+  public int readUnsignedShort() throws IOException {
+    return (readUnsignedByte() << 8) | readUnsignedByte();
+  }
+
+  public char readChar() throws IOException {
+    return (char)((readUnsignedByte() << 8) | readUnsignedByte());
+  }
+
+  public int readInt() throws IOException {
+    return  ((readUnsignedByte() << 24)
+            |(readUnsignedByte() << 16)
+            |(readUnsignedByte() << 8)
+            | readUnsignedByte());
+  }
+
+  public long readLong() throws IOException {
+    return  (((long)readUnsignedByte()) << 56)
+            | (((long)readUnsignedByte()) << 48)
+            | (((long)readUnsignedByte()) << 40)
+            | (((long)readUnsignedByte()) << 32)
+            | (((long)readUnsignedByte()) << 24)
+            | (readUnsignedByte() << 16)
+            | (readUnsignedByte() << 8)
+            | (readUnsignedByte());
+  }
+
+  public float readFloat() throws IOException {
+    return Float.intBitsToFloat(readInt());    
+  }
+
+  public double readDouble() throws IOException {
+    return Double.longBitsToDouble(readLong());    
+  }
+
+  public String readLine() throws IOException {
+    return new DataInputStream(this).readLine();
+  }
+
+  public String readUTF() throws IOException {
+    return new DataInputStream(this).readUTF();
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/FastOutputStream.java b/src/common/org/apache/solr/common/util/FastOutputStream.java
new file mode 100755
index 0000000..3f6275c
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/FastOutputStream.java
@@ -0,0 +1,188 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.*;
+
+/** Single threaded buffered OutputStream
+ *  Internal Solr use only, subject to change.
+ */
+public class FastOutputStream extends OutputStream implements DataOutput {
+  private final OutputStream out;
+  private final byte[] buf;
+  private long written;  // how many bytes written
+  private int pos;
+
+  public FastOutputStream(OutputStream w) {
+  // use default BUFSIZE of BufferedOutputStream so if we wrap that
+  // it won't cause double buffering.
+    this(w, new byte[8192], 0);
+  }
+
+  public FastOutputStream(OutputStream sink, byte[] tempBuffer, int start) {
+    this.out = sink;
+    this.buf = tempBuffer;
+    this.pos = start;
+  }
+
+
+  public static FastOutputStream wrap(OutputStream sink) {
+   return (sink instanceof FastOutputStream) ? (FastOutputStream)sink : new FastOutputStream(sink);
+  }
+
+  @Override
+  public void write(int b) throws IOException {
+    write((byte)b);
+  }
+
+  public void write(byte b[]) throws IOException {
+  }
+
+  public void write(byte b) throws IOException {
+    if (pos >= buf.length) {
+      out.write(buf);
+      written += pos;
+      pos=0;
+    }
+    buf[pos++] = b;
+  }
+
+  @Override
+  public void write(byte arr[], int off, int len) throws IOException {
+    int space = buf.length - pos;
+    if (len < space) {
+      System.arraycopy(arr, off, buf, pos, len);
+      pos += len;
+    } else if (len<buf.length) {
+      // if the data to write is small enough, buffer it.
+      System.arraycopy(arr, off, buf, pos, space);
+      out.write(buf);
+      written += pos;
+      pos = len-space;
+      System.arraycopy(arr, off+space, buf, 0, pos);
+    } else {
+      out.write(buf,0,pos);  // flush
+      written += pos;
+      pos=0;
+      // don't buffer, just write to sink
+      out.write(arr, off, len);
+      written += len;            
+    }
+  }
+
+  /** reserve at least len bytes at the end of the buffer.
+   * Invalid if len > buffer.length
+   * @param len
+   */
+  public void reserve(int len) throws IOException {
+    if (len > (buf.length - pos))
+      flushBuffer();
+  }
+
+  ////////////////// DataOutput methods ///////////////////
+  public void writeBoolean(boolean v) throws IOException {
+    write(v ? 1:0);
+  }
+
+  public void writeByte(int v) throws IOException {
+    write((byte)v);
+  }
+
+  public void writeShort(int v) throws IOException {
+    write((byte)(v >>> 8));
+    write((byte)v);
+  }
+
+  public void writeChar(int v) throws IOException {
+    writeShort(v);
+  }
+
+  public void writeInt(int v) throws IOException {
+    reserve(4);
+    buf[pos] = (byte)(v>>>24);
+    buf[pos+1] = (byte)(v>>>16);
+    buf[pos+2] = (byte)(v>>>8);
+    buf[pos+3] = (byte)(v);
+    pos+=4;
+  }
+
+  public void writeLong(long v) throws IOException {
+    reserve(8);
+    buf[pos] = (byte)(v>>>56);
+    buf[pos+1] = (byte)(v>>>48);
+    buf[pos+2] = (byte)(v>>>40);
+    buf[pos+3] = (byte)(v>>>32);
+    buf[pos+4] = (byte)(v>>>24);
+    buf[pos+5] = (byte)(v>>>16);
+    buf[pos+6] = (byte)(v>>>8);
+    buf[pos+7] = (byte)(v);
+    pos+=8;
+  }
+
+  public void writeFloat(float v) throws IOException {
+    writeInt(Float.floatToRawIntBits(v));
+  }
+
+  public void writeDouble(double v) throws IOException {
+    writeLong(Double.doubleToRawLongBits(v));
+  }
+
+  public void writeBytes(String s) throws IOException {
+    // non-optimized version, but this shouldn't be used anyway
+    for (int i=0; i<s.length(); i++)
+      write((byte)s.charAt(i));
+  }
+
+  public void writeChars(String s) throws IOException {
+    // non-optimized version
+    for (int i=0; i<s.length(); i++)
+      writeChar(s.charAt(i)); 
+  }
+
+  public void writeUTF(String s) throws IOException {
+    // non-optimized version, but this shouldn't be used anyway
+    DataOutputStream daos = new DataOutputStream(this);
+    daos.writeUTF(s);
+  }
+
+
+  @Override
+  public void flush() throws IOException {
+    flushBuffer();
+    out.flush();
+  }
+
+  @Override
+  public void close() throws IOException {
+    flushBuffer();
+    out.close();
+  }
+
+  /** Only flushes the buffer of the FastOutputStream, not that of the
+   * underlying stream.
+   */
+  public void flushBuffer() throws IOException {
+    out.write(buf, 0, pos);
+    written += pos;
+    pos=0;
+  }
+
+  public long size() {
+    return written + pos;
+  }
+}
\ No newline at end of file
diff --git a/src/common/org/apache/solr/common/util/FastWriter.java b/src/common/org/apache/solr/common/util/FastWriter.java
new file mode 100755
index 0000000..45f06e4
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/FastWriter.java
@@ -0,0 +1,128 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.Writer;
+import java.io.IOException;
+
+/** Single threaded BufferedWriter
+ *  Internal Solr use only, subject to change.
+ */
+public class FastWriter extends Writer {
+  // use default BUFSIZE of BufferedWriter so if we wrap that
+  // it won't cause double buffering.
+  private static final int BUFSIZE = 8192;
+  private final Writer sink;
+  private final char[] buf;
+  private int pos;
+
+  public FastWriter(Writer w) {
+    this(w, new char[BUFSIZE], 0);
+  }
+
+  public FastWriter(Writer sink, char[] tempBuffer, int start) {
+    this.sink = sink;
+    this.buf = tempBuffer;
+    this.pos = start;
+  }
+
+  public static FastWriter wrap(Writer sink) {
+    return (sink instanceof FastWriter) ? (FastWriter)sink : new FastWriter(sink);
+  }
+
+  @Override
+  public void write(int c) throws IOException {
+    write((char)c); 
+  }
+
+  public void write(char c) throws IOException {
+    if (pos >= buf.length) {
+      sink.write(buf,0,pos);
+      pos=0;
+    }
+    buf[pos++] = (char)c;
+  }
+
+  @Override
+  public FastWriter append(char c) throws IOException {
+    if (pos >= buf.length) {
+      sink.write(buf,0,pos);
+      pos=0;
+    }
+    buf[pos++] = (char)c;
+    return this;
+  }
+
+  @Override
+  public void write(char cbuf[], int off, int len) throws IOException {
+    int space = buf.length - pos;
+    if (len < space) {
+      System.arraycopy(cbuf, off, buf, pos, len);
+      pos += len;
+    } else if (len<BUFSIZE) {
+      // if the data to write is small enough, buffer it.
+      System.arraycopy(cbuf, off, buf, pos, space);
+      sink.write(buf, 0, buf.length);
+      pos = len-space;
+      System.arraycopy(cbuf, off+space, buf, 0, pos);
+    } else {
+      sink.write(buf,0,pos);  // flush
+      pos=0;
+      // don't buffer, just write to sink
+      sink.write(cbuf, off, len);
+    }
+  }
+
+  @Override
+  public void write(String str, int off, int len) throws IOException {
+    int space = buf.length - pos;
+    if (len < space) {
+      str.getChars(off, off+len, buf, pos);
+      pos += len;
+    } else if (len<BUFSIZE) {
+      // if the data to write is small enough, buffer it.
+      str.getChars(off, off+space, buf, pos);
+      sink.write(buf, 0, buf.length);
+      str.getChars(off+space, off+len, buf, 0);
+      pos = len-space;
+    } else {
+      sink.write(buf,0,pos);  // flush
+      pos=0;
+      // don't buffer, just write to sink
+      sink.write(str, off, len);
+    }
+  }
+
+  @Override
+  public void flush() throws IOException {
+    sink.write(buf,0,pos);
+    pos=0;
+    sink.flush();
+  }
+
+  @Override
+  public void close() throws IOException {
+    flush();
+    sink.close();
+  }
+
+  public void flushBuffer() throws IOException {
+    sink.write(buf, 0, pos);
+    pos=0;
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/IteratorChain.java b/src/common/org/apache/solr/common/util/IteratorChain.java
new file mode 100644
index 0000000..a477180
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/IteratorChain.java
@@ -0,0 +1,82 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/** Chain several Iterators, so that this iterates
+ *  over all of them in sequence.
+ */
+
+public class IteratorChain<E> implements Iterator<E> {
+
+  private final List<Iterator<E>> iterators = new ArrayList<Iterator<E>>();
+  private Iterator<Iterator<E>> itit;
+  private Iterator<E> current;
+ 
+  public void addIterator(Iterator<E> it) {
+    if(itit!=null) throw new RuntimeException("all Iterators must be added before calling hasNext()");
+    iterators.add(it);
+  }
+  
+  public boolean hasNext() {
+    if(itit==null) itit = iterators.iterator();
+    return recursiveHasNext();
+  }
+  
+  /** test if current iterator hasNext(), and if not try the next
+   *  one in sequence, recursively
+   */
+  private boolean recursiveHasNext() {
+    // return false if we have no more iterators
+    if(current==null) {
+      if(itit.hasNext()) {
+        current=itit.next();
+      } else {
+        return false;
+      }
+    }
+    
+    boolean result = current.hasNext();
+    if(!result) {
+      current = null;
+      result = recursiveHasNext();
+    }
+    
+    return result;
+  }
+
+  /** hasNext() must ALWAYS be called before calling this
+   *  otherwise it's a bit hard to keep track of what's happening
+   */
+  public E next() {
+    if(current==null) { 
+      throw new RuntimeException("For an IteratorChain, hasNext() MUST be called before calling next()");
+    }
+    return current.next();
+  }
+
+  public void remove() {
+    // we just need this class 
+    // to iterate in readonly mode
+    throw new UnsupportedOperationException();
+  }
+  
+}
diff --git a/src/common/org/apache/solr/common/util/NamedList.java b/src/common/org/apache/solr/common/util/NamedList.java
new file mode 100644
index 0000000..4439f8c
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/NamedList.java
@@ -0,0 +1,296 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.*;
+import java.io.Serializable;
+
+
+
+/**
+ * A simple container class for modeling an ordered list of name/value pairs.
+ *
+ * <p>
+ * Unlike Maps:
+ * </p>
+ * <ul>
+ *  <li>Names may be repeated</li>
+ *  <li>Order of elements is maintained</li>
+ *  <li>Elements may be accessed by numeric index</li>
+ *  <li>Names and Values can both be null</li>
+ * </ul>
+ *
+ * <p>
+ * A NamedList provides fast access by element number, but not by name.
+ * </p>
+ * <p>
+ * When a NamedList is serialized, order is considered more important than access
+ * by key, so ResponseWriters that output to a format such as JSON will normally
+ * choose a data structure that allows order to be easily preserved in various
+ * clients (i.e. not a straight map).
+ * If access by key is more important, see {@link SimpleOrderedMap},
+ * or simply use a regular {@link Map}
+ * </p>
+ *
+ * @version $Id$
+ */
+public class NamedList<T> implements Cloneable, Serializable, Iterable<Map.Entry<String,T>> {
+  protected final List nvPairs;
+
+  /** Creates an empty instance */
+  public NamedList() {
+    nvPairs = new ArrayList();
+  }
+
+  /**
+   * Creates an instance backed by an explicitly specified list of
+   * pairwise names/values.
+   *
+   * @param nameValuePairs underlying List which should be used to implement a NamedList; modifying this List will affect the NamedList.
+   */
+  public NamedList(List nameValuePairs) {
+    nvPairs=nameValuePairs;
+  }
+
+  /** The total number of name/value pairs */
+  public int size() {
+    return nvPairs.size() >> 1;
+  }
+
+  /**
+   * The name of the pair at the specified List index
+   *
+   * @return null if no name exists
+   */
+  public String getName(int idx) {
+    return (String)nvPairs.get(idx << 1);
+  }
+
+  /**
+   * The value of the pair at the specified List index
+   *
+   * @return may be null
+   */
+  @SuppressWarnings("unchecked")
+  public T getVal(int idx) {
+    return (T)nvPairs.get((idx << 1) + 1);
+  }
+  
+  /**
+   * Adds a name/value pair to the end of the list.
+   */
+  public void add(String name, T val) {
+    nvPairs.add(name);
+    nvPairs.add(val);
+  }
+
+  /**
+   * Modifies the name of the pair at the specified index.
+   */
+  public void setName(int idx, String name) {
+    nvPairs.set(idx<<1, name);
+  }
+
+  /**
+   * Modifies the value of the pair at the specified index.
+   * @return the value that used to be at index
+   */
+  public T setVal(int idx, T val) {
+    int index = (idx<<1)+1;
+    T old = (T)nvPairs.get( index );
+    nvPairs.set(index, val);
+    return old;
+  }
+
+  /**
+   * Removes the name/value pair at the specified index.
+   * @return the value at the index removed
+   */
+  public T remove(int idx) {
+    int index = (idx<<1);
+    nvPairs.remove(index);
+    return (T)nvPairs.remove(index);  // same index, as things shifted in previous remove
+  }
+
+  /**
+   * Scans the list sequentially beginning at the specified index and
+   * returns the index of the first pair with the specified name.
+   *
+   * @param name name to look for, may be null
+   * @param start index to begin searching from
+   * @return The index of the first matching pair, -1 if no match
+   */
+  public int indexOf(String name, int start) {
+    int sz = size();
+    for (int i=start; i<sz; i++) {
+      String n = getName(i);
+      if (name==null) {
+        if (n==null) return i; // matched null
+      } else if (name.equals(n)) {
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  /**
+   * Gets the value for the first instance of the specified name
+   * found.
+   * 
+   * @return null if not found or if the value stored was null.
+   * @see #indexOf
+   * @see #get(String,int)
+   */
+  public T get(String name) {
+    return get(name,0);
+  }
+
+  /**
+   * Gets the value for the first instance of the specified name
+   * found starting at the specified index.
+   * 
+   * @return null if not found or if the value stored was null.
+   * @see #indexOf
+   */
+  public T get(String name, int start) {
+    int sz = size();
+    for (int i=start; i<sz; i++) {
+      String n = getName(i);
+      if (name==null) {
+        if (n==null) return getVal(i);
+      } else if (name.equals(n)) {
+        return getVal(i);
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Gets the values for the the specified name
+   * @param name Name
+   * @return List of values
+   */
+  public List<T> getAll(String name) {
+    List<T> result = new ArrayList<T>();
+    int sz = size();
+    for (int i = 0; i < sz; i++) {
+      String n = getName(i);
+      if (name==n || (name!=null && name.equals(n))) {
+        result.add(getVal(i));
+      }
+    }
+    return result;
+  }
+
+  public String toString() {
+    StringBuffer sb = new StringBuffer();
+    sb.append('{');
+    int sz = size();
+    for (int i=0; i<sz; i++) {
+      if (i != 0) sb.append(',');
+      sb.append(getName(i));
+      sb.append('=');
+      sb.append(getVal(i));
+    }
+    sb.append('}');
+
+    return sb.toString();
+  }
+
+  /**
+   * Iterates over the Map and sequentially adds it's key/value pairs
+   */
+  public boolean addAll(Map<String,T> args) {
+    for( Map.Entry<String, T> entry : args.entrySet() ) {
+      add( entry.getKey(), entry.getValue() );
+    }
+    return args.size()>0;
+  }
+
+  /** Appends the elements of the given NamedList to this one. */
+  public boolean addAll(NamedList<T> nl) {
+    nvPairs.addAll(nl.nvPairs);
+    return nl.size()>0;
+  }
+
+  /**
+   * Makes a <i>shallow copy</i> of the named list.
+   */
+  public NamedList<T> clone() {
+    ArrayList newList = new ArrayList(nvPairs.size());
+    newList.addAll(nvPairs);
+    return new NamedList<T>(newList);
+  }
+
+
+  //----------------------------------------------------------------------------
+  // Iterable interface
+  //----------------------------------------------------------------------------
+  
+  /**
+   * Support the Iterable interface
+   */
+  public Iterator<Map.Entry<String,T>> iterator() {
+    
+    final NamedList list = this;
+    
+    Iterator<Map.Entry<String,T>> iter = new Iterator<Map.Entry<String,T>>() {
+      
+      int idx = 0;
+      
+      public boolean hasNext() {
+        return idx < list.size();
+      }
+
+      public Map.Entry<String,T> next() {
+        final int index = idx++;
+        Map.Entry<String,T> nv = new Map.Entry<String,T>() {
+          public String getKey() {
+            return list.getName( index );
+          }
+
+          @SuppressWarnings("unchecked")
+          public T getValue() {
+            return (T)list.getVal( index );
+          }
+          
+          public String toString()
+          {
+        	  return getKey()+"="+getValue();
+          }
+
+    		  public T setValue(T value) {
+    		    return (T) list.setVal(index, value);
+    		  }
+        };
+        return nv;
+      }
+
+      public void remove() {
+        throw new UnsupportedOperationException();
+      }
+    };
+    return iter;
+  }
+
+  public T remove(String name) {
+    int idx = indexOf(name, 0);
+    if(idx != -1) return remove(idx);
+    return null;
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/NamedListCodec.java b/src/common/org/apache/solr/common/util/NamedListCodec.java
new file mode 100755
index 0000000..df3f6e0
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/NamedListCodec.java
@@ -0,0 +1,652 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.common.util;
+
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ * The class is designed to optimaly serialize/deserialize a NamedList. As we know there are only
+ * a limited type of items this class can do it with very minimal amount of payload and code. There are
+ * 15 known types and if there is an object in the object tree which does not fall into these types, It must be
+ * converted to one of these. Implement an ObjectResolver and pass it over
+ * It is expected that this class is used on both end of the pipes.
+ * The class has one read method and one write method for each of the datatypes
+ *
+ */
+public class NamedListCodec {
+
+  public static final byte
+          NULL = 0,
+          BOOL_TRUE = 1,
+          BOOL_FALSE = 2,
+          BYTE = 3,
+          SHORT = 4,
+          DOUBLE = 5,
+          INT = 6,
+          LONG = 7,
+          FLOAT = 8,
+          DATE = 9,
+          MAP = 10,
+          SOLRDOC = 11,
+          SOLRDOCLST = 12,
+          BYTEARR = 13,
+          ITERATOR = 14,
+          /** this is a special tag signals an end. No value is associated with it*/
+          END = 15,
+
+          // types that combine tag + length (or other info) in a single byte
+          TAG_AND_LEN=(byte)(1 << 5),
+          STR =       (byte)(1 << 5),
+          SINT =      (byte)(2 << 5),
+          SLONG =     (byte)(3 << 5),
+          ARR =       (byte)(4 << 5), //
+          ORDERED_MAP=(byte)(5 << 5), // SimpleOrderedMap (a NamedList subclass, and more common)
+          NAMED_LST = (byte)(6 << 5), // NamedList
+          EXTERN_STRING = (byte)(7 << 5);
+
+
+  private byte VERSION = 1;
+  private ObjectResolver resolver;
+  private FastOutputStream daos;
+
+  public NamedListCodec() { }
+
+  public NamedListCodec(ObjectResolver resolver) {
+    this.resolver = resolver;
+  }
+  
+  public void marshal(NamedList nl, OutputStream os) throws IOException {
+    daos = FastOutputStream.wrap(os);
+    try {
+      daos.writeByte(VERSION);
+      writeNamedList(nl);
+    } finally {
+      daos.flushBuffer();      
+    }
+  }
+
+  public NamedList unmarshal(InputStream is) throws IOException {
+    FastInputStream dis = FastInputStream.wrap(is);
+    byte version = dis.readByte();
+    return (NamedList)readVal(dis);
+  }
+
+
+  public SimpleOrderedMap readOrderedMap(FastInputStream dis) throws IOException {
+    int sz = readSize(dis);
+    SimpleOrderedMap nl = new SimpleOrderedMap();
+    for (int i = 0; i < sz; i++) {
+      String name = (String)readVal(dis);
+      Object val = readVal(dis);
+      nl.add(name, val);
+    }
+    return nl;
+  }
+
+  public NamedList readNamedList(FastInputStream dis) throws IOException {
+    int sz = readSize(dis);
+    NamedList nl = new NamedList();
+    for (int i = 0; i < sz; i++) {
+      String name = (String)readVal(dis);
+      Object val = readVal(dis);
+      nl.add(name, val);
+    }
+    return nl;
+  }
+
+  public void writeNamedList(NamedList nl) throws IOException {
+    writeTag(nl instanceof SimpleOrderedMap ? ORDERED_MAP : NAMED_LST, nl.size());
+    for (int i = 0; i < nl.size(); i++) {
+      String name = nl.getName(i);
+      writeExternString(name);
+      Object val = nl.getVal(i);
+      writeVal(val);
+    }
+  }
+
+  public void writeVal(Object val) throws IOException {
+    if (writeKnownType(val)) {
+      return;
+    } else {
+      Object tmpVal = val;
+      if(resolver !=null) {
+        tmpVal = resolver.resolve(val, this);
+        if (tmpVal == null) return; // null means the resolver took care of it fully
+        if(writeKnownType(tmpVal)) return;
+      }
+    }
+
+    writeVal(val.getClass().getName() + ':' + val.toString());
+  }
+  private static final Object END_OBJ = new Object();
+
+  byte tagByte;
+  public Object readVal(FastInputStream dis) throws IOException {
+    tagByte = dis.readByte();
+
+    // if ((tagByte & 0xe0) == 0) {
+    // if top 3 bits are clear, this is a normal tag
+
+    // OK, try type + size in single byte
+    switch(tagByte>>>5) {
+      case STR >>> 5         : return readStr(dis);
+      case SINT >>>5         : return readSmallInt(dis);
+      case SLONG >>>5        : return readSmallLong(dis);
+      case ARR >>> 5         : return readArray(dis);
+      case ORDERED_MAP >>> 5 : return readOrderedMap(dis);
+      case NAMED_LST >>> 5   : return readNamedList(dis);
+      case EXTERN_STRING >>> 5   : return readExternString(dis);
+    }
+
+    switch(tagByte){
+      case NULL : return null;
+      case DATE : return new Date(dis.readLong());
+      case INT : return dis.readInt();
+      case BOOL_TRUE : return Boolean.TRUE;
+      case BOOL_FALSE : return Boolean.FALSE;
+      case FLOAT : return dis.readFloat();
+      case DOUBLE : return dis.readDouble();
+      case LONG : return dis.readLong();
+      case BYTE : return dis.readByte();
+      case SHORT : return dis.readShort();
+      case MAP : return readMap(dis);
+      case SOLRDOC : return readSolrDocument(dis);
+      case SOLRDOCLST : return readSolrDocumentList(dis);
+      case BYTEARR : return readByteArray(dis);
+      case ITERATOR : return readIterator(dis);
+      case END : return END_OBJ;
+    }
+
+    throw new RuntimeException("Unknown type " + tagByte);
+  }
+
+  public boolean writeKnownType(Object val) throws IOException {
+    if (writePrimitive(val)) return true;
+    if (val instanceof NamedList) {
+      writeNamedList((NamedList) val);
+      return true;
+    }
+    if (val instanceof SolrDocumentList) { // SolrDocumentList is a List, so must come before List check
+      writeSolrDocumentList((SolrDocumentList) val);
+      return true;
+    }
+    if (val instanceof List) {
+      writeArray((List) val);
+      return true;
+    }
+    if (val instanceof Object[]) {
+      writeArray((Object[]) val);
+      return true;
+    }
+    if (val instanceof SolrDocument) {
+      //this needs special treatment to know which fields are to be written
+      if(resolver == null){
+        writeSolrDocument((SolrDocument) val);
+      }else {
+        Object retVal = resolver.resolve(val, this);
+        if(retVal != null) {
+          if (retVal instanceof SolrDocument) {
+            writeSolrDocument((SolrDocument) retVal);
+          } else {
+            writeVal(retVal);
+          }
+        }
+      }
+      return true;
+    }
+    if (val instanceof Map) {
+      writeMap((Map) val);
+      return true;
+    }
+    if (val instanceof Iterator) {
+      writeIterator((Iterator) val);
+      return true;
+    }
+    if (val instanceof Iterable) {
+      writeIterator(((Iterable)val).iterator());
+      return true;
+    }
+    return false;
+  }
+
+  public void writeTag(byte tag) throws IOException {
+    daos.writeByte(tag);
+  }
+  
+  public void writeTag(byte tag, int size) throws IOException {
+    if ((tag & 0xe0) != 0) {
+      if (size < 0x1f) {
+        daos.writeByte(tag | size);
+      } else {
+        daos.writeByte(tag | 0x1f);
+        writeVInt(size-0x1f, daos);
+      }
+    } else {
+      daos.writeByte(tag);
+      writeVInt(size, daos);       
+    }
+  }
+
+  public void writeByteArray(byte[] arr, int offset, int len) throws IOException {
+    writeTag(BYTEARR, len);
+    daos.write(arr, offset, len);
+  }
+
+  public byte[] readByteArray(FastInputStream dis) throws IOException {
+    byte[] arr = new byte[readVInt(dis)];
+    dis.readFully(arr);
+    return arr;
+  }
+
+  public void writeSolrDocument(SolrDocument doc) throws IOException {
+    writeSolrDocument(doc, null);
+  }
+  public void writeSolrDocument(SolrDocument doc, Set<String> fields) throws IOException {
+    int count = 0;
+    if (fields == null) {
+      count = doc.getFieldNames().size();
+    } else {
+      for (Map.Entry<String, Object> entry : doc) {
+        if (fields.contains(entry.getKey())) count++;
+      }
+    }
+    writeTag(SOLRDOC);
+    writeTag(ORDERED_MAP, count);
+    for (Map.Entry<String, Object> entry : doc) {
+      if (fields == null || fields.contains(entry.getKey())) {
+        String name = entry.getKey();
+        writeExternString(name);
+        Object val = entry.getValue();
+        writeVal(val);
+      }
+    }
+  }
+
+   public SolrDocument readSolrDocument(FastInputStream dis) throws IOException {
+    NamedList nl = (NamedList) readVal(dis);
+    SolrDocument doc = new SolrDocument();
+    for (int i = 0; i < nl.size(); i++) {
+      String name = nl.getName(i);
+      Object val = nl.getVal(i);
+      doc.setField(name, val);
+    }
+    return doc;
+  }
+
+  public SolrDocumentList readSolrDocumentList(FastInputStream dis) throws IOException {
+    SolrDocumentList solrDocs = new SolrDocumentList();
+    List list = (List) readVal(dis);
+    solrDocs.setNumFound((Long) list.get(0));
+    solrDocs.setStart((Long)list.get(1));
+    solrDocs.setMaxScore((Float)list.get(2));
+
+    List l = (List) readVal(dis);
+    solrDocs.addAll(l);
+    return solrDocs;
+  }
+
+   public void writeSolrDocumentList(SolrDocumentList docs)
+         throws IOException {
+     writeTag(SOLRDOCLST);
+     List l = new ArrayList(3);
+     l.add(docs.getNumFound());
+     l.add(docs.getStart());
+     l.add(docs.getMaxScore());
+     writeArray(l);
+     writeArray(docs);
+   }
+
+  public Map readMap(FastInputStream dis)
+          throws IOException {
+    int sz = readVInt(dis);
+    Map m = new LinkedHashMap();
+    for (int i = 0; i < sz; i++) {
+      Object key = readVal(dis);
+      Object val = readVal(dis);
+      m.put(key, val);
+
+    }
+    return m;
+  }
+
+  public void writeIterator(Iterator iter) throws IOException {
+    writeTag(ITERATOR);
+    while (iter.hasNext()) {
+      writeVal(iter.next());
+    }
+    writeVal(END_OBJ);
+  }
+
+  public List readIterator(FastInputStream fis) throws IOException {
+    ArrayList l = new ArrayList();
+    while(true){
+      Object  o = readVal(fis);
+      if(o == END_OBJ) break;
+      l.add(o);
+    }
+    return l;
+  }
+
+  public void writeArray(List l) throws IOException {
+    writeTag(ARR, l.size());
+    for (int i = 0; i < l.size(); i++) {
+      writeVal(l.get(i));
+    }
+  }
+
+  public void writeArray(Object[] arr) throws IOException {
+    writeTag(ARR, arr.length);
+    for (int i = 0; i < arr.length; i++) {
+      Object o = arr[i];
+      writeVal(o);
+    }
+  }
+
+  public List readArray(FastInputStream dis) throws IOException {
+    int sz = readSize(dis);
+    ArrayList l = new ArrayList(sz);
+    for (int i = 0; i < sz; i++) {
+      l.add(readVal(dis));
+    }
+    return l;
+  }
+
+  /** write the string as tag+length, with length being the number of UTF-16 characters,
+   * followed by the string encoded in modified-UTF8 
+   */
+  public void writeStr(String s) throws IOException {
+    if (s==null) {
+      writeTag(NULL);
+      return;
+    }
+    // Can't use string serialization or toUTF()... it's limited to 64K
+    // plus it's bigger than it needs to be for small strings anyway
+    int len = s.length();
+    writeTag(STR, len);
+    writeChars(daos, s, 0, len);
+  }
+
+
+  char[] charArr;
+  private String readStr(FastInputStream dis) throws IOException {
+    int sz = readSize(dis);
+    if (charArr==null || charArr.length < sz) {
+      charArr = new char[sz];
+    }
+    readChars(dis, charArr, 0, sz);
+    return new String(charArr, 0, sz);
+  }
+
+  public void writeInt(int val) throws IOException {
+    if (val>0) {
+      int b = SINT | (val & 0x0f);
+
+      if (val >= 0x0f) {
+        b |= 0x10;
+        daos.writeByte(b);
+        writeVInt(val>>>4, daos);
+      } else {
+        daos.writeByte(b);
+      }
+
+    } else {
+      daos.writeByte(INT);
+      daos.writeInt(val);
+    }
+  }
+
+  public int readSmallInt(FastInputStream dis) throws IOException {
+    int v = tagByte & 0x0F;
+    if ((tagByte & 0x10) != 0)
+      v = (readVInt(dis)<<4) | v;
+    return v;
+  }
+
+
+  public void writeLong(long val) throws IOException {
+    if ((val & 0xff00000000000000L) == 0) {
+      int b = SLONG | ((int)val & 0x0f);
+      if (val >= 0x0f) {
+        b |= 0x10;
+        daos.writeByte(b);
+        writeVLong(val>>>4, daos);
+      } else {
+        daos.writeByte(b);
+      }
+    } else {
+      daos.writeByte(LONG);
+      daos.writeLong(val);
+    }
+  }
+
+  public long readSmallLong(FastInputStream dis) throws IOException {
+    long v = tagByte & 0x0F;
+    if ((tagByte & 0x10) != 0)
+      v = (readVLong(dis)<<4) | v;
+    return v;
+  }
+
+  public boolean writePrimitive(Object val) throws IOException {
+    if (val == null) {
+      daos.writeByte(NULL);
+      return true;
+    } else if (val instanceof String) {
+      writeStr((String)val);
+      return true;
+    } else if (val instanceof Integer) {
+      writeInt(((Integer)val).intValue());
+      return true;
+    } else if (val instanceof Long) {
+      writeLong(((Long)val).longValue());
+      return true;
+    } else if (val instanceof Float) {
+      daos.writeByte(FLOAT);
+      daos.writeFloat(((Float) val).floatValue());
+      return true;
+    } else if (val instanceof Date) {
+      daos.writeByte(DATE);
+      daos.writeLong(((Date) val).getTime());
+      return true;
+    } else if (val instanceof Boolean) {
+      if ((Boolean) val) daos.writeByte(BOOL_TRUE);
+      else daos.writeByte(BOOL_FALSE);
+      return true;
+    } else if (val instanceof Double) {
+      daos.writeByte(DOUBLE);
+      daos.writeDouble(((Double) val).doubleValue());
+      return true;
+    } else if (val instanceof Byte) {
+      daos.writeByte(BYTE);
+      daos.writeByte(((Byte) val).intValue());
+      return true;
+    } else if (val instanceof Short) {
+      daos.writeByte(SHORT);
+      daos.writeShort(((Short) val).intValue());
+      return true;
+    } else if (val instanceof byte[]) {
+      writeByteArray((byte[])val, 0, ((byte[])val).length);
+      return true;
+    } else if (val == END_OBJ) {
+      writeTag(END);
+      return true;
+    }
+    return false;
+  }
+
+  public void writeMap( Map val)
+          throws IOException {
+    writeTag(MAP, val.size());
+    for (Map.Entry entry : (Set<Map.Entry>) val.entrySet()) {
+      Object key = entry.getKey();
+      if (key instanceof String) {
+        writeExternString((String) key);
+      } else {
+        writeVal(key);
+      }
+      writeVal(entry.getValue());
+    }
+  }
+
+
+  public int readSize(FastInputStream in) throws IOException {
+    int sz = tagByte & 0x1f;
+    if (sz == 0x1f) sz += readVInt(in);
+    return sz;
+  }
+
+
+
+  /**
+   * Special method for variable length int (copied from lucene). Usually used for writing the length of a collection/array/map
+   * In most of the cases the length can be represented in one byte (length < 127) so it saves 3 bytes/object
+   *
+   * @param i
+   * @param out
+   * @throws IOException
+   */
+  public static void writeVInt(int i, FastOutputStream out) throws IOException {
+    while ((i & ~0x7F) != 0) {
+      out.writeByte((byte) ((i & 0x7f) | 0x80));
+      i >>>= 7;
+    }
+    out.writeByte((byte) i);
+  }
+
+  /**
+   * The counterpart for the above
+   *
+   * @param in
+   * @return the int value
+   * @throws IOException
+   */
+  public static int readVInt(FastInputStream in) throws IOException {
+    byte b = in.readByte();
+    int i = b & 0x7F;
+    for (int shift = 7; (b & 0x80) != 0; shift += 7) {
+      b = in.readByte();
+      i |= (b & 0x7F) << shift;
+    }
+    return i;
+  }
+
+
+  public static void writeVLong(long i, FastOutputStream out) throws IOException {
+    while ((i & ~0x7F) != 0) {
+      out.writeByte((byte)((i & 0x7f) | 0x80));
+      i >>>= 7;
+    }
+    out.writeByte((byte) i);
+  }
+
+  public static long readVLong(FastInputStream in) throws IOException {
+    byte b = in.readByte();
+    long i = b & 0x7F;
+    for (int shift = 7; (b & 0x80) != 0; shift += 7) {
+      b = in.readByte();
+      i |= (long)(b & 0x7F) << shift;
+    }
+    return i;
+  }
+
+  /** Writes a sequence of UTF-8 encoded characters from a string.
+   * @param s the source of the characters
+   * @param start the first character in the sequence
+   * @param length the number of characters in the sequence
+   * @see org.apache.lucene.store.IndexInput#readChars(char[],int,int)
+   */
+  public static void writeChars(FastOutputStream os, String s, int start, int length)
+       throws IOException {
+    final int end = start + length;
+    for (int i = start; i < end; i++) {
+      final int code = (int)s.charAt(i);
+      if (code >= 0x01 && code <= 0x7F)
+	os.write(code);
+      else if (((code >= 0x80) && (code <= 0x7FF)) || code == 0) {
+	os.write(0xC0 | (code >> 6));
+	os.write(0x80 | (code & 0x3F));
+      } else {
+	os.write(0xE0 | (code >>> 12));
+	os.write(0x80 | ((code >> 6) & 0x3F));
+	os.write(0x80 | (code & 0x3F));
+      }
+    }
+  }
+
+  /** Reads UTF-8 encoded characters into an array.
+   * @param buffer the array to read characters into
+   * @param start the offset in the array to start storing characters
+   * @param length the number of characters to read
+   * @see org.apache.lucene.store.IndexOutput#writeChars(String,int,int)
+   */
+  public static void readChars(FastInputStream in, char[] buffer, int start, int length)
+       throws IOException {
+    final int end = start + length;
+    for (int i = start; i < end; i++) {
+      int b = in.read();
+      if ((b & 0x80) == 0)
+	buffer[i] = (char)b;
+      else if ((b & 0xE0) != 0xE0) {
+	buffer[i] = (char)(((b & 0x1F) << 6)
+		 | (in.read() & 0x3F));
+      } else
+	buffer[i] = (char)(((b & 0x0F) << 12)
+		| ((in.read() & 0x3F) << 6)
+	        |  (in.read() & 0x3F));
+    }
+  }
+
+  private int stringsCount  =  0;
+  private Map<String,Integer> stringsMap;
+  private List<String > stringsList;
+  public void writeExternString(String s) throws IOException {
+    if(s == null) {
+      writeTag(NULL) ;
+      return;
+    }
+    Integer idx = stringsMap == null ? null : stringsMap.get(s);
+    if(idx == null) idx =0;
+    writeTag(EXTERN_STRING,idx);
+    if(idx == 0){
+      writeStr(s);
+      if(stringsMap == null) stringsMap = new HashMap<String, Integer>();
+      stringsMap.put(s,++stringsCount);
+    }
+
+  }
+  public String  readExternString(FastInputStream fis) throws IOException {
+    int idx = readSize(fis);
+    if (idx != 0) {// idx != 0 is the index of the extern string
+      return stringsList.get(idx-1);
+    } else {// idx == 0 means it has a string value
+      String s = (String) readVal(fis);
+      if(stringsList == null ) stringsList = new ArrayList<String>();
+      stringsList.add(s);
+      return s;
+    }
+  }
+
+
+  public static interface ObjectResolver{
+    public Object resolve(Object o, NamedListCodec codec) throws IOException;
+  }
+
+
+}
diff --git a/src/common/org/apache/solr/common/util/RTimer.java b/src/common/org/apache/solr/common/util/RTimer.java
new file mode 100644
index 0000000..95c5b05
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/RTimer.java
@@ -0,0 +1,146 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.lang.System;
+import java.lang.Thread;
+import java.util.*;
+
+/** A recursive timer.
+ * 
+ * RTimers are started automatically when instantiated; subtimers are also
+ * started automatically when created.
+ *
+ * @since solr 1.3
+ * @version $Id$
+ */
+public class RTimer {
+
+  public static final int STARTED = 0;
+  public static final int STOPPED = 1;
+  public static final int PAUSED = 2;
+
+  protected int state;
+  protected double startTime;
+  protected double time;
+  protected double culmTime;
+  protected SimpleOrderedMap<RTimer> children;
+
+  public RTimer() {
+    time = 0;
+    culmTime = 0;
+    children = new SimpleOrderedMap<RTimer>();
+    startTime = now();
+    state = STARTED;
+  }
+
+  /** Get current time
+   *
+   * May override to implement a different timer (CPU time, etc).
+   */
+  protected double now() { return System.currentTimeMillis(); }
+
+  /** Recursively stop timer and sub timers */
+  public double stop() {
+    assert state == STARTED || state == PAUSED;
+    time = culmTime;
+    if(state == STARTED) 
+      time += now() - startTime;
+    state = STOPPED;
+    
+    for( Map.Entry<String,RTimer> entry : children ) {
+      RTimer child = entry.getValue();
+      if(child.state == STARTED || child.state == PAUSED) 
+        child.stop();
+    }
+    return time;
+  }
+
+  public void pause() {
+    assert state == STARTED;
+    culmTime += now() - startTime;
+    state = PAUSED;
+  }
+  
+  public void resume() {
+    if(state == STARTED)
+      return;
+    assert state == PAUSED;
+    state = STARTED;
+    startTime = now();
+  }
+
+  /** Get total elapsed time for this timer.
+   *
+   * Timer must be STOPped.
+   */
+  public double getTime() {
+    assert state == STOPPED;
+    return time;
+  }
+
+  /** Create new subtimer with given name
+   *
+   * Subtimer will be started.
+   */
+  public RTimer sub(String desc) {
+    RTimer child = children.get( desc );
+    if( child == null ) {
+      child = new RTimer();
+      children.add(desc, child);
+    }
+    return child;
+  }
+
+  @Override
+  public String toString() {
+    return asNamedList().toString();
+  }
+
+  public NamedList asNamedList() {
+    NamedList<Object> m = new SimpleOrderedMap<Object>();
+    m.add( "time", time );
+    if( children.size() > 0 ) {
+      for( Map.Entry<String, RTimer> entry : children ) {
+        m.add( entry.getKey(), entry.getValue().asNamedList() );
+      }
+    }
+    return m;
+  }
+
+  /*************** Testing *******/
+  public static void main(String []argv) throws InterruptedException {
+    RTimer rt = new RTimer(), subt, st;
+    Thread.sleep(100);
+
+    subt = rt.sub("sub1");
+    Thread.sleep(50);
+    st = subt.sub("sub1.1");
+    st.resume();
+    Thread.sleep(10);
+    st.pause();
+    Thread.sleep(50);
+    st.resume();
+    Thread.sleep(10);
+    st.pause();
+    subt.stop();
+    rt.stop();
+
+    System.out.println( rt.toString());
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/SimpleOrderedMap.java b/src/common/org/apache/solr/common/util/SimpleOrderedMap.java
new file mode 100755
index 0000000..0378753
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/SimpleOrderedMap.java
@@ -0,0 +1,62 @@
+package org.apache.solr.common.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.*;
+
+
+/** <code>SimpleOrderedMap</code> is a {@link NamedList} where access by key is more
+ * important than maintaining order when it comes to representing the
+ * held data in other forms, as ResponseWriters normally do.
+ * It's normally not a good idea to repeat keys or use null keys, but this
+ * is not enforced.  If key uniqueness enforcement is desired, use a regular {@link Map}.
+ * <p>
+ * For example, a JSON response writer may choose to write a SimpleOrderedMap
+ * as {"foo":10,"bar":20} and may choose to write a NamedList as
+ * ["foo",10,"bar",20].  An XML response writer may choose to render both
+ * the same way.
+ * </p>
+ * <p>
+ * This class does not provide efficient lookup by key, it's main purpose is
+ * to hold data to be serialized.  It aims to minimize overhead and to be
+ * efficient at adding new elements.
+ * </p>
+ */
+public class SimpleOrderedMap<T> extends NamedList<T> {
+  /** Creates an empty instance */
+  public SimpleOrderedMap() {
+    super();
+  }
+
+  /**
+   * Creates an instance backed by an explicitly specified list of
+   * pairwise names/values.
+   *
+   * @param nameValuePairs underlying List which should be used to implement a SimpleOrderedMap; modifying this List will affect the SimpleOrderedMap.
+   */
+  public SimpleOrderedMap(List nameValuePairs) {
+    super(nameValuePairs);
+  }
+
+  @Override
+  public SimpleOrderedMap<T> clone() {
+    ArrayList newList = new ArrayList(nvPairs.size());
+    newList.addAll(nvPairs);
+    return new SimpleOrderedMap<T>(newList);
+  }
+}
diff --git a/src/common/org/apache/solr/common/util/StrUtils.java b/src/common/org/apache/solr/common/util/StrUtils.java
new file mode 100644
index 0000000..50da78a
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/StrUtils.java
@@ -0,0 +1,249 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.io.IOException;
+
+/**
+ * @version $Id$
+ */
+public class StrUtils {
+
+  /**
+   * Split a string based on a separator, but don't split if it's inside
+   * a string.  Assume '\' escapes the next char both inside and
+   * outside strings.
+   */
+  public static List<String> splitSmart(String s, char separator) {
+    ArrayList<String> lst = new ArrayList<String>(4);
+    int pos=0, start=0, end=s.length();
+    char inString=0;
+    char ch=0;
+    while (pos < end) {
+      char prevChar=ch;
+      ch = s.charAt(pos++);
+      if (ch=='\\') {    // skip escaped chars
+        pos++;
+      } else if (inString != 0 && ch==inString) {
+        inString=0;
+      } else if (ch=='\'' || ch=='"') {
+        // If char is directly preceeded by a number or letter
+        // then don't treat it as the start of a string.
+        // Examples: 50" TV, or can't
+        if (!Character.isLetterOrDigit(prevChar)) {
+          inString=ch;
+        }
+      } else if (ch==separator && inString==0) {
+        lst.add(s.substring(start,pos-1));
+        start=pos;
+      }
+    }
+    if (start < end) {
+      lst.add(s.substring(start,end));
+    }
+
+    /***
+    if (SolrCore.log.isLoggable(Level.FINEST)) {
+      SolrCore.log.trace("splitCommand=" + lst);
+    }
+    ***/
+
+    return lst;
+  }
+
+  /** Splits a backslash escaped string on the separator.
+   * <p>
+   * Current backslash escaping supported:
+   * <br> \n \t \r \b \f are escaped the same as a Java String
+   * <br> Other characters following a backslash are produced verbatim (\c => c)
+   *
+   * @param s  the string to split
+   * @param separator the separator to split on
+   * @param decode decode backslash escaping
+   */
+  public static List<String> splitSmart(String s, String separator, boolean decode) {
+    ArrayList<String> lst = new ArrayList<String>(2);
+    StringBuilder sb = new StringBuilder();
+    int pos=0, end=s.length();
+    while (pos < end) {
+      if (s.startsWith(separator,pos)) {
+        if (sb.length() > 0) {
+          lst.add(sb.toString());
+          sb=new StringBuilder();
+        }
+        pos+=separator.length();
+        continue;
+      }
+
+      char ch = s.charAt(pos++);
+      if (ch=='\\') {
+        if (!decode) sb.append(ch);
+        if (pos>=end) break;  // ERROR, or let it go?
+        ch = s.charAt(pos++);
+        if (decode) {
+          switch(ch) {
+            case 'n' : ch='\n'; break;
+            case 't' : ch='\t'; break;
+            case 'r' : ch='\r'; break;
+            case 'b' : ch='\b'; break;
+            case 'f' : ch='\f'; break;
+          }
+        }
+      }
+
+      sb.append(ch);
+    }
+
+    if (sb.length() > 0) {
+      lst.add(sb.toString());
+    }
+
+    return lst;
+  }
+
+  /**
+   * Splits file names separated by comma character.
+   * File names can contain comma characters escaped by backslash '\'
+   *
+   * @param fileNames the string containing file names
+   * @return a list of file names with the escaping backslashed removed
+   */
+  public static List<String> splitFileNames(String fileNames) {
+    if (fileNames == null)
+      return Collections.<String>emptyList();
+
+    List<String> result = new ArrayList<String>();
+    for (String file : fileNames.split("(?<!\\\\),")) {
+      result.add(file.replaceAll("\\\\(?=,)", ""));
+    }
+
+    return result;
+  }
+
+  /** Creates a backslash escaped string, joining all the items. */
+  public static String join(List<String> items, char separator) {
+    StringBuilder sb = new StringBuilder(items.size() << 3);
+    boolean first=true;
+    for (String item : items) {
+      if (first) {
+        first = false;
+      } else {
+        sb.append(separator);
+      }
+      for (int i=0; i<item.length(); i++) {
+        char ch = item.charAt(i);
+        if (ch=='\\' || ch == separator) {
+          sb.append('\\');
+        }
+        sb.append(ch);
+      }
+    }
+    return sb.toString();
+  }
+
+
+
+  public static List<String> splitWS(String s, boolean decode) {
+    ArrayList<String> lst = new ArrayList<String>(2);
+    StringBuilder sb = new StringBuilder();
+    int pos=0, end=s.length();
+    while (pos < end) {
+      char ch = s.charAt(pos++);
+      if (Character.isWhitespace(ch)) {
+        if (sb.length() > 0) {
+          lst.add(sb.toString());
+          sb=new StringBuilder();
+        }
+        continue;
+      }
+
+      if (ch=='\\') {
+        if (!decode) sb.append(ch);
+        if (pos>=end) break;  // ERROR, or let it go?
+        ch = s.charAt(pos++);
+        if (decode) {
+          switch(ch) {
+            case 'n' : ch='\n'; break;
+            case 't' : ch='\t'; break;
+            case 'r' : ch='\r'; break;
+            case 'b' : ch='\b'; break;
+            case 'f' : ch='\f'; break;
+          }
+        }
+      }
+
+      sb.append(ch);
+    }
+
+    if (sb.length() > 0) {
+      lst.add(sb.toString());
+    }
+
+    return lst;
+  }
+
+  public static List<String> toLower(List<String> strings) {
+    ArrayList<String> ret = new ArrayList<String>(strings.size());
+    for (String str : strings) {
+      ret.add(str.toLowerCase());
+    }
+    return ret;
+  }
+
+
+
+  /** Return if a string starts with '1', 't', or 'T'
+   *  and return false otherwise.
+   */
+  public static boolean parseBoolean(String s) {
+    char ch = s.length()>0 ? s.charAt(0) : 0;
+    return (ch=='1' || ch=='t' || ch=='T');
+  }
+
+  /**
+   * URLEncodes a value, replacing only enough chars so that
+   * the URL may be unambiguously pasted back into a browser.
+   * <p>
+   * Characters with a numeric value less than 32 are encoded.
+   * &amp;,=,%,+,space are encoded.
+   * <p>
+   */
+  public static void partialURLEncodeVal(Appendable dest, String val) throws IOException {
+    for (int i=0; i<val.length(); i++) {
+      char ch = val.charAt(i);
+      if (ch < 32) {
+        dest.append('%');
+        if (ch < 0x10) dest.append('0');
+        dest.append(Integer.toHexString(ch));
+      } else {
+        switch (ch) {
+          case ' ': dest.append('+'); break;
+          case '&': dest.append("%26"); break;
+          case '%': dest.append("%25"); break;
+          case '=': dest.append("%3D"); break;
+          case '+': dest.append("%2B"); break;
+          default : dest.append(ch); break;
+        }
+      }
+    }
+  }
+
+}
diff --git a/src/common/org/apache/solr/common/util/XML.java b/src/common/org/apache/solr/common/util/XML.java
new file mode 100644
index 0000000..36fef94
--- /dev/null
+++ b/src/common/org/apache/solr/common/util/XML.java
@@ -0,0 +1,183 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.common.util;
+
+import java.io.Writer;
+import java.io.IOException;
+
+/**
+ * @version $Id$
+ */
+public class XML {
+
+  //
+  // copied from some of my personal code...  -YCS
+  // table created from python script.
+  // only have to escape quotes in attribute values, and don't really have to escape '>'
+  // many chars less than 0x20 are *not* valid XML, even when escaped!
+  // for example, <foo>&#0;<foo> is invalid XML.
+  private static final String[] chardata_escapes=
+  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,null,null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;",null,"&gt;"};
+
+  private static final String[] attribute_escapes=
+  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,"&quot;",null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;"};
+
+
+
+  /*****************************************
+   #Simple python script used to generate the escape table above.  -YCS
+   #
+   #use individual char arrays or one big char array for better efficiency
+   # or byte array?
+   #other={'&':'amp', '<':'lt', '>':'gt', "'":'apos', '"':'quot'}
+   #
+   other={'&':'amp', '<':'lt'}
+
+   maxi=ord(max(other.keys()))+1
+   table=[None] * maxi
+   #NOTE: invalid XML chars are "escaped" as #nn; *not* &#nn; because
+   #a real XML escape would cause many strict XML parsers to choke.
+   for i in range(0x20): table[i]='#%d;' % i
+   for i in '\n\r\t ': table[ord(i)]=None
+   for k,v in other.items():
+    table[ord(k)]='&%s;' % v
+
+   result=""
+   for i in range(maxi):
+     val=table[i]
+     if not val: val='null'
+     else: val='"%s"' % val
+     result += val + ','
+
+   print result
+   ****************************************/
+
+
+/*********
+ *
+ * @param str
+ * @param out
+ * @throws IOException
+ */
+  public static void escapeCharData(String str, Writer out) throws IOException {
+    escape(str, out, chardata_escapes);
+  }
+
+  public static void escapeAttributeValue(String str, Writer out) throws IOException {
+    escape(str, out, attribute_escapes);
+  }
+
+  public static void escapeAttributeValue(char [] chars, int start, int length, Writer out) throws IOException {
+    escape(chars, start, length, out, attribute_escapes);
+  }
+
+
+  public final static void writeXML(Writer out, String tag, String val) throws IOException {
+    out.write('<');
+    out.write(tag);
+    if (val == null) {
+      out.write('/');
+      out.write('>');
+    } else {
+      out.write('>');
+      escapeCharData(val,out);
+      out.write('<');
+      out.write('/');
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+  /** does NOT escape character data in val, must already be valid XML */
+  public final static void writeUnescapedXML(Writer out, String tag, String val, Object... attrs) throws IOException {
+    out.write('<');
+    out.write(tag);
+    for (int i=0; i<attrs.length; i++) {
+      out.write(' ');
+      out.write(attrs[i++].toString());
+      out.write('=');
+      out.write('"');
+      out.write(attrs[i].toString());
+      out.write('"');
+    }
+    if (val == null) {
+      out.write('/');
+      out.write('>');
+    } else {
+      out.write('>');
+      out.write(val);
+      out.write('<');
+      out.write('/');
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+  /** escapes character data in val */
+  public final static void writeXML(Writer out, String tag, String val, Object... attrs) throws IOException {
+    out.write('<');
+    out.write(tag);
+    for (int i=0; i<attrs.length; i++) {
+      out.write(' ');
+      out.write(attrs[i++].toString());
+      out.write('=');
+      out.write('"');
+      escapeAttributeValue(attrs[i].toString(), out);
+      out.write('"');
+    }
+    if (val == null) {
+      out.write('/');
+      out.write('>');
+    } else {
+      out.write('>');
+      escapeCharData(val,out);
+      out.write('<');
+      out.write('/');
+      out.write(tag);
+      out.write('>');
+    }
+  }
+
+  private static void escape(char [] chars, int offset, int length, Writer out, String [] escapes) throws IOException{
+     for (int i=offset; i<length; i++) {
+      char ch = chars[i];
+      if (ch<escapes.length) {
+        String replacement = escapes[ch];
+        if (replacement != null) {
+          out.write(replacement);
+          continue;
+        }
+      }
+      out.write(ch);
+    }
+  }
+
+  private static void escape(String str, Writer out, String[] escapes) throws IOException {
+    for (int i=0; i<str.length(); i++) {
+      char ch = str.charAt(i);
+      if (ch<escapes.length) {
+        String replacement = escapes[ch];
+        if (replacement != null) {
+          out.write(replacement);
+          continue;
+        }
+      }
+      out.write(ch);
+    }
+  }
+}
diff --git a/src/java/org/apache/solr/common/ResourceLoader.java b/src/java/org/apache/solr/common/ResourceLoader.java
deleted file mode 100644
index 381d261..0000000
--- a/src/java/org/apache/solr/common/ResourceLoader.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.List;
-
-/**
- * @since solr 1.3
- */ 
-public interface ResourceLoader
-{
-  public InputStream openResource(String resource) throws IOException;
-  
-  /**
-   * Accesses a resource by name and returns the (non comment) lines
-   * containing data.
-   *
-   * <p>
-   * A comment line is any line that starts with the character "#"
-   * </p>
-   *
-   * @param resource
-   * @return a list of non-blank non-comment lines with whitespace trimmed
-   * from front and back.
-   * @throws IOException
-   */
-  public List<String> getLines(String resource) throws IOException;
-  
-  public Object newInstance(String cname, String ... subpackages);
-}
\ No newline at end of file
diff --git a/src/java/org/apache/solr/common/SolrDocument.java b/src/java/org/apache/solr/common/SolrDocument.java
deleted file mode 100644
index 2900a7f..0000000
--- a/src/java/org/apache/solr/common/SolrDocument.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-import java.util.Map.Entry;
-
-
-/**
- * A concrete representation of a document within a Solr index.  Unlike a lucene
- * Document, a SolrDocument may have an Object value matching the type defined in
- * schema.xml
- * 
- * For indexing documents, use the SolrInputDocument that contains extra information
- * for document and field boosting.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrDocument implements Serializable, Iterable<Map.Entry<String, Object>>
-{
-  private Map<String,Object> _fields = null;
-  
-  public SolrDocument()
-  {
-    _fields = new HashMap<String,Object>();
-  }
-
-  /**
-   * @return a list of fields defined in this document
-   */
-  public Collection<String> getFieldNames() {
-    return _fields.keySet();
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Add / Set / Remove Fields
-  ///////////////////////////////////////////////////////////////////
-
-  /**
-   * Remove all fields from the document
-   */
-  public void clear()
-  {
-    _fields.clear();
-  }
-  
-  /**
-   * Remove all fields with the name
-   */
-  public boolean removeFields(String name) 
-  {
-    return _fields.remove( name ) != null;
-  }
-
-  /**
-   * Set a field with the given object.  If the object is an Array, it will 
-   * set multiple fields with the included contents.  This will replace any existing 
-   * field with the given name
-   */
-  @SuppressWarnings("unchecked")
-  public void setField(String name, Object value) 
-  {
-    if( value instanceof Object[] ) {
-      value = new ArrayList(Arrays.asList( (Object[])value ));
-    }
-    else if( value instanceof Collection ) {
-      // nothing
-    }
-    else if( value instanceof Iterable ) {
-      ArrayList<Object> lst = new ArrayList<Object>();
-      for( Object o : (Iterable)value ) {
-        lst.add( o );
-      }
-      value = lst;
-    }
-    _fields.put(name, value);
-  }
-  
-  /**
-   * This will add a field to the document.  If fields already exist with this name
-   * it will append the collection
-   */
-  @SuppressWarnings("unchecked")
-  public void addField(String name, Object value) 
-  { 
-    Object existing = _fields.get(name);
-    if (existing == null) {
-      this.setField( name, value );
-      return;
-    }
-    
-    Collection<Object> vals = null;
-    if( existing instanceof Collection ) {
-      vals = (Collection<Object>)existing;
-    }
-    else {
-      vals = new ArrayList<Object>( 3 );
-      vals.add( existing );
-    }
-    
-    // Add the values to the collection
-    if( value instanceof Iterable ) {
-      for( Object o : (Iterable<Object>)value ) {
-        vals.add( o );
-      }
-    }
-    else if( value instanceof Object[] ) {
-      for( Object o : (Object[])value ) {
-        vals.add( o );
-      }
-    }
-    else {
-      vals.add( value );
-    }
-    _fields.put( name, vals );
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Get the field values
-  ///////////////////////////////////////////////////////////////////
-
-  /**
-   * returns the first value for a field
-   */
-  public Object getFirstValue(String name) {
-    Object v = _fields.get( name );
-    if (v == null || !(v instanceof Collection)) return v;
-    Collection c = (Collection)v;
-    if (c.size() > 0 ) {
-      return c.iterator().next();
-    }
-    return null;
-  }
-  
-  /**
-   * Get the value or collection of values for a given field.  
-   */
-  public Object getFieldValue(String name) {
-    return _fields.get( name );
-  }
-
-  /**
-   * Get a collection of values for a given field name
-   */
-  @SuppressWarnings("unchecked")
-  public Collection<Object> getFieldValues(String name) {
-    Object v = _fields.get( name );
-    if( v instanceof Collection ) {
-      return (Collection<Object>)v;
-    }
-    if( v != null ) {
-      ArrayList<Object> arr = new ArrayList<Object>(1);
-      arr.add( v );
-      return arr;
-    }
-    return null;
-  }
-    
-  @Override
-  public String toString()
-  {
-    return "SolrDocument["+_fields.toString()+"]";
-  }
-
-  /**
-   * Iterate of String->Object keys
-   */
-  public Iterator<Entry<String, Object>> iterator() {
-    return _fields.entrySet().iterator();
-  }
-  
-  //-----------------------------------------------------------------------------------------
-  // JSTL Helpers
-  //-----------------------------------------------------------------------------------------
-  
-  /**
-   * Expose a Map interface to the solr field value collection.
-   */
-  public Map<String,Collection<Object>> getFieldValuesMap()
-  {
-    return new Map<String,Collection<Object>>() {
-      /** Get the field Value */
-      public Collection<Object> get(Object key) { 
-        return getFieldValues( (String)key ); 
-      }
-      
-      // Easily Supported methods
-      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
-      public Set<String>  keySet()           { return _fields.keySet();  }
-      public int          size()             { return _fields.size();    }
-      public boolean      isEmpty()          { return _fields.isEmpty(); }
-
-      // Unsupported operations.  These are not necessary for JSTL
-      public void clear() { throw new UnsupportedOperationException(); }
-      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
-      public Set<java.util.Map.Entry<String, Collection<Object>>> entrySet() {throw new UnsupportedOperationException();}
-      public void putAll(Map<? extends String, ? extends Collection<Object>> t) {throw new UnsupportedOperationException();}
-      public Collection<Collection<Object>> values() {throw new UnsupportedOperationException();}
-      public Collection<Object> put(String key, Collection<Object> value) {throw new UnsupportedOperationException();}
-      public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();}      
-    };
-  }
-
-  /**
-   * Expose a Map interface to the solr fields.  This function is useful for JSTL
-   */
-  public Map<String,Object> getFieldValueMap() {
-    return new Map<String,Object>() {
-      /** Get the field Value */
-      public Object get(Object key) { 
-        return getFirstValue( (String)key ); 
-      }
-      
-      // Easily Supported methods
-      public boolean containsKey(Object key) { return _fields.containsKey( key ); }
-      public Set<String>  keySet()           { return _fields.keySet();  }
-      public int          size()             { return _fields.size();    }
-      public boolean      isEmpty()          { return _fields.isEmpty(); }
-
-      // Unsupported operations.  These are not necessary for JSTL
-      public void clear() { throw new UnsupportedOperationException(); }
-      public boolean containsValue(Object value) {throw new UnsupportedOperationException();}
-      public Set<java.util.Map.Entry<String, Object>> entrySet() {throw new UnsupportedOperationException();}
-      public void putAll(Map<? extends String, ? extends Object> t) {throw new UnsupportedOperationException();}
-      public Collection<Object> values() {throw new UnsupportedOperationException();}
-      public Collection<Object> put(String key, Object value) {throw new UnsupportedOperationException();}
-      public Collection<Object> remove(Object key) {throw new UnsupportedOperationException();}      
-   };
-  }
-}
diff --git a/src/java/org/apache/solr/common/SolrDocumentList.java b/src/java/org/apache/solr/common/SolrDocumentList.java
deleted file mode 100644
index 273cd80..0000000
--- a/src/java/org/apache/solr/common/SolrDocumentList.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import java.util.ArrayList;
-
-
-/**
- * Represent a list of SolrDocuments returned from a search.  This includes
- * position and offset information.
- * 
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrDocumentList extends ArrayList<SolrDocument>
-{ 
-  private long numFound = 0;
-  private long start = 0;
-  private Float maxScore = null;
-  
-  public Float getMaxScore() {
-    return maxScore;
-  }
-  
-  public void setMaxScore(Float maxScore) {
-    this.maxScore = maxScore;
-  }
-  
-  public long getNumFound() {
-    return numFound;
-  }
-  
-  public void setNumFound(long numFound) {
-    this.numFound = numFound;
-  }
-  
-  public long getStart() {
-    return start;
-  }
-  
-  public void setStart(long start) {
-    this.start = start;
-  }
-
-  public String toString() {
-    return "{numFound="+numFound
-            +",start="+start
-            + (maxScore!=null ? ""+maxScore : "")
-            +",docs="+super.toString()
-            +"}";
-  }
-}
diff --git a/src/java/org/apache/solr/common/SolrException.java b/src/java/org/apache/solr/common/SolrException.java
deleted file mode 100644
index bdc516c..0000000
--- a/src/java/org/apache/solr/common/SolrException.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import java.io.CharArrayWriter;
-import java.io.PrintWriter;
-
-/**
- * @version $Id$
- */
-public class SolrException extends RuntimeException {
-  
-  /**
-   * @since solr 1.2
-   */
-  public enum ErrorCode {
-    BAD_REQUEST( 400 ),
-    UNAUTHORIZED( 401 ),
-    FORBIDDEN( 403 ),
-    NOT_FOUND( 404 ),
-    SERVER_ERROR( 500 ),
-    SERVICE_UNAVAILABLE( 503 ); 
-    
-    final int code;
-    
-    private ErrorCode( int c )
-    {
-      code = c;
-    }
-  };
-  
-  public boolean logged=false;
-
-  public SolrException(ErrorCode code, String msg) {
-    super(msg);
-    this.code=code.code;
-  }
-  
-  public SolrException(ErrorCode code, String msg, boolean alreadyLogged) {
-    super(msg);
-    this.code=code.code;
-    this.logged=alreadyLogged;
-  }
-
-  public SolrException(ErrorCode code, String msg, Throwable th, boolean alreadyLogged) {
-    super(msg,th);
-    this.code=code.code;
-    logged=alreadyLogged;
-  }
-
-  public SolrException(ErrorCode code, String msg, Throwable th) {
-    this(code,msg,th,true);
-  }
-
-  public SolrException(ErrorCode code, Throwable th) {
-    super(th);
-    this.code=code.code;
-    logged=true;
-  }
-  
-  /**
-   * @deprecated Use {@link #SolrException(ErrorCode,String)}.
-   */
-  @Deprecated
-  public SolrException(int code, String msg) {
-    super(msg);
-    this.code=code;
-  }
-  
-  /**
-   * @deprecated Use {@link #SolrException(ErrorCode,String,boolean)}.
-   */
-  @Deprecated
-  public SolrException(int code, String msg, boolean alreadyLogged) {
-    super(msg);
-    this.code=code;
-    this.logged=alreadyLogged;
-  }
-
-  /**
-   * @deprecated Use {@link #SolrException(ErrorCode,String,Throwable,boolean)}.
-   */
-  @Deprecated
-  public SolrException(int code, String msg, Throwable th, boolean alreadyLogged) {
-    super(msg,th);
-    this.code=code;
-    logged=alreadyLogged;
-  }
-
-  /**
-   * @deprecated Use {@link #SolrException(ErrorCode,String,Throwable)}.
-   */
-  @Deprecated
-  public SolrException(int code, String msg, Throwable th) {
-    this(code,msg,th,true);
-  }
-
-  /**
-   * @deprecated Use {@link #SolrException(ErrorCode,Throwable)}.
-   */
-  @Deprecated
-  public SolrException(int code, Throwable th) {
-    super(th);
-    this.code=code;
-    logged=true;
-  }
-
-  int code=0;
-  public int code() { return code; }
-
-
-
-
-  public void log(Logger log) { log(log,this); }
-  public static void log(Logger log, Throwable e) {
-    log.error(toStr(e));
-    if (e instanceof SolrException) {
-      ((SolrException)e).logged = true;
-    }
-  }
-
-  public static void log(Logger log, String msg, Throwable e) {
-    log.error(msg + ':' + toStr(e));
-    if (e instanceof SolrException) {
-      ((SolrException)e).logged = true;
-    }
-  }
-
-  public static void logOnce(Logger log, String msg, Throwable e) {
-    if (e instanceof SolrException) {
-      if(((SolrException)e).logged) return;
-    }
-    if (msg!=null) log(log,msg,e);
-    else log(log,e);
-  }
-
-
-  // public String toString() { return toStr(this); }  // oops, inf loop
-  @Override
-  public String toString() { return super.toString(); }
-
-  public static String toStr(Throwable e) {
-    CharArrayWriter cw = new CharArrayWriter();
-    PrintWriter pw = new PrintWriter(cw);
-    e.printStackTrace(pw);
-    pw.flush();
-    return cw.toString();
-
-/** This doesn't work for some reason!!!!!
-    StringWriter sw = new StringWriter();
-    PrintWriter pw = new PrintWriter(sw);
-    e.printStackTrace(pw);
-    pw.flush();
-    System.out.println("The STRING:" + sw.toString());
-    return sw.toString();
-**/
-  }
-
-}
diff --git a/src/java/org/apache/solr/common/SolrInputDocument.java b/src/java/org/apache/solr/common/SolrInputDocument.java
deleted file mode 100644
index b0abf53..0000000
--- a/src/java/org/apache/solr/common/SolrInputDocument.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Collection;
-
-/**
- * Represent the field and boost information needed to construct and index
- * a Lucene Document.  Like the SolrDocument, the field values should
- * match those specified in schema.xml 
- *
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrInputDocument implements Iterable<SolrInputField>, Serializable
-{
-  private final Map<String,SolrInputField> _fields;
-  private float _documentBoost = 1.0f;
-
-  public SolrInputDocument()
-  {
-    _fields = new LinkedHashMap<String,SolrInputField>();
-  }
-  
-  /**
-   * Remove all fields and boosts from the document
-   */
-  public void clear()
-  {
-    if( _fields != null ) {
-      _fields.clear();
-    }
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Add / Set fields
-  ///////////////////////////////////////////////////////////////////
-
-  /** 
-   * Add a field with implied null value for boost.
-   * 
-   * @see #addField(String, Object, float)
-   * @param name name of the field to add
-   * @param value value of the field
-   */
-  public void addField(String name, Object value) 
-  {
-    addField(name, value, 1.0f );
-  }
-  
-  /** Get the first value for a field.
-   * 
-   * @param name name of the field to fetch
-   * @return first value of the field or null if not present
-   */
-  public Object getFieldValue(String name) 
-  {
-    SolrInputField field = getField(name);
-    Object o = null;
-    if (field!=null) o = field.getFirstValue();
-    return o;
-  }
-  
-  /** Get all the values for a field.
-   * 
-   * @param name name of the field to fetch
-   * @return value of the field or null if not set
-   */
-  public Collection<Object> getFieldValues(String name) 
-  {
-    SolrInputField field = getField(name);
-    if (field!=null) {
-      return field.getValues();
-    }
-    return null;
-  } 
-  
-  /** Get all field names.
-   * 
-   * @return Set of all field names.
-   */
-  public Collection<String> getFieldNames() 
-  {
-    return _fields.keySet();
-  }
-  
-  /** Set a field with implied null value for boost.
-   * 
-   * @see #setField(String, Object, float)
-   * @param name name of the field to set
-   * @param value value of the field
-   */
-  public void setField(String name, Object value) 
-  {
-    setField(name, value, 1.0f );
-  }
-  
-  public void setField(String name, Object value, float boost ) 
-  {
-    SolrInputField field = new SolrInputField( name );
-    _fields.put( name, field );
-    field.setValue( value, boost );
-  }
-
-  /**
-   * Remove all fields and boosts from the document
-   */
-  public void addField(String name, Object value, float boost ) 
-  {
-    SolrInputField field = _fields.get( name );
-    if( field == null || field.value == null ) {
-      setField(name, value, boost);
-    }
-    else {
-      field.addValue( value, boost );
-    }
-  }
-
-  /**
-   * Remove a field from the document
-   * 
-   * @param name The field name whose field is to be removed from the document
-   * @return the previous field with <tt>name</tt>, or
-   *         <tt>null</tt> if there was no field for <tt>key</tt>.
-   */
-  public SolrInputField removeField(String name) {
-    return _fields.remove( name );
-  }
-
-  ///////////////////////////////////////////////////////////////////
-  // Get the field values
-  ///////////////////////////////////////////////////////////////////
-
-  public SolrInputField getField( String field )
-  {
-    return _fields.get( field );
-  }
-
-  public Iterator<SolrInputField> iterator() {
-    return _fields.values().iterator();
-  }
-  
-  public float getDocumentBoost() {
-    return _documentBoost;
-  }
-
-  public void setDocumentBoost(float documentBoost) {
-    _documentBoost = documentBoost;
-  }
-  
-  @Override
-  public String toString()
-  {
-    return "SolrInputDocument["+_fields+"]";
-  }
-}
diff --git a/src/java/org/apache/solr/common/SolrInputField.java b/src/java/org/apache/solr/common/SolrInputField.java
deleted file mode 100644
index 5e9102c..0000000
--- a/src/java/org/apache/solr/common/SolrInputField.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public class SolrInputField implements Iterable<Object>, Serializable
-{
-  String name;
-  Object value = null; 
-  float boost = 1.0f;
-  
-  public SolrInputField( String n )
-  {
-    this.name = n;
-  }
-
-  //---------------------------------------------------------------
-  //---------------------------------------------------------------
-
-  /**
-   * Set the value for a field.  Arrays will be converted to a collection.
-   */
-  public void setValue(Object v, float b) {
-    boost = b;
-
-    if( v instanceof Object[] ) {
-      Object[] arr = (Object[])v;
-      Collection<Object> c = new ArrayList<Object>( arr.length );
-      for( Object o : arr ) {
-        c.add( o );
-      }
-      value = c;
-    }
-    else {
-      value = v;
-    }
-  }
-
-  /**
-   * Add values to a field.  if the added value is a collection, each value
-   * will be added individually
-   */
-  @SuppressWarnings("unchecked")
-  public void addValue(Object v, float b) {
-    if( value == null ) {
-      setValue(v, b);
-      return;
-    }
-    
-    // The lucene API and solr XML field specification make it possible to set boosts
-    // on multi-value fields even though lucene indexing does not support this.
-    // To keep behavior consistent with what happens in the lucene index, we accumulate
-    // the product of all boosts specified for this field.
-    boost *= b;
-    
-    Collection<Object> vals = null;
-    if( value instanceof Collection ) {
-      vals = (Collection<Object>)value;
-    }
-    else {
-      vals = new ArrayList<Object>( 3 );
-      vals.add( value );
-      value = vals;
-    }
-    
-    // Add the new values to a collection
-    if( v instanceof Iterable ) {
-      for( Object o : (Iterable<Object>)v ) {
-        vals.add( o );
-      }
-    }
-    else if( v instanceof Object[] ) {
-      for( Object o : (Object[])v ) {
-        vals.add( o );
-      }
-    }
-    else {
-      vals.add( v );
-    }
-  }
-
-  //---------------------------------------------------------------
-  //---------------------------------------------------------------
-  
-  @SuppressWarnings("unchecked")
-  public Object getFirstValue() {
-    if( value instanceof Collection ) {
-      Collection c = (Collection<Object>)value;
-      if( c.size() > 0 ) {
-        return c.iterator().next();
-      }
-      return null;
-    }
-    return value;
-  }
-
-  /**
-   * @return the value for this field.  If the field has multiple values, this
-   * will be a collection.
-   */
-  public Object getValue() {
-    return value;
-  }
-
-  /**
-   * @return the values for this field.  This will return a collection even
-   * if the field is not multi-valued
-   */
-  @SuppressWarnings("unchecked")
-  public Collection<Object> getValues() {
-    if( value instanceof Collection ) {
-      return (Collection<Object>)value;
-    }
-    if( value != null ) {
-      Collection<Object> vals = new ArrayList<Object>(1);
-      vals.add( value );
-      return vals;
-    }
-    return null;
-  }
-
-  /**
-   * @return the number of values for this field
-   */
-  public int getValueCount() {
-    if( value instanceof Collection ) {
-      return ((Collection)value).size();
-    }
-    return (value == null) ? 0 : 1;
-  }
-  
-  //---------------------------------------------------------------
-  //---------------------------------------------------------------
-  
-  public float getBoost() {
-    return boost;
-  }
-
-  public void setBoost(float boost) {
-    this.boost = boost;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public void setName(String name) {
-    this.name = name;
-  }
-
-  @SuppressWarnings("unchecked")
-  public Iterator<Object> iterator() {
-    if( value instanceof Collection ) {
-      return ((Collection)value).iterator();
-    }
-    return new Iterator<Object>() {
-      boolean nxt = (value!=null);
-      
-      public boolean hasNext() {
-        return nxt;
-      }
-
-      public Object next() {
-        nxt = false;
-        return value;
-      }
-
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-  }
-
-  @Override
-  public String toString()
-  {
-    return name + "("+boost+")={" + value + "}";
-  }
-}
diff --git a/src/java/org/apache/solr/common/luke/FieldFlag.java b/src/java/org/apache/solr/common/luke/FieldFlag.java
deleted file mode 100644
index 63d8356..0000000
--- a/src/java/org/apache/solr/common/luke/FieldFlag.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.apache.solr.common.luke;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @version $Id: AdminHandlers.java 608150 2008-01-02 17:15:30Z ryan $
- * @since solr 1.3
- */
-public enum FieldFlag {
-  INDEXED('I', "Indexed"), 
-  TOKENIZED('T', "Tokenized"), 
-  STORED('S', "Stored"), 
-  MULTI_VALUED('M', "Multivalued"),
-  TERM_VECTOR_STORED('V', "TermVector Stored"), 
-  TERM_VECTOR_OFFSET('o', "Store Offset With TermVector"),
-  TERM_VECTOR_POSITION('p', "Store Position With TermVector"),
-  OMIT_NORMS('O', "Omit Norms"), 
-  LAZY('L', "Lazy"), 
-  BINARY('B', "Binary"), 
-  COMPRESSED('C', "Compressed"),
-  SORT_MISSING_FIRST('f', "Sort Missing First"), 
-  SORT_MISSING_LAST('l', "Sort Missing Last");
-
-  private final char abbreviation;
-  private final String display;
-
-  FieldFlag(char abbreviation, String display) {
-    this.abbreviation = abbreviation;
-    this.display = display;
-    this.display.intern();//QUESTION:  Need we bother here?
-  }
-
-  public static FieldFlag getFlag(char abbrev){
-    FieldFlag result = null;
-    FieldFlag [] vals = FieldFlag.values();
-    for (int i = 0; i < vals.length; i++) {
-      if (vals[i].getAbbreviation() == abbrev){
-        result = vals[i];
-        break;
-      }
-    }
-    return result;
-  }
-
-  public char getAbbreviation() {
-    return abbreviation;
-  }
-
-  public String getDisplay() {
-    return display;
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/AppendedSolrParams.java b/src/java/org/apache/solr/common/params/AppendedSolrParams.java
deleted file mode 100644
index f0d5ed5..0000000
--- a/src/java/org/apache/solr/common/params/AppendedSolrParams.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * SolrParams wrapper which acts similar to DefaultSolrParams except that
- * it "appends" the values of multi-value params from both sub instances, so
- * that all of the values are returned. 
- */
-public class AppendedSolrParams extends DefaultSolrParams {
-  public AppendedSolrParams(SolrParams main, SolrParams extra) {
-    super(main, extra);
-  }
-
-  @Override
-  public String[] getParams(String param) {
-    String[] main = params.getParams(param);
-    String[] extra = defaults.getParams(param);
-    if (null == extra || 0 == extra.length) {
-      return main;
-    }
-    if (null == main || 0 == main.length) {
-      return extra;
-    }
-    String[] result = new String[main.length + extra.length];
-    System.arraycopy(main,0,result,0,main.length);
-    System.arraycopy(extra,0,result,main.length,extra.length);
-    return result;
-  }
-
-  @Override
-  public String toString() {
-    return "{main("+params+"),extra("+defaults+")}";
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/CommonParams.java b/src/java/org/apache/solr/common/params/CommonParams.java
deleted file mode 100755
index 4f33c4d..0000000
--- a/src/java/org/apache/solr/common/params/CommonParams.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-
-/**
- * Parameters used across many handlers
- */
-public interface CommonParams {
-
-  /** the query type - which query handler should handle the request */
-  public static final String QT ="qt";
-  
-  /** the response writer type - the format of the response */
-  public static final String WT ="wt";
-  
-  /** query string */
-  public static final String Q ="q";
-  
-  /** sort order */
-  public static final String SORT ="sort";
-  
-  /** Lucene query string(s) for filtering the results without affecting scoring */
-  public static final String FQ ="fq";
-  
-  /** zero based offset of matching documents to retrieve */
-  public static final String START ="start";
-  
-  /** number of documents to return starting at "start" */
-  public static final String ROWS ="rows";
-  
-  /** stylesheet to apply to XML results */
-  public static final String XSL ="xsl";
-  
-  /** stylesheet to apply to XML results */
-  public static final String VERSION ="version";
-  
-  /** query and init param for field list */
-  public static final String FL = "fl";
-  
-  /** default query field */
-  public static final String DF = "df";
-  
-  /** whether to include debug data */
-  public static final String DEBUG_QUERY = "debugQuery";
-  
-  /** another query to explain against */
-  public static final String EXPLAIN_OTHER = "explainOther";
-  
-
-  /** If the content stream should come from a URL (using URLConnection) */
-  public static final String STREAM_URL = "stream.url";
-
-  /** If the content stream should come from a File (using FileReader) */
-  public static final String STREAM_FILE = "stream.file";
-  
-  /** If the content stream should come directly from a field */
-  public static final String STREAM_BODY = "stream.body";
-  
-  /** 
-   * Explicitly set the content type for the input stream
-   * If multiple streams are specified, the explicit contentType
-   * will be used for all of them.  
-   */
-  public static final String STREAM_CONTENTTYPE = "stream.contentType";
-  
-  /**
-   * Timeout value in milliseconds.  If not set, or the value is <= 0, there is no timeout.
-   */
-  public static final String TIME_ALLOWED = "timeAllowed";
-  
-  /** 'true' if the header should include the handler name */
-  public static final String HEADER_ECHO_HANDLER = "echoHandler";
-  
-  /** include the parameters in the header **/
-  public static final String HEADER_ECHO_PARAMS = "echoParams";
-
-  /** include header in the response */
-  public static final String OMIT_HEADER = "omitHeader";
-
-  /** valid values for: <code>echoParams</code> */
-  public enum EchoParamStyle {
-    EXPLICIT,
-    ALL,
-    NONE;
-    
-    public static EchoParamStyle get( String v ) {
-      if( v != null ) {
-        v = v.toUpperCase();
-        if( v.equals( "EXPLICIT" ) ) {
-          return EXPLICIT;
-        }
-        if( v.equals( "ALL") ) {
-          return ALL;
-        }
-        if( v.equals( "NONE") ) {  // the same as nothing...
-          return NONE;
-        }
-      }
-      return null;
-    }
-  };
-}
-
diff --git a/src/java/org/apache/solr/common/params/CoreAdminParams.java b/src/java/org/apache/solr/common/params/CoreAdminParams.java
deleted file mode 100644
index 1d85b2f..0000000
--- a/src/java/org/apache/solr/common/params/CoreAdminParams.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * @since solr 1.3
- */
-public interface CoreAdminParams 
-{
-  /** What Core are we talking about **/
-  public final static String CORE = "core";
-
-  /** Persistent -- should it save the cores state? **/
-  public final static String PERSISTENT = "persistent";
-  
-  /** If you rename something, what is the new name **/
-  public final static String NAME = "name";
-
-  /** Name of the other core in actions involving 2 cores **/
-  public final static String OTHER = "other";
-
-  /** What action **/
-  public final static String ACTION = "action";
-  
-  /** If you specify a schema, what is its name **/
-  public final static String SCHEMA = "schema";
-  
-  /** If you specify a config, what is its name **/
-  public final static String CONFIG = "config";
-  
-  /** Specifies a core instance dir. */
-  public final static String INSTANCE_DIR = "instanceDir";
-
-  /** If you specify a file, what is its name **/
-  public final static String FILE = "file";
-  
-  public enum CoreAdminAction {
-    STATUS,  
-    LOAD,
-    UNLOAD,
-    RELOAD,
-    CREATE,
-    PERSIST,
-    SWAP,
-    RENAME,
-    ALIAS;
-    
-    public static CoreAdminAction get( String p )
-    {
-      if( p != null ) {
-        try {
-          return CoreAdminAction.valueOf( p.toUpperCase() );
-        }
-        catch( Exception ex ) {}
-      }
-      return null; 
-    }
-  }
-}
\ No newline at end of file
diff --git a/src/java/org/apache/solr/common/params/DefaultSolrParams.java b/src/java/org/apache/solr/common/params/DefaultSolrParams.java
deleted file mode 100644
index b71d9ca..0000000
--- a/src/java/org/apache/solr/common/params/DefaultSolrParams.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import java.util.Iterator;
-
-import org.apache.solr.common.util.IteratorChain;
-
-/**
- * @version $Id$
- */
-public class DefaultSolrParams extends SolrParams {
-  protected final SolrParams params;
-  protected final SolrParams defaults;
-
-  public DefaultSolrParams(SolrParams params, SolrParams defaults) {
-    this.params = params;
-    this.defaults = defaults;
-  }
-
-  @Override
-  public String get(String param) {
-    String val = params.get(param);
-    return val!=null ? val : defaults.get(param);
-  }
-
-  @Override
-  public String[] getParams(String param) {
-    String[] vals = params.getParams(param);
-    return vals!=null ? vals : defaults.getParams(param);
-  }
-
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    final IteratorChain<String> c = new IteratorChain<String>();
-    c.addIterator(defaults.getParameterNamesIterator());
-    c.addIterator(params.getParameterNamesIterator());
-    return c;
-  }
-
-  @Override
-  public String toString() {
-    return "{params("+params+"),defaults("+defaults+")}";
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/DisMaxParams.java b/src/java/org/apache/solr/common/params/DisMaxParams.java
deleted file mode 100755
index 6354225..0000000
--- a/src/java/org/apache/solr/common/params/DisMaxParams.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-    
-
-/**
- * A collection of params used in DisMaxRequestHandler,
- * both for Plugin initialization and for Requests.
- */
-public interface DisMaxParams {
-  
-  /** query and init param for tiebreaker value */
-  public static String TIE = "tie";
-  
-  /** query and init param for query fields */
-  public static String QF = "qf";
-  
-  /** query and init param for phrase boost fields */
-  public static String PF = "pf";
-  
-  /** query and init param for MinShouldMatch specification */
-  public static String MM = "mm";
-  
-  /**
-   * query and init param for Phrase Slop value in phrase
-   * boost query (in pf fields)
-   */
-  public static String PS = "ps";
-  
-  /**
-   * query and init param for phrase Slop value in phrases
-   * explicitly included in the user's query string ( in qf fields)
-   */
-  public static String QS = "qs";
-  
-  /** query and init param for boosting query */
-  public static String BQ = "bq";
-  
-  /** query and init param for boosting functions */
-  public static String BF = "bf";
-  
-  /**
-   * Alternate query (expressed in Solr QuerySyntax)
-   * to use if main query (q) is empty
-   */
-  public static String ALTQ = "q.alt";
-  
-  /** query and init param for field list */
-  public static String GEN = "gen";
-}
diff --git a/src/java/org/apache/solr/common/params/FacetParams.java b/src/java/org/apache/solr/common/params/FacetParams.java
deleted file mode 100644
index b4b60b4..0000000
--- a/src/java/org/apache/solr/common/params/FacetParams.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import org.apache.solr.common.SolrException;
-
-
-/**
- * Facet parameters
- */
-public interface FacetParams {
-
-  /**
-   * Should facet counts be calculated?
-   */
-  public static final String FACET = "facet";
-
-  /** What method should be used to do the faceting */
-  public static final String FACET_METHOD = FACET + ".method";
-
-  /** Value for FACET_METHOD param to indicate that Solr should enumerate over terms
-   * in a field to calculate the facet counts.
-   */
-  public static final String FACET_METHOD_enum = "enum";
-
-  /** Value for FACET_METHOD param to indicate that Solr should enumerate over documents
-   * and count up terms by consulting an uninverted representation of the field values
-   * (such as the FieldCache used for sorting).
-   */
-  public static final String FACET_METHOD_fc = "fc";
-  
-  /**
-   * Any lucene formated queries the user would like to use for
-   * Facet Constraint Counts (multi-value)
-   */
-  public static final String FACET_QUERY = FACET + ".query";
-  /**
-   * Any field whose terms the user wants to enumerate over for
-   * Facet Constraint Counts (multi-value)
-   */
-  public static final String FACET_FIELD = FACET + ".field";
-
-  /**
-   * The offset into the list of facets.
-   * Can be overridden on a per field basis.
-   */
-  public static final String FACET_OFFSET = FACET + ".offset";
-
-  /**
-   * Numeric option indicating the maximum number of facet field counts
-   * be included in the response for each field - in descending order of count.
-   * Can be overridden on a per field basis.
-   */
-  public static final String FACET_LIMIT = FACET + ".limit";
-
-  /**
-   * Numeric option indicating the minimum number of hits before a facet should
-   * be included in the response.  Can be overridden on a per field basis.
-   */
-  public static final String FACET_MINCOUNT = FACET + ".mincount";
-
-  /**
-   * Boolean option indicating whether facet field counts of "0" should 
-   * be included in the response.  Can be overridden on a per field basis.
-   */
-  public static final String FACET_ZEROS = FACET + ".zeros";
-
-  /**
-   * Boolean option indicating whether the response should include a 
-   * facet field count for all records which have no value for the 
-   * facet field. Can be overridden on a per field basis.
-   */
-  public static final String FACET_MISSING = FACET + ".missing";
-
-  /**
-   * String option: "count" causes facets to be sorted
-   * by the count, "lex" results in lexicographical order.
-   */
-  public static final String FACET_SORT = FACET + ".sort";
-
-  public static final String FACET_SORT_COUNT = "count";
-  public static final String FACET_SORT_COUNT_LEGACY = "true";
-  public static final String FACET_SORT_LEX = "lex";
-  public static final String FACET_SORT_LEX_LEGACY = "false";
-
-  /**
-   * Only return constraints of a facet field with the given prefix.
-   */
-  public static final String FACET_PREFIX = FACET + ".prefix";
-
- /**
-   * When faceting by enumerating the terms in a field,
-   * only use the filterCache for terms with a df >= to this parameter.
-   */
-  public static final String FACET_ENUM_CACHE_MINDF = FACET + ".enum.cache.minDf";
-  /**
-   * Any field whose terms the user wants to enumerate over for
-   * Facet Contraint Counts (multi-value)
-   */
-  public static final String FACET_DATE = FACET + ".date";
-  /**
-   * Date string indicating the starting point for a date facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_START = FACET_DATE + ".start";
-  /**
-   * Date string indicating the endinging point for a date facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_END = FACET_DATE + ".end";
-  /**
-   * Date Math string indicating the interval of sub-ranges for a date
-   * facet range.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_GAP = FACET_DATE + ".gap";
-  /**
-   * Boolean indicating how counts should be computed if the range
-   * between 'start' and 'end' is not evenly divisible by 'gap'.  If
-   * this value is true, then all counts of ranges involving the 'end'
-   * point will use the exact endpoint specified -- this includes the
-   * 'between' and 'after' counts as well as the last range computed
-   * using the 'gap'.  If the value is false, then 'gap' is used to
-   * compute the effective endpoint closest to the 'end' param which
-   * results in the range between 'start' and 'end' being evenly
-   * divisible by 'gap'.
-   * The default is false.
-   * Can be overriden on a per field basis.
-   */
-  public static final String FACET_DATE_HARD_END = FACET_DATE + ".hardend";
-  /**
-   * String indicating what "other" ranges should be computed for a
-   * date facet range (multi-value).
-   * Can be overriden on a per field basis.
-   * @see FacetDateOther
-   */
-  public static final String FACET_DATE_OTHER = FACET_DATE + ".other";
-
-  /**
-   * An enumeration of the legal values for FACET_DATE_OTHER...
-   * <ul>
-   * <li>before = the count of matches before the start date</li>
-   * <li>after = the count of matches after the end date</li>
-   * <li>between = the count of all matches between start and end</li>
-   * <li>all = all of the above (default value)</li>
-   * <li>none = no additional info requested</li>
-   * </ul>
-   * @see #FACET_DATE_OTHER
-   */
-  public enum FacetDateOther {
-    BEFORE, AFTER, BETWEEN, ALL, NONE;
-    public String toString() { return super.toString().toLowerCase(); }
-    public static FacetDateOther get(String label) {
-      try {
-        return valueOf(label.toUpperCase());
-      } catch (IllegalArgumentException e) {
-        throw new SolrException
-          (SolrException.ErrorCode.BAD_REQUEST,
-           label+" is not a valid type of 'other' date facet information",e);
-      }
-    }
-  }
-  
-
-}
-
diff --git a/src/java/org/apache/solr/common/params/HighlightParams.java b/src/java/org/apache/solr/common/params/HighlightParams.java
deleted file mode 100644
index 8435bf1..0000000
--- a/src/java/org/apache/solr/common/params/HighlightParams.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * @version $Id$
- * @since solr 1.3
- */
-public interface HighlightParams {
-  public static final String HIGHLIGHT   = "hl";
-  public static final String FIELDS      = HIGHLIGHT+".fl";
-  public static final String SNIPPETS    = HIGHLIGHT+".snippets";
-  public static final String FRAGSIZE    = HIGHLIGHT+".fragsize";
-  public static final String INCREMENT   = HIGHLIGHT+".increment";
-  public static final String MAX_CHARS   = HIGHLIGHT+".maxAnalyzedChars";
-  public static final String FORMATTER   = HIGHLIGHT+".formatter";
-  public static final String FRAGMENTER  = HIGHLIGHT+".fragmenter";
-  public static final String FIELD_MATCH = HIGHLIGHT+".requireFieldMatch";
-  public static final String ALTERNATE_FIELD = HIGHLIGHT+".alternateField";
-  public static final String ALTERNATE_FIELD_LENGTH = HIGHLIGHT+".maxAlternateFieldLength";
-  
-  public static final String USE_PHRASE_HIGHLIGHTER = HIGHLIGHT+".usePhraseHighlighter";
-
-  public static final String MERGE_CONTIGUOUS_FRAGMENTS = HIGHLIGHT + ".mergeContiguous";
-  // Formatter
-  public static final String SIMPLE = "simple";
-  public static final String SIMPLE_PRE  = HIGHLIGHT+"."+SIMPLE+".pre";
-  public static final String SIMPLE_POST = HIGHLIGHT+"."+SIMPLE+".post";
-
-  // Regex fragmenter
-  public static final String REGEX = "regex";
-  public static final String SLOP  = HIGHLIGHT+"."+REGEX+".slop";
-  public static final String PATTERN  = HIGHLIGHT+"."+REGEX+".pattern";
-  public static final String MAX_RE_CHARS   = HIGHLIGHT+"."+REGEX+".maxAnalyzedChars";
-}
diff --git a/src/java/org/apache/solr/common/params/MapSolrParams.java b/src/java/org/apache/solr/common/params/MapSolrParams.java
deleted file mode 100644
index 95c71d2..0000000
--- a/src/java/org/apache/solr/common/params/MapSolrParams.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import org.apache.solr.common.util.StrUtils;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * @version $Id$
- */
-public class MapSolrParams extends SolrParams {
-  protected final Map<String,String> map;
-
-  public MapSolrParams(Map<String,String> map) {
-    this.map = map;
-  }
-
-  @Override
-  public String get(String name) {
-    return map.get(name);
-  }
-
-  @Override
-  public String[] getParams(String name) {
-    String val = map.get(name);
-    return val==null ? null : new String[]{val};
-  }
-
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    return map.keySet().iterator();
-  }
-
-  public Map<String,String> getMap() { return map; }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      boolean first=true;
-
-      for (Map.Entry<String,String> entry : map.entrySet()) {
-        String key = entry.getKey();
-        String val = entry.getValue();
-
-        if (!first) sb.append('&');
-        first=false;
-        sb.append(key);
-        sb.append('=');
-        StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-
-    return sb.toString();
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/ModifiableSolrParams.java b/src/java/org/apache/solr/common/params/ModifiableSolrParams.java
deleted file mode 100644
index 32752ac..0000000
--- a/src/java/org/apache/solr/common/params/ModifiableSolrParams.java
+++ /dev/null
@@ -1,212 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import java.io.IOException;
-import java.net.URLEncoder;
-import java.util.LinkedHashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-
-/**
- * This class is similar to MultiMapSolrParams except you can edit the 
- * parameters after it is initialized.  It has helper functions to set/add
- * integer and boolean param values.
- * 
- * @since solr 1.3
- */
-public class ModifiableSolrParams extends SolrParams 
-{
-  private Map<String,String[]> vals;
-  
-  public ModifiableSolrParams()
-  {
-    // LinkedHashMap so params show up in CGI in the same order as they are entered
-    vals = new LinkedHashMap<String, String[]>();
-  }
-
-  /** Constructs a new ModifiableSolrParams directly using the provided Map<String,String[]> */
-  public ModifiableSolrParams( Map<String,String[]> v )
-  {
-    vals = v;
-  }
-
-  /** Constructs a new ModifiableSolrParams, copying values from an existing SolrParams */
-  public ModifiableSolrParams(SolrParams params)
-  {
-    vals = new LinkedHashMap<String, String[]>();
-    if( params != null ) {
-      this.add( params );
-    }
-  }
-
-  //----------------------------------------------------------------
-  //----------------------------------------------------------------
-
-  /**
-   * Replace any existing parameter with the given name.  if val==null remove key from params completely.
-   */
-  public ModifiableSolrParams set( String name, String ... val ) {
-    if (val==null || (val.length==1 && val[0]==null)) {
-      vals.remove(name);
-    } else {
-      vals.put( name, val );
-    }
-    return this;
-  }
-  
-  public ModifiableSolrParams set( String name, int val ) {
-    set( name, String.valueOf(val) );
-    return this;
-  }
-  
-  public ModifiableSolrParams set( String name, boolean val ) {
-    set( name, String.valueOf(val) );
-    return this;
-  }
-
-  /**
-   * Add the given values to any existing name
-   */
-  public ModifiableSolrParams add( String name, String ... val ) {
-    String[] old = vals.put(name, val);
-    if( old != null ) {
-      int i =0;
-      if( val == null || val.length < 1 ) {
-        String[] both = new String[old.length+1];
-        for( String v : old ) {
-          both[i++] = v;
-        }
-        both[i++] = null;
-        vals.put( name, both );
-      }
-      else {
-        String[] both = new String[old.length+val.length];
-        for( String v : old ) {
-          both[i++] = v;
-        }
-        for( String v : val ) {
-          both[i++] = v;
-        }
-        vals.put( name, both );
-      }
-    }
-    return this;
-  }
-
-  public void add(SolrParams params)
-  {
-    Iterator<String> names = params.getParameterNamesIterator();
-    while (names.hasNext()) {
-      String name = names.next();
-      set(name, params.getParams(name));
-    }
-  }
-  
-  /**
-   * remove a field at the given name
-   */
-  public String[] remove( String name )
-  {
-    return vals.remove( name );
-  }
-  
-  /** clear all parameters */
-  public void clear()
-  {
-    vals.clear();
-  }
-  
-  /** 
-   * remove the given value for the given name
-   * 
-   * @return true if the item was removed, false if null or not present
-   */
-  public boolean remove(String name, String value) {
-     String[] tmp = vals.get(name);
-     if (tmp==null) return false;
-     for (int i=0; i<tmp.length; i++) {
-       if (tmp[i].equals(value)) {
-         String[] tmp2 = new String[tmp.length-1];
-         if (tmp2.length==0) {
-           tmp2 = null;
-           remove(name);
-         } else {
-           System.arraycopy(tmp, 0, tmp2, 0, i);
-           System.arraycopy(tmp, i+1, tmp2, i, tmp.length-i-1);
-           set(name, tmp2);
-         }
-         return true;
-       }
-     }
-     return false;
-  }
-
-  //----------------------------------------------------------------
-  //----------------------------------------------------------------
-
-  @Override
-  public String get(String param) {
-    String[] v = vals.get( param );
-    if( v!= null && v.length > 0 ) {
-      return v[0];
-    }
-    return null;
-  }
-
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    return vals.keySet().iterator();
-  }
-  
-  public Set<String> getParameterNames() {
-    return vals.keySet();
-  }
-
-  @Override
-  public String[] getParams(String param) {
-    return vals.get( param );
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      boolean first=true;
-
-      for (Map.Entry<String,String[]> entry : vals.entrySet()) {
-        String key = entry.getKey();
-        String[] valarr = entry.getValue();
-        for (String val : valarr) {
-          if (!first) sb.append('&');
-          first=false;
-          sb.append(key);
-          sb.append('=');
-          if( val != null ) {
-            sb.append( URLEncoder.encode( val, "UTF-8" ) );
-          }
-        }
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-
-    return sb.toString();
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/MoreLikeThisParams.java b/src/java/org/apache/solr/common/params/MoreLikeThisParams.java
deleted file mode 100644
index 9ca6ad3..0000000
--- a/src/java/org/apache/solr/common/params/MoreLikeThisParams.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * @since solr 1.3
- */
-public interface MoreLikeThisParams 
-{
-  // enable more like this -- this only applies to 'StandardRequestHandler' maybe DismaxRequestHandler
-  public final static String MLT = "mlt";
-  
-  public final static String PREFIX = "mlt.";
-  
-  public final static String SIMILARITY_FIELDS     = PREFIX + "fl";
-  public final static String MIN_TERM_FREQ         = PREFIX + "mintf";
-  public final static String MIN_DOC_FREQ          = PREFIX + "mindf";
-  public final static String MIN_WORD_LEN          = PREFIX + "minwl";
-  public final static String MAX_WORD_LEN          = PREFIX + "maxwl";
-  public final static String MAX_QUERY_TERMS       = PREFIX + "maxqt";
-  public final static String MAX_NUM_TOKENS_PARSED = PREFIX + "maxntp";
-  public final static String BOOST                 = PREFIX + "boost"; // boost or not?
-  public final static String QF                    = PREFIX + "qf"; //boosting applied to mlt fields
-
-  // the /mlt request handler uses 'rows'
-  public final static String DOC_COUNT = PREFIX + "count";
-
-  // Do you want to include the original document in the results or not
-  public final static String MATCH_INCLUDE = PREFIX + "match.include";
-  
-  // If multiple docs are matched in the query, what offset do you want?
-  public final static String MATCH_OFFSET  = PREFIX + "match.offset";
-
-  // Do you want to include the original document in the results or not
-  public final static String INTERESTING_TERMS = PREFIX + "interestingTerms";  // false,details,(list or true)
-  
-  public enum TermStyle {
-    NONE,
-    LIST,
-    DETAILS;
-    
-    public static TermStyle get( String p )
-    {
-      if( p != null ) {
-        p = p.toUpperCase();
-        if( p.equals( "DETAILS" ) ) {
-          return DETAILS;
-        }
-        else if( p.equals( "LIST" ) ) {
-          return LIST;
-        }
-      }
-      return NONE; 
-    }
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/MultiMapSolrParams.java b/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
deleted file mode 100644
index 781c1da..0000000
--- a/src/java/org/apache/solr/common/params/MultiMapSolrParams.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import org.apache.solr.common.util.StrUtils;
-
-import java.util.Iterator;
-import java.util.Map;
-import java.io.IOException;
-
-/**
- * @version $Id$
- */
-public class MultiMapSolrParams extends SolrParams {
-  protected final Map<String,String[]> map;
-
-  public static void addParam(String name, String val, Map<String,String[]> map) {
-      String[] arr = map.get(name);
-      if (arr ==null) {
-        arr =new String[]{val};
-      } else {
-        String[] newarr = new String[arr.length+1];
-        System.arraycopy(arr,0,newarr,0,arr.length);
-        newarr[arr.length]=val;
-        arr =newarr;
-      }
-      map.put(name, arr);
-  }
-
-  public MultiMapSolrParams(Map<String,String[]> map) {
-    this.map = map;
-  }
-
-  @Override
-  public String get(String name) {
-    String[] arr = map.get(name);
-    return arr==null ? null : arr[0];
-  }
-
-  @Override
-  public String[] getParams(String name) {
-    return map.get(name);
-  }
-
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    return map.keySet().iterator();
-  }
-
-  public Map<String,String[]> getMap() { return map; }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder(128);
-    try {
-      boolean first=true;
-
-      for (Map.Entry<String,String[]> entry : map.entrySet()) {
-        String key = entry.getKey();
-        String[] valarr = entry.getValue();
-
-        for (String val : valarr) {
-          if (!first) sb.append('&');
-          first=false;
-          sb.append(key);
-          sb.append('=');
-          StrUtils.partialURLEncodeVal(sb, val==null ? "" : val);
-        }
-      }
-    }
-    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
-
-    return sb.toString();
-  }
-
-
-}
diff --git a/src/java/org/apache/solr/common/params/RequiredSolrParams.java b/src/java/org/apache/solr/common/params/RequiredSolrParams.java
deleted file mode 100755
index 7abf75b..0000000
--- a/src/java/org/apache/solr/common/params/RequiredSolrParams.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import org.apache.solr.common.SolrException;
-
-import java.util.Iterator;
-
-/**
- * This is a simple wrapper to SolrParams that will throw a 400
- * exception if you ask for a parameter that does not exist.  Fields
- * specified with
- * 
- * In short, any value you for from a <code>RequiredSolrParams</code> 
- * will return a valid non-null value or throw a 400 exception.  
- * (If you pass in <code>null</code> as the default value, you can 
- * get a null return value)
- * 
- * @version $Id$
- * @since solr 1.2
- */
-public class RequiredSolrParams extends SolrParams {
-  protected final SolrParams params;
-  
-  public RequiredSolrParams(SolrParams params) {
-    this.params = params;
-  }
-
-  /** get the param from params, fail if not found **/
-  @Override
-  public String get(String param) {
-    String val = params.get(param);
-    if( val == null )  {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
-    }
-    return val;
-  }
-  
-  @Override
-  public String getFieldParam(final String field, final String param) {
-    final String fpname = fpname(field,param);
-    String val = params.get(fpname);
-    if (null == val) {
-      // don't call this.get, we want a specified exception message
-      val = params.get(param);
-      if (null == val)  {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                 "Missing required parameter: "+fpname+
-                                 " (or default: "+param+")" );
-      }
-    }
-    return val;
-  }
-
-  @Override
-  public String[] getFieldParams(final String field, final String param) {
-    final String fpname = fpname(field,param);
-    String[] val = params.getParams(fpname);
-    if (null == val) {
-      // don't call this.getParams, we want a specified exception message
-      val = params.getParams(param);
-      if (null == val)  {
-        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,
-                                 "Missing required parameter: "+fpname+
-                                 " (or default: "+param+")" );
-      }
-    }
-    return val;
-  }
-
-  
-  @Override
-  public String[] getParams(String param) {
-    String[] vals = params.getParams(param);
-    if( vals == null || vals.length == 0 ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Missing required parameter: "+param );
-    }
-    return vals;
-  }
-  
-  /** returns an Iterator over the parameter names */
-  @Override
-  public Iterator<String> getParameterNamesIterator() {
-    return params.getParameterNamesIterator();
-  }
-
-  @Override
-  public String toString() {
-    return "{required("+params+")}";  
-  }    
-
-  //----------------------------------------------------------
-  // Functions with a default value - pass directly to the
-  // wrapped SolrParams (they won't return null - unless its the default)
-  //----------------------------------------------------------
-
-  @Override
-  public String get(String param, String def) {
-    return params.get(param, def);
-  }
-
-  @Override
-  public int getInt(String param, int def) {
-    return params.getInt(param, def);
-  }
-
-  @Override
-  public float getFloat(String param, float def) {
-    return params.getFloat(param, def);
-  }
-  
-  @Override
-  public boolean getBool(String param, boolean def) {
-    return params.getBool(param, def);
-  }
-
-  @Override
-  public int getFieldInt(String field, String param, int def) {
-    return params.getFieldInt(field, param, def);
-  }
-  
-  @Override
-  public boolean getFieldBool(String field, String param, boolean def) {
-    return params.getFieldBool(field, param, def);
-  }
-
-  @Override
-  public float getFieldFloat(String field, String param, float def) {
-    return params.getFieldFloat(field, param, def);
-  }
-
-  @Override
-  public String getFieldParam(String field, String param, String def) {
-    return params.getFieldParam(field, param, def);
-  }
-}
diff --git a/src/java/org/apache/solr/common/params/ShardParams.java b/src/java/org/apache/solr/common/params/ShardParams.java
deleted file mode 100644
index e929c0c..0000000
--- a/src/java/org/apache/solr/common/params/ShardParams.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * Parameters used for distributed search.
- */
-public interface ShardParams {
-  /** the shards to use (distributed configuration) */
-  public static final String SHARDS = "shards";
-  
-  /** IDs of the shard documents */
-  public static final String IDS = "ids";
-  
-  /** whether the request goes to a shard */
-  public static final String IS_SHARD = "isShard";
-  
-  /** query type for shard requests */
-  public static final String SHARDS_QT = "shards.qt";
-}
diff --git a/src/java/org/apache/solr/common/params/SolrParams.java b/src/java/org/apache/solr/common/params/SolrParams.java
deleted file mode 100644
index 4b96fb1..0000000
--- a/src/java/org/apache/solr/common/params/SolrParams.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.solr.common.SolrException;
-import org.apache.solr.common.util.NamedList;
-import org.apache.solr.common.util.SimpleOrderedMap;
-
-/**  SolrParams hold request parameters.
- *
- * @version $Id$
- */
-public abstract class SolrParams implements Serializable {
-  
-  /** returns the String value of a param, or null if not set */
-  public abstract String get(String param);
-
-  /** returns an array of the String values of a param, or null if none */
-  public abstract String[] getParams(String param);
-
-  /** returns an Iterator over the parameter names */
-  public abstract Iterator<String> getParameterNamesIterator();
-
-  /** returns the value of the param, or def if not set */
-  public String get(String param, String def) {
-    String val = get(param);
-    return val==null ? def : val;
-  }
-  
-  /** returns a RequiredSolrParams wrapping this */
-  public RequiredSolrParams required()
-  {
-    // TODO? should we want to stash a reference?
-    return new RequiredSolrParams(this);
-  }
-  
-  protected String fpname(String field, String param) {
-    return "f."+field+'.'+param;
-  }
-
-  /** returns the String value of the field parameter, "f.field.param", or
-   *  the value for "param" if that is not set.
-   */
-  public String getFieldParam(String field, String param) {
-    String val = get(fpname(field,param));
-    return val!=null ? val : get(param);
-  }
-
-  /** returns the String value of the field parameter, "f.field.param", or
-   *  the value for "param" if that is not set.  If that is not set, def
-   */
-  public String getFieldParam(String field, String param, String def) {
-    String val = get(fpname(field,param));
-    return val!=null ? val : get(param, def);
-  }
-  
-  /** returns the String values of the field parameter, "f.field.param", or
-   *  the values for "param" if that is not set.
-   */
-  public String[] getFieldParams(String field, String param) {
-    String[] val = getParams(fpname(field,param));
-    return val!=null ? val : getParams(param);
-  }
-
-  /** Returns the Boolean value of the param, or null if not set */
-  public Boolean getBool(String param) {
-    String val = get(param);
-    return val==null ? null : parseBool(val);
-  }
-
-  /** Returns the boolean value of the param, or def if not set */
-  public boolean getBool(String param, boolean def) {
-    String val = get(param);
-    return val==null ? def : parseBool(val);
-  }
-  
-  /** Returns the Boolean value of the field param, 
-      or the value for param, or null if neither is set. */
-  public Boolean getFieldBool(String field, String param) {
-    String val = getFieldParam(field, param);
-    return val==null ? null : parseBool(val);
-  }
-  
-  /** Returns the boolean value of the field param, 
-  or the value for param, or def if neither is set. */
-  public boolean getFieldBool(String field, String param, boolean def) {
-    String val = getFieldParam(field, param);
-    return val==null ? def : parseBool(val);
-  }
-
-  /** Returns the Integer value of the param, or null if not set */
-  public Integer getInt(String param) {
-    String val = get(param);
-    try {
-      return val==null ? null : Integer.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the int value of the param, or def if not set */
-  public int getInt(String param, int def) {
-    String val = get(param);
-    try {
-      return val==null ? def : Integer.parseInt(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** Returns the int value of the field param,
-  or the value for param, or def if neither is set. */
-  public Integer getFieldInt(String field, String param) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? null : Integer.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** Returns the int value of the field param, 
-  or the value for param, or def if neither is set. */
-  public int getFieldInt(String field, String param, int def) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? def : Integer.parseInt(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-
-  /** Returns the Float value of the param, or null if not set */
-  public Float getFloat(String param) {
-    String val = get(param);
-    try {
-      return val==null ? null : Float.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the param, or def if not set */
-  public float getFloat(String param, float def) {
-    String val = get(param);
-    try {
-      return val==null ? def : Float.parseFloat(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the field param. */
-  public Float getFieldFloat(String field, String param) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? null : Float.valueOf(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-
-  /** Returns the float value of the field param,
-  or the value for param, or def if neither is set. */
-  public float getFieldFloat(String field, String param, float def) {
-    String val = getFieldParam(field, param);
-    try {
-      return val==null ? def : Float.parseFloat(val);
-    }
-    catch( Exception ex ) {
-      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, ex.getMessage(), ex );
-    }
-  }
-  
-  /** how to transform a String into a boolean... more flexible than
-   * Boolean.parseBoolean() to enable easier integration with html forms.
-   */
-  protected boolean parseBool(String s) {
-    if( s != null ) {
-      if( s.startsWith("true") || s.startsWith("on") || s.startsWith("yes") ) {
-        return true;
-      }
-      if( s.startsWith("false") || s.startsWith("off") || s.equals("no") ) {
-        return false;
-      }
-    }
-    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "invalid boolean value: "+s );
-  }
-
-  /** Create a Map<String,String> from a NamedList given no keys are repeated */
-  public static Map<String,String> toMap(NamedList params) {
-    HashMap<String,String> map = new HashMap<String,String>();
-    for (int i=0; i<params.size(); i++) {
-      map.put(params.getName(i), params.getVal(i).toString());
-    }
-    return map;
-  }
-
-  /** Create a Map<String,String[]> from a NamedList */
-  public static Map<String,String[]> toMultiMap(NamedList params) {
-    HashMap<String,String[]> map = new HashMap<String,String[]>();
-    for (int i=0; i<params.size(); i++) {
-      String name = params.getName(i);
-      String val = params.getVal(i).toString();
-      MultiMapSolrParams.addParam(name,val,map);
-    }
-    return map;
-  }
-
-  /** Create SolrParams from NamedList. */
-  public static SolrParams toSolrParams(NamedList params) {
-    // if no keys are repeated use the faster MapSolrParams
-    HashMap<String,String> map = new HashMap<String,String>();
-    for (int i=0; i<params.size(); i++) {
-      String prev = map.put(params.getName(i), params.getVal(i).toString());
-      if (prev!=null) return new MultiMapSolrParams(toMultiMap(params));
-    }
-    return new MapSolrParams(map);
-  }
-  
-  /** Convert this to a NamedList */
-  public NamedList<Object> toNamedList() {
-    final SimpleOrderedMap<Object> result = new SimpleOrderedMap<Object>();
-    
-    for(Iterator<String> it=getParameterNamesIterator(); it.hasNext(); ) {
-      final String name = it.next();
-      final String [] values = getParams(name);
-      if(values.length==1) {
-        result.add(name,values[0]);
-      } else {
-        // currently no reason not to use the same array
-        result.add(name,values);
-      }
-    }
-    return result;
-  }
-}
-
-
-
-
-
-
-
-
diff --git a/src/java/org/apache/solr/common/params/SpellingParams.java b/src/java/org/apache/solr/common/params/SpellingParams.java
deleted file mode 100644
index b0c77a0..0000000
--- a/src/java/org/apache/solr/common/params/SpellingParams.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * Parameters used for spellchecking
- * 
- * @since solr 1.3
- */
-public interface SpellingParams {
-
-  public static final String SPELLCHECK_PREFIX = "spellcheck.";
-
-  /**
-   * The name of the dictionary to be used for giving the suggestion for a
-   * request. The value for this parameter is configured in solrconfig.xml
-   */
-  public static final String SPELLCHECK_DICT = SPELLCHECK_PREFIX + "dictionary";
-
-  /**
-   * The count of suggestions needed for a given query.
-   * <p/>
-   * If this parameter is absent in the request then only one suggestion is
-   * returned. If it is more than one then a maximum of given suggestions are
-   * returned for each token in the query.
-   */
-  public static final String SPELLCHECK_COUNT = SPELLCHECK_PREFIX + "count";
-
-  /**
-   * When this parameter is set to true and the misspelled word exists in the
-   * user field, only words that occur more frequently in the Solr field than
-   * the one given will be returned. The default value is false.
-   * <p/>
-   * <b>This is applicable only for dictionaries built from Solr fields.</b>
-   */
-  public static final String SPELLCHECK_ONLY_MORE_POPULAR = SPELLCHECK_PREFIX + "onlyMorePopular";
-
-  /**
-   * Whether to use the extended response format, which is more complicated but
-   * richer. Returns the document frequency for each suggestion and returns one
-   * suggestion block for each term in the query string. Default is false.
-   * <p/>
-   * <b>This is applicable only for dictionaries built from Solr fields.</b>
-   */
-  public static final String SPELLCHECK_EXTENDED_RESULTS = SPELLCHECK_PREFIX + "extendedResults";
-
-  /**
-   * Use the value for this parameter as the query to spell check.
-   * <p/>
-   * This parameter is <b>optional</b>. If absent, then the q parameter is
-   * used.
-   */
-  public static final String SPELLCHECK_Q = SPELLCHECK_PREFIX + "q";
-
-  /**
-   * Whether to build the index or not. Optional and false by default.
-   */
-  public static final String SPELLCHECK_BUILD = SPELLCHECK_PREFIX + "build";
-
-  /**
-   * Whether to reload the index. Optional and false by default.
-   */
-  public static final String SPELLCHECK_RELOAD = SPELLCHECK_PREFIX + "reload";
-
-  /**
-   * Take the top suggestion for each token and create a new query from it
-   */
-  public static final String SPELLCHECK_COLLATE = SPELLCHECK_PREFIX + "collate";
-}
diff --git a/src/java/org/apache/solr/common/params/StatsParams.java b/src/java/org/apache/solr/common/params/StatsParams.java
deleted file mode 100644
index f63cd21..0000000
--- a/src/java/org/apache/solr/common/params/StatsParams.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * Stats Parameters
- */
-public interface StatsParams {
-  public static final String STATS = "stats";
-  public static final String STATS_FIELD = STATS + ".field";
-  public static final String STATS_FACET = STATS + ".facet";
-  public static final String STATS_TWOPASS = STATS + ".twopass";
-}
diff --git a/src/java/org/apache/solr/common/params/TermVectorParams.java b/src/java/org/apache/solr/common/params/TermVectorParams.java
deleted file mode 100644
index cf75ac7..0000000
--- a/src/java/org/apache/solr/common/params/TermVectorParams.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.apache.solr.common.params;
-
-
-/**
- *
- *
- **/
-public interface TermVectorParams {
-
-  public static final String TV_PREFIX = "tv.";
-
-    /**
-  * Return Term Frequency info
-  * */
-  public static final String TF =  TV_PREFIX + "tf";
-  /**
-  * Return Term Vector position information
-  *
-  * */
-  public static final String POSITIONS = TV_PREFIX + "positions";
-  /**
-  * Return offset information, if available
-  * */
-  public static final String OFFSETS = TV_PREFIX + "offsets";
-  /**
-  * Return IDF information.  May be expensive
-  * */
-  public static final String DF = TV_PREFIX + "df";
-
-  /**
-   * Return TF-IDF calculation, i.e. (tf / idf).  May be expensive.
-   */
-  public static final String TF_IDF = TV_PREFIX + "tf_idf";
-
-
-  /**
-   * Return all the options: TF, positions, offsets, idf
-   */
-  public static final String ALL = TV_PREFIX + "all";
-
-  /**
-   * The fields to get term vectors for
-   */
-  public static final String FIELDS = TV_PREFIX + "fl";
-
-  /**
-   * The Doc Ids (Lucene internal ids) of the docs to get the term vectors for
-   */
-  public static final String DOC_IDS = TV_PREFIX + "docIds";
-}
diff --git a/src/java/org/apache/solr/common/params/TermsParams.java b/src/java/org/apache/solr/common/params/TermsParams.java
deleted file mode 100644
index 1ade243..0000000
--- a/src/java/org/apache/solr/common/params/TermsParams.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-
-/**
- *
- *
- **/
-public interface TermsParams {
-  /**
-   * The component name.  Set to true to turn on the TermsComponent
-   */
-  public static final String TERMS = "terms";
-
-  /**
-   * Used for building up the other terms
-   */
-  public static final String TERMS_PREFIX = TERMS + ".";
-
-  /**
-   * Required.  Specify the field to look up terms in.
-   */
-  public static final String TERMS_FIELD = TERMS_PREFIX + "fl";
-
-  /**
-   * Optional.  The lower bound term to start at.  The TermEnum will start at the next term after this term in the dictionary.
-   *
-   * If not specified, the empty string is used
-   */
-  public static final String TERMS_LOWER = TERMS_PREFIX + "lower";
-
-  /**
-   * Optional.  The term to stop at.
-   *
-   * @see #TERMS_UPPER_INCLUSIVE
-   */
-  public static final String TERMS_UPPER = TERMS_PREFIX + "upper";
-  /**
-   * Optional.  If true, include the upper bound term in the results.  False by default.
-   */
-  public static final String TERMS_UPPER_INCLUSIVE = TERMS_PREFIX + "upper.incl";
-
-  /**
-   * Optional.  If true, include the lower bound term in the results, otherwise skip to the next one.  True by default.
-   */
-  public static final String TERMS_LOWER_INCLUSIVE = TERMS_PREFIX + "lower.incl";
-
-  /**
-   * Optional.  The number of results to return.  If not specified, looks for {@link org.apache.solr.common.params.CommonParams#ROWS}.  If that's not specified, uses 10.
-   */
-  public static final String TERMS_ROWS = TERMS_PREFIX + "rows";
-
-  public static final String TERMS_PREFIX_STR = TERMS_PREFIX + "prefix";
-
-  /**
-   * Optional.  The minimum value of docFreq to be returned.  1 by default
-   */
-  public static final String TERMS_MINCOUNT = TERMS_PREFIX + "mincount";
-  /**
-   * Optional.  The maximum value of docFreq to be returned.  -1 by default means no boundary
-   */
-  public static final String TERMS_MAXCOUNT = TERMS_PREFIX + "maxcount";
-}
-
diff --git a/src/java/org/apache/solr/common/params/UpdateParams.java b/src/java/org/apache/solr/common/params/UpdateParams.java
deleted file mode 100644
index b354bcb..0000000
--- a/src/java/org/apache/solr/common/params/UpdateParams.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.params;
-
-/**
- * A collection of standard params used by Update handlers
- *
- * @version $Id$
- * @since solr 1.2
- */
-public interface UpdateParams 
-{
-  /** wait till the command has flushed */
-  public static String WAIT_FLUSH = "waitFlush";
-  
-  /** wait for the search to warm up */
-  public static String WAIT_SEARCHER = "waitSearcher";
-  
-  /** overwrite indexing fields */
-  public static String OVERWRITE = "overwrite";
-  
-  /** Commit everything after the command completes */
-  public static String COMMIT = "commit";
-  
-  /** Optimize the index and commit everything after the command completes */
-  public static String OPTIMIZE = "optimize";
-  
-  /** Rollback update commands */
-  public static String ROLLBACK = "rollback";
-
-  /** Select the update processor to use.  A RequestHandler may or may not respect this parameter */
-  public static final String UPDATE_PROCESSOR = "update.processor";
-  /**
-   * If optimizing, set the maximum number of segments left in the index after optimization.  1 is the default (and is equivalent to calling IndexWriter.optimize() in Lucene).
-   */
-  public static final String MAX_OPTIMIZE_SEGMENTS = "maxSegments";
-}
diff --git a/src/java/org/apache/solr/common/util/ConcurrentLRUCache.java b/src/java/org/apache/solr/common/util/ConcurrentLRUCache.java
deleted file mode 100644
index ddbf9fa..0000000
--- a/src/java/org/apache/solr/common/util/ConcurrentLRUCache.java
+++ /dev/null
@@ -1,535 +0,0 @@
-package org.apache.solr.common.util;
-
-import org.apache.lucene.util.PriorityQueue;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.TreeSet;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.locks.ReentrantLock;
-import java.lang.ref.WeakReference;
-
-/**
- * A LRU cache implementation based upon ConcurrentHashMap and other techniques to reduce
- * contention and synchronization overhead to utilize multiple CPU cores more effectively.
- * <p/>
- * Note that the implementation does not follow a true LRU (least-recently-used) eviction
- * strategy. Instead it strives to remove least recently used items but when the initial
- * cleanup does not remove enough items to reach the 'acceptableWaterMark' limit, it can
- * remove more items forcefully regardless of access order.
- *
- * @version $Id$
- * @since solr 1.4
- */
-public class ConcurrentLRUCache<K,V> {
-
-  private final ConcurrentHashMap<Object, CacheEntry> map;
-  private final int upperWaterMark, lowerWaterMark;
-  private final ReentrantLock markAndSweepLock = new ReentrantLock(true);
-  private boolean isCleaning = false;  // not volatile... piggybacked on other volatile vars
-  private final boolean newThreadForCleanup;
-  private volatile boolean islive = true;
-  private final Stats stats = new Stats();
-  private final int acceptableWaterMark;
-  private long oldestEntry = 0;  // not volatile, only accessed in the cleaning method
-  private final EvictionListener<K,V> evictionListener;
-  private CleanupThread cleanupThread ;
-
-  public ConcurrentLRUCache(int upperWaterMark, final int lowerWaterMark, int acceptableWatermark,
-                            int initialSize, boolean runCleanupThread, boolean runNewThreadForCleanup,
-                            EvictionListener<K,V> evictionListener) {
-    if (upperWaterMark < 1) throw new IllegalArgumentException("upperWaterMark must be > 0");
-    if (lowerWaterMark >= upperWaterMark)
-      throw new IllegalArgumentException("lowerWaterMark must be  < upperWaterMark");
-    map = new ConcurrentHashMap<Object, CacheEntry>(initialSize);
-    newThreadForCleanup = runNewThreadForCleanup;
-    this.upperWaterMark = upperWaterMark;
-    this.lowerWaterMark = lowerWaterMark;
-    this.acceptableWaterMark = acceptableWatermark;
-    this.evictionListener = evictionListener;
-    if (runCleanupThread) {
-      cleanupThread = new CleanupThread(this);
-      cleanupThread.start();
-    }
-  }
-
-
-  public void setAlive(boolean live) {
-    islive = live;
-  }
-
-  public V get(K key) {
-    CacheEntry<K,V> e = map.get(key);
-    if (e == null) {
-      if (islive) stats.missCounter.incrementAndGet();
-      return null;
-    }
-    if (islive) e.lastAccessed = stats.accessCounter.incrementAndGet();
-    return e.value;
-  }
-
-  public V remove(K key) {
-    CacheEntry<K,V> cacheEntry = map.remove(key);
-    if (cacheEntry != null) {
-      stats.size.decrementAndGet();
-      if(evictionListener != null) evictionListener.evictedEntry(cacheEntry.key , cacheEntry.value);
-      return cacheEntry.value;
-    }
-    return null;
-  }
-
-  public Object put(K key, V val) {
-    if (val == null) return null;
-    CacheEntry e = new CacheEntry(key, val, stats.accessCounter.incrementAndGet());
-    CacheEntry oldCacheEntry = map.put(key, e);
-    if (oldCacheEntry == null) {
-      stats.size.incrementAndGet();
-    }
-    if (islive) {
-      stats.putCounter.incrementAndGet();
-    } else {
-      stats.nonLivePutCounter.incrementAndGet();
-    }
-
-    // Check if we need to clear out old entries from the cache.
-    // isCleaning variable is checked instead of markAndSweepLock.isLocked()
-    // for performance because every put invokation will check until
-    // the size is back to an acceptable level.
-    //
-    // There is a race between the check and the call to markAndSweep, but
-    // it's unimportant because markAndSweep actually aquires the lock or returns if it can't.
-    //
-    // Thread safety note: isCleaning read is piggybacked (comes after) other volatile reads
-    // in this method.
-    if (stats.size.get() > upperWaterMark && !isCleaning) {
-      if (newThreadForCleanup) {
-        new Thread() {
-          public void run() {
-            markAndSweep();
-          }
-        }.start();
-      } else if (cleanupThread != null){
-        cleanupThread.wakeThread();
-      } else {
-        markAndSweep();
-      }
-    }
-    return oldCacheEntry == null ? null : oldCacheEntry.value;
-  }
-
-  /**
-   * Removes items from the cache to bring the size down
-   * to an acceptable value ('acceptableWaterMark').
-   * <p/>
-   * It is done in two stages. In the first stage, least recently used items are evicted.
-   * If, after the first stage, the cache size is still greater than 'acceptableSize'
-   * config parameter, the second stage takes over.
-   * <p/>
-   * The second stage is more intensive and tries to bring down the cache size
-   * to the 'lowerWaterMark' config parameter.
-   */
-  private void markAndSweep() {
-    // if we want to keep at least 1000 entries, then timestamps of
-    // current through current-1000 are guaranteed not to be the oldest (but that does
-    // not mean there are 1000 entries in that group... it's acutally anywhere between
-    // 1 and 1000).
-    // Also, if we want to remove 500 entries, then
-    // oldestEntry through oldestEntry+500 are guaranteed to be
-    // removed (however many there are there).
-
-    if (!markAndSweepLock.tryLock()) return;
-    try {
-      long oldestEntry = this.oldestEntry;
-      isCleaning = true;
-      this.oldestEntry = oldestEntry;     // volatile write to make isCleaning visible
-
-      long timeCurrent = stats.accessCounter.get();
-      int sz = stats.size.get();
-
-      int numRemoved = 0;
-      int numKept = 0;
-      long newestEntry = timeCurrent;
-      long newNewestEntry = -1;
-      long newOldestEntry = Integer.MAX_VALUE;
-
-      int wantToKeep = lowerWaterMark;
-      int wantToRemove = sz - lowerWaterMark;
-
-      CacheEntry<K,V>[] eset = new CacheEntry[sz];
-      int eSize = 0;
-
-      // System.out.println("newestEntry="+newestEntry + " oldestEntry="+oldestEntry);
-      // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
-
-      for (CacheEntry<K,V> ce : map.values()) {
-        // set lastAccessedCopy to avoid more volatile reads
-        ce.lastAccessedCopy = ce.lastAccessed;
-        long thisEntry = ce.lastAccessedCopy;
-
-        // since the wantToKeep group is likely to be bigger than wantToRemove, check it first
-        if (thisEntry > newestEntry - wantToKeep) {
-          // this entry is guaranteed not to be in the bottom
-          // group, so do nothing.
-          numKept++;
-          newOldestEntry = Math.min(thisEntry, newOldestEntry);
-        } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?
-          // this entry is guaranteed to be in the bottom group
-          // so immediately remove it from the map.
-          evictEntry(ce.key);
-          numRemoved++;
-        } else {
-          // This entry *could* be in the bottom group.
-          // Collect these entries to avoid another full pass... this is wasted
-          // effort if enough entries are normally removed in this first pass.
-          // An alternate impl could make a full second pass.
-          if (eSize < eset.length-1) {
-            eset[eSize++] = ce;
-            newNewestEntry = Math.max(thisEntry, newNewestEntry);
-            newOldestEntry = Math.min(thisEntry, newOldestEntry);
-          }
-        }
-      }
-
-      // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
-      // TODO: allow this to be customized in the constructor?
-      int numPasses=1; // maximum number of linear passes over the data
-
-      // if we didn't remove enough entries, then make more passes
-      // over the values we collected, with updated min and max values.
-      while (sz - numRemoved > acceptableWaterMark && --numPasses>=0) {
-
-        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
-        newOldestEntry = Integer.MAX_VALUE;
-        newestEntry = newNewestEntry;
-        newNewestEntry = -1;
-        wantToKeep = lowerWaterMark - numKept;
-        wantToRemove = sz - lowerWaterMark - numRemoved;
-
-        // iterate backward to make it easy to remove items.
-        for (int i=eSize-1; i>=0; i--) {
-          CacheEntry<K,V> ce = eset[i];
-          long thisEntry = ce.lastAccessedCopy;
-
-          if (thisEntry > newestEntry - wantToKeep) {
-            // this entry is guaranteed not to be in the bottom
-            // group, so do nothing but remove it from the eset.
-            numKept++;
-            // remove the entry by moving the last element to it's position
-            eset[i] = eset[eSize-1];
-            eSize--;
-
-            newOldestEntry = Math.min(thisEntry, newOldestEntry);
-            
-          } else if (thisEntry < oldestEntry + wantToRemove) { // entry in bottom group?
-
-            // this entry is guaranteed to be in the bottom group
-            // so immediately remove it from the map.
-            evictEntry(ce.key);
-            numRemoved++;
-
-            // remove the entry by moving the last element to it's position
-            eset[i] = eset[eSize-1];
-            eSize--;
-          } else {
-            // This entry *could* be in the bottom group, so keep it in the eset,
-            // and update the stats.
-            newNewestEntry = Math.max(thisEntry, newNewestEntry);
-            newOldestEntry = Math.min(thisEntry, newOldestEntry);
-          }
-        }
-        // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " esetSz="+ eSize + " sz-numRemoved=" + (sz-numRemoved));
-      }
-
-
-
-      // if we still didn't remove enough entries, then make another pass while
-      // inserting into a priority queue
-      if (sz - numRemoved > acceptableWaterMark) {
-
-        oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
-        newOldestEntry = Integer.MAX_VALUE;
-        newestEntry = newNewestEntry;
-        newNewestEntry = -1;
-        wantToKeep = lowerWaterMark - numKept;
-        wantToRemove = sz - lowerWaterMark - numRemoved;
-
-        PQueue queue = new PQueue(wantToRemove);
-
-        for (int i=eSize-1; i>=0; i--) {
-          CacheEntry<K,V> ce = eset[i];
-          long thisEntry = ce.lastAccessedCopy;
-
-          if (thisEntry > newestEntry - wantToKeep) {
-            // this entry is guaranteed not to be in the bottom
-            // group, so do nothing but remove it from the eset.
-            numKept++;
-            // removal not necessary on last pass.
-            // eset[i] = eset[eSize-1];
-            // eSize--;
-
-            newOldestEntry = Math.min(thisEntry, newOldestEntry);
-            
-          } else if (thisEntry < oldestEntry + wantToRemove) {  // entry in bottom group?
-            // this entry is guaranteed to be in the bottom group
-            // so immediately remove it.
-            evictEntry(ce.key);
-            numRemoved++;
-
-            // removal not necessary on last pass.
-            // eset[i] = eset[eSize-1];
-            // eSize--;
-          } else {
-            // This entry *could* be in the bottom group.
-            // add it to the priority queue
-
-            // everything in the priority queue will be removed, so keep track of
-            // the lowest value that ever comes back out of the queue.
-
-            // first reduce the size of the priority queue to account for
-            // the number of items we have already removed while executing
-            // this loop so far.
-            queue.myMaxSize = sz - lowerWaterMark - numRemoved;
-            while (queue.size() > queue.myMaxSize && queue.size() > 0) {
-              CacheEntry otherEntry = (CacheEntry) queue.pop();
-              newOldestEntry = Math.min(otherEntry.lastAccessedCopy, newOldestEntry);
-            }
-            if (queue.myMaxSize <= 0) break;
-
-            Object o = queue.myInsertWithOverflow(ce);
-            if (o != null) {
-              newOldestEntry = Math.min(((CacheEntry)o).lastAccessedCopy, newOldestEntry);
-            }
-          }
-        }
-
-        // Now delete everything in the priority queue.
-        // avoid using pop() since order doesn't matter anymore
-        for (Object o : queue.getValues()) {
-          if (o==null) continue;
-          CacheEntry<K,V> ce = (CacheEntry)o;
-          evictEntry(ce.key);
-          numRemoved++;
-        }
-
-        // System.out.println("items removed:" + numRemoved + " numKept=" + numKept + " initialQueueSize="+ wantToRemove + " finalQueueSize=" + queue.size() + " sz-numRemoved=" + (sz-numRemoved));
-      }
-
-      oldestEntry = newOldestEntry == Integer.MAX_VALUE ? oldestEntry : newOldestEntry;
-      this.oldestEntry = oldestEntry;
-    } finally {
-      isCleaning = false;  // set before markAndSweep.unlock() for visibility
-      markAndSweepLock.unlock();
-    }
-  }
-
-  private static class PQueue extends PriorityQueue {
-    int myMaxSize;
-    PQueue(int maxSz) {
-      super.initialize(maxSz);
-      myMaxSize = maxSz;
-    }
-
-    Object[] getValues() { return heap; }
-
-    protected boolean lessThan(Object a, Object b) {
-      // reverse the parameter order so that the queue keeps the oldest items
-      return ((CacheEntry)b).lastAccessedCopy < ((CacheEntry)a).lastAccessedCopy;
-    }
-
-    // necessary because maxSize is private in base class
-    public Object myInsertWithOverflow(Object element) {
-      if (size() < myMaxSize) {
-        put(element);
-        return null;
-      } else if (size() > 0 && !lessThan(element, heap[1])) {
-        Object ret = heap[1];
-        heap[1] = element;
-        adjustTop();
-        return ret;
-      } else {
-        return element;
-      }
-    }
-  }
-
-
-  private void evictEntry(K key) {
-    CacheEntry<K,V> o = map.remove(key);
-    if (o == null) return;
-    stats.size.decrementAndGet();
-    stats.evictionCounter++;
-    if(evictionListener != null) evictionListener.evictedEntry(o.key,o.value);
-  }
-
-
-  public Map getLatestAccessedItems(long n) {
-    // we need to grab the lock since we are changing lastAccessedCopy
-    markAndSweepLock.lock();
-    Map<K,V> result = new LinkedHashMap<K,V>();
-    TreeSet<CacheEntry> tree = new TreeSet<CacheEntry>();
-    try {
-      for (Map.Entry<Object, CacheEntry> entry : map.entrySet()) {
-        CacheEntry ce = entry.getValue();
-        ce.lastAccessedCopy = ce.lastAccessed;
-        if (tree.size() < n) {
-          tree.add(ce);
-        } else {
-          if (ce.lastAccessedCopy > tree.last().lastAccessedCopy) {
-            tree.remove(tree.last());
-            tree.add(entry.getValue());
-          }
-        }
-      }
-    } finally {
-      markAndSweepLock.unlock();
-    }
-    for (CacheEntry<K,V> e : tree) {
-      result.put(e.key, e.value);
-    }
-    return result;
-  }
-
-  public int size() {
-    return stats.size.get();
-  }
-
-  public void clear() {
-    map.clear();
-  }
-
-  public Map<Object, CacheEntry> getMap() {
-    return map;
-  }
-
-  private static class CacheEntry<K,V> implements Comparable<CacheEntry> {
-    K key;
-    V value;
-    volatile long lastAccessed = 0;
-    long lastAccessedCopy = 0;
-
-
-    public CacheEntry(K key, V value, long lastAccessed) {
-      this.key = key;
-      this.value = value;
-      this.lastAccessed = lastAccessed;
-    }
-
-    public void setLastAccessed(long lastAccessed) {
-      this.lastAccessed = lastAccessed;
-    }
-
-    public int compareTo(CacheEntry that) {
-      if (this.lastAccessedCopy == that.lastAccessedCopy) return 0;
-      return this.lastAccessedCopy < that.lastAccessedCopy ? 1 : -1;
-    }
-
-    public int hashCode() {
-      return value.hashCode();
-    }
-
-    public boolean equals(Object obj) {
-      return value.equals(obj);
-    }
-
-    public String toString() {
-      return "key: " + key + " value: " + value + " lastAccessed:" + lastAccessed;
-    }
-  }
-
-
-  public void destroy() {
-    if(cleanupThread != null){
-      cleanupThread.stopThread();
-    }
-  }
-
-  public Stats getStats() {
-    return stats;
-  }
-
-
-  public static class Stats {
-    private final AtomicLong accessCounter = new AtomicLong(0),
-            putCounter = new AtomicLong(0),
-            nonLivePutCounter = new AtomicLong(0),
-            missCounter = new AtomicLong();
-    private final AtomicInteger size = new AtomicInteger();
-    private long evictionCounter = 0;
-
-    public long getCumulativeLookups() {
-      return (accessCounter.get() - putCounter.get() - nonLivePutCounter.get()) + missCounter.get();
-    }
-
-    public long getCumulativeHits() {
-      return accessCounter.get() - putCounter.get() - nonLivePutCounter.get();
-    }
-
-    public long getCumulativePuts() {
-      return putCounter.get();
-    }
-
-    public long getCumulativeEvictions() {
-      return evictionCounter;
-    }
-
-    public int getCurrentSize() {
-      return size.get();
-    }
-
-    public long getCumulativeNonLivePuts() {
-      return nonLivePutCounter.get();
-    }
-
-    public long getCumulativeMisses() {
-      return missCounter.get();
-    }
-  }
-
-  public static interface EvictionListener<K,V>{
-    public void evictedEntry(K key, V value);
-  }
-
-  private static class CleanupThread extends Thread {
-    private WeakReference<ConcurrentLRUCache> cache;
-
-    private boolean stop = false;
-
-    public CleanupThread(ConcurrentLRUCache c) {
-      cache = new WeakReference<ConcurrentLRUCache>(c);
-    }
-
-    public void run() {
-      while (true) {
-        synchronized (this) {
-          if (stop) break;
-          try {
-            this.wait();
-          } catch (InterruptedException e) {}
-        }
-        if (stop) break;
-        ConcurrentLRUCache c = cache.get();
-        if(c == null) break;
-        c.markAndSweep();
-      }
-    }
-
-    void wakeThread() {
-      synchronized(this){
-        this.notify();
-      }
-    }
-
-    void stopThread() {
-      synchronized(this){
-        stop=true;
-        this.notify();
-      }
-    }
-  }
-
-  protected void finalize() throws Throwable {
-    destroy();
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/ContentStream.java b/src/java/org/apache/solr/common/util/ContentStream.java
deleted file mode 100755
index 7249419..0000000
--- a/src/java/org/apache/solr/common/util/ContentStream.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Reader;
-
-/**
- * @version $Id$
- * @since solr 1.2
- */
-public interface ContentStream {
-  String getName();
-  String getSourceInfo();
-  String getContentType();
-  
-  /**
-   * @return the stream size or <code>null</code> if not known
-   */
-  Long getSize(); // size if we know it, otherwise null
-  
-  /**
-   * Get an open stream.  You are responsible for closing it.  Consider using 
-   * something like:
-   * <pre>
-   *   InputStream stream = stream.getStream();
-   *   try {
-   *     // use the stream...
-   *   }
-   *   finally {
-   *     IOUtils.closeQuietly(stream);
-   *   }
-   *  </pre>
-   *  
-   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
-   * is guaranteed to work.  The runtime behavior for additional calls is undefined.
-   */
-  InputStream getStream() throws IOException;
-
-  /**
-   * Get an open stream.  You are responsible for closing it.  Consider using 
-   * something like:
-   * <pre>
-   *   Reader reader = stream.getReader();
-   *   try {
-   *     // use the reader...
-   *   }
-   *   finally {
-   *     IOUtils.closeQuietly(reader);
-   *   }
-   *  </pre>
-   *  
-   * Only the first call to <code>getStream()</code> or <code>getReader()</code>
-   * is guaranteed to work.  The runtime behavior for additional calls is undefined.
-   */
-  Reader getReader() throws IOException;
-}
diff --git a/src/java/org/apache/solr/common/util/ContentStreamBase.java b/src/java/org/apache/solr/common/util/ContentStreamBase.java
deleted file mode 100755
index b0967b4..0000000
--- a/src/java/org/apache/solr/common/util/ContentStreamBase.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-import java.net.URL;
-import java.net.URLConnection;
-
-
-/**
- * Three concrete implementations for ContentStream - one for File/URL/String
- * 
- * @version $Id$
- * @since solr 1.2
- */
-public abstract class ContentStreamBase implements ContentStream
-{
-  public static final String DEFAULT_CHARSET = "utf-8";
-  
-  protected String name;
-  protected String sourceInfo;
-  protected String contentType;
-  protected Long size;
-  
-  //---------------------------------------------------------------------
-  //---------------------------------------------------------------------
-  
-  public static String getCharsetFromContentType( String contentType )
-  {
-    if( contentType != null ) {
-      int idx = contentType.toLowerCase().indexOf( "charset=" );
-      if( idx > 0 ) {
-        return contentType.substring( idx + "charset=".length() ).trim();
-      }
-    }
-    return null;
-  }
-  
-  //------------------------------------------------------------------------
-  //------------------------------------------------------------------------
-  
-  /**
-   * Construct a <code>ContentStream</code> from a <code>URL</code>
-   * 
-   * This uses a <code>URLConnection</code> to get the content stream
-   * @see  URLConnection
-   */
-  public static class URLStream extends ContentStreamBase
-  {
-    private final URL url;
-    final URLConnection conn;
-    
-    public URLStream( URL url ) throws IOException {
-      this.url = url; 
-      this.conn = this.url.openConnection();
-      
-      contentType = conn.getContentType();
-      name = url.toExternalForm();
-      size = new Long( conn.getContentLength() );
-      sourceInfo = "url";
-    }
-
-    public InputStream getStream() throws IOException {
-      return conn.getInputStream();
-    }
-  }
-  
-  /**
-   * Construct a <code>ContentStream</code> from a <code>File</code>
-   */
-  public static class FileStream extends ContentStreamBase
-  {
-    private final File file;
-    
-    public FileStream( File f ) throws IOException {
-      file = f; 
-      
-      contentType = null; // ??
-      name = file.getName();
-      size = file.length();
-      sourceInfo = file.toURI().toString();
-    }
-
-    public InputStream getStream() throws IOException {
-      return new FileInputStream( file );
-    }
-
-    /**
-     * If an charset is defined (by the contentType) use that, otherwise 
-     * use a file reader
-     */
-    @Override
-    public Reader getReader() throws IOException {
-      String charset = getCharsetFromContentType( contentType );
-      return charset == null 
-        ? new FileReader( file )
-        : new InputStreamReader( getStream(), charset );
-    }
-  }
-  
-
-  /**
-   * Construct a <code>ContentStream</code> from a <code>File</code>
-   */
-  public static class StringStream extends ContentStreamBase
-  {
-    private final String str;
-    
-    public StringStream( String str ) {
-      this.str = str; 
-      
-      contentType = null;
-      name = null;
-      size = new Long( str.length() );
-      sourceInfo = "string";
-    }
-
-    public InputStream getStream() throws IOException {
-      return new ByteArrayInputStream( str.getBytes(DEFAULT_CHARSET) );
-    }
-
-    /**
-     * If an charset is defined (by the contentType) use that, otherwise 
-     * use a StringReader
-     */
-    @Override
-    public Reader getReader() throws IOException {
-      String charset = getCharsetFromContentType( contentType );
-      return charset == null 
-        ? new StringReader( str )
-        : new InputStreamReader( getStream(), charset );
-    }
-  }
-
-  /**
-   * Base reader implementation.  If the contentType declares a 
-   * charset use it, otherwise use "utf-8".
-   */
-  public Reader getReader() throws IOException {
-    String charset = getCharsetFromContentType( getContentType() );
-    return charset == null 
-      ? new InputStreamReader( getStream(), DEFAULT_CHARSET )
-      : new InputStreamReader( getStream(), charset );
-  }
-
-  //------------------------------------------------------------------
-  // Getters / Setters for overrideable attributes
-  //------------------------------------------------------------------
-
-  public String getContentType() {
-    return contentType;
-  }
-
-  public void setContentType(String contentType) {
-    this.contentType = contentType;
-  }
-
-  public String getName() {
-    return name;
-  }
-
-  public void setName(String name) {
-    this.name = name;
-  }
-
-  public Long getSize() {
-    return size;
-  }
-
-  public void setSize(Long size) {
-    this.size = size;
-  }
-
-  public String getSourceInfo() {
-    return sourceInfo;
-  }
-
-  public void setSourceInfo(String sourceInfo) {
-    this.sourceInfo = sourceInfo;
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/DOMUtil.java b/src/java/org/apache/solr/common/util/DOMUtil.java
deleted file mode 100644
index 206f4b0..0000000
--- a/src/java/org/apache/solr/common/util/DOMUtil.java
+++ /dev/null
@@ -1,377 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.util.*;
-
-import org.apache.solr.common.SolrException;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
-/**
- * @version $Id$
- */
-public class DOMUtil {
-
-  public static Map<String,String> toMap(NamedNodeMap attrs) {
-    return toMapExcept(attrs);
-  }
-
-  public static Map<String,String> toMapExcept(NamedNodeMap attrs, String... exclusions) {
-    Map<String,String> args = new HashMap<String,String>();
-    outer: for (int j=0; j<attrs.getLength(); j++) {
-      Node attr = attrs.item(j);
-      String attrName = attr.getNodeName();
-      for (String ex : exclusions)
-        if (ex.equals(attrName)) continue outer;
-      String val = attr.getNodeValue();
-      args.put(attrName, val);
-    }
-    return args;
-  }
-
-  public static Node getChild(Node node, String name) {
-    if (!node.hasChildNodes()) return null;
-    NodeList lst = node.getChildNodes();
-    if (lst == null) return null;
-    for (int i=0; i<lst.getLength(); i++) {
-      Node child = lst.item(i);
-      if (name.equals(child.getNodeName())) return child;
-    }
-    return null;
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name) {
-    return getAttr(attrs,name,null);
-  }
-
-  public static String getAttr(Node nd, String name) {
-    return getAttr(nd.getAttributes(), name);
-  }
-
-  public static String getAttr(NamedNodeMap attrs, String name, String missing_err) {
-    Node attr = attrs==null? null : attrs.getNamedItem(name);
-    if (attr==null) {
-      if (missing_err==null) return null;
-      throw new RuntimeException(missing_err + ": missing mandatory attribute '" + name + "'");
-    }
-    String val = attr.getNodeValue();
-    return val;
-  }
-
-  public static String getAttr(Node node, String name, String missing_err) {
-    return getAttr(node.getAttributes(), name, missing_err);
-  }
-
-  //////////////////////////////////////////////////////////
-  // Routines to parse XML in the syntax of the Solr query
-  // response schema.
-  // Should these be moved to Config?  Should all of these things?
-  //////////////////////////////////////////////////////////
-  public static NamedList<Object> childNodesToNamedList(Node nd) {
-    return nodesToNamedList(nd.getChildNodes());
-  }
-
-  public static List childNodesToList(Node nd) {
-    return nodesToList(nd.getChildNodes());
-  }
-
-  public static NamedList<Object> nodesToNamedList(NodeList nlst) {
-    NamedList<Object> clst = new NamedList<Object>();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), clst, null);
-    }
-    return clst;
-  }
-
-  public static List nodesToList(NodeList nlst) {
-    List lst = new ArrayList();
-    for (int i=0; i<nlst.getLength(); i++) {
-      addToNamedList(nlst.item(i), null, lst);
-    }
-    return lst;
-  }
-
-
-  @SuppressWarnings("unchecked")
-  public static void addToNamedList(Node nd, NamedList nlst, List arr) {
-    // Nodes often include whitespace, etc... so just return if this
-    // is not an Element.
-    if (nd.getNodeType() != Node.ELEMENT_NODE) return;
-
-    String type = nd.getNodeName();
-
-    String name = null;
-    if (nd.hasAttributes()) {
-      NamedNodeMap attrs = nd.getAttributes();
-      Node nameNd = attrs.getNamedItem("name");
-      if (nameNd != null) name=nameNd.getNodeValue();
-    }
-
-    Object val=null;
-
-    if ("str".equals(type)) {
-      val = getText(nd);
-    } else if ("int".equals(type)) {
-      val = Integer.valueOf(getText(nd));
-    } else if ("long".equals(type)) {
-      val = Long.valueOf(getText(nd));
-    } else if ("float".equals(type)) {
-      val = Float.valueOf(getText(nd));
-    } else if ("double".equals(type)) {
-      val = Double.valueOf(getText(nd));
-    } else if ("bool".equals(type)) {
-      val = Boolean.valueOf(getText(nd));
-    } else if ("lst".equals(type)) {
-      val = childNodesToNamedList(nd);
-    } else if ("arr".equals(type)) {
-      val = childNodesToList(nd);
-    }
-
-    if (nlst != null) nlst.add(name,val);
-    if (arr != null) arr.add(val);
-  }
-
-  /**
-   * Drop in replacement for Node.getTextContent().
-   *
-   * <p>
-   * This method is provided to support the same functionality as
-   * Node.getTextContent() but in a way that is DOM Level 2 compatible.
-   * </p>
-   *
-   * @see <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-textContent">DOM Object Model Core</a>
-   */
-  public static String getText(Node nd) {
-
-    short type = nd.getNodeType();
-
-    // for most node types, we can defer to the recursive helper method,
-    // but when asked for the text of these types, we must return null
-    // (Not the empty string)
-    switch (type) {
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-      return null;
-    }
-
-    StringBuilder sb = new StringBuilder();
-    getText(nd, sb);
-    return sb.toString();
-  }
-
-  /** @see #getText(Node) */
-  private static void getText(Node nd, StringBuilder buf) {
-
-    short type = nd.getNodeType();
-
-    switch (type) {
-
-    case Node.ELEMENT_NODE: /* fall through */
-    case Node.ENTITY_NODE: /* fall through */
-    case Node.ENTITY_REFERENCE_NODE: /* fall through */
-    case Node.DOCUMENT_FRAGMENT_NODE:
-      NodeList childs = nd.getChildNodes();
-      for (int i = 0; i < childs.getLength(); i++) {
-        Node child = childs.item(i);
-        short childType = child.getNodeType();
-        if (childType != Node.COMMENT_NODE &&
-            childType != Node.PROCESSING_INSTRUCTION_NODE) {
-          getText(child, buf);
-        }
-      }
-      break;
-
-    case Node.ATTRIBUTE_NODE: /* fall through */
-      /* Putting Attribute nodes in this section does not exactly
-         match the definition of how textContent should behave
-         according to the DOM Level-3 Core documentation - which
-         specifies that the Attr's children should have their
-         textContent concated (Attr's can have a single child which
-         is either Text node or an EntityRefrence).  In practice,
-         DOM implementations do not seem to use child nodes of
-         Attributes, storing the "text" directly as the nodeValue.
-         Fortunately, the DOM Spec indicates that when Attr.nodeValue
-         is read, it should return the nodeValue from the child Node,
-         so this approach should work both for strict implementations,
-         and implementations actually encountered.
-      */
-    case Node.TEXT_NODE: /* fall through */
-    case Node.CDATA_SECTION_NODE: /* fall through */
-    case Node.COMMENT_NODE: /* fall through */
-    case Node.PROCESSING_INSTRUCTION_NODE: /* fall through */
-      buf.append(nd.getNodeValue());
-      break;
-
-    case Node.DOCUMENT_NODE: /* fall through */
-    case Node.DOCUMENT_TYPE_NODE: /* fall through */
-    case Node.NOTATION_NODE: /* fall through */
-    default:
-      /* :NOOP: */
-
-    }
-  }
-
-  /**
-   * Replaces ${system.property[:default value]} references in all attributes
-   * and text nodes of supplied node.  If the system property is not defined and no
-   * default value is provided, a runtime exception is thrown.
-   *
-   * @param node DOM node to walk for substitutions
-   */
-  public static void substituteSystemProperties(Node node) {
-    substituteProperties(node, null);
-  }
-
-  /**
-   * Replaces ${property[:default value]} references in all attributes
-   * and text nodes of supplied node.  If the property is not defined neither in the
-   * given Properties instance nor in System.getProperty and no
-   * default value is provided, a runtime exception is thrown.
-   *
-   * @param node DOM node to walk for substitutions
-   * @param properties the Properties instance from which a value can be looked up
-   */
-  public static void substituteProperties(Node node, Properties properties) {
-    // loop through child nodes
-    Node child;
-    Node next = node.getFirstChild();
-    while ((child = next) != null) {
-
-      // set next before we change anything
-      next = child.getNextSibling();
-
-      // handle child by node type
-      if (child.getNodeType() == Node.TEXT_NODE) {
-        child.setNodeValue(substituteProperty(child.getNodeValue(), properties));
-      } else if (child.getNodeType() == Node.ELEMENT_NODE) {
-        // handle child elements with recursive call
-        NamedNodeMap attributes = child.getAttributes();
-        for (int i = 0; i < attributes.getLength(); i++) {
-          Node attribute = attributes.item(i);
-          attribute.setNodeValue(substituteProperty(attribute.getNodeValue(), properties));
-        }
-        substituteProperties(child, properties);
-      }
-    }
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.replaceProperties:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  private static String substituteProperty(String value, Properties coreProperties) {
-    if (value == null || value.indexOf('$') == -1) {
-      return value;
-    }
-
-    List<String> fragments = new ArrayList<String>();
-    List<String> propertyRefs = new ArrayList<String>();
-    parsePropertyString(value, fragments, propertyRefs);
-
-    StringBuffer sb = new StringBuffer();
-    Iterator<String> i = fragments.iterator();
-    Iterator<String> j = propertyRefs.iterator();
-
-    while (i.hasNext()) {
-      String fragment = i.next();
-      if (fragment == null) {
-        String propertyName = j.next();
-        String defaultValue = null;
-        int colon_index = propertyName.indexOf(':');
-        if (colon_index > -1) {
-          defaultValue = propertyName.substring(colon_index + 1);
-          propertyName = propertyName.substring(0,colon_index);
-        }
-        if (coreProperties != null) {
-          fragment = coreProperties.getProperty(propertyName);
-        }
-        if (fragment == null) {
-          fragment = System.getProperty(propertyName, defaultValue);
-        }
-        if (fragment == null) {
-          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "No system property or default value specified for " + propertyName);
-        }
-      }
-      sb.append(fragment);
-    }
-    return sb.toString();
-  }
-
-  /*
-   * This method borrowed from Ant's PropertyHelper.parsePropertyStringDefault:
-   *   http://svn.apache.org/repos/asf/ant/core/trunk/src/main/org/apache/tools/ant/PropertyHelper.java
-   */
-  private static void parsePropertyString(String value, List<String> fragments, List<String> propertyRefs) {
-      int prev = 0;
-      int pos;
-      //search for the next instance of $ from the 'prev' position
-      while ((pos = value.indexOf("$", prev)) >= 0) {
-
-          //if there was any text before this, add it as a fragment
-          //TODO, this check could be modified to go if pos>prev;
-          //seems like this current version could stick empty strings
-          //into the list
-          if (pos > 0) {
-              fragments.add(value.substring(prev, pos));
-          }
-          //if we are at the end of the string, we tack on a $
-          //then move past it
-          if (pos == (value.length() - 1)) {
-              fragments.add("$");
-              prev = pos + 1;
-          } else if (value.charAt(pos + 1) != '{') {
-              //peek ahead to see if the next char is a property or not
-              //not a property: insert the char as a literal
-              /*
-              fragments.addElement(value.substring(pos + 1, pos + 2));
-              prev = pos + 2;
-              */
-              if (value.charAt(pos + 1) == '$') {
-                  //backwards compatibility two $ map to one mode
-                  fragments.add("$");
-                  prev = pos + 2;
-              } else {
-                  //new behaviour: $X maps to $X for all values of X!='$'
-                  fragments.add(value.substring(pos, pos + 2));
-                  prev = pos + 2;
-              }
-
-          } else {
-              //property found, extract its name or bail on a typo
-              int endName = value.indexOf('}', pos);
-              if (endName < 0) {
-                throw new RuntimeException("Syntax error in property: " + value);
-              }
-              String propertyName = value.substring(pos + 2, endName);
-              fragments.add(null);
-              propertyRefs.add(propertyName);
-              prev = endName + 1;
-          }
-      }
-      //no more $ signs found
-      //if there is any tail to the string, append it
-      if (prev < value.length()) {
-          fragments.add(value.substring(prev));
-      }
-  }
-
-}
diff --git a/src/java/org/apache/solr/common/util/DateUtil.java b/src/java/org/apache/solr/common/util/DateUtil.java
deleted file mode 100644
index eea0ac0..0000000
--- a/src/java/org/apache/solr/common/util/DateUtil.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package org.apache.solr.common.util;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.TimeZone;
-
-
-/**
- * This class has some code from HttpClient DateUtil.
- */
-public class DateUtil {
-  //start HttpClient
-  /**
-   * Date format pattern used to parse HTTP date headers in RFC 1123 format.
-   */
-  public static final String PATTERN_RFC1123 = "EEE, dd MMM yyyy HH:mm:ss zzz";
-
-  /**
-   * Date format pattern used to parse HTTP date headers in RFC 1036 format.
-   */
-  public static final String PATTERN_RFC1036 = "EEEE, dd-MMM-yy HH:mm:ss zzz";
-
-  /**
-   * Date format pattern used to parse HTTP date headers in ANSI C
-   * <code>asctime()</code> format.
-   */
-  public static final String PATTERN_ASCTIME = "EEE MMM d HH:mm:ss yyyy";
-  //These are included for back compat
-  private static final Collection<String> DEFAULT_HTTP_CLIENT_PATTERNS = Arrays.asList(
-          PATTERN_ASCTIME, PATTERN_RFC1036, PATTERN_RFC1123);
-
-  private static final Date DEFAULT_TWO_DIGIT_YEAR_START;
-
-  static {
-    Calendar calendar = Calendar.getInstance();
-    calendar.set(2000, Calendar.JANUARY, 1, 0, 0);
-    DEFAULT_TWO_DIGIT_YEAR_START = calendar.getTime();
-  }
-
-  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
-
-  //end HttpClient
-
-  //---------------------------------------------------------------------------------------
-
-  /**
-   * A suite of default date formats that can be parsed, and thus transformed to the Solr specific format
-   */
-  public static final Collection<String> DEFAULT_DATE_FORMATS = new ArrayList<String>();
-
-  static {
-    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd'T'HH:mm:ss'Z'");
-    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd'T'HH:mm:ss");
-    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd");
-    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd hh:mm:ss");
-    DEFAULT_DATE_FORMATS.add("yyyy-MM-dd HH:mm:ss");
-    DEFAULT_DATE_FORMATS.add("EEE MMM d hh:mm:ss z yyyy");
-    DEFAULT_DATE_FORMATS.addAll(DEFAULT_HTTP_CLIENT_PATTERNS);
-  }
-
-  /**
-   * Returns a formatter that can be use by the current thread if needed to
-   * convert Date objects to the Internal representation.
-   *
-   * @param d The input date to parse
-   * @return The parsed {@link java.util.Date}
-   * @throws java.text.ParseException If the input can't be parsed
-   * @throws org.apache.commons.httpclient.util.DateParseException
-   *                                  If the input can't be parsed
-   */
-  public static Date parseDate(String d) throws ParseException {
-    return parseDate(d, DEFAULT_DATE_FORMATS);
-  }
-
-  public static Date parseDate(String d, Collection<String> fmts) throws ParseException {
-    // 2007-04-26T08:05:04Z
-    if (d.endsWith("Z") && d.length() > 20) {
-      return getThreadLocalDateFormat().parse(d);
-    }
-    return parseDate(d, fmts, null);
-  }
-
-  /**
-   * Slightly modified from org.apache.commons.httpclient.util.DateUtil.parseDate
-   * <p/>
-   * Parses the date value using the given date formats.
-   *
-   * @param dateValue   the date value to parse
-   * @param dateFormats the date formats to use
-   * @param startDate   During parsing, two digit years will be placed in the range
-   *                    <code>startDate</code> to <code>startDate + 100 years</code>. This value may
-   *                    be <code>null</code>. When <code>null</code> is given as a parameter, year
-   *                    <code>2000</code> will be used.
-   * @return the parsed date
-   * @throws ParseException if none of the dataFormats could parse the dateValue
-   */
-  public static Date parseDate(
-          String dateValue,
-          Collection<String> dateFormats,
-          Date startDate
-  ) throws ParseException {
-
-    if (dateValue == null) {
-      throw new IllegalArgumentException("dateValue is null");
-    }
-    if (dateFormats == null) {
-      dateFormats = DEFAULT_HTTP_CLIENT_PATTERNS;
-    }
-    if (startDate == null) {
-      startDate = DEFAULT_TWO_DIGIT_YEAR_START;
-    }
-    // trim single quotes around date if present
-    // see issue #5279
-    if (dateValue.length() > 1
-            && dateValue.startsWith("'")
-            && dateValue.endsWith("'")
-            ) {
-      dateValue = dateValue.substring(1, dateValue.length() - 1);
-    }
-
-    SimpleDateFormat dateParser = null;
-    Iterator formatIter = dateFormats.iterator();
-
-    while (formatIter.hasNext()) {
-      String format = (String) formatIter.next();
-      if (dateParser == null) {
-        dateParser = new SimpleDateFormat(format, Locale.US);
-        dateParser.setTimeZone(GMT);
-        dateParser.set2DigitYearStart(startDate);
-      } else {
-        dateParser.applyPattern(format);
-      }
-      try {
-        return dateParser.parse(dateValue);
-      } catch (ParseException pe) {
-        // ignore this exception, we will try the next format
-      }
-    }
-
-    // we were unable to parse the date
-    throw new ParseException("Unable to parse the date " + dateValue, 0);
-  }
-
-
-  /**
-   * Returns a formatter that can be use by the current thread if needed to
-   * convert Date objects to the Internal representation.
-   *
-   * @return The {@link java.text.DateFormat} for the current thread
-   */
-  public static DateFormat getThreadLocalDateFormat() {
-    return fmtThreadLocal.get();
-  }
-
-  public static TimeZone UTC = TimeZone.getTimeZone("UTC");
-  private static ThreadLocalDateFormat fmtThreadLocal = new ThreadLocalDateFormat();
-
-  private static class ThreadLocalDateFormat extends ThreadLocal<DateFormat> {
-    DateFormat proto;
-
-    public ThreadLocalDateFormat() {
-      super();
-      //2007-04-26T08:05:04Z
-      SimpleDateFormat tmp = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
-      tmp.setTimeZone(UTC);
-      proto = tmp;
-    }
-
-    @Override
-    protected DateFormat initialValue() {
-      return (DateFormat) proto.clone();
-    }
-  }
-
-
-}
\ No newline at end of file
diff --git a/src/java/org/apache/solr/common/util/FastInputStream.java b/src/java/org/apache/solr/common/util/FastInputStream.java
deleted file mode 100755
index 3abddc5..0000000
--- a/src/java/org/apache/solr/common/util/FastInputStream.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.*;
-
-/** Single threaded buffered InputStream
- *  Internal Solr use only, subject to change.
- */
-public class FastInputStream extends InputStream implements DataInput {
-  private final InputStream in;
-  private final byte[] buf;
-  private int pos;
-  private int end;
-
-  public FastInputStream(InputStream in) {
-  // use default BUFSIZE of BufferedOutputStream so if we wrap that
-  // it won't cause double buffering.
-    this(in, new byte[8192], 0, 0);
-  }
-
-  public FastInputStream(InputStream in, byte[] tempBuffer, int start, int end) {
-    this.in = in;
-    this.buf = tempBuffer;
-    this.pos = start;
-    this.end = end;
-  }
-
-
-  public static FastInputStream wrap(InputStream in) {
-    return (in instanceof FastInputStream) ? (FastInputStream)in : new FastInputStream(in);
-  }
-
-  @Override
-  public int read() throws IOException {
-    if (pos >= end) {
-      refill();
-      if (pos >= end) return -1;
-    }
-    return buf[pos++] & 0xff;     
-  }
-
-  public int readUnsignedByte() throws IOException {
-    if (pos >= end) {
-      refill();
-      if (pos >= end) throw new EOFException();
-    }
-    return buf[pos++] & 0xff;
-  }
-
-  public void refill() throws IOException {
-    // this will set end to -1 at EOF
-    end = in.read(buf, 0, buf.length);
-    pos = 0;
-  }
-
-  @Override
-  public int available() throws IOException {
-    return end - pos;
-  }
-
-  @Override
-  public int read(byte b[], int off, int len) throws IOException {
-    int r=0;  // number of bytes read
-    // first read from our buffer;
-    if (end-pos > 0) {
-      r = Math.min(end-pos, len);
-      System.arraycopy(buf, pos, b, off, r);      
-      pos += r;
-    }
-
-    if (r == len) return r;
-
-    // amount left to read is >= buffer size
-    if (len-r >= buf.length) {
-      int ret = in.read(b, off+r, len-r);
-      if (ret==-1) return r==0 ? -1 : r;
-      r += ret;
-      return r;
-    }
-
-    refill();
-
-    // first read from our buffer;
-    if (end-pos > 0) {
-      int toRead = Math.min(end-pos, len-r);
-      System.arraycopy(buf, pos, b, off+r, toRead);
-      pos += toRead;
-      r += toRead;
-      return r;
-    }
-    
-    return -1;
-  }
-
-  @Override
-  public void close() throws IOException {
-    in.close();
-  }
-
-  public void readFully(byte b[]) throws IOException {
-    readFully(b, 0, b.length);
-  }
-
-  public void readFully(byte b[], int off, int len) throws IOException {
-    while (len>0) {
-      int ret = read(b, off, len);
-      if (ret==-1) {
-        throw new EOFException();
-      }
-      off += ret;
-      len -= ret;
-    }
-  }
-
-  public int skipBytes(int n) throws IOException {
-    if (end-pos >= n) {
-      pos += n;
-      return n;
-    }
-
-    if (end-pos<0) return -1;
-    
-    int r = end-pos;
-    pos = end;
-
-    while (r < n) {
-      refill();
-      if (end-pos <= 0) return r;
-      int toRead = Math.min(end-pos, n-r);
-      r += toRead;
-      pos += toRead;
-    }
-
-    return r;
-  }
-
-  public boolean readBoolean() throws IOException {
-    return readByte()==1;
-  }
-
-  public byte readByte() throws IOException {
-    if (pos >= end) {
-      refill();
-      if (pos >= end) throw new EOFException();
-    }
-    return buf[pos++];
-  }
-
-
-  public short readShort() throws IOException {
-    return (short)((readUnsignedByte() << 8) | readUnsignedByte());
-  }
-
-  public int readUnsignedShort() throws IOException {
-    return (readUnsignedByte() << 8) | readUnsignedByte();
-  }
-
-  public char readChar() throws IOException {
-    return (char)((readUnsignedByte() << 8) | readUnsignedByte());
-  }
-
-  public int readInt() throws IOException {
-    return  ((readUnsignedByte() << 24)
-            |(readUnsignedByte() << 16)
-            |(readUnsignedByte() << 8)
-            | readUnsignedByte());
-  }
-
-  public long readLong() throws IOException {
-    return  (((long)readUnsignedByte()) << 56)
-            | (((long)readUnsignedByte()) << 48)
-            | (((long)readUnsignedByte()) << 40)
-            | (((long)readUnsignedByte()) << 32)
-            | (((long)readUnsignedByte()) << 24)
-            | (readUnsignedByte() << 16)
-            | (readUnsignedByte() << 8)
-            | (readUnsignedByte());
-  }
-
-  public float readFloat() throws IOException {
-    return Float.intBitsToFloat(readInt());    
-  }
-
-  public double readDouble() throws IOException {
-    return Double.longBitsToDouble(readLong());    
-  }
-
-  public String readLine() throws IOException {
-    return new DataInputStream(this).readLine();
-  }
-
-  public String readUTF() throws IOException {
-    return new DataInputStream(this).readUTF();
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/FastOutputStream.java b/src/java/org/apache/solr/common/util/FastOutputStream.java
deleted file mode 100755
index 3f6275c..0000000
--- a/src/java/org/apache/solr/common/util/FastOutputStream.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.*;
-
-/** Single threaded buffered OutputStream
- *  Internal Solr use only, subject to change.
- */
-public class FastOutputStream extends OutputStream implements DataOutput {
-  private final OutputStream out;
-  private final byte[] buf;
-  private long written;  // how many bytes written
-  private int pos;
-
-  public FastOutputStream(OutputStream w) {
-  // use default BUFSIZE of BufferedOutputStream so if we wrap that
-  // it won't cause double buffering.
-    this(w, new byte[8192], 0);
-  }
-
-  public FastOutputStream(OutputStream sink, byte[] tempBuffer, int start) {
-    this.out = sink;
-    this.buf = tempBuffer;
-    this.pos = start;
-  }
-
-
-  public static FastOutputStream wrap(OutputStream sink) {
-   return (sink instanceof FastOutputStream) ? (FastOutputStream)sink : new FastOutputStream(sink);
-  }
-
-  @Override
-  public void write(int b) throws IOException {
-    write((byte)b);
-  }
-
-  public void write(byte b[]) throws IOException {
-  }
-
-  public void write(byte b) throws IOException {
-    if (pos >= buf.length) {
-      out.write(buf);
-      written += pos;
-      pos=0;
-    }
-    buf[pos++] = b;
-  }
-
-  @Override
-  public void write(byte arr[], int off, int len) throws IOException {
-    int space = buf.length - pos;
-    if (len < space) {
-      System.arraycopy(arr, off, buf, pos, len);
-      pos += len;
-    } else if (len<buf.length) {
-      // if the data to write is small enough, buffer it.
-      System.arraycopy(arr, off, buf, pos, space);
-      out.write(buf);
-      written += pos;
-      pos = len-space;
-      System.arraycopy(arr, off+space, buf, 0, pos);
-    } else {
-      out.write(buf,0,pos);  // flush
-      written += pos;
-      pos=0;
-      // don't buffer, just write to sink
-      out.write(arr, off, len);
-      written += len;            
-    }
-  }
-
-  /** reserve at least len bytes at the end of the buffer.
-   * Invalid if len > buffer.length
-   * @param len
-   */
-  public void reserve(int len) throws IOException {
-    if (len > (buf.length - pos))
-      flushBuffer();
-  }
-
-  ////////////////// DataOutput methods ///////////////////
-  public void writeBoolean(boolean v) throws IOException {
-    write(v ? 1:0);
-  }
-
-  public void writeByte(int v) throws IOException {
-    write((byte)v);
-  }
-
-  public void writeShort(int v) throws IOException {
-    write((byte)(v >>> 8));
-    write((byte)v);
-  }
-
-  public void writeChar(int v) throws IOException {
-    writeShort(v);
-  }
-
-  public void writeInt(int v) throws IOException {
-    reserve(4);
-    buf[pos] = (byte)(v>>>24);
-    buf[pos+1] = (byte)(v>>>16);
-    buf[pos+2] = (byte)(v>>>8);
-    buf[pos+3] = (byte)(v);
-    pos+=4;
-  }
-
-  public void writeLong(long v) throws IOException {
-    reserve(8);
-    buf[pos] = (byte)(v>>>56);
-    buf[pos+1] = (byte)(v>>>48);
-    buf[pos+2] = (byte)(v>>>40);
-    buf[pos+3] = (byte)(v>>>32);
-    buf[pos+4] = (byte)(v>>>24);
-    buf[pos+5] = (byte)(v>>>16);
-    buf[pos+6] = (byte)(v>>>8);
-    buf[pos+7] = (byte)(v);
-    pos+=8;
-  }
-
-  public void writeFloat(float v) throws IOException {
-    writeInt(Float.floatToRawIntBits(v));
-  }
-
-  public void writeDouble(double v) throws IOException {
-    writeLong(Double.doubleToRawLongBits(v));
-  }
-
-  public void writeBytes(String s) throws IOException {
-    // non-optimized version, but this shouldn't be used anyway
-    for (int i=0; i<s.length(); i++)
-      write((byte)s.charAt(i));
-  }
-
-  public void writeChars(String s) throws IOException {
-    // non-optimized version
-    for (int i=0; i<s.length(); i++)
-      writeChar(s.charAt(i)); 
-  }
-
-  public void writeUTF(String s) throws IOException {
-    // non-optimized version, but this shouldn't be used anyway
-    DataOutputStream daos = new DataOutputStream(this);
-    daos.writeUTF(s);
-  }
-
-
-  @Override
-  public void flush() throws IOException {
-    flushBuffer();
-    out.flush();
-  }
-
-  @Override
-  public void close() throws IOException {
-    flushBuffer();
-    out.close();
-  }
-
-  /** Only flushes the buffer of the FastOutputStream, not that of the
-   * underlying stream.
-   */
-  public void flushBuffer() throws IOException {
-    out.write(buf, 0, pos);
-    written += pos;
-    pos=0;
-  }
-
-  public long size() {
-    return written + pos;
-  }
-}
\ No newline at end of file
diff --git a/src/java/org/apache/solr/common/util/FastWriter.java b/src/java/org/apache/solr/common/util/FastWriter.java
deleted file mode 100755
index 45f06e4..0000000
--- a/src/java/org/apache/solr/common/util/FastWriter.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.Writer;
-import java.io.IOException;
-
-/** Single threaded BufferedWriter
- *  Internal Solr use only, subject to change.
- */
-public class FastWriter extends Writer {
-  // use default BUFSIZE of BufferedWriter so if we wrap that
-  // it won't cause double buffering.
-  private static final int BUFSIZE = 8192;
-  private final Writer sink;
-  private final char[] buf;
-  private int pos;
-
-  public FastWriter(Writer w) {
-    this(w, new char[BUFSIZE], 0);
-  }
-
-  public FastWriter(Writer sink, char[] tempBuffer, int start) {
-    this.sink = sink;
-    this.buf = tempBuffer;
-    this.pos = start;
-  }
-
-  public static FastWriter wrap(Writer sink) {
-    return (sink instanceof FastWriter) ? (FastWriter)sink : new FastWriter(sink);
-  }
-
-  @Override
-  public void write(int c) throws IOException {
-    write((char)c); 
-  }
-
-  public void write(char c) throws IOException {
-    if (pos >= buf.length) {
-      sink.write(buf,0,pos);
-      pos=0;
-    }
-    buf[pos++] = (char)c;
-  }
-
-  @Override
-  public FastWriter append(char c) throws IOException {
-    if (pos >= buf.length) {
-      sink.write(buf,0,pos);
-      pos=0;
-    }
-    buf[pos++] = (char)c;
-    return this;
-  }
-
-  @Override
-  public void write(char cbuf[], int off, int len) throws IOException {
-    int space = buf.length - pos;
-    if (len < space) {
-      System.arraycopy(cbuf, off, buf, pos, len);
-      pos += len;
-    } else if (len<BUFSIZE) {
-      // if the data to write is small enough, buffer it.
-      System.arraycopy(cbuf, off, buf, pos, space);
-      sink.write(buf, 0, buf.length);
-      pos = len-space;
-      System.arraycopy(cbuf, off+space, buf, 0, pos);
-    } else {
-      sink.write(buf,0,pos);  // flush
-      pos=0;
-      // don't buffer, just write to sink
-      sink.write(cbuf, off, len);
-    }
-  }
-
-  @Override
-  public void write(String str, int off, int len) throws IOException {
-    int space = buf.length - pos;
-    if (len < space) {
-      str.getChars(off, off+len, buf, pos);
-      pos += len;
-    } else if (len<BUFSIZE) {
-      // if the data to write is small enough, buffer it.
-      str.getChars(off, off+space, buf, pos);
-      sink.write(buf, 0, buf.length);
-      str.getChars(off+space, off+len, buf, 0);
-      pos = len-space;
-    } else {
-      sink.write(buf,0,pos);  // flush
-      pos=0;
-      // don't buffer, just write to sink
-      sink.write(str, off, len);
-    }
-  }
-
-  @Override
-  public void flush() throws IOException {
-    sink.write(buf,0,pos);
-    pos=0;
-    sink.flush();
-  }
-
-  @Override
-  public void close() throws IOException {
-    flush();
-    sink.close();
-  }
-
-  public void flushBuffer() throws IOException {
-    sink.write(buf, 0, pos);
-    pos=0;
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/IteratorChain.java b/src/java/org/apache/solr/common/util/IteratorChain.java
deleted file mode 100644
index a477180..0000000
--- a/src/java/org/apache/solr/common/util/IteratorChain.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-/** Chain several Iterators, so that this iterates
- *  over all of them in sequence.
- */
-
-public class IteratorChain<E> implements Iterator<E> {
-
-  private final List<Iterator<E>> iterators = new ArrayList<Iterator<E>>();
-  private Iterator<Iterator<E>> itit;
-  private Iterator<E> current;
- 
-  public void addIterator(Iterator<E> it) {
-    if(itit!=null) throw new RuntimeException("all Iterators must be added before calling hasNext()");
-    iterators.add(it);
-  }
-  
-  public boolean hasNext() {
-    if(itit==null) itit = iterators.iterator();
-    return recursiveHasNext();
-  }
-  
-  /** test if current iterator hasNext(), and if not try the next
-   *  one in sequence, recursively
-   */
-  private boolean recursiveHasNext() {
-    // return false if we have no more iterators
-    if(current==null) {
-      if(itit.hasNext()) {
-        current=itit.next();
-      } else {
-        return false;
-      }
-    }
-    
-    boolean result = current.hasNext();
-    if(!result) {
-      current = null;
-      result = recursiveHasNext();
-    }
-    
-    return result;
-  }
-
-  /** hasNext() must ALWAYS be called before calling this
-   *  otherwise it's a bit hard to keep track of what's happening
-   */
-  public E next() {
-    if(current==null) { 
-      throw new RuntimeException("For an IteratorChain, hasNext() MUST be called before calling next()");
-    }
-    return current.next();
-  }
-
-  public void remove() {
-    // we just need this class 
-    // to iterate in readonly mode
-    throw new UnsupportedOperationException();
-  }
-  
-}
diff --git a/src/java/org/apache/solr/common/util/NamedList.java b/src/java/org/apache/solr/common/util/NamedList.java
deleted file mode 100644
index 4439f8c..0000000
--- a/src/java/org/apache/solr/common/util/NamedList.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.util.*;
-import java.io.Serializable;
-
-
-
-/**
- * A simple container class for modeling an ordered list of name/value pairs.
- *
- * <p>
- * Unlike Maps:
- * </p>
- * <ul>
- *  <li>Names may be repeated</li>
- *  <li>Order of elements is maintained</li>
- *  <li>Elements may be accessed by numeric index</li>
- *  <li>Names and Values can both be null</li>
- * </ul>
- *
- * <p>
- * A NamedList provides fast access by element number, but not by name.
- * </p>
- * <p>
- * When a NamedList is serialized, order is considered more important than access
- * by key, so ResponseWriters that output to a format such as JSON will normally
- * choose a data structure that allows order to be easily preserved in various
- * clients (i.e. not a straight map).
- * If access by key is more important, see {@link SimpleOrderedMap},
- * or simply use a regular {@link Map}
- * </p>
- *
- * @version $Id$
- */
-public class NamedList<T> implements Cloneable, Serializable, Iterable<Map.Entry<String,T>> {
-  protected final List nvPairs;
-
-  /** Creates an empty instance */
-  public NamedList() {
-    nvPairs = new ArrayList();
-  }
-
-  /**
-   * Creates an instance backed by an explicitly specified list of
-   * pairwise names/values.
-   *
-   * @param nameValuePairs underlying List which should be used to implement a NamedList; modifying this List will affect the NamedList.
-   */
-  public NamedList(List nameValuePairs) {
-    nvPairs=nameValuePairs;
-  }
-
-  /** The total number of name/value pairs */
-  public int size() {
-    return nvPairs.size() >> 1;
-  }
-
-  /**
-   * The name of the pair at the specified List index
-   *
-   * @return null if no name exists
-   */
-  public String getName(int idx) {
-    return (String)nvPairs.get(idx << 1);
-  }
-
-  /**
-   * The value of the pair at the specified List index
-   *
-   * @return may be null
-   */
-  @SuppressWarnings("unchecked")
-  public T getVal(int idx) {
-    return (T)nvPairs.get((idx << 1) + 1);
-  }
-  
-  /**
-   * Adds a name/value pair to the end of the list.
-   */
-  public void add(String name, T val) {
-    nvPairs.add(name);
-    nvPairs.add(val);
-  }
-
-  /**
-   * Modifies the name of the pair at the specified index.
-   */
-  public void setName(int idx, String name) {
-    nvPairs.set(idx<<1, name);
-  }
-
-  /**
-   * Modifies the value of the pair at the specified index.
-   * @return the value that used to be at index
-   */
-  public T setVal(int idx, T val) {
-    int index = (idx<<1)+1;
-    T old = (T)nvPairs.get( index );
-    nvPairs.set(index, val);
-    return old;
-  }
-
-  /**
-   * Removes the name/value pair at the specified index.
-   * @return the value at the index removed
-   */
-  public T remove(int idx) {
-    int index = (idx<<1);
-    nvPairs.remove(index);
-    return (T)nvPairs.remove(index);  // same index, as things shifted in previous remove
-  }
-
-  /**
-   * Scans the list sequentially beginning at the specified index and
-   * returns the index of the first pair with the specified name.
-   *
-   * @param name name to look for, may be null
-   * @param start index to begin searching from
-   * @return The index of the first matching pair, -1 if no match
-   */
-  public int indexOf(String name, int start) {
-    int sz = size();
-    for (int i=start; i<sz; i++) {
-      String n = getName(i);
-      if (name==null) {
-        if (n==null) return i; // matched null
-      } else if (name.equals(n)) {
-        return i;
-      }
-    }
-    return -1;
-  }
-
-  /**
-   * Gets the value for the first instance of the specified name
-   * found.
-   * 
-   * @return null if not found or if the value stored was null.
-   * @see #indexOf
-   * @see #get(String,int)
-   */
-  public T get(String name) {
-    return get(name,0);
-  }
-
-  /**
-   * Gets the value for the first instance of the specified name
-   * found starting at the specified index.
-   * 
-   * @return null if not found or if the value stored was null.
-   * @see #indexOf
-   */
-  public T get(String name, int start) {
-    int sz = size();
-    for (int i=start; i<sz; i++) {
-      String n = getName(i);
-      if (name==null) {
-        if (n==null) return getVal(i);
-      } else if (name.equals(n)) {
-        return getVal(i);
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Gets the values for the the specified name
-   * @param name Name
-   * @return List of values
-   */
-  public List<T> getAll(String name) {
-    List<T> result = new ArrayList<T>();
-    int sz = size();
-    for (int i = 0; i < sz; i++) {
-      String n = getName(i);
-      if (name==n || (name!=null && name.equals(n))) {
-        result.add(getVal(i));
-      }
-    }
-    return result;
-  }
-
-  public String toString() {
-    StringBuffer sb = new StringBuffer();
-    sb.append('{');
-    int sz = size();
-    for (int i=0; i<sz; i++) {
-      if (i != 0) sb.append(',');
-      sb.append(getName(i));
-      sb.append('=');
-      sb.append(getVal(i));
-    }
-    sb.append('}');
-
-    return sb.toString();
-  }
-
-  /**
-   * Iterates over the Map and sequentially adds it's key/value pairs
-   */
-  public boolean addAll(Map<String,T> args) {
-    for( Map.Entry<String, T> entry : args.entrySet() ) {
-      add( entry.getKey(), entry.getValue() );
-    }
-    return args.size()>0;
-  }
-
-  /** Appends the elements of the given NamedList to this one. */
-  public boolean addAll(NamedList<T> nl) {
-    nvPairs.addAll(nl.nvPairs);
-    return nl.size()>0;
-  }
-
-  /**
-   * Makes a <i>shallow copy</i> of the named list.
-   */
-  public NamedList<T> clone() {
-    ArrayList newList = new ArrayList(nvPairs.size());
-    newList.addAll(nvPairs);
-    return new NamedList<T>(newList);
-  }
-
-
-  //----------------------------------------------------------------------------
-  // Iterable interface
-  //----------------------------------------------------------------------------
-  
-  /**
-   * Support the Iterable interface
-   */
-  public Iterator<Map.Entry<String,T>> iterator() {
-    
-    final NamedList list = this;
-    
-    Iterator<Map.Entry<String,T>> iter = new Iterator<Map.Entry<String,T>>() {
-      
-      int idx = 0;
-      
-      public boolean hasNext() {
-        return idx < list.size();
-      }
-
-      public Map.Entry<String,T> next() {
-        final int index = idx++;
-        Map.Entry<String,T> nv = new Map.Entry<String,T>() {
-          public String getKey() {
-            return list.getName( index );
-          }
-
-          @SuppressWarnings("unchecked")
-          public T getValue() {
-            return (T)list.getVal( index );
-          }
-          
-          public String toString()
-          {
-        	  return getKey()+"="+getValue();
-          }
-
-    		  public T setValue(T value) {
-    		    return (T) list.setVal(index, value);
-    		  }
-        };
-        return nv;
-      }
-
-      public void remove() {
-        throw new UnsupportedOperationException();
-      }
-    };
-    return iter;
-  }
-
-  public T remove(String name) {
-    int idx = indexOf(name, 0);
-    if(idx != -1) return remove(idx);
-    return null;
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/NamedListCodec.java b/src/java/org/apache/solr/common/util/NamedListCodec.java
deleted file mode 100755
index df3f6e0..0000000
--- a/src/java/org/apache/solr/common/util/NamedListCodec.java
+++ /dev/null
@@ -1,652 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.solr.common.util;
-
-import org.apache.solr.common.SolrDocument;
-import org.apache.solr.common.SolrDocumentList;
-
-import java.io.*;
-import java.util.*;
-
-/**
- * The class is designed to optimaly serialize/deserialize a NamedList. As we know there are only
- * a limited type of items this class can do it with very minimal amount of payload and code. There are
- * 15 known types and if there is an object in the object tree which does not fall into these types, It must be
- * converted to one of these. Implement an ObjectResolver and pass it over
- * It is expected that this class is used on both end of the pipes.
- * The class has one read method and one write method for each of the datatypes
- *
- */
-public class NamedListCodec {
-
-  public static final byte
-          NULL = 0,
-          BOOL_TRUE = 1,
-          BOOL_FALSE = 2,
-          BYTE = 3,
-          SHORT = 4,
-          DOUBLE = 5,
-          INT = 6,
-          LONG = 7,
-          FLOAT = 8,
-          DATE = 9,
-          MAP = 10,
-          SOLRDOC = 11,
-          SOLRDOCLST = 12,
-          BYTEARR = 13,
-          ITERATOR = 14,
-          /** this is a special tag signals an end. No value is associated with it*/
-          END = 15,
-
-          // types that combine tag + length (or other info) in a single byte
-          TAG_AND_LEN=(byte)(1 << 5),
-          STR =       (byte)(1 << 5),
-          SINT =      (byte)(2 << 5),
-          SLONG =     (byte)(3 << 5),
-          ARR =       (byte)(4 << 5), //
-          ORDERED_MAP=(byte)(5 << 5), // SimpleOrderedMap (a NamedList subclass, and more common)
-          NAMED_LST = (byte)(6 << 5), // NamedList
-          EXTERN_STRING = (byte)(7 << 5);
-
-
-  private byte VERSION = 1;
-  private ObjectResolver resolver;
-  private FastOutputStream daos;
-
-  public NamedListCodec() { }
-
-  public NamedListCodec(ObjectResolver resolver) {
-    this.resolver = resolver;
-  }
-  
-  public void marshal(NamedList nl, OutputStream os) throws IOException {
-    daos = FastOutputStream.wrap(os);
-    try {
-      daos.writeByte(VERSION);
-      writeNamedList(nl);
-    } finally {
-      daos.flushBuffer();      
-    }
-  }
-
-  public NamedList unmarshal(InputStream is) throws IOException {
-    FastInputStream dis = FastInputStream.wrap(is);
-    byte version = dis.readByte();
-    return (NamedList)readVal(dis);
-  }
-
-
-  public SimpleOrderedMap readOrderedMap(FastInputStream dis) throws IOException {
-    int sz = readSize(dis);
-    SimpleOrderedMap nl = new SimpleOrderedMap();
-    for (int i = 0; i < sz; i++) {
-      String name = (String)readVal(dis);
-      Object val = readVal(dis);
-      nl.add(name, val);
-    }
-    return nl;
-  }
-
-  public NamedList readNamedList(FastInputStream dis) throws IOException {
-    int sz = readSize(dis);
-    NamedList nl = new NamedList();
-    for (int i = 0; i < sz; i++) {
-      String name = (String)readVal(dis);
-      Object val = readVal(dis);
-      nl.add(name, val);
-    }
-    return nl;
-  }
-
-  public void writeNamedList(NamedList nl) throws IOException {
-    writeTag(nl instanceof SimpleOrderedMap ? ORDERED_MAP : NAMED_LST, nl.size());
-    for (int i = 0; i < nl.size(); i++) {
-      String name = nl.getName(i);
-      writeExternString(name);
-      Object val = nl.getVal(i);
-      writeVal(val);
-    }
-  }
-
-  public void writeVal(Object val) throws IOException {
-    if (writeKnownType(val)) {
-      return;
-    } else {
-      Object tmpVal = val;
-      if(resolver !=null) {
-        tmpVal = resolver.resolve(val, this);
-        if (tmpVal == null) return; // null means the resolver took care of it fully
-        if(writeKnownType(tmpVal)) return;
-      }
-    }
-
-    writeVal(val.getClass().getName() + ':' + val.toString());
-  }
-  private static final Object END_OBJ = new Object();
-
-  byte tagByte;
-  public Object readVal(FastInputStream dis) throws IOException {
-    tagByte = dis.readByte();
-
-    // if ((tagByte & 0xe0) == 0) {
-    // if top 3 bits are clear, this is a normal tag
-
-    // OK, try type + size in single byte
-    switch(tagByte>>>5) {
-      case STR >>> 5         : return readStr(dis);
-      case SINT >>>5         : return readSmallInt(dis);
-      case SLONG >>>5        : return readSmallLong(dis);
-      case ARR >>> 5         : return readArray(dis);
-      case ORDERED_MAP >>> 5 : return readOrderedMap(dis);
-      case NAMED_LST >>> 5   : return readNamedList(dis);
-      case EXTERN_STRING >>> 5   : return readExternString(dis);
-    }
-
-    switch(tagByte){
-      case NULL : return null;
-      case DATE : return new Date(dis.readLong());
-      case INT : return dis.readInt();
-      case BOOL_TRUE : return Boolean.TRUE;
-      case BOOL_FALSE : return Boolean.FALSE;
-      case FLOAT : return dis.readFloat();
-      case DOUBLE : return dis.readDouble();
-      case LONG : return dis.readLong();
-      case BYTE : return dis.readByte();
-      case SHORT : return dis.readShort();
-      case MAP : return readMap(dis);
-      case SOLRDOC : return readSolrDocument(dis);
-      case SOLRDOCLST : return readSolrDocumentList(dis);
-      case BYTEARR : return readByteArray(dis);
-      case ITERATOR : return readIterator(dis);
-      case END : return END_OBJ;
-    }
-
-    throw new RuntimeException("Unknown type " + tagByte);
-  }
-
-  public boolean writeKnownType(Object val) throws IOException {
-    if (writePrimitive(val)) return true;
-    if (val instanceof NamedList) {
-      writeNamedList((NamedList) val);
-      return true;
-    }
-    if (val instanceof SolrDocumentList) { // SolrDocumentList is a List, so must come before List check
-      writeSolrDocumentList((SolrDocumentList) val);
-      return true;
-    }
-    if (val instanceof List) {
-      writeArray((List) val);
-      return true;
-    }
-    if (val instanceof Object[]) {
-      writeArray((Object[]) val);
-      return true;
-    }
-    if (val instanceof SolrDocument) {
-      //this needs special treatment to know which fields are to be written
-      if(resolver == null){
-        writeSolrDocument((SolrDocument) val);
-      }else {
-        Object retVal = resolver.resolve(val, this);
-        if(retVal != null) {
-          if (retVal instanceof SolrDocument) {
-            writeSolrDocument((SolrDocument) retVal);
-          } else {
-            writeVal(retVal);
-          }
-        }
-      }
-      return true;
-    }
-    if (val instanceof Map) {
-      writeMap((Map) val);
-      return true;
-    }
-    if (val instanceof Iterator) {
-      writeIterator((Iterator) val);
-      return true;
-    }
-    if (val instanceof Iterable) {
-      writeIterator(((Iterable)val).iterator());
-      return true;
-    }
-    return false;
-  }
-
-  public void writeTag(byte tag) throws IOException {
-    daos.writeByte(tag);
-  }
-  
-  public void writeTag(byte tag, int size) throws IOException {
-    if ((tag & 0xe0) != 0) {
-      if (size < 0x1f) {
-        daos.writeByte(tag | size);
-      } else {
-        daos.writeByte(tag | 0x1f);
-        writeVInt(size-0x1f, daos);
-      }
-    } else {
-      daos.writeByte(tag);
-      writeVInt(size, daos);       
-    }
-  }
-
-  public void writeByteArray(byte[] arr, int offset, int len) throws IOException {
-    writeTag(BYTEARR, len);
-    daos.write(arr, offset, len);
-  }
-
-  public byte[] readByteArray(FastInputStream dis) throws IOException {
-    byte[] arr = new byte[readVInt(dis)];
-    dis.readFully(arr);
-    return arr;
-  }
-
-  public void writeSolrDocument(SolrDocument doc) throws IOException {
-    writeSolrDocument(doc, null);
-  }
-  public void writeSolrDocument(SolrDocument doc, Set<String> fields) throws IOException {
-    int count = 0;
-    if (fields == null) {
-      count = doc.getFieldNames().size();
-    } else {
-      for (Map.Entry<String, Object> entry : doc) {
-        if (fields.contains(entry.getKey())) count++;
-      }
-    }
-    writeTag(SOLRDOC);
-    writeTag(ORDERED_MAP, count);
-    for (Map.Entry<String, Object> entry : doc) {
-      if (fields == null || fields.contains(entry.getKey())) {
-        String name = entry.getKey();
-        writeExternString(name);
-        Object val = entry.getValue();
-        writeVal(val);
-      }
-    }
-  }
-
-   public SolrDocument readSolrDocument(FastInputStream dis) throws IOException {
-    NamedList nl = (NamedList) readVal(dis);
-    SolrDocument doc = new SolrDocument();
-    for (int i = 0; i < nl.size(); i++) {
-      String name = nl.getName(i);
-      Object val = nl.getVal(i);
-      doc.setField(name, val);
-    }
-    return doc;
-  }
-
-  public SolrDocumentList readSolrDocumentList(FastInputStream dis) throws IOException {
-    SolrDocumentList solrDocs = new SolrDocumentList();
-    List list = (List) readVal(dis);
-    solrDocs.setNumFound((Long) list.get(0));
-    solrDocs.setStart((Long)list.get(1));
-    solrDocs.setMaxScore((Float)list.get(2));
-
-    List l = (List) readVal(dis);
-    solrDocs.addAll(l);
-    return solrDocs;
-  }
-
-   public void writeSolrDocumentList(SolrDocumentList docs)
-         throws IOException {
-     writeTag(SOLRDOCLST);
-     List l = new ArrayList(3);
-     l.add(docs.getNumFound());
-     l.add(docs.getStart());
-     l.add(docs.getMaxScore());
-     writeArray(l);
-     writeArray(docs);
-   }
-
-  public Map readMap(FastInputStream dis)
-          throws IOException {
-    int sz = readVInt(dis);
-    Map m = new LinkedHashMap();
-    for (int i = 0; i < sz; i++) {
-      Object key = readVal(dis);
-      Object val = readVal(dis);
-      m.put(key, val);
-
-    }
-    return m;
-  }
-
-  public void writeIterator(Iterator iter) throws IOException {
-    writeTag(ITERATOR);
-    while (iter.hasNext()) {
-      writeVal(iter.next());
-    }
-    writeVal(END_OBJ);
-  }
-
-  public List readIterator(FastInputStream fis) throws IOException {
-    ArrayList l = new ArrayList();
-    while(true){
-      Object  o = readVal(fis);
-      if(o == END_OBJ) break;
-      l.add(o);
-    }
-    return l;
-  }
-
-  public void writeArray(List l) throws IOException {
-    writeTag(ARR, l.size());
-    for (int i = 0; i < l.size(); i++) {
-      writeVal(l.get(i));
-    }
-  }
-
-  public void writeArray(Object[] arr) throws IOException {
-    writeTag(ARR, arr.length);
-    for (int i = 0; i < arr.length; i++) {
-      Object o = arr[i];
-      writeVal(o);
-    }
-  }
-
-  public List readArray(FastInputStream dis) throws IOException {
-    int sz = readSize(dis);
-    ArrayList l = new ArrayList(sz);
-    for (int i = 0; i < sz; i++) {
-      l.add(readVal(dis));
-    }
-    return l;
-  }
-
-  /** write the string as tag+length, with length being the number of UTF-16 characters,
-   * followed by the string encoded in modified-UTF8 
-   */
-  public void writeStr(String s) throws IOException {
-    if (s==null) {
-      writeTag(NULL);
-      return;
-    }
-    // Can't use string serialization or toUTF()... it's limited to 64K
-    // plus it's bigger than it needs to be for small strings anyway
-    int len = s.length();
-    writeTag(STR, len);
-    writeChars(daos, s, 0, len);
-  }
-
-
-  char[] charArr;
-  private String readStr(FastInputStream dis) throws IOException {
-    int sz = readSize(dis);
-    if (charArr==null || charArr.length < sz) {
-      charArr = new char[sz];
-    }
-    readChars(dis, charArr, 0, sz);
-    return new String(charArr, 0, sz);
-  }
-
-  public void writeInt(int val) throws IOException {
-    if (val>0) {
-      int b = SINT | (val & 0x0f);
-
-      if (val >= 0x0f) {
-        b |= 0x10;
-        daos.writeByte(b);
-        writeVInt(val>>>4, daos);
-      } else {
-        daos.writeByte(b);
-      }
-
-    } else {
-      daos.writeByte(INT);
-      daos.writeInt(val);
-    }
-  }
-
-  public int readSmallInt(FastInputStream dis) throws IOException {
-    int v = tagByte & 0x0F;
-    if ((tagByte & 0x10) != 0)
-      v = (readVInt(dis)<<4) | v;
-    return v;
-  }
-
-
-  public void writeLong(long val) throws IOException {
-    if ((val & 0xff00000000000000L) == 0) {
-      int b = SLONG | ((int)val & 0x0f);
-      if (val >= 0x0f) {
-        b |= 0x10;
-        daos.writeByte(b);
-        writeVLong(val>>>4, daos);
-      } else {
-        daos.writeByte(b);
-      }
-    } else {
-      daos.writeByte(LONG);
-      daos.writeLong(val);
-    }
-  }
-
-  public long readSmallLong(FastInputStream dis) throws IOException {
-    long v = tagByte & 0x0F;
-    if ((tagByte & 0x10) != 0)
-      v = (readVLong(dis)<<4) | v;
-    return v;
-  }
-
-  public boolean writePrimitive(Object val) throws IOException {
-    if (val == null) {
-      daos.writeByte(NULL);
-      return true;
-    } else if (val instanceof String) {
-      writeStr((String)val);
-      return true;
-    } else if (val instanceof Integer) {
-      writeInt(((Integer)val).intValue());
-      return true;
-    } else if (val instanceof Long) {
-      writeLong(((Long)val).longValue());
-      return true;
-    } else if (val instanceof Float) {
-      daos.writeByte(FLOAT);
-      daos.writeFloat(((Float) val).floatValue());
-      return true;
-    } else if (val instanceof Date) {
-      daos.writeByte(DATE);
-      daos.writeLong(((Date) val).getTime());
-      return true;
-    } else if (val instanceof Boolean) {
-      if ((Boolean) val) daos.writeByte(BOOL_TRUE);
-      else daos.writeByte(BOOL_FALSE);
-      return true;
-    } else if (val instanceof Double) {
-      daos.writeByte(DOUBLE);
-      daos.writeDouble(((Double) val).doubleValue());
-      return true;
-    } else if (val instanceof Byte) {
-      daos.writeByte(BYTE);
-      daos.writeByte(((Byte) val).intValue());
-      return true;
-    } else if (val instanceof Short) {
-      daos.writeByte(SHORT);
-      daos.writeShort(((Short) val).intValue());
-      return true;
-    } else if (val instanceof byte[]) {
-      writeByteArray((byte[])val, 0, ((byte[])val).length);
-      return true;
-    } else if (val == END_OBJ) {
-      writeTag(END);
-      return true;
-    }
-    return false;
-  }
-
-  public void writeMap( Map val)
-          throws IOException {
-    writeTag(MAP, val.size());
-    for (Map.Entry entry : (Set<Map.Entry>) val.entrySet()) {
-      Object key = entry.getKey();
-      if (key instanceof String) {
-        writeExternString((String) key);
-      } else {
-        writeVal(key);
-      }
-      writeVal(entry.getValue());
-    }
-  }
-
-
-  public int readSize(FastInputStream in) throws IOException {
-    int sz = tagByte & 0x1f;
-    if (sz == 0x1f) sz += readVInt(in);
-    return sz;
-  }
-
-
-
-  /**
-   * Special method for variable length int (copied from lucene). Usually used for writing the length of a collection/array/map
-   * In most of the cases the length can be represented in one byte (length < 127) so it saves 3 bytes/object
-   *
-   * @param i
-   * @param out
-   * @throws IOException
-   */
-  public static void writeVInt(int i, FastOutputStream out) throws IOException {
-    while ((i & ~0x7F) != 0) {
-      out.writeByte((byte) ((i & 0x7f) | 0x80));
-      i >>>= 7;
-    }
-    out.writeByte((byte) i);
-  }
-
-  /**
-   * The counterpart for the above
-   *
-   * @param in
-   * @return the int value
-   * @throws IOException
-   */
-  public static int readVInt(FastInputStream in) throws IOException {
-    byte b = in.readByte();
-    int i = b & 0x7F;
-    for (int shift = 7; (b & 0x80) != 0; shift += 7) {
-      b = in.readByte();
-      i |= (b & 0x7F) << shift;
-    }
-    return i;
-  }
-
-
-  public static void writeVLong(long i, FastOutputStream out) throws IOException {
-    while ((i & ~0x7F) != 0) {
-      out.writeByte((byte)((i & 0x7f) | 0x80));
-      i >>>= 7;
-    }
-    out.writeByte((byte) i);
-  }
-
-  public static long readVLong(FastInputStream in) throws IOException {
-    byte b = in.readByte();
-    long i = b & 0x7F;
-    for (int shift = 7; (b & 0x80) != 0; shift += 7) {
-      b = in.readByte();
-      i |= (long)(b & 0x7F) << shift;
-    }
-    return i;
-  }
-
-  /** Writes a sequence of UTF-8 encoded characters from a string.
-   * @param s the source of the characters
-   * @param start the first character in the sequence
-   * @param length the number of characters in the sequence
-   * @see org.apache.lucene.store.IndexInput#readChars(char[],int,int)
-   */
-  public static void writeChars(FastOutputStream os, String s, int start, int length)
-       throws IOException {
-    final int end = start + length;
-    for (int i = start; i < end; i++) {
-      final int code = (int)s.charAt(i);
-      if (code >= 0x01 && code <= 0x7F)
-	os.write(code);
-      else if (((code >= 0x80) && (code <= 0x7FF)) || code == 0) {
-	os.write(0xC0 | (code >> 6));
-	os.write(0x80 | (code & 0x3F));
-      } else {
-	os.write(0xE0 | (code >>> 12));
-	os.write(0x80 | ((code >> 6) & 0x3F));
-	os.write(0x80 | (code & 0x3F));
-      }
-    }
-  }
-
-  /** Reads UTF-8 encoded characters into an array.
-   * @param buffer the array to read characters into
-   * @param start the offset in the array to start storing characters
-   * @param length the number of characters to read
-   * @see org.apache.lucene.store.IndexOutput#writeChars(String,int,int)
-   */
-  public static void readChars(FastInputStream in, char[] buffer, int start, int length)
-       throws IOException {
-    final int end = start + length;
-    for (int i = start; i < end; i++) {
-      int b = in.read();
-      if ((b & 0x80) == 0)
-	buffer[i] = (char)b;
-      else if ((b & 0xE0) != 0xE0) {
-	buffer[i] = (char)(((b & 0x1F) << 6)
-		 | (in.read() & 0x3F));
-      } else
-	buffer[i] = (char)(((b & 0x0F) << 12)
-		| ((in.read() & 0x3F) << 6)
-	        |  (in.read() & 0x3F));
-    }
-  }
-
-  private int stringsCount  =  0;
-  private Map<String,Integer> stringsMap;
-  private List<String > stringsList;
-  public void writeExternString(String s) throws IOException {
-    if(s == null) {
-      writeTag(NULL) ;
-      return;
-    }
-    Integer idx = stringsMap == null ? null : stringsMap.get(s);
-    if(idx == null) idx =0;
-    writeTag(EXTERN_STRING,idx);
-    if(idx == 0){
-      writeStr(s);
-      if(stringsMap == null) stringsMap = new HashMap<String, Integer>();
-      stringsMap.put(s,++stringsCount);
-    }
-
-  }
-  public String  readExternString(FastInputStream fis) throws IOException {
-    int idx = readSize(fis);
-    if (idx != 0) {// idx != 0 is the index of the extern string
-      return stringsList.get(idx-1);
-    } else {// idx == 0 means it has a string value
-      String s = (String) readVal(fis);
-      if(stringsList == null ) stringsList = new ArrayList<String>();
-      stringsList.add(s);
-      return s;
-    }
-  }
-
-
-  public static interface ObjectResolver{
-    public Object resolve(Object o, NamedListCodec codec) throws IOException;
-  }
-
-
-}
diff --git a/src/java/org/apache/solr/common/util/RTimer.java b/src/java/org/apache/solr/common/util/RTimer.java
deleted file mode 100644
index 95c5b05..0000000
--- a/src/java/org/apache/solr/common/util/RTimer.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.lang.System;
-import java.lang.Thread;
-import java.util.*;
-
-/** A recursive timer.
- * 
- * RTimers are started automatically when instantiated; subtimers are also
- * started automatically when created.
- *
- * @since solr 1.3
- * @version $Id$
- */
-public class RTimer {
-
-  public static final int STARTED = 0;
-  public static final int STOPPED = 1;
-  public static final int PAUSED = 2;
-
-  protected int state;
-  protected double startTime;
-  protected double time;
-  protected double culmTime;
-  protected SimpleOrderedMap<RTimer> children;
-
-  public RTimer() {
-    time = 0;
-    culmTime = 0;
-    children = new SimpleOrderedMap<RTimer>();
-    startTime = now();
-    state = STARTED;
-  }
-
-  /** Get current time
-   *
-   * May override to implement a different timer (CPU time, etc).
-   */
-  protected double now() { return System.currentTimeMillis(); }
-
-  /** Recursively stop timer and sub timers */
-  public double stop() {
-    assert state == STARTED || state == PAUSED;
-    time = culmTime;
-    if(state == STARTED) 
-      time += now() - startTime;
-    state = STOPPED;
-    
-    for( Map.Entry<String,RTimer> entry : children ) {
-      RTimer child = entry.getValue();
-      if(child.state == STARTED || child.state == PAUSED) 
-        child.stop();
-    }
-    return time;
-  }
-
-  public void pause() {
-    assert state == STARTED;
-    culmTime += now() - startTime;
-    state = PAUSED;
-  }
-  
-  public void resume() {
-    if(state == STARTED)
-      return;
-    assert state == PAUSED;
-    state = STARTED;
-    startTime = now();
-  }
-
-  /** Get total elapsed time for this timer.
-   *
-   * Timer must be STOPped.
-   */
-  public double getTime() {
-    assert state == STOPPED;
-    return time;
-  }
-
-  /** Create new subtimer with given name
-   *
-   * Subtimer will be started.
-   */
-  public RTimer sub(String desc) {
-    RTimer child = children.get( desc );
-    if( child == null ) {
-      child = new RTimer();
-      children.add(desc, child);
-    }
-    return child;
-  }
-
-  @Override
-  public String toString() {
-    return asNamedList().toString();
-  }
-
-  public NamedList asNamedList() {
-    NamedList<Object> m = new SimpleOrderedMap<Object>();
-    m.add( "time", time );
-    if( children.size() > 0 ) {
-      for( Map.Entry<String, RTimer> entry : children ) {
-        m.add( entry.getKey(), entry.getValue().asNamedList() );
-      }
-    }
-    return m;
-  }
-
-  /*************** Testing *******/
-  public static void main(String []argv) throws InterruptedException {
-    RTimer rt = new RTimer(), subt, st;
-    Thread.sleep(100);
-
-    subt = rt.sub("sub1");
-    Thread.sleep(50);
-    st = subt.sub("sub1.1");
-    st.resume();
-    Thread.sleep(10);
-    st.pause();
-    Thread.sleep(50);
-    st.resume();
-    Thread.sleep(10);
-    st.pause();
-    subt.stop();
-    rt.stop();
-
-    System.out.println( rt.toString());
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/SimpleOrderedMap.java b/src/java/org/apache/solr/common/util/SimpleOrderedMap.java
deleted file mode 100755
index 0378753..0000000
--- a/src/java/org/apache/solr/common/util/SimpleOrderedMap.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package org.apache.solr.common.util;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.*;
-
-
-/** <code>SimpleOrderedMap</code> is a {@link NamedList} where access by key is more
- * important than maintaining order when it comes to representing the
- * held data in other forms, as ResponseWriters normally do.
- * It's normally not a good idea to repeat keys or use null keys, but this
- * is not enforced.  If key uniqueness enforcement is desired, use a regular {@link Map}.
- * <p>
- * For example, a JSON response writer may choose to write a SimpleOrderedMap
- * as {"foo":10,"bar":20} and may choose to write a NamedList as
- * ["foo",10,"bar",20].  An XML response writer may choose to render both
- * the same way.
- * </p>
- * <p>
- * This class does not provide efficient lookup by key, it's main purpose is
- * to hold data to be serialized.  It aims to minimize overhead and to be
- * efficient at adding new elements.
- * </p>
- */
-public class SimpleOrderedMap<T> extends NamedList<T> {
-  /** Creates an empty instance */
-  public SimpleOrderedMap() {
-    super();
-  }
-
-  /**
-   * Creates an instance backed by an explicitly specified list of
-   * pairwise names/values.
-   *
-   * @param nameValuePairs underlying List which should be used to implement a SimpleOrderedMap; modifying this List will affect the SimpleOrderedMap.
-   */
-  public SimpleOrderedMap(List nameValuePairs) {
-    super(nameValuePairs);
-  }
-
-  @Override
-  public SimpleOrderedMap<T> clone() {
-    ArrayList newList = new ArrayList(nvPairs.size());
-    newList.addAll(nvPairs);
-    return new SimpleOrderedMap<T>(newList);
-  }
-}
diff --git a/src/java/org/apache/solr/common/util/StrUtils.java b/src/java/org/apache/solr/common/util/StrUtils.java
deleted file mode 100644
index 50da78a..0000000
--- a/src/java/org/apache/solr/common/util/StrUtils.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.io.IOException;
-
-/**
- * @version $Id$
- */
-public class StrUtils {
-
-  /**
-   * Split a string based on a separator, but don't split if it's inside
-   * a string.  Assume '\' escapes the next char both inside and
-   * outside strings.
-   */
-  public static List<String> splitSmart(String s, char separator) {
-    ArrayList<String> lst = new ArrayList<String>(4);
-    int pos=0, start=0, end=s.length();
-    char inString=0;
-    char ch=0;
-    while (pos < end) {
-      char prevChar=ch;
-      ch = s.charAt(pos++);
-      if (ch=='\\') {    // skip escaped chars
-        pos++;
-      } else if (inString != 0 && ch==inString) {
-        inString=0;
-      } else if (ch=='\'' || ch=='"') {
-        // If char is directly preceeded by a number or letter
-        // then don't treat it as the start of a string.
-        // Examples: 50" TV, or can't
-        if (!Character.isLetterOrDigit(prevChar)) {
-          inString=ch;
-        }
-      } else if (ch==separator && inString==0) {
-        lst.add(s.substring(start,pos-1));
-        start=pos;
-      }
-    }
-    if (start < end) {
-      lst.add(s.substring(start,end));
-    }
-
-    /***
-    if (SolrCore.log.isLoggable(Level.FINEST)) {
-      SolrCore.log.trace("splitCommand=" + lst);
-    }
-    ***/
-
-    return lst;
-  }
-
-  /** Splits a backslash escaped string on the separator.
-   * <p>
-   * Current backslash escaping supported:
-   * <br> \n \t \r \b \f are escaped the same as a Java String
-   * <br> Other characters following a backslash are produced verbatim (\c => c)
-   *
-   * @param s  the string to split
-   * @param separator the separator to split on
-   * @param decode decode backslash escaping
-   */
-  public static List<String> splitSmart(String s, String separator, boolean decode) {
-    ArrayList<String> lst = new ArrayList<String>(2);
-    StringBuilder sb = new StringBuilder();
-    int pos=0, end=s.length();
-    while (pos < end) {
-      if (s.startsWith(separator,pos)) {
-        if (sb.length() > 0) {
-          lst.add(sb.toString());
-          sb=new StringBuilder();
-        }
-        pos+=separator.length();
-        continue;
-      }
-
-      char ch = s.charAt(pos++);
-      if (ch=='\\') {
-        if (!decode) sb.append(ch);
-        if (pos>=end) break;  // ERROR, or let it go?
-        ch = s.charAt(pos++);
-        if (decode) {
-          switch(ch) {
-            case 'n' : ch='\n'; break;
-            case 't' : ch='\t'; break;
-            case 'r' : ch='\r'; break;
-            case 'b' : ch='\b'; break;
-            case 'f' : ch='\f'; break;
-          }
-        }
-      }
-
-      sb.append(ch);
-    }
-
-    if (sb.length() > 0) {
-      lst.add(sb.toString());
-    }
-
-    return lst;
-  }
-
-  /**
-   * Splits file names separated by comma character.
-   * File names can contain comma characters escaped by backslash '\'
-   *
-   * @param fileNames the string containing file names
-   * @return a list of file names with the escaping backslashed removed
-   */
-  public static List<String> splitFileNames(String fileNames) {
-    if (fileNames == null)
-      return Collections.<String>emptyList();
-
-    List<String> result = new ArrayList<String>();
-    for (String file : fileNames.split("(?<!\\\\),")) {
-      result.add(file.replaceAll("\\\\(?=,)", ""));
-    }
-
-    return result;
-  }
-
-  /** Creates a backslash escaped string, joining all the items. */
-  public static String join(List<String> items, char separator) {
-    StringBuilder sb = new StringBuilder(items.size() << 3);
-    boolean first=true;
-    for (String item : items) {
-      if (first) {
-        first = false;
-      } else {
-        sb.append(separator);
-      }
-      for (int i=0; i<item.length(); i++) {
-        char ch = item.charAt(i);
-        if (ch=='\\' || ch == separator) {
-          sb.append('\\');
-        }
-        sb.append(ch);
-      }
-    }
-    return sb.toString();
-  }
-
-
-
-  public static List<String> splitWS(String s, boolean decode) {
-    ArrayList<String> lst = new ArrayList<String>(2);
-    StringBuilder sb = new StringBuilder();
-    int pos=0, end=s.length();
-    while (pos < end) {
-      char ch = s.charAt(pos++);
-      if (Character.isWhitespace(ch)) {
-        if (sb.length() > 0) {
-          lst.add(sb.toString());
-          sb=new StringBuilder();
-        }
-        continue;
-      }
-
-      if (ch=='\\') {
-        if (!decode) sb.append(ch);
-        if (pos>=end) break;  // ERROR, or let it go?
-        ch = s.charAt(pos++);
-        if (decode) {
-          switch(ch) {
-            case 'n' : ch='\n'; break;
-            case 't' : ch='\t'; break;
-            case 'r' : ch='\r'; break;
-            case 'b' : ch='\b'; break;
-            case 'f' : ch='\f'; break;
-          }
-        }
-      }
-
-      sb.append(ch);
-    }
-
-    if (sb.length() > 0) {
-      lst.add(sb.toString());
-    }
-
-    return lst;
-  }
-
-  public static List<String> toLower(List<String> strings) {
-    ArrayList<String> ret = new ArrayList<String>(strings.size());
-    for (String str : strings) {
-      ret.add(str.toLowerCase());
-    }
-    return ret;
-  }
-
-
-
-  /** Return if a string starts with '1', 't', or 'T'
-   *  and return false otherwise.
-   */
-  public static boolean parseBoolean(String s) {
-    char ch = s.length()>0 ? s.charAt(0) : 0;
-    return (ch=='1' || ch=='t' || ch=='T');
-  }
-
-  /**
-   * URLEncodes a value, replacing only enough chars so that
-   * the URL may be unambiguously pasted back into a browser.
-   * <p>
-   * Characters with a numeric value less than 32 are encoded.
-   * &amp;,=,%,+,space are encoded.
-   * <p>
-   */
-  public static void partialURLEncodeVal(Appendable dest, String val) throws IOException {
-    for (int i=0; i<val.length(); i++) {
-      char ch = val.charAt(i);
-      if (ch < 32) {
-        dest.append('%');
-        if (ch < 0x10) dest.append('0');
-        dest.append(Integer.toHexString(ch));
-      } else {
-        switch (ch) {
-          case ' ': dest.append('+'); break;
-          case '&': dest.append("%26"); break;
-          case '%': dest.append("%25"); break;
-          case '=': dest.append("%3D"); break;
-          case '+': dest.append("%2B"); break;
-          default : dest.append(ch); break;
-        }
-      }
-    }
-  }
-
-}
diff --git a/src/java/org/apache/solr/common/util/XML.java b/src/java/org/apache/solr/common/util/XML.java
deleted file mode 100644
index 36fef94..0000000
--- a/src/java/org/apache/solr/common/util/XML.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.solr.common.util;
-
-import java.io.Writer;
-import java.io.IOException;
-
-/**
- * @version $Id$
- */
-public class XML {
-
-  //
-  // copied from some of my personal code...  -YCS
-  // table created from python script.
-  // only have to escape quotes in attribute values, and don't really have to escape '>'
-  // many chars less than 0x20 are *not* valid XML, even when escaped!
-  // for example, <foo>&#0;<foo> is invalid XML.
-  private static final String[] chardata_escapes=
-  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,null,null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;",null,"&gt;"};
-
-  private static final String[] attribute_escapes=
-  {"#0;","#1;","#2;","#3;","#4;","#5;","#6;","#7;","#8;",null,null,"#11;","#12;",null,"#14;","#15;","#16;","#17;","#18;","#19;","#20;","#21;","#22;","#23;","#24;","#25;","#26;","#27;","#28;","#29;","#30;","#31;",null,null,"&quot;",null,null,null,"&amp;",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"&lt;"};
-
-
-
-  /*****************************************
-   #Simple python script used to generate the escape table above.  -YCS
-   #
-   #use individual char arrays or one big char array for better efficiency
-   # or byte array?
-   #other={'&':'amp', '<':'lt', '>':'gt', "'":'apos', '"':'quot'}
-   #
-   other={'&':'amp', '<':'lt'}
-
-   maxi=ord(max(other.keys()))+1
-   table=[None] * maxi
-   #NOTE: invalid XML chars are "escaped" as #nn; *not* &#nn; because
-   #a real XML escape would cause many strict XML parsers to choke.
-   for i in range(0x20): table[i]='#%d;' % i
-   for i in '\n\r\t ': table[ord(i)]=None
-   for k,v in other.items():
-    table[ord(k)]='&%s;' % v
-
-   result=""
-   for i in range(maxi):
-     val=table[i]
-     if not val: val='null'
-     else: val='"%s"' % val
-     result += val + ','
-
-   print result
-   ****************************************/
-
-
-/*********
- *
- * @param str
- * @param out
- * @throws IOException
- */
-  public static void escapeCharData(String str, Writer out) throws IOException {
-    escape(str, out, chardata_escapes);
-  }
-
-  public static void escapeAttributeValue(String str, Writer out) throws IOException {
-    escape(str, out, attribute_escapes);
-  }
-
-  public static void escapeAttributeValue(char [] chars, int start, int length, Writer out) throws IOException {
-    escape(chars, start, length, out, attribute_escapes);
-  }
-
-
-  public final static void writeXML(Writer out, String tag, String val) throws IOException {
-    out.write('<');
-    out.write(tag);
-    if (val == null) {
-      out.write('/');
-      out.write('>');
-    } else {
-      out.write('>');
-      escapeCharData(val,out);
-      out.write('<');
-      out.write('/');
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-  /** does NOT escape character data in val, must already be valid XML */
-  public final static void writeUnescapedXML(Writer out, String tag, String val, Object... attrs) throws IOException {
-    out.write('<');
-    out.write(tag);
-    for (int i=0; i<attrs.length; i++) {
-      out.write(' ');
-      out.write(attrs[i++].toString());
-      out.write('=');
-      out.write('"');
-      out.write(attrs[i].toString());
-      out.write('"');
-    }
-    if (val == null) {
-      out.write('/');
-      out.write('>');
-    } else {
-      out.write('>');
-      out.write(val);
-      out.write('<');
-      out.write('/');
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-  /** escapes character data in val */
-  public final static void writeXML(Writer out, String tag, String val, Object... attrs) throws IOException {
-    out.write('<');
-    out.write(tag);
-    for (int i=0; i<attrs.length; i++) {
-      out.write(' ');
-      out.write(attrs[i++].toString());
-      out.write('=');
-      out.write('"');
-      escapeAttributeValue(attrs[i].toString(), out);
-      out.write('"');
-    }
-    if (val == null) {
-      out.write('/');
-      out.write('>');
-    } else {
-      out.write('>');
-      escapeCharData(val,out);
-      out.write('<');
-      out.write('/');
-      out.write(tag);
-      out.write('>');
-    }
-  }
-
-  private static void escape(char [] chars, int offset, int length, Writer out, String [] escapes) throws IOException{
-     for (int i=offset; i<length; i++) {
-      char ch = chars[i];
-      if (ch<escapes.length) {
-        String replacement = escapes[ch];
-        if (replacement != null) {
-          out.write(replacement);
-          continue;
-        }
-      }
-      out.write(ch);
-    }
-  }
-
-  private static void escape(String str, Writer out, String[] escapes) throws IOException {
-    for (int i=0; i<str.length(); i++) {
-      char ch = str.charAt(i);
-      if (ch<escapes.length) {
-        String replacement = escapes[ch];
-        if (replacement != null) {
-          out.write(replacement);
-          continue;
-        }
-      }
-      out.write(ch);
-    }
-  }
-}
diff --git a/src/maven/solr-common-pom.xml.template b/src/maven/solr-common-pom.xml.template
deleted file mode 100644
index 4239b1c..0000000
--- a/src/maven/solr-common-pom.xml.template
+++ /dev/null
@@ -1,59 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-  <!--
-    Licensed to the Apache Software Foundation (ASF) under one
-    or more contributor license agreements.  See the NOTICE file
-    distributed with this work for additional information
-    regarding copyright ownership.  The ASF licenses this file
-    to you under the Apache License, Version 2.0 (the
-    "License"); you may not use this file except in compliance
-    with the License.  You may obtain a copy of the License at
-    
-    http://www.apache.org/licenses/LICENSE-2.0
-    
-    Unless required by applicable law or agreed to in writing,
-    software distributed under the License is distributed on an
-    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-    KIND, either express or implied.  See the License for the
-    specific language governing permissions and limitations
-    under the License.
-  -->
-
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.apache.solr</groupId>
-    <artifactId>solr-parent</artifactId>
-    <version>@maven_version@</version>
-  </parent>
-
-  <groupId>org.apache.solr</groupId>
-  <artifactId>solr-common</artifactId>
-  <name>Apache Solr Common</name>
-  <version>@maven_version@</version>
-  <description>Apache Solr Common</description>
-  <packaging>jar</packaging>
-
-  <dependencies>
-
-    <dependency>
-	    <groupId>org.slf4j</groupId>
-	    <artifactId>slf4j-api</artifactId>
-	    <version>1.5.5</version>
-	  </dependency> 
-	
-	<!--
-	Your app will need an slf4j implementation, it does not matter which one...
-    <dependency>
-      <groupId>org.slf4j</groupId>
-      <artifactId>slf4j-log4j12</artifactId>
-      <version>1.5.3</version>
-      <scope>runtime</scope>
-    </dependency>
-    -->
-
-  </dependencies>
-  
-</project>
diff --git a/src/maven/solr-solrj-pom.xml.template b/src/maven/solr-solrj-pom.xml.template
new file mode 100644
index 0000000..057507d
--- /dev/null
+++ b/src/maven/solr-solrj-pom.xml.template
@@ -0,0 +1,84 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+
+  <!--
+    Licensed to the Apache Software Foundation (ASF) under one
+    or more contributor license agreements.  See the NOTICE file
+    distributed with this work for additional information
+    regarding copyright ownership.  The ASF licenses this file
+    to you under the Apache License, Version 2.0 (the
+    "License"); you may not use this file except in compliance
+    with the License.  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing,
+    software distributed under the License is distributed on an
+    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+    KIND, either express or implied.  See the License for the
+    specific language governing permissions and limitations
+    under the License.
+  -->
+
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.apache.solr</groupId>
+    <artifactId>solr-parent</artifactId>
+    <version>@maven_version@</version>
+  </parent>
+
+  <groupId>org.apache.solr</groupId>
+  <artifactId>solr-solrj</artifactId>
+  <name>Apache Solr Solrj</name>
+  <version>@maven_version@</version>
+  <description>Apache Solr Solrj</description>
+  <packaging>jar</packaging>
+
+  <dependencies>
+
+    <!-- Solr -->
+    <dependency>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
+      <version>1.5.5</version>
+    </dependency> 
+
+    <!-- Apache Commons -->
+    <dependency>
+      <groupId>commons-httpclient</groupId>
+      <artifactId>commons-httpclient</artifactId>
+      <version>3.1</version>
+    </dependency>
+    <dependency>
+      <groupId>commons-codec</groupId>
+      <artifactId>commons-codec</artifactId>
+      <version>1.3</version>
+    </dependency>
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>1.4</version>
+    </dependency>
+    <dependency>
+      <groupId>commons-fileupload</groupId>
+      <artifactId>commons-fileupload</artifactId>
+      <version>1.2.1</version>
+    </dependency>
+
+    <!-- Stax -->
+    <dependency>
+      <groupId>woodstox</groupId>
+      <artifactId>wstx-asl</artifactId>
+      <version>3.2.7</version>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.geronimo.specs</groupId>
+      <artifactId>geronimo-stax-api_1.0_spec</artifactId>
+      <version>1.0.1</version>
+    </dependency>   
+
+  </dependencies>
+
+</project>
diff --git a/src/solrj/org/apache/solr/client/solrj/ResponseParser.java b/src/solrj/org/apache/solr/client/solrj/ResponseParser.java
new file mode 100644
index 0000000..5c028be
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/ResponseParser.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.Reader;
+import java.io.InputStream;
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class ResponseParser
+{
+  public abstract String getWriterType(); // for example: wt=XML, JSON, etc
+
+  public abstract NamedList<Object> processResponse(InputStream body, String encoding);
+
+  public abstract NamedList<Object> processResponse(Reader reader);
+  
+  /**
+   * @return the version param passed to solr
+   */
+  public String getVersion()
+  {
+    return "2.2";
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/SolrQuery.java b/src/solrj/org/apache/solr/client/solrj/SolrQuery.java
new file mode 100644
index 0000000..4d4faae
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/SolrQuery.java
@@ -0,0 +1,588 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.FacetParams;
+import org.apache.solr.common.params.HighlightParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.StatsParams;
+
+
+/**
+ * This is an augmented SolrParams with get/set/add fields for common fields used
+ * in the Standard and Dismax request handlers
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrQuery extends ModifiableSolrParams 
+{
+  public enum ORDER { desc, asc;
+    public ORDER reverse() {
+      return (this == asc) ? desc : asc;
+    }
+  }
+  
+  public SolrQuery() {
+    super();
+  }
+
+  /** Create a new SolrQuery
+   * 
+   * @param q query string
+   */
+  public SolrQuery(String q) {
+    this();
+    this.set(CommonParams.Q, q);
+  }
+
+
+  /** add a field for facet computation
+   * 
+   * @param fields the field name from the IndexSchema
+   * @return this
+   */
+  public SolrQuery addFacetField(String ... fields) {
+    for( String f : fields ) {
+      this.add(FacetParams.FACET_FIELD, f);
+    }
+    this.set(FacetParams.FACET, true);
+    return this;
+  }
+
+  /** get the facet fields
+   * 
+   * @return string array of facet fields or null if not set/empty
+   */
+  public String[] getFacetFields() {
+    return this.getParams(FacetParams.FACET_FIELD);
+  }
+
+  /** remove a facet field
+   * 
+   */
+  public boolean removeFacetField(String name) {
+    boolean b = this.remove(FacetParams.FACET_FIELD, name);
+    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
+      this.setFacet(false);
+    }
+    return b;
+  }
+  
+  /** enable/disable faceting.  
+   * 
+   * @param b flag to indicate faceting should be enabled.  if b==false removes all other faceting parameters
+   * @return this
+   */
+  public SolrQuery setFacet(boolean b) {
+    if (b) {
+      this.set(FacetParams.FACET, true);
+    } else {
+      this.remove(FacetParams.FACET);
+      this.remove(FacetParams.FACET_MINCOUNT);
+      this.remove(FacetParams.FACET_FIELD);
+      this.remove(FacetParams.FACET_LIMIT);
+      this.remove(FacetParams.FACET_MISSING);
+      this.remove(FacetParams.FACET_OFFSET);
+      this.remove(FacetParams.FACET_PREFIX);
+      this.remove(FacetParams.FACET_QUERY);
+      this.remove(FacetParams.FACET_SORT);
+      this.remove(FacetParams.FACET_ZEROS);
+      this.remove(FacetParams.FACET_PREFIX); // does not include the individual fields...
+    }
+    return this;
+  }
+  
+  public SolrQuery setFacetPrefix( String prefix )
+  {
+    this.set( FacetParams.FACET_PREFIX, prefix );
+    return this;
+  }
+
+  public SolrQuery setFacetPrefix( String field, String prefix )
+  {
+    this.set( "f."+field+"."+FacetParams.FACET_PREFIX, prefix );
+    return this;
+  }
+
+  /** add a faceting query
+   * 
+   * @param f facet query
+   */
+  public SolrQuery addFacetQuery(String f) {
+    this.add(FacetParams.FACET_QUERY, f);
+    return this;
+  }
+
+  /** get facet queries
+   * 
+   * @return all facet queries or null if not set/empty
+   */
+  public String[] getFacetQuery() {
+    return this.getParams(FacetParams.FACET_QUERY);
+  }
+
+  /** remove a facet query
+   * 
+   * @param q the facet query to remove
+   * @return true if the facet query was removed false otherwise
+   */
+  public boolean removeFacetQuery(String q) {
+    boolean b = this.remove(FacetParams.FACET_QUERY, q);
+    if (this.get(FacetParams.FACET_FIELD) == null && this.get(FacetParams.FACET_QUERY) == null) {
+      this.setFacet(false);
+    }
+    return b;
+  }
+
+  /** se the facet limit
+   * 
+   * @param lim number facet items to return
+   */
+  public SolrQuery setFacetLimit(int lim) {
+    this.set(FacetParams.FACET_LIMIT, lim);
+    return this;
+  }
+
+  /** get current facet limit
+   * 
+   * @return facet limit or default of 25
+   */
+  public int getFacetLimit() {
+    return this.getInt(FacetParams.FACET_LIMIT, 25);
+  }
+
+  /** set facet minimum count
+   * 
+   * @param cnt facets having less that cnt hits will be excluded from teh facet list
+   */
+  public SolrQuery setFacetMinCount(int cnt) {
+    this.set(FacetParams.FACET_MINCOUNT, cnt);
+    return this;
+  }
+
+  /** get facet minimum count
+   * 
+   * @return facet minimum count or default of 1
+   */
+  public int getFacetMinCount() {
+    return this.getInt(FacetParams.FACET_MINCOUNT, 1);
+  }
+
+  public SolrQuery setFacetMissing(Boolean v) {
+    this.set(FacetParams.FACET_MISSING, v);
+    return this;
+  }
+
+  /**
+   * @deprecated use {@link #setFacetMissing(String)}
+   */
+  public SolrQuery setMissing(String fld) {
+    return setFacetMissing(Boolean.valueOf(fld));
+  }
+
+  /** get facet sort
+   * 
+   * @return facet sort or default of FacetParams.FACET_SORT_COUNT
+   */
+  public String getFacetSortString() {
+    return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT);
+  }
+
+  /** get facet sort
+   * 
+   * @return facet sort or default of true
+   * @deprecated Use {@link #getFacetSortString()} instead, true corresponds to
+   * FacetParams.FACET_SORT_COUNT and false to FacetParams.FACET_SORT_LEX.
+   */
+  @Deprecated
+  public boolean getFacetSort() {
+    return this.get(FacetParams.FACET_SORT, FacetParams.FACET_SORT_COUNT).equals(FacetParams.FACET_SORT_COUNT);
+  }
+
+  /** set facet sort
+   * 
+   * @param sort sort facets
+   * @return this
+   */
+  public SolrQuery setFacetSort(String sort) {
+    this.set(FacetParams.FACET_SORT, sort);
+    return this;
+  }
+
+  /** set facet sort
+   * 
+   * @param sort sort facets
+   * @return this
+   * @deprecated Use {@link #setFacetSort(String)} instead, true corresponds to
+   * FacetParams.FACET_SORT_COUNT and false to FacetParams.FACET_SORT_LEX.
+   */
+  @Deprecated
+  public SolrQuery setFacetSort(boolean sort) {
+    this.set(FacetParams.FACET_SORT, sort == true ? FacetParams.FACET_SORT_COUNT : FacetParams.FACET_SORT_LEX);
+    return this;
+  }
+
+  /** add highlight field
+   * 
+   * @param f field to enable for highlighting
+   */
+  public SolrQuery addHighlightField(String f) {
+    this.add(HighlightParams.FIELDS, f);
+    this.set(HighlightParams.HIGHLIGHT, true);
+    return this;
+  }
+
+  /** remove a field for highlighting
+   * 
+   * @param f field name to not highlight
+   * @return true if removed, false otherwise
+   */
+  public boolean removeHighlightField(String f) {
+    boolean b = this.remove(HighlightParams.FIELDS, f);
+    if (this.get(HighlightParams.FIELDS) == null) {
+      this.setHighlight(false);
+    }
+    return b;
+  }
+
+  /** get list of hl fields
+   * 
+   * @return highlight fields or null if not set/empty
+   */
+  public String[] getHighlightFields() {
+    return this.getParams(HighlightParams.FIELDS);
+  }
+
+  public SolrQuery setHighlightSnippets(int num) {
+    this.set(HighlightParams.SNIPPETS, num);
+    return this;
+  }
+
+  public int getHighlightSnippets() {
+    return this.getInt(HighlightParams.SNIPPETS, 1);
+  }
+
+  public SolrQuery setHighlightFragsize(int num) {
+    this.set(HighlightParams.FRAGSIZE, num);
+    return this;
+  }
+
+  public int getHighlightFragsize() {
+    return this.getInt(HighlightParams.FRAGSIZE, 100);
+  }
+
+  public SolrQuery setHighlightRequireFieldMatch(boolean flag) {
+    this.set(HighlightParams.FIELD_MATCH, flag);
+    return this;
+  }
+
+  public boolean getHighlightRequireFieldMatch() {
+    return this.getBool(HighlightParams.FIELD_MATCH, false);
+  }
+
+  public SolrQuery setHighlightSimplePre(String f) {
+    this.set(HighlightParams.SIMPLE_PRE, f);
+    return this;
+  }
+
+  public String getHighlightSimplePre() {
+    return this.get(HighlightParams.SIMPLE_PRE, "");
+  }
+
+  public SolrQuery setHighlightSimplePost(String f) {
+    this.set(HighlightParams.SIMPLE_POST, f);
+    return this;
+  }
+
+  public String getHighlightSimplePost() {
+    return this.get(HighlightParams.SIMPLE_POST, "");
+  }
+
+  public SolrQuery setSortField(String field, ORDER order) {
+    this.remove(CommonParams.SORT);
+    addValueToParam(CommonParams.SORT, toSortString(field, order));
+    return this;
+  }
+  
+  public SolrQuery addSortField(String field, ORDER order) {
+    return addValueToParam(CommonParams.SORT, toSortString(field, order));
+  }
+
+  public SolrQuery removeSortField(String field, ORDER order) {
+    String s = this.get(CommonParams.SORT);
+    String removeSort = toSortString(field, order);
+    if (s != null) {
+      String[] sorts = s.split(",");
+      s = join(sorts, ", ", removeSort);
+      if (s.length()==0) s=null;
+      this.set(CommonParams.SORT, s);
+    }
+    return this;
+  }
+  
+  public String[] getSortFields() {
+    String s = getSortField();
+    if (s==null) return null;
+    return s.split(",");
+  }
+
+  public String getSortField() {
+    return this.get(CommonParams.SORT);
+  }
+  
+  public void setGetFieldStatistics( boolean v )
+  {
+    this.set( StatsParams.STATS, v );
+  }
+  
+  public void setGetFieldStatistics( String field, boolean twopass )
+  {
+    this.set( StatsParams.STATS, true );
+    this.add( StatsParams.STATS_FIELD, field );
+    this.set( "f."+field+"."+StatsParams.STATS_TWOPASS, twopass+"" );
+  }
+  
+  public void addStatsFieldFacets( String field, String ... facets )
+  {
+    if( field == null ) {
+      this.add( StatsParams.STATS_FACET, facets );
+    }
+    else {
+      for( String f : facets ) {
+        this.add( "f."+field+"."+StatsParams.STATS_FACET, f );
+      }
+    }
+  }
+
+  public SolrQuery setFilterQueries(String ... fq) {
+    this.set(CommonParams.FQ, fq);
+    return this;
+  }
+
+  public SolrQuery addFilterQuery(String ... fq) {
+    this.add(CommonParams.FQ, fq);
+    return this;
+  }
+
+  public boolean removeFilterQuery(String fq) {
+    return this.remove(CommonParams.FQ, fq);
+  }
+
+  public String[] getFilterQueries() {
+    return this.getParams(CommonParams.FQ);
+  }
+  
+  public boolean getHighlight() {
+    return this.getBool(HighlightParams.HIGHLIGHT, false);
+  }
+  
+  public SolrQuery setHighlight(boolean b) {
+    if (b) {
+      this.set(HighlightParams.HIGHLIGHT, true);
+    } else {
+      this.remove(HighlightParams.HIGHLIGHT);
+      this.remove(HighlightParams.FIELD_MATCH);
+      this.remove(HighlightParams.FIELDS);
+      this.remove(HighlightParams.FORMATTER);
+      this.remove(HighlightParams.FRAGSIZE);
+      this.remove(HighlightParams.SIMPLE_POST);
+      this.remove(HighlightParams.SIMPLE_PRE);
+      this.remove(HighlightParams.SNIPPETS);
+    }
+    return this;
+  }
+
+  public SolrQuery setFields(String ... fields) {
+    if( fields == null || fields.length == 0 ) {
+      this.remove( CommonParams.FL );
+      return this;
+    }
+    StringBuilder sb = new StringBuilder();
+    sb.append( fields[0] );
+    for( int i=1; i<fields.length; i++ ) {
+      sb.append( ',' );
+      sb.append( fields[i] );
+    }
+    this.set(CommonParams.FL, sb.toString() );
+    return this;
+  }
+    
+  public SolrQuery addField(String field) {
+    return addValueToParam(CommonParams.FL, field);
+  }
+
+  public String getFields() {
+    String fields = this.get(CommonParams.FL);
+    if (fields!=null && fields.equals("score")) {
+      fields = "*, score";
+    }
+    return fields;
+  }
+
+  public SolrQuery setIncludeScore(boolean includeScore) {
+    if (includeScore) {
+      this.add(CommonParams.FL, "score");
+    } else {
+      this.remove(CommonParams.FL, "score");
+    }
+    return this;
+  }
+
+  public SolrQuery setQuery(String query) {
+    this.set(CommonParams.Q, query);
+    return this;
+  }
+
+  public String getQuery() {
+    return this.get(CommonParams.Q);
+  }
+
+  public SolrQuery setRows(Integer rows) {
+    if( rows == null ) {
+      this.remove( CommonParams.ROWS );
+    }
+    else {
+      this.set(CommonParams.ROWS, rows);
+    }
+    return this;
+  }
+
+  public Integer getRows()
+  {
+    return this.getInt(CommonParams.ROWS);
+  }
+
+  public void setShowDebugInfo(boolean showDebugInfo) {
+    this.set(CommonParams.DEBUG_QUERY, String.valueOf(showDebugInfo));
+  }
+
+// use addSortField( sort, order 
+//  public void setSort(String ... sort) {
+//    this.set(CommonParams.SORT, sort);
+//  }
+
+  public SolrQuery setStart(Integer start) {
+    if( start == null ) {
+      this.remove( CommonParams.START );
+    }
+    else {
+      this.set(CommonParams.START, start);
+    }
+    return this;
+  }
+  
+  public Integer getStart()
+  {
+    return this.getInt(CommonParams.START);
+  }
+
+  public SolrQuery setQueryType(String qt) {
+    this.set(CommonParams.QT, qt);
+    return this;
+  }
+
+  public String getQueryType() {
+    return this.get(CommonParams.QT);
+  }
+
+  public SolrQuery setParam(String name, String ... values) {
+    this.set(name, values);
+    return this;
+  }
+
+  public SolrQuery setParam(String name, boolean value) {
+    this.set(name, value);
+    return this;
+  }
+
+  /** get a deep copy of this object * */
+  public SolrQuery getCopy() {
+    SolrQuery q = new SolrQuery();
+    for (String name : this.getParameterNames()) {
+      q.setParam(name, this.getParams(name));
+    }
+    return q;
+  }
+  
+  /**
+  * Set the maximum time allowed for this query. If the query takes more time
+  * than the specified milliseconds, a timeout occurs and partial (or no)
+  * results may be returned.
+  * 
+  * If given Integer is null, then this parameter is removed from the request
+  * 
+  *@param milliseconds the time in milliseconds allowed for this query
+  */
+  public SolrQuery setTimeAllowed(Integer milliseconds) {
+    if (milliseconds == null) {
+      this.remove(CommonParams.TIME_ALLOWED);
+    } else {
+      this.set(CommonParams.TIME_ALLOWED, milliseconds);
+    }
+    return this;
+  }
+  
+  /**
+  * Get the maximum time allowed for this query.
+  */
+  public Integer getTimeAllowed() {
+    return this.getInt(CommonParams.TIME_ALLOWED);
+  }
+
+  ///////////////////////
+  //  Utility functions
+  ///////////////////////
+  
+  private String toSortString(String field, ORDER order) {
+    return field.trim() + ' ' + String.valueOf(order).trim();
+  }
+  
+  private String join(String a, String b, String sep) {
+    StringBuilder sb = new StringBuilder();
+    if (a!=null && a.length()>0) {
+      sb.append(a);
+      sb.append(sep);
+    } 
+    if (b!=null && b.length()>0) {
+      sb.append(b);
+    }
+    return sb.toString().trim();
+  }
+  
+  private SolrQuery addValueToParam(String name, String value) {
+    String tmp = this.get(name);
+    tmp = join(tmp, value, ",");
+    this.set(name, tmp);
+    return this;
+  }
+   
+  private String join(String[] vals, String sep, String removeVal) {
+    StringBuilder sb = new StringBuilder();
+    for (int i=0; i<vals.length; i++) {
+      if (removeVal==null || !vals[i].equals(removeVal)) {
+        sb.append(vals[i]);
+        if (i<vals.length-1) {
+          sb.append(sep);
+        }
+      }
+    }
+    return sb.toString().trim();
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/SolrRequest.java b/src/solrj/org/apache/solr/client/solrj/SolrRequest.java
new file mode 100644
index 0000000..57833fe
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/SolrRequest.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Collection;
+
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class SolrRequest implements Serializable
+{
+  public enum METHOD {
+    GET,
+    POST
+  };
+
+  private METHOD method = METHOD.GET;
+  private String path = null;
+
+  private ResponseParser responseParser;
+  //---------------------------------------------------------
+  //---------------------------------------------------------
+
+  public SolrRequest( METHOD m, String path )
+  {
+    this.method = m;
+    this.path = path;
+  }
+
+  //---------------------------------------------------------
+  //---------------------------------------------------------
+
+  public METHOD getMethod() {
+    return method;
+  }
+  public void setMethod(METHOD method) {
+    this.method = method;
+  }
+
+  public String getPath() {
+    return path;
+  }
+  public void setPath(String path) {
+    this.path = path;
+  }
+
+  /**
+   *
+   * @return The {@link org.apache.solr.client.solrj.ResponseParser}
+   */
+  public ResponseParser getResponseParser() {
+    return responseParser;
+  }
+
+  /**
+   * Optionally specify how the Response should be parsed.  Not all server implementations require a ResponseParser
+   * to be specified.
+   * @param responseParser The {@link org.apache.solr.client.solrj.ResponseParser}
+   */
+  public void setResponseParser(ResponseParser responseParser) {
+    this.responseParser = responseParser;
+  }
+
+  public abstract SolrParams getParams();
+  public abstract Collection<ContentStream> getContentStreams() throws IOException;
+  public abstract SolrResponse process( SolrServer server ) throws SolrServerException, IOException;
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/SolrResponse.java b/src/solrj/org/apache/solr/client/solrj/SolrResponse.java
new file mode 100644
index 0000000..aa89c74
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/SolrResponse.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.Serializable;
+
+import org.apache.solr.common.util.NamedList;
+
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class SolrResponse implements Serializable
+{
+  public abstract long getElapsedTime();
+  public abstract void setResponse(  NamedList<Object> rsp );
+  public abstract NamedList<Object> getResponse();
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/SolrServer.java b/src/solrj/org/apache/solr/client/solrj/SolrServer.java
new file mode 100644
index 0000000..b661d65
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/SolrServer.java
@@ -0,0 +1,131 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.ArrayList;
+
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.client.solrj.request.SolrPing;
+import org.apache.solr.client.solrj.request.UpdateRequest;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.client.solrj.response.SolrPingResponse;
+import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.client.solrj.SolrRequest.METHOD;
+import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class SolrServer implements Serializable
+{
+  private DocumentObjectBinder binder;
+
+  public UpdateResponse add(Collection<SolrInputDocument> docs ) throws SolrServerException, IOException {
+    UpdateRequest req = new UpdateRequest();
+    req.add(docs);
+    return req.process(this);
+  }
+
+  public UpdateResponse addBeans(Collection<?> beans ) throws SolrServerException, IOException {
+    DocumentObjectBinder binder = this.getBinder();
+    ArrayList<SolrInputDocument> docs =  new ArrayList<SolrInputDocument>(beans.size());
+    for (Object bean : beans) {
+      docs.add(binder.toSolrInputDocument(bean));
+    }
+    return add(docs);
+  }
+
+  public UpdateResponse add(SolrInputDocument doc ) throws SolrServerException, IOException {
+    UpdateRequest req = new UpdateRequest();
+    req.add(doc);
+    return req.process(this);
+  }
+
+  public UpdateResponse addBean(Object obj) throws IOException, SolrServerException {
+    return add(getBinder().toSolrInputDocument(obj));
+  }
+
+  /** waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
+   * @throws IOException 
+   */
+  public UpdateResponse commit( ) throws SolrServerException, IOException {
+    return commit(true, true);
+  }
+
+  /** waitFlush=true and waitSearcher=true to be inline with the defaults for plain HTTP access
+   * @throws IOException 
+   */
+  public UpdateResponse optimize( ) throws SolrServerException, IOException {
+    return optimize(true, true, 1);
+  }
+  
+  public UpdateResponse commit( boolean waitFlush, boolean waitSearcher ) throws SolrServerException, IOException {
+    return new UpdateRequest().setAction( UpdateRequest.ACTION.COMMIT, waitFlush, waitSearcher ).process( this );
+  }
+
+  public UpdateResponse optimize( boolean waitFlush, boolean waitSearcher ) throws SolrServerException, IOException {
+    return optimize(waitFlush, waitSearcher, 1);
+  }
+
+  public UpdateResponse optimize(boolean waitFlush, boolean waitSearcher, int maxSegments ) throws SolrServerException, IOException {
+    return new UpdateRequest().setAction( UpdateRequest.ACTION.OPTIMIZE, waitFlush, waitSearcher, maxSegments ).process( this );
+  }
+  
+  public UpdateResponse rollback() throws SolrServerException, IOException {
+    return new UpdateRequest().rollback().process( this );
+  }
+  
+  public UpdateResponse deleteById(String id) throws SolrServerException, IOException {
+    return new UpdateRequest().deleteById( id ).process( this );
+  }
+
+  public UpdateResponse deleteByQuery(String query) throws SolrServerException, IOException {
+    return new UpdateRequest().deleteByQuery( query ).process( this );
+  }
+
+  public SolrPingResponse ping() throws SolrServerException, IOException {
+    return new SolrPing().process( this );
+  }
+
+  public QueryResponse query(SolrParams params) throws SolrServerException {
+    return new QueryRequest( params ).process( this );
+  }
+  
+  public QueryResponse query(SolrParams params, METHOD method) throws SolrServerException {
+    return new QueryRequest( params, method ).process( this );
+  }
+  
+  /**
+   * SolrServer implementations need to implement a how a request is actually processed
+   */ 
+  public abstract NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException;
+
+  public DocumentObjectBinder getBinder() {
+    if(binder == null){
+      binder = new DocumentObjectBinder();
+    }
+    return binder;
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/SolrServerException.java b/src/solrj/org/apache/solr/client/solrj/SolrServerException.java
new file mode 100644
index 0000000..67c46d9
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/SolrServerException.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+/** Exception to catch all types of communication / parsing issues associated with talking to SOLR
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrServerException extends Exception {
+
+  private static final long serialVersionUID = -3371703521752000294L;
+  
+  public SolrServerException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
+  public SolrServerException(String message) {
+    super(message);
+  }
+
+  public SolrServerException(Throwable cause) {
+    super(cause);
+  }
+  
+  public Throwable getRootCause() {
+    Throwable t = this;
+    while (true) {
+      Throwable cause = t.getCause();
+      if (cause!=null) {
+        t = cause;
+      } else {
+        break;
+      }
+    }
+    return t;
+  }
+
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java b/src/solrj/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
new file mode 100644
index 0000000..6ca3234
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/beans/DocumentObjectBinder.java
@@ -0,0 +1,258 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.beans;
+
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Method;
+import java.lang.reflect.Array;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A class to map objects to and from solr documents.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class DocumentObjectBinder {
+  private final Map<Class, List<DocField>> infocache = new ConcurrentHashMap<Class, List<DocField>>();
+
+  public DocumentObjectBinder() {
+  }
+
+  public <T> List<T> getBeans(Class<T> clazz, SolrDocumentList solrDocList) {
+    List<DocField> fields = getDocFields( clazz );
+    List<T> result = new ArrayList<T>(solrDocList.size());
+
+    for(int j=0;j<solrDocList.size();j++) {
+      SolrDocument sdoc = solrDocList.get(j);
+
+      T obj = null;
+      try {
+        obj = clazz.newInstance();
+        result.add(obj);
+      } catch (Exception e) {
+        throw new RuntimeException("Could not instantiate object of " + clazz,e);
+      }
+      for (int i = 0; i < fields.size(); i++) {
+        DocField docField = fields.get(i);
+        docField.inject(obj, sdoc);
+      }
+    }
+    return result;
+  }
+  
+  public SolrInputDocument toSolrInputDocument( Object obj )
+  {
+    List<DocField> fields = getDocFields( obj.getClass() );
+    if( fields.isEmpty() ) {
+      throw new RuntimeException( "class: "+obj.getClass()+" does not define any fields." );
+    }
+    
+    SolrInputDocument doc = new SolrInputDocument();
+    for( DocField field : fields ) {
+      doc.setField( field.name, field.get( obj ), 1.0f );
+    }
+    return doc;
+  }
+  
+  private List<DocField> getDocFields( Class clazz )
+  {
+    List<DocField> fields = infocache.get(clazz);
+    if (fields == null) {
+      synchronized(infocache) {
+        infocache.put(clazz, fields = collectInfo(clazz));
+      }
+    }
+    return fields;
+  }
+
+  private List<DocField> collectInfo(Class clazz) {
+    List<DocField> fields = new ArrayList<DocField>();
+    Class superClazz = clazz;
+    ArrayList<AccessibleObject> members = new ArrayList<AccessibleObject>();
+    while (superClazz != null && superClazz != Object.class) {
+      members.addAll(Arrays.asList(superClazz.getDeclaredFields()));
+      members.addAll(Arrays.asList(superClazz.getDeclaredMethods()));
+      superClazz = superClazz.getSuperclass();
+    }
+    for (AccessibleObject member : members) {
+      if (member.isAnnotationPresent(Field.class)) {
+        member.setAccessible(true);
+        fields.add(new DocField(member));
+      }
+    }
+    return fields;
+  }
+
+  private static class DocField {
+    private String name;
+    private java.lang.reflect.Field field;
+    private Method setter;
+    private Method getter;
+    private Class type;
+    private boolean isArray = false, isList=false;
+
+    public DocField(AccessibleObject member) {
+      if (member instanceof java.lang.reflect.Field) {
+        field = (java.lang.reflect.Field) member;
+      } else {
+        setter = (Method) member;
+      }
+      Field annotation = member.getAnnotation(Field.class);
+      storeName(annotation);
+      storeType();
+      
+      // Look for a matching getter
+      if( setter != null ) {
+        String gname = setter.getName();
+        if( gname.startsWith("set") ) {
+          gname = "get" + gname.substring(3);
+          try {
+            getter = setter.getDeclaringClass().getMethod( gname, (Class[])null );
+          }
+          catch( Exception ex ) {
+            // no getter -- don't worry about it...
+            if( type == Boolean.class ) {
+              gname = "is" + setter.getName().substring( 3 );
+              try {
+                getter = setter.getDeclaringClass().getMethod( gname, (Class[])null );
+              }
+              catch( Exception ex2 ) {
+                // no getter -- don't worry about it...
+              }
+            }
+          }
+        }
+      }
+    }
+
+    private void storeName(Field annotation) {
+      if (annotation.value().equals(Field.DEFAULT)) {
+        if (field != null) {
+          name = field.getName();
+        } else {
+          String setterName = setter.getName();
+          if (setterName.startsWith("set") && setterName.length() > 3) {
+            name = setterName.substring(3, 4).toLowerCase() + setterName.substring(4);
+          } else {
+            name = setter.getName();
+          }
+        }
+      } else {
+        name = annotation.value();
+      }
+    }
+
+    private void storeType() {
+      if (field != null) {
+        type = field.getType();
+      } else {
+        Class[] params = setter.getParameterTypes();
+        if (params.length != 1)
+          throw new RuntimeException("Invalid setter method. Must have one and only one parameter");
+        type = params[0];
+      }
+      if(type == Collection.class || type == List.class || type == ArrayList.class) {
+        type = Object.class;
+        isList = true;
+        /*ParameterizedType parameterizedType = null;
+        if(field !=null){
+          if( field.getGenericType() instanceof ParameterizedType){
+            parameterizedType = (ParameterizedType) field.getGenericType();
+            Type[] types = parameterizedType.getActualTypeArguments();
+            if (types != null && types.length > 0) type = (Class) types[0];
+          }
+        }*/
+      } else if (type.isArray()) {
+        isArray = true;
+        type = type.getComponentType();
+      }
+    }
+
+    public <T> void inject(T obj, SolrDocument sdoc) {
+      Object val = sdoc.getFieldValue(name);
+      if(val == null) return;
+      if (isArray) {
+        if (val instanceof List) {
+          List collection = (List) val;
+          set(obj, collection.toArray((Object[]) Array.newInstance(type,collection.size())));
+        } else {
+          Object[] arr = (Object[]) Array.newInstance(type, 1);
+          arr[0] = val;
+          set(obj, arr);
+        }
+      } else if (isList) {
+        if (val instanceof List) {
+          set(obj, val);
+        } else {
+          ArrayList l = new ArrayList();
+          l.add(val);
+          set(obj, l);
+        }
+      } else {
+        if (val instanceof List) {
+          List l = (List) val;
+          if(l.size()>0) 
+            set(obj, l.get(0));
+        } 
+        else {
+          set(obj,val) ;
+        }
+      }
+    }
+    
+    private void set(Object obj, Object v) {
+      try {
+        if (field != null) {
+          field.set(obj, v);
+        } else if (setter != null) {
+          setter.invoke(obj, v);
+        }
+      } 
+      catch (Exception e) {
+        throw new RuntimeException("Exception while setting value : "+v+" on " + (field != null ? field : setter), e);
+      }
+    }
+    
+    public Object get( final Object obj )
+    {
+      if (field != null) {
+        try {
+          return field.get(obj);
+        } 
+        catch (Exception e) {        
+          throw new RuntimeException("Exception while getting value: " + field, e);
+        }
+      }
+      else if (getter == null) {
+        throw new RuntimeException( "Missing getter for field: "+name+" -- You can only call the 'get' for fields that have a field of 'get' method" );
+      }
+      
+      try {
+        return getter.invoke( obj, (Object[])null );
+      } 
+      catch (Exception e) {        
+        throw new RuntimeException("Exception while getting value: " + getter, e);
+      }
+    }
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/beans/Field.java b/src/solrj/org/apache/solr/client/solrj/beans/Field.java
new file mode 100644
index 0000000..156fcef
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/beans/Field.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.beans;
+
+import static java.lang.annotation.ElementType.*;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Target;
+import java.lang.annotation.Retention;
+
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+@Target({FIELD, METHOD})
+@Retention(RUNTIME)
+public @interface Field {
+  public static final String DEFAULT ="#default";
+  String value() default DEFAULT;
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/impl/BinaryResponseParser.java b/src/solrj/org/apache/solr/client/solrj/impl/BinaryResponseParser.java
new file mode 100755
index 0000000..466b07c
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/impl/BinaryResponseParser.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.impl;
+
+import org.apache.solr.client.solrj.ResponseParser;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.NamedListCodec;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class BinaryResponseParser extends ResponseParser {
+  public String getWriterType() {
+    return "javabin";
+  }
+
+  public NamedList<Object> processResponse(InputStream body, String encoding) {
+    try {
+      return new NamedListCodec().unmarshal(body);
+    } catch (IOException e) {
+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
+
+    }
+  }
+
+  public NamedList<Object> processResponse(Reader reader) {
+    throw new RuntimeException("Cannot handle character stream");
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java b/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
new file mode 100644
index 0000000..9fa758c
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/impl/CommonsHttpSolrServer.java
@@ -0,0 +1,488 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.InflaterInputStream;
+
+import org.apache.commons.httpclient.*;
+import org.apache.commons.httpclient.methods.GetMethod;
+import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
+import org.apache.commons.httpclient.methods.PostMethod;
+import org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;
+import org.apache.commons.httpclient.methods.multipart.Part;
+import org.apache.commons.httpclient.methods.multipart.PartBase;
+import org.apache.commons.httpclient.methods.multipart.StringPart;
+import org.apache.commons.io.IOUtils;
+import org.apache.solr.client.solrj.ResponseParser;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class CommonsHttpSolrServer extends SolrServer 
+{
+  public static final String AGENT = "Solr["+CommonsHttpSolrServer.class.getName()+"] 1.0"; 
+  
+  /**
+   * The URL of the Solr server.
+   */
+  protected String _baseURL;
+  protected ModifiableSolrParams _invariantParams;
+  protected ResponseParser _parser;
+  
+  private final HttpClient _httpClient;
+  private boolean _followRedirects = false;
+  private boolean _allowCompression = false;
+  private int _maxRetries = 0;
+  
+  /**
+   * If set to false, add the query parameters as URL-encoded parameters to the
+   * POST request in a single part. If set to true, create a new part of a
+   * multi-part request for each parameter.
+   * 
+   * The reason for adding all parameters as parts of a multi-part request is
+   * that this allows us to specify the charset -- standards for single-part
+   * requests specify that non-ASCII characters should be URL-encoded, but don't
+   * specify the charset of the characters to be URL-encoded (cf.
+   * http://www.w3.org/TR/html401/interact/forms.html#form-content-type).
+   * Therefore you have to rely on your servlet container doing the right thing
+   * with single-part requests.
+   */
+  private boolean useMultiPartPost;
+  
+  /**  
+   * @param solrServerUrl The URL of the Solr server.  For 
+   * example, "<code>http://localhost:8983/solr/</code>"
+   * if you are using the standard distribution Solr webapp 
+   * on your local machine.
+   */
+  public CommonsHttpSolrServer(String solrServerUrl) throws MalformedURLException {
+    this(new URL(solrServerUrl));
+  }
+
+  /** Talk to the Solr server via the given HttpClient.  The connection manager
+   * for the client should be a MultiThreadedHttpConnectionManager if this
+   * client is being reused across SolrServer instances, or of multiple threads
+   * will use this SolrServer.
+   */
+  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient) throws MalformedURLException {
+    this(new URL(solrServerUrl), httpClient, new BinaryResponseParser(), false);
+  }
+  
+  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient, boolean useMultiPartPost) throws MalformedURLException {
+    this(new URL(solrServerUrl), httpClient, new BinaryResponseParser(), useMultiPartPost);
+  }
+
+  public CommonsHttpSolrServer(String solrServerUrl, HttpClient httpClient, ResponseParser parser) throws MalformedURLException {
+    this(new URL(solrServerUrl), httpClient, parser, false);
+  }
+
+  /**
+   * @param baseURL The URL of the Solr server.  For 
+   * example, "<code>http://localhost:8983/solr/</code>"
+   * if you are using the standard distribution Solr webapp 
+   * on your local machine.
+   */
+  public CommonsHttpSolrServer(URL baseURL) 
+  {
+    this(baseURL, null, new BinaryResponseParser(), false);
+  }
+
+  public CommonsHttpSolrServer(URL baseURL, HttpClient client){
+    this(baseURL, client, new BinaryResponseParser(), false);
+  }
+  
+  public CommonsHttpSolrServer(URL baseURL, HttpClient client, boolean useMultiPartPost){
+    this(baseURL, client, new BinaryResponseParser(), useMultiPartPost);
+  }
+
+
+  public CommonsHttpSolrServer(URL baseURL, HttpClient client, ResponseParser parser, boolean useMultiPartPost) {
+    _baseURL = baseURL.toExternalForm();
+    if( _baseURL.endsWith( "/" ) ) {
+      _baseURL = _baseURL.substring( 0, _baseURL.length()-1 );
+    }
+    if( _baseURL.indexOf( '?' ) >=0 ) {
+      throw new RuntimeException( "Invalid base url for solrj.  The base URL must not contain parameters: "+_baseURL );
+    }
+ 
+    _httpClient = (client == null) ? new HttpClient(new MultiThreadedHttpConnectionManager()) : client;
+
+    if (client == null) {
+      // set some better defaults if we created a new connection manager and client
+      
+      // increase the default connections
+      this.setDefaultMaxConnectionsPerHost( 32 );  // 2
+      this.setMaxTotalConnections( 128 ); // 20
+    }
+
+    // by default use the binary response parser
+    _parser = parser;
+    
+    this.useMultiPartPost = useMultiPartPost;
+  }
+
+
+  //------------------------------------------------------------------------
+  //------------------------------------------------------------------------
+
+  /**
+   * Process the request.  If {@link org.apache.solr.client.solrj.SolrRequest#getResponseParser()} is null, then use
+   * {@link #getParser()}
+   * @param request The {@link org.apache.solr.client.solrj.SolrRequest} to process
+   * @return The {@link org.apache.solr.common.util.NamedList} result
+   * @throws SolrServerException
+   * @throws IOException
+   *
+   * @see #request(org.apache.solr.client.solrj.SolrRequest, org.apache.solr.client.solrj.ResponseParser)
+   */
+  @Override
+  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException
+  {
+    ResponseParser responseParser = request.getResponseParser();
+    if (responseParser == null) {
+      responseParser = _parser;
+    }
+    return request(request, responseParser);
+  }
+
+  
+  public NamedList<Object> request(final SolrRequest request, ResponseParser processor) throws SolrServerException, IOException{
+    
+    HttpMethod method = null;
+    SolrParams params = request.getParams();
+    Collection<ContentStream> streams = request.getContentStreams();
+    String path = request.getPath();
+    if( path == null || !path.startsWith( "/" ) ) {
+      path = "/select";
+    }
+    
+    ResponseParser parser = request.getResponseParser();
+    if( parser == null ) {
+      parser = _parser;
+    }
+    
+    // The parser 'wt=' and 'version=' params are used instead of the original params
+    ModifiableSolrParams wparams = new ModifiableSolrParams();
+    wparams.set( CommonParams.WT, parser.getWriterType() );
+    wparams.set( CommonParams.VERSION, parser.getVersion() );
+    if( params == null ) {
+      params = wparams;
+    }
+    else {
+      params = new DefaultSolrParams( wparams, params );
+    }
+    
+    if( _invariantParams != null ) {
+      params = new DefaultSolrParams( _invariantParams, params );
+    }
+
+    int tries = _maxRetries + 1;
+    try {
+      while( tries-- > 0 ) {
+        // Note: since we aren't do intermittent time keeping
+        // ourselves, the potential non-timeout latency could be as
+        // much as tries-times (plus scheduling effects) the given
+        // timeAllowed.
+        try {
+          if( SolrRequest.METHOD.GET == request.getMethod() ) {
+            if( streams != null ) {
+              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "GET can't send streams!" );
+            }
+            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );
+          }
+          else if( SolrRequest.METHOD.POST == request.getMethod() ) {
+
+            String url = _baseURL + path;
+            boolean isMultipart = ( streams != null && streams.size() > 1 );
+
+            if (streams == null || isMultipart) {
+              PostMethod post = new PostMethod(url);
+              post.getParams().setContentCharset("UTF-8");
+              if (!this.useMultiPartPost && !isMultipart) {
+                post.addRequestHeader("Content-Type",
+                    "application/x-www-form-urlencoded; charset=UTF-8");
+              }
+
+              List<Part> parts = new LinkedList<Part>();
+              Iterator<String> iter = params.getParameterNamesIterator();
+              while (iter.hasNext()) {
+                String p = iter.next();
+                String[] vals = params.getParams(p);
+                if (vals != null) {
+                  for (String v : vals) {
+                    if (this.useMultiPartPost || isMultipart) {
+                      parts.add(new StringPart(p, v, "UTF-8"));
+                    } else {
+                      post.addParameter(p, v);
+                    }
+                  }
+                }
+              }
+
+              if (isMultipart) {
+                int i = 0;
+                for (ContentStream content : streams) {
+                  final ContentStream c = content;
+
+                  String charSet = null;
+                  String transferEncoding = null;
+                  parts.add(new PartBase(c.getName(), c.getContentType(),
+                      charSet, transferEncoding) {
+                    @Override
+                    protected long lengthOfData() throws IOException {
+                      return c.getSize();
+                    }
+
+                    @Override
+                    protected void sendData(OutputStream out)
+                        throws IOException {
+                      IOUtils.copy(c.getReader(), out);
+                    }
+                  });
+                }
+              }
+              if (parts.size() > 0) {
+                post.setRequestEntity(new MultipartRequestEntity(parts
+                    .toArray(new Part[parts.size()]), post.getParams()));
+              }
+
+              method = post;
+            }
+            // It is has one stream, it is the post body, put the params in the URL
+            else {
+              String pstr = ClientUtils.toQueryString( params, false );
+              PostMethod post = new PostMethod( url+pstr );
+
+              // Single stream as body
+              // Using a loop just to get the first one
+              for( ContentStream content : streams ) {
+                post.setRequestEntity(
+                    new InputStreamRequestEntity( content.getStream(), content.getContentType())
+                );
+                break;
+              }
+              method = post;
+            }
+          }
+          else {
+            throw new SolrServerException("Unsupported method: "+request.getMethod() );
+          }
+        }
+        catch( NoHttpResponseException r ) {
+          // This is generally safe to retry on
+          method.releaseConnection();
+          method = null;
+          // If out of tries then just rethrow (as normal error).
+          if( ( tries < 1 ) ) {
+            throw r;
+          }
+          //log.warn( "Caught: " + r + ". Retrying..." );
+        }
+      }
+    }
+    catch( IOException ex ) {
+      throw new SolrServerException("error reading streams", ex );
+    }
+
+    method.setFollowRedirects( _followRedirects );
+    method.addRequestHeader( "User-Agent", AGENT );
+    if( _allowCompression ) {
+      method.setRequestHeader( new Header( "Accept-Encoding", "gzip,deflate" ) );
+    }
+
+    try {
+      // Execute the method.
+      //System.out.println( "EXECUTE:"+method.getURI() );
+
+      int statusCode = _httpClient.executeMethod(method);
+      if (statusCode != HttpStatus.SC_OK) {
+        StringBuilder msg = new StringBuilder();
+        msg.append( method.getStatusLine().getReasonPhrase() );
+        msg.append( "\n\n" );
+        msg.append( method.getStatusText() );
+        msg.append( "\n\n" );
+        msg.append( "request: "+method.getURI() );
+        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), "UTF-8") );
+      }
+
+      // Read the contents
+      String charset = "UTF-8";
+      if( method instanceof HttpMethodBase ) {
+        charset = ((HttpMethodBase)method).getResponseCharSet();
+      }
+      InputStream respBody = method.getResponseBodyAsStream();
+      // Jakarta Commons HTTPClient doesn't handle any
+      // compression natively.  Handle gzip or deflate
+      // here if applicable.
+      if( _allowCompression ) {
+        Header contentEncodingHeader = method.getResponseHeader( "Content-Encoding" );
+        if( contentEncodingHeader != null ) {
+          String contentEncoding = contentEncodingHeader.getValue();
+          if( contentEncoding.contains( "gzip" ) ) {
+            //log.debug( "wrapping response in GZIPInputStream" );
+            respBody = new GZIPInputStream( respBody );
+          }
+          else if( contentEncoding.contains( "deflate" ) ) {
+            //log.debug( "wrapping response in InflaterInputStream" );
+            respBody = new InflaterInputStream(respBody);
+          }
+        }
+        else {
+          Header contentTypeHeader = method.getResponseHeader( "Content-Type" );
+          if( contentTypeHeader != null ) {
+            String contentType = contentTypeHeader.getValue();
+            if( contentType != null ) {
+              if( contentType.startsWith( "application/x-gzip-compressed" ) ) {
+                //log.debug( "wrapping response in GZIPInputStream" );
+                respBody = new GZIPInputStream( respBody );
+              }
+              else if ( contentType.startsWith("application/x-deflate") ) {
+                //log.debug( "wrapping response in InflaterInputStream" );
+                respBody = new InflaterInputStream(respBody);
+              }
+            }
+          }
+        }
+      }
+      return processor.processResponse(respBody, charset);
+    }
+    catch (HttpException e) {
+      throw new SolrServerException( e );
+    }
+    catch (IOException e) {
+      throw new SolrServerException( e );
+    }
+    finally {
+      method.releaseConnection();
+    }
+  }
+
+  //-------------------------------------------------------------------
+  //-------------------------------------------------------------------
+  
+  /**
+   * Parameters are added to ever request regardless.  This may be a place to add 
+   * something like an authentication token.
+   */
+  public ModifiableSolrParams getInvariantParams()
+  {
+    return _invariantParams;
+  }
+
+  public String getBaseURL() {
+    return _baseURL;
+  }
+
+  public void setBaseURL(String baseURL) {
+    this._baseURL = baseURL;
+  }
+
+  public ResponseParser getParser() {
+    return _parser;
+  }
+
+  /**
+   * Note: Setting this value is not thread-safe.
+   * @param processor The {@link org.apache.solr.client.solrj.ResponseParser}
+   */
+  public void setParser(ResponseParser processor) {
+    _parser = processor;
+  }
+
+  public HttpClient getHttpClient() {
+    return _httpClient;
+  }
+
+  private HttpConnectionManager getConnectionManager() {
+    return _httpClient.getHttpConnectionManager();
+  }
+  
+  /** set connectionTimeout on the underlying HttpConnectionManager */
+  public void setConnectionTimeout(int timeout) {
+    getConnectionManager().getParams().setConnectionTimeout(timeout);
+  }
+  
+  /** set connectionManagerTimeout on the HttpClient.**/
+  public void setConnectionManagerTimeout(int timeout) {
+    _httpClient.getParams().setConnectionManagerTimeout(timeout);
+  }
+  
+  /** set soTimeout (read timeout) on the underlying HttpConnectionManager.  This is desirable for queries, but probably not for indexing. */
+  public void setSoTimeout(int timeout) {
+    getConnectionManager().getParams().setSoTimeout(timeout);
+  }
+  
+  /** set maxConnectionsPerHost on the underlying HttpConnectionManager */
+  public void setDefaultMaxConnectionsPerHost(int connections) {
+    getConnectionManager().getParams().setDefaultMaxConnectionsPerHost(connections);
+  }
+  
+  /** set maxTotalConnection on the underlying HttpConnectionManager */
+  public void setMaxTotalConnections(int connections) {
+    getConnectionManager().getParams().setMaxTotalConnections(connections);
+  }
+
+  /**
+   * set followRedirects.  This defaults to false under the
+   * assumption that if you are following a redirect to get to a Solr
+   * installation, something is misconfigured somewhere.
+   */
+  public void setFollowRedirects( boolean followRedirects ) {
+    _followRedirects = followRedirects;
+  }
+
+  /**
+   * set allowCompression.  If compression is enabled, both gzip and
+   * deflate compression will be accepted in the HTTP response.
+   */
+  public void setAllowCompression( boolean allowCompression ) {
+    _allowCompression = allowCompression;
+  }
+
+  /**
+   *  set maximum number of retries to attempt in the event of
+   *  transient errors.  Default: 0 (no) retries. No more than 1
+   *  recommended.
+   */
+  public void setMaxRetries( int maxRetries ) {
+    _maxRetries = maxRetries;
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/impl/XMLResponseParser.java b/src/solrj/org/apache/solr/client/solrj/impl/XMLResponseParser.java
new file mode 100644
index 0000000..318048f
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/impl/XMLResponseParser.java
@@ -0,0 +1,440 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.impl;
+
+import java.io.Reader;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+
+import org.apache.solr.client.solrj.ResponseParser;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class XMLResponseParser extends ResponseParser
+{
+  public static Logger log = LoggerFactory.getLogger(XMLResponseParser.class);
+
+  // reuse the factory among all parser instances so things like string caches
+  // won't be duplicated
+  static final XMLInputFactory factory;
+  static {
+    factory = XMLInputFactory.newInstance();
+    try {
+      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe
+      // XMLInputFactory, as that implementation tries to cache and reuse the
+      // XMLStreamReader.  Setting the parser-specific "reuse-instance" property to false
+      // prevents this.
+      // All other known open-source stax parsers (and the bea ref impl)
+      // have thread-safe factories.
+      factory.setProperty("reuse-instance", Boolean.FALSE);
+    }
+    catch( IllegalArgumentException ex ) {
+      // Other implementations will likely throw this exception since "reuse-instance"
+      // isimplementation specific.
+      log.debug( "Unable to set the 'reuse-instance' property for the input factory: "+factory );
+    }
+  }
+
+  public XMLResponseParser() {}
+  
+  @Override
+  public String getWriterType()
+  {
+    return "xml";
+  }
+
+  @Override
+  public NamedList<Object> processResponse(Reader in) {
+    XMLStreamReader parser = null;
+    try {
+      parser = factory.createXMLStreamReader(in);
+    } catch (XMLStreamException e) {
+      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
+    }
+
+    return processResponse(parser);    
+  }
+
+  @Override
+  public NamedList<Object> processResponse(InputStream in, String encoding)
+  {
+     XMLStreamReader parser = null;
+    try {
+      parser = factory.createXMLStreamReader(in, encoding);
+    } catch (XMLStreamException e) {
+      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", e);
+    }
+
+    return processResponse(parser);
+  }
+
+  /**
+   * parse the text into a named list...
+   */
+  private NamedList<Object> processResponse(XMLStreamReader parser)
+  {
+    try {
+      NamedList<Object> response = null;
+      for (int event = parser.next();  
+       event != XMLStreamConstants.END_DOCUMENT;
+       event = parser.next()) 
+      {
+        switch (event) {
+          case XMLStreamConstants.START_ELEMENT:
+
+            if( response != null ) {
+              throw new Exception( "already read the response!" );
+            }
+            
+            // only top-level element is "response
+            String name = parser.getLocalName();
+            if( name.equals( "response" ) || name.equals( "result" ) ) {
+              response = readNamedList( parser );
+            }
+            else if( name.equals( "solr" ) ) {
+              return new SimpleOrderedMap<Object>();
+            }
+            else {
+              throw new Exception( "really needs to be response or result.  " +
+                  "not:"+parser.getLocalName() );
+            }
+            break;
+        } 
+      } 
+      return response;
+    }
+    catch( Exception ex ) {
+      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "parsing error", ex );
+    }
+    finally {
+      try {
+        parser.close();
+      }
+      catch( Exception ex ){}
+    }
+  }
+
+  
+  protected enum KnownType {
+    STR    (true)  { @Override public String  read( String txt ) { return txt;                  } },
+    INT    (true)  { @Override public Integer read( String txt ) { return Integer.valueOf(txt); } },
+    FLOAT  (true)  { @Override public Float   read( String txt ) { return Float.valueOf(txt);   } },
+    DOUBLE (true)  { @Override public Double  read( String txt ) { return Double.valueOf(txt);  } },
+    LONG   (true)  { @Override public Long    read( String txt ) { return Long.valueOf(txt);    } },
+    BOOL   (true)  { @Override public Boolean read( String txt ) { return Boolean.valueOf(txt); } },
+    NULL   (true)  { @Override public Object  read( String txt ) { return null;                 } },
+    DATE   (true)  { 
+      @Override 
+      public Date read( String txt ) { 
+        try {
+          return ClientUtils.parseDate(txt);      
+        }
+        catch( Exception ex ) {
+          ex.printStackTrace();
+        }
+        return null;
+      } 
+    },
+    
+    ARR    (false) { @Override public Object read( String txt ) { return null; } },
+    LST    (false) { @Override public Object read( String txt ) { return null; } },
+    RESULT (false) { @Override public Object read( String txt ) { return null; } },
+    DOC    (false) { @Override public Object read( String txt ) { return null; } };
+    
+    final boolean isLeaf;
+    
+    KnownType( boolean isLeaf )
+    {
+      this.isLeaf = isLeaf;
+    }
+    
+    public abstract Object read( String txt );
+    
+    public static KnownType get( String v )
+    {
+      if( v != null ) {
+        try {
+          return KnownType.valueOf( v.toUpperCase() );
+        }
+        catch( Exception ex ) {}
+      }
+      return null;
+    }
+  };
+  
+  protected NamedList<Object> readNamedList( XMLStreamReader parser ) throws XMLStreamException
+  {
+    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
+      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
+    }
+
+    StringBuilder builder = new StringBuilder();
+    NamedList<Object> nl = new SimpleOrderedMap<Object>();
+    KnownType type = null;
+    String name = null;
+    
+    // just eat up the events...
+    int depth = 0;
+    while( true ) 
+    {
+      switch (parser.next()) {
+      case XMLStreamConstants.START_ELEMENT:
+        depth++;
+        builder.setLength( 0 ); // reset the text
+        type = KnownType.get( parser.getLocalName() );
+        if( type == null ) {
+          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
+        }
+        
+        name = null;
+        int cnt = parser.getAttributeCount();
+        for( int i=0; i<cnt; i++ ) {
+          if( "name".equals( parser.getAttributeLocalName( i ) ) ) {
+            name = parser.getAttributeValue( i );
+            break;
+          }
+        }
+        
+        if( name == null ) {
+          throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );
+        }
+        
+        if( !type.isLeaf ) {
+          switch( type ) {
+          case LST:    nl.add( name, readNamedList( parser ) ); depth--; continue;
+          case ARR:    nl.add( name, readArray(     parser ) ); depth--; continue;
+          case RESULT: nl.add( name, readDocuments( parser ) ); depth--; continue;
+          case DOC:    nl.add( name, readDocument(  parser ) ); depth--; continue;
+          }
+          throw new XMLStreamException( "branch element not handled!", parser.getLocation() );
+        }
+        break;
+        
+      case XMLStreamConstants.END_ELEMENT:
+        if( --depth < 0 ) {
+          return nl;
+        }
+        //System.out.println( "NL:ELEM:"+type+"::"+name+"::"+builder );
+        nl.add( name, type.read( builder.toString().trim() ) );
+        break;
+
+      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
+      case XMLStreamConstants.CDATA:
+      case XMLStreamConstants.CHARACTERS:
+        builder.append( parser.getText() );
+        break;
+      }
+    }
+  }
+
+  protected List<Object> readArray( XMLStreamReader parser ) throws XMLStreamException
+  {
+    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
+      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
+    }
+    if( !"arr".equals( parser.getLocalName().toLowerCase() ) ) {
+      throw new RuntimeException( "must be 'arr', not: "+parser.getLocalName() );
+    }
+    
+    StringBuilder builder = new StringBuilder();
+    KnownType type = null;
+
+    List<Object> vals = new ArrayList<Object>();
+
+    int depth = 0;
+    while( true ) 
+    {
+      switch (parser.next()) {
+      case XMLStreamConstants.START_ELEMENT:
+        depth++;
+        KnownType t = KnownType.get( parser.getLocalName() );
+        if( t == null ) {
+          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
+        }
+        if( type == null ) {
+          type = t;
+        }
+        /*** actually, there is no rule that arrays need the same type
+        else if( type != t && !(t == KnownType.NULL || type == KnownType.NULL)) {
+          throw new RuntimeException( "arrays must have the same type! ("+type+"!="+t+") "+parser.getLocalName() );
+        }
+        ***/
+        type = t;
+
+        builder.setLength( 0 ); // reset the text
+        
+        if( !type.isLeaf ) {
+          switch( type ) {
+          case LST:    vals.add( readNamedList( parser ) ); continue;
+          case ARR:    vals.add( readArray( parser ) ); continue;
+          case RESULT: vals.add( readDocuments( parser ) ); continue;
+          case DOC:    vals.add( readDocument( parser ) ); continue;
+          }
+          throw new XMLStreamException( "branch element not handled!", parser.getLocation() );
+        }
+        break;
+        
+      case XMLStreamConstants.END_ELEMENT:
+        if( --depth < 0 ) {
+          return vals; // the last element is itself
+        }
+        //System.out.println( "ARR:"+type+"::"+builder );
+        Object val = type.read( builder.toString().trim() );
+        if( val == null && type != KnownType.NULL) {
+          throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );
+        }
+        vals.add( val );
+        break;
+
+      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
+      case XMLStreamConstants.CDATA:
+      case XMLStreamConstants.CHARACTERS:
+        builder.append( parser.getText() );
+        break;
+    }
+    }
+  }
+  
+  protected SolrDocumentList readDocuments( XMLStreamReader parser ) throws XMLStreamException
+  {
+    SolrDocumentList docs = new SolrDocumentList();
+
+    // Parse the attributes
+    for( int i=0; i<parser.getAttributeCount(); i++ ) {
+      String n = parser.getAttributeLocalName( i );
+      String v = parser.getAttributeValue( i );
+      if( "numFound".equals( n ) ) {
+        docs.setNumFound( Long.parseLong( v ) );
+      }
+      else if( "start".equals( n ) ) {
+        docs.setStart( Long.parseLong( v ) );
+      }
+      else if( "maxScore".equals( n ) ) {
+        docs.setMaxScore( Float.parseFloat( v ) );
+      }
+    }
+    
+    // Read through each document
+    int event;
+    while( true ) {
+      event = parser.next();
+      if( XMLStreamConstants.START_ELEMENT == event ) {
+        if( !"doc".equals( parser.getLocalName() ) ) {
+          throw new RuntimeException( "shoudl be doc! "+parser.getLocalName() + " :: " + parser.getLocation() );
+        }
+        docs.add( readDocument( parser ) );
+      }
+      else if ( XMLStreamConstants.END_ELEMENT == event ) {
+        return docs;  // only happens once
+      }
+    }
+  }
+
+  protected SolrDocument readDocument( XMLStreamReader parser ) throws XMLStreamException
+  {
+    if( XMLStreamConstants.START_ELEMENT != parser.getEventType() ) {
+      throw new RuntimeException( "must be start element, not: "+parser.getEventType() );
+    }
+    if( !"doc".equals( parser.getLocalName().toLowerCase() ) ) {
+      throw new RuntimeException( "must be 'lst', not: "+parser.getLocalName() );
+    }
+
+    SolrDocument doc = new SolrDocument();
+    StringBuilder builder = new StringBuilder();
+    KnownType type = null;
+    String name = null;
+    
+    // just eat up the events...
+    int depth = 0;
+    while( true ) 
+    {
+      switch (parser.next()) {
+      case XMLStreamConstants.START_ELEMENT:
+        depth++;
+        builder.setLength( 0 ); // reset the text
+        type = KnownType.get( parser.getLocalName() );
+        if( type == null ) {
+          throw new RuntimeException( "this must be known type! not: "+parser.getLocalName() );
+        }
+        
+        name = null;
+        int cnt = parser.getAttributeCount();
+        for( int i=0; i<cnt; i++ ) {
+          if( "name".equals( parser.getAttributeLocalName( i ) ) ) {
+            name = parser.getAttributeValue( i );
+            break;
+          }
+        }
+        
+        if( name == null ) {
+          throw new XMLStreamException( "requires 'name' attribute: "+parser.getLocalName(), parser.getLocation() );
+        }
+        
+        // Handle multi-valued fields
+        if( type == KnownType.ARR ) {
+          for( Object val : readArray( parser ) ) {
+            doc.addField( name, val );
+          }
+          depth--; // the array reading clears out the 'endElement'
+        }
+        else if( !type.isLeaf ) {
+          throw new XMLStreamException( "must be value or array", parser.getLocation() );
+        }
+        break;
+        
+      case XMLStreamConstants.END_ELEMENT:
+        if( --depth < 0 ) {
+          return doc;
+        }
+        //System.out.println( "FIELD:"+type+"::"+name+"::"+builder );
+        Object val = type.read( builder.toString().trim() );
+        if( val == null ) {
+          throw new XMLStreamException( "error reading value:"+type, parser.getLocation() );
+        }
+        doc.addField( name, val );
+        break;
+
+      case XMLStreamConstants.SPACE: // TODO?  should this be trimmed? make sure it only gets one/two space?
+      case XMLStreamConstants.CDATA:
+      case XMLStreamConstants.CHARACTERS:
+        builder.append( parser.getText() );
+        break;
+      }
+    }
+  }
+
+  
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/request/CoreAdminRequest.java b/src/solrj/org/apache/solr/client/solrj/request/CoreAdminRequest.java
new file mode 100644
index 0000000..c2a2389
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/CoreAdminRequest.java
@@ -0,0 +1,250 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.response.CoreAdminResponse;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.CoreAdminParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * This class is experimental and subject to change.
+ * @version $Id: CoreAdminRequest.java 606335 2007-12-21 22:23:39Z ryan $
+ * @since solr 1.3
+ */
+public class CoreAdminRequest extends SolrRequest
+{
+  protected String core = null;
+  protected String other = null;
+  protected CoreAdminParams.CoreAdminAction action = null;
+  
+  //a create core request
+  public static class Create extends CoreAdminRequest {
+    protected String instanceDir;
+    protected String configName = null;
+    protected String schemaName = null;
+    
+    public Create() {
+      action = CoreAdminAction.CREATE;
+    }
+    
+    public void setInstanceDir(String instanceDir) { this.instanceDir = instanceDir; }
+    public void setSchemaName(String schema) { this.schemaName = schema; }
+    public void setConfigName(String config) { this.configName = config; }
+    
+    public String getInstanceDir() { return instanceDir; }
+    public String getSchemaName()  { return schemaName; }
+    public String getConfigName()  { return configName; }
+    
+    @Override
+    public SolrParams getParams() {
+      if( action == null ) {
+        throw new RuntimeException( "no action specified!" );
+      }
+      ModifiableSolrParams params = new ModifiableSolrParams();
+      params.set( CoreAdminParams.ACTION, action.toString() );
+      if( action.equals(CoreAdminAction.CREATE) ) {
+        params.set( CoreAdminParams.NAME, core );
+      } else {
+        params.set( CoreAdminParams.CORE, core );
+      }
+      params.set( CoreAdminParams.INSTANCE_DIR, instanceDir);
+      if (configName != null) {
+        params.set( CoreAdminParams.CONFIG, configName);
+      }
+      if (schemaName != null) {
+        params.set( CoreAdminParams.SCHEMA, schemaName);
+      }
+      return params;
+    }
+  }
+    //a persist core request
+  public static class Persist extends CoreAdminRequest {
+    protected String fileName = null;
+    
+    public Persist() {
+      action = CoreAdminAction.PERSIST;
+    }
+    
+    public void setFileName(String name) {
+      fileName = name;
+    }
+    public String getFileName() {
+      return fileName;
+    }
+    @Override
+    public SolrParams getParams() {
+      if( action == null ) {
+        throw new RuntimeException( "no action specified!" );
+      }
+      ModifiableSolrParams params = new ModifiableSolrParams();
+      params.set( CoreAdminParams.ACTION, action.toString() );
+      if (fileName != null) {
+        params.set( CoreAdminParams.FILE, fileName);
+      }
+      return params;
+    }
+  }
+  
+  public CoreAdminRequest()
+  {
+    super( METHOD.GET, "/admin/cores" );
+  }
+
+  public CoreAdminRequest( String path )
+  {
+    super( METHOD.GET, path );
+  }
+
+  public final void setCoreName( String coreName )
+  {
+    this.core = coreName;
+  }
+
+  public final void setOtherCoreName( String otherCoreName )
+  {
+    this.other = otherCoreName;
+  }
+  
+  //---------------------------------------------------------------------------------------
+  //
+  //---------------------------------------------------------------------------------------
+
+  public void setAction( CoreAdminAction action )
+  {
+    this.action = action;
+  }
+
+  //---------------------------------------------------------------------------------------
+  //
+  //---------------------------------------------------------------------------------------
+
+  @Override
+  public SolrParams getParams() 
+  {
+    if( action == null ) {
+      throw new RuntimeException( "no action specified!" );
+    }
+    ModifiableSolrParams params = new ModifiableSolrParams();
+    params.set( CoreAdminParams.ACTION, action.toString() );
+    params.set( CoreAdminParams.CORE, core );
+    if (other != null) {
+      params.set(CoreAdminParams.OTHER, other);
+    }
+    return params;
+  }
+
+  //---------------------------------------------------------------------------------------
+  //
+  //---------------------------------------------------------------------------------------
+
+  @Override
+  public Collection<ContentStream> getContentStreams() throws IOException {
+    return null;
+  }
+
+  @Override
+  public CoreAdminResponse process(SolrServer server) throws SolrServerException, IOException 
+  {
+    long startTime = System.currentTimeMillis();
+    CoreAdminResponse res = new CoreAdminResponse();
+    res.setResponse( server.request( this ) );
+    res.setElapsedTime( System.currentTimeMillis()-startTime );
+    return res;
+  }
+
+  //---------------------------------------------------------------------------------------
+  //
+  //---------------------------------------------------------------------------------------
+
+  public static CoreAdminResponse reloadCore( String name, SolrServer server ) throws SolrServerException, IOException
+  {
+    CoreAdminRequest req = new CoreAdminRequest();
+    req.setCoreName( name );
+    req.setAction( CoreAdminAction.RELOAD );
+    return req.process( server );
+  }
+
+  public static CoreAdminResponse unloadCore( String name, SolrServer server ) throws SolrServerException, IOException
+  {
+    CoreAdminRequest req = new CoreAdminRequest();
+    req.setCoreName( name );
+    req.setAction( CoreAdminAction.UNLOAD );
+    return req.process( server );
+  }  
+
+  public static CoreAdminResponse renameCore(String coreName, String newName, SolrServer server ) throws SolrServerException, IOException
+  {
+    CoreAdminRequest req = new CoreAdminRequest();
+    req.setCoreName(coreName);
+    req.setOtherCoreName(newName);
+    req.setAction( CoreAdminAction.RENAME );
+    return req.process( server );
+  }
+
+  public static CoreAdminResponse aliasCore(String coreName, String newName, SolrServer server ) throws SolrServerException, IOException
+  {
+    CoreAdminRequest req = new CoreAdminRequest();
+    req.setCoreName(coreName);
+    req.setOtherCoreName(newName);
+    req.setAction( CoreAdminAction.ALIAS );
+    return req.process( server );
+  }
+
+  public static CoreAdminResponse getStatus( String name, SolrServer server ) throws SolrServerException, IOException
+  {
+    CoreAdminRequest req = new CoreAdminRequest();
+    req.setCoreName( name );
+    req.setAction( CoreAdminAction.STATUS );
+    return req.process( server );
+  }
+  
+  public static CoreAdminResponse createCore( String name, String instanceDir, SolrServer server ) throws SolrServerException, IOException 
+  {
+    return CoreAdminRequest.createCore(name, instanceDir, server, null, null);
+  }
+  
+  public static CoreAdminResponse createCore( String name, String instanceDir, SolrServer server, String configFile, String schemaFile ) throws SolrServerException, IOException 
+  {
+    CoreAdminRequest.Create req = new CoreAdminRequest.Create();
+    req.setCoreName( name );
+    req.setInstanceDir(instanceDir);
+    if(configFile != null){
+      req.setConfigName(configFile);
+    }
+    if(schemaFile != null){
+      req.setSchemaName(schemaFile);
+    }
+    return req.process( server );
+  }
+
+  public static CoreAdminResponse persist(String fileName, SolrServer server) throws SolrServerException, IOException 
+  {
+    CoreAdminRequest.Persist req = new CoreAdminRequest.Persist();
+    req.setFileName(fileName);
+    return req.process(server);
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/request/DirectXmlRequest.java b/src/solrj/org/apache/solr/client/solrj/request/DirectXmlRequest.java
new file mode 100644
index 0000000..0f10300
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/DirectXmlRequest.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * Send arbitrary XML to a request handler
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class DirectXmlRequest extends SolrRequest
+{
+  final String xml;
+  
+  public DirectXmlRequest( String path, String body )
+  {
+    super( METHOD.POST, path );
+    xml = body;
+  }
+
+  @Override
+  public Collection<ContentStream> getContentStreams() {
+    return ClientUtils.toContentStreams( xml, ClientUtils.TEXT_XML );
+  }
+
+  @Override
+  public SolrParams getParams() {
+    return null;
+  }
+
+  @Override
+  public UpdateResponse process( SolrServer server ) throws SolrServerException, IOException
+  {
+    long startTime = System.currentTimeMillis();
+    UpdateResponse res = new UpdateResponse();
+    res.setResponse( server.request( this ) );
+    res.setElapsedTime( System.currentTimeMillis()-startTime );
+    return res;
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/request/LukeRequest.java b/src/solrj/org/apache/solr/client/solrj/request/LukeRequest.java
new file mode 100644
index 0000000..3109203
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/LukeRequest.java
@@ -0,0 +1,126 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.response.LukeResponse;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class LukeRequest extends SolrRequest
+{
+  private List<String> fields;
+  private int numTerms = -1;
+  private boolean showSchema = false;
+  
+  public LukeRequest()
+  {
+    super( METHOD.GET, "/admin/luke" );
+  }
+
+  public LukeRequest( String path )
+  {
+    super( METHOD.GET, path );
+  }
+
+  //---------------------------------------------------------------------------------
+  //---------------------------------------------------------------------------------
+  
+  public void addField( String f )
+  {
+    if( fields == null ) {
+      fields = new ArrayList<String>();
+    }
+    fields.add( f );
+  }
+
+  public void setFields( List<String> f )
+  {
+    fields = f;
+  }
+  
+  //---------------------------------------------------------------------------------
+  //---------------------------------------------------------------------------------
+  
+  public boolean isShowSchema() {
+    return showSchema;
+  }
+
+  public void setShowSchema(boolean showSchema) {
+    this.showSchema = showSchema;
+  }
+
+  public int getNumTerms() {
+    return numTerms;
+  }
+
+  /**
+   * the number of terms to return for a given field.  If the number is 0, it will not traverse the terms.  
+   */
+  public void setNumTerms(int count) {
+    this.numTerms = count;
+  }
+
+  //---------------------------------------------------------------------------------
+  //---------------------------------------------------------------------------------
+  
+  @Override
+  public Collection<ContentStream> getContentStreams() {
+    return null;
+  }
+
+  @Override
+  public SolrParams getParams() {
+    ModifiableSolrParams params = new ModifiableSolrParams();
+    if( fields != null && fields.size() > 0 ) {
+      params.add( CommonParams.FL, fields.toArray( new String[fields.size()] ) );
+    }
+    if( numTerms >= 0 ) {
+      params.add( "numTerms", numTerms+"" );
+    }
+    if (showSchema) {
+    	params.add("show", "schema");
+    }
+    return params;
+  }
+
+  @Override
+  public LukeResponse process( SolrServer server ) throws SolrServerException, IOException 
+  {
+    long startTime = System.currentTimeMillis();
+    LukeResponse res = new LukeResponse();
+    res.setResponse( server.request( this ) );
+    res.setElapsedTime( System.currentTimeMillis()-startTime );
+    return res;
+  }
+}
+
diff --git a/src/solrj/org/apache/solr/client/solrj/request/QueryRequest.java b/src/solrj/org/apache/solr/client/solrj/request/QueryRequest.java
new file mode 100644
index 0000000..2bbc581
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/QueryRequest.java
@@ -0,0 +1,100 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.util.Collection;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class QueryRequest extends SolrRequest
+{
+  private SolrParams query;
+  
+  public QueryRequest()
+  {
+    super( METHOD.GET, null );
+  }
+
+  public QueryRequest( SolrParams q )
+  {
+    super( METHOD.GET, null );
+    query = q;
+  }
+  
+  public QueryRequest( SolrParams q, METHOD method )
+  {
+    super( method, null );
+    query = q;
+  }
+
+  /**
+   * Use the params 'QT' parameter if it exists
+   */
+  @Override
+  public String getPath() {
+    String qt = query.get( CommonParams.QT );
+    if( qt == null ) {
+      qt = super.getPath();
+    }
+    if( qt != null && qt.startsWith( "/" ) ) {
+      return qt;
+    }
+    return "/select";
+  }
+  
+  //---------------------------------------------------------------------------------
+  //---------------------------------------------------------------------------------
+  
+  @Override
+  public Collection<ContentStream> getContentStreams() {
+    return null;
+  }
+
+  @Override
+  public SolrParams getParams() {
+    return query;
+  }
+
+  @Override
+  public QueryResponse process( SolrServer server ) throws SolrServerException 
+  {
+    try 
+    {
+      long startTime = System.currentTimeMillis();
+      QueryResponse res = new QueryResponse( server.request( this ), server );
+      res.setElapsedTime( System.currentTimeMillis()-startTime );
+      return res;
+    } 
+    catch (Exception e) 
+    {
+      throw new SolrServerException("Error executing query", e);
+    }
+  }
+}
+
diff --git a/src/solrj/org/apache/solr/client/solrj/request/SolrPing.java b/src/solrj/org/apache/solr/client/solrj/request/SolrPing.java
new file mode 100644
index 0000000..16c7e17
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/SolrPing.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.response.SolrPingResponse;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.util.ContentStream;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrPing extends SolrRequest
+{
+  private ModifiableSolrParams params;
+  
+  public SolrPing()
+  {
+    super( METHOD.GET, "/admin/ping" );
+    params = new ModifiableSolrParams();
+  }
+
+  @Override
+  public Collection<ContentStream> getContentStreams() {
+    return null;
+  }
+
+  @Override
+  public ModifiableSolrParams getParams() {
+    return params;
+  }
+
+  @Override
+  public SolrPingResponse process( SolrServer server ) throws SolrServerException, IOException 
+  {
+    long startTime = System.currentTimeMillis();
+    SolrPingResponse res = new SolrPingResponse();
+    res.setResponse( server.request( this ) );
+    res.setElapsedTime( System.currentTimeMillis()-startTime );
+    return res;
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/request/UpdateRequest.java b/src/solrj/org/apache/solr/client/solrj/request/UpdateRequest.java
new file mode 100644
index 0000000..55599e1
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/request/UpdateRequest.java
@@ -0,0 +1,273 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.request;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.UpdateParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.XML;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class UpdateRequest extends SolrRequest
+{
+  public enum ACTION {
+    COMMIT,
+    OPTIMIZE
+  };
+  
+  private List<SolrInputDocument> documents = null;
+  private List<String> deleteById = null;
+  private List<String> deleteQuery = null;
+
+  private ModifiableSolrParams params;
+  private int commitWithin = -1;
+  
+  public UpdateRequest()
+  {
+    super( METHOD.POST, "/update" );
+  }
+
+  public UpdateRequest(String url) {
+    super(METHOD.POST, url);
+  }
+
+  //---------------------------------------------------------------------------
+  //---------------------------------------------------------------------------
+  
+  /**
+   * clear the pending documents and delete commands
+   */
+  public void clear()
+  {
+    if( documents != null ) {
+      documents.clear();
+    }
+    if( deleteById != null ) {
+      deleteById.clear();
+    }
+    if( deleteQuery != null ) {
+      deleteQuery.clear();
+    }
+  }
+  
+  //---------------------------------------------------------------------------
+  //---------------------------------------------------------------------------
+  
+  public UpdateRequest add( final SolrInputDocument doc )
+  {
+    if( documents == null ) {
+      documents = new ArrayList<SolrInputDocument>( 2 );
+    }
+    documents.add( doc );
+    return this;
+  }
+  
+  public UpdateRequest add( final Collection<SolrInputDocument> docs )
+  {
+    if( documents == null ) {
+      documents = new ArrayList<SolrInputDocument>( docs.size()+1 );
+    }
+    documents.addAll( docs );
+    return this;
+  }
+  
+  public UpdateRequest deleteById( String id )
+  {
+    if( deleteById == null ) {
+      deleteById = new ArrayList<String>();
+    }
+    deleteById.add( id );
+    return this;
+  }
+  
+  public UpdateRequest deleteByQuery( String q )
+  {
+    if( deleteQuery == null ) {
+      deleteQuery = new ArrayList<String>();
+    }
+    deleteQuery.add( q );
+    return this;
+  }
+
+  /** Sets appropriate parameters for the given ACTION */
+  public UpdateRequest setAction(ACTION action, boolean waitFlush, boolean waitSearcher ) {
+    return setAction(action, waitFlush, waitSearcher, 1);
+  }
+
+  public UpdateRequest setAction(ACTION action, boolean waitFlush, boolean waitSearcher, int maxSegments ) {
+    if (params == null)
+      params = new ModifiableSolrParams();
+
+    if( action == ACTION.OPTIMIZE ) {
+      params.set( UpdateParams.OPTIMIZE, "true" );
+      params.set(UpdateParams.MAX_OPTIMIZE_SEGMENTS, maxSegments);
+    }
+    else if( action == ACTION.COMMIT ) {
+      params.set( UpdateParams.COMMIT, "true" );
+    }
+    params.set( UpdateParams.WAIT_FLUSH, waitFlush+"" );
+    params.set( UpdateParams.WAIT_SEARCHER, waitSearcher+"" );
+    return this;
+  }
+
+  /**
+   * @since Solr 1.4
+   */
+  public UpdateRequest rollback() {
+    if (params == null)
+      params = new ModifiableSolrParams();
+
+    params.set( UpdateParams.ROLLBACK, "true" );
+    return this;
+  }
+  
+
+  public void setParam(String param, String value) {
+    if (params == null)
+      params = new ModifiableSolrParams();
+    params.set(param, value);
+  }
+
+  /** Sets the parameters for this update request, overwriting any previous */
+  public void setParams(ModifiableSolrParams params) {
+    this.params = params;
+  }
+
+  //--------------------------------------------------------------------------
+  //--------------------------------------------------------------------------
+
+  @Override
+  public Collection<ContentStream> getContentStreams() throws IOException {
+    return ClientUtils.toContentStreams( getXML(), ClientUtils.TEXT_XML );
+  }
+  
+  public String getXML() throws IOException {
+    StringWriter writer = new StringWriter();
+    if( documents != null && documents.size() > 0 ) {
+      if( commitWithin > 0 ) {
+        writer.write("<add commitWithin=\""+commitWithin+"\">");
+      }
+      else {
+        writer.write("<add>");
+      }
+      for (SolrInputDocument doc : documents ) {
+        if( doc != null ) {
+          ClientUtils.writeXML( doc, writer );
+        }
+      }
+      writer.write("</add>");
+    }
+    
+    // Add the delete commands
+    boolean deleteI = deleteById != null && deleteById.size() > 0;
+    boolean deleteQ = deleteQuery != null && deleteQuery.size() > 0;
+    if( deleteI || deleteQ ) {
+      writer.append( "<delete>" );
+      if( deleteI ) {
+        for( String id : deleteById ) {
+          writer.append( "<id>" );
+          XML.escapeCharData( id, writer );
+          writer.append( "</id>" );
+        }
+      }
+      if( deleteQ ) {
+        for( String q : deleteQuery ) {
+          writer.append( "<query>" );
+          XML.escapeCharData( q, writer );
+          writer.append( "</query>" );
+        }
+      }
+      writer.append( "</delete>" );
+    }
+    
+    // If action is COMMIT or OPTIMIZE, it is sent with params
+    String xml = writer.toString();
+    //System.out.println( "SEND:"+xml );
+    return (xml.length() > 0) ? xml : null;
+  }
+
+
+  //--------------------------------------------------------------------------
+  //--------------------------------------------------------------------------
+
+  @Override
+  public ModifiableSolrParams getParams() {
+    return params;
+  }
+  
+  @Override
+  public UpdateResponse process( SolrServer server ) throws SolrServerException, IOException
+  {
+    long startTime = System.currentTimeMillis();
+    UpdateResponse res = new UpdateResponse();
+    res.setResponse( server.request( this ) );
+    res.setElapsedTime( System.currentTimeMillis()-startTime );
+    return res;
+  }
+  
+  //--------------------------------------------------------------------------
+  // 
+  //--------------------------------------------------------------------------
+
+  public boolean isWaitFlush() {
+    return params != null && params.getBool(UpdateParams.WAIT_FLUSH, false);
+  }
+
+  public boolean isWaitSearcher() {
+    return params != null && params.getBool(UpdateParams.WAIT_SEARCHER, false);
+  }
+
+  public ACTION getAction() {
+    if (params==null) return null;
+    if (params.getBool(UpdateParams.COMMIT, false)) return ACTION.COMMIT; 
+    if (params.getBool(UpdateParams.OPTIMIZE, false)) return ACTION.OPTIMIZE;
+    return null;
+  }
+
+  public void setWaitFlush(boolean waitFlush) {
+    setParam( UpdateParams.WAIT_FLUSH, waitFlush+"" );
+  }
+
+  public void setWaitSearcher(boolean waitSearcher) {
+    setParam( UpdateParams.WAIT_SEARCHER, waitSearcher+"" );
+  }
+
+  public int getCommitWithin() {
+    return commitWithin;
+  }
+
+  public void setCommitWithin(int commitWithin) {
+    this.commitWithin = commitWithin;
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/CoreAdminResponse.java b/src/solrj/org/apache/solr/client/solrj/response/CoreAdminResponse.java
new file mode 100644
index 0000000..7034402
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/CoreAdminResponse.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import java.util.Date;
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class CoreAdminResponse extends SolrResponseBase
+{ 
+  @SuppressWarnings("unchecked")
+  public NamedList<NamedList<Object>> getCoreStatus()
+  {
+    return (NamedList<NamedList<Object>>) getResponse().get( "status" );
+  }
+
+  public NamedList<Object> getCoreStatus( String core )
+  {
+    return getCoreStatus().get( core );
+  }
+  
+  public Date getStartTime( String core )
+  {
+    NamedList<Object> v = getCoreStatus( core );
+    if( v == null ) {
+      return null;
+    }
+    return (Date) v.get( "startTime" );
+  }
+  
+  public Long getUptime( String core )
+  {
+    NamedList<Object> v = getCoreStatus( core );
+    if( v == null ) {
+      return null;
+    }
+    return (Long) v.get( "uptime" );
+  }
+}
\ No newline at end of file
diff --git a/src/solrj/org/apache/solr/client/solrj/response/FacetField.java b/src/solrj/org/apache/solr/client/solrj/response/FacetField.java
new file mode 100644
index 0000000..bbfaa47
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/FacetField.java
@@ -0,0 +1,176 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import org.apache.solr.client.solrj.util.ClientUtils;
+ 
+ /**
+  * A utility class to hold the facet response.  It could use the NamedList container,
+  * but for JSTL, it is nice to have something that implements List so it can be iterated
+  * 
+  * @version $Id$
+  * @since solr 1.3
+  */
+ public class FacetField implements Serializable
+ {
+   public static class Count implements Serializable 
+   {
+     private String _name = null;
+     private long _count = 0;
+     // hang onto the FacetField for breadcrumb creation convenience
+     private FacetField _ff = null;
+     
+     public Count( FacetField ff, String n, long c )
+     {
+       _name = n;
+       _count = c;
+       _ff = ff;
+     }
+     
+     public String getName() {
+       return _name;
+     }
+     
+     public void setName( String n )
+     {
+       _name = n;
+     }
+
+     public long getCount() {
+       return _count;
+     }
+     
+     public void setCount( long c )
+     {
+       _count = c;
+     }
+     
+     public FacetField getFacetField() {
+       return _ff;
+     }
+     
+     @Override
+     public String toString()
+     {
+       return _name+" ("+_count+")";
+     }
+     
+     public String getAsFilterQuery() {
+       if (_ff.getName().equals("facet_queries")) {
+         return _name;
+       }
+       return 
+          ClientUtils.escapeQueryChars( _ff._name ) + ":" + 
+          ClientUtils.escapeQueryChars( _name );
+     }
+   }
+   
+   private String      _name   = null;
+   private List<Count> _values = null;
+   private String _gap = null;
+   private Date _end = null;
+   
+   public FacetField( final String n )
+   {
+     _name = n;
+   }
+   
+   public FacetField(String name, String gap, Date end) {
+     _name = name;
+     _gap = gap;
+     _end = end;
+   }
+   
+   /**
+    * Date Gap Facet parameter
+    * 
+    * @return the value specified for facet.date.gap
+    */
+   public String getGap()   {
+     return _gap;
+   }
+   
+   /**
+    * Date End Facet parameter
+    * 
+    * @return the value specified for facet.date.end
+    */
+   public Date getEnd() {
+     return _end;
+   }
+
+   /**
+    * Insert at the end of the list
+    */
+   public void add( String name, long cnt )
+   {
+     if( _values == null ) {
+       _values = new ArrayList<Count>( 30 );
+     }
+     _values.add( new Count( this, name, cnt ) );
+   }
+
+   /**
+    * Insert at the beginning of the list.
+    */
+   public void insert( String name, long cnt )
+   {
+     if( _values == null ) {
+       _values = new ArrayList<Count>( 30 );
+     }
+     _values.add( 0, new Count( this, name, cnt ) );
+   }
+
+   public String getName() {
+     return _name;
+   }
+
+   public List<Count> getValues() {
+     return _values;
+   }
+   
+   public int getValueCount()
+   {
+     return _values == null ? 0 : _values.size();
+   }
+
+   public FacetField getLimitingFields(long max) 
+   {
+     FacetField ff = new FacetField( _name );
+     if( _values != null ) {
+       ff._values = new ArrayList<Count>( _values.size() );
+       for( Count c : _values ) {
+         if( c._count < max ) { // !equal to
+           ff._values.add( c );
+         }
+       }
+     }
+     return ff;
+   }
+   
+   @Override
+   public String toString()
+   {
+     return _name + ":" + _values;
+   }
+ }
diff --git a/src/solrj/org/apache/solr/client/solrj/response/FieldStatsInfo.java b/src/solrj/org/apache/solr/client/solrj/response/FieldStatsInfo.java
new file mode 100644
index 0000000..2516160
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/FieldStatsInfo.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.response;
+
+import org.apache.solr.common.util.NamedList;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Holds stats info
+ *
+ * @version $Id: SpellCheckResponse.java 693622 2008-09-09 21:21:06Z gsingers $
+ * @since solr 1.4
+ */
+public class FieldStatsInfo implements Serializable {
+  final String name;
+  
+  Double min;
+  Double max;
+  Double sum;
+  Long count;
+  Long missing;
+  Double mean = null;
+  Double sumOfSquares = null;
+  Double stddev = null;
+  Double median = null;
+  
+  Map<String,List<FieldStatsInfo>> facets;
+  
+  public FieldStatsInfo( NamedList<Object> nl, String fname )
+  {
+    name = fname;
+    
+    for( Map.Entry<String, Object> entry : nl ) {
+      if( "min".equals( entry.getKey() ) ) {
+        min = (Double)entry.getValue();
+      }
+      else if( "max".equals( entry.getKey() ) ) {
+        max = (Double)entry.getValue();
+      }
+      else if( "sum".equals( entry.getKey() ) ) {
+        sum = (Double)entry.getValue();
+      }
+      else if( "count".equals( entry.getKey() ) ) {
+        count = (Long)entry.getValue();
+      }
+      else if( "missing".equals( entry.getKey() ) ) {
+        missing = (Long)entry.getValue();
+      }
+      else if( "mean".equals( entry.getKey() ) ) {
+        mean = (Double)entry.getValue();
+      }
+      else if( "sumOfSquares".equals( entry.getKey() ) ) {
+        sumOfSquares = (Double)entry.getValue();
+      }
+      else if( "stddev".equals( entry.getKey() ) ) {
+        stddev = (Double)entry.getValue();
+      }
+      else if( "median".equals( entry.getKey() ) ) {
+        median = (Double)entry.getValue();
+      }
+      else if( "facets".equals( entry.getKey() ) ) {
+        NamedList<Object> fields = (NamedList<Object>)entry.getValue();
+        facets = new HashMap<String, List<FieldStatsInfo>>();
+        for( Map.Entry<String, Object> ev : fields ) {
+          List<FieldStatsInfo> vals = new ArrayList<FieldStatsInfo>();
+          facets.put( ev.getKey(), vals );
+          NamedList<NamedList<Object>> vnl = (NamedList<NamedList<Object>>) ev.getValue();
+          for( int i=0; i<vnl.size(); i++ ) {
+            String n = vnl.getName(i);
+            vals.add( new FieldStatsInfo( vnl.getVal(i), n ) );
+          }
+        }
+      }
+      else {
+        throw new RuntimeException( "unknown key: "+entry.getKey() + " ["+entry.getValue()+"]" );
+      }
+    }
+  }
+  
+  public String toString()
+  {
+    StringBuilder sb = new StringBuilder();
+    sb.append( name );
+    sb.append( ": {" );
+    if( min != null ) {
+      sb.append( " min:").append( min );
+    }
+    if( max != null ) {
+      sb.append( " max:").append( max );
+    }
+    if( sum != null ) {
+      sb.append( " sum:").append( sum );
+    }
+    if( count != null ) {
+      sb.append( " count:").append( count );
+    }
+    if( missing != null ) {
+      sb.append( " missing:").append( missing );
+    }
+    if( mean != null ) {
+      sb.append( " mean:").append( mean );
+    }
+    if( median != null ) {
+      sb.append( " median:").append(median);
+    }
+    if( stddev != null ) {
+      sb.append( " stddev:").append(stddev);
+    }
+    sb.append( " }" );
+    return sb.toString();
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public Double getMin() {
+    return min;
+  }
+
+  public Double getMax() {
+    return max;
+  }
+
+  public Double getSum() {
+    return sum;
+  }
+
+  public Long getCount() {
+    return count;
+  }
+
+  public Long getMissing() {
+    return missing;
+  }
+
+  public Double getMean() {
+    return mean;
+  }
+
+  public Double getStddev() {
+    return stddev;
+  }
+
+  public Double getMedian() {
+    return median;
+  }
+
+  public Map<String, List<FieldStatsInfo>> getFacets() {
+    return facets;
+  }
+  
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/LukeResponse.java b/src/solrj/org/apache/solr/client/solrj/response/LukeResponse.java
new file mode 100644
index 0000000..4e4877c
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/LukeResponse.java
@@ -0,0 +1,270 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import org.apache.solr.common.luke.FieldFlag;
+import org.apache.solr.common.util.NamedList;
+
+import java.io.Serializable;
+import java.util.*;
+
+
+/**
+ * This is an incomplete representation of the data returned from Luke
+ *
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class LukeResponse extends SolrResponseBase {
+
+  public static class FieldTypeInfo implements Serializable {
+    String name;
+    String className;
+    boolean tokenized;
+    String analyzer;
+    List<String> fields;
+
+
+    public FieldTypeInfo(String name) {
+      this.name = name;
+      fields = Collections.emptyList();
+    }
+
+
+    public String getAnalyzer() {
+      return analyzer;
+    }
+
+    public String getClassName() {
+      return className;
+    }
+
+    public List<String> getFields() {
+      return fields;
+    }
+
+    public String getName() {
+      return name;
+    }
+
+    public boolean isTokenized() {
+      return tokenized;
+    }/*
+     Sample:
+     types={ignored={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f94934},
+     integer={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@3525a2},
+     sfloat={fields=[price, weight],tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@39cf9c},
+     text_ws={fields=[cat],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@6d3ca2)},
+     alphaOnlySort={fields=[alphaNameSort],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.KeywordTokenizerFactory@a7bd3b,
+      org.apache.solr.analysis.LowerCaseFilterFactory@78aae2, org.apache.solr.analysis.TrimFilterFactory@1b16a7,
+      org.apache.solr.analysis.PatternReplaceFilterFactory@6c6b08)},date={fields=[timestamp],tokenized=false,
+      analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@e6e42e},sint={fields=[popularity],
+      tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@8ea21d},
+      boolean={fields=[inStock],tokenized=false,analyzer=org.apache.solr.schema.BoolField$1@354949},
+      textTight={fields=[sku],tokenized=true,analyzer=TokenizerChain(org.apache.solr.analysis.WhitespaceTokenizerFactory@5e88f7,
+       org.apache.solr.analysis.SynonymFilterFactory@723646, org.apache.solr.analysis.StopFilterFactory@492ff1,
+       org.apache.solr.analysis.WordDelimiterFilterFactory@eaabad, org.apache.solr.analysis.LowerCaseFilterFactory@ad1355,
+        org.apache.solr.analysis.EnglishPorterFilterFactory@d03a00, org.apache.solr.analysis.RemoveDuplicatesTokenFilterFactory@900079)},
+        long={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@f3b83},
+        double={fields=null,tokenized=false,analyzer=org.apache.solr.schema.FieldType$DefaultAnalyzer@c2b07},
+
+      */
+
+    @SuppressWarnings("unchecked")
+    public void read(NamedList<Object> nl) {
+      for (Map.Entry<String, Object> entry : nl) {
+        String key = entry.getKey();
+        if ("fields".equals(key) && entry.getValue() != null) {
+          List<String> theFields = (List<String>) entry.getValue();
+          fields = new ArrayList<String>(theFields);
+        } else if ("tokenized".equals(key) == true) {
+          tokenized = Boolean.parseBoolean(entry.getValue().toString());
+        } else if ("analyzer".equals(key) == true) {
+          analyzer = entry.getValue().toString();
+        } else if ("className".equals(key) == true) {
+          className = entry.getValue().toString();
+        }
+      }
+    }
+  }
+
+  public static class FieldInfo implements Serializable {
+    String name;
+    String type;
+    String schema;
+    int docs;
+    int distinct;
+    EnumSet<FieldFlag> flags;
+    boolean cacheableFaceting;
+    NamedList<Integer> topTerms;
+
+    public FieldInfo(String n) {
+      name = n;
+    }
+
+    @SuppressWarnings("unchecked")
+    public void read(NamedList<Object> nl) {
+      for (Map.Entry<String, Object> entry : nl) {
+        if ("type".equals(entry.getKey())) {
+          type = (String) entry.getValue();
+        }
+        if ("flags".equals(entry.getKey())) {
+          flags = parseFlags((String) entry.getValue());
+        } else if ("schema".equals(entry.getKey())) {
+          schema = (String) entry.getValue();
+        } else if ("docs".equals(entry.getKey())) {
+          docs = (Integer) entry.getValue();
+        } else if ("distinct".equals(entry.getKey())) {
+          distinct = (Integer) entry.getValue();
+        } else if ("cacheableFaceting".equals(entry.getKey())) {
+          cacheableFaceting = (Boolean) entry.getValue();
+        } else if ("topTerms".equals(entry.getKey())) {
+          topTerms = (NamedList<Integer>) entry.getValue();
+        }
+      }
+    }
+
+    public static EnumSet<FieldFlag> parseFlags(String flagStr) {
+      EnumSet<FieldFlag> result = EnumSet.noneOf(FieldFlag.class);
+      char[] chars = flagStr.toCharArray();
+      for (int i = 0; i < chars.length; i++) {
+        if (chars[i] != '-') {
+          FieldFlag flag = FieldFlag.getFlag(chars[i]);
+          result.add(flag);
+        }
+      }
+      return result;
+    }
+
+    public EnumSet<FieldFlag> getFlags() {
+      return flags;
+    }
+
+    public boolean isCacheableFaceting() {
+      return cacheableFaceting;
+    }
+
+    public String getType() {
+      return type;
+    }
+
+    public int getDistinct() {
+      return distinct;
+    }
+
+    public int getDocs() {
+      return docs;
+    }
+
+    public String getName() {
+      return name;
+    }
+
+    public String getSchema() {
+      return schema;
+    }
+
+    public NamedList<Integer> getTopTerms() {
+      return topTerms;
+    }
+  }
+
+  private NamedList<Object> indexInfo;
+  private Map<String, FieldInfo> fieldInfo;
+  private Map<String, FieldTypeInfo> fieldTypeInfo;
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public void setResponse(NamedList<Object> res) {
+    super.setResponse(res);
+
+    // Parse indexinfo
+    indexInfo = (NamedList<Object>) res.get("index");
+
+    NamedList<Object> schema = (NamedList<Object>) res.get("schema");
+    NamedList<Object> flds = (NamedList<Object>) res.get("fields");
+    if (flds == null && schema != null ) {
+      flds = (NamedList<Object>) schema.get("fields");
+    }
+    if (flds != null) {
+      fieldInfo = new HashMap<String, FieldInfo>();
+      for (Map.Entry<String, Object> field : flds) {
+        FieldInfo f = new FieldInfo(field.getKey());
+        f.read((NamedList<Object>) field.getValue());
+        fieldInfo.put(field.getKey(), f);
+      }
+    }
+
+    if( schema != null ) {
+      NamedList<Object> fldTypes = (NamedList<Object>) schema.get("types");
+      if (fldTypes != null) {
+        fieldTypeInfo = new HashMap<String, FieldTypeInfo>();
+        for (Map.Entry<String, Object> fieldType : fldTypes) {
+          FieldTypeInfo ft = new FieldTypeInfo(fieldType.getKey());
+          ft.read((NamedList<Object>) fieldType.getValue());
+          fieldTypeInfo.put(fieldType.getKey(), ft);
+        }
+      }
+    }
+  }
+
+  //----------------------------------------------------------------
+  //----------------------------------------------------------------
+
+  public String getIndexDirectory() {
+    if (indexInfo == null) return null;
+    return (String) indexInfo.get("directory");
+  }
+
+  public Integer getNumDocs() {
+    if (indexInfo == null) return null;
+    return (Integer) indexInfo.get("numDocs");
+  }
+
+  public Integer getMaxDoc() {
+    if (indexInfo == null) return null;
+    return (Integer) indexInfo.get("maxDoc");
+  }
+
+  public Integer getNumTerms() {
+    if (indexInfo == null) return null;
+    return (Integer) indexInfo.get("numTerms");
+  }
+
+  public Map<String, FieldTypeInfo> getFieldTypeInfo() {
+    return fieldTypeInfo;
+  }
+
+  public FieldTypeInfo getFieldTypeInfo(String name) {
+    return fieldTypeInfo.get(name);
+  }
+
+  public NamedList<Object> getIndexInfo() {
+    return indexInfo;
+  }
+
+  public Map<String, FieldInfo> getFieldInfo() {
+    return fieldInfo;
+  }
+
+  public FieldInfo getFieldInfo(String f) {
+    return fieldInfo.get(f);
+  }
+
+  //----------------------------------------------------------------
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/QueryResponse.java b/src/solrj/org/apache/solr/client/solrj/response/QueryResponse.java
new file mode 100644
index 0000000..25a6ff5
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/QueryResponse.java
@@ -0,0 +1,320 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+@SuppressWarnings("unchecked")
+public class QueryResponse extends SolrResponseBase 
+{
+  // Direct pointers to known types
+  private NamedList<Object> _header = null;
+  private SolrDocumentList _results = null;
+  private NamedList<ArrayList> _sortvalues = null;
+  private NamedList<Object> _facetInfo = null;
+  private NamedList<Object> _debugInfo = null;
+  private NamedList<Object> _highlightingInfo = null;
+  private NamedList<Object> _spellInfo = null;
+  private NamedList<Object> _statsInfo = null;
+
+  // Facet stuff
+  private Map<String,Integer> _facetQuery = null;
+  private List<FacetField> _facetFields = null;
+  private List<FacetField> _limitingFacets = null;
+  private List<FacetField> _facetDates = null;
+
+  // Highlight Info
+  private Map<String,Map<String,List<String>>> _highlighting = null;
+
+  // SpellCheck Response
+  private SpellCheckResponse _spellResponse = null;
+
+  // Field stats Response
+  private Map<String,FieldStatsInfo> _fieldStatsInfo = null;
+  
+  // Debug Info
+  private Map<String,Object> _debugMap = null;
+  private Map<String,String> _explainMap = null;
+
+  // utility variable used for automatic binding -- it should not be serialized
+  private transient final SolrServer solrServer;
+  
+  public QueryResponse(){
+    solrServer = null;
+  }
+  
+  /**
+   * Utility constructor to set the solrServer and namedList
+   */
+  public QueryResponse( NamedList<Object> res , SolrServer solrServer){
+    this.setResponse( res );
+    this.solrServer = solrServer;
+  }
+
+  @Override
+  public void setResponse( NamedList<Object> res )
+  {
+    super.setResponse( res );
+    
+    // Look for known things
+    for( int i=0; i<res.size(); i++ ) {
+      String n = res.getName( i );
+      if( "responseHeader".equals( n ) ) {
+        _header = (NamedList<Object>) res.getVal( i );
+      }
+      else if( "response".equals( n ) ) {
+        _results = (SolrDocumentList) res.getVal( i );
+      }
+      else if( "sort_values".equals( n ) ) {
+        _sortvalues = (NamedList<ArrayList>) res.getVal( i );
+      }
+      else if( "facet_counts".equals( n ) ) {
+        _facetInfo = (NamedList<Object>) res.getVal( i );
+        extractFacetInfo( _facetInfo );
+      }
+      else if( "debug".equals( n ) ) {
+        _debugInfo = (NamedList<Object>) res.getVal( i );
+        extractDebugInfo( _debugInfo );
+      }
+      else if( "highlighting".equals( n ) ) {
+        _highlightingInfo = (NamedList<Object>) res.getVal( i );
+        extractHighlightingInfo( _highlightingInfo );
+      }
+      else if ( "spellcheck".equals( n ) )  {
+        _spellInfo = (NamedList<Object>) res.getVal( i );
+        extractSpellCheckInfo( _spellInfo );
+      }
+      else if ( "stats".equals( n ) )  {
+        _statsInfo = (NamedList<Object>) res.getVal( i );
+        extractStatsInfo( _statsInfo );
+      }
+    }
+  }
+
+  private void extractSpellCheckInfo(NamedList<Object> spellInfo) {
+    _spellResponse = new SpellCheckResponse(spellInfo);
+  }
+
+  private void extractStatsInfo(NamedList<Object> info) {
+    if( info != null ) {
+      _fieldStatsInfo = new HashMap<String, FieldStatsInfo>();
+      NamedList<NamedList<Object>> ff = (NamedList<NamedList<Object>>) info.get( "stats_fields" );
+      if( ff != null ) {
+        for( Map.Entry<String,NamedList<Object>> entry : ff ) {
+          _fieldStatsInfo.put( entry.getKey(), 
+              new FieldStatsInfo( entry.getValue(), entry.getKey() ) );
+        }
+      }
+    }
+  }
+
+  private void extractDebugInfo( NamedList<Object> debug )
+  {
+    _debugMap = new LinkedHashMap<String, Object>(); // keep the order
+    for( Map.Entry<String, Object> info : debug ) {
+      _debugMap.put( info.getKey(), info.getValue() );
+    }
+
+    // Parse out interesting bits from the debug info
+    _explainMap = new HashMap<String, String>();
+    NamedList<String> explain = (NamedList<String>)_debugMap.get( "explain" );
+    if( explain != null ) {
+      for( Map.Entry<String, String> info : explain ) {
+        String key = info.getKey();
+        _explainMap.put( key, info.getValue() );
+      }
+    }
+  }
+
+  private void extractHighlightingInfo( NamedList<Object> info )
+  {
+    _highlighting = new HashMap<String,Map<String,List<String>>>();
+    for( Map.Entry<String, Object> doc : info ) {
+      Map<String,List<String>> fieldMap = new HashMap<String, List<String>>();
+      _highlighting.put( doc.getKey(), fieldMap );
+      
+      NamedList<List<String>> fnl = (NamedList<List<String>>)doc.getValue();
+      for( Map.Entry<String, List<String>> field : fnl ) {
+        fieldMap.put( field.getKey(), field.getValue() );
+      }
+    }
+  }
+
+  private void extractFacetInfo( NamedList<Object> info )
+  {
+    // Parse the queries
+    _facetQuery = new HashMap<String, Integer>();
+    NamedList<Integer> fq = (NamedList<Integer>) info.get( "facet_queries" );
+    for( Map.Entry<String, Integer> entry : fq ) {
+      _facetQuery.put( entry.getKey(), entry.getValue() );
+    }
+    
+    // Parse the facet info into fields
+    // TODO?? The list could be <int> or <long>?  If always <long> then we can switch to <Long>
+    NamedList<NamedList<Number>> ff = (NamedList<NamedList<Number>>) info.get( "facet_fields" );
+    if( ff != null ) {
+      _facetFields = new ArrayList<FacetField>( ff.size() );
+      _limitingFacets = new ArrayList<FacetField>( ff.size() );
+      
+      long minsize = _results.getNumFound();
+      for( Map.Entry<String,NamedList<Number>> facet : ff ) {
+        FacetField f = new FacetField( facet.getKey() );
+        for( Map.Entry<String, Number> entry : facet.getValue() ) {
+          f.add( entry.getKey(), entry.getValue().longValue() );
+        }
+        
+        _facetFields.add( f );
+        FacetField nl = f.getLimitingFields( minsize );
+        if( nl.getValueCount() > 0 ) {
+          _limitingFacets.add( nl );
+        }
+      }
+    }
+    
+    //Parse date facets
+    NamedList<NamedList<Object>> df = (NamedList<NamedList<Object>>) info.get("facet_dates");
+    if (df != null) {
+      // System.out.println(df);
+      _facetDates = new ArrayList<FacetField>( df.size() );
+      for (Map.Entry<String, NamedList<Object>> facet : df) {
+        // System.out.println("Key: " + facet.getKey() + " Value: " + facet.getValue());
+        NamedList<Object> values = facet.getValue();
+        String gap = (String) values.get("gap");
+        Date end = (Date) values.get("end");
+        FacetField f = new FacetField(facet.getKey(), gap, end);
+        
+        for (Map.Entry<String, Object> entry : values)   {
+          try {
+            f.add(entry.getKey(), Long.parseLong(entry.getValue().toString()));
+          } catch (NumberFormatException e) {
+            //Ignore for non-number responses which are already handled above
+          }
+        }
+        
+        _facetDates.add(f);
+      }
+    }
+  }
+
+  //------------------------------------------------------
+  //------------------------------------------------------
+
+  /**
+   * Remove the field facet info
+   */
+  public void removeFacets() {
+    _facetFields = new ArrayList<FacetField>();
+  }
+  
+  //------------------------------------------------------
+  //------------------------------------------------------
+
+  public NamedList<Object> getHeader() {
+    return _header;
+  }
+
+  public SolrDocumentList getResults() {
+    return _results;
+  }
+ 
+  public NamedList<ArrayList> getSortValues(){
+    return _sortvalues;
+  }
+
+  public Map<String, Object> getDebugMap() {
+    return _debugMap;
+  }
+
+  public Map<String, String> getExplainMap() {
+    return _explainMap;
+  }
+
+  public Map<String,Integer> getFacetQuery() {
+    return _facetQuery;
+  }
+
+  public Map<String, Map<String, List<String>>> getHighlighting() {
+    return _highlighting;
+  }
+
+  public SpellCheckResponse getSpellCheckResponse() {
+    return _spellResponse;
+  }
+
+  public List<FacetField> getFacetFields() {
+    return _facetFields;
+  }
+  
+  public List<FacetField> getFacetDates()   {
+    return _facetDates;
+  }
+  
+  /** get 
+   * 
+   * @param name the name of the 
+   * @return the FacetField by name or null if it does not exist
+   */
+  public FacetField getFacetField(String name) {
+    if (_facetFields==null) return null;
+    for (FacetField f : _facetFields) {
+      if (f.getName().equals(name)) return f;
+    }
+    return null;
+  }
+  
+  public FacetField getFacetDate(String name)   {
+    if (_facetDates == null)
+      return null;
+    for (FacetField f : _facetDates)
+      if (f.getName().equals(name))
+        return f;
+    return null;
+  }
+  
+  public List<FacetField> getLimitingFacets() {
+    return _limitingFacets;
+  }
+  
+  public <T> List<T> getBeans(Class<T> type){
+    return solrServer == null ? 
+      new DocumentObjectBinder().getBeans(type,_results):
+      solrServer.getBinder().getBeans(type, _results);
+  }
+
+  public Map<String, FieldStatsInfo> getFieldStatsInfo() {
+    return _fieldStatsInfo;
+  }
+}
+
+
+
diff --git a/src/solrj/org/apache/solr/client/solrj/response/SolrPingResponse.java b/src/solrj/org/apache/solr/client/solrj/response/SolrPingResponse.java
new file mode 100644
index 0000000..44d3785
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/SolrPingResponse.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrPingResponse extends SolrResponseBase
+{
+  // nothing special now...
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/SolrResponseBase.java b/src/solrj/org/apache/solr/client/solrj/response/SolrResponseBase.java
new file mode 100644
index 0000000..ed0908f
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/SolrResponseBase.java
@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import org.apache.solr.client.solrj.SolrResponse;
+import org.apache.solr.common.util.NamedList;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrResponseBase extends SolrResponse
+{
+  private long elapsedTime = -1;
+  private NamedList<Object> response = null;
+  private String requestUrl = null;
+  
+  @Override
+  public long getElapsedTime() {
+    return elapsedTime;
+  }
+
+  public void setElapsedTime(long elapsedTime) {
+    this.elapsedTime = elapsedTime;
+  }
+
+  @Override
+  public NamedList<Object> getResponse() {
+    return response;
+  }
+
+  @Override
+  public void setResponse(NamedList<Object> response) {
+    this.response = response;
+  }
+
+  @Override
+  public String toString() {
+    return response.toString();
+  }
+  
+  public NamedList getResponseHeader() {
+    return (NamedList) response.get("responseHeader");
+  }
+  
+  // these two methods are based on the logic in SolrCore.setResponseHeaderValues(...)
+  public int getStatus() {
+    NamedList header = getResponseHeader();
+    if (header != null) {
+        return (Integer) header.get("status");
+    }
+    else {
+        return 0;
+    }
+  }
+  
+  public int getQTime() {
+    NamedList header = getResponseHeader();
+    if (header != null) {
+        return (Integer) header.get("QTime");
+    }
+    else {
+        return 0;
+    }
+  }
+
+  public String getRequestUrl() {
+    return requestUrl;
+  }
+
+  public void setRequestUrl(String requestUrl) {
+    this.requestUrl = requestUrl;
+  }
+  
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/SpellCheckResponse.java b/src/solrj/org/apache/solr/client/solrj/response/SpellCheckResponse.java
new file mode 100644
index 0000000..b69005d
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/SpellCheckResponse.java
@@ -0,0 +1,151 @@
+package org.apache.solr.client.solrj.response;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SimpleOrderedMap;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Encapsulates responses from SpellCheckComponent
+ *
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SpellCheckResponse {
+  private boolean correctlySpelled;
+  private String collation;
+  private List<Suggestion> suggestions = new ArrayList<Suggestion>();
+  Map<String, Suggestion> suggestionMap = new LinkedHashMap<String, Suggestion>();
+
+  public SpellCheckResponse(NamedList<Object> spellInfo) {
+    NamedList<Object> sugg = (NamedList<Object>) spellInfo.get("suggestions");
+    if (sugg == null) {
+      correctlySpelled = true;
+      return;
+    }
+    for (int i = 0; i < sugg.size(); i++) {
+      String n = sugg.getName(i);
+      if ("correctlySpelled".equals(n)) {
+        correctlySpelled = (Boolean) sugg.getVal(i);
+      } else if ("collation".equals(n)) {
+        collation = (String) sugg.getVal(i);
+      } else {
+        Suggestion s = new Suggestion(n, (NamedList<Object>) sugg.getVal(i));
+        suggestionMap.put(n, s);
+        suggestions.add(s);
+      }
+    }
+  }
+
+  public boolean isCorrectlySpelled() {
+    return correctlySpelled;
+  }
+
+  public List<Suggestion> getSuggestions() {
+    return suggestions;
+  }
+
+  public Map<String, Suggestion> getSuggestionMap() {
+    return suggestionMap;
+  }
+
+  public Suggestion getSuggestion(String token) {
+    return suggestionMap.get(token);
+  }
+
+  public String getFirstSuggestion(String token) {
+    Suggestion s = suggestionMap.get(token);
+    if (s != null) {
+      return s.getSuggestions().isEmpty() ? null : s.getSuggestions().get(0);
+    }
+    return null;
+  }
+
+  public String getCollatedResult() {
+    return collation;
+  }
+
+  public static class Suggestion {
+    private String token;
+    private int numFound;
+    private int startOffset;
+    private int endOffset;
+    private int originalFrequency;
+    private List<String> suggestions = new ArrayList<String>();
+    private List<Integer> suggestionFrequencies = new ArrayList<Integer>();
+
+    public Suggestion(String token, NamedList<Object> suggestion) {
+      this.token = token;
+      for (int i = 0; i < suggestion.size(); i++) {
+        String n = suggestion.getName(i);
+
+        if ("numFound".equals(n)) {
+          numFound = (Integer) suggestion.getVal(i);
+        } else if ("startOffset".equals(n)) {
+          startOffset = (Integer) suggestion.getVal(i);
+        } else if ("endOffset".equals(n)) {
+          endOffset = (Integer) suggestion.getVal(i);
+        } else if ("origFreq".equals(n)) {
+          originalFrequency = (Integer) suggestion.getVal(i);
+        } else if ("suggestion".equals(n)) {
+          Object o = suggestion.getVal(i);
+          if (o instanceof List) {
+            List<String> list = (List<String>) o;
+            suggestions.addAll(list);
+          } else if (o instanceof SimpleOrderedMap) {
+            SimpleOrderedMap map = (SimpleOrderedMap) o;
+            suggestions.add((String) map.get("word"));
+            suggestionFrequencies.add((Integer) map.get("frequency"));
+          }
+        }
+      }
+    }
+
+    public String getToken() {
+      return token;
+    }
+
+    public int getNumFound() {
+      return numFound;
+    }
+
+    public int getStartOffset() {
+      return startOffset;
+    }
+
+    public int getEndOffset() {
+      return endOffset;
+    }
+
+    public int getOriginalFrequency() {
+      return originalFrequency;
+    }
+
+    public List<String> getSuggestions() {
+      return suggestions;
+    }
+
+    public List<Integer> getSuggestionFrequencies() {
+      return suggestionFrequencies;
+    }
+  }
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/response/UpdateResponse.java b/src/solrj/org/apache/solr/client/solrj/response/UpdateResponse.java
new file mode 100644
index 0000000..d4dc756
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/response/UpdateResponse.java
@@ -0,0 +1,32 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import org.apache.solr.common.util.NamedList;
+
+
+/**
+ * TODO -- mostly a stub until we have a defined output format
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class UpdateResponse extends SolrResponseBase
+{
+  // nothing special now...
+}
diff --git a/src/solrj/org/apache/solr/client/solrj/util/ClientUtils.java b/src/solrj/org/apache/solr/client/solrj/util/ClientUtils.java
new file mode 100644
index 0000000..5785738
--- /dev/null
+++ b/src/solrj/org/apache/solr/client/solrj/util/ClientUtils.java
@@ -0,0 +1,224 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.util;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.net.URLEncoder;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.TimeZone;
+
+import org.apache.commons.httpclient.util.DateParseException;
+
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.SolrInputField;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.ContentStream;
+import org.apache.solr.common.util.ContentStreamBase;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.common.util.DateUtil;
+
+
+/**
+ * TODO? should this go in common?
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class ClientUtils 
+{
+  // Standard Content types
+  public static final String TEXT_XML = "text/xml; charset=utf-8";  
+  
+  /**
+   * Take a string and make it an iterable ContentStream
+   */
+  public static Collection<ContentStream> toContentStreams( final String str, final String contentType )
+  {
+    if( str == null )
+      return null;
+
+    ArrayList<ContentStream> streams = new ArrayList<ContentStream>( 1 );
+    ContentStreamBase ccc = new ContentStreamBase.StringStream( str );
+    ccc.setContentType( contentType );
+    streams.add( ccc );
+    return streams;
+  }
+
+  /**
+   * @param d SolrDocument to convert
+   * @return a SolrInputDocument with the same fields and values as the
+   *   SolrDocument.  All boosts are 1.0f
+   */
+  public static SolrInputDocument toSolrInputDocument( SolrDocument d )
+  {
+    SolrInputDocument doc = new SolrInputDocument();
+    for( String name : d.getFieldNames() ) {
+      doc.addField( name, d.getFieldValue(name), 1.0f );
+    }
+    return doc;
+  }
+
+  /**
+   * @param d SolrInputDocument to convert
+   * @return a SolrDocument with the same fields and values as the SolrInputDocument
+   */
+  public static SolrDocument toSolrDocument( SolrInputDocument d )
+  {
+    SolrDocument doc = new SolrDocument();
+    for( SolrInputField field : d ) {
+      doc.setField( field.getName(), field.getValue() );
+    }
+    return doc;
+  }
+
+  //------------------------------------------------------------------------
+  //------------------------------------------------------------------------
+
+  public static void writeXML( SolrInputDocument doc, Writer writer ) throws IOException
+  {
+    writer.write("<doc boost=\""+doc.getDocumentBoost()+"\">");
+
+    for( SolrInputField field : doc ) {
+      float boost = field.getBoost();
+      String name = field.getName();
+      for( Object v : field ) {
+        if (v instanceof Date) {
+          v = DateUtil.getThreadLocalDateFormat().format( (Date)v );
+        }
+        if( boost != 1.0f ) {
+          XML.writeXML(writer, "field", v.toString(), "name", name, "boost", boost );
+        }
+        else {
+          XML.writeXML(writer, "field", v.toString(), "name", name );
+        }
+
+        // only write the boost for the first multi-valued field
+        // otherwise, the used boost is the product of all the boost values
+        boost = 1.0f;
+      }
+    }
+    writer.write("</doc>");
+  }
+
+
+  public static String toXML( SolrInputDocument doc )
+  {
+    StringWriter str = new StringWriter();
+    try {
+      writeXML( doc, str );
+    }
+    catch( Exception ex ){}
+    return str.toString();
+  }
+
+  //---------------------------------------------------------------------------------------
+
+  /**
+   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#DEFAULT_DATE_FORMATS}
+   */
+  public static final Collection<String> fmts = DateUtil.DEFAULT_DATE_FORMATS;
+
+  /**
+   * Returns a formatter that can be use by the current thread if needed to
+   * convert Date objects to the Internal representation.
+   * @throws ParseException
+   * @throws DateParseException
+   *
+   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#parseDate(String)}
+   */
+  public static Date parseDate( String d ) throws ParseException, DateParseException
+  {
+    return DateUtil.parseDate(d);
+  }
+
+  /**
+   * Returns a formatter that can be use by the current thread if needed to
+   * convert Date objects to the Internal representation.
+   *
+   * @deprecated use {@link org.apache.solr.common.util.DateUtil#getThreadLocalDateFormat()}
+   */
+  public static DateFormat getThreadLocalDateFormat() {
+
+    return DateUtil.getThreadLocalDateFormat();
+  }
+
+  /**
+   * @deprecated Use {@link org.apache.solr.common.util.DateUtil#UTC}.
+   */
+  public static TimeZone UTC = DateUtil.UTC;
+
+
+
+  /**
+   * See: http://lucene.apache.org/java/docs/queryparsersyntax.html#Escaping Special Characters
+   */
+  public static String escapeQueryChars(String s) {
+    StringBuffer sb = new StringBuffer();
+    for (int i = 0; i < s.length(); i++) {
+      char c = s.charAt(i);
+      // These characters are part of the query syntax and must be escaped
+      if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':'
+        || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~'
+        || c == '*' || c == '?' || c == '|' || c == '&'
+        || Character.isWhitespace(c)) {
+        sb.append('\\');
+      }
+      sb.append(c);
+    }
+    return sb.toString();
+  }
+
+  public static String toQueryString( SolrParams params, boolean xml ) {
+    StringBuilder sb = new StringBuilder(128);
+    try {
+      String amp = xml ? "&amp;" : "&";
+      boolean first=true;
+      Iterator<String> names = params.getParameterNamesIterator();
+      while( names.hasNext() ) {
+        String key = names.next();
+        String[] valarr = params.getParams( key );
+        if( valarr == null ) {
+          sb.append( first?"?":amp );
+          sb.append(key);
+          first=false;
+        }
+        else {
+          for (String val : valarr) {
+            sb.append( first? "?":amp );
+            sb.append(key);
+            if( val != null ) {
+              sb.append('=');
+              sb.append( URLEncoder.encode( val, "UTF-8" ) );
+            }
+            first=false;
+          }
+        }
+      }
+    }
+    catch (IOException e) {throw new RuntimeException(e);}  // can't happen
+    return sb.toString();
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java b/src/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java
new file mode 100644
index 0000000..b9dd2cf
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/LargeVolumeTestBase.java
@@ -0,0 +1,111 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.common.SolrInputDocument;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class LargeVolumeTestBase extends SolrExampleTestBase 
+{
+  SolrServer gserver = null;
+  
+  // for real load testing, make these numbers bigger
+  static final int numdocs = 100; //1000 * 1000;
+  static final int threadCount = 5;
+  
+  public void testMultiThreaded() throws Exception {
+    gserver = this.getSolrServer();
+    gserver.deleteByQuery( "*:*" ); // delete everything!
+    
+    DocThread[] threads = new DocThread[threadCount];
+    for (int i=0; i<threadCount; i++) {
+      threads[i] = new DocThread( "T"+i+":" );
+      threads[i].setName("DocThread-" + i);
+      threads[i].start();
+      System.out.println("Started thread: " + i);
+    }
+    for (int i=0; i<threadCount; i++) {
+      threads[i].join();
+    }
+    
+    query(threadCount * numdocs);
+    System.out.println("done");
+  }
+
+  private void query(int count) throws SolrServerException, IOException {
+    SolrQuery query = new SolrQuery("*:*");
+    QueryResponse response = gserver.query(query);
+    assertEquals(0, response.getStatus());
+    assertEquals(count, response.getResults().getNumFound());
+  }
+
+  public class DocThread extends Thread {
+    
+    final SolrServer tserver;
+    final String name;
+    
+    public DocThread( String name )
+    {
+      tserver = createNewSolrServer();
+      this.name = name;
+    }
+    
+    @Override
+    public void run() {
+      try {
+        UpdateResponse resp = null;
+        List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
+        for (int i = 0; i < numdocs; i++) {
+          if (i > 0 && i % 200 == 0) {
+            resp = tserver.add(docs);
+            assertEquals(0, resp.getStatus());
+            docs = new ArrayList<SolrInputDocument>();
+          }
+          if (i > 0 && i % 5000 == 0) {
+            System.out.println(getName() + " - Committing " + i);
+            resp = tserver.commit();
+            assertEquals(0, resp.getStatus());
+          }
+          SolrInputDocument doc = new SolrInputDocument();
+          doc.addField("id", name+i );
+          doc.addField("cat", "foocat");
+          docs.add(doc);
+        }
+        resp = tserver.add(docs);
+        assertEquals(0, resp.getStatus());
+        resp = tserver.commit();
+        assertEquals(0, resp.getStatus());
+        resp = tserver.optimize();
+        assertEquals(0, resp.getStatus());
+
+      } catch (Exception e) {
+        e.printStackTrace();
+        fail( getName() + "---" + e.getMessage() );
+      }
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java b/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
new file mode 100644
index 0000000..a8f22a2
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/MultiCoreExampleTestBase.java
@@ -0,0 +1,177 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.io.File;
+
+import org.apache.solr.client.solrj.request.CoreAdminRequest;
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.client.solrj.request.UpdateRequest;
+import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
+import org.apache.solr.client.solrj.response.CoreAdminResponse;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.core.SolrCore;
+
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public abstract class MultiCoreExampleTestBase extends SolrExampleTestBase 
+{
+  // protected static final CoreContainer cores = new CoreContainer();
+  protected static CoreContainer cores;
+
+  @Override public String getSolrHome() { return "../../../example/multicore/"; }
+  
+  @Override public String getSchemaFile()     { return getSolrHome()+"core0/conf/schema.xml";     }
+  @Override public String getSolrConfigFile() { return getSolrHome()+"core0/conf/solrconfig.xml"; }
+  
+  @Override public void setUp() throws Exception {
+    super.setUp();
+    cores = h.getCoreContainer();
+    SolrCore.log.info("CORES=" + cores + " : " + cores.getCoreNames());
+    cores.setPersistent(false);
+  }
+
+  @Override
+  protected final SolrServer getSolrServer()
+  {
+    throw new UnsupportedOperationException();
+  }
+  
+  @Override
+  protected final SolrServer createNewSolrServer()
+  {
+    throw new UnsupportedOperationException();
+  }
+
+  protected abstract SolrServer getSolrCore0();
+  protected abstract SolrServer getSolrCore1();
+  protected abstract SolrServer getSolrAdmin();
+  protected abstract SolrServer getSolrCore(String name);
+  
+
+  public void testMultiCore() throws Exception
+  {
+    UpdateRequest up = new UpdateRequest();
+    up.setAction( ACTION.COMMIT, true, true );
+    up.deleteByQuery( "*:*" );
+    up.process( getSolrCore0() );
+    up.process( getSolrCore1() );
+    up.clear();
+    
+    // Add something to each core
+    SolrInputDocument doc = new SolrInputDocument();
+    doc.setField( "id", "AAA" );
+    doc.setField( "core0", "yup" );
+   
+    // Add to core0
+    up.add( doc );
+    up.process( getSolrCore0() );
+
+    // You can't add it to core1
+    try {
+      up.process( getSolrCore1() );
+      fail( "Can't add core0 field to core1!" );
+    }
+    catch( Exception ex ) {}
+
+    // Add to core1
+    doc.setField( "id", "BBB" );
+    doc.setField( "core1", "yup" );
+    doc.removeField( "core0" );
+    up.add( doc );
+    up.process( getSolrCore1() );
+
+    // You can't add it to core1
+    try {
+      up.process( getSolrCore0() );
+      fail( "Can't add core1 field to core0!" );
+    }
+    catch( Exception ex ) {}
+    
+    // now Make sure AAA is in 0 and BBB in 1
+    SolrQuery q = new SolrQuery();
+    QueryRequest r = new QueryRequest( q );
+    q.setQuery( "id:AAA" );
+    assertEquals( 1, r.process( getSolrCore0() ).getResults().size() );
+    assertEquals( 0, r.process( getSolrCore1() ).getResults().size() );
+    
+    // Now test Changing the default core
+    assertEquals( 1, getSolrCore0().query( new SolrQuery( "id:AAA" ) ).getResults().size() );
+    assertEquals( 0, getSolrCore0().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+
+    assertEquals( 0, getSolrCore1().query( new SolrQuery( "id:AAA" ) ).getResults().size() );
+    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+
+    // Now test reloading it should have a newer open time
+    String name = "core0";
+    SolrServer coreadmin = getSolrAdmin();
+    CoreAdminResponse mcr = CoreAdminRequest.getStatus( name, coreadmin );
+    long before = mcr.getStartTime( name ).getTime();
+    CoreAdminRequest.reloadCore( name, coreadmin );
+    
+    mcr = CoreAdminRequest.getStatus( name, coreadmin );
+    long after = mcr.getStartTime( name ).getTime();
+    assertTrue( "should have more recent time: "+after+","+before, after > before );
+
+    // test alias
+    CoreAdminRequest.aliasCore("core1","corefoo",coreadmin);
+    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+    assertEquals( 1, getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+
+    // test that reload affects aliases
+    CoreAdminRequest.reloadCore("core1", coreadmin);
+
+    // this is only an effective test for embedded, where we have
+    // direct access to the core container.
+    SolrCore c1 = cores.getCore("core1");
+    SolrCore c2 = cores.getCore("corefoo");
+    assertTrue(c1 == c2);
+    if (c1 != null) c1.close();
+    if (c2 != null) c2.close();
+
+    // retest core query
+    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+
+    // test close
+    CoreAdminRequest.unloadCore("corefoo",coreadmin);
+    try {
+      getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) );
+      fail( "corefoo should be gone" );
+    }
+    catch( Exception ex ) {}
+    // aliased core should still work
+    assertEquals( 1, getSolrCore1().query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+    
+    // test move
+    CoreAdminRequest.renameCore("core1","corea",coreadmin);
+    CoreAdminRequest.renameCore("corea","coreb",coreadmin);
+    CoreAdminRequest.renameCore("coreb","corec",coreadmin);
+    CoreAdminRequest.renameCore("corec","cored",coreadmin);
+    CoreAdminRequest.renameCore("cored","corefoo",coreadmin);
+    try {
+      getSolrCore("core1").query( new SolrQuery( "id:BBB" ) );
+      fail( "core1 should be gone" );
+    }
+    catch( Exception ex ) {}
+    assertEquals( 1, getSolrCore("corefoo").query( new SolrQuery( "id:BBB" ) ).getResults().size() );
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/SolrExampleTestBase.java b/src/test/org/apache/solr/client/solrj/SolrExampleTestBase.java
new file mode 100644
index 0000000..f2717ad
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/SolrExampleTestBase.java
@@ -0,0 +1,56 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+
+import org.apache.solr.util.AbstractSolrTestCase;
+
+/**
+ * This should include tests against the example solr config
+ * 
+ * This lets us try various SolrServer implementations with the same tests.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+abstract public class SolrExampleTestBase extends AbstractSolrTestCase 
+{
+  public String getSolrHome() { return "../../../example/solr/"; }
+  
+  @Override public String getSchemaFile()     { return getSolrHome()+"conf/schema.xml";     }
+  @Override public String getSolrConfigFile() { return getSolrHome()+"conf/solrconfig.xml"; }
+ 
+  @Override
+  public void setUp() throws Exception
+  {
+    super.setUp();
+    
+    // this sets the property for jetty starting SolrDispatchFilter
+    System.setProperty( "solr.solr.home", this.getSolrHome() ); 
+  }
+  
+  /**
+   * Subclasses need to initialize the server impl
+   */
+  protected abstract SolrServer getSolrServer();
+  
+  /**
+   * Create a new solr server
+   */
+  protected abstract SolrServer createNewSolrServer();
+}
diff --git a/src/test/org/apache/solr/client/solrj/SolrExampleTests.java b/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
new file mode 100644
index 0000000..032cefb
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/SolrExampleTests.java
@@ -0,0 +1,519 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import junit.framework.Assert;
+
+import org.apache.solr.client.solrj.request.DirectXmlRequest;
+import org.apache.solr.client.solrj.request.LukeRequest;
+import org.apache.solr.client.solrj.request.SolrPing;
+import org.apache.solr.client.solrj.response.FieldStatsInfo;
+import org.apache.solr.client.solrj.request.UpdateRequest;
+import org.apache.solr.client.solrj.response.LukeResponse;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.client.solrj.response.FacetField;
+import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.util.XML;
+import org.apache.solr.common.params.FacetParams;
+
+/**
+ * This should include tests against the example solr config
+ * 
+ * This lets us try various SolrServer implementations with the same tests.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+abstract public class SolrExampleTests extends SolrExampleTestBase 
+{
+  /**
+   * query the example
+   */
+  public void testExampleConfig() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    
+    // Now add something...
+    SolrInputDocument doc = new SolrInputDocument();
+    String docID = "1112211111";
+    doc.addField( "id", docID, 1.0f );
+    doc.addField( "name", "my name!", 1.0f );
+    
+    Assert.assertEquals( null, doc.getField("foo") );
+    Assert.assertTrue(doc.getField("name").getValue() != null );
+        
+    UpdateResponse upres = server.add( doc ); 
+    System.out.println( "ADD:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    upres = server.commit( true, true );
+    System.out.println( "COMMIT:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    upres = server.optimize( true, true );
+    System.out.println( "OPTIMIZE:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    SolrQuery query = new SolrQuery();
+    query.setQuery( "id:"+docID );
+    QueryResponse response = server.query( query );
+    
+    Assert.assertEquals(docID, response.getResults().get(0).getFieldValue("id") );
+    
+    // Now add a few docs for facet testing...
+    List<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
+    SolrInputDocument doc2 = new SolrInputDocument();
+    doc2.addField( "id", "2", 1.0f );
+    doc2.addField( "inStock", true, 1.0f );
+    doc2.addField( "price", 2, 1.0f );
+    doc2.addField( "timestamp", new java.util.Date(), 1.0f );
+    docs.add(doc2);
+    SolrInputDocument doc3 = new SolrInputDocument();
+    doc3.addField( "id", "3", 1.0f );
+    doc3.addField( "inStock", false, 1.0f );
+    doc3.addField( "price", 3, 1.0f );
+    doc3.addField( "timestamp", new java.util.Date(), 1.0f );
+    docs.add(doc3);
+    SolrInputDocument doc4 = new SolrInputDocument();
+    doc4.addField( "id", "4", 1.0f );
+    doc4.addField( "inStock", true, 1.0f );
+    doc4.addField( "price", 4, 1.0f );
+    doc4.addField( "timestamp", new java.util.Date(), 1.0f );
+    docs.add(doc4);
+    SolrInputDocument doc5 = new SolrInputDocument();
+    doc5.addField( "id", "5", 1.0f );
+    doc5.addField( "inStock", false, 1.0f );
+    doc5.addField( "price", 5, 1.0f );
+    doc5.addField( "timestamp", new java.util.Date(), 1.0f );
+    docs.add(doc5);
+    
+    upres = server.add( docs ); 
+    System.out.println( "ADD:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    upres = server.commit( true, true );
+    System.out.println( "COMMIT:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    upres = server.optimize( true, true );
+    System.out.println( "OPTIMIZE:"+upres.getResponse() );
+    Assert.assertEquals(0, upres.getStatus());
+    
+    query = new SolrQuery("*:*");
+    query.addFacetQuery("price:[* TO 2]");
+    query.addFacetQuery("price:[2 TO 4]");
+    query.addFacetQuery("price:[5 TO *]");
+    query.addFacetField("inStock");
+    query.addFacetField("price");
+    query.addFacetField("timestamp");
+    query.removeFilterQuery("inStock:true");
+    
+    response = server.query( query );
+    Assert.assertEquals(0, response.getStatus());
+    Assert.assertEquals(5, response.getResults().getNumFound() );
+    Assert.assertEquals(3, response.getFacetQuery().size());    
+    Assert.assertEquals(2, response.getFacetField("inStock").getValueCount());
+    Assert.assertEquals(4, response.getFacetField("price").getValueCount());
+    
+    // test a second query, test making a copy of the main query
+    SolrQuery query2 = query.getCopy();
+    query2.addFilterQuery("inStock:true");
+    response = server.query( query2 );
+    Assert.assertEquals(1, query2.getFilterQueries().length);
+    Assert.assertEquals(0, response.getStatus());
+    Assert.assertEquals(2, response.getResults().getNumFound() );
+    Assert.assertFalse(query.getFilterQueries() == query2.getFilterQueries());
+  }
+
+
+  /**
+   * query the example
+   */
+  public void testAddRetrieve() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    
+    // Now add something...
+    SolrInputDocument doc1 = new SolrInputDocument();
+    doc1.addField( "id", "id1", 1.0f );
+    doc1.addField( "name", "doc1", 1.0f );
+    doc1.addField( "price", 10 );
+
+    SolrInputDocument doc2 = new SolrInputDocument();
+    doc2.addField( "id", "id2", 1.0f );
+    doc2.addField( "name", "doc2", 1.0f );
+    doc2.addField( "price", 20 );
+    
+    Collection<SolrInputDocument> docs = new ArrayList<SolrInputDocument>();
+    docs.add( doc1 );
+    docs.add( doc2 );
+    
+    // Add the documents
+    server.add( docs );
+    server.commit();
+    
+    SolrQuery query = new SolrQuery();
+    query.setQuery( "*:*" );
+    query.addSortField( "price", SolrQuery.ORDER.asc );
+    QueryResponse rsp = server.query( query );
+    
+    Assert.assertEquals( 2, rsp.getResults().getNumFound() );
+    System.out.println( rsp.getResults() );
+    
+    // Now do it again
+    server.add( docs );
+    server.commit();
+    
+    rsp = server.query( query );
+    Assert.assertEquals( 2, rsp.getResults().getNumFound() );
+    System.out.println( rsp.getResults() );
+    
+  }
+  
+  /**
+   * query the example
+   */
+  public void testCommitWithin() throws Exception
+  {    
+    // make sure it is empty...
+    SolrServer server = getSolrServer();
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    QueryResponse rsp = server.query( new SolrQuery( "*:*") );
+    Assert.assertEquals( 0, rsp.getResults().getNumFound() );
+
+    // Now try a timed commit...
+    SolrInputDocument doc3 = new SolrInputDocument();
+    doc3.addField( "id", "id3", 1.0f );
+    doc3.addField( "name", "doc3", 1.0f );
+    doc3.addField( "price", 10 );
+    UpdateRequest up = new UpdateRequest();
+    up.add( doc3 );
+    up.setCommitWithin( 100 );
+    up.process( server );
+    
+    rsp = server.query( new SolrQuery( "*:*") );
+    Assert.assertEquals( 0, rsp.getResults().getNumFound() );
+    
+    Thread.sleep( 500 ); // wait 1/2 seconds...
+
+    // now check that it comes out...
+    rsp = server.query( new SolrQuery( "id:id3") );
+    Assert.assertEquals( 1, rsp.getResults().getNumFound() );
+  }
+  
+  
+  protected void assertNumFound( String query, int num ) throws SolrServerException, IOException
+  {
+    QueryResponse rsp = getSolrServer().query( new SolrQuery( query ) );
+    if( num != rsp.getResults().getNumFound() ) {
+      fail( "expected: "+num +" but had: "+rsp.getResults().getNumFound() + " :: " + rsp.getResults() );
+    }
+  }
+
+  public void testAddDelete() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    
+    SolrInputDocument[] doc = new SolrInputDocument[3];
+    for( int i=0; i<3; i++ ) {
+      doc[i] = new SolrInputDocument();
+      doc[i].setField( "id", i + " & 222", 1.0f );
+    }
+    String id = (String) doc[0].getField( "id" ).getFirstValue();
+    
+    server.add( doc[0] );
+    server.commit();
+    assertNumFound( "*:*", 1 ); // make sure it got in
+    
+    // make sure it got in there
+    server.deleteById( id );
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got out
+    
+    // add it back 
+    server.add( doc[0] );
+    server.commit();
+    assertNumFound( "*:*", 1 ); // make sure it got in
+    server.deleteByQuery( "id:\""+ClientUtils.escapeQueryChars(id)+"\"" );
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got out
+    
+    // Add two documents
+    for( SolrInputDocument d : doc ) {
+      server.add( d );
+    }
+    server.commit();
+    assertNumFound( "*:*", 3 ); // make sure it got in
+    
+    // should be able to handle multiple delete commands in a single go
+    StringWriter xml = new StringWriter();
+    xml.append( "<delete>" );
+    for( SolrInputDocument d : doc ) {
+      xml.append( "<id>" );
+      XML.escapeCharData( (String)d.getField( "id" ).getFirstValue(), xml );
+      xml.append( "</id>" );
+    }
+    xml.append( "</delete>" );
+    DirectXmlRequest up = new DirectXmlRequest( "/update", xml.toString() );
+    server.request( up );
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got out
+  }
+  
+  public void testLukeHandler() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    
+    SolrInputDocument[] doc = new SolrInputDocument[5];
+    for( int i=0; i<doc.length; i++ ) {
+      doc[i] = new SolrInputDocument();
+      doc[i].setField( "id", "ID"+i, 1.0f );
+      server.add( doc[i] );
+    }
+    server.commit();
+    assertNumFound( "*:*", doc.length ); // make sure it got in
+    
+    LukeRequest luke = new LukeRequest();
+    luke.setShowSchema( false );
+    LukeResponse rsp = luke.process( server );
+    assertNull( rsp.getFieldTypeInfo() ); // if you don't ask for it, the schema is null
+    
+    luke.setShowSchema( true );
+    rsp = luke.process( server );
+    assertNotNull( rsp.getFieldTypeInfo() ); 
+  }
+
+  public void testStatistics() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got in
+    
+    int i=0;               // 0   1   2   3   4   5   6   7   8   9 
+    int[] nums = new int[] { 23, 26, 38, 46, 55, 63, 77, 84, 92, 94 };
+    for( int num : nums ) {
+      SolrInputDocument doc = new SolrInputDocument();
+      doc.setField( "id", "doc"+i++ );
+      doc.setField( "name", "doc: "+num );
+      doc.setField( "popularity", num );
+      server.add( doc );
+    }
+    server.commit();
+    assertNumFound( "*:*", nums.length ); // make sure they all got in
+    
+    SolrQuery query = new SolrQuery( "*:*" );
+    query.setRows( 0 );
+    query.setGetFieldStatistics( "popularity", true );
+    
+    QueryResponse rsp = server.query( query );
+    FieldStatsInfo stats = rsp.getFieldStatsInfo().get( "popularity" );
+    assertNotNull( stats );
+    
+    assertEquals( 23.0, stats.getMin() );
+    assertEquals( 94.0, stats.getMax() );
+    assertEquals( new Long(nums.length), stats.getCount() );
+    assertEquals( new Long(0), stats.getMissing() );
+    assertEquals( (nums[4]+nums[5])/2.0, stats.getMedian() );
+    assertEquals( "26.4", stats.getStddev().toString().substring(0,4) );
+    
+    // now lets try again with a new set...  (odd median)
+    //----------------------------------------------------
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got in
+    nums = new int[] { 5, 7, 10, 19, 20 };
+    for( int num : nums ) {
+      SolrInputDocument doc = new SolrInputDocument();
+      doc.setField( "id", "doc"+i++ );
+      doc.setField( "name", "doc: "+num );
+      doc.setField( "popularity", num );
+      server.add( doc );
+    }
+    server.commit();
+    assertNumFound( "*:*", nums.length ); // make sure they all got in
+    
+    rsp = server.query( query );
+    stats = rsp.getFieldStatsInfo().get( "popularity" );
+    assertNotNull( stats );
+    
+    assertEquals( 5.0, stats.getMin() );
+    assertEquals( 20.0, stats.getMax() );
+    assertEquals( new Long(nums.length), stats.getCount() );
+    assertEquals( new Long(0), stats.getMissing() );
+    assertEquals( 10.0, stats.getMedian() );
+    
+    // Now try again with faceting
+    //---------------------------------
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got in
+    nums = new int[] { 1, 2, 3, 4, 5, 10, 11, 12, 13, 14 };
+    for( i=0; i<nums.length; i++ ) {
+      int num = nums[i];
+      SolrInputDocument doc = new SolrInputDocument();
+      doc.setField( "id", "doc"+i );
+      doc.setField( "name", "doc: "+num );
+      doc.setField( "popularity", num );
+      doc.setField( "inStock", i < 5 );
+      server.add( doc );
+    }
+    server.commit();
+    assertNumFound( "inStock:true",  5 ); // make sure they all got in
+    assertNumFound( "inStock:false", 5 ); // make sure they all got in
+
+    // facet on 'inStock'
+    query.addStatsFieldFacets( "popularity", "inStock" );
+    rsp = server.query( query );
+    stats = rsp.getFieldStatsInfo().get( "popularity" );
+    assertNotNull( stats );
+    
+    List<FieldStatsInfo> facets = stats.getFacets().get( "inStock" );
+    assertNotNull( facets );
+    assertEquals( 2, facets.size() );
+    FieldStatsInfo inStockF = facets.get(0);
+    FieldStatsInfo inStockT = facets.get(1);
+    if( "true".equals( inStockF.getName() ) ) {
+      FieldStatsInfo tmp = inStockF;
+      inStockF = inStockT;
+      inStockT = tmp;
+    }
+
+    // make sure half went to each
+    assertEquals( inStockF.getCount(), inStockT.getCount() );
+    assertEquals( stats.getCount().longValue(), inStockF.getCount()+inStockT.getCount() );
+
+    assertTrue( "check that min max faceted ok", inStockF.getMin() > inStockT.getMax() );
+    assertEquals( "they have the same distribution", inStockF.getStddev(), inStockT.getStddev() );
+  }
+
+  public void testPingHandler() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got in
+    
+    // should be ok
+    server.ping();
+    
+    try {
+      SolrPing ping = new SolrPing();
+      ping.getParams().set( "qt", "unknown handler!" );
+      ping.process( server );
+      fail( "sent unknown query type!" );
+    }
+    catch( Exception ex ) {
+      // expected
+    }
+  }
+  
+  public void testFaceting() throws Exception
+  {    
+    SolrServer server = getSolrServer();
+    
+    // Empty the database...
+    server.deleteByQuery( "*:*" );// delete everything!
+    server.commit();
+    assertNumFound( "*:*", 0 ); // make sure it got in
+    
+    ArrayList<SolrInputDocument> docs = new ArrayList<SolrInputDocument>(10);
+    for( int i=1; i<=10; i++ ) {
+      SolrInputDocument doc = new SolrInputDocument();
+      doc.setField( "id", i+"", 1.0f );
+      if( (i%2)==0 ) {
+        doc.addField( "features", "two" );
+      }
+      if( (i%3)==0 ) {
+        doc.addField( "features", "three" );
+      }
+      if( (i%4)==0 ) {
+        doc.addField( "features", "four" );
+      }
+      if( (i%5)==0 ) {
+        doc.addField( "features", "five" );
+      }
+      docs.add( doc );
+    }
+    server.add( docs );
+    server.commit();
+    
+    SolrQuery query = new SolrQuery( "*:*" );
+    query.remove( FacetParams.FACET_FIELD );
+    query.addFacetField( "features" );
+    query.setFacetMinCount( 0 );
+    query.setFacet( true );
+    query.setRows( 0 );
+    
+    QueryResponse rsp = server.query( query );
+    assertEquals( docs.size(), rsp.getResults().getNumFound() );
+    
+    List<FacetField> facets = rsp.getFacetFields();
+    assertEquals( 1, facets.size() );
+    FacetField ff = facets.get( 0 );
+    assertEquals( "features", ff.getName() );
+    System.out.println( "111: "+ff.getValues() );
+    // check all counts
+    assertEquals( "[two (5), three (3), five (2), four (2)]", ff.getValues().toString() );
+    
+    // should be the same facets with minCount=0
+    query.setFilterQueries( "features:two" );
+    rsp = server.query( query );
+    ff = rsp.getFacetField( "features" );
+    assertEquals( "[two (5), four (2), five (1), three (1)]", ff.getValues().toString() );
+    
+    // with minCount > 3
+    query.setFacetMinCount( 4 );
+    rsp = server.query( query );
+    ff = rsp.getFacetField( "features" );
+    assertEquals( "[two (5)]", ff.getValues().toString() );
+
+    // with minCount > 3
+    query.setFacetMinCount( -1 );
+    rsp = server.query( query );
+    ff = rsp.getFacetField( "features" );
+    
+    System.out.println( rsp.getResults().getNumFound() + " :::: 444: "+ff.getValues() );
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/SolrExceptionTest.java b/src/test/org/apache/solr/client/solrj/SolrExceptionTest.java
new file mode 100644
index 0000000..b83a291
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/SolrExceptionTest.java
@@ -0,0 +1,53 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import java.net.UnknownHostException;
+
+import junit.framework.TestCase;
+
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrException;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrExceptionTest extends TestCase {
+
+  public void testSolrException() throws Throwable {
+    // test a connection to a solr server that probably doesn't exist
+    // this is a very simple test and most of the test should be considered verified 
+    // if the compiler won't let you by without the try/catch
+    boolean gotExpectedError = false;
+    try {
+      SolrServer client = new CommonsHttpSolrServer("http://333.333.333.333:8080/solr/");
+      SolrQuery query = new SolrQuery("test123");
+      client.query(query);
+    } catch (SolrServerException sse) {
+      gotExpectedError = true;
+      assertTrue(UnknownHostException.class == sse.getRootCause().getClass()
+              //If one is using OpenDNS, then you don't get UnknownHostException, instead you get back that the query couldn't execute
+              || (sse.getRootCause().getClass() == SolrException.class && ((SolrException) sse.getRootCause()).code() == 302 && sse.getMessage().equals("Error executing query")));
+    }
+    assertTrue(gotExpectedError);
+  }
+  
+}
diff --git a/src/test/org/apache/solr/client/solrj/SolrQueryTest.java b/src/test/org/apache/solr/client/solrj/SolrQueryTest.java
new file mode 100644
index 0000000..c339461
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/SolrQueryTest.java
@@ -0,0 +1,139 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import org.apache.solr.common.params.FacetParams;
+
+import junit.framework.Assert;
+import junit.framework.TestCase;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrQueryTest extends TestCase {
+  
+  public void testSolrQueryMethods() {
+    SolrQuery q = new SolrQuery("dog");
+    boolean b = false;
+    
+    q.setFacetLimit(10);
+    q.addFacetField("price");
+    q.addFacetField("state");
+    Assert.assertEquals(q.getFacetFields().length, 2);
+    q.addFacetQuery("instock:true");
+    q.addFacetQuery("instock:false");
+    q.addFacetQuery("a:b");
+    Assert.assertEquals(q.getFacetQuery().length, 3);
+    
+    b = q.removeFacetField("price");
+    Assert.assertEquals(b, true);
+    b = q.removeFacetField("price2");
+    Assert.assertEquals(b, false);
+    b = q.removeFacetField("state");
+    Assert.assertEquals(b, true);
+    Assert.assertEquals(null, q.getFacetFields());
+    
+    b = q.removeFacetQuery("instock:true");
+    Assert.assertEquals(b, true);
+    b = q.removeFacetQuery("instock:false");
+    b = q.removeFacetQuery("a:c");
+    Assert.assertEquals(b, false);
+    b = q.removeFacetQuery("a:b");
+    Assert.assertEquals(null, q.getFacetQuery());   
+    
+    q.addSortField("price", SolrQuery.ORDER.asc);
+    q.addSortField("date", SolrQuery.ORDER.desc);
+    q.addSortField("qty", SolrQuery.ORDER.desc);
+    q.removeSortField("date", SolrQuery.ORDER.desc);
+    Assert.assertEquals(2, q.getSortFields().length);
+    q.removeSortField("price", SolrQuery.ORDER.asc);
+    q.removeSortField("qty", SolrQuery.ORDER.desc);
+    Assert.assertEquals(null, q.getSortFields());
+    
+    q.addHighlightField("hl1");
+    q.addHighlightField("hl2");
+    q.setHighlightSnippets(2);
+    Assert.assertEquals(2, q.getHighlightFields().length);
+    Assert.assertEquals(100, q.getHighlightFragsize());
+    Assert.assertEquals(q.getHighlightSnippets(), 2);
+    q.removeHighlightField("hl1");
+    q.removeHighlightField("hl3");
+    Assert.assertEquals(1, q.getHighlightFields().length);
+    q.removeHighlightField("hl2");
+    Assert.assertEquals(null, q.getHighlightFields());
+    
+    // check to see that the removes are properly clearing the cgi params
+    Assert.assertEquals(q.toString(), "q=dog");
+
+    //Add time allowed param
+    q.setTimeAllowed(1000);
+    Assert.assertEquals((Integer)1000, q.getTimeAllowed() );
+    //Adding a null should remove it
+    q.setTimeAllowed(null);
+    Assert.assertEquals(null, q.getTimeAllowed() ); 
+    
+    System.out.println(q);
+  }
+  
+  public void testFacetSort() {
+    SolrQuery q = new SolrQuery("dog");
+    assertEquals("count", q.getFacetSortString());
+    q.setFacetSort("lex");
+    assertEquals("lex", q.getFacetSortString());
+  }
+
+  public void testFacetSortLegacy() {
+    SolrQuery q = new SolrQuery("dog");
+    assertTrue("expected default value to be true", q.getFacetSort());
+    q.setFacetSort(false);
+    assertFalse("expected set value to be false", q.getFacetSort());
+  }
+
+  public void testSettersGetters() {
+      SolrQuery q = new SolrQuery("foo");
+      assertEquals(10, q.setFacetLimit(10).getFacetLimit());
+      assertEquals(10, q.setFacetMinCount(10).getFacetMinCount());
+      assertEquals("lex", q.setFacetSort("lex").getFacetSortString());
+      assertEquals(10, q.setHighlightSnippets(10).getHighlightSnippets());
+      assertEquals(10, q.setHighlightFragsize(10).getHighlightFragsize());
+      assertEquals(true, q.setHighlightRequireFieldMatch(true).getHighlightRequireFieldMatch());
+      assertEquals("foo", q.setHighlightSimplePre("foo").getHighlightSimplePre());
+      assertEquals("foo", q.setHighlightSimplePost("foo").getHighlightSimplePost());
+      assertEquals(true, q.setHighlight(true).getHighlight());
+      assertEquals("foo", q.setQuery("foo").getQuery());
+      assertEquals(10, q.setRows(10).getRows().intValue());
+      assertEquals(10, q.setStart(10).getStart().intValue());
+      assertEquals("foo", q.setQueryType("foo").getQueryType());
+      assertEquals(10, q.setTimeAllowed(10).getTimeAllowed().intValue());
+      
+      // non-standard
+      assertEquals("foo", q.setFacetPrefix("foo").get( FacetParams.FACET_PREFIX, null ) );
+      assertEquals("foo", q.setFacetPrefix("a", "foo").getFieldParam( "a", FacetParams.FACET_PREFIX, null ) );
+
+      assertEquals( Boolean.TRUE, q.setMissing(Boolean.TRUE.toString()).getBool( FacetParams.FACET_MISSING ) );
+      assertEquals( Boolean.FALSE, q.setFacetMissing( Boolean.FALSE ).getBool( FacetParams.FACET_MISSING ) );      
+      assertEquals( "true", q.setParam( "xxx", true ).getParams( "xxx" )[0] );
+  }
+  
+  public void testOrder() {
+    assertEquals( SolrQuery.ORDER.asc, SolrQuery.ORDER.desc.reverse() );
+    assertEquals( SolrQuery.ORDER.desc, SolrQuery.ORDER.asc.reverse() );
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/StartSolrJetty.java b/src/test/org/apache/solr/client/solrj/StartSolrJetty.java
new file mode 100644
index 0000000..8749674
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/StartSolrJetty.java
@@ -0,0 +1,71 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj;
+
+import org.mortbay.jetty.Connector;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.bio.SocketConnector;
+import org.mortbay.jetty.webapp.WebAppContext;
+
+/**
+ * @since solr 1.3
+ */
+public class StartSolrJetty 
+{
+  public static void main( String[] args ) 
+  {
+    //System.setProperty("solr.solr.home", "../../../example/solr");
+
+    Server server = new Server();
+    SocketConnector connector = new SocketConnector();
+    // Set some timeout options to make debugging easier.
+    connector.setMaxIdleTime(1000 * 60 * 60);
+    connector.setSoLingerTime(-1);
+    connector.setPort(8080);
+    server.setConnectors(new Connector[] { connector });
+    
+    WebAppContext bb = new WebAppContext();
+    bb.setServer(server);
+    bb.setContextPath("/");
+    bb.setWar("src/webapp/web");
+
+//    // START JMX SERVER
+//    if( true ) {
+//      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
+//      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);
+//      server.getContainer().addEventListener(mBeanContainer);
+//      mBeanContainer.start();
+//    }
+    
+    server.addHandler(bb);
+
+    try {
+      System.out.println(">>> STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP");
+      server.start();
+      while (System.in.available() == 0) {
+        Thread.sleep(5000);
+      }
+      server.stop();
+      server.join();
+    } 
+    catch (Exception e) {
+      e.printStackTrace();
+      System.exit(100);
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java b/src/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java
new file mode 100644
index 0000000..b0577bd
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/beans/TestDocumentObjectBinder.java
@@ -0,0 +1,180 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.beans;
+
+import junit.framework.TestCase;
+
+import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
+import org.apache.solr.client.solrj.beans.Field;
+import org.apache.solr.client.solrj.impl.XMLResponseParser;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.client.solrj.util.ClientUtils;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.SolrInputField;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.util.NamedList;
+import org.junit.Assert;
+
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+
+public class TestDocumentObjectBinder extends TestCase 
+{
+  public void testSimple() throws Exception {
+    DocumentObjectBinder binder = new DocumentObjectBinder();
+    XMLResponseParser parser = new XMLResponseParser();
+    NamedList<Object> nl = null;
+    nl = parser.processResponse(new StringReader(xml));
+    QueryResponse res = new QueryResponse(nl, null);
+    SolrDocumentList solDocList = res.getResults();
+    List<Item> l = binder.getBeans(Item.class,res.getResults());
+    Assert.assertEquals(solDocList.size(), l.size());
+    Assert.assertEquals(solDocList.get(0).getFieldValue("features"), l.get(0).features);
+
+    Item item = new Item();
+    item.id = "aaa";
+    item.categories = new String[] { "aaa", "bbb", "ccc" };
+    SolrInputDocument out = binder.toSolrInputDocument( item );
+
+    Assert.assertEquals( item.id, out.getFieldValue( "id" ) );
+    SolrInputField catfield = out.getField( "cat" );
+    Assert.assertEquals( 3, catfield.getValueCount() );
+    Assert.assertEquals( "[aaa, bbb, ccc]", catfield.getValue().toString() );
+  
+    // Test the error on not settable stuff...
+    NotGettableItem ng = new NotGettableItem();
+    ng.setInStock( false );
+    try {
+      out = binder.toSolrInputDocument( ng );
+      Assert.fail( "Should throw an error" );
+    }
+    catch( RuntimeException ex ) {
+      // ok -- this should happen...
+    }
+  }
+  public void testSingleVal4Array(){
+    DocumentObjectBinder binder = new DocumentObjectBinder();
+    SolrDocumentList solDocList = new SolrDocumentList();
+    SolrDocument d = new SolrDocument();
+    solDocList.add(d);
+    d.setField("cat","hello");
+    List<Item> l = binder.getBeans(Item.class,solDocList);
+    Assert.assertEquals("hello", l.get(0).categories[0]);
+
+  }
+  
+  public void testToAndFromSolrDocument()
+  {
+    Item item = new Item();
+    item.id = "one";
+    item.inStock = false;
+    item.categories =  new String[] { "aaa", "bbb", "ccc" };
+    item.features = Arrays.asList( item.categories );
+    
+    DocumentObjectBinder binder = new DocumentObjectBinder();
+    SolrInputDocument doc = binder.toSolrInputDocument( item );
+    SolrDocumentList docs = new SolrDocumentList();
+    docs.add( ClientUtils.toSolrDocument(doc) );
+    Item out = binder.getBeans( Item.class, docs ).get( 0 );
+
+    // make sure it came out the same
+    Assert.assertEquals( item.id, out.id );
+    Assert.assertEquals( item.inStock, out.inStock );
+    Assert.assertEquals( item.categories.length, out.categories.length );
+    Assert.assertEquals( item.features, out.features );
+  }
+
+  public static class Item {
+    @Field
+    String id;
+
+    @Field("cat")
+    String[] categories;
+
+    @Field
+    List<String> features;
+
+    @Field
+    Date timestamp;
+
+    @Field("highway_mileage")
+    int mwyMileage;
+
+    boolean inStock = false;
+
+    @Field
+    public void setInStock(Boolean b) {
+      inStock = b;
+    }
+    
+    // required if you want to fill SolrDocuments with the same annotaion...
+    public boolean isInStock()
+    {
+      return inStock;
+    }
+  }
+  
+
+  public static class NotGettableItem {
+    @Field
+    String id;
+
+    private boolean inStock;
+    private String aaa;
+
+    @Field
+    public void setInStock(Boolean b) {
+      inStock = b;
+    }
+
+    public String getAaa() {
+      return aaa;
+    }
+
+    @Field
+    public void setAaa(String aaa) {
+      this.aaa = aaa;
+    }
+  }
+
+  public static final String xml = 
+    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
+    "<response>" +
+    "<lst name=\"responseHeader\"><int name=\"status\">0</int><int name=\"QTime\">0</int><lst name=\"params\"><str name=\"start\">0</str><str name=\"q\">*:*\n" +
+    "</str><str name=\"version\">2.2</str><str name=\"rows\">4</str></lst></lst><result name=\"response\" numFound=\"26\" start=\"0\"><doc><arr name=\"cat\">" +
+    "<str>electronics</str><str>hard drive</str></arr><arr name=\"features\"><str>7200RPM, 8MB cache, IDE Ultra ATA-133</str>" +
+    "<str>NoiseGuard, SilentSeek technology, Fluid Dynamic Bearing (FDB) motor</str></arr><str name=\"id\">SP2514N</str>" +
+    "<bool name=\"inStock\">true</bool><str name=\"manu\">Samsung Electronics Co. Ltd.</str><str name=\"name\">Samsung SpinPoint P120 SP2514N - hard drive - 250 GB - ATA-133</str>" +
+    "<int name=\"popularity\">6</int><float name=\"price\">92.0</float><str name=\"sku\">SP2514N</str><date name=\"timestamp\">2008-04-16T10:35:57.078Z</date></doc>" +
+    "<doc><arr name=\"cat\"><str>electronics</str><str>hard drive</str></arr><arr name=\"features\"><str>SATA 3.0Gb/s, NCQ</str><str>8.5ms seek</str>" +
+    "<str>16MB cache</str></arr><str name=\"id\">6H500F0</str><bool name=\"inStock\">true</bool><str name=\"manu\">Maxtor Corp.</str>" +
+    "<str name=\"name\">Maxtor DiamondMax 11 - hard drive - 500 GB - SATA-300</str><int name=\"popularity\">6</int><float name=\"price\">350.0</float>" +
+    "<str name=\"sku\">6H500F0</str><date name=\"timestamp\">2008-04-16T10:35:57.109Z</date></doc><doc><arr name=\"cat\"><str>electronics</str>" +
+    "<str>connector</str></arr><arr name=\"features\"><str>car power adapter, white</str></arr><str name=\"id\">F8V7067-APL-KIT</str>" +
+    "<bool name=\"inStock\">false</bool><str name=\"manu\">Belkin</str><str name=\"name\">Belkin Mobile Power Cord for iPod w/ Dock</str>" +
+    "<int name=\"popularity\">1</int><float name=\"price\">19.95</float><str name=\"sku\">F8V7067-APL-KIT</str>" +
+    "<date name=\"timestamp\">2008-04-16T10:35:57.140Z</date><float name=\"weight\">4.0</float></doc><doc>" +
+    "<arr name=\"cat\"><str>electronics</str><str>connector</str></arr><arr name=\"features\">" +
+    "<str>car power adapter for iPod, white</str></arr><str name=\"id\">IW-02</str><bool name=\"inStock\">false</bool>" +
+    "<str name=\"manu\">Belkin</str><str name=\"name\">iPod &amp; iPod Mini USB 2.0 Cable</str>" +
+    "<int name=\"popularity\">1</int><float name=\"price\">11.5</float><str name=\"sku\">IW-02</str>" +
+    "<date name=\"timestamp\">2008-04-16T10:35:57.140Z</date><float name=\"weight\">2.0</float></doc></result>\n" +
+    "</response>";
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java b/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
new file mode 100644
index 0000000..17baea1
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/JettyWebappTest.java
@@ -0,0 +1,94 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import java.net.URL;
+
+import junit.framework.TestCase;
+
+import org.apache.commons.io.IOUtils;
+import org.mortbay.jetty.Connector;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.bio.SocketConnector;
+import org.mortbay.jetty.webapp.WebAppContext;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class JettyWebappTest extends TestCase 
+{
+  int port = 0;
+  static final String context = "/test";
+  
+  Server server;
+  
+  @Override
+  public void setUp() throws Exception 
+  {
+    System.setProperty("solr.solr.home", "../../../example/solr");
+    String path = "../../webapp/web";
+
+    server = new Server(port);
+    new WebAppContext(server, path, context );
+
+    SocketConnector connector = new SocketConnector();
+    connector.setMaxIdleTime(1000 * 60 * 60);
+    connector.setSoLingerTime(-1);
+    connector.setPort(0);
+    server.setConnectors(new Connector[]{connector});
+    server.setStopAtShutdown( true );
+    
+    server.start();
+    port = connector.getLocalPort();
+  }
+
+  @Override
+  public void tearDown() throws Exception 
+  {
+    try {
+      server.stop();
+    } catch( Exception ex ) {}
+  }
+  
+  public void testJSP() throws Exception
+  {
+    // Currently not an extensive test, but it does fire up the JSP pages and make 
+    // sure they compile ok
+    
+    String adminPath = "http://localhost:"+port+context+"/";
+    String html = IOUtils.toString( new URL(adminPath).openStream() );
+    assertNotNull( html ); // real error will be an exception
+
+    adminPath += "admin/";
+    html = IOUtils.toString( new URL(adminPath).openStream() );
+    assertNotNull( html ); // real error will be an exception
+
+    // analysis
+    html = IOUtils.toString( new URL(adminPath+"analysis.jsp").openStream() );
+    assertNotNull( html ); // real error will be an exception
+
+    // schema browser
+    html = IOUtils.toString( new URL(adminPath+"schema.jsp").openStream() );
+    assertNotNull( html ); // real error will be an exception
+
+    // schema browser
+    html = IOUtils.toString( new URL(adminPath+"threaddump.jsp").openStream() );
+    assertNotNull( html ); // real error will be an exception
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java b/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
new file mode 100644
index 0000000..e523562
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeEmbeddedTest.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import org.apache.solr.client.solrj.LargeVolumeTestBase;
+import org.apache.solr.client.solrj.SolrServer;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class LargeVolumeEmbeddedTest extends LargeVolumeTestBase {
+
+  SolrServer server;
+  
+  @Override public void setUp() throws Exception 
+  {
+    super.setUp();
+    
+    // setup the server...
+    server = createNewSolrServer();
+  }
+
+  @Override
+  protected SolrServer getSolrServer()
+  {
+    return server;
+  }
+
+  @Override
+  protected SolrServer createNewSolrServer()
+  {
+    return new EmbeddedSolrServer( h.getCoreContainer(), "" );
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java b/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
new file mode 100644
index 0000000..ff42d35
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/LargeVolumeJettyTest.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import org.apache.solr.client.solrj.LargeVolumeTestBase;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class LargeVolumeJettyTest extends LargeVolumeTestBase {
+
+  SolrServer server;
+  JettySolrRunner jetty;
+
+  int port = 0;
+  static final String context = "/example";
+
+  
+  @Override public void setUp() throws Exception 
+  {
+    super.setUp();
+    
+    jetty = new JettySolrRunner( context, 0 );
+    jetty.start();
+    port = jetty.getLocalPort();
+    
+    server = this.createNewSolrServer();
+  }
+
+  @Override public void tearDown() throws Exception 
+  {
+    super.tearDown();
+    jetty.stop();  // stop the server
+  }
+  
+
+  @Override
+  protected SolrServer getSolrServer()
+  {
+    return server;
+  }
+
+  @Override
+  protected SolrServer createNewSolrServer()
+  {
+    try {
+      // setup the server...
+      String url = "http://localhost:"+port+context;
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
+      s.setConnectionTimeout(100); // 1/10th sec
+      s.setDefaultMaxConnectionsPerHost(100);
+      s.setMaxTotalConnections(100);
+      return s;
+    }
+    catch( Exception ex ) {
+      throw new RuntimeException( ex );
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java b/src/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java
new file mode 100644
index 0000000..be95da0
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/MultiCoreEmbeddedTest.java
@@ -0,0 +1,65 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import java.io.File;
+
+import org.apache.solr.client.solrj.MultiCoreExampleTestBase;
+import org.apache.solr.client.solrj.SolrServer;
+
+/**
+ * This runs SolrServer test using 
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class MultiCoreEmbeddedTest extends MultiCoreExampleTestBase {
+
+  @Override public void setUp() throws Exception 
+  {
+    super.setUp();
+    
+    File home = new File( getSolrHome() );
+    File f = new File( home, "solr.xml" );
+    cores.load( getSolrHome(), f );
+  }
+
+  @Override
+  protected SolrServer getSolrCore0()
+  {
+    return new EmbeddedSolrServer( cores, "core0" );
+  }
+
+  @Override
+  protected SolrServer getSolrCore1()
+  {
+    return new EmbeddedSolrServer( cores, "core1" );
+  }
+
+  @Override
+  protected SolrServer getSolrCore(String name)
+  {
+    return new EmbeddedSolrServer( cores, name );
+  }
+
+  @Override
+  protected SolrServer getSolrAdmin()
+  {
+    return new EmbeddedSolrServer( cores, "core0" );
+  } 
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java b/src/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java
new file mode 100644
index 0000000..a08c61e
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/MultiCoreExampleJettyTest.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import org.apache.solr.client.solrj.MultiCoreExampleTestBase;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+
+/**
+ * TODO? perhaps use:
+ *  http://docs.codehaus.org/display/JETTY/ServletTester
+ * rather then open a real connection?
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class MultiCoreExampleJettyTest extends MultiCoreExampleTestBase {
+
+  JettySolrRunner jetty;
+
+  int port = 0;
+  static final String context = "/example";
+  
+  @Override public void setUp() throws Exception 
+  {    
+    super.setUp();
+
+    jetty = new JettySolrRunner( context, 0 );
+    jetty.start();
+    port = jetty.getLocalPort();
+
+    h.getCoreContainer().setPersistent(false);    
+  }
+
+  @Override public void tearDown() throws Exception 
+  {
+    super.tearDown();
+    jetty.stop();  // stop the server
+  }
+  
+
+  @Override
+  protected SolrServer getSolrCore(String name)
+  {
+    return createServer(name);
+  }
+
+  @Override
+  protected SolrServer getSolrCore0()
+  {
+    return createServer( "core0" );
+  }
+
+  @Override
+  protected SolrServer getSolrCore1()
+  {
+    return createServer( "core1" );
+  }
+
+  @Override
+  protected SolrServer getSolrAdmin()
+  {
+    return createServer( "" );
+  } 
+  
+  private SolrServer createServer( String name )
+  {
+    try {
+      // setup the server...
+      String url = "http://localhost:"+port+context+"/"+name;
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
+      s.setConnectionTimeout(100); // 1/10th sec
+      s.setDefaultMaxConnectionsPerHost(100);
+      s.setMaxTotalConnections(100);
+      return s;
+    }
+    catch( Exception ex ) {
+      throw new RuntimeException( ex );
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java b/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
new file mode 100644
index 0000000..36c57af
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/SolrExampleEmbeddedTest.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import org.apache.solr.client.solrj.SolrExampleTests;
+import org.apache.solr.client.solrj.SolrServer;
+
+/**
+ * This runs SolrServer test using 
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrExampleEmbeddedTest extends SolrExampleTests {
+
+  SolrServer server;
+  
+  @Override public void setUp() throws Exception 
+  {
+    super.setUp();
+    
+    // setup the server...
+    server = createNewSolrServer();
+  }
+
+  @Override
+  protected SolrServer getSolrServer()
+  {
+    return server;
+  }
+
+  @Override
+  protected SolrServer createNewSolrServer()
+  {
+    return new EmbeddedSolrServer( h.getCoreContainer(), "" );
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java b/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
new file mode 100644
index 0000000..d0c4a20
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/SolrExampleJettyTest.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import org.apache.solr.client.solrj.SolrExampleTests;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.schema.SchemaField;
+import org.junit.Assert;
+
+/**
+ * TODO? perhaps use:
+ *  http://docs.codehaus.org/display/JETTY/ServletTester
+ * rather then open a real connection?
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class SolrExampleJettyTest extends SolrExampleTests {
+
+  SolrServer server;
+  JettySolrRunner jetty;
+
+  int port = 0;
+  static final String context = "/example";
+  
+  @Override public void setUp() throws Exception 
+  {
+    super.setUp();
+    
+    jetty = new JettySolrRunner( context, 0 );
+    jetty.start();
+    port = jetty.getLocalPort();
+    System.out.println("Assigned Port#" + port);
+    server = this.createNewSolrServer();
+  }
+
+  @Override public void tearDown() throws Exception 
+  {
+    super.tearDown();
+    jetty.stop();  // stop the server
+  }
+  
+  
+  @Override
+  protected SolrServer getSolrServer()
+  {
+    return server;
+  }
+
+  @Override
+  protected SolrServer createNewSolrServer()
+  {
+    try {
+      // setup the server...
+      String url = "http://localhost:"+port+context;
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
+      s.setConnectionTimeout(100); // 1/10th sec
+      s.setDefaultMaxConnectionsPerHost(100);
+      s.setMaxTotalConnections(100);
+      return s;
+    }
+    catch( Exception ex ) {
+      throw new RuntimeException( ex );
+    }
+  }
+  
+  public void testBadSetup()
+  {
+    try {
+      // setup the server...
+      String url = "http://localhost/?core=xxx";
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer( url );
+      Assert.fail( "CommonsHttpSolrServer should not allow a path with a parameter: "+s.getBaseURL() );
+    }
+    catch( Exception ex ) {
+      // expected
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java b/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
new file mode 100644
index 0000000..9aed3a7
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/embedded/TestSolrProperties.java
@@ -0,0 +1,169 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import static junit.framework.Assert.assertEquals;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.request.CoreAdminRequest;
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.client.solrj.request.UpdateRequest;
+import org.apache.solr.client.solrj.request.UpdateRequest.ACTION;
+import org.apache.solr.client.solrj.response.CoreAdminResponse;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.util.AbstractSolrTestCase;
+import org.junit.After;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.File;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class TestSolrProperties {
+  protected static Logger log = LoggerFactory.getLogger(TestSolrProperties.class);
+  protected CoreContainer cores = null;
+
+  public String getSolrHome() {
+    return "solr/shared";
+  }
+
+  public String getSolrXml() {
+    return "solr.xml";
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    System.setProperty("solr.solr.home", getSolrHome());
+
+    log.info("pwd: " + (new File(".")).getAbsolutePath());
+    File home = new File(getSolrHome());
+    File f = new File(home, "solr.xml");
+    cores = new CoreContainer(getSolrHome(), f);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    if (cores != null)
+      cores.shutdown();
+    File dataDir = new File(getSolrHome() + "/data");
+    String skip = System.getProperty("solr.test.leavedatadir");
+    if (null != skip && 0 != skip.trim().length()) {
+      log.info("NOTE: per solr.test.leavedatadir, dataDir will not be removed: " + dataDir.getAbsolutePath());
+    } else {
+      if (!AbstractSolrTestCase.recurseDelete(dataDir)) {
+        log.warn("!!!! WARNING: best effort to remove " + dataDir.getAbsolutePath() + " FAILED !!!!!");
+      }
+    }
+    File persistedFile = new File(getSolrHome() + File.separator + "solr-persist.xml");
+    persistedFile.delete();
+  }
+
+  protected SolrServer getSolrCore0() {
+    return new EmbeddedSolrServer(cores, "core0");
+  }
+
+
+  protected SolrServer getSolrCore1() {
+    return new EmbeddedSolrServer(cores, "core1");
+  }
+
+  protected SolrServer getSolrAdmin() {
+    return new EmbeddedSolrServer(cores, "core0");
+  }
+
+  protected SolrServer getSolrCore(String name) {
+    return new EmbeddedSolrServer(cores, name);
+  }
+
+  @Test
+  public void testProperties() throws Exception {
+    UpdateRequest up = new UpdateRequest();
+    up.setAction(ACTION.COMMIT, true, true);
+    up.deleteByQuery("*:*");
+    up.process(getSolrCore0());
+    up.process(getSolrCore1());
+    up.clear();
+
+    // Add something to each core
+    SolrInputDocument doc = new SolrInputDocument();
+    doc.setField("id", "AAA");
+    doc.setField("core0", "yup stopfra stopfrb stopena stopenb");
+
+    // Add to core0
+    up.add(doc);
+    up.process(getSolrCore0());
+
+    // You can't add it to core1
+    try {
+      up.process(getSolrCore1());
+      fail("Can't add core0 field to core1!");
+    }
+    catch (Exception ex) {
+    }
+
+    // Add to core1
+    doc.setField("id", "BBB");
+    doc.setField("core1", "yup stopfra stopfrb stopena stopenb");
+    doc.removeField("core0");
+    up.add(doc);
+    up.process(getSolrCore1());
+
+    // You can't add it to core1
+    try {
+      up.process(getSolrCore0());
+      fail("Can't add core1 field to core0!");
+    }
+    catch (Exception ex) {
+    }
+
+    // now Make sure AAA is in 0 and BBB in 1
+    SolrQuery q = new SolrQuery();
+    QueryRequest r = new QueryRequest(q);
+    q.setQuery("id:AAA");
+    assertEquals(1, r.process(getSolrCore0()).getResults().size());
+    assertEquals(0, r.process(getSolrCore1()).getResults().size());
+
+    // Now test Changing the default core
+    assertEquals(1, getSolrCore0().query(new SolrQuery("id:AAA")).getResults().size());
+    assertEquals(0, getSolrCore0().query(new SolrQuery("id:BBB")).getResults().size());
+
+    assertEquals(0, getSolrCore1().query(new SolrQuery("id:AAA")).getResults().size());
+    assertEquals(1, getSolrCore1().query(new SolrQuery("id:BBB")).getResults().size());
+
+    // Now test reloading it should have a newer open time
+    String name = "core0";
+    SolrServer coreadmin = getSolrAdmin();
+    CoreAdminResponse mcr = CoreAdminRequest.getStatus(name, coreadmin);
+    long before = mcr.getStartTime(name).getTime();
+    CoreAdminRequest.reloadCore(name, coreadmin);
+
+    mcr = CoreAdminRequest.getStatus(name, coreadmin);
+    long after = mcr.getStartTime(name).getTime();
+    assertTrue("should have more recent time: " + after + "," + before, after > before);
+
+    mcr = CoreAdminRequest.persist("solr-persist.xml", coreadmin);
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/response/QueryResponseTest.java b/src/test/org/apache/solr/client/solrj/response/QueryResponseTest.java
new file mode 100644
index 0000000..694cdac
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/response/QueryResponseTest.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.response;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.FileReader;
+
+import junit.framework.Assert;
+
+import org.apache.solr.client.solrj.impl.XMLResponseParser;
+import org.apache.solr.common.util.NamedList;
+import org.junit.Test;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Simple test for Date facet support in QueryResponse
+ * 
+ * @since solr 1.3
+ */
+public class QueryResponseTest {
+  @Test
+  public void testDateFacets() throws Exception   {
+    XMLResponseParser parser = new XMLResponseParser();
+    FileReader in = new FileReader("sampleDateFacetResponse.xml");
+    assertTrue("in is null and it shouldn't be", in != null);
+    NamedList<Object> response = parser.processResponse(in);
+    in.close();
+    
+    QueryResponse qr = new QueryResponse(response, null);
+    Assert.assertNotNull(qr);
+    
+    Assert.assertNotNull(qr.getFacetDates());
+    
+    for (FacetField f : qr.getFacetDates()) {
+      Assert.assertNotNull(f);
+      System.out.println(f.toString());
+      System.out.println("GAP: " + f.getGap());
+      System.out.println("END: " + f.getEnd());
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java b/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
new file mode 100644
index 0000000..7eb7e0c
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/response/TestSpellCheckResponse.java
@@ -0,0 +1,107 @@
+package org.apache.solr.client.solrj.response;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.Assert;
+import org.apache.solr.client.solrj.SolrExampleTestBase;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.embedded.JettySolrRunner;
+import org.apache.solr.client.solrj.impl.CommonsHttpSolrServer;
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.SpellingParams;
+
+/**
+ * Test for SpellCheckComponent's response in Solrj
+ *
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class TestSpellCheckResponse extends SolrExampleTestBase {
+
+  SolrServer server;
+  JettySolrRunner jetty;
+
+  int port = 0;
+  static final String context = "/example";
+
+  public void setUp() throws Exception {
+    super.setUp();
+
+    jetty = new JettySolrRunner(context, 0);
+    jetty.start();
+    port = jetty.getLocalPort();
+    System.out.println("Assigned Port: " + port);
+    server = this.createNewSolrServer();
+  }
+
+  public void testSpellCheckResponse() throws Exception {
+    SolrInputDocument doc = new SolrInputDocument();
+    doc.setField("id", "AAA");
+    doc.setField("name", "Samsung");
+    server.add(doc);
+    server.commit(true, true);
+
+    SolrQuery query = new SolrQuery("*:*");
+    query.set(CommonParams.QT, "/spellCheckCompRH");
+    query.set("spellcheck", true);
+    query.set(SpellingParams.SPELLCHECK_Q, "samsang");
+    query.set(SpellingParams.SPELLCHECK_BUILD, true);
+    QueryRequest request = new QueryRequest(query);
+    SpellCheckResponse response = request.process(server).getSpellCheckResponse();
+    Assert.assertEquals("Incorrect spelling results", "samsung", response.getFirstSuggestion("samsang"));
+  }
+
+  public void testSpellCheckResponse_Extended() throws Exception {
+    SolrInputDocument doc = new SolrInputDocument();
+    doc.setField("id", "AAA");
+    doc.setField("name", "Samsung");
+    server.add(doc);
+    server.commit(true, true);
+
+    SolrQuery query = new SolrQuery("*:*");
+    query.set(CommonParams.QT, "/spellCheckCompRH");
+    query.set("spellcheck", true);
+    query.set(SpellingParams.SPELLCHECK_Q, "samsang");
+    query.set(SpellingParams.SPELLCHECK_BUILD, true);
+    query.set(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, true);
+    QueryRequest request = new QueryRequest(query);
+    SpellCheckResponse response = request.process(server).getSpellCheckResponse();
+    Assert.assertEquals("Incorrect spelling results", "samsung", response.getFirstSuggestion("samsang"));
+  }
+
+  protected SolrServer getSolrServer() {
+    return server;
+  }
+
+  protected SolrServer createNewSolrServer() {
+    try {
+      // setup the server...
+      String url = "http://localhost:" + port + context;
+      CommonsHttpSolrServer s = new CommonsHttpSolrServer(url);
+      s.setConnectionTimeout(100); // 1/10th sec
+      s.setDefaultMaxConnectionsPerHost(100);
+      s.setMaxTotalConnections(100);
+      return s;
+    }
+    catch (Exception ex) {
+      throw new RuntimeException(ex);
+    }
+  }
+}
diff --git a/src/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java b/src/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java
new file mode 100644
index 0000000..77beeb3
--- /dev/null
+++ b/src/test/org/apache/solr/client/solrj/util/ClientUtilsTest.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.util;
+
+import junit.framework.TestCase;
+
+/**
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class ClientUtilsTest extends TestCase {
+  
+  public void testEscapeQuery() 
+  { 
+    assertEquals( "nochange", ClientUtils.escapeQueryChars( "nochange" ) );
+    assertEquals( "12345", ClientUtils.escapeQueryChars( "12345" ) );
+    assertEquals( "with\\ space", ClientUtils.escapeQueryChars( "with space" ) );
+    assertEquals( "h\\:ello\\!", ClientUtils.escapeQueryChars( "h:ello!" ) );
+    assertEquals( "h\\~\\!", ClientUtils.escapeQueryChars( "h~!" ) );
+  }
+}
diff --git a/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java b/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
new file mode 100644
index 0000000..e822eee
--- /dev/null
+++ b/src/webapp/src/org/apache/solr/client/solrj/embedded/EmbeddedSolrServer.java
@@ -0,0 +1,172 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import java.io.IOException;
+
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.ModifiableSolrParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.core.CoreContainer;
+import org.apache.solr.core.CoreDescriptor;
+import org.apache.solr.core.SolrCore;
+import org.apache.solr.request.BinaryResponseWriter;
+import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.request.SolrQueryResponse;
+import org.apache.solr.request.SolrRequestHandler;
+import org.apache.solr.servlet.SolrRequestParsers;
+
+/**
+ * SolrServer that connects directly to SolrCore
+ * 
+ * TODO -- this implementation sends the response to XML and then parses it.  
+ * It *should* be able to convert the response directly into a named list.
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class EmbeddedSolrServer extends SolrServer
+{
+  protected final CoreContainer coreContainer;
+  protected final String coreName;
+  private final SolrRequestParsers _parser;
+  
+  /**
+   * Use the other constructor using a CoreContainer and a name.
+   * @param core
+   * @deprecated
+   */
+  @Deprecated
+  public EmbeddedSolrServer( SolrCore core )
+  {
+    if ( core == null ) {
+      throw new NullPointerException("SolrCore instance required");
+    }
+    CoreDescriptor dcore = core.getCoreDescriptor();
+    if (dcore == null)
+      throw new NullPointerException("CoreDescriptor required");
+    
+    CoreContainer cores = dcore.getCoreContainer();
+    if (cores == null)
+      throw new NullPointerException("CoreContainer required");
+    
+    coreName = dcore.getName();
+    coreContainer = cores;
+    _parser = new SolrRequestParsers( null );
+  }
+    
+  /**
+   * Creates a SolrServer.
+   * @param coreContainer the core container
+   * @param coreName the core name
+   */
+  public EmbeddedSolrServer(  CoreContainer coreContainer, String coreName )
+  {
+    if ( coreContainer == null ) {
+      throw new NullPointerException("CoreContainer instance required");
+    }
+    this.coreContainer = coreContainer;
+    this.coreName = coreName == null? "" : coreName;
+    _parser = new SolrRequestParsers( null );
+  }
+  
+  @Override
+  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException 
+  {
+    String path = request.getPath();
+    if( path == null || !path.startsWith( "/" ) ) {
+      path = "/select";
+    }
+
+    // Check for cores action
+    SolrCore core =  coreContainer.getCore( coreName );
+    if( core == null ) {
+      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, 
+                               "No such core: " + coreName );
+    }
+    
+    SolrParams params = request.getParams();
+    if( params == null ) {
+      params = new ModifiableSolrParams();
+    }
+    
+    // Extract the handler from the path or params
+    SolrRequestHandler handler = core.getRequestHandler( path );
+    if( handler == null ) {
+      if( "/select".equals( path ) || "/select/".equalsIgnoreCase( path) ) {
+        String qt = params.get( CommonParams.QT );
+        handler = core.getRequestHandler( qt );
+        if( handler == null ) {
+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
+        }
+      }
+      // Perhaps the path is to manage the cores
+      if( handler == null &&
+          coreContainer != null &&
+          path.equals( coreContainer.getAdminPath() ) ) {
+        handler = coreContainer.getMultiCoreHandler();
+      }
+    }
+    if( handler == null ) {
+      core.close();
+      throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+path );
+    }
+
+    try {
+      SolrQueryRequest req = _parser.buildRequestFrom( core, params, request.getContentStreams() );
+      req.getContext().put( "path", path );
+      SolrQueryResponse rsp = new SolrQueryResponse();
+      core.execute( handler, req, rsp );
+      if( rsp.getException() != null ) {
+        throw new SolrServerException( rsp.getException() );
+      }
+      
+      // Now write it out
+      NamedList<Object> normalized = getParsedResponse(req, rsp);
+      req.close();
+      return normalized;
+    }
+    catch( IOException iox ) {
+      throw iox;
+    }
+    catch( Exception ex ) {
+      throw new SolrServerException( ex );
+    }
+    finally {
+      core.close();
+    }
+  }
+  
+  /**
+   * @param req
+   * @param rsp
+   * @return a response object equivalent to what you get from the XML/JSON/javabin parser. Documents
+   * become SolrDocuments, DocList becomes SolrDocumentList etc.
+   * 
+   * @deprecated use {@link BinaryResponseWriter#getParsedResponse(SolrQueryRequest, SolrQueryResponse)}
+   */
+  public NamedList<Object> getParsedResponse( SolrQueryRequest req, SolrQueryResponse rsp )
+  {
+    return BinaryResponseWriter.getParsedResponse(req, rsp);
+  }
+}
diff --git a/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java b/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java
new file mode 100644
index 0000000..ff7a058
--- /dev/null
+++ b/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner.java
@@ -0,0 +1,190 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.client.solrj.embedded;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.solr.servlet.SolrDispatchFilter;
+import org.mortbay.jetty.Handler;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.Connector;
+import org.mortbay.jetty.servlet.Context;
+import org.mortbay.jetty.servlet.FilterHolder;
+import org.mortbay.log.Logger;
+
+/**
+ * Run solr using jetty
+ * 
+ * @version $Id$
+ * @since solr 1.3
+ */
+public class JettySolrRunner 
+{
+  Server server;
+  FilterHolder dispatchFilter;
+  
+  public JettySolrRunner( String context, int port )
+  {
+    this.init( context, port );
+  }
+
+  public JettySolrRunner( String context, int port, String solrConfigFilename )
+  {
+    this.init( context, port );
+    dispatchFilter.setInitParameter("solrconfig-filename", solrConfigFilename);
+  }
+  
+//  public JettySolrRunner( String context, String home, String dataDir, int port, boolean log )
+//  {
+//    if(!log) {
+//      System.setProperty("org.mortbay.log.class", NoLog.class.getName() );
+//      System.setProperty("java.util.logging.config.file", home+"/conf/logging.properties");
+//      NoLog noLogger = new NoLog();
+//      org.mortbay.log.Log.setLog(noLogger);
+//    }
+//
+//    // Initalize JNDI
+//    Config.setInstanceDir(home);
+//    new SolrCore(dataDir, new IndexSchema(home+"/conf/schema.xml"));
+//    this.init( context, port );
+//  }
+  
+  private void init( String context, int port )
+  {
+    server = new Server( port );    
+    server.setStopAtShutdown( true );
+    
+    // Initialize the servlets
+    Context root = new Context( server, context, Context.SESSIONS );
+    
+    // for some reason, there must be a servlet for this to get applied
+    root.addServlet( Servlet404.class, "/*" );
+    dispatchFilter = root.addFilter( SolrDispatchFilter.class, "*", Handler.REQUEST );
+  }
+
+  //------------------------------------------------------------------------------------------------
+  //------------------------------------------------------------------------------------------------
+  
+  public void start() throws Exception
+  {
+    if(!server.isRunning() ) {
+      server.start();
+    }
+  }
+  
+  public void stop() throws Exception
+  {
+    if( server.isRunning() ) {
+      server.stop();
+      server.join();
+    }
+  }
+
+  /**
+   * Returns the Local Port of the first Connector found for the jetty Server.
+   * @exception RuntimeException if there is no Connector
+   */
+  public int getLocalPort() {
+    Connector[] conns = server.getConnectors();
+    if (0 == conns.length) {
+      throw new RuntimeException("Jetty Server has no Connectors");
+    }
+    return conns[0].getLocalPort();
+  }
+  
+  //--------------------------------------------------------------
+  //--------------------------------------------------------------
+    
+  /** 
+   * This is a stupid hack to give jetty something to attach to
+   */
+  public static class Servlet404 extends HttpServlet
+  {
+    @Override
+    public void service(HttpServletRequest req, HttpServletResponse res ) throws IOException
+    {
+      res.sendError( 404, "Can not find: "+req.getRequestURI() );
+    }
+  }
+  
+  /**
+   * A main class that starts jetty+solr 
+   * This is useful for debugging
+   */
+  public static void main( String[] args )
+  {
+    try {
+      JettySolrRunner jetty = new JettySolrRunner( "/solr", 3456 );
+      jetty.start();
+    }
+    catch( Exception ex ) {
+      ex.printStackTrace();
+    }
+  }
+}
+
+
+class NoLog implements Logger
+{    
+  private static boolean debug = System.getProperty("DEBUG",null)!=null;
+  private final String name;
+      
+  public NoLog()
+  {
+    this(null);
+  }
+  
+  public NoLog(String name)
+  {    
+    this.name=name==null?"":name;
+  }
+  
+  public boolean isDebugEnabled()
+  {
+    return debug;
+  }
+  
+  public void setDebugEnabled(boolean enabled)
+  {
+    debug=enabled;
+  }
+  
+  public void info(String msg,Object arg0, Object arg1) {}
+  public void debug(String msg,Throwable th){}
+  public void debug(String msg,Object arg0, Object arg1){}
+  public void warn(String msg,Object arg0, Object arg1){}
+  public void warn(String msg, Throwable th){}
+
+  public Logger getLogger(String name)
+  {
+    if ((name==null && this.name==null) ||
+      (name!=null && name.equals(this.name)))
+      return this;
+    return new NoLog(name);
+  }
+  
+  @Override
+  public String toString()
+  {
+    return "NOLOG["+name+"]";
+  }
+}

