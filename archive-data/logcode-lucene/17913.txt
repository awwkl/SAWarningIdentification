GitDiffStart: acbf053b7c3d6caa0287cd615ad3b282f726a0eb | Mon May 17 11:28:04 2010 +0000
diff --git a/lucene/contrib/CHANGES.txt b/lucene/contrib/CHANGES.txt
index c1da64a..ee3595c 100644
--- a/lucene/contrib/CHANGES.txt
+++ b/lucene/contrib/CHANGES.txt
@@ -157,6 +157,9 @@ New features
  * LUCENE-2393: The HighFreqTerms tool (in misc) can now optionally
    also include the total termFreq.  (Tom Burton-West via Mike McCandless)
 
+ * LUCENE-2463: Add a Greek inflectional stemmer. GreekAnalyzer will now stem words
+   when Version is set to 3.1 or higher.  (Robert Muir)
+
 Build
 
  * LUCENE-2124: Moved the JDK-based collation support from contrib/collation 
diff --git a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
index 477881b..4dcf341 100644
--- a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
+++ b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekAnalyzer.java
@@ -16,9 +16,7 @@ package org.apache.lucene.analysis.el;
  * limitations under the License.
  */
 
-
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.CharArraySet;
 import org.apache.lucene.analysis.StopFilter;
 import org.apache.lucene.analysis.StopwordAnalyzerBase;
 import org.apache.lucene.analysis.TokenStream;
@@ -28,8 +26,8 @@ import org.apache.lucene.analysis.standard.StandardTokenizer;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;  // for javadoc
 import org.apache.lucene.util.Version;
 
+import java.io.IOException;
 import java.io.Reader;
-import java.util.Arrays;
 import java.util.Map;
 import java.util.Set;
 
@@ -45,7 +43,7 @@ import java.util.Set;
  * <p>You must specify the required {@link Version}
  * compatibility when creating GreekAnalyzer:
  * <ul>
- *   <li> As of 3.1, StandardFilter is used by default.
+ *   <li> As of 3.1, StandardFilter and GreekStemmer are used by default.
  *   <li> As of 2.9, StopFilter preserves position
  *        increments
  * </ul>
@@ -53,73 +51,74 @@ import java.util.Set;
  * <p><b>NOTE</b>: This class uses the same {@link Version}
  * dependent settings as {@link StandardAnalyzer}.</p>
  */
-public final class GreekAnalyzer extends StopwordAnalyzerBase
-{
-    /**
-     * List of typical Greek stopwords.
-     */
-    private static final String[] GREEK_STOP_WORDS = {
-      "ο", "η", "?ο", "οι", "?α", "?ο?", "?η?", "??ν", "?ον", "?ην", "και", 
-      "κι", "κ", "ειμαι", "ει?αι", "ειναι", "ειμα??ε", "ει??ε", "??ο", "??ον",
-      "??η", "??ην", "μα", "αλλα", "α?ο", "για", "??ο?", "με", "?ε", "??",
-      "?α?α", "αν?ι", "κα?α", "με?α", "θα", "να", "δε", "δεν", "μη", "μην",
-      "ε?ι", "εν?", "εαν", "αν", "?ο?ε", "?ο?", "???", "?οιο?", "?οια", "?οιο",
-      "?οιοι", "?οιε?", "?οι?ν", "?οιο??", "α??ο?", "α??η", "α??ο", "α??οι",
-      "α???ν", "α??ο??", "α??ε?", "α??α", "εκεινο?", "εκεινη", "εκεινο",
-      "εκεινοι", "εκεινε?", "εκεινα", "εκειν?ν", "εκεινο??", "ο???", "ομ??",
-      "ι???", "ο?ο", "ο?ι"
-    };
-    
-    /**
-     * Returns a set of default Greek-stopwords 
-     * @return a set of default Greek-stopwords 
-     */
-    public static final Set<?> getDefaultStopSet(){
-      return DefaultSetHolder.DEFAULT_SET;
-    }
-    
-    private static class DefaultSetHolder {
-      private static final Set<?> DEFAULT_SET = CharArraySet.unmodifiableSet(new CharArraySet(
-          Version.LUCENE_CURRENT, Arrays.asList(GREEK_STOP_WORDS), false));
-    }
-
-    public GreekAnalyzer(Version matchVersion) {
-      this(matchVersion, DefaultSetHolder.DEFAULT_SET);
-    }
+public final class GreekAnalyzer extends StopwordAnalyzerBase {
+  /** File containing default Greek stopwords. */
+  public final static String DEFAULT_STOPWORD_FILE = "stopwords.txt";
+  
+  /**
+   * Returns a set of default Greek-stopwords 
+   * @return a set of default Greek-stopwords 
+   */
+  public static final Set<?> getDefaultStopSet(){
+    return DefaultSetHolder.DEFAULT_SET;
+  }
+  
+  private static class DefaultSetHolder {
+    private static final Set<?> DEFAULT_SET;
     
-    /**
-     * Builds an analyzer with the given stop words 
-     * 
-     * @param matchVersion
-     *          lucene compatibility version
-     * @param stopwords
-     *          a stopword set
-     */
-    public GreekAnalyzer(Version matchVersion, Set<?> stopwords) {
-      super(matchVersion, stopwords);
+    static {
+      try {
+        DEFAULT_SET = loadStopwordSet(false, GreekAnalyzer.class, DEFAULT_STOPWORD_FILE, "#");
+      } catch (IOException ex) {
+        // default set should always be present as it is part of the
+        // distribution (JAR)
+        throw new RuntimeException("Unable to load default stopword set");
+      }
     }
-
-    /**
-     * Builds an analyzer with the given stop words.
-     * @param stopwords Array of stopwords to use.
-     * @deprecated use {@link #GreekAnalyzer(Version, Set)} instead
-     */
-    @Deprecated
-    public GreekAnalyzer(Version matchVersion, String... stopwords)
-    {
-      this(matchVersion, StopFilter.makeStopSet(matchVersion, stopwords));
-    }
-
-    /**
-     * Builds an analyzer with the given stop words.
-     * @deprecated use {@link #GreekAnalyzer(Version, Set)} instead
-     */
-    @Deprecated
-    public GreekAnalyzer(Version matchVersion, Map<?,?> stopwords)
-    {
-      this(matchVersion, stopwords.keySet());
-    }
-
+  }
+  
+  /**
+   * Builds an analyzer with the default stop words.
+   * @param matchVersion Lucene compatibility version,
+   *   See <a href="#version">above</a>
+   */
+  public GreekAnalyzer(Version matchVersion) {
+    this(matchVersion, DefaultSetHolder.DEFAULT_SET);
+  }
+  
+  /**
+   * Builds an analyzer with the given stop words. 
+   * <p>
+   * <b>NOTE:</b> The stopwords set should be pre-processed with the logic of 
+   * {@link GreekLowerCaseFilter} for best results.
+   *  
+   * @param matchVersion Lucene compatibility version,
+   *   See <a href="#version">above</a>
+   * @param stopwords a stopword set
+   */
+  public GreekAnalyzer(Version matchVersion, Set<?> stopwords) {
+    super(matchVersion, stopwords);
+  }
+  
+  /**
+   * Builds an analyzer with the given stop words.
+   * @param stopwords Array of stopwords to use.
+   * @deprecated use {@link #GreekAnalyzer(Version, Set)} instead
+   */
+  @Deprecated
+  public GreekAnalyzer(Version matchVersion, String... stopwords) {
+    this(matchVersion, StopFilter.makeStopSet(matchVersion, stopwords));
+  }
+  
+  /**
+   * Builds an analyzer with the given stop words.
+   * @deprecated use {@link #GreekAnalyzer(Version, Set)} instead
+   */
+  @Deprecated
+  public GreekAnalyzer(Version matchVersion, Map<?,?> stopwords) {
+    this(matchVersion, stopwords.keySet());
+  }
+  
   /**
    * Creates
    * {@link org.apache.lucene.analysis.ReusableAnalyzerBase.TokenStreamComponents}
@@ -127,16 +126,19 @@ public final class GreekAnalyzer extends StopwordAnalyzerBase
    * 
    * @return {@link org.apache.lucene.analysis.ReusableAnalyzerBase.TokenStreamComponents}
    *         built from a {@link StandardTokenizer} filtered with
-   *         {@link GreekLowerCaseFilter}, {@link StandardFilter} and
-   *         {@link StopFilter}
+   *         {@link GreekLowerCaseFilter}, {@link StandardFilter},
+   *         {@link StopFilter}, and {@link GreekStemFilter}
    */
-    @Override
-    protected TokenStreamComponents createComponents(String fieldName,
-        Reader reader) {
-      final Tokenizer source = new StandardTokenizer(matchVersion, reader);
-      TokenStream result = new GreekLowerCaseFilter(source);
-      if (matchVersion.onOrAfter(Version.LUCENE_31))
-        result = new StandardFilter(result);
-      return new TokenStreamComponents(source, new StopFilter(matchVersion, result, stopwords));
-    }
+  @Override
+  protected TokenStreamComponents createComponents(String fieldName,
+      Reader reader) {
+    final Tokenizer source = new StandardTokenizer(matchVersion, reader);
+    TokenStream result = new GreekLowerCaseFilter(matchVersion, source);
+    if (matchVersion.onOrAfter(Version.LUCENE_31))
+      result = new StandardFilter(result);
+    result = new StopFilter(matchVersion, result, stopwords);
+    if (matchVersion.onOrAfter(Version.LUCENE_31))
+      result = new GreekStemFilter(result);
+    return new TokenStreamComponents(source, result);
+  }
 }
diff --git a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekLowerCaseFilter.java b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekLowerCaseFilter.java
index 53da0b8..d93860e 100644
--- a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekLowerCaseFilter.java
+++ b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekLowerCaseFilter.java
@@ -20,97 +20,115 @@ import java.io.IOException;
 
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.util.CharacterUtils;
+import org.apache.lucene.util.Version;
 
 /**
  * Normalizes token text to lower case, removes some Greek diacritics,
  * and standardizes final sigma to sigma. 
- *
+ * <a name="version"/>
+ * <p>You must specify the required {@link Version}
+ * compatibility when creating GreekLowerCaseFilter:
+ * <ul>
+ *   <li> As of 3.1, supplementary characters are properly lowercased.
+ * </ul>
  */
-public final class GreekLowerCaseFilter extends TokenFilter
-{
-    private TermAttribute termAtt;
-    
-    public GreekLowerCaseFilter(TokenStream in)
-    {
-    	super(in);
-    	termAtt = addAttribute(TermAttribute.class);
-    }
+public final class GreekLowerCaseFilter extends TokenFilter {
+  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+  private final CharacterUtils charUtils;
 
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (input.incrementToken()) {
-        char[] chArray = termAtt.termBuffer();
-        int chLen = termAtt.termLength();
-        // TODO: iterate codepoints to support supp. characters
-        for (int i = 0; i < chLen; i++)
-        {
-          chArray[i] = (char) lowerCase(chArray[i]);
-        }
-        return true;
-      } else {
-        return false;
-      }
+  /** @deprecated Use {@link #GreekLowerCaseFilter(Version, TokenStream)} instead. */
+  @Deprecated
+  public GreekLowerCaseFilter(TokenStream in) {
+    this(Version.LUCENE_30, in);
+  }
+  
+  /**
+   * Create a GreekLowerCaseFilter that normalizes Greek token text.
+   * 
+   * @param matchVersion Lucene compatibility version, 
+   *   See <a href="#version">above</a>
+   * @param in TokenStream to filter
+   */
+  public GreekLowerCaseFilter(Version matchVersion, TokenStream in) {
+    super(in);
+    this.charUtils = CharacterUtils.getInstance(matchVersion);
+  }
+  
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char[] chArray = termAtt.buffer();
+      int chLen = termAtt.length();
+      for (int i = 0; i < chLen;) {
+        i += Character.toChars(
+            lowerCase(charUtils.codePointAt(chArray, i)), chArray, i);
+       }
+      return true;
+    } else {
+      return false;
     }
-    
-    private int lowerCase(int codepoint) {
-      switch(codepoint) {
-        /* There are two lowercase forms of sigma:
-         *   U+03C2: small final sigma (end of word)
-         *   U+03C3: small sigma (otherwise)
-         *   
-         * Standardize both to U+03C3
-         */
-        case '\u03C2': /* small final sigma */
-          return '\u03C3'; /* small sigma */
+  }
+  
+  private int lowerCase(int codepoint) {
+    switch(codepoint) {
+      /* There are two lowercase forms of sigma:
+       *   U+03C2: small final sigma (end of word)
+       *   U+03C3: small sigma (otherwise)
+       *   
+       * Standardize both to U+03C3
+       */
+      case '\u03C2': /* small final sigma */
+        return '\u03C3'; /* small sigma */
+        
+      /* Some greek characters contain diacritics.
+       * This filter removes these, converting to the lowercase base form.
+       */
+        
+      case '\u0386': /* capital alpha with tonos */
+      case '\u03AC': /* small alpha with tonos */
+        return '\u03B1'; /* small alpha */
+        
+      case '\u0388': /* capital epsilon with tonos */
+      case '\u03AD': /* small epsilon with tonos */
+        return '\u03B5'; /* small epsilon */
+        
+      case '\u0389': /* capital eta with tonos */
+      case '\u03AE': /* small eta with tonos */
+        return '\u03B7'; /* small eta */
+        
+      case '\u038A': /* capital iota with tonos */
+      case '\u03AA': /* capital iota with dialytika */
+      case '\u03AF': /* small iota with tonos */
+      case '\u03CA': /* small iota with dialytika */
+      case '\u0390': /* small iota with dialytika and tonos */
+        return '\u03B9'; /* small iota */
+        
+      case '\u038E': /* capital upsilon with tonos */
+      case '\u03AB': /* capital upsilon with dialytika */
+      case '\u03CD': /* small upsilon with tonos */
+      case '\u03CB': /* small upsilon with dialytika */
+      case '\u03B0': /* small upsilon with dialytika and tonos */
+        return '\u03C5'; /* small upsilon */
+        
+      case '\u038C': /* capital omicron with tonos */
+      case '\u03CC': /* small omicron with tonos */
+        return '\u03BF'; /* small omicron */
+        
+      case '\u038F': /* capital omega with tonos */
+      case '\u03CE': /* small omega with tonos */
+        return '\u03C9'; /* small omega */
         
-        /* Some greek characters contain diacritics.
-         * This filter removes these, converting to the lowercase base form.
-         */
+      /* The previous implementation did the conversion below.
+       * Only implemented for backwards compatibility with old indexes.
+       */
         
-        case '\u0386': /* capital alpha with tonos */
-        case '\u03AC': /* small alpha with tonos */
-          return '\u03B1'; /* small alpha */
-          
-        case '\u0388': /* capital epsilon with tonos */
-        case '\u03AD': /* small epsilon with tonos */
-          return '\u03B5'; /* small epsilon */
-          
-        case '\u0389': /* capital eta with tonos */
-        case '\u03AE': /* small eta with tonos */
-          return '\u03B7'; /* small eta */
+      case '\u03A2': /* reserved */
+        return '\u03C2'; /* small final sigma */
         
-        case '\u038A': /* capital iota with tonos */
-        case '\u03AA': /* capital iota with dialytika */
-        case '\u03AF': /* small iota with tonos */
-        case '\u03CA': /* small iota with dialytika */
-        case '\u0390': /* small iota with dialytika and tonos */
-          return '\u03B9'; /* small iota */
-          
-        case '\u038E': /* capital upsilon with tonos */
-        case '\u03AB': /* capital upsilon with dialytika */
-        case '\u03CD': /* small upsilon with tonos */
-        case '\u03CB': /* small upsilon with dialytika */
-        case '\u03B0': /* small upsilon with dialytika and tonos */
-          return '\u03C5'; /* small upsilon */
-          
-        case '\u038C': /* capital omicron with tonos */
-        case '\u03CC': /* small omicron with tonos */
-          return '\u03BF'; /* small omicron */
-          
-        case '\u038F': /* capital omega with tonos */
-        case '\u03CE': /* small omega with tonos */
-          return '\u03C9'; /* small omega */
-          
-        /* The previous implementation did the conversion below.
-         * Only implemented for backwards compatibility with old indexes.
-         */
-          
-        case '\u03A2': /* reserved */
-          return '\u03C2'; /* small final sigma */
-          
-        default:
-          return Character.toLowerCase(codepoint);
-      }
+      default:
+        return Character.toLowerCase(codepoint);
     }
+  }
 }
diff --git a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemFilter.java b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemFilter.java
new file mode 100644
index 0000000..4aef18d
--- /dev/null
+++ b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemFilter.java
@@ -0,0 +1,63 @@
+package org.apache.lucene.analysis.el;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.KeywordMarkerFilter; // for javadoc
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.KeywordAttribute;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+
+/**
+ * A {@link TokenFilter} that applies {@link GreekStemmer} to stem Greek
+ * words.
+ * <p>
+ * To prevent terms from being stemmed use an instance of
+ * {@link KeywordMarkerFilter} or a custom {@link TokenFilter} that sets
+ * the {@link KeywordAttribute} before this {@link TokenStream}.
+ * </p>
+ * <p>
+ * NOTE: Input is expected to be casefolded for Greek (including folding of final
+ * sigma to sigma), and with diacritics removed. This can be achieved by using 
+ * either {@link GreekLowerCaseFilter} or ICUFoldingFilter before GreekStemFilter.
+ * @lucene.experimental
+ */
+public final class GreekStemFilter extends TokenFilter {
+  private final GreekStemmer stemmer = new GreekStemmer();
+  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+  private final KeywordAttribute keywordAttr = addAttribute(KeywordAttribute.class);
+  
+  public GreekStemFilter(TokenStream input) {
+    super(input);
+  }
+  
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      if(!keywordAttr.isKeyword()) {
+        final int newlen = stemmer.stem(termAtt.buffer(), termAtt.length());
+        termAtt.setLength(newlen);
+      }
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
diff --git a/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemmer.java b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemmer.java
new file mode 100644
index 0000000..53cef6a
--- /dev/null
+++ b/modules/analysis/common/src/java/org/apache/lucene/analysis/el/GreekStemmer.java
@@ -0,0 +1,819 @@
+package org.apache.lucene.analysis.el;
+
+import org.apache.lucene.analysis.CharArraySet;
+import org.apache.lucene.util.Version;
+
+import java.util.Arrays;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A stemmer for Greek words, according to: <i>Development of a Stemmer for the
+ * Greek Language.</i> Georgios Ntais
+ * <p>
+ * NOTE: Input is expected to be casefolded for Greek (including folding of final
+ * sigma to sigma), and with diacritics removed. This can be achieved with 
+ * either {@link GreekLowerCaseFilter} or ICUFoldingFilter.
+ * @lucene.experimental
+ */
+public class GreekStemmer {
+  public int stem(char s[], int len) {
+    if (len < 4) // too short
+      return len;
+    
+    final int origLen = len;
+    // "short rules": if it hits one of these, it skips the "long list"
+    len = rule0(s, len);
+    len = rule1(s, len);
+    len = rule2(s, len);
+    len = rule3(s, len);
+    len = rule4(s, len);
+    len = rule5(s, len);
+    len = rule6(s, len);
+    len = rule7(s, len);
+    len = rule8(s, len);
+    len = rule9(s, len);
+    len = rule10(s, len);
+    len = rule11(s, len);
+    len = rule12(s, len);
+    len = rule13(s, len);
+    len = rule14(s, len);
+    len = rule15(s, len);
+    len = rule16(s, len);
+    len = rule17(s, len);
+    len = rule18(s, len);
+    len = rule19(s, len);
+    len = rule20(s, len);
+    // "long list"
+    if (len == origLen)
+      len = rule21(s, len);
+    
+    return rule22(s, len);
+  }
+
+  private int rule0(char s[], int len) {
+    if (len > 9 && (endsWith(s, len, "καθε????ο?")
+        || endsWith(s, len, "καθε?????ν")))
+      return len - 4;
+    
+    if (len > 8 && (endsWith(s, len, "γεγονο?ο?")
+        || endsWith(s, len, "γεγονο??ν")))
+      return len - 4;
+    
+    if (len > 8 && endsWith(s, len, "καθε????α"))
+      return len - 3;
+    
+    if (len > 7 && (endsWith(s, len, "?α?ογιο?")
+        || endsWith(s, len, "?α?ογι?ν")))
+      return len - 4;
+    
+    if (len > 7 && endsWith(s, len, "γεγονο?α"))
+      return len - 3;
+    
+    if (len > 7 && endsWith(s, len, "καθε????"))
+      return len - 2;
+    
+    if (len > 6 && (endsWith(s, len, "?καγιο?"))
+        || endsWith(s, len, "?καγι?ν")
+        || endsWith(s, len, "ολογιο?")
+        || endsWith(s, len, "ολογι?ν")
+        || endsWith(s, len, "κ?εα?ο?")
+        || endsWith(s, len, "κ?εα??ν")
+        || endsWith(s, len, "?ε?α?ο?")
+        || endsWith(s, len, "?ε?α??ν")
+        || endsWith(s, len, "?ε?α?ο?")
+        || endsWith(s, len, "?ε?α??ν"))
+      return len - 4;
+    
+    if (len > 6 && endsWith(s, len, "?α?ογια"))
+      return len - 3;
+    
+    if (len > 6 && endsWith(s, len, "γεγονο?"))
+      return len - 2;
+    
+    if (len > 5 && (endsWith(s, len, "?αγιο?")
+        || endsWith(s, len, "?αγι?ν")
+        || endsWith(s, len, "?ογιο?")
+        || endsWith(s, len, "?ογι?ν")))
+      return len - 4;
+    
+    if (len > 5 && (endsWith(s, len, "?καγια")
+        || endsWith(s, len, "ολογια")
+        || endsWith(s, len, "κ?εα?α")
+        || endsWith(s, len, "?ε?α?α")
+        || endsWith(s, len, "?ε?α?α")))
+      return len - 3;
+    
+    if (len > 4 && (endsWith(s, len, "?αγια")
+        || endsWith(s, len, "?ογια")
+        || endsWith(s, len, "???ο?")
+        || endsWith(s, len, "????ν")))
+      return len - 3;
+    
+    if (len > 4 && (endsWith(s, len, "κ?εα?")
+        || endsWith(s, len, "?ε?α?")
+        || endsWith(s, len, "?ε?α?")))
+      return len - 2;
+    
+    if (len > 3 && endsWith(s, len, "???α"))
+      return len - 2;
+    
+    if (len > 2 && endsWith(s, len, "???"))
+      return len - 1;
+    
+    return len;
+  }
+
+  private int rule1(char s[], int len) {
+    if (len > 4 && (endsWith(s, len, "αδε?") || endsWith(s, len, "αδ?ν"))) {
+      len -= 4;
+      if (!(endsWith(s, len, "οκ") ||
+          endsWith(s, len, "μαμ") ||
+          endsWith(s, len, "μαν") ||
+          endsWith(s, len, "μ?αμ?") ||
+          endsWith(s, len, "?α?ε?") ||
+          endsWith(s, len, "γιαγι") ||
+          endsWith(s, len, "ν?αν?") ||
+          endsWith(s, len, "κ??") ||
+          endsWith(s, len, "θει") ||
+          endsWith(s, len, "?εθε?")))
+        len += 2; // add back -αδ
+    }
+    return len;
+  }
+  
+  private int rule2(char s[], int len) {
+    if (len > 4 && (endsWith(s, len, "εδε?") || endsWith(s, len, "εδ?ν"))) {
+      len -= 4;
+      if (endsWith(s, len, "ο?") ||
+          endsWith(s, len, "ι?") ||
+          endsWith(s, len, "εμ?") ||
+          endsWith(s, len, "??") ||
+          endsWith(s, len, "γη?") ||
+          endsWith(s, len, "δα?") ||
+          endsWith(s, len, "κ?α??") ||
+          endsWith(s, len, "μιλ"))
+        len += 2; // add back -εδ
+    }
+    return len;
+  }
+  
+  private int rule3(char s[], int len) {
+    if (len > 5 && (endsWith(s, len, "ο?δε?") || endsWith(s, len, "ο?δ?ν"))) {
+      len -= 5;
+      if (endsWith(s, len, "α?κ") ||
+          endsWith(s, len, "καλιακ") ||
+          endsWith(s, len, "?ε?αλ") ||
+          endsWith(s, len, "λι?") ||
+          endsWith(s, len, "?λεξ") ||
+          endsWith(s, len, "?κ") ||
+          endsWith(s, len, "?") ||
+          endsWith(s, len, "?λ") ||
+          endsWith(s, len, "??") ||
+          endsWith(s, len, "βελ") ||
+          endsWith(s, len, "λο?λ") ||
+          endsWith(s, len, "?ν") ||
+          endsWith(s, len, "??") ||
+          endsWith(s, len, "??αγ") ||
+          endsWith(s, len, "?ε"))
+        len += 3; // add back -ο?δ
+    }
+    return len;
+  }
+  
+  private static final CharArraySet exc4 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("θ", "δ", "ελ", "γαλ", "ν", "?", "ιδ", "?α?"),
+      false);
+  
+  private int rule4(char s[], int len) {   
+    if (len > 3 && (endsWith(s, len, "ε??") || endsWith(s, len, "ε?ν"))) {
+      len -= 3;
+      if (exc4.contains(s, 0, len))
+        len++; // add back -ε
+    }
+    return len;
+  }
+  
+  private int rule5(char s[], int len) {
+    if (len > 2 && endsWith(s, len, "ια")) {
+      len -= 2;
+      if (endsWithVowel(s, len))
+        len++; // add back -ι
+    } else if (len > 3 && (endsWith(s, len, "ιο?") || endsWith(s, len, "ι?ν"))) {
+      len -= 3;
+      if (endsWithVowel(s, len))
+        len++; // add back -ι
+    }
+    return len;
+  }
+
+  private static final CharArraySet exc6 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("αλ", "αδ", "ενδ", "αμαν", "αμμο?αλ", "ηθ", "ανηθ",
+          "αν?ιδ", "???", "β??μ", "γε?", "εξ?δ", "καλ?", "καλλιν", "κα?αδ",
+          "μο?λ", "μ?αν", "μ?αγια?", "μ?ολ", "μ?ο?", "νι?", "ξικ", "??νομηλ",
+          "?ε??", "?ι??", "?ικαν?", "?λια??", "?ο??ελν", "????οδ", "?ε??",
+          "??ναδ", "??αμ", "??οδ", "?ιλον", "??λοδ", "?α?"), 
+       false);
+
+  private int rule6(char s[], int len) {
+    boolean removed = false;
+    if (len > 3 && (endsWith(s, len, "ικα") || endsWith(s, len, "ικο"))) {
+      len -= 3;
+      removed = true;
+    } else if (len > 4 && (endsWith(s, len, "ικο?") || endsWith(s, len, "ικ?ν"))) {
+      len -= 4;
+      removed = true;
+    }
+    
+    if (removed) {
+      if (endsWithVowel(s, len) || exc6.contains(s, 0, len))
+        len += 2; // add back -ικ
+    }
+    return len;
+  }
+  
+  private static final CharArraySet exc7 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("ανα?", "α?οθ", "α?οκ", "α?ο??", "βο?β", "ξεθ", "ο?λ",
+          "?εθ", "?ικ?", "?ο?", "?ι?", "?"), 
+      false);
+  
+  private int rule7(char s[], int len) {
+    if (len == 5 && endsWith(s, len, "αγαμε"))
+      return len - 1;
+    
+    if (len > 7 && endsWith(s, len, "ηθηκαμε"))
+      len -= 7;
+    else if (len > 6 && endsWith(s, len, "ο??αμε"))
+      len -= 6;
+    else if (len > 5 && (endsWith(s, len, "αγαμε") ||
+             endsWith(s, len, "η?αμε") ||
+             endsWith(s, len, "ηκαμε")))
+      len -= 5;
+    
+    if (len > 3 && endsWith(s, len, "αμε")) {
+      len -= 3;
+      if (exc7.contains(s, 0, len))
+        len += 2; // add back -αμ
+    }
+
+    return len;
+  }
+
+  private static final CharArraySet exc8a = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("??", "??"),
+      false);
+
+  private static final CharArraySet exc8b = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("βε?ε?", "βο?λκ", "β?α?μ", "γ", "δ?αδο?μ", "θ", "καλ?ο?ζ",
+          "κα??ελ", "κο?μο?", "λαο?λ", "μ?αμεθ", "μ", "μο??ο?λμ", "ν", "ο?λ",
+          "?", "?ελεκ", "?λ", "?ολι?", "?ο??ολ", "?α?ακα??", "?ο?λ?",
+          "??α?λα?", "ο??", "??ιγγ", "??ο?", "???ο??ε?", "?", "???ο?λ", "αγ",
+          "ο??", "γαλ", "γε?", "δεκ", "δι?λ", "αμε?ικαν", "ο??", "?ιθ",
+          "?ο??ι?", "?", "ζ?ν?", "ικ", "κα??", "κο?", "λι?", "λο?θη?", "μαιν?",
+          "μελ", "?ιγ", "??", "??εγ", "??αγ", "??αγ", "?", "ε?", "αδα?",
+          "αθιγγ", "αμη?", "ανικ", "ανο?γ", "α?ηγ", "α?ιθ", "α??ιγγ", "βα?",
+          "βα?κ", "βαθ?γαλ", "βιομη?", "β?α??κ", "δια?", "δια?", "ενο?γ",
+          "θ??", "κα?νοβιομη?", "κα?αγαλ", "κλιβ", "κοιλα??", "λιβ",
+          "μεγλοβιομη?", "μικ?οβιομη?", "ν?αβ", "ξη?οκλιβ", "ολιγοδαμ",
+          "ολογαλ", "?εν?α??", "?ε?η?", "?ε?ι??", "?λα?", "?ολ?δα?", "?ολ?μη?",
+          "??ε?", "?αβ", "?ε?", "??ε?η?", "??οκο?", "?αμηλοδα?", "?ηλο?αβ"),
+      false);
+  
+  private int rule8(char s[], int len) {
+    boolean removed = false;
+    
+    if (len > 8 && endsWith(s, len, "ιο?ν?ανε")) {
+      len -= 8;
+      removed = true;
+    } else if (len > 7 && endsWith(s, len, "ιον?ανε") ||
+        endsWith(s, len, "ο?ν?ανε") ||
+        endsWith(s, len, "ηθηκανε")) {
+      len -= 7;
+      removed = true;
+    } else if (len > 6 && endsWith(s, len, "ιο?ανε") ||
+        endsWith(s, len, "ον?ανε") ||
+        endsWith(s, len, "ο??ανε")) {
+      len -= 6;
+      removed = true;
+    } else if (len > 5 && endsWith(s, len, "αγανε") ||
+        endsWith(s, len, "η?ανε") ||
+        endsWith(s, len, "ο?ανε") ||
+        endsWith(s, len, "ηκανε")) {
+      len -= 5;
+      removed = true;
+    }
+    
+    if (removed && exc8a.contains(s, 0, len)) {
+      // add -αγαν (we removed > 4 chars so its safe)
+      len += 4;
+      s[len - 4] = 'α';
+      s[len - 3] = 'γ';
+      s[len - 2] = 'α';
+      s[len - 1] = 'ν';
+    }
+    
+    if (len > 3 && endsWith(s, len, "ανε")) {
+      len -= 3;
+      if (endsWithVowelNoY(s, len) || exc8b.contains(s, 0, len)) {
+        len += 2; // add back -αν
+      }
+    }
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc9 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("αβα?", "βεν", "ενα?", "αβ?", "αδ", "αθ", "αν", "α?λ",
+          "βα?ον", "ν??", "?κ", "κο?", "μ?ο?", "νι?", "?αγ", "?α?ακαλ", "?ε??",
+          "?κελ", "????", "?οκ", "?", "δ", "εμ", "θα??", "θ"), 
+      false);
+  
+  private int rule9(char s[], int len) {
+    if (len > 5 && endsWith(s, len, "η?ε?ε"))
+      len -= 5;
+    
+    if (len > 3 && endsWith(s, len, "ε?ε")) {
+      len -= 3;
+      if (exc9.contains(s, 0, len) ||
+          endsWithVowelNoY(s, len) ||
+          endsWith(s, len, "οδ") ||
+          endsWith(s, len, "αι?") ||
+          endsWith(s, len, "?ο?") ||
+          endsWith(s, len, "?αθ") ||
+          endsWith(s, len, "διαθ") ||
+          endsWith(s, len, "??") ||
+          endsWith(s, len, "ενδ") ||
+          endsWith(s, len, "ε??") ||
+          endsWith(s, len, "?ιθ") ||
+          endsWith(s, len, "??ε?θ") ||
+          endsWith(s, len, "?αθ") ||
+          endsWith(s, len, "ενθ") ||
+          endsWith(s, len, "?οθ") ||
+          endsWith(s, len, "?θ") ||
+          endsWith(s, len, "???") ||
+          endsWith(s, len, "αιν") ||
+          endsWith(s, len, "??νδ") ||
+          endsWith(s, len, "??ν") ||
+          endsWith(s, len, "??νθ") ||
+          endsWith(s, len, "???") ||
+          endsWith(s, len, "?ον") ||
+          endsWith(s, len, "β?") ||
+          endsWith(s, len, "καθ") ||
+          endsWith(s, len, "ε?θ") ||
+          endsWith(s, len, "εκθ") ||
+          endsWith(s, len, "νε?") ||
+          endsWith(s, len, "?ον") ||
+          endsWith(s, len, "α?κ") ||
+          endsWith(s, len, "βα?") ||
+          endsWith(s, len, "βολ") ||
+          endsWith(s, len, "??ελ")) {
+        len += 2; // add back -ε?
+      }
+    }
+    
+    return len;
+  }
+
+  private int rule10(char s[], int len) {
+    if (len > 5 && (endsWith(s, len, "ον?α?") || endsWith(s, len, "?ν?α?"))) {
+      len -= 5;
+      if (len == 3 && endsWith(s, len, "α??")) {
+        len += 3; // add back *ν?
+        s[len - 3] = 'ο';
+      }
+      if (endsWith(s, len, "κ?ε")) {
+        len += 3; // add back *ν?
+        s[len - 3] = '?';
+      }
+    }
+    
+    return len;
+  }
+  
+  private int rule11(char s[], int len) {
+    if (len > 6 && endsWith(s, len, "ομα??ε")) {
+      len -= 6;
+      if (len == 2 && endsWith(s, len, "ον")) {
+        len += 5; // add back -ομα??
+      }
+    } else if (len > 7 && endsWith(s, len, "ιομα??ε")) {
+      len -= 7;
+      if (len == 2 && endsWith(s, len, "ον")) {
+        len += 5;
+        s[len - 5] = 'ο';
+        s[len - 4] = 'μ';
+        s[len - 3] = 'α';
+        s[len - 2] = '?';
+        s[len - 1] = '?';
+      }
+    }
+    return len;
+  }
+
+  private static final CharArraySet exc12a = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("?", "α?", "??μ?", "α??μ?", "ακα?α?", "αμε?αμ?"),
+      false);
+
+  private static final CharArraySet exc12b = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("αλ", "α?", "εκ?ελ", "ζ", "μ", "ξ", "?α?ακαλ", "α?", "??ο", "νι?"),
+      false);
+  
+  private int rule12(char s[], int len) {
+    if (len > 5 && endsWith(s, len, "ιε??ε")) {
+      len -= 5;
+      if (exc12a.contains(s, 0, len))   
+        len += 4; // add back -ιε??
+    }
+    
+    if (len > 4 && endsWith(s, len, "ε??ε")) {
+      len -= 4;
+      if (exc12b.contains(s, 0, len))
+        len += 3; // add back -ε??
+    }
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc13 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("διαθ", "θ", "?α?ακα?αθ", "??ο?θ", "??νθ"),
+      false);
+  
+  private int rule13(char s[], int len) {
+    if (len > 6 && endsWith(s, len, "ηθηκε?")) {
+      len -= 6;
+    } else if (len > 5 && (endsWith(s, len, "ηθηκα") || endsWith(s, len, "ηθηκε"))) {
+      len -= 5;
+    }
+    
+    boolean removed = false;
+    
+    if (len > 4 && endsWith(s, len, "ηκε?")) {
+      len -= 4;
+      removed = true;
+    } else if (len > 3 && (endsWith(s, len, "ηκα") || endsWith(s, len, "ηκε"))) {
+      len -= 3;
+      removed = true;
+    }
+
+    if (removed && (exc13.contains(s, 0, len) 
+        || endsWith(s, len, "?κ?λ")
+        || endsWith(s, len, "?κο?λ")
+        || endsWith(s, len, "να?θ")
+        || endsWith(s, len, "??")
+        || endsWith(s, len, "οθ")
+        || endsWith(s, len, "?ιθ"))) { 
+      len += 2; // add back the -ηκ
+    }
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc14 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("?α?μακ", "?αδ", "αγκ", "ανα??", "β?ομ", "εκλι?", "λαμ?ιδ",
+          "λε?", "μ", "?α?", "?", "λ", "μεδ", "με?αζ", "??ο?ειν", "αμ", "αιθ",
+          "ανηκ", "δε??οζ", "ενδια?ε?", "δε", "δε??ε?ε?", "καθα?ε?", "?λε",
+          "??α"), 
+      false);
+
+  private int rule14(char s[], int len) {
+    boolean removed = false;
+    
+    if (len > 5 && endsWith(s, len, "ο??ε?")) {
+      len -= 5;
+      removed = true;
+    } else if (len > 4 && (endsWith(s, len, "ο??α") || endsWith(s, len, "ο??ε"))) {
+      len -= 4;
+      removed = true;
+    }
+    
+    if (removed && (exc14.contains(s, 0, len) 
+        || endsWithVowel(s, len)
+        || endsWith(s, len, "?οδα?")
+        || endsWith(s, len, "βλε?")
+        || endsWith(s, len, "?αν?α?")
+        || endsWith(s, len, "???δ") 
+        || endsWith(s, len, "μαν?ιλ")
+        || endsWith(s, len, "μαλλ")
+        || endsWith(s, len, "κ?μα?")
+        || endsWith(s, len, "λα?")
+        || endsWith(s, len, "ληγ")
+        || endsWith(s, len, "?αγ")
+        || endsWith(s, len, "ομ")
+        || endsWith(s, len, "????"))) {
+      len += 3; // add back -ο??
+    }
+
+   return len;
+  }
+  
+  private static final CharArraySet exc15a = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("αβα??", "?ολ??", "αδη?", "?αμ?", "?", "α??", "α?", "αμαλ",
+          "αμαλλι", "αν???", "α?ε?", "α??α?", "α?α?", "δε?βεν", "δ?ο?ο?",
+          "ξε?", "νεο?", "νομο?", "ολο?", "ομο?", "??ο??", "??ο???ο?", "??μ?",
+          "??ν?", "?", "??ο?", "?α?", "αει?", "αιμο??", "αν??", "α?ο?",
+          "α??ι?", "δια?", "εν", "ε?ι?", "κ?οκαλο?", "?ιδη?ο?", "λ", "να?",
+          "ο?λαμ", "ο??", "?", "??", "μ"), 
+      false);
+  
+  private static final CharArraySet exc15b = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("?ο?", "να?λο?"),
+      false);
+  
+  private int rule15(char s[], int len) {
+    boolean removed = false;
+    if (len > 4 && endsWith(s, len, "αγε?")) {
+      len -= 4;
+      removed = true;
+    } else if (len > 3 && (endsWith(s, len, "αγα") || endsWith(s, len, "αγε"))) {
+      len -= 3;
+      removed = true;
+    }
+    
+    if (removed) {
+      final boolean cond1 = exc15a.contains(s, 0, len) 
+        || endsWith(s, len, "ο?")
+        || endsWith(s, len, "?ελ")
+        || endsWith(s, len, "?ο??")
+        || endsWith(s, len, "λλ")
+        || endsWith(s, len, "??")
+        || endsWith(s, len, "??")
+        || endsWith(s, len, "??")
+        || endsWith(s, len, "??")
+        || endsWith(s, len, "λο?")
+        || endsWith(s, len, "?μην");
+      
+      final boolean cond2 = exc15b.contains(s, 0, len)
+        || endsWith(s, len, "κολλ");
+      
+      if (cond1 && !cond2)
+        len += 2; // add back -αγ  
+    }
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc16 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("ν", "?ε??ον", "δ?δεκαν", "ε?ημον", "μεγαλον", "ε??αν"),
+      false);
+  
+  private int rule16(char s[], int len) {
+    boolean removed = false;
+    if (len > 4 && endsWith(s, len, "η?ο?")) {
+      len -= 4;
+      removed = true;
+    } else if (len > 3 && (endsWith(s, len, "η?ε") || endsWith(s, len, "η?α"))) {
+      len -= 3;
+      removed = true;
+    }
+    
+    if (removed && exc16.contains(s, 0, len))
+      len += 2; // add back -η?
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc17 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("α?β", "?β", "α??", "??", "α?λ", "αειμν", "δ????", "ε???", "κοινο??", "?αλιμ?"),
+      false);
+  
+  private int rule17(char s[], int len) {
+    if (len > 4 && endsWith(s, len, "η??ε")) {
+      len -= 4;
+      if (exc17.contains(s, 0, len))
+        len += 3; // add back the -η??
+    }
+    
+    return len;
+  }
+  
+  private static final CharArraySet exc18 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("ν", "?", "??ι", "???αβομο???", "κακομο???", "εξ?ν"),
+      false);
+  
+  private int rule18(char s[], int len) {
+    boolean removed = false;
+    
+    if (len > 6 && (endsWith(s, len, "η?ο?νε") || endsWith(s, len, "ηθο?νε"))) {
+      len -= 6;
+      removed = true;
+    } else if (len > 4 && endsWith(s, len, "ο?νε")) {
+      len -= 4;
+      removed = true;
+    }
+    
+    if (removed && exc18.contains(s, 0, len)) {
+      len += 3;
+      s[len - 3] = 'ο';
+      s[len - 2] = '?';
+      s[len - 1] = 'ν';
+    }
+    return len;
+  }
+  
+  private static final CharArraySet exc19 = new CharArraySet(Version.LUCENE_31,
+      Arrays.asList("?α?α?ο??", "?", "?", "??ιο?λ", "αζ", "αλλο?ο??", "α?ο??"),
+      false);
+  
+  private int rule19(char s[], int len) {
+    boolean removed = false;
+    
+    if (len > 6 && (endsWith(s, len, "η?ο?με") || endsWith(s, len, "ηθο?με"))) {
+      len -= 6;
+      removed = true;
+    } else if (len > 4 && endsWith(s, len, "ο?με")) {
+      len -= 4;
+      removed = true;
+    }
+    
+    if (removed && exc19.contains(s, 0, len)) {
+      len += 3;
+      s[len - 3] = 'ο';
+      s[len - 2] = '?';
+      s[len - 1] = 'μ';
+    }
+    return len;
+  }
+  
+  private int rule20(char s[], int len) {
+    if (len > 5 && (endsWith(s, len, "μα??ν") || endsWith(s, len, "μα?ο?")))
+      len -= 3;
+    else if (len > 4 && endsWith(s, len, "μα?α"))
+      len -= 2;
+    return len;
+  }
+
+  private int rule21(char s[], int len) {
+    if (len > 9 && endsWith(s, len, "ιον?ο??αν"))
+      return len - 9;
+    
+    if (len > 8 && (endsWith(s, len, "ιομα??αν") ||
+        endsWith(s, len, "ιο?α??αν") ||
+        endsWith(s, len, "ιο?μα??ε") ||
+        endsWith(s, len, "ον?ο??αν")))
+      return len - 8;
+    
+    if (len > 7 && (endsWith(s, len, "ιεμα??ε") ||
+        endsWith(s, len, "ιε?α??ε") ||
+        endsWith(s, len, "ιομο?να") ||
+        endsWith(s, len, "ιο?α??ε") ||
+        endsWith(s, len, "ιο?ο?να") ||
+        endsWith(s, len, "ιο?ν?αι") ||
+        endsWith(s, len, "ιο?ν?αν") ||
+        endsWith(s, len, "ηθηκα?ε") ||
+        endsWith(s, len, "ομα??αν") ||
+        endsWith(s, len, "ο?α??αν") ||
+        endsWith(s, len, "ο?μα??ε")))
+      return len - 7;
+    
+    if (len > 6 && (endsWith(s, len, "ιομο?ν") ||
+        endsWith(s, len, "ιον?αν") ||
+        endsWith(s, len, "ιο?ο?ν") ||
+        endsWith(s, len, "ηθει?ε") ||
+        endsWith(s, len, "ηθηκαν") ||
+        endsWith(s, len, "ομο?να") ||
+        endsWith(s, len, "ο?α??ε") ||
+        endsWith(s, len, "ο?ο?να") ||
+        endsWith(s, len, "ο?ν?αι") ||
+        endsWith(s, len, "ο?ν?αν") ||
+        endsWith(s, len, "ο??α?ε")))
+      return len - 6;
+    
+    if (len > 5 && (endsWith(s, len, "αγα?ε") ||
+        endsWith(s, len, "ιεμαι") ||
+        endsWith(s, len, "ιε?αι") ||
+        endsWith(s, len, "ιε?αι") ||
+        endsWith(s, len, "ιο?αν") ||
+        endsWith(s, len, "ιο?μα") ||
+        endsWith(s, len, "ηθει?") ||
+        endsWith(s, len, "ηθο?ν") ||
+        endsWith(s, len, "ηκα?ε") ||
+        endsWith(s, len, "η?α?ε") ||
+        endsWith(s, len, "η?ο?ν") ||
+        endsWith(s, len, "ομο?ν") ||
+        endsWith(s, len, "ον?αι") ||
+        endsWith(s, len, "ον?αν") ||
+        endsWith(s, len, "ο?ο?ν") ||
+        endsWith(s, len, "ο?μαι") ||
+        endsWith(s, len, "ο??αν")))
+      return len - 5;
+    
+    if (len > 4 && (endsWith(s, len, "αγαν") ||
+        endsWith(s, len, "αμαι") ||
+        endsWith(s, len, "α?αι") ||
+        endsWith(s, len, "α?αι") ||
+        endsWith(s, len, "ει?ε") ||
+        endsWith(s, len, "ε?αι") ||
+        endsWith(s, len, "ε?αι") ||
+        endsWith(s, len, "ηδε?") ||
+        endsWith(s, len, "ηδ?ν") ||
+        endsWith(s, len, "ηθει") ||
+        endsWith(s, len, "ηκαν") ||
+        endsWith(s, len, "η?αν") ||
+        endsWith(s, len, "η?ει") ||
+        endsWith(s, len, "η?ε?") ||
+        endsWith(s, len, "ομαι") ||
+        endsWith(s, len, "ο?αν")))
+      return len - 4;
+    
+    if (len > 3 && (endsWith(s, len, "αει") ||
+        endsWith(s, len, "ει?") ||
+        endsWith(s, len, "ηθ?") ||
+        endsWith(s, len, "η??") ||
+        endsWith(s, len, "ο?ν") ||
+        endsWith(s, len, "ο??")))
+      return len - 3;
+    
+    if (len > 2 && (endsWith(s, len, "αν") ||
+        endsWith(s, len, "α?") ||
+        endsWith(s, len, "α?") ||
+        endsWith(s, len, "ει") ||
+        endsWith(s, len, "ε?") ||
+        endsWith(s, len, "η?") ||
+        endsWith(s, len, "οι") ||
+        endsWith(s, len, "ο?") ||
+        endsWith(s, len, "ο?") ||
+        endsWith(s, len, "??") ||
+        endsWith(s, len, "?ν")))
+      return len - 2;
+    
+    if (len > 1 && endsWithVowel(s, len))
+      return len - 1;
+
+    return len;
+  }
+  
+  private int rule22(char s[], int len) {
+    if (endsWith(s, len, "ε??ε?") ||
+        endsWith(s, len, "ε??α?"))
+      return len - 5;
+    
+    if (endsWith(s, len, "ο?ε?") ||
+        endsWith(s, len, "ο?α?") ||
+        endsWith(s, len, "??ε?") ||
+        endsWith(s, len, "??α?") ||
+        endsWith(s, len, "??ε?") ||
+        endsWith(s, len, "??α?"))
+      return len - 4;
+
+    return len;
+  }
+
+  private boolean endsWith(char s[], int len, String suffix) {
+    final int suffixLen = suffix.length();
+    if (suffixLen > len)
+      return false;
+    for (int i = suffixLen - 1; i >= 0; i--)
+      if (s[len -(suffixLen - i)] != suffix.charAt(i))
+        return false;
+    
+    return true;
+  }
+  
+  private boolean endsWithVowel(char s[], int len) {
+    if (len == 0)
+      return false;
+    switch(s[len - 1]) {
+      case 'α':
+      case 'ε':
+      case 'η':
+      case 'ι':
+      case 'ο':
+      case '?':
+      case '?':
+        return true;
+      default:
+        return false;
+    }
+  }
+  
+  private boolean endsWithVowelNoY(char s[], int len) {
+    if (len == 0)
+      return false;
+    switch(s[len - 1]) {
+      case 'α':
+      case 'ε':
+      case 'η':
+      case 'ι':
+      case 'ο':
+      case '?':
+        return true;
+      default:
+        return false;
+    }
+  }
+}
diff --git a/modules/analysis/common/src/resources/org/apache/lucene/analysis/el/stopwords.txt b/modules/analysis/common/src/resources/org/apache/lucene/analysis/el/stopwords.txt
new file mode 100644
index 0000000..1a08d31
--- /dev/null
+++ b/modules/analysis/common/src/resources/org/apache/lucene/analysis/el/stopwords.txt
@@ -0,0 +1,76 @@
+# Lucene Greek Stopwords list
+ο
+η
+?ο
+οι
+?α
+?ο?
+?η?
+??ν
+?ον
+?ην
+και 
+κι
+κ
+ειμαι
+ει?αι
+ειναι
+ειμα??ε
+ει??ε
+??ο
+??ον
+??η
+??ην
+μα
+αλλα
+α?ο
+για
+??ο?
+με
+?ε
+??
+?α?α
+αν?ι
+κα?α
+με?α
+θα
+να
+δε
+δεν
+μη
+μην
+ε?ι
+εν?
+εαν
+αν
+?ο?ε
+?ο?
+???
+?οιο?
+?οια
+?οιο
+?οιοι
+?οιε?
+?οι?ν
+?οιο??
+α??ο?
+α??η
+α??ο
+α??οι
+α???ν
+α??ο??
+α??ε?
+α??α
+εκεινο?
+εκεινη
+εκεινο
+εκεινοι
+εκεινε?
+εκεινα
+εκειν?ν
+εκεινο??
+ο???
+ομ??
+ι???
+ο?ο
+ο?ι
diff --git a/modules/analysis/common/src/test/org/apache/lucene/analysis/el/GreekAnalyzerTest.java b/modules/analysis/common/src/test/org/apache/lucene/analysis/el/GreekAnalyzerTest.java
index 6f87c1f..69dbf01 100644
--- a/modules/analysis/common/src/test/org/apache/lucene/analysis/el/GreekAnalyzerTest.java
+++ b/modules/analysis/common/src/test/org/apache/lucene/analysis/el/GreekAnalyzerTest.java
@@ -26,42 +26,67 @@ import org.apache.lucene.util.Version;
  */
 public class GreekAnalyzerTest extends BaseTokenStreamTestCase {
 
+  /**
+   * Test the analysis of various greek strings.
+   *
+   * @throws Exception in case an error occurs
+   */
+  public void testAnalyzer() throws Exception {
+    Analyzer a = new GreekAnalyzer(TEST_VERSION_CURRENT);
+    // Verify the correct analysis of capitals and small accented letters, and
+    // stemming
+    assertAnalyzesTo(a, "?ία εξαι?ε?ικά καλή και ?λο??ια ?ει?ά ?α?ακ?ή??ν ?η? ?λληνική? γλ???α?",
+        new String[] { "μια", "εξαι?ε?", "καλ", "?λο??", "?ει?", "?α?ακ?η?",
+        "ελληνικ", "γλ???" });
+    // Verify the correct analysis of small letters with diaeresis and the elimination
+    // of punctuation marks
+    assertAnalyzesTo(a, "??ο??ν?α (και)     [?ολλα?λέ?] - ??????Σ",
+        new String[] { "??οιον?", "?ολλα?λ", "αναγκ" });
+    // Verify the correct analysis of capital accented letters and capital letters with diaeresis,
+    // as well as the elimination of stop words
+    assertAnalyzesTo(a, "?Ρ?Ϋ????Σ??Σ  ??ογο?, ο με???? και οι άλλοι",
+        new String[] { "??ο??οθε?", "α?ογ", "με??", "αλλ" });
+  }
+  
 	/**
 	 * Test the analysis of various greek strings.
 	 *
 	 * @throws Exception in case an error occurs
+	 * @deprecated Remove this test when support for 3.0 is no longer needed
 	 */
-	public void testAnalyzer() throws Exception {
-		Analyzer a = new GreekAnalyzer(TEST_VERSION_CURRENT);
+  @Deprecated
+	public void testAnalyzerBWCompat() throws Exception {
+		Analyzer a = new GreekAnalyzer(Version.LUCENE_30);
 		// Verify the correct analysis of capitals and small accented letters
-		assertAnalyzesTo(a, "\u039c\u03af\u03b1 \u03b5\u03be\u03b1\u03b9\u03c1\u03b5\u03c4\u03b9\u03ba\u03ac \u03ba\u03b1\u03bb\u03ae \u03ba\u03b1\u03b9 \u03c0\u03bb\u03bf\u03cd\u03c3\u03b9\u03b1 \u03c3\u03b5\u03b9\u03c1\u03ac \u03c7\u03b1\u03c1\u03b1\u03ba\u03c4\u03ae\u03c1\u03c9\u03bd \u03c4\u03b7\u03c2 \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae\u03c2 \u03b3\u03bb\u03ce\u03c3\u03c3\u03b1\u03c2",
-				new String[] { "\u03bc\u03b9\u03b1", "\u03b5\u03be\u03b1\u03b9\u03c1\u03b5\u03c4\u03b9\u03ba\u03b1", "\u03ba\u03b1\u03bb\u03b7", "\u03c0\u03bb\u03bf\u03c5\u03c3\u03b9\u03b1", "\u03c3\u03b5\u03b9\u03c1\u03b1", "\u03c7\u03b1\u03c1\u03b1\u03ba\u03c4\u03b7\u03c1\u03c9\u03bd",
-				"\u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03b7\u03c3", "\u03b3\u03bb\u03c9\u03c3\u03c3\u03b1\u03c3" });
+		assertAnalyzesTo(a, "?ία εξαι?ε?ικά καλή και ?λο??ια ?ει?ά ?α?ακ?ή??ν ?η? ?λληνική? γλ???α?",
+				new String[] { "μια", "εξαι?ε?ικα", "καλη", "?λο??ια", "?ει?α", "?α?ακ?η??ν",
+				"ελληνικη?", "γλ???α?" });
 		// Verify the correct analysis of small letters with diaeresis and the elimination
 		// of punctuation marks
-		assertAnalyzesTo(a, "\u03a0\u03c1\u03bf\u03ca\u03cc\u03bd\u03c4\u03b1 (\u03ba\u03b1\u03b9)     [\u03c0\u03bf\u03bb\u03bb\u03b1\u03c0\u03bb\u03ad\u03c2]	-	\u0391\u039d\u0391\u0393\u039a\u0395\u03a3",
-				new String[] { "\u03c0\u03c1\u03bf\u03b9\u03bf\u03bd\u03c4\u03b1", "\u03c0\u03bf\u03bb\u03bb\u03b1\u03c0\u03bb\u03b5\u03c3", "\u03b1\u03bd\u03b1\u03b3\u03ba\u03b5\u03c3" });
-		// Verify the correct analysis of capital accented letters and capitalletters with diaeresis,
+		assertAnalyzesTo(a, "??ο??ν?α (και)     [?ολλα?λέ?] - ??????Σ",
+				new String[] { "??οιον?α", "?ολλα?λε?", "αναγκε?" });
+		// Verify the correct analysis of capital accented letters and capital letters with diaeresis,
 		// as well as the elimination of stop words
-		assertAnalyzesTo(a, "\u03a0\u03a1\u039f\u03ab\u03a0\u039f\u0398\u0395\u03a3\u0395\u0399\u03a3  \u0386\u03c8\u03bf\u03b3\u03bf\u03c2, \u03bf \u03bc\u03b5\u03c3\u03c4\u03cc\u03c2 \u03ba\u03b1\u03b9 \u03bf\u03b9 \u03ac\u03bb\u03bb\u03bf\u03b9",
-				new String[] { "\u03c0\u03c1\u03bf\u03c5\u03c0\u03bf\u03b8\u03b5\u03c3\u03b5\u03b9\u03c3", "\u03b1\u03c8\u03bf\u03b3\u03bf\u03c3", "\u03bc\u03b5\u03c3\u03c4\u03bf\u03c3", "\u03b1\u03bb\u03bb\u03bf\u03b9" });
+		assertAnalyzesTo(a, "?Ρ?Ϋ????Σ??Σ  ??ογο?, ο με???? και οι άλλοι",
+				new String[] { "??ο??οθε?ει?", "α?ογο?", "με??ο?", "αλλοι" });
 	}
 	
-	public void testReusableTokenStream() throws Exception {
-	    Analyzer a = new GreekAnalyzer(TEST_VERSION_CURRENT);
-	    // Verify the correct analysis of capitals and small accented letters
-	    assertAnalyzesToReuse(a, "\u039c\u03af\u03b1 \u03b5\u03be\u03b1\u03b9\u03c1\u03b5\u03c4\u03b9\u03ba\u03ac \u03ba\u03b1\u03bb\u03ae \u03ba\u03b1\u03b9 \u03c0\u03bb\u03bf\u03cd\u03c3\u03b9\u03b1 \u03c3\u03b5\u03b9\u03c1\u03ac \u03c7\u03b1\u03c1\u03b1\u03ba\u03c4\u03ae\u03c1\u03c9\u03bd \u03c4\u03b7\u03c2 \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ae\u03c2 \u03b3\u03bb\u03ce\u03c3\u03c3\u03b1\u03c2",
-	            new String[] { "\u03bc\u03b9\u03b1", "\u03b5\u03be\u03b1\u03b9\u03c1\u03b5\u03c4\u03b9\u03ba\u03b1", "\u03ba\u03b1\u03bb\u03b7", "\u03c0\u03bb\u03bf\u03c5\u03c3\u03b9\u03b1", "\u03c3\u03b5\u03b9\u03c1\u03b1", "\u03c7\u03b1\u03c1\u03b1\u03ba\u03c4\u03b7\u03c1\u03c9\u03bd",
-	            "\u03b5\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03b7\u03c3", "\u03b3\u03bb\u03c9\u03c3\u03c3\u03b1\u03c3" });
-	    // Verify the correct analysis of small letters with diaeresis and the elimination
-	    // of punctuation marks
-	    assertAnalyzesToReuse(a, "\u03a0\u03c1\u03bf\u03ca\u03cc\u03bd\u03c4\u03b1 (\u03ba\u03b1\u03b9)     [\u03c0\u03bf\u03bb\u03bb\u03b1\u03c0\u03bb\u03ad\u03c2] -   \u0391\u039d\u0391\u0393\u039a\u0395\u03a3",
-	            new String[] { "\u03c0\u03c1\u03bf\u03b9\u03bf\u03bd\u03c4\u03b1", "\u03c0\u03bf\u03bb\u03bb\u03b1\u03c0\u03bb\u03b5\u03c3", "\u03b1\u03bd\u03b1\u03b3\u03ba\u03b5\u03c3" });
-	    // Verify the correct analysis of capital accented letters and capitalletters with diaeresis,
-	    // as well as the elimination of stop words
-	    assertAnalyzesToReuse(a, "\u03a0\u03a1\u039f\u03ab\u03a0\u039f\u0398\u0395\u03a3\u0395\u0399\u03a3  \u0386\u03c8\u03bf\u03b3\u03bf\u03c2, \u03bf \u03bc\u03b5\u03c3\u03c4\u03cc\u03c2 \u03ba\u03b1\u03b9 \u03bf\u03b9 \u03ac\u03bb\u03bb\u03bf\u03b9",
-	            new String[] { "\u03c0\u03c1\u03bf\u03c5\u03c0\u03bf\u03b8\u03b5\u03c3\u03b5\u03b9\u03c3", "\u03b1\u03c8\u03bf\u03b3\u03bf\u03c3", "\u03bc\u03b5\u03c3\u03c4\u03bf\u03c3", "\u03b1\u03bb\u03bb\u03bf\u03b9" });
-	}
+  public void testReusableTokenStream() throws Exception {
+    Analyzer a = new GreekAnalyzer(TEST_VERSION_CURRENT);
+    // Verify the correct analysis of capitals and small accented letters, and
+    // stemming
+    assertAnalyzesToReuse(a, "?ία εξαι?ε?ικά καλή και ?λο??ια ?ει?ά ?α?ακ?ή??ν ?η? ?λληνική? γλ???α?",
+        new String[] { "μια", "εξαι?ε?", "καλ", "?λο??", "?ει?", "?α?ακ?η?",
+        "ελληνικ", "γλ???" });
+    // Verify the correct analysis of small letters with diaeresis and the elimination
+    // of punctuation marks
+    assertAnalyzesToReuse(a, "??ο??ν?α (και)     [?ολλα?λέ?] - ??????Σ",
+        new String[] { "??οιον?", "?ολλα?λ", "αναγκ" });
+    // Verify the correct analysis of capital accented letters and capital letters with diaeresis,
+    // as well as the elimination of stop words
+    assertAnalyzesToReuse(a, "?Ρ?Ϋ????Σ??Σ  ??ογο?, ο με???? και οι άλλοι",
+        new String[] { "??ο??οθε?", "α?ογ", "με??", "αλλ" });
+  }
 	
 	/**
 	 * Greek Analyzer didn't call standardFilter, so no normalization of acronyms.
diff --git a/modules/analysis/common/src/test/org/apache/lucene/analysis/el/TestGreekStemmer.java b/modules/analysis/common/src/test/org/apache/lucene/analysis/el/TestGreekStemmer.java
new file mode 100644
index 0000000..1b95c29
--- /dev/null
+++ b/modules/analysis/common/src/test/org/apache/lucene/analysis/el/TestGreekStemmer.java
@@ -0,0 +1,508 @@
+package org.apache.lucene.analysis.el;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+
+public class TestGreekStemmer extends BaseTokenStreamTestCase {
+  Analyzer a = new GreekAnalyzer(TEST_VERSION_CURRENT);
+
+  public void testMasculineNouns() throws Exception {
+    // -ο?
+    checkOneTerm(a, "άνθ???ο?", "ανθ???");
+    checkOneTerm(a, "ανθ???ο?", "ανθ???");
+    checkOneTerm(a, "άνθ???ο", "ανθ???");
+    checkOneTerm(a, "άνθ???ε", "ανθ???");
+    checkOneTerm(a, "άνθ???οι", "ανθ???");
+    checkOneTerm(a, "ανθ????ν", "ανθ???");
+    checkOneTerm(a, "ανθ???ο??", "ανθ???");
+    checkOneTerm(a, "άνθ???οι", "ανθ???");
+    
+    // -η?
+    checkOneTerm(a, "?ελά?η?", "?ελα?");
+    checkOneTerm(a, "?ελά?η", "?ελα?");
+    checkOneTerm(a, "?ελά?ε?", "?ελα?");
+    checkOneTerm(a, "?ελα??ν", "?ελα?");
+    
+    // -α?/-ε?
+    checkOneTerm(a, "ελέ?αν?α?", "ελε?αν?");
+    checkOneTerm(a, "ελέ?αν?α", "ελε?αν?");
+    checkOneTerm(a, "ελέ?αν?ε?", "ελε?αν?");
+    checkOneTerm(a, "ελε?άν??ν", "ελε?αν?");
+    
+    // -α?/-αδε?
+    checkOneTerm(a, "μ?αμ?ά?", "μ?αμ?");
+    checkOneTerm(a, "μ?αμ?ά", "μ?αμ?");
+    checkOneTerm(a, "μ?αμ?άδε?", "μ?αμ?");
+    checkOneTerm(a, "μ?αμ?άδ?ν", "μ?αμ?");
+    
+    // -η?/-ηδε?
+    checkOneTerm(a, "μ?ακάλη?", "μ?ακαλ");
+    checkOneTerm(a, "μ?ακάλη", "μ?ακαλ");
+    checkOneTerm(a, "μ?ακάληδε?", "μ?ακαλ");
+    checkOneTerm(a, "μ?ακάληδ?ν", "μ?ακαλ");
+    
+    // -ε?
+    checkOneTerm(a, "κα?έ?", "κα?");
+    checkOneTerm(a, "κα?έ", "κα?");
+    checkOneTerm(a, "κα?έδε?", "κα?");
+    checkOneTerm(a, "κα?έδ?ν", "κα?");
+    
+    // -έα?/εί?
+    checkOneTerm(a, "γ?αμμα?έα?", "γ?αμμα?ε");
+    checkOneTerm(a, "γ?αμμα?έα", "γ?αμμα?ε");
+    // plural forms conflate w/ each other, not w/ the sing forms
+    checkOneTerm(a, "γ?αμμα?εί?", "γ?αμμα?");
+    checkOneTerm(a, "γ?αμμα?έ?ν", "γ?αμμα?");
+    
+    // -ο??/οι
+    checkOneTerm(a, "α???λο??", "α?ο?λ");
+    checkOneTerm(a, "α???λο?", "α?ο?λ");
+    checkOneTerm(a, "α???λοι", "α?ο?λ");
+    checkOneTerm(a, "α???λ?ν", "α?ο?λ");
+    
+    // -ο??/-ο?δε?
+    checkOneTerm(a, "?α??ο??", "?α??");
+    checkOneTerm(a, "?α??ο?", "?α??");
+    checkOneTerm(a, "?α??ο?δε?", "?α??");
+    checkOneTerm(a, "?α??ο?δ?ν", "?α??");
+    
+    // -η?/-ει?
+    checkOneTerm(a, "λά??η?", "λα??");
+    checkOneTerm(a, "λά??η", "λα??");
+    checkOneTerm(a, "λά??ει?", "λα??");
+    checkOneTerm(a, "λά??ε?ν", "λα??");
+    
+    // -??
+    checkOneTerm(a, "?έλεκ??", "?ελεκ");
+    checkOneTerm(a, "?έλεκ?", "?ελεκ");
+    checkOneTerm(a, "?ελέκει?", "?ελεκ");
+    checkOneTerm(a, "?ελέκε?ν", "?ελεκ");
+    
+    // -??
+    // note: nom./voc. doesn't conflate w/ the rest
+    checkOneTerm(a, "μέν???", "μεν???");
+    checkOneTerm(a, "μέν?ο?ο?", "μεν?ο?");
+    checkOneTerm(a, "μέν?ο?α", "μεν?ο?");
+    checkOneTerm(a, "μέν?ο?ε?", "μεν?ο?");
+    checkOneTerm(a, "μεν????ν", "μεν?ο?");
+    
+    // -?ν
+    checkOneTerm(a, "αγ?να?", "αγ?ν");
+    checkOneTerm(a, "αγ?νο?", "αγ?ν");
+    checkOneTerm(a, "αγ?να", "αγ?ν");
+    checkOneTerm(a, "αγ?να", "αγ?ν");
+    checkOneTerm(a, "αγ?νε?", "αγ?ν");
+    checkOneTerm(a, "αγ?ν?ν", "αγ?ν");
+    
+    // -α?/-ηδε?
+    checkOneTerm(a, "αέ?α?", "αε?");
+    checkOneTerm(a, "αέ?α", "αε?");
+    checkOneTerm(a, "αέ?ηδε?", "αε?");
+    checkOneTerm(a, "αέ?ηδ?ν", "αε?");
+    
+    // -η?/-η?ε?
+    checkOneTerm(a, "γ?η?", "γο");
+    checkOneTerm(a, "γ?η", "γοη"); // too short
+    // the two plural forms conflate
+    checkOneTerm(a, "γ?η?ε?", "γοη?");
+    checkOneTerm(a, "γοή??ν", "γοη?");
+  }
+  
+  public void testFeminineNouns() throws Exception {
+    // -α/-ε?,-?ν
+    checkOneTerm(a, "?ο?ά", "?ο?");
+    checkOneTerm(a, "?ο?ά?", "?ο?");
+    checkOneTerm(a, "?ο?έ?", "?ο?");
+    checkOneTerm(a, "?ο??ν", "?ο?");
+    
+    // -α/-ε?,-?ν
+    checkOneTerm(a, "αγελάδα", "αγελαδ");
+    checkOneTerm(a, "αγελάδα?", "αγελαδ");
+    checkOneTerm(a, "αγελάδε?", "αγελαδ");
+    checkOneTerm(a, "αγελάδ?ν", "αγελαδ");
+    
+    // -η/-ε?
+    checkOneTerm(a, "ζά?α?η", "ζα?α?");
+    checkOneTerm(a, "ζά?α?η?", "ζα?α?");
+    checkOneTerm(a, "ζά?α?ε?", "ζα?α?");
+    checkOneTerm(a, "ζα?ά?ε?ν", "ζα?α?");
+    
+    // -η/-ει?
+    checkOneTerm(a, "?ηλε??α?η", "?ηλεο?α?");
+    checkOneTerm(a, "?ηλε??α?η?", "?ηλεο?α?");
+    checkOneTerm(a, "?ηλεο?ά?ει?", "?ηλεο?α?");
+    checkOneTerm(a, "?ηλεο?ά?ε?ν", "?ηλεο?α?");
+    
+    // -α/-αδε?
+    checkOneTerm(a, "μαμά", "μαμ");
+    checkOneTerm(a, "μαμά?", "μαμ");
+    checkOneTerm(a, "μαμάδε?", "μαμ");
+    checkOneTerm(a, "μαμάδ?ν", "μαμ");
+    
+    // -ο?
+    checkOneTerm(a, "λε????ο?", "λε??ο?");
+    checkOneTerm(a, "λε????ο?", "λε??ο?");
+    checkOneTerm(a, "λε????ο", "λε??ο?");
+    checkOneTerm(a, "λε????ε", "λε??ο?");
+    checkOneTerm(a, "λε????οι", "λε??ο?");
+    checkOneTerm(a, "λε?????ν", "λε??ο?");
+    checkOneTerm(a, "λε????ο??", "λε??ο?");
+    
+    // -ο?
+    checkOneTerm(a, "αλε?ο?", "αλε?");
+    checkOneTerm(a, "αλε?ο??", "αλε?");
+    checkOneTerm(a, "αλε?ο?δε?", "αλε?");
+    checkOneTerm(a, "αλε?ο?δ?ν", "αλε?");
+    
+    // -έα?/εί?
+    // note: not all forms conflate
+    checkOneTerm(a, "γ?αμμα?έα?", "γ?αμμα?ε");
+    checkOneTerm(a, "γ?αμμα?έ??", "γ?αμμα?");
+    checkOneTerm(a, "γ?αμμα?έα", "γ?αμμα?ε");
+    checkOneTerm(a, "γ?αμμα?εί?", "γ?αμμα?");
+    checkOneTerm(a, "γ?αμμα?έ?ν", "γ?αμμα?");
+  }
+  
+  public void testNeuterNouns() throws Exception {
+    // ending with -ο
+    // note: nom doesnt conflate
+    checkOneTerm(a, "βιβλίο", "βιβλι");
+    checkOneTerm(a, "βιβλίο?", "βιβλ");
+    checkOneTerm(a, "βιβλία", "βιβλ");
+    checkOneTerm(a, "βιβλί?ν", "βιβλ");
+    
+    // ending with -ι
+    checkOneTerm(a, "?ο?λί", "?ο?λ");
+    checkOneTerm(a, "?ο?λιο?", "?ο?λ");
+    checkOneTerm(a, "?ο?λιά", "?ο?λ");
+    checkOneTerm(a, "?ο?λι?ν", "?ο?λ");
+    
+    // ending with -α
+    // note: nom. doesnt conflate
+    checkOneTerm(a, "???βλημα", "??οβλημ");
+    checkOneTerm(a, "??οβλήμα?ο?", "??οβλημα");
+    checkOneTerm(a, "??οβλήμα?α", "??οβλημα");
+    checkOneTerm(a, "??οβλημά??ν", "??οβλημα");
+    
+    // ending with -ο?/-ο??
+    checkOneTerm(a, "?έλαγο?", "?ελαγ");
+    checkOneTerm(a, "?ελάγο??", "?ελαγ");
+    checkOneTerm(a, "?ελάγη", "?ελαγ");
+    checkOneTerm(a, "?ελάγ?ν", "?ελαγ");
+    
+    // ending with -??/-??ο?
+    checkOneTerm(a, "γεγον??", "γεγον");
+    checkOneTerm(a, "γεγον??ο?", "γεγον");
+    checkOneTerm(a, "γεγον??α", "γεγον");
+    checkOneTerm(a, "γεγον???ν", "γεγον");
+    
+    // ending with -?/-ιο?
+    checkOneTerm(a, "β?άδ?", "β?αδ");
+    checkOneTerm(a, "β?άδι", "β?αδ");
+    checkOneTerm(a, "β?αδιο?", "β?αδ");
+    checkOneTerm(a, "β?άδια", "β?αδ");
+    checkOneTerm(a, "β?αδι?ν", "β?αδ");
+    
+    // ending with -?/-α?ο?
+    // note: nom. doesnt conflate
+    checkOneTerm(a, "δ???", "δο?");
+    checkOneTerm(a, "δ??α?ο?", "δο?α?");
+    checkOneTerm(a, "δ??α?α", "δο?α?");
+    checkOneTerm(a, "δο?ά??ν", "δο?α?");
+    
+    // ending with -α?
+    checkOneTerm(a, "κ?έα?", "κ?ε");
+    checkOneTerm(a, "κ?έα?ο?", "κ?ε");
+    checkOneTerm(a, "κ?έα?α", "κ?ε");
+    checkOneTerm(a, "κ?εά??ν", "κ?ε");
+    
+    // ending with -??
+    checkOneTerm(a, "λ?κ????", "λ?κο??");
+    checkOneTerm(a, "λ?κ????ο?", "λ?κο??");
+    checkOneTerm(a, "λ?κ????α", "λ?κο??");
+    checkOneTerm(a, "λ?κο????ν", "λ?κο??");
+    
+    // ending with -ον/-ο?
+    // note: nom. doesnt conflate
+    checkOneTerm(a, "μέ?ον", "με?ον");
+    checkOneTerm(a, "μέ?ο?", "με?");
+    checkOneTerm(a, "μέ?α", "με?");
+    checkOneTerm(a, "μέ??ν", "με?");
+    
+    // ending in -ον/-ον?ο?
+    // note: nom. doesnt conflate
+    checkOneTerm(a, "ενδια?έ?ον", "ενδια?ε?ον");
+    checkOneTerm(a, "ενδια?έ?ον?ο?", "ενδια?ε?ον?");
+    checkOneTerm(a, "ενδια?έ?ον?α", "ενδια?ε?ον?");
+    checkOneTerm(a, "ενδια?ε??ν??ν", "ενδια?ε?ον?");
+    
+    // ending with -εν/-εν?ο?
+    checkOneTerm(a, "ανακοιν?θέν", "ανακοιν?θεν");
+    checkOneTerm(a, "ανακοιν?θέν?ο?", "ανακοιν?θεν?");
+    checkOneTerm(a, "ανακοιν?θέν?α", "ανακοιν?θεν?");
+    checkOneTerm(a, "ανακοιν?θέν??ν", "ανακοιν?θεν?");
+    
+    // ending with -αν/-αν?ο?
+    checkOneTerm(a, "??μ?αν", "??μ?");
+    checkOneTerm(a, "??μ?αν?ο?", "??μ?αν?");
+    checkOneTerm(a, "??μ?αν?α", "??μ?αν?");
+    checkOneTerm(a, "??μ?άν??ν", "??μ?αν?");
+    
+    // ending with  -α/-ακ?ο?
+    checkOneTerm(a, "γάλα", "γαλ");
+    checkOneTerm(a, "γάλακ?ο?", "γαλακ?");
+    checkOneTerm(a, "γάλα?α", "γαλα?");
+    checkOneTerm(a, "γαλάκ??ν", "γαλακ?");
+  }
+  
+  public void testAdjectives() throws Exception {
+    // ending with -ή?, -έ?/-εί?, -ή
+    checkOneTerm(a, "??νε?ή?", "??νε?");
+    checkOneTerm(a, "??νε?ο??", "??νε?");
+    checkOneTerm(a, "??νε?ή", "??νε?");
+    checkOneTerm(a, "??νε??ν", "??νε?");
+    checkOneTerm(a, "??νε?εί?", "??νε?");
+    checkOneTerm(a, "??νε?έ?", "??νε?");
+    
+    // ending with -η?, -ε?/-ει?, -η
+    checkOneTerm(a, "??νήθη?", "??νηθ");
+    checkOneTerm(a, "??νήθο??", "??νηθ");
+    checkOneTerm(a, "??νήθη", "??νηθ");
+    // note: doesn't conflate
+    checkOneTerm(a, "??νήθει?", "??ν");
+    checkOneTerm(a, "??νήθ?ν", "??νηθ");
+    checkOneTerm(a, "??νηθε?", "??νηθ");
+    
+    // ending with -??, -?/-ει?, -ια
+    checkOneTerm(a, "βαθ??", "βαθ");
+    checkOneTerm(a, "βαθέο?", "βαθε");
+    checkOneTerm(a, "βαθ?", "βαθ");
+    checkOneTerm(a, "βαθεί?", "βαθ");
+    checkOneTerm(a, "βαθέ?ν", "βαθ");
+    
+    checkOneTerm(a, "βαθιά", "βαθ");
+    checkOneTerm(a, "βαθιά?", "βαθι");
+    checkOneTerm(a, "βαθιέ?", "βαθι");
+    checkOneTerm(a, "βαθι?ν", "βαθ");
+    
+    checkOneTerm(a, "βαθέα", "βαθε");
+    
+    // comparative/superlative
+    checkOneTerm(a, "?ηλ??", "?ηλ");
+    checkOneTerm(a, "?ηλ??ε?ο?", "?ηλ");
+    checkOneTerm(a, "?ηλ??α?ο?", "?ηλ");
+    
+    checkOneTerm(a, "??αίο?", "??αι");
+    checkOneTerm(a, "??αι??ε?ο?", "??αι");
+    checkOneTerm(a, "??αι??α?ο?", "??αι");
+    
+    checkOneTerm(a, "ε?ιεική?", "ε?ιεικ");
+    checkOneTerm(a, "ε?ιεικέ??ε?ο?", "ε?ιεικ");
+    checkOneTerm(a, "ε?ιεικέ??α?ο?", "ε?ιεικ");
+  }
+  
+
+  public void testVerbs() throws Exception {
+    // note, past/present verb stems will not conflate (from the paper)
+    //-?,-α/-.?,-.α
+    checkOneTerm(a, "ο?ίζ?", "ο?ιζ");
+    checkOneTerm(a, "??ιζα", "ο?ιζ");
+    checkOneTerm(a, "??ιζε", "ο?ιζ");
+    checkOneTerm(a, "ο?ίζον?α?", "ο?ιζ");
+    checkOneTerm(a, "ο?ίζομαι", "ο?ιζ");
+    checkOneTerm(a, "ο?ιζ?μο?ν", "ο?ιζ");
+    checkOneTerm(a, "ο?ίζε?αι", "ο?ιζ");
+    
+    checkOneTerm(a, "??ι?α", "ο?ι?");
+    checkOneTerm(a, "ο?ί??", "ο?ι?");
+    checkOneTerm(a, "??ι?ε", "ο?ι?");
+    checkOneTerm(a, "ο?ί?ει", "ο?ι?");
+    
+    checkOneTerm(a, "ο?ί??ηκα", "ο?ι??");
+    checkOneTerm(a, "ο?ι???", "ο?ι??");
+    checkOneTerm(a, "ο?ι??εί?", "ο?ι??");
+    checkOneTerm(a, "ο?ι??εί", "ο?ι??");
+    
+    checkOneTerm(a, "ο?ι?μένο", "ο?ι?μεν");
+    checkOneTerm(a, "ο?ι?μένη", "ο?ι?μεν");
+    checkOneTerm(a, "ο?ι?μένο?", "ο?ι?μεν");
+    
+    // -?,-α/-ξ?,-ξα
+    checkOneTerm(a, "ανοίγ?", "ανοιγ");
+    checkOneTerm(a, "άνοιγα", "ανοιγ");
+    checkOneTerm(a, "άνοιγε", "ανοιγ");
+    checkOneTerm(a, "ανοίγον?α?", "ανοιγ");
+    checkOneTerm(a, "ανοίγομαι", "ανοιγ");
+    checkOneTerm(a, "ανοιγ?μο?ν", "ανοιγ");
+    
+    checkOneTerm(a, "άνοιξα", "ανοιξ");
+    checkOneTerm(a, "ανοίξ?", "ανοιξ");
+    checkOneTerm(a, "άνοιξε", "ανοιξ");
+    checkOneTerm(a, "ανοίξει", "ανοιξ");
+    
+    checkOneTerm(a, "ανοί??ηκα", "ανοι??");
+    checkOneTerm(a, "ανοι???", "ανοι??");
+    checkOneTerm(a, "ανοί??ηκα", "ανοι??");
+    checkOneTerm(a, "ανοι??εί?", "ανοι??");
+    checkOneTerm(a, "ανοι??εί", "ανοι??");
+    
+    checkOneTerm(a, "ανοίξο?", "ανοιξ");
+    
+    //-?/-ά?,-ο??α/-ά??,-α?α
+    checkOneTerm(a, "?ε?ν?", "?ε?ν");
+    checkOneTerm(a, "?ε?νά?", "?ε?ν");
+    checkOneTerm(a, "?ε?νο??α", "?ε?ν");
+    checkOneTerm(a, "?έ?ναγα", "?ε?ν");
+    checkOneTerm(a, "?έ?να", "?ε?ν");
+    checkOneTerm(a, "?ε?ν?ν?α?", "?ε?ν");
+    
+    checkOneTerm(a, "?έ?α?α", "?ε?α?");
+    checkOneTerm(a, "?ε?ά??", "?ε?α?");
+    checkOneTerm(a, "?έ?α?ε", "?ε?α?");
+    checkOneTerm(a, "?ε?ά?ει", "?ε?α?");
+    
+    checkOneTerm(a, "?ε?νιέμαι", "?ε?ν");
+    checkOneTerm(a, "?ε?νι?μο?ν", "?ε?ν");
+   
+    checkOneTerm(a, "?ε?ά??ηκα", "?ε?α??");
+    checkOneTerm(a, "?ε?α???", "?ε?α??");
+    checkOneTerm(a, "?ε?α??εί?", "?ε?α??");
+    checkOneTerm(a, "?ε?α??εί", "?ε?α??");
+
+    checkOneTerm(a, "?ε?α?μένο", "?ε?α?μεν");
+    checkOneTerm(a, "?ε?α?μένη", "?ε?α?μεν");
+    checkOneTerm(a, "?ε?α?μένο?", "?ε?α?μεν");
+    
+    // -?/-ά?,-ο??α/-άξ?,-αξα
+    checkOneTerm(a, "?ε??", "?ε?");
+    checkOneTerm(a, "?ε?ά?", "?ε?");
+    checkOneTerm(a, "?ε?ο??α", "?ε?");
+    checkOneTerm(a, "?έ?αγα", "?ε?");
+    checkOneTerm(a, "?έ?α", "?ε?");
+    checkOneTerm(a, "?ε??ν?α?", "?ε?");
+    checkOneTerm(a, "?ε?ιέμαι", "?ε?");
+    checkOneTerm(a, "?ε?ι?μο?ν", "?ε?");
+    
+    checkOneTerm(a, "?έ?αξα", "?ε?αξ");
+    checkOneTerm(a, "?ε?άξ?", "?ε?αξ");
+    checkOneTerm(a, "?έ?αξε", "?ε?αξ");
+    checkOneTerm(a, "?ε?άξει", "?ε?αξ");
+
+    checkOneTerm(a, "?ε?ά??ηκα", "?ε?α??");
+    checkOneTerm(a, "?ε?α???", "?ε?α??");
+    checkOneTerm(a, "?ε?α??εί?", "?ε?α??");
+    checkOneTerm(a, "?ε?α??εί", "?ε?α??");
+    
+    checkOneTerm(a, "?ε?αμένο", "?ε?αμεν");
+    checkOneTerm(a, "?ε?αμένη", "?ε?αμεν");
+    checkOneTerm(a, "?ε?αμένο?", "?ε?αμεν");
+    
+    // -?/-ά?,-ο??α / -έ??,-ε?α
+    checkOneTerm(a, "καλ?", "καλ");
+    checkOneTerm(a, "καλο??α", "καλ");
+    checkOneTerm(a, "καλεί?", "καλ");
+    checkOneTerm(a, "καλ?ν?α?", "καλ");
+    
+    checkOneTerm(a, "καλο?μαι", "καλ");
+    // pass. imperfect /imp. progressive doesnt conflate
+    checkOneTerm(a, "καλο?μο?ν", "καλο?μ");
+    checkOneTerm(a, "καλεί?αι", "καλει?α");
+    
+    checkOneTerm(a, "καλέ??ηκα", "καλε??");
+    checkOneTerm(a, "καλε???", "καλε??");
+    checkOneTerm(a, "καλε??εί?", "καλε??");
+    checkOneTerm(a, "καλε??εί", "καλε??");
+    
+    checkOneTerm(a, "καλε?μένο", "καλε?μεν");
+    checkOneTerm(a, "καλε?μένη", "καλε?μεν");
+    checkOneTerm(a, "καλε?μένο?", "καλε?μεν");
+    
+    checkOneTerm(a, "?ο??", "?ο?");
+    checkOneTerm(a, "?ο?ά?", "?ο?");
+    checkOneTerm(a, "?ο?ο??α", "?ο?");
+    checkOneTerm(a, "???αγα", "?ο?");
+    checkOneTerm(a, "???α", "?ο?");
+    checkOneTerm(a, "?ο??ν?α?", "?ο?");
+    checkOneTerm(a, "?ο?ιέμαι", "?ο?");
+    checkOneTerm(a, "?ο?ι?μο?ν", "?ο?");
+    checkOneTerm(a, "?ο?ιέ?αι", "?ο?");
+    
+    checkOneTerm(a, "???ε?α", "?ο?ε?");
+    checkOneTerm(a, "?ο?έ??", "?ο?ε?");
+    checkOneTerm(a, "???ε?ε", "?ο?ε?");
+    checkOneTerm(a, "?ο?έ?ει", "?ο?ε?");
+    
+    checkOneTerm(a, "?ο?έθηκα", "?ο?εθ");
+    checkOneTerm(a, "?ο?εθ?", "?ο?εθ");
+    checkOneTerm(a, "?ο?εθεί?", "?ο?εθ");
+    checkOneTerm(a, "?ο?εθεί", "?ο?εθ");
+    
+    checkOneTerm(a, "?ο?εμένο", "?ο?εμεν");
+    checkOneTerm(a, "?ο?εμένη", "?ο?εμεν");
+    checkOneTerm(a, "?ο?εμένο?", "?ο?εμεν");
+    
+    // -?/-ά?,-ο??α / -ή??,-η?α
+    checkOneTerm(a, "κ?α??", "κ?α?");
+    checkOneTerm(a, "κ?α?ά?", "κ?α?");
+    checkOneTerm(a, "κ?α?ο??α", "κ?α?");
+    checkOneTerm(a, "κ?ά?αγα", "κ?α?");
+    checkOneTerm(a, "κ?ά?α", "κ?α?");
+    checkOneTerm(a, "κ?α??ν?α?", "κ?α?");
+    
+    checkOneTerm(a, "κ?ά?η?α", "κ?α?");
+    checkOneTerm(a, "κ?α?ή??", "κ?α?");
+    checkOneTerm(a, "κ?ά?η?ε", "κ?α?");
+    checkOneTerm(a, "κ?α?ή?ει", "κ?α?");
+    
+    checkOneTerm(a, "κ?α?ο?μαι", "κ?α?");
+    checkOneTerm(a, "κ?α?ιέμαι", "κ?α?");
+    // this imperfect form doesnt conflate 
+    checkOneTerm(a, "κ?α?ο?μο?ν", "κ?α?ο?μ");
+    checkOneTerm(a, "κ?α?ι?μο?ν", "κ?α?");
+    // this imp. prog form doesnt conflate
+    checkOneTerm(a, "κ?α?εί?αι", "κ?α?ει?α");
+
+    checkOneTerm(a, "κ?α?ήθηκα", "κ?α?");
+    checkOneTerm(a, "κ?α?ηθ?", "κ?α?");
+    checkOneTerm(a, "κ?α?ηθεί?", "κ?α?");
+    checkOneTerm(a, "κ?α?ηθεί", "κ?α?");
+    checkOneTerm(a, "κ?α?ή?ο?", "κ?α?");
+    
+    checkOneTerm(a, "κ?α?ημένο", "κ?α?ημεν");
+    checkOneTerm(a, "κ?α?ημένη", "κ?α?ημεν");
+    checkOneTerm(a, "κ?α?ημένο?", "κ?α?ημεν");
+    
+    // -.μαι,-.μο?ν / -.?,-.ηκα
+    checkOneTerm(a, "κοιμάμαι", "κοιμ");
+    checkOneTerm(a, "κοιμ?μο?ν", "κοιμ");
+    checkOneTerm(a, "κοιμά?αι", "κοιμ");
+    
+    checkOneTerm(a, "κοιμήθηκα", "κοιμ");
+    checkOneTerm(a, "κοιμηθ?", "κοιμ");
+    checkOneTerm(a, "κοιμή?ο?", "κοιμ");
+    checkOneTerm(a, "κοιμηθεί", "κοιμ");
+    
+    checkOneTerm(a, "κοιμι?μένο", "κοιμι?μεν");
+    checkOneTerm(a, "κοιμι?μένη", "κοιμι?μεν");
+    checkOneTerm(a, "κοιμι?μένο?", "κοιμι?μεν");
+  }
+  
+  public void testExceptions() throws Exception {
+    checkOneTerm(a, "καθε????α", "καθε??");
+    checkOneTerm(a, "καθε????ο?", "καθε??");
+    checkOneTerm(a, "καθε????", "καθε??");
+    checkOneTerm(a, "καθε?????ν", "καθε??");
+    
+    checkOneTerm(a, "?ο?με", "?ο?μ");
+    checkOneTerm(a, "?ο?μ", "?ο?μ");
+    
+    checkOneTerm(a, "??ο?αγε?", "??ο?αγ");
+    checkOneTerm(a, "??ο?αγ", "??ο?αγ");
+    
+    checkOneTerm(a, "εμε?ε", "εμε?");
+    checkOneTerm(a, "εμε?", "εμε?");
+    
+    checkOneTerm(a, "α??ον?α?", "α??ον?");
+    checkOneTerm(a, "α??ον??ν", "α??ον?");
+  }
+}
diff --git a/solr/src/java/org/apache/solr/analysis/GreekLowerCaseFilterFactory.java b/solr/src/java/org/apache/solr/analysis/GreekLowerCaseFilterFactory.java
index 61fc2c0..c9dd410 100644
--- a/solr/src/java/org/apache/solr/analysis/GreekLowerCaseFilterFactory.java
+++ b/solr/src/java/org/apache/solr/analysis/GreekLowerCaseFilterFactory.java
@@ -33,6 +33,7 @@ public class GreekLowerCaseFilterFactory extends BaseTokenFilterFactory
   @Override
   public void init(Map<String, String> args) {
     super.init(args);
+    assureMatchVersion();
     if (args.containsKey("charset"))
       throw new SolrException(ErrorCode.SERVER_ERROR,
           "The charset parameter is no longer supported.  "
diff --git a/solr/src/java/org/apache/solr/analysis/GreekStemFilterFactory.java b/solr/src/java/org/apache/solr/analysis/GreekStemFilterFactory.java
new file mode 100644
index 0000000..2c6f005
--- /dev/null
+++ b/solr/src/java/org/apache/solr/analysis/GreekStemFilterFactory.java
@@ -0,0 +1,30 @@
+package org.apache.solr.analysis;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.el.GreekStemFilter;
+
+/** Factory for {@link GreekStemFilter} */
+public class GreekStemFilterFactory extends BaseTokenFilterFactory {
+
+  public TokenStream create(TokenStream input) {
+    return new GreekStemFilter(input);
+  }
+
+}
diff --git a/solr/src/test/org/apache/solr/analysis/TestGreekLowerCaseFilterFactory.java b/solr/src/test/org/apache/solr/analysis/TestGreekLowerCaseFilterFactory.java
index f697020..929204e 100644
--- a/solr/src/test/org/apache/solr/analysis/TestGreekLowerCaseFilterFactory.java
+++ b/solr/src/test/org/apache/solr/analysis/TestGreekLowerCaseFilterFactory.java
@@ -31,10 +31,11 @@ public class TestGreekLowerCaseFilterFactory extends BaseTokenTestCase {
   /**
    * Ensure the filter actually lowercases (and a bit more) greek text.
    */
-  public void testStemming() throws Exception {
+  public void testNormalization() throws Exception {
     Reader reader = new StringReader("?ά?ο? ??Ϊ?Σ");
     Tokenizer tokenizer = new WhitespaceTokenizer(DEFAULT_VERSION, reader);
     GreekLowerCaseFilterFactory factory = new GreekLowerCaseFilterFactory();
+    factory.init(DEFAULT_VERSION_PARAM);
     TokenStream stream = factory.create(tokenizer);
     assertTokenStreamContents(stream, new String[] { "μαιο?", "μαιο?" });
   }
diff --git a/solr/src/test/org/apache/solr/analysis/TestGreekStemFilterFactory.java b/solr/src/test/org/apache/solr/analysis/TestGreekStemFilterFactory.java
new file mode 100644
index 0000000..c2ede0d
--- /dev/null
+++ b/solr/src/test/org/apache/solr/analysis/TestGreekStemFilterFactory.java
@@ -0,0 +1,40 @@
+package org.apache.solr.analysis;
+
+import java.io.Reader;
+import java.io.StringReader;
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.WhitespaceTokenizer;
+import org.apache.lucene.analysis.el.GreekLowerCaseFilter;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Simple tests to ensure the Greek stem filter factory is working.
+ */
+public class TestGreekStemFilterFactory extends BaseTokenTestCase {
+  public void testStemming() throws Exception {
+    Reader reader = new StringReader("άνθ???ο?");
+    Tokenizer tokenizer = new WhitespaceTokenizer(DEFAULT_VERSION, reader);
+    TokenStream normalized = new GreekLowerCaseFilter(DEFAULT_VERSION, tokenizer);
+    GreekStemFilterFactory factory = new GreekStemFilterFactory();
+    TokenStream stream = factory.create(normalized);
+    assertTokenStreamContents(stream, new String[] { "ανθ???" });
+  }
+}

